diff --git a/.github/stale.yml b/.github/stale.yml
new file mode 100644
index 000000000..d20444829
--- /dev/null
+++ b/.github/stale.yml
@@ -0,0 +1,21 @@
+# Number of days of inactivity before an issue becomes stale
+daysUntilStale: 7
+# Number of days of inactivity before a stale issue is closed
+daysUntilClose: 7
+# Issues with these labels will never be considered stale
+exemptLabels:
+  - bug
+  - enhancement
+  - feature
+  - documentation
+  - build stability
+# Label to use when marking an issue as stale
+staleLabel: stale
+# Comment to post when marking an issue as stale. Set to `false` to disable
+markComment: >
+  This issue has been automatically marked as stale because it has not had
+  activity in the last seven days. It will be closed if no further activity
+  occurs within the next seven days. Thank you for your contributions.
+# Comment to post when closing a stale issue. Set to `false` to disable
+closeComment: false
+unmarkComment: false
diff --git a/.gitignore b/.gitignore
index dbfe9eb43..0fdd65869 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,12 +2,11 @@
 local.properties
 *.keystore
 *.DS_Store
-proguard-project.txt
 
 # Gradle
-**/.gradle
-**/.settings
-**/build
+.gradle
+build
+jacoco.exec
 
 # gh-pages
 doc/**
@@ -19,24 +18,15 @@ docs/**/*
 *.swp
 *.swo
 
-# Intellij 
-*.ipr
+# sed
+*.bak
+
+# Intellij
 *.iml
+*.ipr
 *.iws
-**/.idea/.name
-**/.idea/compiler.xml
-**/.idea/copyright/profiles_settings.xml
-**/.idea/encodings.xml
-**/.idea/misc.xml
-**/.idea/modules.xml
-**/.idea/scopes/scope_settings.xml
-**/.idea/vcs.xml
-**/.idea/libraries
-**/.idea/workspace.xml
-**/.idea/tasks.xml
-**/.idea/gradle.xml
-**/.idea/dictionaries
-**/.idea/dataSources.ids
-**/.idea/datasources.xml
-**/.idea/uiDesigner.xml
+.idea/**
+!.idea/codeStyleSettings.xml
+!.idea/inspectionProfiles
+!.idea/inspectionProfiles/Project_Default.xml
 
diff --git a/.gitmodules b/.gitmodules
index 525eef67a..d9d405d51 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,12 +1,6 @@
-[submodule "third_party/volley/volley"]
-	path = third_party/volley/volley
-	url = https://android.googlesource.com/platform/frameworks/volley
 [submodule "third_party/disklrucache"]
 	path = third_party/disklrucache
 	url = https://github.com/sjudd/DiskLruCache.git
-[submodule "library/src/androidTest/resources/exif-orientation-examples"]
-	path = library/src/androidTest/resources/exif-orientation-examples
+[submodule "library/test/src/test/resources/exif-orientation-examples"]
+	path = library/test/src/test/resources/exif-orientation-examples
 	url = https://github.com/recurser/exif-orientation-examples.git
-[submodule "library/src/test/resources/exif-orientation-examples"]
-	path = library/src/test/resources/exif-orientation-examples
-	url = https://github.com/recurser/exif-orientation-examples
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index 536c52938..ebd90ff05 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -15,245 +15,17 @@
             <option name="USE_RELATIVE_INDENTS" value="false" />
           </value>
         </option>
-        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
-        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+        <option name="INSERT_INNER_CLASS_IMPORTS" value="true" />
+        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />
+        <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
+          <value />
+        </option>
         <option name="IMPORT_LAYOUT_TABLE">
           <value>
             <package name="" withSubpackages="true" static="true" />
             <emptyLine />
-            <package name="com.google" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="android" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="antenna" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="antlr" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ar" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="asposewobfuscated" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="asquare" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="atg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="au" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="beaver" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bibtex" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bmsi" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="bsh" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ccl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cern" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ChartDirector" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="checkers" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="com" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="COM" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="common" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="contribs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="corejava" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cryptix" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="cybervillains" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="dalvik" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="danbikel" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="de" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="EDU" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="eg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="eu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="examples" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fat" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fit" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fitlibrary" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="fmpp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="freemarker" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="gnu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovy" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovyjarjarantlr" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="groovyjarjarasm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="hak" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="hep" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ie" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="imageinfo" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="info" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="it" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jal" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="Jama" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="japa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="japacheckers" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jas" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jasmin" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javancss" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javanet" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javassist" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javazoom" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="java_cup" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jcifs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jetty" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="JFlex" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jj2000" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jline" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="JSci" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jsr166y" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="junit" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jxl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="jxxload_help" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="kawa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="kea" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="libcore" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="libsvm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="lti" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="memetic" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="mt" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="mx4j" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="net" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="netscape" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="nl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="nu" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="oauth" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ognl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="opennlp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="oracle" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="org" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="penn2dg" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="pennconverter" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="pl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="prefuse" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="proguard" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="repackage" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="scm" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="se" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="serp" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="simple" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="soot" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sqlj" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="src" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ssa" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sun" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="sunlabs" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="tcl" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testdata" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testshell" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="testsuite" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="twitter4j" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="uk" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="ViolinStrings" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="weka" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="wet" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="winstone" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="woolfel" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="wowza" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="java" withSubpackages="true" static="false" />
-            <emptyLine />
-            <package name="javax" withSubpackages="true" static="false" />
-            <emptyLine />
             <package name="" withSubpackages="true" static="false" />
-            <emptyLine />
-            <emptyLine />
           </value>
         </option>
         <option name="RIGHT_MARGIN" value="100" />
@@ -263,20 +35,13 @@
         <option name="JD_KEEP_EMPTY_RETURN" value="false" />
         <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
         <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
-        <option name="BLANK_LINES_AFTER_CLASS_HEADER" value="1" />
-        <option name="ALIGN_MULTILINE_PARAMETERS_IN_CALLS" value="true" />
-        <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="true" />
-        <option name="ALIGN_MULTILINE_ASSIGNMENT" value="true" />
-        <option name="ALIGN_MULTILINE_TERNARY_OPERATION" value="true" />
-        <option name="ALIGN_MULTILINE_THROWS_LIST" value="true" />
-        <option name="ALIGN_MULTILINE_EXTENDS_LIST" value="true" />
-        <option name="ALIGN_MULTILINE_PARENTHESIZED_EXPRESSION" value="true" />
-        <option name="ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION" value="true" />
+        <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="0" />
+        <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+        <option name="ALIGN_MULTILINE_FOR" value="false" />
+        <option name="SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE" value="true" />
         <option name="CALL_PARAMETERS_WRAP" value="1" />
         <option name="METHOD_PARAMETERS_WRAP" value="1" />
         <option name="EXTENDS_LIST_WRAP" value="1" />
-        <option name="THROWS_LIST_WRAP" value="1" />
-        <option name="EXTENDS_KEYWORD_WRAP" value="1" />
         <option name="THROWS_KEYWORD_WRAP" value="1" />
         <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
         <option name="BINARY_OPERATION_WRAP" value="1" />
@@ -285,37 +50,510 @@
         <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
         <option name="FOR_STATEMENT_WRAP" value="1" />
         <option name="ARRAY_INITIALIZER_WRAP" value="1" />
-        <option name="ASSIGNMENT_WRAP" value="5" />
         <option name="WRAP_COMMENTS" value="true" />
         <option name="IF_BRACE_FORCE" value="3" />
         <option name="DOWHILE_BRACE_FORCE" value="3" />
         <option name="WHILE_BRACE_FORCE" value="3" />
         <option name="FOR_BRACE_FORCE" value="3" />
+        <AndroidXmlCodeStyleSettings>
+          <option name="USE_CUSTOM_SETTINGS" value="true" />
+          <option name="LAYOUT_SETTINGS">
+            <value>
+              <option name="INSERT_BLANK_LINE_BEFORE_TAG" value="false" />
+            </value>
+          </option>
+        </AndroidXmlCodeStyleSettings>
+        <JSCodeStyleSettings>
+          <option name="INDENT_CHAINED_CALLS" value="false" />
+        </JSCodeStyleSettings>
+        <JavaCodeStyleSettings>
+          <option name="DO_NOT_WRAP_AFTER_SINGLE_ANNOTATION" value="true" />
+        </JavaCodeStyleSettings>
+        <Python>
+          <option name="USE_CONTINUATION_INDENT_FOR_ARGUMENTS" value="true" />
+        </Python>
+        <TypeScriptCodeStyleSettings>
+          <option name="INDENT_CHAINED_CALLS" value="false" />
+        </TypeScriptCodeStyleSettings>
         <XML>
+          <option name="XML_ALIGN_ATTRIBUTES" value="false" />
           <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
         </XML>
-        <ADDITIONAL_INDENT_OPTIONS fileType="haml">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="java">
-          <option name="INDENT_SIZE" value="2" />
-          <option name="CONTINUATION_INDENT_SIZE" value="4" />
-          <option name="TAB_SIZE" value="8" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="js">
-          <option name="CONTINUATION_INDENT_SIZE" value="4" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="sass">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
-        <ADDITIONAL_INDENT_OPTIONS fileType="yml">
-          <option name="INDENT_SIZE" value="2" />
-        </ADDITIONAL_INDENT_OPTIONS>
+        <codeStyleSettings language="CSS">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="ECMA Script Level 4">
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="EXTENDS_LIST_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+        </codeStyleSettings>
+        <codeStyleSettings language="HTML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
         <codeStyleSettings language="JAVA">
+          <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_RESOURCES" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="EXTENDS_LIST_WRAP" value="1" />
+          <option name="THROWS_KEYWORD_WRAP" value="1" />
+          <option name="METHOD_CALL_CHAIN_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="KEEP_SIMPLE_BLOCKS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_METHODS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_LAMBDAS_IN_ONE_LINE" value="true" />
+          <option name="KEEP_SIMPLE_CLASSES_IN_ONE_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JSON">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="JavaScript">
+          <option name="RIGHT_MARGIN" value="80" />
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
           <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="ALIGN_MULTILINE_FOR" value="false" />
+          <option name="CALL_PARAMETERS_WRAP" value="1" />
+          <option name="METHOD_PARAMETERS_WRAP" value="1" />
+          <option name="BINARY_OPERATION_WRAP" value="1" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="TERNARY_OPERATION_WRAP" value="1" />
+          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ARRAY_INITIALIZER_WRAP" value="1" />
+          <option name="IF_BRACE_FORCE" value="3" />
+          <option name="DOWHILE_BRACE_FORCE" value="3" />
+          <option name="WHILE_BRACE_FORCE" value="3" />
+          <option name="FOR_BRACE_FORCE" value="3" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="ObjectiveC">
+          <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="1" />
+          <option name="BLANK_LINES_BEFORE_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AFTER_IMPORTS" value="0" />
+          <option name="BLANK_LINES_AROUND_CLASS" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD" value="0" />
+          <option name="BLANK_LINES_AROUND_METHOD_IN_INTERFACE" value="0" />
+          <option name="ALIGN_MULTILINE_BINARY_OPERATION" value="false" />
+          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />
+          <option name="FOR_STATEMENT_WRAP" value="1" />
+          <option name="ASSIGNMENT_WRAP" value="1" />
           <indentOptions>
             <option name="INDENT_SIZE" value="2" />
             <option name="CONTINUATION_INDENT_SIZE" value="4" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="PROTO">
+          <option name="RIGHT_MARGIN" value="80" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="Python">
+          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />
+          <option name="RIGHT_MARGIN" value="80" />
+          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+          <option name="PARENT_SETTINGS_INSTALLED" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="SASS">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="SCSS">
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="TypeScript">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="XML">
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+          <arrangement>
+            <rules>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:android</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:id</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:.*Style</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_width</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_height</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_weight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_margin</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_marginRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_.*</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:padding</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingTop</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingBottom</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingStart</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingEnd</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingLeft</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:paddingRight</NAME>
+                      <XML_ATTRIBUTE />
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res-auto</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/tools</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>.*</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+            </rules>
+          </arrangement>
+        </codeStyleSettings>
+        <codeStyleSettings language="protobuf">
+          <option name="RIGHT_MARGIN" value="80" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="2" />
             <option name="TAB_SIZE" value="2" />
           </indentOptions>
         </codeStyleSettings>
@@ -323,4 +561,4 @@
     </option>
     <option name="USE_PER_PROJECT_SETTINGS" value="true" />
   </component>
-</project>
\ No newline at end of file
+</project>
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
index 000000000..1c2b4c84f
--- /dev/null
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -0,0 +1,9 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0">
+    <option name="myName" value="Project Default" />
+    <inspection_tool class="SerializableHasSerialVersionUIDField" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="ignoreAnonymousInnerClasses" value="false" />
+      <option name="superClassString" value="" />
+    </inspection_tool>
+  </profile>
+</component>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index d7e468055..8e655e0f8 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,29 +1,48 @@
 language: android
+sudo: false
+dist: trusty
+
+before_install:
+  - mkdir "$ANDROID_HOME/licenses" || true
+  - echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55\nd56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+  - echo -e "\n84831b9409646a918e30573bab4c9c91346d8abd\n504667f4c0de7af1a06de9f4b1727b84351f2910" > "$ANDROID_HOME/licenses/android-sdk-preview-license"
+
 android:
   components:
-  - tools
-  - platform-tools
-  - build-tools-22.0.1
-  - android-22
-  - extra-android-m2repository
-  - extra-android-support
-
-  licenses:
-  - 'android-sdk-license.*'
+    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943
+    - tools
+    - tools
 
 jdk:
-  - openjdk7
-  - oraclejdk7
+  - oraclejdk8
 
-sudo: false
+env:
+  matrix:
+    - COMPONENT=unit
+    - COMPONENT=firebase
+    - COMPONENT=instrumentation ANDROID_TARGET=16
+    - COMPONENT=instrumentation ANDROID_TARGET=17
+    - COMPONENT=instrumentation ANDROID_TARGET=18
+    - COMPONENT=instrumentation ANDROID_TARGET=19
+    - COMPONENT=instrumentation ANDROID_TARGET=21
+    - COMPONENT=instrumentation ANDROID_TARGET=22
+    - COMPONENT=samples
+
+before_script:
+  - ./scripts/travis_before_script.sh
 
-script: 'travis_retry ./gradlew build --parallel'
+script:
+  - ./scripts/travis_script.sh
 
 after_success:
-- scripts/travis-sonatype-publish.sh
-- ./gradlew jacocoTestReport coveralls
+  - ./scripts/travis_after_success.sh
 
+before_cache:
+  - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock
+  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
 cache:
   directories:
-    - $HOME/.gradle/caches
+    - $HOME/.gradle/caches/
+    - $HOME/.gradle/wrapper/
+    - $HOME/.android/build-cache
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 000000000..7b49f092c
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,53 @@
+# Change Log
+
+## [v4.5.0](https://github.com/bumptech/glide/tree/HEAD)
+
+[Full Changelog](https://github.com/bumptech/glide/compare/v4.4.0...v4.5.0)
+
+## Features
+* Add an API to pause all requests for a given `Activity` or `Fragment` to allow callers to manually reduce memory when their Fragment or Application is backgrounded (@kurtisnelson, 09e33a2133eb1d4005b227439c0c53c9c4e8c89b) 
+* Fully support Bitmap re-use for `RGBA_F16` `Bitmap`s. Previously Glide supported decoding `RGBA_F16` `Bitmap`s, but would not re-use any stored in the `BitmapPool` when doing so (cc0288c3b4bfb82a109a3f279af52c57fc5e1499)
+* Support decoding Videos from resources as `AssetFileDescriptor`s (6e9866b5a19d06625006a9a8c605db21047df74b)
+* Added support for the [`MediaMetadataRetriever#getScaledFrameAtTime`][2] method added in OMR1 to marginally reduce memory usage when decoding video frames (ded8f77c9f2471e3c3413aa234656df8cf72dd2f)
+* Support transcoding `BitmapDrawable`s to `byte[]`s (015d2659a9ea7438ab72b94500a0921f8ff35aa3)
+
+## Bugs
+* Cleaned up old and incorrect `@TargetApi` annoatations (@SUPERCILEX, 67783961c71639871cc3687894976e6caeb6609e)
+* Added `@Nullable` and `@NonNull` annotations to many of Glide's APIs (@SUPERCILEX, dc12b60c8f0a21eb9b3ab2164471c93d2e20ae25, c3dafde00a061bafcd43a739336ca3503af13a7d, 0cffd1da977e9ca334032ebc1d798213a177aab7, f541b65e596a49d252ba6b80d3b05a111ce93461, 36e0b802c3a1e564caf230b351a6438fa32100ac, 650bb7770d08b279c2a7f00e25337618da54f7f3, bd2f21595d3404e6aadf1f4333bef369509c4a56, e35a73b4e78f2f05dc5c1163b8083ac1b662b02f, f37ced1512f7eabf37f6c93b1b7ffb32c3629b72, bb96b633174184965cd1bdf9027ef3843f59c54f, 276d4ff4bdce85763c985c90a87ea5e858a1ffe4, c3107801dab8ccbe121157bee7dba29b7d9723e6, )
+* Fixed a case where restarting an identical request with `skipMemoryCache(true)` would complete the load from the memory cache (#2663, 3dc1d18da75b44d8d97f4161fe0d330e4993e537)
+* Fixed decoding interlaced and downsampled GIFs as static images (#2698, b64f23de2a7ba38fceac1cda85f05158e80132f9)
+* Added more models to the list of devices requiring a lock when decoding or drawing Bitmaps (@strooooke, #738, c809f7ec03bbfc2c529f2c211cfc644c2073aab0, e923554b10fa9625f4fa6fe706f3d5a553843ab9)
+* Fixed a race condition where starting multiple loads simultaneously the first time any request is made for a given model and resource could lead to NPEs (#2708, d427cbd33206cbcc88ac4a0f0c29ef831d4bb5b5)
+* Make the annotation processor tests pass on Windows (@SUPERCILEX, #2709, 2b4be8b8c210abb34740f0778434679b644a6525)
+* Fix NPE and RuntimeExceptions thrown in `DefaultConnectivityMonitor` on some devices (c902730b75085cecdd40cd5817453d8af0eff4e9)
+* Only trim to half of the memory cache maximum size, not the current size, when background the app (@kurtisnelson, 429b7e2d9854da549eb0b852e2e08de176f05fbf)
+* Fix a `StateVerifier` exception thrown when `ResourceEncoder` implementations unexpectedly throw exceptions while writing resources to Glide's disk cache (6c7cf3f8cae998469a7e7df8c70c459311479a38)
+* Fix an NPE error message when `ResourceDrawableDecoder` fails to decode an image (d522ac7249ca1bf71f6de30e62d71a1faa8d4c4c)
+* Fix an `IllegalStateException` if a request using [`.error()`][3] is cleared while the error request is running (#2767, 9c70aa5f92f523c6bac29628554fdde5428e0cdd)
+* Cleaned up a number of accessor classes generated by unnecessarily strict visibility in inner classes (@TWiStErRob, e02969417a75048af0fcb61c5fbf6ea94bd2c4aa)
+* Updated OkHttp and removed a no longer necessary workaround for `ClassCastException`s thrown by the Android framework on O (#2355, 642b2dc431e54cb677088e934743d78f1ad84810)
+* Added missing annotations to overrides on some of Glide's generated classes (@TWiStErRob, 62d7464fb4f874897121591815ecb7503f7bc01b, 9fde00628f223e96372aeceadcb3e35a0635cb6d, d7bb6f956b34dd00ad0dbcb64f15f4b9c2fb0538)
+* Avoid throwing exceptions when `LruBitmapPool` was asked to provide `Bitmap`s with a `null` config (c1036c1cdc3c85827bf566e104a12ca880e26411)
+
+
+## Behavior Changes
+* Default to `aar` packaging in POMs, so `@aar` should no longer be required to avoid warnings about jars depending on aars (06ba3442fd8d25c943e986c2bd6c138aa4b390e3)
+* Default active resource retention to false (73759b9eb1d3b186c4deb6412137b0b1193fbd5d), but leave the option in `GlideBuilder` to manually enable it. Enabling active resource retention can lead to recycled `Bitmap` errors or `Bitmap` re-use bugs if applications call `Bitmap.recycle()` on any images loaded by Glide or mutate the contents of `Bitmap`s loaded by Glide. 
+* Treat devices with API < 19 as having `ActivityManager.isLowRam` set to `true` (#2650, b221d4bbec138efcdb1aabd07600b7df713f9e40)
+
+## Breaking Changes
+* Removed deprecated constructors requiring `Context`s in most of Glide's default `Transformation` (23975d933bcda7d136340b9988f2bd575065b667, 733b2e0f25a6d3ddbb4942172e92a9fe01c87363, 9bedc2b5fe5b1b2e05203af173c73f0e599a0177, 55594baf791ccb49dd5cdc256662360717b409bb, d8f6224d127b984c3ac1356d44f62126e4843d07, d840533448fd7bde528e0af7ce10c49653430c12, 2f76842b8ef9ac15c43a2c5175f23496b5a13f37, 144ac5374eb0bd11a8f8e92d7346dafac1426621, 150ebabbd7d5e8751c8678fa01418d1b1f1259da, 92d761d002da25320f2c504267f56d73b889b2d4, a6f1b1c1bef5b4e8be736c564792715266b07463) 
+
+## Deprecations
+* Deprecated [`VideoBitmapDecoder`][4], use [`VideoDecoder`][5] instead.
+
+## Build Changes
+* Glide must be compiled against API 27 (@SUPERCILEX, #2730, 75c2a8b6d216013e7fbf797231839a8f4c82757a)
+* Glide uses v27 of the support libraries (though v26 should work as well, to use v26 of the support library, see [Glide's Android SDK requirements docs page][1])
+* Updated to PMD 6.0.0 (@TWiStErRob, f16aef4c6ad583bafe796c7a952a0d10920c4dcd)
+* Fix a PMD failure when building with --profile or any other way in which class files didn't happen to have already been compiled (@TWiStErRob, #2776, fd73179166b15af246769c9b1ae205c65c584e5b)
+
+[1]: http://bumptech.github.io/glide/doc/download-setup.html#android-sdk-requirements
+[2]: https://developer.android.com/reference/android/media/MediaMetadataRetriever.html#getScaledFrameAtTime(long,%20int,%20int,%20int)
+[3]: http://bumptech.github.io/glide/javadocs/440/com/bumptech/glide/RequestBuilder.html#error-com.bumptech.glide.RequestBuilder-
+[4]: http://bumptech.github.io/glide/javadocs/450/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.html
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 5fc10cb16..d3fc25937 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,26 +1,48 @@
 # Contributing
-Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other
-aspects of the library (documentation, the wiki etc.)
+Contributions of all types are welcome.
+We use GitHub as our bug and feature tracker both for code and for other aspects of the library (documentation, the wiki, etc.).
+
 
 ## Asking Questions
-The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on
-freenode.org.][3]
+The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on freenode.org][3].
+
 
 ## Filing issues
-To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more
-information you can provide, the more likely we are to be able help.
+When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed.
+Similarly if you support a particular feature request, feel free to let us know by commenting on the issue or [subscribing][6] to the issue.
+
+To file a new issue, please use our issue template and fill out the template as much as possible (remove irrelevant parts).
+The more information you can provide, the more likely we are to be able help.
 
-When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if
-you support a particular feature request, feel free to let us know by commenting on the issue.
 
 ## Contributing code
-Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find
-instructions on building the project in our README. Our code style is defined in Intellij project files in the repo
-and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel
-free to put up your pull request anyway and we can help you fix the style issues. If you'd like to
-contribute code, you will need to sign [Google's individual contributor license agreement][4].
+Pull requests are welcome for all parts of the codebase, especially the integration libraries.
+You can find instructions on building the project in [README.md][5].
+Our code style is defined in Intellij project files in the repo and also by our Checkstyle config.
+If you'd like to submit code, but can't get the style checks to pass, feel free to put up your pull request anyway and we can help you fix the style issues.
+If you'd like to contribute code, you will need to sign [Google's individual contributor license agreement][4] which will be asked when you create the PR by [googlebot](https://github.com/googlebot) should you forget it.
+
+## Labels
+Labels on issues are managed by contributors, you don't have to worry about them. Here's a list of what they mean:
+
+ * **bug**: feature that should work, but doesn't
+ * **enhancement**: minor tweak/addition to existing behavior
+ * **feature**: new behavior, bigger than enhancement, it gives more bang to Glide
+ * **question**: no need to modify Glide to fix the issue, usually a usage problem
+ * **reproducible**: has enough information to very easily reproduce, mostly in form of a small project in a GitHub repo
+ * **repro-needed**: we need some code to be able to reproduce and debug locally, otherwise there's not much we can do
+ * **duplicate**: there's another issue which already covers/tracks this
+ * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons
+ * **invalid**: there isn't enough information to make a verdict, or unrelated to Glide
+ * **non-library**: issue is not in the core library code, but rather in documentation, samples, build process, releases
+ * **v4**: problem originated in v4, or question about v4 (while v3 is in wide use)
+
+*bug + enhancement: feature that doesn't work, but it's an edge case that either has a workaround or doesn't affect many users*
+
 
-[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version**%3A%0A**Integration%20libraries**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details%20/%20Repro%20steps%20/%20Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60
 [2]: https://groups.google.com/forum/#!forum/glidelibrary
 [3]: http://webchat.freenode.net/?channels=glide-library
-[4]: https://developers.google.com/open-source/cla/individual.
+[4]: https://developers.google.com/open-source/cla/individual
+[5]: https://github.com/bumptech/glide
+[6]: https://help.github.com/articles/subscribing-to-conversations/
diff --git a/ISSUE_TEMPLATE.md b/ISSUE_TEMPLATE.md
new file mode 100644
index 000000000..f76cfa70d
--- /dev/null
+++ b/ISSUE_TEMPLATE.md
@@ -0,0 +1,50 @@
+<!--
+Please fill in the below fields with some data to help us best diagnose the issue.
+The more specific you are, the better! You can help a lot by not making us ask these questions.
+Feel free to remove any irrelevant parts that you know are not related to the issue.
+Any HTML comment like this will be stripped when rendering markdown, no need to delete them.
+-->
+
+
+<!-- What version of Glide you're running, for example: 3.7.1 | 3.8.0-SNAPSHOT | 4.0.0-SNAPSHOT
+It's essentially the version number from your build.gradle: `dependencies { compile '...:x.y.z' }` -->
+**Glide Version**:
+
+<!-- Do you use any integration library, like OkHttp3 or Volley? For example:
+Fails to display with stock networking, but works with okhttp3-1.4.0 -->
+**Integration libraries**:
+
+<!-- What devices you managed to get the issue to come up on? For example:
+fails on Galaxy S4/GT-I9500 4.4.2, works fine on Nexus 6P 5.1 and Genymotion Nexus 5 5.0.1 -->
+**Device/Android Version**:
+
+<!-- Share the details of your issue in prose, detailing actual and expected behavior. It also helps if you give some info **why** you are trying to do something as opposed to **what** is not working. -->
+**Issue details / Repro steps / Use case background**: 
+
+<!-- How do you use Glide?
+Make sure you include everything as is in your app's code:
+Changing a single method parameter can yield totally different results.
+Please clarify any magic variables that appear in the code, for example: "// `this` is a Fragment"
+-->
+**Glide load line / `GlideModule` (if any) / list Adapter code (if any)**:
+```java
+Glide.with...
+```
+
+<!-- How does your app look like?
+We're most interested in the layout attributes and the hierarchy around the ImageView -->
+**Layout XML**:
+```xml
+<FrameLayout xmlns:android="...
+```
+
+<!--
+What is the error message that you got in the log?
+You can find some help on diagnosing issues here: https://github.com/bumptech/glide/wiki/Debugging-and-Error-Handling
+-->
+**Stack trace / LogCat**:
+```ruby
+paste stack trace and/or log here
+```
+
+<!-- Bonus points if you attach a relevant screenshot, screen recording or a small demo project -->
diff --git a/PULL_REQUEST_TEMPLATE.md b/PULL_REQUEST_TEMPLATE.md
new file mode 100644
index 000000000..3cd191bf1
--- /dev/null
+++ b/PULL_REQUEST_TEMPLATE.md
@@ -0,0 +1,14 @@
+<!-- Make sure you've run `gradlew clean check jar assemble` before commit. -->
+<!-- Don't forget that you can always force push to your private branches to make changes. -->
+<!-- Please make sure there are no weird commits in the change set by rebasing to latest upstream. -->
+<!-- Please squash typo/checkstyle/review fix commits into the base commit. -->
+
+## Description
+<!-- Please describe the changes you made on a high level. -->
+<!-- Make sure you reference the GitHub issue here if this change is related to one. -->
+
+## Motivation and Context
+<!-- Why is this change required? What problem does it solve? -->
+<!-- If it's fixing a bug reference it or provide repro steps. -->
+
+<!-- If you have any issues feel free to create the PR anyway, we'll help to resolve them. -->
\ No newline at end of file
diff --git a/README.md b/README.md
index 34bbbf0b3..f1445f0d3 100644
--- a/README.md
+++ b/README.md
@@ -1,15 +1,16 @@
 Glide
 =====
 
-[![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
+[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide) [![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
+| [View Glide's documentation][20] | [简体中文文档][22] | [Report an issue with Glide][5]
 
 Glide is a fast and efficient open source media management and image loading framework for Android that wraps media
 decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.
 
 ![](static/glide_logo.png)
 
-Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible api
-that allows developers to plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based
+Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible API
+that allows developers to plug in to almost any network stack. By default Glide uses a custom `HttpUrlConnection` based
 stack, but also includes utility libraries plug in to Google's Volley project or Square's OkHttp library instead.
 
 Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is
@@ -17,18 +18,21 @@ also effective for almost any case where you need to fetch, resize, and display
 
 Download
 --------
+For detailed instructions and requirements, see Glide's [download and setup docs page][28].
+
 You can download a jar from GitHub's [releases page][1].
 
 Or use Gradle:
 
-```groovy
+```gradle
 repositories {
   mavenCentral()
+  google()
 }
 
 dependencies {
-    compile 'com.github.bumptech.glide:glide:3.6.0'
-    compile 'com.android.support:support-v4:19.1.0'
+  implementation 'com.github.bumptech.glide:glide:4.6.1'
+  annotationProcessor 'com.github.bumptech.glide:compiler:4.6.1'
 }
 ```
 
@@ -38,131 +42,135 @@ Or Maven:
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>glide</artifactId>
-  <version>3.6.0</version>
-  <type>aar</type>
+  <version>4.6.1</version>
 </dependency>
 <dependency>
-  <groupId>com.google.android</groupId>
-  <artifactId>support-v4</artifactId>
-  <version>r7</version>
+  <groupId>com.github.bumptech.glide</groupId>
+  <artifactId>compiler</artifactId>
+  <version>4.6.1</version>
+  <optional>true</optional>
 </dependency>
 ```
 
-Proguard
+For info on using the bleeding edge, see the [Snapshots][17] docs page.
+
+ProGuard
 --------
-Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:
-```
+Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see the [Download and Setup docs page][25] for more details):
+
+```pro
 -keep public class * implements com.bumptech.glide.module.GlideModule
+-keep public class * extends com.bumptech.glide.module.AppGlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
-    **[] $VALUES;
-    public *;
+  **[] $VALUES;
+  public *;
 }
+
+# for DexGuard only
+-keepresourcexmlelements manifest/application/meta-data@value=GlideModule
 ```
 
 How do I use Glide?
 -------------------
-Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [javadocs][3].
+Check out the [documentation][20] for pages on a variety of topics, and see the [javadocs][3].
 
-Simple use cases will look something like this:
+For Glide v3, see the [wiki][2].
 
-```Java
+Simple use cases with Glide's [generated API][21] will look something like this:
 
+```java
 // For a simple view:
-@Override
-public void onCreate(Bundle savedInstanceState) {
-    ...
+@Override public void onCreate(Bundle savedInstanceState) {
+  ...
+  ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
 
-    ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
-
-    Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
+  GlideApp.with(this).load("http://goo.gl/gEgYUd").into(imageView);
 }
 
-// For a list:
-@Override
-public View getView(int position, View recycled, ViewGroup container) {
-    final ImageView myImageView;
-    if (recycled == null) {
-        myImageView = (ImageView) inflater.inflate(R.layout.my_image_view,
-                container, false);
-    } else {
-        myImageView = (ImageView) recycled;
-    }
-
-    String url = myUrls.get(position);
-
-    Glide.with(myFragment)
-        .load(url)
-        .centerCrop()
-        .placeholder(R.drawable.loading_spinner)
-        .crossFade()
-        .into(myImageView);
-
-    return myImageView;
+// For a simple image list:
+@Override public View getView(int position, View recycled, ViewGroup container) {
+  final ImageView myImageView;
+  if (recycled == null) {
+    myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);
+  } else {
+    myImageView = (ImageView) recycled;
+  }
+
+  String url = myUrls.get(position);
+
+  GlideApp
+    .with(myFragment)
+    .load(url)
+    .centerCrop()
+    .placeholder(R.drawable.loading_spinner)
+    .into(myImageView);
+
+  return myImageView;
 }
-
 ```
 
-OkHttp and Volley
------------------
-Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies. The
-integration libraries are available via Maven or the [releases page][1].
+Status
+------
+Version 4 is now released and stable. Updates are currently released at least monthly with new features and bug fixes.
 
-For instructions on including either the OkHttp or the Volley integration libraries, see the
-[Integration Libraries][12] wiki page.
+Comments/bugs/questions/pull requests are always welcome! Please read [CONTRIBUTING.md][5] on how to report issues.
 
-Android SDK Version
--------------------
-Glide requires a minimum sdk version of 10.
+Compatibility
+-------------
 
-License
--------
-BSD, part MIT and Apache 2.0. See LICENSE file for details.
+ * **Minimum Android SDK**: Glide v4 requires a minimum API level of 14.
+ * **Compile Android SDK**: Glide v4 requires you to compile against API 26 or later.
 
-Status
-------
-Version 3 is a stable public release used in multiple open source projects at Google including in the Android Camera
-app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!
+ If you need to support older versions of Android, consider staying on [Glide v3][14], which works on API 10, but is not actively maintained.
+
+ * **OkHttp 3.x**: There is an optional dependency available called `okhttp3-integration`, see the [docs page][23].
+ * **Volley**: There is an optional dependency available called `volley-integration`, see the [docs page][24].
+ * **Round Pictures**: `CircleImageView`/`CircularImageView`/`RoundedImageView` are known to have [issues][18] with `TransitionDrawable` (`.crossFade()` with `.thumbnail()` or `.placeholder()`) and animated GIFs, use a [`BitmapTransformation`][19] (`.circleCrop()` will be available in v4) or `.dontAnimate()` to fix the issue.
+ * **Huge Images** (maps, comic strips): Glide can load huge images by downsampling them, but does not support zooming and panning `ImageView`s as they require special resource optimizations (such as tiling) to work without `OutOfMemoryError`s.
 
 Build
-------
+-----
 Building Glide with gradle is fairly straight forward:
 
-```
-git clone git@github.com:bumptech/glide.git
+```shell
+git clone https://github.com/bumptech/glide.git 
 cd glide
-git submodule init && git submodule update
 ./gradlew jar
 ```
 
-Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment
+**Note**: Make sure your *Android SDK* has the *Android Support Repository* installed, and that your `$ANDROID_HOME` environment
 variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line.
 
 Samples
 -------
-Follow the steps in the 'Build' section to setup the project and then:
+Follow the steps in the [Build](#build) section to set up the project and then:
 
-```
+```shell
 ./gradlew :samples:flickr:run
 ./gradlew :samples:giphy:run
 ./gradlew :samples:svg:run
+./gradlew :samples:contacturi:run
 ```
+You may also find precompiled APKs on the [releases page][1].
 
 Development
 -----------
-Follow the steps in the 'Build' section to setup the project and then edit the files however you wish.
-[Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
+Follow the steps in the [Build](#build) section to setup the project and then edit the files however you wish.
+[Android Studio][26] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
 
-To open the project in Intellij 14:
+To open the project in Android Studio:
 
-1. Go to File.
-2. Click on 'Open...'
+1. Go to *File* menu or the *Welcome Screen*
+2. Click on *Open...*
 3. Navigate to Glide's root directory.
-4. Select glide-parent.iml
+4. Select `setting.gradle`
+
+For more details, see the [Contributing docs page][27].
 
 Getting Help
 ------------
 To report a specific problem or feature request, [open a new issue on Github][5]. For questions, suggestions, or
-anything else, join or email [Glide's discussion group][6], or join our irc channel: [irc.freenode.net#glide-library][13].
+anything else, email [Glide's discussion group][6], or join our IRC channel: [irc.freenode.net#glide-library][13].
 
 Contributing
 ------------
@@ -170,15 +178,19 @@ Before submitting pull requests, contributors must sign Google's [individual con
 
 Thanks
 ------
-* The Android team and Jake Wharton for the [disk cache implementation][8] Glide's disk cache is based on.
-* Dave Smith for the [gif decoder gist][9] Glide's gif decoder is based on.
-* Chris Banes for his [gradle-mvn-push][10] script.
-* Corey Hall for Glide's [amazing logo][11].
+* The **Android team** and **Jake Wharton** for the [disk cache implementation][8] Glide's disk cache is based on.
+* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on.
+* **Chris Banes** for his [gradle-mvn-push][10] script.
+* **Corey Hall** for Glide's [amazing logo][11].
 * Everyone who has contributed code and reported issues!
 
 Author
 ------
-Sam Judd - @samajudd
+Sam Judd - @sjudd on GitHub, @samajudd on Twitter
+
+License
+-------
+BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details.
 
 Disclaimer
 ---------
@@ -186,9 +198,9 @@ This is not an official Google product.
 
 [1]: https://github.com/bumptech/glide/releases
 [2]: https://github.com/bumptech/glide/wiki
-[3]: http://bumptech.github.io/glide/javadocs/latest/index.html
+[3]: https://bumptech.github.io/glide/ref/javadocs.html
 [4]: https://www.jetbrains.com/idea/download/
-[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
 [7]: https://developers.google.com/open-source/cla/individual
 [8]: https://github.com/JakeWharton/DiskLruCache
@@ -197,3 +209,18 @@ This is not an official Google product.
 [11]: static/glide_logo.png
 [12]: https://github.com/bumptech/glide/wiki/Integration-Libraries
 [13]: http://webchat.freenode.net/?channels=glide-library
+[14]: https://github.com/bumptech/glide/tree/3.0
+[15]: https://github.com/bumptech/glide/tree/master
+[16]: https://github.com/bumptech/glide/blob/master/LICENSE
+[17]: http://bumptech.github.io/glide/dev/snapshots.html
+[18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
+[19]: https://github.com/wasabeef/glide-transformations
+[20]: https://bumptech.github.io/glide/
+[21]: https://bumptech.github.io/glide/doc/generatedapi.html
+[22]: https://muyangmin.github.io/glide-docs-cn/
+[23]: http://bumptech.github.io/glide/int/okhttp3.html
+[24]: http://bumptech.github.io/glide/int/volley.html
+[25]: http://bumptech.github.io/glide/doc/download-setup.html#proguard
+[26]: https://developer.android.com/studio/index.html
+[27]: http://bumptech.github.io/glide/dev/contributing.html
+[28]: http://bumptech.github.io/glide/doc/download-setup.html
diff --git a/annotation/.gitignore b/annotation/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/build.gradle b/annotation/build.gradle
new file mode 100644
index 000000000..d6a7f76df
--- /dev/null
+++ b/annotation/build.gradle
@@ -0,0 +1,3 @@
+apply plugin: 'java'
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
\ No newline at end of file
diff --git a/annotation/compiler/.gitignore b/annotation/compiler/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/compiler/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/compiler/build.gradle b/annotation/compiler/build.gradle
new file mode 100644
index 000000000..4be6596a0
--- /dev/null
+++ b/annotation/compiler/build.gradle
@@ -0,0 +1,92 @@
+import org.gradle.internal.jvm.Jvm
+import proguard.gradle.ProGuardTask
+
+apply plugin: 'java'
+
+configurations {
+    // adapted from https://android.googlesource.com/platform/frameworks/testing/+/976c423/espresso/espresso-lib/build.gradle
+    // compileOnly dependencies will be repackaged, see rules in jarjar ant task below
+    jarjar 
+}
+
+dependencies {
+    // from https://code.google.com/archive/p/jarjar/downloads
+    jarjar files('libs/jarjar-1.4.jar')
+
+    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}"
+    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
+    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    compile project(':annotation')
+    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator.
+    compile files(Jvm.current().getToolsJar())
+}
+
+// Make sure running `gradlew :annotation:compiler:check` actually does full quality control.
+test.dependsOn ':annotation:compiler:test:test'
+
+def packagingFolder = file("${buildDir}/intermediates")
+def repackagedJar = file("${packagingFolder}/repackaged.jar")
+def proguardedJar = file("${packagingFolder}/proguarded.jar")
+
+task compiledJar(type: Jar, dependsOn: classes) {
+    destinationDir = packagingFolder
+    archiveName = 'compiled.jar'
+    from sourceSets.main.output
+}
+
+// Repackage compileOnly dependencies to avoid namespace collisions.
+task jarjar(dependsOn: [tasks.compiledJar, configurations.compileOnly]) {
+    // Set up inputs and outputs to only rebuild when necessary (code change, dependency change).
+    inputs.files compiledJar
+    inputs.files configurations.compileOnly
+    outputs.file repackagedJar
+
+    doFirst {
+        ant {
+            taskdef name: 'jarjar',
+                    classname: 'com.tonicsystems.jarjar.JarJarTask',
+                    classpath: configurations.jarjar.asPath
+
+            jarjar(jarfile: repackagedJar) {
+                configurations.compileOnly.resolve().each {
+                    zipfileset(src: it.absolutePath, excludes: [
+                        'META-INF/maven/**',
+                        'META-INF/services/javax.annotation.processing.Processor'
+                    ].join(','))
+                }
+                zipfileset(src: tasks.compiledJar.archivePath)
+                def repackageIntoGlide = 'com.bumptech.glide.repackaged.@0'
+                rule result: repackageIntoGlide, pattern: 'com.squareup.javapoet.**'
+                rule result: repackageIntoGlide, pattern: 'com.google.auto.**'
+                rule result: repackageIntoGlide, pattern: 'com.google.common.**'
+                rule result: repackageIntoGlide, pattern: 'com.google.thirdparty.publicsuffix.**'
+            }
+        }
+    }
+}
+
+// Proguard repackaged dependencies to reduce the binary size.
+task proguard(type: ProGuardTask, dependsOn: tasks.jarjar) {
+    configuration 'proguard.pro'
+
+    injars repackagedJar
+    outjars proguardedJar
+
+    libraryjars files(configurations.compile.collect())
+    libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
+}
+
+// Replace the contents of the standard jar task with those from our our compiled, repackaged and
+// proguarded jar. Replacing the task itself is possible and looks simpler, but requires
+// reconstructing the task dependency chain and is more complex in practice.
+jar {
+    dependsOn proguard
+    from zipTree(proguardedJar)
+    exclude { entry ->
+        sourceSets.main.output.files*.absolutePath.any {
+            entry.file.absolutePath.startsWith it
+        }
+    }
+}
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/annotation/compiler/gradle.properties b/annotation/compiler/gradle.properties
new file mode 100644
index 000000000..1f7f8a7a7
--- /dev/null
+++ b/annotation/compiler/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide Annotation processor
+POM_ARTIFACT_ID=compiler
+POM_PACKAGING=jar
+POM_DESCRIPTION=Glide's anntation processor. Should be included in all Applications and in all libraries that use Glide's modules for configuration.
diff --git a/annotation/compiler/libs/jarjar-1.4.jar b/annotation/compiler/libs/jarjar-1.4.jar
new file mode 100644
index 000000000..68b9db9aa
Binary files /dev/null and b/annotation/compiler/libs/jarjar-1.4.jar differ
diff --git a/annotation/compiler/proguard.pro b/annotation/compiler/proguard.pro
new file mode 100644
index 000000000..d40c8f599
--- /dev/null
+++ b/annotation/compiler/proguard.pro
@@ -0,0 +1,22 @@
+-verbose
+# Use ProGuard only to get rid of unused classes
+-dontobfuscate
+-dontoptimize
+-keepattributes *
+-keep class !com.bumptech.glide.repackaged.**,com.bumptech.glide.**
+
+# Keep the entry point to this library, see META-INF\services\javax.annotation.processing.Processor
+-keep class com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor
+
+
+# "duplicate definition of library class"
+-dontnote sun.applet.**
+# "duplicate definition of library class"
+-dontnote sun.tools.jar.**
+# Reflective accesses in com.google.common.util.concurrent.* and some others
+-dontnote com.bumptech.glide.repackaged.com.google.common.**
+# com.google.common.collect.* and some others (….common.*.*)
+-dontwarn com.google.j2objc.annotations.Weak
+# com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$ClassValueValidator
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+#-dontwarn **
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
new file mode 100644
index 000000000..291f594ae
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
@@ -0,0 +1,273 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeSpec.Builder;
+import com.squareup.javapoet.WildcardTypeName;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates a new implementation of a AppGlideModule that calls all included LibraryGlideModules
+ * and the original AppGlideModule.
+ *
+ * <p>The generated class will always call the AppGlideModule last to give it priority over choices
+ * made or classes registered in LibraryGlideModules.
+ *
+ * <p>Android logging is included to allow developers to see exactly which modules are included at
+ * runtime.
+ *
+ * <p>The generated class looks something like this:
+ * <pre>
+ * <code>
+ *  final class GeneratedAppGlideModuleImpl extends com.bumptech.glide.GeneratedAppGlideModule {
+ *    private final com.bumptech.glide.samples.giphy.GiphyGlideModule appGlideModule;
+ *
+ *    GeneratedAppGlideModule() {
+ *      appGlideModule = new com.bumptech.glide.samples.giphy.GiphyGlideModule();
+ *      if (android.util.Log.isLoggable("Glide", android.util.Log.DEBUG)) {
+ *        android.util.Log.d("Glide", "Discovered AppGlideModule from annotation:"
+ *            + " com.bumptech.glide.samples.giphy.GiphyGlideModule");
+ *        android.util.Log.d("Glide", "Discovered LibraryGlideModule from annotation:"
+ *            + "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule");
+ *      }
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public void applyOptions(android.content.Context context,
+ *        com.bumptech.glide.GlideBuilder builder) {
+ *      appGlideModule.applyOptions(context, builder);
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public void registerComponents(android.content.Context context,
+ *        com.bumptech.glide.Registry registry) {
+ *      new com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule()
+ *          .registerComponents(context, registry);
+ *      appGlideModule.registerComponents(context, registry);
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public boolean isManifestParsingEnabled() {
+ *      return appGlideModule.isManifestParsingEnabled();
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    {@literal @android.support.annotation.NonNull}
+ *    public java.util.Set&lt;java.lang.Class&lt;?>> getExcludedModuleClasses() {
+ *      return appGlideModule.getExcludedModuleClasses();
+ *    }
+ *  }
+ * </code>
+ * </pre>
+ */
+final class AppModuleGenerator {
+  static final String GENERATED_ROOT_MODULE_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String GLIDE_LOG_TAG = "Glide";
+  private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME =
+      "GeneratedAppGlideModuleImpl";
+  private static final String GENERATED_ROOT_MODULE_SIMPLE_NAME = "GeneratedAppGlideModule";
+
+  private final ProcessorUtil processorUtil;
+
+  AppModuleGenerator(ProcessorUtil processorUtil) {
+    this.processorUtil = processorUtil;
+  }
+
+  TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {
+    ClassName appGlideModuleClassName = ClassName.get(appGlideModule);
+    List<String> excludedGlideModuleClassNames =
+        getExcludedGlideModuleClassNames(appGlideModule);
+
+    List<String> orderedLibraryGlideModuleClassNames =
+        new ArrayList<>(libraryGlideModuleClassNames);
+    Collections.sort(orderedLibraryGlideModuleClassNames);
+
+    MethodSpec constructor =
+        generateConstructor(
+            appGlideModuleClassName,
+            orderedLibraryGlideModuleClassNames,
+            excludedGlideModuleClassNames);
+
+    MethodSpec registerComponents =
+        generateRegisterComponents(
+            orderedLibraryGlideModuleClassNames, excludedGlideModuleClassNames);
+
+    MethodSpec getExcludedModuleClasses =
+        generateGetExcludedModuleClasses(excludedGlideModuleClassNames);
+
+    MethodSpec applyOptions =
+        MethodSpec.methodBuilder("applyOptions")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("android.content", "Context"), "context")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addStatement("appGlideModule.applyOptions(context, builder)", appGlideModule)
+            .build();
+
+    MethodSpec isManifestParsingEnabled =
+        MethodSpec.methodBuilder("isManifestParsingEnabled")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .returns(boolean.class)
+            .addStatement("return appGlideModule.isManifestParsingEnabled()", appGlideModule)
+            .build();
+
+    Builder builder = TypeSpec.classBuilder(GENERATED_APP_MODULE_IMPL_SIMPLE_NAME)
+        .addModifiers(Modifier.FINAL)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build()
+        )
+        .superclass(
+            ClassName.get(GENERATED_ROOT_MODULE_PACKAGE_NAME, GENERATED_ROOT_MODULE_SIMPLE_NAME))
+        .addField(appGlideModuleClassName, "appGlideModule", Modifier.PRIVATE, Modifier.FINAL)
+        .addMethod(constructor)
+        .addMethod(applyOptions)
+        .addMethod(registerComponents)
+        .addMethod(isManifestParsingEnabled)
+        .addMethod(getExcludedModuleClasses);
+
+    ClassName generatedRequestManagerFactoryClassName =
+        ClassName.get(
+            RequestManagerFactoryGenerator.GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME,
+            RequestManagerFactoryGenerator.GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME);
+
+    builder.addMethod(
+        MethodSpec.methodBuilder("getRequestManagerFactory")
+            .addAnnotation(Override.class)
+            .addAnnotation(nonNull())
+            .returns(generatedRequestManagerFactoryClassName)
+            .addStatement("return new $T()", generatedRequestManagerFactoryClassName)
+            .build());
+    return builder.build();
+  }
+
+  // TODO: When we drop support for parsing GlideModules from AndroidManifests, remove this method.
+  private MethodSpec generateGetExcludedModuleClasses(Collection<String> excludedClassNames) {
+    TypeName wildCardOfObject = WildcardTypeName.subtypeOf(Object.class);
+    ParameterizedTypeName classOfWildcardOfObjet =
+        ParameterizedTypeName.get(ClassName.get(Class.class), wildCardOfObject);
+    ParameterizedTypeName setOfClassOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(Set.class), classOfWildcardOfObjet);
+    ParameterizedTypeName hashSetOfClassOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(HashSet.class), classOfWildcardOfObjet);
+    MethodSpec.Builder builder = MethodSpec.methodBuilder("getExcludedModuleClasses")
+        .addModifiers(Modifier.PUBLIC)
+        .addAnnotation(Override.class)
+        .addAnnotation(nonNull())
+        .returns(setOfClassOfWildcardOfObject);
+
+    if (excludedClassNames.isEmpty()) {
+      builder.addStatement("return $T.emptySet()", Collections.class);
+    } else {
+      builder.addStatement(
+          "$T excludedClasses = new $T()", setOfClassOfWildcardOfObject,
+          hashSetOfClassOfWildcardOfObject);
+      for (String excludedClassName : excludedClassNames) {
+        // TODO: Remove this when we no longer support manifest parsing.
+        // Using a Literal ($L) instead of a type ($T) to get a fully qualified import that allows
+        // us to suppress deprecation warnings. Aimed at deprecated GlideModules.
+        builder.addStatement("excludedClasses.add($L.class)", excludedClassName);
+      }
+      builder.addStatement("return excludedClasses");
+    }
+
+    return builder.build();
+  }
+
+  private MethodSpec generateRegisterComponents(
+      Collection<String> libraryGlideModuleClassNames,
+      Collection<String> excludedGlideModuleClassNames) {
+    MethodSpec.Builder registerComponents =
+        MethodSpec.methodBuilder("registerComponents")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("android.content", "Context"), "context")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("com.bumptech.glide", "Glide"), "glide")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(
+                ClassName.get("com.bumptech.glide", "Registry"), "registry")
+                .addAnnotation(nonNull())
+                .build()
+            );
+
+    for (String glideModule : libraryGlideModuleClassNames) {
+      if (excludedGlideModuleClassNames.contains(glideModule)) {
+        continue;
+      }
+      ClassName moduleClassName = ClassName.bestGuess(glideModule);
+      registerComponents.addStatement(
+          "new $T().registerComponents(context, glide, registry)", moduleClassName);
+    }
+    // Order matters here. The AppGlideModule must be called last.
+    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");
+    return registerComponents.build();
+  }
+
+  private MethodSpec generateConstructor(ClassName appGlideModule,
+      Collection<String> libraryGlideModuleClassNames,
+      Collection<String> excludedGlideModuleClassNames) {
+    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
+    constructorBuilder.addStatement("appGlideModule = new $T()", appGlideModule);
+
+    ClassName androidLogName = ClassName.get("android.util", "Log");
+
+    // Add some log lines to indicate to developers which modules where discovered.
+    constructorBuilder.beginControlFlow("if ($T.isLoggable($S, $T.DEBUG))",
+        androidLogName, GLIDE_LOG_TAG, androidLogName);
+    constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+        "Discovered AppGlideModule from annotation: " + appGlideModule);
+    // Excluded GlideModule classes from the manifest are logged in Glide's singleton.
+    for (String glideModule : libraryGlideModuleClassNames) {
+      ClassName moduleClassName = ClassName.bestGuess(glideModule);
+      if (excludedGlideModuleClassNames.contains(glideModule)) {
+        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);
+      } else {
+        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+            "Discovered LibraryGlideModule from annotation: " + moduleClassName);
+      }
+    }
+    constructorBuilder.endControlFlow();
+    return constructorBuilder.build();
+  }
+
+  private List<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
+    Set<String> names = processorUtil.findClassValuesFromAnnotationOnClassAsNames(
+        appGlideModule, Excludes.class);
+    List<String> result = new ArrayList<>(names);
+    Collections.sort(result);
+    return result;
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
new file mode 100644
index 000000000..5e10a334b
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
@@ -0,0 +1,177 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Runs the final steps of Glide's annotation process and generates the combined
+ * {@code AppGlideModule}, {@code com.bumptech.glide.Glide},
+ * {@code com.bumptech.glide.RequestManager}, and
+ * {@code com.bumptech.glide.request.RequestOptions} classes.
+ */
+final class AppModuleProcessor {
+  private static final String COMPILER_PACKAGE_NAME =
+      GlideAnnotationProcessor.class.getPackage().getName();
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final List<TypeElement> appGlideModules = new ArrayList<>();
+  private final RequestOptionsGenerator requestOptionsGenerator;
+  private final RequestManagerGenerator requestManagerGenerator;
+  private final AppModuleGenerator appModuleGenerator;
+  private final RequestBuilderGenerator requestBuilderGenerator;
+  private final RequestManagerFactoryGenerator requestManagerFactoryGenerator;
+  private final GlideGenerator glideGenerator;
+
+  AppModuleProcessor(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    appModuleGenerator = new AppModuleGenerator(processorUtil);
+    requestOptionsGenerator = new RequestOptionsGenerator(processingEnv, processorUtil);
+    requestManagerGenerator = new RequestManagerGenerator(processingEnv, processorUtil);
+    requestManagerFactoryGenerator = new RequestManagerFactoryGenerator(processingEnv);
+    glideGenerator = new GlideGenerator(processingEnv, processorUtil);
+    requestBuilderGenerator = new RequestBuilderGenerator(processingEnv, processorUtil);
+  }
+
+  void processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
+     for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+       if (processorUtil.isAppGlideModule(element)) {
+         appGlideModules.add(element);
+       }
+     }
+
+    processorUtil.debugLog("got app modules: " + appGlideModules);
+
+    if (appGlideModules.size() > 1) {
+      throw new IllegalStateException(
+          "You cannot have more than one AppGlideModule, found: " + appGlideModules);
+    }
+  }
+
+  boolean maybeWriteAppModule() {
+    // appGlideModules is added to in order to catch errors where multiple AppGlideModules may be
+    // present for a single application or library. Because we only add to appGlideModules, we use
+    // isGeneratedAppGlideModuleWritten to make sure the GeneratedAppGlideModule is written at
+    // most once.
+    if (appGlideModules.isEmpty()) {
+      return false;
+    }
+    TypeElement appModule = appGlideModules.get(0);
+    processorUtil.debugLog("Processing app module: " + appModule);
+    // If this package is null, it means there are no classes with this package name. One way this
+    // could happen is if we process an annotation and reach this point without writing something
+    // to the package. We do not error check here because that shouldn't happen with the
+    // current implementation.
+    PackageElement glideGenPackage =
+        processingEnv.getElementUtils().getPackageElement(COMPILER_PACKAGE_NAME);
+    FoundIndexedClassNames indexedClassNames = getIndexedClassNames(glideGenPackage);
+
+    // Write all generated code to the package containing the AppGlideModule. Doing so fixes
+    // classpath collisions if more than one Application containing a AppGlideModule is included
+    // in a project.
+    String generatedCodePackageName = appModule.getEnclosingElement().toString();
+
+    TypeSpec generatedRequestOptions =
+          requestOptionsGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);
+      writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
+
+    TypeSpec generatedRequestBuilder =
+        requestBuilderGenerator.generate(generatedCodePackageName, generatedRequestOptions);
+    writeRequestBuilder(generatedCodePackageName, generatedRequestBuilder);
+
+    TypeSpec requestManager =
+        requestManagerGenerator.generate(
+            generatedCodePackageName, generatedRequestOptions, generatedRequestBuilder,
+            indexedClassNames.extensions);
+    writeRequestManager(generatedCodePackageName, requestManager);
+
+    TypeSpec requestManagerFactory =
+        requestManagerFactoryGenerator.generate(generatedCodePackageName, requestManager);
+    writeRequestManagerFactory(requestManagerFactory);
+
+    TypeSpec glide =
+        glideGenerator.generate(generatedCodePackageName, getGlideName(appModule), requestManager);
+    writeGlide(generatedCodePackageName, glide);
+
+    TypeSpec generatedAppGlideModule =
+        appModuleGenerator.generate(appModule, indexedClassNames.glideModules);
+    writeAppModule(generatedAppGlideModule);
+
+    processorUtil.infoLog("Wrote GeneratedAppGlideModule with: " + indexedClassNames.glideModules);
+
+    return true;
+  }
+
+  private String getGlideName(TypeElement appModule) {
+    return appModule.getAnnotation(GlideModule.class).glideName();
+  }
+
+  @SuppressWarnings("unchecked")
+  private FoundIndexedClassNames getIndexedClassNames(PackageElement glideGenPackage) {
+    Set<String> glideModules = new HashSet<>();
+    Set<String> extensions = new HashSet<>();
+    List<? extends Element> glideGeneratedElements = glideGenPackage.getEnclosedElements();
+    for (Element indexer : glideGeneratedElements) {
+      Index annotation = indexer.getAnnotation(Index.class);
+      // If the annotation is null, it means we've come across another class in the same package
+      // that we can safely ignore.
+      if (annotation != null) {
+        Collections.addAll(glideModules, annotation.modules());
+        Collections.addAll(extensions, annotation.extensions());
+      }
+    }
+
+    processorUtil.debugLog("Found GlideModules: " + glideModules);
+    return new FoundIndexedClassNames(glideModules, extensions);
+  }
+
+  private void writeGlide(String packageName, TypeSpec glide) {
+    processorUtil.writeClass(packageName, glide);
+  }
+
+  private void writeRequestManager(String packageName, TypeSpec requestManager) {
+    processorUtil.writeClass(packageName, requestManager);
+  }
+
+  // We dont' care about collisions in IDEs since this class isn't an API class.
+  private void writeRequestManagerFactory(TypeSpec requestManagerFactory) {
+    processorUtil.writeClass(
+        AppModuleGenerator.GENERATED_ROOT_MODULE_PACKAGE_NAME, requestManagerFactory);
+  }
+
+  // The app module we generate subclasses a package private class. We don't care about classpath
+  // collisions in IDEs since this class isn't an API class.
+  private void writeAppModule(TypeSpec appModule) {
+    processorUtil.writeClass(AppModuleGenerator.GENERATED_ROOT_MODULE_PACKAGE_NAME, appModule);
+  }
+
+  private void writeRequestOptions(String packageName, TypeSpec requestOptions) {
+    processorUtil.writeClass(packageName, requestOptions);
+  }
+
+  private void writeRequestBuilder(String packageName, TypeSpec requestBuilder) {
+    processorUtil.writeClass(packageName, requestBuilder);
+  }
+
+  private static final class FoundIndexedClassNames {
+    private final Set<String> glideModules;
+    private final Set<String> extensions;
+
+    private FoundIndexedClassNames(Set<String> glideModules, Set<String> extensions) {
+      this.glideModules = glideModules;
+      this.extensions = extensions;
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
new file mode 100644
index 000000000..eed0f1243
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
@@ -0,0 +1,49 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Writes Indexer classes annotated with {@link Index} for all
+ * classes found annotated with {@link GlideExtension}.
+ */
+final class ExtensionProcessor {
+  private final ProcessorUtil processorUtil;
+  private final IndexerGenerator indexerGenerator;
+  private final GlideExtensionValidator extensionValidator;
+
+  ExtensionProcessor(
+      ProcessingEnvironment processingEnvironment,
+      ProcessorUtil processorUtil,
+      IndexerGenerator indexerGenerator) {
+    this.processorUtil = processorUtil;
+    this.indexerGenerator = indexerGenerator;
+    extensionValidator = new GlideExtensionValidator(processingEnvironment, processorUtil);
+  }
+
+  boolean processExtensions(RoundEnvironment env) {
+    List<TypeElement> elements = processorUtil.getElementsFor(GlideExtension.class, env);
+    processorUtil.debugLog("Processing types : " + elements);
+    for (TypeElement typeElement : elements) {
+      extensionValidator.validateExtension(typeElement);
+      processorUtil.debugLog("Processing elements: " + typeElement.getEnclosedElements());
+    }
+
+    if (elements.isEmpty()) {
+      return false;
+    }
+    TypeSpec spec = indexerGenerator.generate(elements);
+    processorUtil.writeIndexer(spec);
+    return true;
+  }
+
+  Set<String> getSupportedAnnotationTypes() {
+    return Collections.singleton(GlideExtension.class.getName());
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
new file mode 100644
index 000000000..32a8575d9
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
@@ -0,0 +1,135 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideType;
+import com.google.auto.service.AutoService;
+import java.util.HashSet;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.TypeElement;
+
+// Links in Javadoc will work due to build setup, even though there is no direct dependency here.
+/**
+ * Generates classes based on Glide's annotations that configure Glide, add support for additional
+ * resource types, and/or extend Glide's API.
+ *
+ * <p>This processor discovers all {@code AppGlideModule} and
+ * {@code LibraryGlideModule} implementations that are
+ * annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any implementations missing the
+ * annotation will be ignored.
+ *
+ * <p>This processor also discovers all {@link com.bumptech.glide.annotation.GlideExtension}
+ * annotated classes.
+ *
+ * <p>Multiple classes are generated by this processor:
+ * <ul>
+ *   <li>For {@code LibraryGlideModule}s - A GlideIndexer class in a
+ *      specific package that will later be used by the processor to discover all
+ *      {@code LibraryGlideModule} classes.
+ *   <li>For {@code AppGlideModule}s - A single
+ *      {@code AppGlideModule} implementation
+ *     ({@code com.bumptech.glide.GeneratedAppGlideModule}) that calls all
+ *     {@code LibraryGlideModule}s and the
+ *     original {@code AppGlideModule} in the correct order when Glide is
+ *     initialized.
+ *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -
+ *   <ul>
+ *     <li>A {@code com.bumptech.glide.request.RequestOptions} implementation that contains
+ *     static versions of all builder methods in the base class and both static and instance
+ *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
+ *     <li>If one or more methods in one or more
+ *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
+ *     {@link GlideType}:
+ *     <ul>
+ *       <li>A {@code com.bumptech.glide.RequestManager} implementation containing a generated
+ *       method for each method annotated with
+ *       {@link GlideType}.
+ *       <li>A {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ *       implementation that produces the generated {@code com.bumptech.glide.RequestManager}s.
+ *       <li>A {@code com.bumptech.glide.Glide} look-alike that implements all static methods in
+ *       the {@code com.bumptech.glide.Glide} singleton and returns the generated
+ *       {@code com.bumptech.glide.RequestManager} implementation when appropriate.
+ *     </ul>
+ *   </ul>
+ * </ul>
+ *
+ * <p>{@code AppGlideModule} implementations must only be included in
+ * applications, not in libraries. There must be exactly one
+ * {@code AppGlideModule} implementation per
+ * Application. The {@code AppGlideModule} class is
+ * used as a signal that all modules have been found and that the final merged
+ * {@code com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
+ */
+@AutoService(Processor.class)
+public final class GlideAnnotationProcessor extends AbstractProcessor {
+  static final boolean DEBUG = false;
+  private ProcessorUtil processorUtil;
+  private LibraryModuleProcessor libraryModuleProcessor;
+  private AppModuleProcessor appModuleProcessor;
+  private boolean isGeneratedAppGlideModuleWritten;
+  private ExtensionProcessor extensionProcessor;
+
+  @Override
+  public synchronized void init(ProcessingEnvironment processingEnvironment) {
+    super.init(processingEnvironment);
+    processorUtil = new ProcessorUtil(processingEnvironment);
+    IndexerGenerator indexerGenerator = new IndexerGenerator(processorUtil);
+    libraryModuleProcessor = new LibraryModuleProcessor(processorUtil, indexerGenerator);
+    appModuleProcessor = new AppModuleProcessor(processingEnvironment, processorUtil);
+    extensionProcessor =
+        new ExtensionProcessor(processingEnvironment, processorUtil, indexerGenerator);
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    Set<String> result = new HashSet<>();
+    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());
+    result.addAll(extensionProcessor.getSupportedAnnotationTypes());
+    return result;
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+   /**
+    * Each round we do the following:
+    * <ol>
+    *   <li>Find all {@code AppGlideModule}s and save them to an instance variable (throw if > 1).
+    *   <li>Find all {@code LibraryGlideModule}s
+    *   <li>For each {@code LibraryGlideModule},
+    *       write an {@code Indexer} with an Annotation with the class name.
+    *   <li>If we wrote any {@code Indexer}s, return and wait for the next round.
+    *   <li>If we didn't write any {@code Indexer}s and there is a {@code AppGlideModule},
+    *       write the {@code GeneratedAppGlideModule}.
+    *       Once the {@code GeneratedAppGlideModule} is written, we expect to be finished.
+    *       Any further generation of related classes will result in errors.
+    * </ol>
+    */
+  @Override
+  public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {
+//    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {
+//      return false;
+//    }
+    processorUtil.process();
+    boolean newModulesWritten = libraryModuleProcessor.processModules(env);
+    boolean newExtensionWritten = extensionProcessor.processExtensions(env);
+    appModuleProcessor.processModules(set, env);
+
+    if (newExtensionWritten || newModulesWritten) {
+      if (isGeneratedAppGlideModuleWritten) {
+        throw new IllegalStateException("Cannot process annotations after writing AppGlideModule");
+      }
+      return true;
+    }
+
+    if (!isGeneratedAppGlideModuleWritten) {
+      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();
+    }
+    return true;
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
new file mode 100644
index 000000000..051cc4be6
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -0,0 +1,307 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.annotation.GlideType;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
+
+/**
+ * Validates that classes annotated with {@link com.bumptech.glide.annotation.GlideExtension}
+ * contains methods with the expected format.
+ *
+ * <p>Validation is performed so that errors can be found when a library is compiled. Without
+ * validation, an error written in to a library wouldn't be found until Glide tried to generate code
+ * for an Application.
+ */
+final class GlideExtensionValidator {
+  private final ProcessingEnvironment processingEnvironment;
+  private final ProcessorUtil processorUtil;
+
+  GlideExtensionValidator(
+      ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
+    this.processingEnvironment = processingEnvironment;
+    this.processorUtil = processorUtil;
+  }
+
+  void validateExtension(TypeElement typeElement) {
+    if (!typeElement.getModifiers().contains(Modifier.PUBLIC)) {
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, including: " + getName(typeElement));
+    }
+    for (Element element : typeElement.getEnclosedElements()) {
+      if (element.getKind() == ElementKind.CONSTRUCTOR) {
+        validateExtensionConstructor(element);
+      } else if (element.getKind() == ElementKind.METHOD) {
+        ExecutableElement executableElement = (ExecutableElement) element;
+        if (executableElement.getAnnotation(GlideOption.class) != null) {
+          validateGlideOption(executableElement);
+        } else if (executableElement.getAnnotation(GlideType.class) != null) {
+          validateGlideType(executableElement);
+        }
+      }
+    }
+  }
+
+  private static String getQualifiedMethodName(ExecutableElement executableElement) {
+    return getEnclosingClassName(executableElement) + "#" + getName(executableElement);
+  }
+
+  private static String getEnclosingClassName(Element element) {
+    return element.getEnclosingElement().toString();
+  }
+
+  private static String getName(Element element) {
+    return element.toString();
+  }
+
+  private static void validateExtensionConstructor(Element element) {
+    if (!element.getModifiers().contains(Modifier.PRIVATE)) {
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found a non-private constructor in: " + getEnclosingClassName(element));
+    }
+    ExecutableElement executableElement = (ExecutableElement) element;
+    if (!executableElement.getParameters().isEmpty()) {
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found parameters in the constructor of: "
+              + getEnclosingClassName(element));
+    }
+  }
+
+  private void validateGlideOption(ExecutableElement executableElement) {
+    if (returnsVoid(executableElement)) {
+      validateDeprecatedGlideOption(executableElement);
+    } else {
+      validateNewGlideOption(executableElement);
+    }
+  }
+
+  private void validateNewGlideOption(ExecutableElement executableElement) {
+    validateNewGlideOptionAnnotations(executableElement);
+    validateGlideOptionParameters(executableElement);
+    TypeMirror returnType = executableElement.getReturnType();
+    if (!isRequestOptions(returnType)) {
+      throw new IllegalArgumentException("@GlideOption methods should return a RequestOptions"
+          + " object, but " + getQualifiedMethodName(executableElement) + " returns " + returnType
+          + ". If you're using old style @GlideOption methods, your method may have a void return"
+          + " type, but doing so is deprecated and support will be removed in a future version");
+    }
+    validateGlideOptionOverride(executableElement);
+  }
+
+  private void validateNewGlideOptionAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
+  private void validateDeprecatedGlideOption(ExecutableElement executableElement) {
+    validateStaticVoid(executableElement, GlideOption.class);
+    validateGlideOptionParameters(executableElement);
+    validateGlideOptionOverride(executableElement);
+  }
+
+  private static void validateGlideOptionParameters(ExecutableElement executableElement) {
+    if (executableElement.getParameters().isEmpty()) {
+      throw new IllegalArgumentException("@GlideOption methods must take a "
+          + "RequestOptions object as their first parameter, but "
+          + getQualifiedMethodName(executableElement) + " has none");
+    }
+    VariableElement first = executableElement.getParameters().get(0);
+    TypeMirror expected = first.asType();
+    if (!isRequestOptions(expected)) {
+      throw new IllegalArgumentException("@GlideOption methods must take a"
+          + " RequestOptions object as their first parameter, but the first parameter in "
+          + getQualifiedMethodName(executableElement) + " is " + expected);
+    }
+  }
+
+  private static boolean isRequestOptions(TypeMirror typeMirror) {
+    return typeMirror.toString().equals("com.bumptech.glide.request.RequestOptions");
+  }
+
+  private void validateGlideOptionOverride(ExecutableElement element) {
+    int overrideType = processorUtil.getOverrideType(element);
+    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);
+    if (isOverridingRequestOptionsMethod && overrideType == GlideOption.OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Accidentally attempting to override a method in"
+          + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
+          + " if this is intentional. Offending method: "
+          + getQualifiedMethodName(element));
+    } else if (!isOverridingRequestOptionsMethod && overrideType != GlideOption.OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Requested to override an existing method in"
+          + " RequestOptions, but no such method was found. Offending method: "
+          + getQualifiedMethodName(element));
+    }
+  }
+
+  private boolean isMethodInRequestOptions(ExecutableElement toFind) {
+    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
+    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
+    // first type.
+    TypeElement requestOptionsType =
+        processingEnvironment
+            .getElementUtils()
+            .getTypeElement(RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
+    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
+    String toFindSimpleName = toFind.getSimpleName().toString();
+    for (Element element : requestOptionsType.getEnclosedElements()) {
+      if (element.getKind() != ElementKind.METHOD) {
+        continue;
+      }
+      ExecutableElement inBase = (ExecutableElement) element;
+      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
+        List<String> parameterNamesInBase =
+            getComparableParameterNames(inBase, false /*skipFirst*/);
+        if (parameterNamesInBase.equals(toFindParameterNames)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private static List<String> getComparableParameterNames(
+      ExecutableElement element, boolean skipFirst) {
+    List<? extends VariableElement> parameters = element.getParameters();
+    if (skipFirst) {
+      parameters = parameters.subList(1, parameters.size());
+    }
+    List<String> result = new ArrayList<>(parameters.size());
+    for (VariableElement parameter : parameters) {
+      result.add(parameter.asType().toString());
+    }
+    return result;
+  }
+
+  private void validateGlideType(ExecutableElement executableElement) {
+    if (returnsVoid(executableElement)) {
+      validateDeprecatedGlideType(executableElement);
+    } else {
+      validateNewGlideType(executableElement);
+    }
+  }
+
+  private void validateNewGlideType(ExecutableElement executableElement) {
+    TypeMirror returnType = executableElement.getReturnType();
+    validateNewGlideTypeAnnotations(executableElement);
+    if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {
+      String expectedClassName = getGlideTypeValue(executableElement);
+      throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<"
+          + expectedClassName + "> object, but " + getQualifiedMethodName(executableElement)
+          + " returns: " + returnType + ". If you're using old style @GlideType methods, your"
+          + " method may have a void return type, but doing so is deprecated and support will be"
+          + " removed in a future version");
+    }
+    validateGlideTypeParameters(executableElement);
+  }
+
+  private String getGlideTypeValue(ExecutableElement executableElement) {
+    return
+        processorUtil
+            .findClassValuesFromAnnotationOnClassAsNames(
+                executableElement, GlideType.class).iterator().next();
+  }
+
+  private boolean typeMatchesExpected(
+      TypeMirror returnType, ExecutableElement executableElement) {
+    if (!(returnType instanceof DeclaredType)) {
+      return false;
+    }
+    List<? extends TypeMirror> typeArguments = ((DeclaredType) returnType).getTypeArguments();
+    if (typeArguments.size() != 1) {
+      return false;
+    }
+    TypeMirror argument = typeArguments.get(0);
+    String expected = getGlideTypeValue(executableElement);
+    return argument.toString().equals(expected);
+  }
+
+  private boolean isRequestBuilder(TypeMirror typeMirror) {
+    TypeMirror toCompare = processingEnvironment.getTypeUtils().erasure(typeMirror);
+    return toCompare.toString().equals("com.bumptech.glide.RequestBuilder");
+  }
+
+  private static void validateDeprecatedGlideType(ExecutableElement executableElement) {
+    validateStaticVoid(executableElement, GlideType.class);
+    validateGlideTypeParameters(executableElement);
+  }
+
+  private static void validateGlideTypeParameters(ExecutableElement executableElement) {
+    if (executableElement.getParameters().size() != 1) {
+      throw new IllegalArgumentException("@GlideType methods must take a"
+          + " RequestBuilder object as their first and only parameter, but given multiple for: "
+          + getQualifiedMethodName(executableElement));
+    }
+
+    VariableElement first = executableElement.getParameters().get(0);
+    TypeMirror argumentType = first.asType();
+    if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
+      throw new IllegalArgumentException("@GlideType methods must take a"
+          + " RequestBuilder object as their first and only parameter, but given: " + argumentType
+          + " for: " + getQualifiedMethodName(executableElement));
+    }
+  }
+
+  private void validateNewGlideTypeAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
+  private void validateAnnotatedNonNull(ExecutableElement executableElement) {
+    Set<String> annotationNames =
+        FluentIterable.from(executableElement.getAnnotationMirrors())
+            .transform(new Function<AnnotationMirror, String>() {
+              @Override
+              public String apply(AnnotationMirror input) {
+                return input.getAnnotationType().asElement().toString();
+              }
+            })
+            .toSet();
+    if (!annotationNames.contains(nonNull().reflectionName())) {
+      processingEnvironment.getMessager().printMessage(
+          Kind.WARNING,
+          getQualifiedMethodName(executableElement)
+              + " is missing the " + nonNull().reflectionName() + " annotation,"
+              + " please add it to ensure that your extension methods are always returning non-null"
+              + " values");
+    }
+  }
+
+  private static void validateStatic(ExecutableElement executableElement, Class<?> clazz) {
+    if (!executableElement.getModifiers().contains(Modifier.STATIC)) {
+      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must be static");
+    }
+  }
+
+  private static boolean returnsVoid(ExecutableElement executableElement) {
+    TypeMirror returnType = executableElement.getReturnType();
+    return returnType.getKind() == TypeKind.VOID;
+  }
+
+  private static void validateVoid(ExecutableElement executableElement, Class<?> clazz) {
+    if (!returnsVoid(executableElement)) {
+      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must return void");
+    }
+  }
+
+  private static void validateStaticVoid(ExecutableElement executableElement, Class<?> clazz) {
+    validateStatic(executableElement, clazz);
+    validateVoid(executableElement, clazz);
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
new file mode 100644
index 000000000..512fc42a7
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
@@ -0,0 +1,230 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.google.common.base.Function;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.MethodSpec.Builder;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates a Glide look-alike that acts as the entry point to the generated API
+ * (GlideApp.with(...)).
+ *
+ * <p>>Generated {@code com.bumptech.glide.Glide} look-alikes look like this (note that the name
+ * is configurable in {@link com.bumptech.glide.annotation.GlideModule}):
+ * <pre>
+ * <code>
+ * public final class GlideApp {
+ *   private GiphyGlide() {
+ *   }
+ *
+ *   public static File getPhotoCacheDir(Context context) {
+ *     return Glide.getPhotoCacheDir(context);
+ *   }
+ *
+ *   public static File getPhotoCacheDir(Context context, String cacheName) {
+ *     return Glide.getPhotoCacheDir(context, cacheName);
+ *   }
+ *
+ *   public static Glide get(Context context) {
+ *     return Glide.get(context);
+ *   }
+ *
+ *   public static void tearDown() {
+ *     Glide.tearDown();
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Context context) {
+ *     return (GeneratedRequestManager) Glide.with(context);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Activity activity) {
+ *    return (GeneratedRequestManager) Glide.with(activity);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(FragmentActivity activity) {
+ *     return (GeneratedRequestManager) Glide.with(activity);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Fragment fragment) {
+ *     return (GeneratedRequestManager) Glide.with(fragment);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(android.support.v4.app.Fragment fragment) {
+ *     return (GeneratedRequestManager) Glide.with(fragment);
+ *   }
+ * </code>
+ * </pre>
+ */
+final class GlideGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+
+  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME =
+      "android.support.annotation.VisibleForTesting";
+
+  private static final String SUPPRESS_LINT_PACKAGE_NAME =
+      "android.annotation";
+  private static final String SUPPRESS_LINT_CLASS_NAME =
+      "SuppressLint";
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final TypeElement glideType;
+  private final TypeElement requestManagerType;
+
+  GlideGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    Elements elementUtils = processingEnv.getElementUtils();
+
+    requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(
+      String generatedCodePackageName, String glideName, TypeSpec generatedRequestManager) {
+    return TypeSpec.classBuilder(glideName)
+        .addJavadoc(
+            "The entry point for interacting with Glide for Applications\n"
+                + "\n"
+                + "<p>Includes all generated APIs from all\n"
+                + "{@link $T}s in source and dependent libraries.\n"
+                + "\n"
+                + "<p>This class is generated and should not be modified"
+                + "\n"
+                + "@see $T\n", GlideExtension.class, glideType)
+        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addMethod(MethodSpec.constructorBuilder()
+            .addModifiers(Modifier.PRIVATE)
+            .build())
+        .addMethods(
+            generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager))
+        .build();
+  }
+
+  private List<MethodSpec> generateOverridesForGlideMethods(
+      final String generatedCodePackageName, final TypeSpec generatedRequestManager) {
+    return Lists.transform(discoverGlideMethodsToOverride(),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            if (isGlideWithMethod(input)) {
+              return overrideGlideWithMethod(
+                  generatedCodePackageName, generatedRequestManager, input);
+            } else {
+              return overrideGlideStaticMethod(input);
+            }
+          }
+        });
+  }
+
+  private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride) {
+    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+
+    TypeElement element =
+        (TypeElement) processingEnv.getTypeUtils().asElement(methodToOverride.getReturnType());
+
+    MethodSpec.Builder builder =
+        MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+            .addParameters(ProcessorUtil.getParameters(methodToOverride));
+
+    addReturnAnnotations(builder, methodToOverride);
+
+    boolean returnsValue = element != null;
+    if (returnsValue) {
+      builder.returns(ClassName.get(element));
+    }
+
+    StringBuilder code = new StringBuilder(returnsValue ? "return " : "");
+    code.append("$T.$N(");
+    List<Object> args = new ArrayList<>();
+    args.add(ClassName.get(glideType));
+    args.add(methodToOverride.getSimpleName());
+    if (!parameters.isEmpty()) {
+      for (VariableElement param : parameters) {
+        code.append("$L, ");
+        args.add(param.getSimpleName());
+      }
+      code = new StringBuilder(code.substring(0, code.length() - 2));
+    }
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
+    return builder.build();
+  }
+
+  private Builder addReturnAnnotations(Builder builder, ExecutableElement methodToOverride) {
+    String visibleForTestingTypeQualifiedName =
+        processingEnv
+            .getElementUtils()
+            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME)
+            .toString();
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+
+      // Suppress a lint warning if we're overriding a VisibleForTesting method.
+      // See #1977.
+      String annotationQualifiedName = mirror.getAnnotationType().toString();
+      if (annotationQualifiedName.equals(visibleForTestingTypeQualifiedName)) {
+        builder.addAnnotation(
+            AnnotationSpec.builder(
+                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
+                .addMember("value", "$S", "VisibleForTests")
+                .build());
+      }
+    }
+
+    return builder;
+  }
+
+  private List<ExecutableElement> discoverGlideMethodsToOverride() {
+    return processorUtil.findStaticMethods(glideType);
+  }
+
+  private boolean isGlideWithMethod(ExecutableElement element) {
+    return processorUtil.isReturnValueTypeMatching(element, requestManagerType);
+  }
+
+  private MethodSpec overrideGlideWithMethod(
+      String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {
+    ClassName generatedRequestManagerClassName =
+        ClassName.get(packageName, generatedRequestManager.name);
+    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+    Preconditions.checkArgument(
+        parameters.size() == 1, "Expected size of 1, but got %s", methodToOverride);
+    VariableElement parameter = parameters.iterator().next();
+
+    Builder builder = MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+        .addParameters(ProcessorUtil.getParameters(methodToOverride))
+        .returns(generatedRequestManagerClassName)
+        .addStatement("return ($T) $T.$N($L)",
+            generatedRequestManagerClassName, glideType,
+            methodToOverride.getSimpleName().toString(),
+            parameter.getSimpleName());
+
+    return addReturnAnnotations(builder, methodToOverride).build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
new file mode 100644
index 000000000..7ff49feea
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
@@ -0,0 +1,110 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.List;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates an empty class with an annotation containing the class names of one or more
+ * LibraryGlideModules and/or one or more GlideExtensions.
+ *
+ * <p>We use a separate class so that LibraryGlideModules and GlideExtensions written in libraries
+ * can be bundled into an AAR and later retrieved by the annotation processor when it processes the
+ * AppGlideModule in an application.
+ *
+ * <p>The output file generated by this class with a LibraryGlideModule looks like this:
+ * <pre>
+ * <code>
+ *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
+ *      modules = "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule"
+ *  )
+ *  public class Indexer_GlideModule_com_bumptech_glide_integration_okhttp3_OkHttpLibraryGlideModule
+ *  {
+ *  }
+ * </code>
+ * </pre>
+ *
+ * <p>The output file generated by this class with a GlideExtension looks like this:
+ * <pre>
+ * <code>
+ *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
+ *      extensions = "com.bumptech.glide.integration.gif.GifOptions"
+ *  )
+ *  public class Indexer_GlideExtension_com_bumptech_glide_integration_gif_GifOptions {
+ *  }
+ * </code>
+ * </pre>
+ * </p>
+ */
+final class IndexerGenerator {
+  private static final String INDEXER_NAME_PREFIX = "GlideIndexer_";
+  private final ProcessorUtil processorUtil;
+
+  IndexerGenerator(ProcessorUtil processorUtil) {
+    this.processorUtil = processorUtil;
+  }
+
+  TypeSpec generate(List<TypeElement> types) {
+    List<TypeElement> modules =  new ArrayList<>();
+    List<TypeElement> extensions = new ArrayList<>();
+    for (TypeElement element : types) {
+      if (processorUtil.isExtension(element)) {
+        extensions.add(element);
+      } else if (processorUtil.isLibraryGlideModule(element)) {
+        modules.add(element);
+      } else {
+        throw new IllegalArgumentException("Unrecognized type: " + element);
+      }
+    }
+    if (!modules.isEmpty() && !extensions.isEmpty()) {
+      throw new IllegalArgumentException("Given both modules and extensions, expected one or the "
+          + "other. Modules: " + modules + " Extensions: " + extensions);
+    }
+    if (!modules.isEmpty()) {
+      return generate(types, GlideModule.class);
+    } else {
+      return generate(types, GlideExtension.class);
+    }
+  }
+
+  private static TypeSpec generate(List<TypeElement> libraryModules,
+      Class<? extends Annotation> annotation) {
+    AnnotationSpec.Builder annotationBuilder =
+        AnnotationSpec.builder(Index.class);
+
+    String value = getAnnotationValue(annotation);
+    for (TypeElement childModule : libraryModules) {
+      annotationBuilder.addMember(value, "$S", ClassName.get(childModule).toString());
+    }
+
+    StringBuilder indexerName = new StringBuilder(
+        INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_");
+    for (TypeElement element : libraryModules) {
+      indexerName.append(element.getQualifiedName().toString().replace(".", "_"));
+      indexerName.append("_");
+    }
+    indexerName = new StringBuilder(indexerName.substring(0, indexerName.length() - 1));
+
+    return TypeSpec.classBuilder(indexerName.toString())
+        .addAnnotation(annotationBuilder.build())
+        .addModifiers(Modifier.PUBLIC)
+        .build();
+  }
+
+  private static String getAnnotationValue(Class<? extends Annotation> annotation) {
+    if (annotation == GlideModule.class) {
+      return "modules";
+    } else if (annotation == GlideExtension.class) {
+      return "extensions";
+    } else {
+      throw new IllegalArgumentException("Unrecognized annotation: " + annotation);
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
new file mode 100644
index 000000000..d6e6329a7
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates Indexer classes annotated with {@link Index} for all
+ * {@code LibraryGlideModule}s.
+ */
+final class LibraryModuleProcessor {
+  private final ProcessorUtil processorUtil;
+  private final IndexerGenerator indexerGenerator;
+
+  LibraryModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+    this.processorUtil = processorUtil;
+    this.indexerGenerator = indexerGenerator;
+  }
+
+  boolean processModules(RoundEnvironment env) {
+     // Order matters here, if we find an Indexer below, we return before writing the root module.
+    // If we fail to add to appModules before then, we might accidentally skip a valid RootModule.
+    List<TypeElement> libraryGlideModules = new ArrayList<>();
+    for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+      // Root elements are added separately and must be checked separately because they're sub
+      // classes of LibraryGlideModules.
+      if (processorUtil.isAppGlideModule(element)) {
+        continue;
+      } else if (!processorUtil.isLibraryGlideModule(element)) {
+        throw new IllegalStateException("@GlideModule can only be applied to LibraryGlideModule"
+            + " and AppGlideModule implementations, not: " + element);
+      }
+
+      libraryGlideModules.add(element);
+    }
+
+    processorUtil.debugLog("got child modules: " + libraryGlideModules);
+    if (libraryGlideModules.isEmpty()) {
+      return false;
+    }
+
+    TypeSpec indexer = indexerGenerator.generate(libraryGlideModules);
+    processorUtil.writeIndexer(indexer);
+    processorUtil.debugLog("Wrote an Indexer this round, skipping the app module to ensure all "
+        + "indexers are found");
+     // If I write an Indexer in a round in the target package, then try to find all classes in
+    // the target package, my newly written Indexer won't be found. Since we wrote a class with
+    // an Annotation handled by this processor, we know we will be called again in the next round
+    // and we can safely wait to write our AppGlideModule until then.
+    return true;
+  }
+
+  Set<String> getSupportedAnnotationTypes() {
+    return Collections.singleton(GlideModule.class.getName());
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
new file mode 100644
index 000000000..201dd604a
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -0,0 +1,494 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor.DEBUG;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import com.sun.tools.javac.code.Attribute;
+import com.sun.tools.javac.code.Type.ClassType;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+/**
+ * Utilities for writing classes and logging.
+ */
+final class ProcessorUtil {
+  private static final String GLIDE_MODULE_PACKAGE_NAME = "com.bumptech.glide.module";
+  private static final String APP_GLIDE_MODULE_SIMPLE_NAME = "AppGlideModule";
+  private static final String LIBRARY_GLIDE_MODULE_SIMPLE_NAME = "LibraryGlideModule";
+  private static final String APP_GLIDE_MODULE_QUALIFIED_NAME =
+      GLIDE_MODULE_PACKAGE_NAME + "." + APP_GLIDE_MODULE_SIMPLE_NAME;
+  private static final String LIBRARY_GLIDE_MODULE_QUALIFIED_NAME =
+      GLIDE_MODULE_PACKAGE_NAME + "." + LIBRARY_GLIDE_MODULE_SIMPLE_NAME;
+  private static final String COMPILER_PACKAGE_NAME =
+      GlideAnnotationProcessor.class.getPackage().getName();
+  private static final ClassName NONNULL_ANNOTATION =
+      ClassName.get("android.support.annotation", "NonNull");
+
+  private final ProcessingEnvironment processingEnv;
+  private final TypeElement appGlideModuleType;
+  private final TypeElement libraryGlideModuleType;
+  private int round;
+
+  ProcessorUtil(ProcessingEnvironment processingEnv) {
+    this.processingEnv = processingEnv;
+
+    appGlideModuleType =
+        processingEnv.getElementUtils().getTypeElement(APP_GLIDE_MODULE_QUALIFIED_NAME);
+    libraryGlideModuleType =
+        processingEnv.getElementUtils().getTypeElement(LIBRARY_GLIDE_MODULE_QUALIFIED_NAME);
+  }
+
+  void process() {
+    round++;
+  }
+
+  boolean isAppGlideModule(TypeElement element) {
+    return processingEnv.getTypeUtils().isAssignable(element.asType(),
+        appGlideModuleType.asType());
+  }
+
+  boolean isLibraryGlideModule(TypeElement element) {
+    return processingEnv.getTypeUtils().isAssignable(element.asType(),
+        libraryGlideModuleType.asType());
+  }
+
+  boolean isExtension(TypeElement element) {
+    return element.getAnnotation(GlideExtension.class) != null;
+  }
+
+  int getOverrideType(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption.override();
+  }
+
+  void writeIndexer(TypeSpec indexer) {
+    writeClass(COMPILER_PACKAGE_NAME, indexer);
+  }
+
+  void writeClass(String packageName, TypeSpec clazz) {
+    try {
+      debugLog("Writing class:\n" + clazz);
+      JavaFile.builder(packageName, clazz).build().writeTo(processingEnv.getFiler());
+    } catch (Throwable e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  List<ExecutableElement> findAnnotatedElementsInClasses(
+      Set<String> classNames, Class<? extends Annotation> annotationClass) {
+    List<ExecutableElement> result = new ArrayList<>();
+    for (String glideExtensionClassName : classNames) {
+      TypeElement glideExtension = processingEnv.getElementUtils()
+          .getTypeElement(glideExtensionClassName);
+      for (Element element : glideExtension.getEnclosedElements()) {
+        if (element.getAnnotation(annotationClass) != null) {
+          result.add((ExecutableElement) element);
+        }
+      }
+    }
+    return result;
+  }
+
+  List<TypeElement> getElementsFor(
+      Class<? extends Annotation> clazz, RoundEnvironment env) {
+    Collection<? extends Element> annotatedElements = env.getElementsAnnotatedWith(clazz);
+    return ElementFilter.typesIn(annotatedElements);
+  }
+
+  /**
+   * Generates a Javadoc code block for generated methods that delegate to methods in
+   * {@link GlideExtension}s.
+   *
+   * <p>The generated block looks something like this:
+   * <pre>
+   * <code>
+   *   {@literal @see} com.extension.package.name.ExtensionClassName#extensionMethod(arg1, argN)
+   * </code>
+   * </pre>
+   *
+   * @param method The method from the {@link GlideExtension} annotated class that the generated
+   * method this Javadoc will be attached to delegates to.
+   */
+  CodeBlock generateSeeMethodJavadoc(ExecutableElement method) {
+    // Use the simple name of the containing type instead of just the containing type's TypeMirror
+    // so that we avoid appending <CHILD> or other type arguments to the class and breaking
+    // Javadoc's linking.
+    // With this we get @see RequestOptions#methodName().
+    // With just ClassName.get(element.getEnclosingElement().asType()), we get:
+    // @see RequestOptions<CHILD>#methodName().
+    return generateSeeMethodJavadoc(getJavadocSafeName(method.getEnclosingElement()),
+        method.getSimpleName().toString(), method.getParameters());
+  }
+
+  /**
+   * Generates a Javadoc block for generated methods that delegate to other methods.
+   *
+   * <p>The generated block looks something like this:
+   * <pre>
+   * <code>
+   *     {@literal @see} com.package.ClassContainingMethod.methodSimpleName(
+   *         methodParam1, methodParamN)
+   * </code>
+   * </pre>
+   * @param nameOfClassContainingMethod The simple class name of the class containing the method
+   * without any generic types like {@literal <T>}.
+   * @param methodSimpleName The name of the method.
+   * @param methodParameters A maybe empty list of all the parameters for the method in question.
+   */
+  CodeBlock generateSeeMethodJavadoc(
+      TypeName nameOfClassContainingMethod, String methodSimpleName,
+      List<? extends VariableElement> methodParameters) {
+    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
+        methodSimpleName, Lists.transform(methodParameters,
+            new Function<VariableElement, Object>() {
+              @Override
+              public Object apply(VariableElement input) {
+                return getJavadocSafeName(input);
+              }
+            }));
+  }
+
+  CodeBlock generateSeeMethodJavadoc(
+      TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {
+    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
+        methodSpec.name, Lists.transform(methodSpec.parameters,
+            new Function<ParameterSpec, Object>() {
+              @Override
+              public Object apply(ParameterSpec input) {
+                return input.type;
+              }
+            }));
+  }
+
+  private CodeBlock generateSeeMethodJavadocInternal(
+      TypeName nameOfClassContainingMethod, String methodName,
+      List<Object> safeParameterNames) {
+    StringBuilder javadocString = new StringBuilder("@see $T#$L(");
+    List<Object> javadocArgs = new ArrayList<>();
+    javadocArgs.add(nameOfClassContainingMethod);
+    javadocArgs.add(methodName);
+
+    for (Object param : safeParameterNames) {
+      javadocString.append("$T, ");
+      javadocArgs.add(param);
+    }
+    if (javadocArgs.size() > 2) {
+      javadocString = new StringBuilder(javadocString.substring(0, javadocString.length() - 2));
+    }
+    javadocString.append(")\n");
+    return CodeBlock.of(javadocString.toString(), javadocArgs.toArray(new Object[0]));
+  }
+
+  /**
+   * Returns a safe String to use in a Javadoc that will function in a link.
+   *
+   * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>}
+   * in {@literal RequestOptions<T>} for example).
+   */
+  private TypeName getJavadocSafeName(Element element) {
+    Types typeUtils = processingEnv.getTypeUtils();
+    TypeMirror type = element.asType();
+    if (typeUtils.asElement(type) == null) {
+      // If there is no Element, it's a primitive and can't have additional types, so we're done.
+      return ClassName.get(element.asType());
+    }
+    Name simpleName = typeUtils.asElement(type).getSimpleName();
+    return ClassName.bestGuess(simpleName.toString());
+  }
+
+  void debugLog(String toLog) {
+    if (DEBUG) {
+      infoLog(toLog);
+    }
+  }
+
+  void infoLog(String toLog) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "[" + round + "] " + toLog);
+  }
+
+  void warnLog(String toLog) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, toLog);
+  }
+
+  static CodeBlock generateCastingSuperCall(TypeName toReturn, ExecutableElement method) {
+    return CodeBlock.builder()
+        .add("return ($T) super.$N(", toReturn, method.getSimpleName())
+        .add(
+            FluentIterable.from(method.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(",")))
+        .add(");\n")
+        .build();
+  }
+
+  static MethodSpec.Builder overriding(ExecutableElement method) {
+    String methodName = method.getSimpleName().toString();
+
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addAnnotation(Override.class);
+
+    Set<Modifier> modifiers = method.getModifiers();
+    modifiers = new LinkedHashSet<>(modifiers);
+    modifiers.remove(Modifier.ABSTRACT);
+    Modifier defaultModifier = null;
+    // Modifier.DEFAULT doesn't exist until Java 8.
+    try {
+      defaultModifier = Modifier.valueOf("DEFAULT");
+    } catch (IllegalArgumentException e) {
+      // Ignored.
+    }
+    modifiers.remove(defaultModifier);
+
+    builder = builder.addModifiers(modifiers);
+
+    for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {
+      TypeVariable var = (TypeVariable) typeParameterElement.asType();
+      builder = builder.addTypeVariable(TypeVariableName.get(var));
+    }
+
+    builder = builder.returns(TypeName.get(method.getReturnType()))
+        .addParameters(getParameters(method))
+        .varargs(method.isVarArgs());
+
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      builder = builder.addException(TypeName.get(thrownType));
+    }
+
+    return builder;
+  }
+
+  static List<ParameterSpec> getParameters(ExecutableElement method) {
+    return getParameters(method.getParameters());
+  }
+
+  static List<ParameterSpec> getParameters(List<? extends VariableElement> parameters) {
+    List<ParameterSpec> result = new ArrayList<>();
+    for (VariableElement parameter : parameters) {
+      result.add(getParameter(parameter));
+    }
+    return result;
+  }
+
+  private static ParameterSpec getParameter(VariableElement method) {
+    TypeName type = TypeName.get(method.asType());
+    String name = method.getSimpleName().toString();
+    return ParameterSpec.builder(type, name)
+        .addModifiers(method.getModifiers())
+        .addAnnotations(getAnnotations(method))
+        .build();
+  }
+
+  private static List<AnnotationSpec> getAnnotations(VariableElement element) {
+    List<AnnotationSpec> result = new ArrayList<>();
+    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
+      result.add(AnnotationSpec.get(mirror));
+    }
+    return result;
+  }
+
+  static ClassName nonNull() {
+    return NONNULL_ANNOTATION;
+  }
+
+  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeElement returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findStaticMethodsReturning(TypeElement clazz, TypeElement returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.STATIC))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findStaticMethods(TypeElement clazz) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods((TypeMirror) null /*returnType*/, MethodType.STATIC))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  Set<String> findClassValuesFromAnnotationOnClassAsNames(
+      Element clazz, Class<? extends Annotation> annotationClass) {
+    String annotationClassName = annotationClass.getName();
+    AnnotationValue excludedModuleAnnotationValue = null;
+    for (AnnotationMirror annotationMirror : clazz.getAnnotationMirrors()) {
+      // Two different AnnotationMirrors the same class might not be equal, so compare Strings
+      // instead. This check is necessary because a given class may have multiple Annotations.
+      if (!annotationClassName.equals(annotationMirror.getAnnotationType().toString())) {
+        continue;
+      }
+      Set<? extends Map.Entry<? extends ExecutableElement, ? extends AnnotationValue>> values =
+          annotationMirror.getElementValues().entrySet();
+      // Excludes has only one value. If we ever change that, we'd need to iterate over all
+      // values in the entry set and compare the keys to whatever our Annotation's attribute is
+      // (usually value).
+      if (values.size() != 1) {
+        throw new IllegalArgumentException("Expected single value, but found: " + values);
+      }
+      excludedModuleAnnotationValue = values.iterator().next().getValue();
+      if (excludedModuleAnnotationValue == null
+          || excludedModuleAnnotationValue instanceof Attribute.UnresolvedClass) {
+        throw new IllegalArgumentException(
+            "Failed to find value for: " + annotationClass + " from mirrors: "
+                + clazz.getAnnotationMirrors());
+      }
+    }
+    if (excludedModuleAnnotationValue == null) {
+      return Collections.emptySet();
+    }
+    Object value = excludedModuleAnnotationValue.getValue();
+    if (value instanceof List) {
+      List<?> values = (List<?>) value;
+      Set<String> result = new HashSet<>(values.size());
+      for (Object current : values) {
+        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));
+      }
+      return result;
+    } else {
+      ClassType classType = (ClassType) value;
+      return Collections.singleton(classType.toString());
+    }
+  }
+
+  // We should be able to cast to Attribute.Class rather than use reflection, but there are some
+  // compilers that seem to break when we do so. See #2673 for an example.
+  private static String getExcludedModuleClassFromAnnotationAttribute(
+      Element clazz, Object attribute) {
+    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {
+      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz
+          + ", one or more excluded Modules could not be found at compile time. Ensure that all"
+          + "excluded Modules are included in your classpath.");
+    }
+    Method[] methods = attribute.getClass().getDeclaredMethods();
+    if (methods == null || methods.length == 0) {
+      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz
+          + ", invalid exclude: " + attribute);
+    }
+    for (Method method : methods) {
+      if (method.getName().equals("getValue")) {
+        try {
+          return method.invoke(attribute).toString();
+        } catch (IllegalAccessException | InvocationTargetException e) {
+          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);
+        }
+      }
+    }
+    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);
+  }
+
+  private enum MethodType {
+    STATIC,
+    INSTANCE
+  }
+
+  private final class FilterPublicMethods implements Predicate<Element> {
+    @Nullable
+    private final TypeMirror returnType;
+    private final MethodType methodType;
+
+    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType) {
+      this.returnType = returnType;
+      this.methodType = methodType;
+    }
+
+    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType) {
+      this(returnType != null ? returnType.asType() : null, methodType);
+    }
+
+    @Override
+    public boolean apply(@Nullable Element input) {
+      if (input == null
+          || input.getKind() != ElementKind.METHOD
+          || !input.getModifiers().contains(Modifier.PUBLIC)) {
+        return false;
+      }
+      boolean isStatic = input.getModifiers().contains(Modifier.STATIC);
+      if (methodType == MethodType.STATIC && !isStatic) {
+        return false;
+      } else if (methodType == MethodType.INSTANCE && isStatic) {
+        return false;
+      }
+      ExecutableElement method = (ExecutableElement) input;
+      return returnType == null || isReturnValueTypeMatching(method, returnType);
+    }
+  }
+
+  boolean isReturnValueTypeMatching(ExecutableElement method, TypeElement expectedReturnType) {
+    return isReturnValueTypeMatching(method, expectedReturnType.asType());
+  }
+
+  private boolean isReturnValueTypeMatching(
+      ExecutableElement method, TypeMirror expectedReturnType) {
+    return processingEnv.getTypeUtils().isAssignable(
+        method.getReturnType(), expectedReturnType);
+  }
+
+  private static final class ToMethod implements Function<Element, ExecutableElement> {
+
+    @Nullable
+    @Override
+    public ExecutableElement apply(@Nullable Element input) {
+      return (ExecutableElement) input;
+    }
+  }
+
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
new file mode 100644
index 000000000..2486c8226
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -0,0 +1,461 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import com.squareup.javapoet.WildcardTypeName;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Generates a {@code com.bumptech.glide.RequestBuilder} subclass containing all methods from
+ * the base class, all methods from {@code com.bumptech.glide.request.RequestOptions} and all
+ * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated
+ * classes.
+ *
+ * <p>Generated code looks like this:
+ * <pre>
+ * <code>
+ * public final class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> {
+ *   GlideRequest(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+ *     super(transcodeClass, other);
+ *   }
+ *
+ *   GlideRequest(GlideContext context, RequestManager requestManager,
+ *       Class<TranscodeType> transcodeClass) {
+ *     super(context, requestManager ,transcodeClass);
+ *   }
+ *
+ *   {@literal @Override}
+ *   protected GlideRequest<File> getDownloadOnlyRequest() {
+ *    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+ *   }
+ *
+ *   /**
+ *    * {@literal @see} GlideOptions#dontAnimate()
+ *    *\/
+ *   public GlideRequest<TranscodeType> dontAnimate() {
+ *     if (getMutableOptions() instanceof GlideOptions) {
+ *       this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+ *     } else {
+ *       this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+ *     }
+ *     return this;
+ *   }
+ *
+ *   /**
+ *    * {@literal @see} RequestOptions#sizeMultiplier(float)
+ *    *\/
+ *   public GlideRequest<TranscodeType> sizeMultiplier(float sizeMultiplier) {
+ *     this.requestOptions = getMutableOptions().sizeMultiplier(sizeMultiplier);
+ *     return this;
+ *   }
+ *
+ *   ...
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestBuilderGenerator {
+  private static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  private static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
+
+  private static final String REQUEST_BUILDER_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String REQUEST_BUILDER_SIMPLE_NAME = "RequestBuilder";
+  static final String REQUEST_BUILDER_QUALIFIED_NAME =
+      REQUEST_BUILDER_PACKAGE_NAME + "." + REQUEST_BUILDER_SIMPLE_NAME;
+
+  // Uses package private methods and variables.
+  private static final String GENERATED_REQUEST_BUILDER_SIMPLE_NAME = "GlideRequest";
+
+  /**
+   * An arbitrary name of the Generic type in the generated RequestBuilder.
+   * e.g. RequestBuilder<TranscodeType>
+   */
+  private static final String TRANSCODE_TYPE_NAME = "TranscodeType";
+  /** A set of method names to avoid overriding from RequestOptions. */
+  private static final ImmutableSet<String> EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS =
+      ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");
+  private static final ClassName CHECK_RESULT_CLASS_NAME =
+      ClassName.get("android.support.annotation", "CheckResult");
+  private static final AnnotationSpec NON_NULL = AnnotationSpec.builder(nonNull()).build();
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private ClassName generatedRequestBuilderClassName;
+  private final TypeVariableName transcodeTypeName;
+  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;
+  private final TypeElement requestOptionsType;
+  private final TypeElement requestBuilderType;
+  private ClassName requestOptionsClassName;
+
+  RequestBuilderGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    requestBuilderType = processingEnv.getElementUtils()
+        .getTypeElement(REQUEST_BUILDER_QUALIFIED_NAME);
+
+    transcodeTypeName = TypeVariableName.get(TRANSCODE_TYPE_NAME);
+
+    requestOptionsType = processingEnv.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {
+    generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);
+    generatedRequestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);
+
+    if (generatedOptions != null) {
+      requestOptionsClassName =
+          ClassName.get(generatedCodePackageName, generatedOptions.name);
+    } else {
+      requestOptionsClassName =
+          ClassName.get(
+              RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,
+              RequestBuilderGenerator.REQUEST_OPTIONS_SIMPLE_NAME);
+    }
+
+    ParameterizedTypeName requestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(
+            ClassName.get(REQUEST_BUILDER_PACKAGE_NAME, REQUEST_BUILDER_SIMPLE_NAME),
+            transcodeTypeName);
+
+    return TypeSpec.classBuilder(GENERATED_REQUEST_BUILDER_SIMPLE_NAME)
+        .addJavadoc("Contains all public methods from {@link $T}, all options from\n",
+            requestBuilderType)
+        .addJavadoc("{@link $T} and all generated options from\n", requestOptionsType)
+        .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class)
+        .addJavadoc("{@link $T} annotated classes.\n", GlideExtension.class)
+        .addJavadoc("\n")
+        .addJavadoc("<p>Generated code, do not modify.\n")
+        .addJavadoc("\n")
+        .addJavadoc("@see $T\n", requestBuilderType)
+        .addJavadoc("@see $T\n", requestOptionsType)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "unused")
+                .addMember("value", "$S", "deprecation")
+                .build())
+        .addModifiers(Modifier.PUBLIC)
+        .addTypeVariable(transcodeTypeName)
+        .superclass(requestBuilderOfTranscodeType)
+        .addSuperinterface(Cloneable.class)
+        .addMethods(generateConstructors())
+        .addMethod(generateDownloadOnlyRequestMethod())
+        .addMethods(generateGeneratedRequestOptionsEquivalents(generatedOptions))
+        .addMethods(generateRequestBuilderOverrides())
+        .build();
+  }
+
+  /**
+   * Generates overrides of all methods in {@code com.bumptech.glide.RequestBuilder} that return
+   * {@code com.bumptech.glide.RequestBuilder} so that they return our generated subclass instead.
+   */
+  private List<MethodSpec> generateRequestBuilderOverrides() {
+    TypeMirror rawRequestBuilderType =
+        processingEnv.getTypeUtils().erasure(requestBuilderType.asType());
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestBuilderType, rawRequestBuilderType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestBuilderOverride(input);
+          }
+        });
+  }
+
+  /**
+   * Generates an override of a particular method in {@code com.bumptech.glide.RequestBuilder} that
+   * returns {@code com.bumptech.glide.RequestBuilder} so that it returns our generated subclass
+   * instead.
+   */
+  private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOverride) {
+    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // exactly one type argument, so this is safe unless those assumptions change.
+    TypeMirror typeArgument =
+        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
+
+    ParameterizedTypeName generatedRequestBuilderOfType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
+
+    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(",
+                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build());
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder = builder.addAnnotation(AnnotationSpec.get(mirror));
+    }
+
+    if (methodToOverride.isVarArgs()) {
+      builder = builder
+          .addModifiers(Modifier.FINAL)
+          .addAnnotation(SafeVarargs.class)
+          .addAnnotation(
+              AnnotationSpec.builder(SuppressWarnings.class)
+                  .addMember("value", "$S", "varargs")
+                  .build());
+    }
+
+    return builder.build();
+  }
+
+  /**
+   * Generates methods with equivalent names and arguments to methods annotated with
+   * {@link GlideOption} in
+   * {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
+   * {@code com.bumptech.glide.RequestBuilder} subclass.
+   */
+  private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(
+      @Nullable final TypeSpec generatedOptions) {
+    if (generatedOptions == null) {
+      return Collections.emptyList();
+    }
+    return FluentIterable
+        .from(generatedOptions.methodSpecs)
+        .filter(new Predicate<MethodSpec>() {
+          @Override
+          public boolean apply(MethodSpec input) {
+            return isUsefulGeneratedRequestOption(input);
+          }
+        })
+        .transform(new Function<MethodSpec, MethodSpec>() {
+          @Override
+          public MethodSpec apply(MethodSpec input) {
+            return generateGeneratedRequestOptionEquivalent(input);
+          }
+        })
+        .toList();
+  }
+
+  /**
+   * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our
+   * {@code com.bumptech.glide.RequestBuilder} subclass.
+   *
+   * <p>Only newly generated methods will be included in the generated
+   * {@code com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
+   * methods that override other methods to avoid duplicates.
+   */
+  private boolean isUsefulGeneratedRequestOption(MethodSpec requestOptionMethod) {
+    return
+        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionMethod.name)
+        && requestOptionMethod.hasModifier(Modifier.PUBLIC)
+        && !requestOptionMethod.hasModifier(Modifier.STATIC)
+        && requestOptionMethod.returnType.toString()
+            .equals(requestOptionsClassName.toString());
+  }
+
+   /**
+   * Generates a particular method with  an equivalent name and arguments to the given method
+   * from the generated {@code com.bumptech.glide.request.BaseRequestBuilder} subclass.
+   */
+  private MethodSpec generateGeneratedRequestOptionEquivalent(MethodSpec requestOptionMethod) {
+    CodeBlock callRequestOptionsMethod = CodeBlock.builder()
+        .add(".$N(", requestOptionMethod.name)
+        .add(FluentIterable.from(requestOptionMethod.parameters)
+            .transform(new Function<ParameterSpec, String>() {
+              @Override
+              public String apply(ParameterSpec input) {
+                return input.name;
+              }
+            })
+            .join(Joiner.on(", ")))
+        .add(");\n")
+        .build();
+
+    MethodSpec.Builder result = MethodSpec.methodBuilder(requestOptionMethod.name)
+        .addJavadoc(
+            processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod))
+        .addModifiers(Modifier.PUBLIC)
+        .varargs(requestOptionMethod.varargs)
+        .addAnnotations(
+            FluentIterable.from(requestOptionMethod.annotations)
+                .filter(new Predicate<AnnotationSpec>() {
+                  @Override
+                  public boolean apply(AnnotationSpec input) {
+                    return !input.type.equals(TypeName.get(Override.class))
+                        // SafeVarargs can only be applied to final methods. GlideRequest is
+                        // non-final to allow for mocking.
+                        && !input.type.equals(TypeName.get(SafeVarargs.class))
+                        // We need to combine warnings below.
+                        && !input.type.equals(TypeName.get(SuppressWarnings.class));
+                  }
+                })
+                .toList()
+        )
+        .addTypeVariables(requestOptionMethod.typeVariables)
+        .addParameters(requestOptionMethod.parameters)
+        .returns(generatedRequestBuilderOfTranscodeType)
+        .beginControlFlow(
+            "if (getMutableOptions() instanceof $T)", requestOptionsClassName)
+        .addCode("this.requestOptions = (($T) getMutableOptions())",
+            requestOptionsClassName)
+        .addCode(callRequestOptionsMethod)
+        .nextControlFlow("else")
+        .addCode(CodeBlock.of("this.requestOptions = new $T().apply(this.requestOptions)",
+            requestOptionsClassName))
+        .addCode(callRequestOptionsMethod)
+        .endControlFlow()
+        .addStatement("return this");
+
+    AnnotationSpec suppressWarnings = buildSuppressWarnings(requestOptionMethod);
+    if (suppressWarnings != null) {
+      result.addAnnotation(suppressWarnings);
+    }
+    return result.build();
+  }
+
+  @Nullable
+  private AnnotationSpec buildSuppressWarnings(MethodSpec requestOptionMethod) {
+    Set<String> suppressions = new HashSet<>();
+    if (requestOptionMethod.annotations.contains(
+        AnnotationSpec.builder(SuppressWarnings.class).build())) {
+      for (AnnotationSpec annotation : requestOptionMethod.annotations) {
+        if (annotation.type.equals(TypeName.get(SuppressWarnings.class))) {
+          List<CodeBlock> codeBlocks = annotation.members.get("value");
+          suppressions.addAll(FluentIterable.from(codeBlocks).transform(
+              new Function<CodeBlock, String>() {
+                @Override
+                public String apply(CodeBlock input) {
+                  return input.toString();
+                }
+              }).toSet());
+        }
+      }
+    }
+
+    if (requestOptionMethod.annotations.contains(
+        AnnotationSpec.builder(SafeVarargs.class).build())) {
+      suppressions.add("unchecked");
+      suppressions.add("varargs");
+    }
+
+    if (suppressions.isEmpty()) {
+      return null;
+    }
+    // Enforce ordering across compilers (Internal and External compilers end up disagreeing on the
+    // order produced by the Set additions above.)
+    ArrayList<String> suppressionsList = new ArrayList<>(suppressions);
+    Collections.sort(suppressionsList);
+
+    AnnotationSpec.Builder builder = AnnotationSpec.builder(SuppressWarnings.class);
+    for (String suppression : suppressionsList) {
+      builder.addMember("value", "$S", suppression);
+    }
+
+    return builder.build();
+  }
+
+  private List<MethodSpec> generateConstructors() {
+    ParameterizedTypeName classOfTranscodeType =
+        ParameterizedTypeName.get(ClassName.get(Class.class), transcodeTypeName);
+
+    TypeName wildcardOfObject = WildcardTypeName.subtypeOf(Object.class);
+    ParameterizedTypeName requestBuilderOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(requestBuilderType), wildcardOfObject);
+
+    MethodSpec firstConstructor =
+        MethodSpec.constructorBuilder()
+            .addParameter(ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(requestBuilderOfWildcardOfObject, "other")
+                .addAnnotation(nonNull())
+                .build()
+            )
+        .addStatement("super($N, $N)", "transcodeClass", "other")
+        .build();
+
+    ClassName context = ClassName.get("android.content", "Context");
+    ClassName glide = ClassName.get("com.bumptech.glide", "Glide");
+    ClassName requestManager = ClassName.get("com.bumptech.glide", "RequestManager");
+    MethodSpec secondConstructor =
+        MethodSpec.constructorBuilder()
+            .addParameter(ParameterSpec.builder(glide, "glide")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(requestManager, "requestManager")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(classOfTranscodeType, "transcodeClass")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addParameter(ParameterSpec.builder(context, "context")
+                .addAnnotation(nonNull())
+                .build()
+            )
+            .addStatement(
+                "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context")
+            .build();
+    return ImmutableList.of(firstConstructor, secondConstructor);
+  }
+
+  /**
+   * Overrides the protected downloadOnly method in {@code com.bumptech.glide.RequestBuilder} to
+   * return our generated subclass instead.
+   */
+  private MethodSpec generateDownloadOnlyRequestMethod() {
+    ParameterizedTypeName generatedRequestBuilderOfFile
+        = ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
+    return MethodSpec.methodBuilder("getDownloadOnlyRequest")
+        .addAnnotation(Override.class)
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(NON_NULL)
+        .returns(generatedRequestBuilderOfFile)
+        .addModifiers(Modifier.PROTECTED)
+        .addStatement("return new $T<>($T.class, $N).apply($N)",
+            generatedRequestBuilderClassName, File.class, "this",
+            "DOWNLOAD_ONLY_OPTIONS")
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
new file mode 100644
index 000000000..4aec3c8bb
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
@@ -0,0 +1,109 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeSpec;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates an implementation of
+ * {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
+ * generated {@code com.bumptech.glide.RequestManager} implementation.
+ *
+ * <p>Generated {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ * classes look like this:
+ * <pre>
+ * <code>
+ * public class GeneratedRequestManagerFactory
+ *     implements RequestManagerRetriever.RequestManagerFactory {
+ *   {@literal @Override}
+ *   public RequestManager build(Glide glide, Lifecycle lifecycle,
+ *       RequestManagerTreeNode treeNode) {
+ *     return new GeneratedRequestManager(glide, lifecycle, treeNode);
+ *   }
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestManagerFactoryGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+  private static final String LIFECYCLE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.Lifecycle";
+  private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerTreeNode";
+  private static final String REQUEST_MANAGER_FACTORY_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+  private static final ClassName CONTEXT_CLASS_NAME =
+      ClassName.get("android.content", "Context");
+
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME =
+      "com.bumptech.glide";
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME =
+      "GeneratedRequestManagerFactory";
+
+  private final TypeElement glideType;
+  private final TypeElement lifecycleType;
+  private final TypeElement requestManagerTreeNodeType;
+  private final TypeElement requestManagerFactoryInterface;
+  private final ClassName requestManagerClassName;
+
+  RequestManagerFactoryGenerator(ProcessingEnvironment processingEnv) {
+    Elements elementUtils = processingEnv.getElementUtils();
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+    lifecycleType = elementUtils.getTypeElement(LIFECYCLE_QUALIFIED_NAME);
+    requestManagerTreeNodeType =
+        elementUtils.getTypeElement(REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME);
+
+    requestManagerFactoryInterface =
+        elementUtils.getTypeElement(REQUEST_MANAGER_FACTORY_QUALIFIED_NAME);
+
+    TypeElement requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+    requestManagerClassName = ClassName.get(requestManagerType);
+
+  }
+
+  TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestManagerSpec) {
+    return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME)
+        .addModifiers(Modifier.FINAL)
+        .addSuperinterface(ClassName.get(requestManagerFactoryInterface))
+        .addJavadoc("Generated code, do not modify\n")
+        .addMethod(
+            MethodSpec.methodBuilder("build")
+                .addModifiers(Modifier.PUBLIC)
+                .addAnnotation(Override.class)
+                .addAnnotation(nonNull())
+                .returns(requestManagerClassName)
+                .addParameter(ParameterSpec.builder(ClassName.get(glideType), "glide")
+                    .addAnnotation(nonNull())
+                    .build()
+                )
+                .addParameter(ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+                    .addAnnotation(nonNull())
+                    .build()
+                )
+                .addParameter(
+                    ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                        .addAnnotation(nonNull())
+                        .build()
+                )
+                .addParameter(ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
+                    .addAnnotation(nonNull())
+                    .build()
+                )
+                .addStatement(
+                    "return new $T(glide, lifecycle, treeNode, context)",
+                    ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name))
+                .build()
+        )
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
new file mode 100644
index 000000000..31e646ddc
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -0,0 +1,363 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates an implementation of {@code com.bumptech.glide.RequestManager} that contains generated
+ * methods from {@link GlideExtension}s and {@link GlideType}.
+ *
+ * <p>Generated {@code com.bumptech.glide.RequestManager} implementations look like this:
+ * <pre>
+ * <code>
+ * public final class GeneratedRequestManager extends RequestManager {
+ *   GeneratedRequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+ *     super(glide, lifecycle, treeNode);
+ *   }
+ *
+ *   public RequestBuilder<GifDrawable> asGif() {
+ *     RequestBuilder<GifDrawable> requestBuilder = this.as(GifDrawable.class);
+ *     GifOptions.asGif(requestBuilder);
+ *     return requestBuilder;
+ *   }
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestManagerGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+  private static final String LIFECYCLE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.Lifecycle";
+  private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerTreeNode";
+  private static final ClassName CHECK_RESULT_CLASS_NAME =
+      ClassName.get("android.support.annotation", "CheckResult");
+  private static final ClassName CONTEXT_CLASS_NAME =
+      ClassName.get("android.content", "Context");
+
+  private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME =
+      "GlideRequests";
+
+  private ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final ClassName requestManagerClassName;
+  private final TypeElement lifecycleType;
+  private final TypeElement requestManagerTreeNodeType;
+  private final TypeElement glideType;
+  private final TypeElement requestManagerType;
+  private final TypeElement requestBuilderType;
+  private ClassName generatedRequestBuilderClassName;
+
+  RequestManagerGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    Elements elementUtils = processingEnv.getElementUtils();
+
+    requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+    requestManagerClassName = ClassName.get(requestManagerType);
+
+    lifecycleType = elementUtils.getTypeElement(LIFECYCLE_QUALIFIED_NAME);
+    requestManagerTreeNodeType =
+        elementUtils.getTypeElement(REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME);
+
+    requestBuilderType =
+        elementUtils.getTypeElement(RequestBuilderGenerator.REQUEST_BUILDER_QUALIFIED_NAME);
+
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(
+      String generatedCodePackageName, @Nullable TypeSpec requestOptions, TypeSpec requestBuilder,
+      Set<String> glideExtensions) {
+    generatedRequestBuilderClassName = ClassName.get(generatedCodePackageName, requestBuilder.name);
+    return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_SIMPLE_NAME)
+        .superclass(requestManagerClassName)
+        .addJavadoc("Includes all additions from methods in {@link $T}s\n"
+                + "annotated with {@link $T}\n"
+                + "\n"
+                + "<p>Generated code, do not modify\n",
+            GlideExtension.class, GlideType.class)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build())
+        .addModifiers(Modifier.PUBLIC)
+        .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
+        .addMethod(generateCallSuperConstructor())
+        .addMethods(generateExtensionRequestManagerMethods(glideExtensions))
+        .addMethods(generateRequestManagerRequestManagerMethodOverrides(generatedCodePackageName))
+        .addMethods(generateRequestManagerRequestBuilderMethodOverrides())
+        .addMethods(
+            FluentIterable.from(
+                Collections.singletonList(
+                    generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
+                .filter(Predicates.<MethodSpec>notNull()))
+        .build();
+  }
+
+  private MethodSpec generateCallSuperConstructor() {
+    return MethodSpec.constructorBuilder()
+        .addModifiers(Modifier.PUBLIC)
+        .addParameter(ParameterSpec.builder(ClassName.get(glideType), "glide")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addParameter(ParameterSpec.builder(ClassName.get(lifecycleType), "lifecycle")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addParameter(ParameterSpec.builder(ClassName.get(requestManagerTreeNodeType), "treeNode")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addParameter(ParameterSpec.builder(CONTEXT_CLASS_NAME, "context")
+            .addAnnotation(nonNull())
+            .build()
+        )
+        .addStatement("super(glide, lifecycle, treeNode, context)")
+        .build();
+  }
+
+  private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec requestBuilder) {
+    TypeVariableName resourceType = TypeVariableName.get("ResourceType");
+    ParameterizedTypeName classOfResouceType = ParameterizedTypeName
+        .get(ClassName.get(Class.class), resourceType);
+
+    ClassName generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, requestBuilder.name);
+
+    ParameterizedTypeName requestBuilderOfResourceType = ParameterizedTypeName
+        .get(generatedRequestBuilderClassName, resourceType);
+
+    return MethodSpec.methodBuilder("as")
+        .addModifiers(Modifier.PUBLIC)
+        .addAnnotation(Override.class)
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(nonNull())
+        .addTypeVariable(TypeVariableName.get("ResourceType"))
+        .returns(requestBuilderOfResourceType)
+        .addParameter(classOfResouceType.annotated(AnnotationSpec.builder(nonNull()).build()),
+            "resourceClass")
+        .addStatement("return new $T<>(glide, this, resourceClass, context)",
+            this.generatedRequestBuilderClassName)
+        .build();
+  }
+
+  /** Generates the list of overrides of methods that return {@code RequestManager}. */
+  private List<MethodSpec> generateRequestManagerRequestManagerMethodOverrides(
+      final String generatedPackageName) {
+    return FluentIterable.from(
+        processorUtil.findInstanceMethodsReturning(requestManagerType, requestManagerType))
+        .transform(new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(@Nullable ExecutableElement input) {
+            return generateRequestManagerRequestManagerMethodOverride(generatedPackageName, input);
+          }
+        })
+        .toList();
+  }
+
+  private MethodSpec generateRequestManagerRequestManagerMethodOverride(
+      String generatedPackageName, ExecutableElement method) {
+    ClassName generatedRequestManagerName =
+        ClassName.get(generatedPackageName, GENERATED_REQUEST_MANAGER_SIMPLE_NAME);
+    return ProcessorUtil.overriding(method)
+        .addAnnotation(nonNull())
+        .returns(generatedRequestManagerName)
+        .addCode(ProcessorUtil.generateCastingSuperCall(generatedRequestManagerName, method))
+        .build();
+  }
+
+  /** Generates the list of overrides of methods that return {@code RequestBuilder}. */
+  private List<MethodSpec> generateRequestManagerRequestBuilderMethodOverrides() {
+    // Without the erasure, this is a RequestBuilder<Y>. A RequestBuilder<X> is not assignable to a
+    // RequestBuilder<Y>. After type erasure this is a RequestBuilder. A RequestBuilder<X> is
+    // assignable to the raw RequestBuilder.
+    TypeMirror rawRequestBuilder = processingEnv.getTypeUtils()
+        .erasure(requestBuilderType.asType());
+
+    return FluentIterable.from(
+        processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
+        .filter(new Predicate<ExecutableElement>() {
+          @Override
+          public boolean apply(ExecutableElement input) {
+            // Skip the <T> as(Class<T>) method.
+            return !input.getSimpleName().toString().equals("as");
+          }
+        })
+        .transform(new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestManagerRequestBuilderMethodOverride(input);
+          }
+        })
+        .toList();
+  }
+
+  /**
+   * Generates overrides of existing RequestManager methods so that they return our generated
+   * RequestBuilder subtype.
+   */
+  private MethodSpec generateRequestManagerRequestBuilderMethodOverride(
+      ExecutableElement methodToOverride) {
+    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // exactly one type argument, so this is safe unless those assumptions change.
+    TypeMirror typeArgument =
+        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
+
+    ParameterizedTypeName generatedRequestBuilderOfType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
+
+    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType)
+        .addCode(
+            ProcessorUtil.generateCastingSuperCall(
+                generatedRequestBuilderOfType, methodToOverride));
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+    }
+    return builder.build();
+  }
+
+  private List<MethodSpec> generateExtensionRequestManagerMethods(
+      Set<String> glideExtensions) {
+    List<ExecutableElement> requestManagerExtensionMethods =
+        processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);
+
+    return Lists.transform(requestManagerExtensionMethods,
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateAdditionalRequestManagerMethod(input);
+          }
+        });
+  }
+
+  // Generates methods added to RequestManager via GlideExtensions.
+  private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement extensionMethod) {
+    if (extensionMethod.getReturnType().getKind() == TypeKind.VOID) {
+      return generateAdditionalRequestManagerMethodLegacy(extensionMethod);
+    } else {
+      return generateAdditionalRequestManagerMethodNew(extensionMethod);
+    }
+  }
+
+  private MethodSpec generateAdditionalRequestManagerMethodLegacy(
+      ExecutableElement extensionMethod) {
+    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
+        GlideType.class).iterator().next();
+    ClassName returnTypeClassName = ClassName.bestGuess(returnType);
+    ParameterizedTypeName parameterizedTypeName =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
+
+    return MethodSpec.methodBuilder(extensionMethod.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC)
+        .returns(parameterizedTypeName)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(nonNull())
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addStatement(
+            "$T requestBuilder = this.as($T.class)", parameterizedTypeName, returnTypeClassName)
+        .addStatement("$T.$N(requestBuilder)",
+            extensionMethod.getEnclosingElement(), extensionMethod.getSimpleName())
+        .addStatement("return requestBuilder")
+        .build();
+  }
+
+  private MethodSpec generateAdditionalRequestManagerMethodNew(
+      ExecutableElement extensionMethod) {
+    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
+        GlideType.class).iterator().next();
+    ClassName returnTypeClassName = ClassName.bestGuess(returnType);
+    ParameterizedTypeName parameterizedTypeName =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
+
+    return MethodSpec.methodBuilder(extensionMethod.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC)
+        .returns(parameterizedTypeName)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(nonNull())
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addStatement(
+            "return ($T) $T.$N(this.as($T.class))",
+            parameterizedTypeName,
+            extensionMethod.getEnclosingElement(),
+            extensionMethod.getSimpleName(),
+            returnTypeClassName)
+        .build();
+  }
+
+  /**
+   * The {@code RequestOptions} subclass should always be our
+   * generated subclass type to avoid inadvertent errors where a different subclass is applied that
+   * accidentally wipes out some logic in overidden methods in our generated subclass.
+   */
+  @Nullable
+  private MethodSpec generateOverrideSetRequestOptions(
+      String generatedCodePackageName, @Nullable TypeSpec generatedRequestOptions) {
+    if (generatedRequestOptions == null) {
+      return null;
+    }
+
+    Elements elementUtils = processingEnv.getElementUtils();
+    TypeElement requestOptionsType =
+        elementUtils.getTypeElement(
+            RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
+
+    // This class may have just been generated and therefore may not be found if we try to obtain
+    // it via Elements, so use just the String version instead.
+    String generatedRequestOptionsQualifiedName =
+        generatedCodePackageName + "." + generatedRequestOptions.name;
+
+    String methodName = "setRequestOptions";
+    String parameterName = "toSet";
+
+    return MethodSpec.methodBuilder(methodName)
+        .addAnnotation(Override.class)
+        .addModifiers(Modifier.PROTECTED)
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(requestOptionsType), parameterName)
+                .addAnnotation(nonNull())
+                .build())
+        .beginControlFlow("if ($N instanceof $L)",
+            parameterName, generatedRequestOptionsQualifiedName)
+        .addStatement("super.$N($N)", methodName, parameterName)
+        .nextControlFlow("else")
+        .addStatement("super.setRequestOptions(new $L().apply($N))",
+            generatedRequestOptionsQualifiedName, parameterName)
+        .endControlFlow()
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
new file mode 100644
index 000000000..852ebc5c0
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -0,0 +1,675 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;
+import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
+import com.google.common.base.Preconditions;
+import com.google.common.base.Strings;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.CodeBlock.Builder;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+
+/**
+ * Generates a new implementation of {@code com.bumptech.glide.request.RequestOptions}
+ * containing static versions of methods included in the base class and static and instance versions
+ * of all methods annotated with {@link GlideOption} in classes annotated with
+ * {@link GlideExtension}.
+ *
+ * <p>The generated class looks something like this:
+ * <pre>
+ * <code>
+ * public final class GlideOptions extends com.bumptech.glide.request.RequestOptions {
+ *
+ *   public static com.google.android.apps.photos.glide.GlideOptions signatureOf(
+ *       com.bumptech.glide.load.Key arg0) {
+ *     return new com.google.android.apps.photos.glide.GlideOptions()
+ *         .apply(com.bumptech.glide.request.RequestOptions.signatureOf(arg0));
+ *   }
+ *
+ *   ... // The rest of the static versions of methods from RequestOptions go here.
+ *
+ *   // Now on to methods generated from an extension:
+ *   public com.bumptech.glide.GlideOptions dontAnimate() {
+ *     com.bumptech.glide.integration.gifdecoder.GifOptions.dontAnimate(this);
+ *     return this;
+ *   }
+ *
+ *   public static com.bumptech.glide.GlideOptions noAnimation() {
+ *     return new com.bumptech.glide.GlideOptions().dontAnimate();
+ *   }
+ * }
+ * </code>
+ * </pre>
+ * </p>
+ */
+final class RequestOptionsGenerator {
+  private static final String GENERATED_REQUEST_OPTIONS_SIMPLE_NAME = "GlideOptions";
+  static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
+  private static final ClassName CHECK_RESULT_CLASS_NAME =
+      ClassName.get("android.support.annotation", "CheckResult");
+
+  private final ProcessingEnvironment processingEnvironment;
+  private final ClassName requestOptionsName;
+  private final TypeElement requestOptionsType;
+  private final ProcessorUtil processorUtil;
+  private ClassName glideOptionsName;
+  private int nextStaticFieldUniqueId;
+
+  RequestOptionsGenerator(
+      ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
+    this.processingEnvironment = processingEnvironment;
+    this.processorUtil = processorUtil;
+
+    requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME,
+        REQUEST_OPTIONS_SIMPLE_NAME);
+
+    requestOptionsType = processingEnvironment.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(String generatedCodePackageName, Set<String> glideExtensionClassNames) {
+    glideOptionsName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_OPTIONS_SIMPLE_NAME);
+
+    List<MethodAndStaticVar> methodsForExtensions =
+        generateMethodsForExtensions(glideExtensionClassNames);
+
+    Set<MethodSignature> extensionMethodSignatures = ImmutableSet.copyOf(
+        Iterables.transform(methodsForExtensions,
+            new Function<MethodAndStaticVar, MethodSignature>() {
+              @Nullable
+              @Override
+              public MethodSignature apply(MethodAndStaticVar f) {
+                return new MethodSignature(f.method);
+              }
+            }));
+
+    List<MethodAndStaticVar> staticOverrides = generateStaticMethodOverridesForRequestOptions();
+    List<MethodSpec> instanceOverrides = generateInstanceMethodOverridesForRequestOptions();
+
+    List<MethodAndStaticVar> allMethodsAndStaticVars = new ArrayList<>();
+    for (MethodAndStaticVar item : staticOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(item.method))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(item);
+    }
+    for (MethodSpec methodSpec : instanceOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(methodSpec))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(new MethodAndStaticVar(methodSpec));
+    }
+    allMethodsAndStaticVars.addAll(methodsForExtensions);
+
+    TypeSpec.Builder classBuilder = TypeSpec.classBuilder(GENERATED_REQUEST_OPTIONS_SIMPLE_NAME)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build())
+        .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
+        .addModifiers(Modifier.FINAL)
+        .addModifiers(Modifier.PUBLIC)
+        .addSuperinterface(Cloneable.class)
+        .superclass(requestOptionsName);
+
+    for (MethodAndStaticVar methodAndStaticVar : allMethodsAndStaticVars) {
+      if (methodAndStaticVar.method != null) {
+        classBuilder.addMethod(methodAndStaticVar.method);
+      }
+      if (methodAndStaticVar.staticField != null) {
+        classBuilder.addField(methodAndStaticVar.staticField);
+      }
+    }
+    return classBuilder.build();
+  }
+
+  private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
+    Builder builder = CodeBlock.builder()
+        .add("Automatically generated from {@link $T} annotated classes.\n",
+            GlideExtension.class)
+        .add("\n")
+        .add("@see $T\n", requestOptionsName);
+
+    for (String glideExtensionClass : glideExtensionClassNames) {
+      builder.add("@see $T\n", ClassName.bestGuess(glideExtensionClass));
+    }
+    return builder.build();
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForExtensions(
+      Set<String> glideExtensionClassNames) {
+    List<ExecutableElement> requestOptionExtensionMethods =
+        processorUtil.findAnnotatedElementsInClasses(
+            glideExtensionClassNames, GlideOption.class);
+
+    List<MethodAndStaticVar> result = new ArrayList<>(requestOptionExtensionMethods.size());
+    for (ExecutableElement requestOptionsExtensionMethod : requestOptionExtensionMethods) {
+      result.addAll(generateMethodsForRequestOptionsExtension(requestOptionsExtensionMethod));
+    }
+
+    return result;
+  }
+
+  private List<MethodSpec> generateInstanceMethodOverridesForRequestOptions() {
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestOptionsType, requestOptionsType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestOptionOverride(input);
+          }
+        });
+  }
+
+  private MethodSpec generateRequestOptionOverride(ExecutableElement methodToOverride) {
+    MethodSpec.Builder result = ProcessorUtil.overriding(methodToOverride)
+        .returns(glideOptionsName)
+        .addModifiers(Modifier.FINAL)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(", glideOptionsName, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build());
+
+    if (methodToOverride.getSimpleName().toString().equals("transforms")) {
+      result
+          .addAnnotation(SafeVarargs.class)
+          .addAnnotation(
+              AnnotationSpec.builder(SuppressWarnings.class)
+                  .addMember("value", "$S", "varargs")
+                  .build());
+    }
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      result.addAnnotation(AnnotationSpec.get(mirror));
+    }
+
+    return result.build();
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtension(
+      ExecutableElement element) {
+    if (element.getReturnType().getKind() == TypeKind.VOID) {
+      processorUtil.warnLog(
+          "The " + element.getSimpleName() + " method annotated with @GlideOption in the "
+              + element.getEnclosingElement().getSimpleName() + " @GlideExtension is using a legacy"
+              + " format. Support will be removed in a future version. Please change your method"
+              + " definition so that your @GlideModule annotated methods return RequestOptions"
+              + " objects instead of null.");
+      return generateMethodsForRequestOptionsExtensionDeprecated(element);
+    } else {
+      return generateMethodsForRequestOptionsExtensionNew(element);
+    }
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtensionNew(
+      ExecutableElement element) {
+    int overrideType = processorUtil.getOverrideType(element);
+
+    String methodName = element.getSimpleName().toString();
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addModifiers(Modifier.PUBLIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+        .varargs(element.isVarArgs())
+        .returns(glideOptionsName);
+
+    // The 0th element is expected to be a RequestOptions object.
+    List<? extends VariableElement> parameters =
+        element.getParameters().subList(1, element.getParameters().size());
+    builder.addParameters(ProcessorUtil.getParameters(parameters));
+
+    String extensionRequestOptionsArgument;
+    if (overrideType == OVERRIDE_EXTEND) {
+      builder
+          .addJavadoc(
+              processorUtil.generateSeeMethodJavadoc(requestOptionsName, methodName, parameters))
+          .addAnnotation(Override.class);
+
+      List<Object> methodArgs = new ArrayList<>();
+      methodArgs.add(element.getSimpleName().toString());
+      StringBuilder methodLiterals = new StringBuilder();
+      if (!parameters.isEmpty()) {
+        for (VariableElement variable : parameters) {
+          methodLiterals.append("$L, ");
+          methodArgs.add(variable.getSimpleName().toString());
+        }
+        methodLiterals = new StringBuilder(
+            methodLiterals.substring(0, methodLiterals.length() - 2));
+      }
+      extensionRequestOptionsArgument = CodeBlock.builder()
+          .add("super.$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
+          .build()
+          .toString();
+    } else {
+      extensionRequestOptionsArgument = "this";
+    }
+
+    List<Object> args = new ArrayList<>();
+    StringBuilder code = new StringBuilder("return ($T) $T.$L($L, ");
+    args.add(glideOptionsName);
+    args.add(ClassName.get(element.getEnclosingElement().asType()));
+    args.add(element.getSimpleName().toString());
+    args.add(extensionRequestOptionsArgument);
+    if (!parameters.isEmpty()) {
+      for (VariableElement variable : parameters) {
+        code.append("$L, ");
+        args.add(variable.getSimpleName().toString());
+      }
+    }
+    code = new StringBuilder(code.substring(0, code.length() - 2));
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
+
+    builder
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(nonNull());
+
+    List<MethodAndStaticVar> result = new ArrayList<>();
+    result.add(new MethodAndStaticVar(builder.build()));
+    MethodAndStaticVar methodAndVar = generateStaticMethodEquivalentForExtensionMethod(element);
+    if (methodAndVar != null) {
+      result.add(methodAndVar);
+    }
+
+    return result;
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtensionDeprecated(
+      ExecutableElement element) {
+    int overrideType = processorUtil.getOverrideType(element);
+
+    String methodName = element.getSimpleName().toString();
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addModifiers(Modifier.PUBLIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+        .varargs(element.isVarArgs())
+        .returns(glideOptionsName);
+
+    // The 0th element is expected to be a RequestOptions object.
+    List<? extends VariableElement> parameters =
+        element.getParameters().subList(1, element.getParameters().size());
+    builder.addParameters(ProcessorUtil.getParameters(parameters));
+
+    // Generates the String and list of arguments to pass in when calling this method or super.
+    // IE centerCrop(context) creates methodLiterals="%L" and methodArgs=[centerCrop, context].
+    List<Object> methodArgs = new ArrayList<>();
+    methodArgs.add(element.getSimpleName().toString());
+    StringBuilder methodLiterals = new StringBuilder();
+    if (!parameters.isEmpty()) {
+      for (VariableElement variable : parameters) {
+        methodLiterals.append("$L, ");
+        methodArgs.add(variable.getSimpleName().toString());
+      }
+      methodLiterals = new StringBuilder(methodLiterals.substring(0, methodLiterals.length() - 2));
+    }
+
+    builder.beginControlFlow("if (isAutoCloneEnabled())")
+        .addStatement(
+            "return clone().$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
+        .endControlFlow();
+
+    // Add the correct super() call.
+    if (overrideType == OVERRIDE_EXTEND) {
+      String callSuper = "super.$L(" + methodLiterals + ")";
+      builder.addStatement(callSuper, methodArgs.toArray(new Object[0]))
+          .addJavadoc(processorUtil.generateSeeMethodJavadoc(
+              requestOptionsName, methodName, parameters))
+          .addAnnotation(Override.class);
+    }
+
+    // Adds: <AnnotatedClass>.<thisMethodName>(RequestOptions<?>, <arg1>, <arg2>, <argN>);
+    List<Object> args = new ArrayList<>();
+    StringBuilder code = new StringBuilder("$T.$L($L, ");
+    args.add(ClassName.get(element.getEnclosingElement().asType()));
+    args.add(element.getSimpleName().toString());
+    args.add("this");
+    if (!parameters.isEmpty()) {
+      for (VariableElement variable : parameters) {
+        code.append("$L, ");
+        args.add(variable.getSimpleName().toString());
+      }
+    }
+    code = new StringBuilder(code.substring(0, code.length() - 2));
+    code.append(")");
+    builder.addStatement(code.toString(), args.toArray(new Object[0]));
+
+    builder.addStatement("return this")
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(nonNull());
+
+    List<MethodAndStaticVar> result = new ArrayList<>();
+    result.add(new MethodAndStaticVar(builder.build()));
+    MethodAndStaticVar methodAndVar = generateStaticMethodEquivalentForExtensionMethod(element);
+    if (methodAndVar != null) {
+      result.add(methodAndVar);
+    }
+
+    return result;
+  }
+
+  private List<MethodAndStaticVar> generateStaticMethodOverridesForRequestOptions() {
+    List<ExecutableElement> staticMethodsThatReturnRequestOptions =
+        processorUtil.findStaticMethodsReturning(requestOptionsType, requestOptionsType);
+    List<MethodAndStaticVar> staticMethods = new ArrayList<>();
+    for (ExecutableElement element : staticMethodsThatReturnRequestOptions) {
+      if (element.getAnnotation(Deprecated.class) != null) {
+        continue;
+      }
+      staticMethods.add(generateStaticMethodEquivalentForRequestOptionsStaticMethod(element));
+    }
+    return staticMethods;
+  }
+
+  /**
+   * This method is a bit of a hack, but it lets us tie the static version of a method with the
+   * instance version. In turn that lets us call the instance versions on the generated subclass,
+   * instead of just delegating to the RequestOptions static methods. Using the instance methods
+   * on the generated subclass allows our static methods to properly call code that overrides
+   * an existing method in RequestOptions.
+   *
+   * <p>The string names here just map between the static methods in
+   * {@code com.bumptech.glide.request.RequestOptions} and the instance methods they call.
+   */
+  private static String getInstanceMethodNameFromStaticMethodName(String staticMethodName) {
+    String equivalentInstanceMethodName;
+    if ("bitmapTransform".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "transform";
+    } else if ("decodeTypeOf".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "decode";
+    } else if (staticMethodName.endsWith("Transform")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 9);
+    } else if (staticMethodName.endsWith("Of")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 2);
+    } else if ("noTransformation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontTransform";
+    } else if ("noAnimation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontAnimate";
+    } else if (staticMethodName.equals("option")) {
+      equivalentInstanceMethodName = "set";
+    } else {
+      throw new IllegalArgumentException("Unrecognized static method name: " + staticMethodName);
+    }
+    return equivalentInstanceMethodName;
+  }
+
+  private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStaticMethod(
+      ExecutableElement staticMethod) {
+    boolean memoize = memoizeStaticMethodFromArguments(staticMethod);
+    String staticMethodName = staticMethod.getSimpleName().toString();
+
+    String equivalentInstanceMethodName =
+        getInstanceMethodNameFromStaticMethodName(staticMethodName);
+
+    MethodSpec.Builder methodSpecBuilder =
+        MethodSpec.methodBuilder(staticMethodName)
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
+            .returns(glideOptionsName);
+
+    List<? extends VariableElement> parameters = staticMethod.getParameters();
+    StringBuilder createNewOptionAndCall = createNewOptionAndCall(memoize, methodSpecBuilder,
+        parameters, "new $T().$N(", ProcessorUtil.getParameters(staticMethod));
+
+    FieldSpec requiredStaticField = null;
+    if (memoize) {
+      // Generates code that looks like:
+      // if (GlideOptions.<methodName> == null) {
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
+      // }
+
+      // Mix in an incrementing unique id to handle method overloading.
+      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
+          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+          .build();
+      methodSpecBuilder.beginControlFlow(
+          "if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName, staticVariableName, glideOptionsName, equivalentInstanceMethodName,
+              "autoClone()")
+          .endControlFlow()
+          .addStatement("return $T.$N", glideOptionsName, staticVariableName);
+    } else {
+      // Generates code that looks like:
+      // return new GlideOptions().<methodName>()
+      methodSpecBuilder.addStatement(
+          "return " + createNewOptionAndCall, glideOptionsName, equivalentInstanceMethodName);
+    }
+
+    List<? extends TypeParameterElement> typeParameters = staticMethod.getTypeParameters();
+    for (TypeParameterElement typeParameterElement : typeParameters) {
+      methodSpecBuilder.addTypeVariable(
+          TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
+    }
+
+    methodSpecBuilder
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
+        .addAnnotation(nonNull());
+
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
+  }
+
+  private static boolean memoizeStaticMethodFromArguments(ExecutableElement staticMethod) {
+    return staticMethod.getParameters().isEmpty()
+        || (staticMethod.getParameters().size() == 1
+        && staticMethod.getParameters().get(0).getSimpleName().toString()
+        .equals("android.content.Context"));
+  }
+
+  @Nullable
+  private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
+      ExecutableElement instanceMethod) {
+    boolean skipStaticMethod = skipStaticMethod(instanceMethod);
+    if (skipStaticMethod) {
+      return null;
+    }
+    String staticMethodName = getStaticMethodName(instanceMethod);
+    String instanceMethodName = instanceMethod.getSimpleName().toString();
+    if (Strings.isNullOrEmpty(staticMethodName)) {
+      if (instanceMethodName.startsWith("dont")) {
+        staticMethodName = "no" + instanceMethodName.replace("dont", "");
+      } else {
+        staticMethodName = instanceMethodName + "Of";
+      }
+    }
+    boolean memoize = memoizeStaticMethodFromAnnotation(instanceMethod);
+
+    //noinspection ResultOfMethodCallIgnored
+    Preconditions.checkNotNull(staticMethodName);
+    MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
+        .varargs(instanceMethod.isVarArgs())
+        .returns(glideOptionsName);
+
+    List<? extends VariableElement> parameters = instanceMethod.getParameters();
+
+    // Always remove the first parameter because it's always RequestOptions in extensions. The
+    // actual method we want to generate will pass the RequestOptions in to the extension method,
+    // but should not itself require a RequestOptions object to be passed in.
+    if (parameters.isEmpty()) {
+      throw new IllegalArgumentException(
+          "Expected non-empty parameters for: " + instanceMethod);
+    }
+    // Remove is not supported.
+    parameters = parameters.subList(1, parameters.size());
+
+    StringBuilder createNewOptionAndCall = createNewOptionAndCall(memoize, methodSpecBuilder,
+        parameters, "new $T().$L(", ProcessorUtil.getParameters(parameters));
+
+    FieldSpec requiredStaticField = null;
+    if (memoize) {
+      // Generates code that looks like:
+      // if (GlideOptions.<methodName> == null) {
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
+      // }
+
+      // Mix in an incrementing unique id to handle method overloading.
+      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
+          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+          .build();
+      methodSpecBuilder.beginControlFlow(
+          "if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName, staticVariableName, glideOptionsName, instanceMethodName,
+              "autoClone()")
+          .endControlFlow()
+          .addStatement("return $T.$N", glideOptionsName, staticVariableName);
+    } else {
+      // Generates code that looks like:
+      // return new GlideOptions().<methodName>()
+      methodSpecBuilder.addStatement(
+          "return " + createNewOptionAndCall, glideOptionsName, instanceMethodName);
+    }
+
+    List<? extends TypeParameterElement> typeParameters = instanceMethod.getTypeParameters();
+    for (TypeParameterElement typeParameterElement : typeParameters) {
+      methodSpecBuilder.addTypeVariable(
+          TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
+    }
+
+    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
+
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
+  }
+
+  private StringBuilder createNewOptionAndCall(boolean memoize,
+      MethodSpec.Builder methodSpecBuilder,
+      List<? extends VariableElement> parameters, String start, List<ParameterSpec> specs) {
+    StringBuilder createNewOptionAndCall = new StringBuilder(start);
+    if (!parameters.isEmpty()) {
+      methodSpecBuilder.addParameters(specs);
+      for (VariableElement parameter : parameters) {
+        createNewOptionAndCall.append(parameter.getSimpleName().toString());
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall.append(".getApplicationContext()");
+        }
+        createNewOptionAndCall.append(", ");
+      }
+      createNewOptionAndCall = new StringBuilder(
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2));
+    }
+    createNewOptionAndCall.append(")");
+    return createNewOptionAndCall;
+  }
+
+  private boolean isAndroidContext(VariableElement variableElement) {
+    Element element = processingEnvironment.getTypeUtils().asElement(variableElement.asType());
+    return element.toString().equals("android.content.Context");
+  }
+
+  @Nullable
+  private static String getStaticMethodName(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    String result = glideOption != null ? glideOption.staticMethodName() : null;
+    return Strings.emptyToNull(result);
+  }
+
+  private static boolean memoizeStaticMethodFromAnnotation(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption != null && glideOption.memoizeStaticMethod();
+  }
+
+  private static boolean skipStaticMethod(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption != null && glideOption.skipStaticMethod();
+  }
+
+  private static final class MethodAndStaticVar {
+    @Nullable final MethodSpec method;
+    @Nullable final FieldSpec staticField;
+
+    MethodAndStaticVar(@Nullable MethodSpec method) {
+      this(method, null /*staticField*/);
+    }
+
+    MethodAndStaticVar(@Nullable MethodSpec method, @Nullable FieldSpec staticField) {
+      this.method = method;
+      this.staticField = staticField;
+    }
+  }
+
+  private static final class MethodSignature {
+    private final TypeName returnType;
+    private final List<TypeName> parameterTypes;
+    private final boolean isStatic;
+    private final String name;
+
+    MethodSignature(MethodSpec spec) {
+      name = spec.name;
+      isStatic = spec.modifiers.contains(Modifier.STATIC);
+      returnType = spec.returnType;
+      parameterTypes =
+          Lists.transform(spec.parameters, new Function<ParameterSpec, TypeName>() {
+            @Nullable
+            @Override
+            public TypeName apply(ParameterSpec parameterSpec) {
+              return parameterSpec.type;
+
+            }
+          });
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof MethodSignature) {
+        MethodSignature other = (MethodSignature) o;
+        return name.equals(other.name)
+            && returnType.equals(other.returnType)
+            && parameterTypes.equals(other.parameterTypes)
+            && isStatic == other.isStatic;
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hashCode(name, returnType, parameterTypes, isStatic);
+    }
+  }
+}
diff --git a/annotation/compiler/test/.gitignore b/annotation/compiler/test/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/compiler/test/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/compiler/test/build.gradle b/annotation/compiler/test/build.gradle
new file mode 100644
index 000000000..5bb534de3
--- /dev/null
+++ b/annotation/compiler/test/build.gradle
@@ -0,0 +1,51 @@
+apply plugin: 'java'
+
+sourceSets {
+    test {
+        output.resourcesDir = "build/classes/java/test"
+    }
+}
+
+// This special test only submodule exists because adding the :glide dependency seems to break
+// the annotation processor dependency chain for the internal sample apps. It's also somewhat
+// easier to parse as a separate module given the existing complexity here and in the compiler
+dependencies {
+    // build.gradle file.
+    testImplementation project(':glide')
+    testImplementation project(':annotation:compiler')
+    testImplementation "com.squareup:javapoet:${JAVAPOET_VERSION}"
+    testImplementation "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}"
+    testImplementation "com.google.code.findbugs:jsr305:${JSR_305_VERSION}"
+    // Using 0.10 of compile-testing is required for Android Studio to function, but not for the
+    // gradle build. Not yet clear why, but it looks like some kind of version conflict between
+    // javapoet, guava and/or truth.
+    //noinspection GradleDependency
+    testImplementation 'com.google.testing.compile:compile-testing:0.10'
+    // Use a stupidly old version of the Android classes jar. This works because we just need to get
+    // our generated classes to compile and our generated classes tend to use simple and stable
+    // Android APIs. If that changes, we'll need to find an alternative.
+    testImplementation 'com.google.android:android:4.1.1.4'
+    // Use a stupidly old version of v4 because it's a jar. The newer support v4 packages are aars,
+    // which we can't depend on in a standard Java test. Since our usage of v4 is pretty simple,
+    // hopefully this will continue to work going forward.
+    testImplementation 'com.google.android:support-v4:r6'
+    testImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+}
+
+task regenerateTestResources {
+    group 'Verification'
+    description 'Regenerates all test resource files under annotation/compiler/test/src/test/resources that are compared against the current output to detect regressions'
+    tasks.withType(Test) {
+        systemProperties.put("com.bumptech.glide.annotation.compiler.test.regenerate.path", projectDir)
+    }
+    doFirst {
+        println("Regenerating test resources....")
+    }
+    doLast {
+        println("Finished regenerating test resources")
+    }
+}
+regenerateTestResources.finalizedBy(test)
+
+test.maxParallelForks = 2
+
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
new file mode 100644
index 000000000..323a4b151
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class.
+ */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithExcludesTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("AppModuleWithExcludes.java"),
+                emptyLibraryModule());
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
new file mode 100644
index 000000000..86fb5b02b
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules that use the @Excludes annotation with multiple excluded Module classes.
+ */
+@RunWith(JUnit4.class)
+public class AppGlideModuleWithMultipleExcludesTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("AppModuleWithMultipleExcludes.java"),
+                forResource("EmptyLibraryModule1.java"),
+                forResource("EmptyLibraryModule2.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
new file mode 100644
index 000000000..d9c18209d
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java
@@ -0,0 +1,122 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.libraryResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding both an empty {@link com.bumptech.glide.module.AppGlideModule} and an empty
+ * {@link com.bumptech.glide.module.LibraryGlideModule} in a single project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyAppAndLibraryGlideModulesTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                emptyLibraryModule());
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedIndexer() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(libraryResource(expectedClassName + ".java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
new file mode 100644
index 000000000..8af5e23d9
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding a single {@link com.bumptech.glide.test.EmptyAppModule} in a project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyAppGlideModuleTest {
+  private static final String MODULE_NAME = "EmptyAppModule.java";
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(forResource(MODULE_NAME));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(6);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(forResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
+
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
new file mode 100644
index 000000000..f4776d227
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding a single {@link com.bumptech.glide.module.LibraryGlideModule} in a project.
+ */
+@RunWith(JUnit4.class)
+public class EmptyLibraryGlideModuleTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private static final String MODULE_NAME = "EmptyLibraryModule.java";
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(forResource(MODULE_NAME));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(1);
+  }
+
+  @Test
+  public void compilation_generatesExpectedIndexer() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(expectedClassName + ".java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
new file mode 100644
index 000000000..8c2588db1
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java
@@ -0,0 +1,146 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.SubDirectory;
+import com.bumptech.glide.annotation.compiler.test.TestDescription;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies only the output we expect to change based on the various configurations of GlideOptions.
+ *
+ * <p>The output for all classes is tested in {@link LegacyGlideExtensionWithOptionTest}.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionOptionsTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  @Rule public final TestDescription testDescription = new TestDescription();
+  private static final String EXTENSION_NAME = "Extension.java";
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtendMultipleArguments")
+  public void compilation_withOverrideReplace_andMultipleArguments_validOptions()
+      throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtendMultipleArguments")
+  public void compilation_withOverrideReplace_andMultipleArguments_validRequest()
+      throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  private enum Subject {
+    GlideOptions,
+    GlideRequest;
+
+    String file() {
+      return name() + ".java";
+    }
+  }
+
+  private void runTest(Subject subject) throws IOException {
+    String subDir = getSubDirectoryName();
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                extension(subDir));
+    assertThat(compilation).succeededWithoutWarnings();
+
+    assertThat(compilation)
+        .generatedSourceFile(subpackage(subject.name()))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(subDir, subject.file()).getCharContent(true)));
+  }
+
+  private String getSubDirectoryName() {
+    return testDescription
+        .getDescription()
+        .getAnnotation(SubDirectory.class)
+        .value();
+  }
+
+  private JavaFileObject extension(String subdir) {
+    return forResource(subdir, EXTENSION_NAME);
+  }
+
+  private JavaFileObject forResource(String subdir, String name) {
+    return Util.forResource(getClass().getSimpleName(), subdir + "/" + name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
new file mode 100644
index 000000000..a67555ea8
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java
@@ -0,0 +1,107 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension option in the new
+ * option style where extension methods always return values.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionWithOptionTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithOption.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
new file mode 100644
index 000000000..af4a4b747
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java
@@ -0,0 +1,106 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension type.
+ */
+@RunWith(JUnit4.class)
+public class GlideExtensionWithTypeTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithType.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
new file mode 100644
index 000000000..e99c6160c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests AppGlideModules with invalid usages of the @Excludes annotation.
+ */
+// Ignore warnings since most methods use ExpectedException
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidAppGlideModuleWithExcludesTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  @Test
+  public void compilation_withMissingExcludedModuleClass_throws() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            JavaFileObjects.forSourceLines(
+                "AppModuleWithExcludes",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.Excludes;",
+                "import com.bumptech.glide.annotation.GlideModule;",
+                "import com.bumptech.glide.module.AppGlideModule;",
+                "import com.bumptech.glide.test.EmptyLibraryModule;",
+                "@GlideModule",
+                "@Excludes(EmptyLibraryModule.class)",
+                "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+  }
+
+  @Test
+  public void compilation_withEmptyExcludes_fails() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "AppModuleWithExcludes",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.Excludes;",
+                    "import com.bumptech.glide.annotation.GlideModule;",
+                    "import com.bumptech.glide.module.AppGlideModule;",
+                    "import com.bumptech.glide.test.EmptyLibraryModule;",
+                    "@GlideModule",
+                    "@Excludes",
+                    "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+    assertThat(compilation).failed();
+  }
+
+  @Test
+  public void compilation_withNonGlideModule_throws() {
+     Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "AppModuleWithExcludes",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.Excludes;",
+                    "import com.bumptech.glide.annotation.GlideModule;",
+                    "import com.bumptech.glide.module.AppGlideModule;",
+                    "import com.bumptech.glide.test.EmptyLibraryModule;",
+                    "@GlideModule",
+                    "@Excludes(Object.class)",
+                    "public final class AppModuleWithExcludes extends AppGlideModule {}"));
+    assertThat(compilation).failed();
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
new file mode 100644
index 000000000..c1a47efa2
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
@@ -0,0 +1,132 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s themselves.
+ */
+// Avoid warnings when using ExpectedException.
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideExtensionTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  @Test
+  public void compilation_withPublicConstructor_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PublicConstructor",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class PublicConstructor { }"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("non-private constructor");
+      Truth.assertThat(cause.getMessage()).contains("PublicConstructor");
+
+    }
+  }
+
+  @Test
+  public void compilation_withPackagePrivateExtension_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PackagePrivateExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "class PackagePrivateExtension {",
+                  "  private PackagePrivateExtension() {}",
+                  "}"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("must be public");
+      Truth.assertThat(cause.getMessage()).contains("PackagePrivateExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withConstructorWithParameters_throws() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "ConstructorParametersExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class ConstructorParametersExtension {",
+                  "  private ConstructorParametersExtension(int failParam) {}",
+                  "  public void doSomething() {}",
+                  "}"));
+      fail("Failed to get expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("parameters in the constructor");
+      Truth.assertThat(cause.getMessage()).contains("ConstructorParametersExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withNonStaticMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  public void doSomething() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withStaticMethod_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  public static void doSomething() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
new file mode 100644
index 000000000..a0be89706
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
@@ -0,0 +1,341 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s for methods annotated
+ * with {@link com.bumptech.glide.annotation.GlideOption}.
+ */
+// Ignore warnings since most methods use ExpectedException
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideOptionsExtensionTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  @Test
+  public void compilation_withAnnotatedNonStaticMethod_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public void doSomething() {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgInWrongOrder_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "NonRequestOptionsFirstArgExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.RequestOptions;",
+                  "@GlideExtension",
+                  "public class NonRequestOptionsFirstArgExtension{",
+                  "  private NonRequestOptionsFirstArgExtension() {}",
+                  "  @GlideOption",
+                  "  public static void doSomething(Object arg1, RequestOptions options) {}",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestOptions object as their first parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("NonRequestOptionsFirstArgExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArg_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static void doSomething(RequestOptions options) {}",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining("is using a legacy format.");
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgAndOtherArg_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static void doSomething(RequestOptions options, Object arg2) {}",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining("is using a legacy format.");
+  }
+
+  @Test
+  public void compilation_overridingOptionWithoutAnnotationType_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static void centerCrop(RequestOptions options) {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withOverrideExtend_butNotOverridingMethod_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
+                "  public static void something(RequestOptions options) {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withOverrideExtend_andOverridingMethod_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)",
+                "  public static void centerCrop(RequestOptions options) {}",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining("is using a legacy format.");
+  }
+
+  @Test
+  public void compilation_withOverrideReplace_butNotOverridingMethod_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
+                "  public static void something(RequestOptions options) {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withOverrideReplace_andOverridingMethod_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)",
+                "  public static void centerCrop(RequestOptions options) {}",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining("is using a legacy format.");
+  }
+
+  @Test
+  public void compilation_withRequestOptionsReturnValue_succeeds() {
+     Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import android.support.annotation.NonNull;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @NonNull",
+                "  @GlideOption",
+                "  public static RequestOptions doSomething(RequestOptions options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withNonRequestOptionsReturnValue_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.RequestOptions;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static Object doSomething(RequestOptions options) {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideOption methods should return a RequestOptions object");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withMissingNonNullAnnotation_warns() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static RequestOptions doSomething(RequestOptions options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#doSomething");
+  }
+
+  @Test
+  public void compilation_withNoOptionParameters_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "MissingRequestOptionsExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.RequestOptions;",
+                  "@GlideExtension",
+                  "public class MissingRequestOptionsExtension {",
+                  "  private MissingRequestOptionsExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static RequestOptions doSomething() {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestOptions object as their first parameter");
+      Truth.assertThat(message).contains("doSomething");
+      Truth.assertThat(message).contains("MissingRequestOptionsExtension");
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
new file mode 100644
index 000000000..9076f806e
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
@@ -0,0 +1,354 @@
+package com.bumptech.glide.annotation.compiler;
+
+
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
+
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.io.IOException;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Checks assertions on {@link com.bumptech.glide.annotation.GlideExtension}s for methods annotated
+ * with {@link com.bumptech.glide.annotation.GlideType}.
+ */
+// Ignore warnings since most methods use ExpectedException
+@SuppressWarnings("ResultOfMethodCallIgnored")
+@RunWith(JUnit4.class)
+public class InvalidGlideTypeExtensionTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  @Test
+  public void compilation_withAnnotatedNonStaticMethod_fails() {
+    expectedException.expectMessage("@GlideType methods must be static");
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public void doSomething() {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withoutRequestBuilderArg_fails() {
+    expectedException
+        .expectMessage(
+            "@GlideType methods must take a RequestBuilder object as their first and only"
+                + " parameter, but given multiple for:"
+                + " com.bumptech.glide.test.Extension#doSomething()");
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static void doSomething() {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestBuilderArg_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static void type(RequestBuilder<Number> builder) {}",
+                "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withNonRequestBuilderArg_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongParameterTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongParameterTypeExtension {",
+                  "  private WrongParameterTypeExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static void type(Object arg) {}",
+                  "}"));
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestBuilder object as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongParameterTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_withRequestBuilderArgAndOtherArg_fails() {
+    expectedException
+        .expectMessage(
+            "@GlideType methods must take a RequestBuilder object as their first and only"
+                + " parameter, but given multiple for:"
+                + " com.bumptech.glide.test.Extension#type("
+                + "com.bumptech.glide.RequestBuilder<java.lang.Number>,"
+                + "java.lang.Object)");
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static void type(RequestBuilder<Number> builder, Object arg2) {}",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_overridingExistingType_fails()
+      throws IOException {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import android.graphics.drawable.Drawable;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideType(Drawable.class)",
+                    "  public static void asDrawable(RequestBuilder<Drawable> builder) {}",
+                    "}"));
+    expectedException
+        .expectMessage(
+            "error: method asDrawable() is already defined in class"
+                + " com.bumptech.glide.test.GlideRequests");
+    compilation.generatedSourceFile(subpackage("GlideRequests"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_succeeds() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import android.support.annotation.NonNull;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @NonNull",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> asNumber(",
+                    "      RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningNonRequestBuilder_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static Object asNumber(",
+                  "      RequestBuilder<Number> builder) {",
+                  "    return new Object();",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("@GlideType methods should return a RequestBuilder");
+      Truth.assertThat(message).contains("Number");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilderWithIncorrectType_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongBuilderTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongBuilderTypeExtension {",
+                  "  private WrongBuilderTypeExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Object> asNumber(",
+                  "      RequestBuilder<Object> builder) {",
+                  "    return builder;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideType methods should return a RequestBuilder<java.lang.Number>");
+      Truth.assertThat(message)
+          .contains("WrongBuilderTypeExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilder_andMultipleParams_fails() {
+    expectedException.expectMessage(
+        "@GlideType methods must take a RequestBuilder object as their first and only parameter,"
+            + " but given multiple for:"
+            + " com.bumptech.glide.test.Extension#asNumber("
+            + "com.bumptech.glide.RequestBuilder<java.lang.Number>,java.lang.Object)");
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static RequestBuilder<Number> asNumber(",
+                "      RequestBuilder<Number> builder, Object arg1) {",
+                "    return builder;",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningBuilder_nonBuilderParam_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "IncorrectParameterExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class IncorrectParameterExtension {",
+                  "  private IncorrectParameterExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Number> asNumber(",
+                  "      Object arg) {",
+                  "    return null;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("@GlideType methods must take a RequestBuilder object"
+          + " as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("IncorrectParameterExtension");
+    }
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_missingNonNull_warns() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> asNumber(",
+                    "      RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#asNumber");
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionOptionsTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionOptionsTest.java
new file mode 100644
index 000000000..5087f3be9
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionOptionsTest.java
@@ -0,0 +1,134 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.SubDirectory;
+import com.bumptech.glide.annotation.compiler.test.TestDescription;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies only the output we expect to change based on the various configurations of GlideOptions
+ * when GlideOptions are defined in the legacy format.
+ *
+ * <p>The output for all classes is tested in {@link LegacyGlideExtensionWithOptionTest}.
+ */
+@RunWith(JUnit4.class)
+public class LegacyGlideExtensionOptionsTest {
+  @Rule public final TestDescription testDescription = new TestDescription();
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+
+  private static final String EXTENSION_NAME = "Extension.java";
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideExtend")
+  public void compilation_withOverrideExtend_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("OverrideReplace")
+  public void compilation_withOverrideReplace_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("StaticMethodName")
+  public void compilation_withStaticMethodName_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("MemoizeStaticMethod")
+  public void compilation_withMemoizeStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validOptions() throws IOException {
+    runTest(Subject.GlideOptions);
+  }
+
+  @Test
+  @SubDirectory("SkipStaticMethod")
+  public void compilation_withSkipStaticMethod_validRequest() throws IOException {
+    runTest(Subject.GlideRequest);
+  }
+
+  private enum Subject {
+    GlideOptions,
+    GlideRequest;
+
+    String file() {
+      return name() + ".java";
+    }
+  }
+
+  private void runTest(Subject subject) throws IOException {
+    String subDirectoryName = getSubDirectoryName();
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                extension(subDirectoryName));
+    assertThat(compilation).succeeded();
+
+    assertThat(compilation)
+        .generatedSourceFile(subpackage(subject.name()))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(subDirectoryName, subject.file()).getCharContent(true)));
+  }
+
+  private String getSubDirectoryName() {
+    return testDescription
+        .getDescription()
+        .getAnnotation(SubDirectory.class)
+        .value();
+  }
+
+  private JavaFileObject extension(String subdir) {
+    return forResource(subdir, EXTENSION_NAME);
+  }
+
+  private JavaFileObject forResource(String subdir, String name) {
+    return Util.forResource(getClass().getSimpleName(), subdir + "/" + name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithOptionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithOptionTest.java
new file mode 100644
index 000000000..933402ff3
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithOptionTest.java
@@ -0,0 +1,113 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension option in the legacy
+ * option style where extension methods always returned {@code null}.
+ */
+@RunWith(JUnit4.class)
+public class LegacyGlideExtensionWithOptionTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithOption.java"));
+    assertThat(compilation).succeeded();
+    //noinspection ResultOfMethodCallIgnored
+    assertThat(compilation).hadWarningContaining(
+        "The squareThumb method annotated with @GlideOption in the ExtensionWithOption"
+            + " @GlideExtension is using a legacy format. Support will be removed in a future"
+            + " version. Please change your method definition so that your @GlideModule annotated"
+            + " methods return RequestOptions objects instead of null.");
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithTypeTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithTypeTest.java
new file mode 100644
index 000000000..52b19d890
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/LegacyGlideExtensionWithTypeTest.java
@@ -0,0 +1,106 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.appResource;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
+import static com.bumptech.glide.annotation.compiler.test.Util.glide;
+import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.ReferencedResource;
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Verifies the output of the processor with a simple single extension type.
+ */
+@RunWith(JUnit4.class)
+public class LegacyGlideExtensionWithTypeTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                forResource("ExtensionWithType.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(7);
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideOptions"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGlideRequestClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequest"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));
+  }
+
+  @Test
+  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideRequests"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilationGeneratesExpectedGlideAppClass() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(subpackage("GlideApp"))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));
+  }
+
+  @Test
+  @ReferencedResource
+  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {
+    assertThat(compilation)
+        .generatedSourceFile(glide("GeneratedRequestManagerFactory"))
+        .contentsAsUtf8String()
+        .isEqualTo(
+            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
new file mode 100644
index 000000000..cecf9f748
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleAppGlideModuleTest.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.testing.compile.Compilation;
+import javax.tools.JavaFileObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Ensures that adding more than one {@link com.bumptech.glide.module.AppGlideModule} to a project
+ * will fail.
+ */
+@RunWith(JUnit4.class)
+public class MultipleAppGlideModuleTest {
+  private static final String FIRST_MODULE = "EmptyAppModule1.java";
+  private static final String SECOND_MODULE = "EmptyAppModule2.java";
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  // Throws.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void compilation_withTwoAppModules_fails() {
+    expectedException.expect(RuntimeException.class);
+    javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(forResource(FIRST_MODULE), forResource(SECOND_MODULE));
+  }
+
+  @Test
+  public void compilation_withFirstModuleOnly_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(forResource(FIRST_MODULE));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_withSecondModuleOnly_succeeds() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(forResource(SECOND_MODULE));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
new file mode 100644
index 000000000..94e1c27b7
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/MultipleEmptyLibraryGlideModuleTest.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.annotation;
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;
+import com.bumptech.glide.annotation.compiler.test.Util;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
+import java.io.IOException;
+import javax.tools.JavaFileObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests adding multiple {@link com.bumptech.glide.module.LibraryGlideModule}s in a project.
+ */
+@RunWith(JUnit4.class)
+public class MultipleEmptyLibraryGlideModuleTest {
+  @Rule public final RegenerateResourcesRule regenerateResourcesRule =
+      new RegenerateResourcesRule(getClass());
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  private Compilation compilation;
+
+  @Before
+  public void setUp() {
+    compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                forResource("EmptyLibraryModule1.java"),
+                forResource("EmptyLibraryModule2.java"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void compilation_generatesAllExpectedFiles() {
+    Truth.assertThat(compilation.generatedSourceFiles()).hasSize(1);
+  }
+
+  @Test
+  public void compilation_generatesExpectedIndexerForModules() throws IOException {
+    String expectedClassName =
+        "GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide"
+            + "_test_EmptyLibraryModule2";
+    assertThat(compilation)
+        .generatedSourceFile(annotation(expectedClassName))
+        .contentsAsUtf8String()
+        .isEqualTo(asUnixChars(forResource(expectedClassName + ".java").getCharContent(true)));
+  }
+
+  private JavaFileObject forResource(String name) {
+    return Util.forResource(getClass().getSimpleName(), name);
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
new file mode 100644
index 000000000..b7194411d
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/ReferencedResource.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that the method in question is referencing a test resource that it doesn't "own" and
+ * should not attempt to regenerate.
+ *
+ * <p>Used by {@link RegenerateResourcesRule} to ensure that if we are regenerating resources,
+ * we're only regenerating them for a single class and only for the single class that has the
+ * correct name and directory sequence so that we update the correct file.
+ *
+ * <p>Ideally this wouldn't be necessary. It would be great if we could find a way to go from the
+ * test failure more directly to the actual path of the resource used. Right now we're basically
+ * guessing based on this annotation, the class name of the test class, and any values from
+ * {@link SubDirectory}. Without this annotation, we'd end up writing files that were never used.
+ */
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ReferencedResource {
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
new file mode 100644
index 000000000..66f48c767
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/RegenerateResourcesRule.java
@@ -0,0 +1,101 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;
+
+import android.support.annotation.NonNull;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import org.junit.ComparisonFailure;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Regenerates test resources for annotation compiler tests when the
+ * {@link Util#REGENERATE_TEST_RESOURCES_PROPERTY_NAME} property is set to the directory containing
+ * the project.
+ *
+ * <p>This can easily be used via gradle by running:
+ * {@code
+ *  ./gradlew :annotation:compiler:test:regenerateTestResources
+ * }
+ *
+ * <p>Our regenerate task will set the appropriate environment variables that will allow the logic
+ * here to succeed. When running the tests normally, this class will do nothing.
+ */
+public final class RegenerateResourcesRule implements TestRule {
+
+  private final Class<?> testClass;
+
+  public RegenerateResourcesRule(Class<?> testClass) {
+    this.testClass = testClass;
+  }
+
+  @Override
+  public Statement apply(final Statement base, final Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } catch (ComparisonFailure e) {
+          String projectRoot = Util.getProjectRootIfRegeneratingTestResources();
+          if (projectRoot == null || description.getAnnotation(ReferencedResource.class) != null) {
+            throw e;
+          }
+          updateResourceFile(e, projectRoot, description);
+        }
+      }
+    };
+  }
+
+  private void updateResourceFile(
+      ComparisonFailure e, @NonNull String projectDirectory, Description description) {
+    String testClassName = testClass.getSimpleName();
+    String testFileName = parseFileNameFromMessage(e);
+    String testDirectory = projectDirectory + "/src/test/resources/" + testClassName;
+    String subDirectorySegment =
+        description.getAnnotation(SubDirectory.class) != null
+            ? description.getAnnotation(SubDirectory.class).value() + "/"
+            : "";
+
+    File expectedDirectory = new File(testDirectory + "/" + subDirectorySegment);
+    if (!expectedDirectory.exists() && !expectedDirectory.mkdirs()) {
+      throw new IllegalStateException(
+          "Failed to generate expected directory: " + expectedDirectory);
+    }
+    if (!expectedDirectory.isDirectory()) {
+      throw new IllegalStateException(
+          "Expected a directory, but found a file: " + expectedDirectory);
+    }
+
+    File expectedFile = new File(expectedDirectory, testFileName);
+    Writer writer = null;
+    try {
+      writer = new FileWriter(expectedFile);
+      writer.write(asUnixChars(e.getActual()).toString());
+      writer.close();
+    } catch (IOException e1) {
+      throw new RuntimeException("Failed to regenerate test file", e1);
+    } finally {
+      if (writer != null) {
+        try {
+          writer.close();
+        } catch (IOException exception) {
+          // Ignore.
+        }
+      }
+    }
+  }
+
+  // Parses </SOURCE_OUTPUT/com/bumptech/glide/test/GlideOptions.java> to GlideOptions.java.
+  private static String parseFileNameFromMessage(ComparisonFailure e) {
+    String message = e.getMessage();
+    int firstGreaterThanIndex = message.indexOf('>');
+    String substring = message.substring(0, firstGreaterThanIndex);
+    int lastForwardSlashIndex = substring.lastIndexOf('/');
+    return substring.substring(lastForwardSlashIndex + 1, substring.length());
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
new file mode 100644
index 000000000..c0023498a
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/SubDirectory.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates the subdirectory for a particular test that contains the test resource(s) used for the
+ * method.
+ *
+ * <p>Used both by tests to extract the correct subdirectory and by the
+ * {@link RegenerateResourcesRule} for the same purpose.
+ */
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SubDirectory {
+  String value();
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
new file mode 100644
index 000000000..2b4c7c72c
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/TestDescription.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import org.junit.rules.TestWatcher;
+import org.junit.runner.Description;
+
+/**
+ * Exposes the {@link Description} for the current test, similar to
+ * {@link org.junit.rules.TestName}.
+ */
+public final class TestDescription extends TestWatcher {
+  private Description description;
+  @Override
+  protected void starting(Description description) {
+    this.description = description;
+  }
+
+  public Description getDescription() {
+    return description;
+  }
+}
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
new file mode 100644
index 000000000..64c4f9f08
--- /dev/null
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/test/Util.java
@@ -0,0 +1,87 @@
+package com.bumptech.glide.annotation.compiler.test;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+
+/** Test utilities. */
+public final class Util {
+  private static final String REGENERATE_TEST_RESOURCES_PROPERTY_NAME =
+      "com.bumptech.glide.annotation.compiler.test.regenerate.path";
+  private static final String GLIDE_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String SUB_PACKAGE_NAME = qualified(GLIDE_PACKAGE_NAME, "test");
+  private static final String ANNOTATION_PACKAGE_NAME = "com.bumptech.glide.annotation.compiler";
+  private static final String DEFAULT_APP_DIR_NAME = "EmptyAppGlideModuleTest";
+  private static final String DEFAULT_LIBRARY_DIR_NAME = "EmptyLibraryGlideModuleTest";
+  /**
+   * Hardcoded file separator to workaround {@code JavaFileObjects.forResource(...)} defaulting to
+   * the unix one.
+   */
+  private static final String FILE_SEPARATOR = "/";
+  private static final String LINE_SEPARATOR = "\n";
+
+  private Util() {
+    // Utility class.
+  }
+
+  /**
+   * Returns the {@code String} from a system property that is expected to contain the project
+   * directory for the module containing these tests or {@code null} if we're not currently
+   * attempting to regenerate test resources.
+   */
+  static String getProjectRootIfRegeneratingTestResources() {
+    return System.getProperty(REGENERATE_TEST_RESOURCES_PROPERTY_NAME);
+  }
+
+  public static JavaFileObject emptyAppModule() {
+    return appResource("EmptyAppModule.java");
+  }
+
+  public static JavaFileObject emptyLibraryModule() {
+    return libraryResource("EmptyLibraryModule.java");
+  }
+
+  public static JavaFileObject appResource(String className) {
+    return forResource(DEFAULT_APP_DIR_NAME, className);
+  }
+
+  public static JavaFileObject libraryResource(String className) {
+    return forResource(DEFAULT_LIBRARY_DIR_NAME, className);
+  }
+
+  public static JavaFileObject forResource(String directoryName, String name) {
+    try {
+      return JavaFileObjects.forResource(directoryName + FILE_SEPARATOR + name);
+    } catch (IllegalArgumentException e) {
+      // IllegalArgumentException will be thrown if the resource is missing. If we're trying to
+      // generate test resources for a new test, we want to avoid this exception because it does not
+      // contain any expected output that we can write to a file. By returning an empty file, we
+      // avoid the exception and get the output from our comparison tests that we can then write
+      // out.
+      // If we're not regenerating test resources, we should throw the normal exception.
+      if (getProjectRootIfRegeneratingTestResources() != null) {
+        return JavaFileObjects.forSourceString("com.bumptech.test.empty", "");
+      }
+      throw e;
+    }
+  }
+
+  public static String annotation(String className) {
+    return qualified(ANNOTATION_PACKAGE_NAME, className);
+  }
+
+  public static String subpackage(String className) {
+    return qualified(SUB_PACKAGE_NAME, className);
+  }
+
+  public static String glide(String className) {
+    return qualified(GLIDE_PACKAGE_NAME, className);
+  }
+
+  public static CharSequence asUnixChars(CharSequence chars) {
+    return chars.toString().replace(System.lineSeparator(), LINE_SEPARATOR);
+  }
+
+  private static String qualified(String packageName, String className) {
+    return packageName + '.' + className;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java
new file mode 100644
index 000000000..579bb5ab3
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.test.EmptyLibraryModule;
+
+@GlideModule
+@Excludes(EmptyLibraryModule.class)
+public final class AppModuleWithExcludes extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..ecb3b4b05
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithExcludes;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithExcludes appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new AppModuleWithExcludes();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithExcludes");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java
new file mode 100644
index 000000000..c530727e1
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java
@@ -0,0 +1,11 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.test.EmptyLibraryModule1;
+import com.bumptech.glide.test.EmptyLibraryModule2;
+
+@GlideModule
+@Excludes({EmptyLibraryModule1.class, EmptyLibraryModule2.class})
+public final class AppModuleWithMultipleExcludes extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java
new file mode 100644
index 000000000..236008a91
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule1 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java
new file mode 100644
index 000000000..8a43eb292
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/EmptyLibraryModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule2 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..af059c6b1
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.AppModuleWithMultipleExcludes;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.HashSet;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final AppModuleWithMultipleExcludes appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new AppModuleWithMultipleExcludes();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.AppModuleWithMultipleExcludes");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule1");
+      Log.d("Glide", "AppGlideModule excludes LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule2");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule1.class);
+    excludedClasses.add(com.bumptech.glide.test.EmptyLibraryModule2.class);
+    return excludedClasses;
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..6e307e0ff
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.EmptyAppModule;
+import com.bumptech.glide.test.EmptyLibraryModule;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.Collections;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final EmptyAppModule appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new EmptyAppModule();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.EmptyAppModule");
+      Log.d("Glide", "Discovered LibraryGlideModule from annotation: com.bumptech.glide.test.EmptyLibraryModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    new EmptyLibraryModule().registerComponents(context, glide, registry);
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    return Collections.emptySet();
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java
new file mode 100644
index 000000000..203f9df63
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/EmptyAppModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
new file mode 100644
index 000000000..f960738d9
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java
@@ -0,0 +1,51 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.test.EmptyAppModule;
+import java.lang.Class;
+import java.lang.Override;
+import java.lang.SuppressWarnings;
+import java.util.Collections;
+import java.util.Set;
+
+@SuppressWarnings("deprecation")
+final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {
+  private final EmptyAppModule appGlideModule;
+
+  GeneratedAppGlideModuleImpl() {
+    appGlideModule = new EmptyAppModule();
+    if (Log.isLoggable("Glide", Log.DEBUG)) {
+      Log.d("Glide", "Discovered AppGlideModule from annotation: com.bumptech.glide.test.EmptyAppModule");
+    }
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    appGlideModule.applyOptions(context, builder);
+  }
+
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    appGlideModule.registerComponents(context, glide, registry);
+  }
+
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return appGlideModule.isManifestParsingEnabled();
+  }
+
+  @Override
+  @NonNull
+  public Set<Class<?>> getExcludedModuleClasses() {
+    return Collections.emptySet();
+  }
+
+  @Override
+  @NonNull
+  GeneratedRequestManagerFactory getRequestManagerFactory() {
+    return new GeneratedRequestManagerFactory();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
new file mode 100644
index 000000000..2a442b0a5
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.test.GlideRequests;
+import java.lang.Override;
+
+/**
+ * Generated code, do not modify
+ */
+final class GeneratedRequestManagerFactory implements RequestManagerRetriever.RequestManagerFactory {
+  @Override
+  @NonNull
+  public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    return new GlideRequests(glide, lifecycle, treeNode, context);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
new file mode 100644
index 000000000..a6b2b8941
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java
@@ -0,0 +1,131 @@
+package com.bumptech.glide.test;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentActivity;
+import android.view.View;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import java.io.File;
+import java.lang.Deprecated;
+import java.lang.String;
+
+/**
+ * The entry point for interacting with Glide for Applications
+ *
+ * <p>Includes all generated APIs from all
+ * {@link com.bumptech.glide.annotation.GlideExtension}s in source and dependent libraries.
+ *
+ * <p>This class is generated and should not be modified
+ * @see Glide
+ */
+public final class GlideApp {
+  private GlideApp() {
+  }
+
+  /**
+   * @see Glide#getPhotoCacheDir(Context)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(@NonNull Context arg0) {
+    return Glide.getPhotoCacheDir(arg0);
+  }
+
+  /**
+   * @see Glide#getPhotoCacheDir(Context, String)
+   */
+  @Nullable
+  public static File getPhotoCacheDir(@NonNull Context arg0, @NonNull String arg1) {
+    return Glide.getPhotoCacheDir(arg0, arg1);
+  }
+
+  /**
+   * @see Glide#get(Context)
+   */
+  @NonNull
+  public static Glide get(@NonNull Context arg0) {
+    return Glide.get(arg0);
+  }
+
+  /**
+   * @see Glide#init(Glide)
+   */
+  @Deprecated
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void init(Glide glide) {
+    Glide.init(glide);
+  }
+
+  /**
+   * @see Glide#init(Context, GlideBuilder)
+   */
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void init(@NonNull Context arg0, @NonNull GlideBuilder arg1) {
+    Glide.init(arg0, arg1);
+  }
+
+  /**
+   * @see Glide#tearDown()
+   */
+  @VisibleForTesting
+  @SuppressLint("VisibleForTests")
+  public static void tearDown() {
+    Glide.tearDown();
+  }
+
+  /**
+   * @see Glide#with(Context)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Context arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(Activity)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Activity arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(FragmentActivity)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull FragmentActivity arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(Fragment)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull Fragment arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(Fragment)
+   */
+  @Deprecated
+  @NonNull
+  public static GlideRequests with(@NonNull android.app.Fragment arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+
+  /**
+   * @see Glide#with(View)
+   */
+  @NonNull
+  public static GlideRequests with(@NonNull View arg0) {
+    return (GlideRequests) Glide.with(arg0);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
new file mode 100644
index 000000000..9b92b8ab4
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java
@@ -0,0 +1,618 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
new file mode 100644
index 000000000..00c6c5d7a
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
new file mode 100644
index 000000000..7824b67f9
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
@@ -0,0 +1,171 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.applyDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.setDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Integer arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object arg0) {
+    return (GlideRequest<File>) super.download(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java
new file mode 100644
index 000000000..60ad52260
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/EmptyLibraryModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java
new file mode 100644
index 000000000..b18a61cd1
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/EmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.annotation.compiler;
+
+@Index(
+    modules = "com.bumptech.glide.test.EmptyLibraryModule"
+)
+public class GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule {
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
new file mode 100644
index 000000000..05cf8447b
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(memoizeStaticMethod = true)
+  public static RequestOptions test(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..bd161674f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -0,0 +1,642 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform1;
+
+  private static GlideOptions centerInsideTransform2;
+
+  private static GlideOptions centerCropTransform3;
+
+  private static GlideOptions circleCropTransform4;
+
+  private static GlideOptions noTransformation5;
+
+  private static GlideOptions noAnimation6;
+
+  private static GlideOptions testOf0;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform1 == null) {
+      GlideOptions.fitCenterTransform1 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform2 == null) {
+      GlideOptions.centerInsideTransform2 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform2;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform3 == null) {
+      GlideOptions.centerCropTransform3 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform4 == null) {
+      GlideOptions.circleCropTransform4 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform4;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation5 == null) {
+      GlideOptions.noTransformation5 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation5;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation6 == null) {
+      GlideOptions.noAnimation6 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation6;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testOf() {
+    if (GlideOptions.testOf0 == null) {
+      GlideOptions.testOf0 =
+          new GlideOptions().test().autoClone();
+    }
+    return GlideOptions.testOf0;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
new file mode 100644
index 000000000..b11fe757f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static RequestOptions centerCrop(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
new file mode 100644
index 000000000..5043b0d98
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -0,0 +1,631 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   * @see RequestOptions#centerCrop()
+   */
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    return (GlideOptions) Extension.centerCrop(super.centerCrop());
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
new file mode 100644
index 000000000..6179c1263
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
new file mode 100644
index 000000000..a0be8a2c3
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static RequestOptions override(RequestOptions requestOptions, int width, int height) {
+    return requestOptions
+        .override(width, height)
+        .centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
new file mode 100644
index 000000000..be6e957ad
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
@@ -0,0 +1,621 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#override(RequestOptions, int, int)
+   * @see RequestOptions#override(int, int)
+   */
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions override(int width, int height) {
+    return (GlideOptions) Extension.override(super.override(width, height), width, height);
+  }
+
+  /**
+   * @see Extension#override(RequestOptions, int, int)
+   */
+  @CheckResult
+  public static GlideOptions overrideOf(int width, int height) {
+    return new GlideOptions().override(width, height);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
new file mode 100644
index 000000000..ff1366641
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
new file mode 100644
index 000000000..78d91590f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)
+  public static RequestOptions centerCrop(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
new file mode 100644
index 000000000..8d0696027
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -0,0 +1,629 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    return (GlideOptions) Extension.centerCrop(this);
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
new file mode 100644
index 000000000..6179c1263
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
new file mode 100644
index 000000000..69db3bc0f
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(skipStaticMethod = true)
+  public static RequestOptions test(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..74b45424d
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -0,0 +1,628 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
new file mode 100644
index 000000000..9e05dde64
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption(staticMethodName = "testSomething")
+  public static RequestOptions test(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
new file mode 100644
index 000000000..14f17549b
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -0,0 +1,636 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    return (GlideOptions) Extension.test(this);
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testSomething() {
+    return new GlideOptions().test();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
new file mode 100644
index 000000000..9884bcefb
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class ExtensionWithOption {
+
+  private ExtensionWithOption() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption
+  public static RequestOptions squareThumb(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
new file mode 100644
index 000000000..377c83922
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
@@ -0,0 +1,636 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithOption
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions squareThumb() {
+    return (GlideOptions) ExtensionWithOption.squareThumb(this);
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions squareThumbOf() {
+    return new GlideOptions().squareThumb();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
new file mode 100644
index 000000000..fb9e7f7c3
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#squareThumb()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> squareThumb() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).squareThumb();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).squareThumb();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
new file mode 100644
index 000000000..1d58e6ff0
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+
+@GlideExtension
+public final class ExtensionWithType {
+
+  private ExtensionWithType() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideType(Number.class)
+  public static RequestBuilder<Number> asNumber(RequestBuilder<Number> builder) {
+    return builder;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
new file mode 100644
index 000000000..0b3fbfea0
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideOptions.java
@@ -0,0 +1,619 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithType
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
new file mode 100644
index 000000000..87d740099
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
@@ -0,0 +1,181 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Number;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  /**
+   * @see ExtensionWithType#asNumber(RequestBuilder)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<Number> asNumber() {
+    return (GlideRequest<Number>) ExtensionWithType.asNumber(this.as(Number.class));
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.applyDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.setDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Integer arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object arg0) {
+    return (GlideRequest<File>) super.download(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
new file mode 100644
index 000000000..f37b64050
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(memoizeStaticMethod = true)
+  public static void test(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..6c0100161
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -0,0 +1,646 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform1;
+
+  private static GlideOptions centerInsideTransform2;
+
+  private static GlideOptions centerCropTransform3;
+
+  private static GlideOptions circleCropTransform4;
+
+  private static GlideOptions noTransformation5;
+
+  private static GlideOptions noAnimation6;
+
+  private static GlideOptions testOf0;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform1 == null) {
+      GlideOptions.fitCenterTransform1 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform2 == null) {
+      GlideOptions.centerInsideTransform2 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform2;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform3 == null) {
+      GlideOptions.centerCropTransform3 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform4 == null) {
+      GlideOptions.circleCropTransform4 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform4;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation5 == null) {
+      GlideOptions.noTransformation5 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation5;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation6 == null) {
+      GlideOptions.noAnimation6 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation6;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    if (isAutoCloneEnabled()) {
+      return clone().test();
+    }
+    Extension.test(this);
+    return this;
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testOf() {
+    if (GlideOptions.testOf0 == null) {
+      GlideOptions.testOf0 =
+          new GlideOptions().test().autoClone();
+    }
+    return GlideOptions.testOf0;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/Extension.java
new file mode 100644
index 000000000..5bc2838f8
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
+  public static void centerCrop(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
new file mode 100644
index 000000000..ebeb08175
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -0,0 +1,636 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   * @see RequestOptions#centerCrop()
+   */
+  @Override
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    if (isAutoCloneEnabled()) {
+      return clone().centerCrop();
+    }
+    super.centerCrop();
+    Extension.centerCrop(this);
+    return this;
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
new file mode 100644
index 000000000..6179c1263
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/Extension.java
new file mode 100644
index 000000000..591f857f2
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(override = GlideOption.OVERRIDE_REPLACE)
+  public static void centerCrop(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
new file mode 100644
index 000000000..8604712ba
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -0,0 +1,633 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions centerCrop() {
+    if (isAutoCloneEnabled()) {
+      return clone().centerCrop();
+    }
+    Extension.centerCrop(this);
+    return this;
+  }
+
+  /**
+   * @see Extension#centerCrop(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions centerCropOf() {
+    return new GlideOptions().centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
new file mode 100644
index 000000000..6179c1263
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -0,0 +1,770 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/Extension.java
new file mode 100644
index 000000000..448a02b74
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(skipStaticMethod = true)
+  public static void test(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
new file mode 100644
index 000000000..58fb322a4
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -0,0 +1,632 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    if (isAutoCloneEnabled()) {
+      return clone().test();
+    }
+    Extension.test(this);
+    return this;
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/Extension.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/Extension.java
new file mode 100644
index 000000000..b6c72bbad
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/Extension.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class Extension {
+
+  private Extension() {
+    // Utility class.
+  }
+
+  @GlideOption(staticMethodName = "testSomething")
+  public static void test(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
new file mode 100644
index 000000000..970b5fb0a
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -0,0 +1,640 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see Extension
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions test() {
+    if (isAutoCloneEnabled()) {
+      return clone().test();
+    }
+    Extension.test(this);
+    return this;
+  }
+
+  /**
+   * @see Extension#test(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions testSomething() {
+    return new GlideOptions().test();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
new file mode 100644
index 000000000..ca9ea8813
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#test()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> test() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).test();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).test();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/ExtensionWithOption.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/ExtensionWithOption.java
new file mode 100644
index 000000000..b67065d43
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/ExtensionWithOption.java
@@ -0,0 +1,18 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+
+@GlideExtension
+public final class ExtensionWithOption {
+
+  private ExtensionWithOption() {
+    // Utility class.
+  }
+
+  @GlideOption
+  public static void squareThumb(RequestOptions requestOptions) {
+    requestOptions.centerCrop();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java
new file mode 100644
index 000000000..a7f63dd7c
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java
@@ -0,0 +1,640 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithOption
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(RequestOptions)
+   */
+  @CheckResult
+  @NonNull
+  public GlideOptions squareThumb() {
+    if (isAutoCloneEnabled()) {
+      return clone().squareThumb();
+    }
+    ExtensionWithOption.squareThumb(this);
+    return this;
+  }
+
+  /**
+   * @see ExtensionWithOption#squareThumb(RequestOptions)
+   */
+  @CheckResult
+  public static GlideOptions squareThumbOf() {
+    return new GlideOptions().squareThumb();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java
new file mode 100644
index 000000000..fb9e7f7c3
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java
@@ -0,0 +1,784 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Contains all public methods from {@link RequestBuilder<TranscodeType>}, all options from
+ * {@link RequestOptions} and all generated options from
+ * {@link com.bumptech.glide.annotation.GlideOption} in annotated methods in
+ * {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * <p>Generated code, do not modify.
+ *
+ * @see RequestBuilder<TranscodeType>
+ * @see RequestOptions
+ */
+@SuppressWarnings({
+    "unused",
+    "deprecation"
+})
+public class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> implements Cloneable {
+  GlideRequest(@NonNull Class<TranscodeType> transcodeClass, @NonNull RequestBuilder<?> other) {
+    super(transcodeClass, other);
+  }
+
+  GlideRequest(@NonNull Glide glide, @NonNull RequestManager requestManager,
+      @NonNull Class<TranscodeType> transcodeClass, @NonNull Context context) {
+    super(glide, requestManager ,transcodeClass, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  protected GlideRequest<File> getDownloadOnlyRequest() {
+    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+  }
+
+  /**
+   * @see GlideOptions#sizeMultiplier(float)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).sizeMultiplier(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).sizeMultiplier(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useUnlimitedSourceGeneratorsPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useUnlimitedSourceGeneratorsPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useUnlimitedSourceGeneratorsPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#useAnimationPool(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> useAnimationPool(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).useAnimationPool(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).useAnimationPool(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#onlyRetrieveFromCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> onlyRetrieveFromCache(boolean flag) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).onlyRetrieveFromCache(flag);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).onlyRetrieveFromCache(flag);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#diskCacheStrategy(DiskCacheStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).diskCacheStrategy(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).diskCacheStrategy(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#priority(Priority)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> priority(@NonNull Priority arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).priority(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).priority(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#placeholder(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> placeholder(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fallback(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fallback(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fallback(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fallback(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(Drawable)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@Nullable Drawable arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#error(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> error(@DrawableRes int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).error(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).error(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#theme(Resources.Theme)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> theme(@Nullable Resources.Theme arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).theme(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).theme(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#skipMemoryCache(boolean)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> skipMemoryCache(boolean skip) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).skipMemoryCache(skip);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).skipMemoryCache(skip);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int, int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int width, int height) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(width, height);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(width, height);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#override(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> override(int size) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).override(size);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).override(size);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#signature(Key)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> signature(@NonNull Key arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).signature(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).signature(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#set(Option<T>, T)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).set(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).set(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#decode(Class<?>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> decode(@NonNull Class<?> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).decode(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).decode(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeFormat(Bitmap.CompressFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeFormat(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeFormat(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#encodeQuality(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).encodeQuality(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).encodeQuality(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#frame(long)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> frame(@IntRange(from = 0) long arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).frame(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).frame(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#format(DecodeFormat)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> format(@NonNull DecodeFormat arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).format(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).format(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#disallowHardwareConfig()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> disallowHardwareConfig() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).disallowHardwareConfig();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).disallowHardwareConfig();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#downsample(DownsampleStrategy)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> downsample(@NonNull DownsampleStrategy arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).downsample(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).downsample(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#timeout(int)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> timeout(@IntRange(from = 0) int arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).timeout(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).timeout(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalFitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalFitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalFitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> fitCenter() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).fitCenter();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).fitCenter();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCenterInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCenterInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCenterInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> centerInside() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).centerInside();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).centerInside();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalCircleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalCircleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalCircleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalCircleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> circleCrop() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).circleCrop();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).circleCrop();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transforms(Transformation<Bitmap>[])
+   */
+  @NonNull
+  @CheckResult
+  @SuppressWarnings({
+      "unchecked",
+      "varargs"
+  })
+  public GlideRequest<TranscodeType> transforms(@NonNull Transformation<Bitmap>... arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transforms(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transforms(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Transformation<Bitmap>)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#optionalTransform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).optionalTransform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).optionalTransform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#transform(Class<T>, Transformation<T>)
+   */
+  @NonNull
+  @CheckResult
+  public <T> GlideRequest<TranscodeType> transform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).transform(arg0, arg1);
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).transform(arg0, arg1);
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontTransform()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontTransform() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontTransform();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontTransform();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#dontAnimate()
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> dontAnimate() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+    }
+    return this;
+  }
+
+  /**
+   * @see GlideOptions#squareThumb()
+   */
+  @CheckResult
+  @NonNull
+  public GlideRequest<TranscodeType> squareThumb() {
+    if (getMutableOptions() instanceof GlideOptions) {
+      this.requestOptions = ((GlideOptions) getMutableOptions()).squareThumb();
+    } else {
+      this.requestOptions = new GlideOptions().apply(this.requestOptions).squareThumb();
+    }
+    return this;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> apply(@NonNull RequestOptions arg0) {
+    return (GlideRequest<TranscodeType>) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> transition(@NonNull TransitionOptions<?, ? super TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.transition(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> listener(@Nullable RequestListener<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.listener(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequest<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType> arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  public final GlideRequest<TranscodeType> thumbnail(@Nullable RequestBuilder<TranscodeType>... arg0) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> thumbnail(float sizeMultiplier) {
+    return (GlideRequest<TranscodeType>) super.thumbnail(sizeMultiplier);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Object arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Drawable arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable String arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable Uri arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable File arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable URL arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<TranscodeType> load(@Nullable byte[] arg0) {
+    return (GlideRequest<TranscodeType>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<TranscodeType> clone() {
+    return (GlideRequest<TranscodeType>) super.clone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/ExtensionWithType.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/ExtensionWithType.java
new file mode 100644
index 000000000..47c22dd4d
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/ExtensionWithType.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+
+@GlideExtension
+public final class ExtensionWithType {
+
+  private ExtensionWithType() {
+    // Utility class.
+  }
+
+  @GlideType(Number.class)
+  public static void asInteger(RequestBuilder<Number> builder) {}
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideOptions.java
new file mode 100644
index 000000000..0b3fbfea0
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideOptions.java
@@ -0,0 +1,619 @@
+package com.bumptech.glide.test;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.request.RequestOptions;
+import java.lang.Class;
+import java.lang.Cloneable;
+import java.lang.Override;
+import java.lang.SafeVarargs;
+import java.lang.SuppressWarnings;
+
+/**
+ * Automatically generated from {@link com.bumptech.glide.annotation.GlideExtension} annotated classes.
+ *
+ * @see RequestOptions
+ * @see ExtensionWithType
+ */
+@SuppressWarnings("deprecation")
+public final class GlideOptions extends RequestOptions implements Cloneable {
+  private static GlideOptions fitCenterTransform0;
+
+  private static GlideOptions centerInsideTransform1;
+
+  private static GlideOptions centerCropTransform2;
+
+  private static GlideOptions circleCropTransform3;
+
+  private static GlideOptions noTransformation4;
+
+  private static GlideOptions noAnimation5;
+
+  /**
+   * @see RequestOptions#sizeMultiplierOf(float)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions sizeMultiplierOf(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return new GlideOptions().sizeMultiplier(arg0);
+  }
+
+  /**
+   * @see RequestOptions#diskCacheStrategyOf(DiskCacheStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy arg0) {
+    return new GlideOptions().diskCacheStrategy(arg0);
+  }
+
+  /**
+   * @see RequestOptions#priorityOf(Priority)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions priorityOf(@NonNull Priority arg0) {
+    return new GlideOptions().priority(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@Nullable Drawable arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#placeholderOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions placeholderOf(@DrawableRes int arg0) {
+    return new GlideOptions().placeholder(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(Drawable)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@Nullable Drawable arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#errorOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions errorOf(@DrawableRes int arg0) {
+    return new GlideOptions().error(arg0);
+  }
+
+  /**
+   * @see RequestOptions#skipMemoryCacheOf(boolean)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions skipMemoryCacheOf(boolean skipMemoryCache) {
+    return new GlideOptions().skipMemoryCache(skipMemoryCache);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int, int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0,
+      @IntRange(from = 0) int arg1) {
+    return new GlideOptions().override(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#overrideOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions overrideOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().override(arg0);
+  }
+
+  /**
+   * @see RequestOptions#signatureOf(Key)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions signatureOf(@NonNull Key arg0) {
+    return new GlideOptions().signature(arg0);
+  }
+
+  /**
+   * @see RequestOptions#fitCenterTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions fitCenterTransform() {
+    if (GlideOptions.fitCenterTransform0 == null) {
+      GlideOptions.fitCenterTransform0 =
+          new GlideOptions().fitCenter().autoClone();
+    }
+    return GlideOptions.fitCenterTransform0;
+  }
+
+  /**
+   * @see RequestOptions#centerInsideTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerInsideTransform() {
+    if (GlideOptions.centerInsideTransform1 == null) {
+      GlideOptions.centerInsideTransform1 =
+          new GlideOptions().centerInside().autoClone();
+    }
+    return GlideOptions.centerInsideTransform1;
+  }
+
+  /**
+   * @see RequestOptions#centerCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions centerCropTransform() {
+    if (GlideOptions.centerCropTransform2 == null) {
+      GlideOptions.centerCropTransform2 =
+          new GlideOptions().centerCrop().autoClone();
+    }
+    return GlideOptions.centerCropTransform2;
+  }
+
+  /**
+   * @see RequestOptions#circleCropTransform()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions circleCropTransform() {
+    if (GlideOptions.circleCropTransform3 == null) {
+      GlideOptions.circleCropTransform3 =
+          new GlideOptions().circleCrop().autoClone();
+    }
+    return GlideOptions.circleCropTransform3;
+  }
+
+  /**
+   * @see RequestOptions#bitmapTransform(Transformation)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions bitmapTransform(@NonNull Transformation<Bitmap> arg0) {
+    return new GlideOptions().transform(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noTransformation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noTransformation() {
+    if (GlideOptions.noTransformation4 == null) {
+      GlideOptions.noTransformation4 =
+          new GlideOptions().dontTransform().autoClone();
+    }
+    return GlideOptions.noTransformation4;
+  }
+
+  /**
+   * @see RequestOptions#option(Option, T)
+   */
+  @CheckResult
+  @NonNull
+  public static <T> GlideOptions option(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return new GlideOptions().set(arg0, arg1);
+  }
+
+  /**
+   * @see RequestOptions#decodeTypeOf(Class)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions decodeTypeOf(@NonNull Class<?> arg0) {
+    return new GlideOptions().decode(arg0);
+  }
+
+  /**
+   * @see RequestOptions#formatOf(DecodeFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions formatOf(@NonNull DecodeFormat arg0) {
+    return new GlideOptions().format(arg0);
+  }
+
+  /**
+   * @see RequestOptions#frameOf(long)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions frameOf(@IntRange(from = 0) long arg0) {
+    return new GlideOptions().frame(arg0);
+  }
+
+  /**
+   * @see RequestOptions#downsampleOf(DownsampleStrategy)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions downsampleOf(@NonNull DownsampleStrategy arg0) {
+    return new GlideOptions().downsample(arg0);
+  }
+
+  /**
+   * @see RequestOptions#timeoutOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions timeoutOf(@IntRange(from = 0) int arg0) {
+    return new GlideOptions().timeout(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeQualityOf(int)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeQualityOf(@IntRange(from = 0, to = 100) int arg0) {
+    return new GlideOptions().encodeQuality(arg0);
+  }
+
+  /**
+   * @see RequestOptions#encodeFormatOf(CompressFormat)
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions encodeFormatOf(@NonNull Bitmap.CompressFormat arg0) {
+    return new GlideOptions().encodeFormat(arg0);
+  }
+
+  /**
+   * @see RequestOptions#noAnimation()
+   */
+  @CheckResult
+  @NonNull
+  public static GlideOptions noAnimation() {
+    if (GlideOptions.noAnimation5 == null) {
+      GlideOptions.noAnimation5 =
+          new GlideOptions().dontAnimate().autoClone();
+    }
+    return GlideOptions.noAnimation5;
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions sizeMultiplier(@FloatRange(from = 0.0, to = 1.0) float arg0) {
+    return (GlideOptions) super.sizeMultiplier(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    return (GlideOptions) super.useUnlimitedSourceGeneratorsPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions useAnimationPool(boolean flag) {
+    return (GlideOptions) super.useAnimationPool(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions onlyRetrieveFromCache(boolean flag) {
+    return (GlideOptions) super.onlyRetrieveFromCache(flag);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions diskCacheStrategy(@NonNull DiskCacheStrategy arg0) {
+    return (GlideOptions) super.diskCacheStrategy(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions priority(@NonNull Priority arg0) {
+    return (GlideOptions) super.priority(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@Nullable Drawable arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions placeholder(@DrawableRes int arg0) {
+    return (GlideOptions) super.placeholder(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@Nullable Drawable arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fallback(@DrawableRes int arg0) {
+    return (GlideOptions) super.fallback(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@Nullable Drawable arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions error(@DrawableRes int arg0) {
+    return (GlideOptions) super.error(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions theme(@Nullable Resources.Theme arg0) {
+    return (GlideOptions) super.theme(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions skipMemoryCache(boolean skip) {
+    return (GlideOptions) super.skipMemoryCache(skip);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int width, int height) {
+    return (GlideOptions) super.override(width, height);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions override(int size) {
+    return (GlideOptions) super.override(size);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions signature(@NonNull Key arg0) {
+    return (GlideOptions) super.signature(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public final GlideOptions clone() {
+    return (GlideOptions) super.clone();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions set(@NonNull Option<T> arg0, @NonNull T arg1) {
+    return (GlideOptions) super.set(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions decode(@NonNull Class<?> arg0) {
+    return (GlideOptions) super.decode(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeFormat(@NonNull Bitmap.CompressFormat arg0) {
+    return (GlideOptions) super.encodeFormat(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions encodeQuality(@IntRange(from = 0, to = 100) int arg0) {
+    return (GlideOptions) super.encodeQuality(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions frame(@IntRange(from = 0) long arg0) {
+    return (GlideOptions) super.frame(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions format(@NonNull DecodeFormat arg0) {
+    return (GlideOptions) super.format(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions disallowHardwareConfig() {
+    return (GlideOptions) super.disallowHardwareConfig();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions downsample(@NonNull DownsampleStrategy arg0) {
+    return (GlideOptions) super.downsample(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions timeout(@IntRange(from = 0) int arg0) {
+    return (GlideOptions) super.timeout(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterCrop() {
+    return (GlideOptions) super.optionalCenterCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerCrop() {
+    return (GlideOptions) super.centerCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalFitCenter() {
+    return (GlideOptions) super.optionalFitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions fitCenter() {
+    return (GlideOptions) super.fitCenter();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCenterInside() {
+    return (GlideOptions) super.optionalCenterInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions centerInside() {
+    return (GlideOptions) super.centerInside();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalCircleCrop() {
+    return (GlideOptions) super.optionalCircleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions circleCrop() {
+    return (GlideOptions) super.circleCrop();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions transform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.transform(arg0);
+  }
+
+  @Override
+  @SafeVarargs
+  @SuppressWarnings("varargs")
+  @NonNull
+  @CheckResult
+  public final GlideOptions transforms(@NonNull Transformation<Bitmap>... arg0) {
+    return (GlideOptions) super.transforms(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions optionalTransform(@NonNull Transformation<Bitmap> arg0) {
+    return (GlideOptions) super.optionalTransform(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions optionalTransform(@NonNull Class<T> arg0,
+      @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.optionalTransform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final <T> GlideOptions transform(@NonNull Class<T> arg0, @NonNull Transformation<T> arg1) {
+    return (GlideOptions) super.transform(arg0, arg1);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontTransform() {
+    return (GlideOptions) super.dontTransform();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions dontAnimate() {
+    return (GlideOptions) super.dontAnimate();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public final GlideOptions apply(@NonNull RequestOptions arg0) {
+    return (GlideOptions) super.apply(arg0);
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions lock() {
+    return (GlideOptions) super.lock();
+  }
+
+  @Override
+  @NonNull
+  public final GlideOptions autoClone() {
+    return (GlideOptions) super.autoClone();
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
new file mode 100644
index 000000000..be9b074e6
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
@@ -0,0 +1,183 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.RequestOptions;
+import java.io.File;
+import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
+import java.lang.Number;
+import java.lang.Object;
+import java.lang.Override;
+import java.lang.String;
+import java.lang.SuppressWarnings;
+import java.net.URL;
+
+/**
+ * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
+ * annotated with {@link com.bumptech.glide.annotation.GlideType}
+ *
+ * <p>Generated code, do not modify
+ */
+@SuppressWarnings("deprecation")
+public class GlideRequests extends RequestManager {
+  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    super(glide, lifecycle, treeNode, context);
+  }
+
+  @Override
+  @CheckResult
+  @NonNull
+  public <ResourceType> GlideRequest<ResourceType> as(@NonNull Class<ResourceType> resourceClass) {
+    return new GlideRequest<>(glide, this, resourceClass, context);
+  }
+
+  /**
+   * @see ExtensionWithType#asInteger(RequestBuilder)
+   */
+  @NonNull
+  @CheckResult
+  public GlideRequest<Number> asInteger() {
+    GlideRequest<Number> requestBuilder = this.as(Number.class);
+    ExtensionWithType.asInteger(requestBuilder);
+    return requestBuilder;
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.applyDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  public GlideRequests setDefaultRequestOptions(@NonNull RequestOptions arg0) {
+    return (GlideRequests) super.setDefaultRequestOptions(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Bitmap> asBitmap() {
+    return (GlideRequest<Bitmap>) super.asBitmap();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<GifDrawable> asGif() {
+    return (GlideRequest<GifDrawable>) super.asGif();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> asDrawable() {
+    return (GlideRequest<Drawable>) super.asDrawable();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Integer arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Object arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> downloadOnly() {
+    return (GlideRequest<File>) super.downloadOnly();
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> download(@Nullable Object arg0) {
+    return (GlideRequest<File>) super.download(arg0);
+  }
+
+  @Override
+  @NonNull
+  @CheckResult
+  public GlideRequest<File> asFile() {
+    return (GlideRequest<File>) super.asFile();
+  }
+
+  @Override
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    if (toSet instanceof com.bumptech.glide.test.GlideOptions) {
+      super.setRequestOptions(toSet);
+    } else {
+      super.setRequestOptions(new com.bumptech.glide.test.GlideOptions().apply(toSet));
+    }
+  }
+}
diff --git a/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java
new file mode 100644
index 000000000..a05259d66
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule1 extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java
new file mode 100644
index 000000000..fb46c0c13
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleAppGlideModuleTest/EmptyAppModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public final class EmptyAppModule2 extends AppGlideModule {}
\ No newline at end of file
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java
new file mode 100644
index 000000000..236008a91
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule1.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule1 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java
new file mode 100644
index 000000000..8a43eb292
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/EmptyLibraryModule2.java
@@ -0,0 +1,7 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+
+@GlideModule
+public final class EmptyLibraryModule2 extends LibraryGlideModule {}
diff --git a/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java
new file mode 100644
index 000000000..d4284aa69
--- /dev/null
+++ b/annotation/compiler/test/src/test/resources/MultipleEmptyLibraryGlideModuleTest/GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.annotation.compiler;
+
+@Index(
+    modules = {
+        "com.bumptech.glide.test.EmptyLibraryModule1",
+        "com.bumptech.glide.test.EmptyLibraryModule2"
+    }
+)
+public class GlideIndexer_GlideModule_com_bumptech_glide_test_EmptyLibraryModule1_com_bumptech_glide_test_EmptyLibraryModule2 {
+}
diff --git a/annotation/gradle.properties b/annotation/gradle.properties
new file mode 100644
index 000000000..ab55616cf
--- /dev/null
+++ b/annotation/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide Annotations
+POM_ARTIFACT_ID=annotations
+POM_PACKAGING=jar
+POM_DESCRIPTION=A set of annotations for configuring Glide.
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
new file mode 100644
index 000000000..13de814b2
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Specifies a set of GlideModule and/or LibraryGlideModule classes that should be excluded
+ * from an application.
+ *
+ * <p>Used only on AppGlideModules. Adding this annotation to other classes will have no affect.
+ *
+ * <p>Cannot be used to exclude AppGlideModules (there must be at most one per Application anyway).
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Excludes {
+  Class<?>[] value();
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
new file mode 100644
index 000000000..bb525c849
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicate a class that extends Glide's public API.
+ *
+ * @see GlideOption
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.SOURCE)
+public @interface GlideExtension { }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
new file mode 100644
index 000000000..dc91418e2
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies AppGlideModules and LibraryGlideModules for Glide's annotation processor to merge at
+ * compile time.
+ *
+ * <p>Replaces <meta-data /> tags in AndroidManifest.xml.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.SOURCE)
+public @interface GlideModule {
+  /**
+   * Returns the name of the class that will be used as a replacement for
+   * {@code com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
+   */
+  String glideName() default "GlideApp";
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
new file mode 100644
index 000000000..58197a802
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
@@ -0,0 +1,131 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies methods in {@link GlideExtension} annotated classes that extend
+ * {@code com.bumptech.glide.request.RequestOptions}.
+ *
+ * <p>All annotated methods will be added to a single
+ * {@code com.bumptech.glide.request.RequestOptions} implementation generated per application.
+ * Overlapping method names in different extensions may cause errors at compile time.
+ *
+ * <p>Static equivalents of annotated methods will also be generated.
+ *
+ * <p>Methods with this annotation will only be found if they belong to classes annotated with
+ * {@link GlideExtension}.
+ *
+ * <p>The preferred way of writing extension methods returns the provided
+ * {@code com.bumptech.glide.request.RequestOptions} object with one or more methods called on it.
+ * You must not return a newly instantiated {@code com.bumptech.glide.request.RequestOptions} object
+ * as doing so my cause a {@code ClassCastException} at runtime. Calling either
+ * {@code com.bumptech.glide.request.RequestOptions#autoClone()} or
+ * {@code com.bumptech.glide.request.RequestOptions#lock()} is safe, but unnecessary and should
+ * typically be avoided. The preferred style looks like:
+ *
+ * <pre>
+ * {@code
+ * {@link @}GlideExtension
+ * public class MyExtension {
+ *   private MyExtension() {}
+ *
+ *   {@literal @}GlideOption
+ *   public static RequestOptions myOption(RequestOptions options) {
+ *     return options
+ *         .optionOne()
+ *         .optionTwo();
+ *   }
+ * }
+ * }
+ * </pre>
+ *
+ * <p>The deprecated way of writing extension methods is simply a static void method. The
+ * {@code com.bumptech.glide.request.RequestOptions} object is cloned before it is passed to this
+ * method to avoid an option method returning a new instance, but using methods like
+ * {@code com.bumptech.glide.request.RequestOptions#clone()} or
+ * {@code com.bumptech.glide.request.RequestOptions#autoClone()} can result in options applied in
+ * the method being silently ignored. Prefer the new style whenever possible.
+ *
+ * <pre>
+ * {@code
+ * {@literal @}GlideExtension
+ * public class MyExtension {
+ *   private MyExtension() {}
+ *
+ *   // Deprecated! Use the new style of GlideOption extensions instead.
+ *   {@literal @}GlideOption
+ *   public static void myOption(RequestOptions options) {
+ *     options
+ *         .optionOne()
+ *         .optionTwo();
+ *   }
+ * }
+ * }
+ * </pre>
+ */
+@Target(ElementType.METHOD)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+public @interface GlideOption {
+   /** Does not intend to override a method in a super class. */
+  int OVERRIDE_NONE = 0;
+  /** Expects to call super and then add additional functionality to an overridden method. */
+  int OVERRIDE_EXTEND = 1;
+  /** Expects to not call super and replace an overridden method. */
+  int OVERRIDE_REPLACE = 2;
+
+  /**
+   * Determines how and whether a generated method should extend a method from it's parent.
+   *
+   * <p>Must be one of {@link #OVERRIDE_NONE}, {@link #OVERRIDE_EXTEND}, {@link #OVERRIDE_REPLACE}.
+   *
+   * <p>The extended method is determined by String and argument matching against methods in the
+   * extended class. If {@link #OVERRIDE_NONE} is used and the method and arguments match a method
+   * in the extended class, a compile time error will result. Similarly if any other override type
+   * is used and no method/arguments in the extended class match, a compile time error will result.
+   */
+  int override() default OVERRIDE_NONE;
+
+  /**
+   * Sets the name for the generated static version of this method.
+   *
+   * <p>If this value is not set, the static method name is just the original method name with "Of"
+   * appended.
+   */
+  String staticMethodName() default "";
+
+  /**
+   * {@code true} to indicate that it's safe to statically memoize the result of this method using
+   * {@code com.bumptech.glide.request.RequestOptions#autoClone()}.
+   *
+   * <p>This method should only be used for no-arg methods where there's only a single possible
+   * value.
+   *
+   * <p>Memoization can save object allocations for frequently used options.
+   */
+  boolean memoizeStaticMethod() default false;
+
+  /**
+   * {@code true} to prevent a static builder method from being generated.
+   *
+   * <p>By default static methods are generated for all methods annotated with
+   * {@link GlideOption}. These static factory methods allow for a cleaner API when used
+   * with {@code com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
+   * simply creates a new {@code com.bumptech.glide.request.RequestOptions} object, calls the
+   * instance version of the method on it and returns it. For example:
+   * <pre>
+   * <code>
+   * public static GlideOptions noAnimation() {
+   *   return new GlideOptions().dontAnimate();
+   * }
+   * </code>
+   * </pre>
+   *
+   * @see #memoizeStaticMethod()
+   * @see #staticMethodName()
+   */
+  boolean skipStaticMethod() default false;
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
new file mode 100644
index 000000000..d3538d99b
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
@@ -0,0 +1,43 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies methods in {@link GlideExtension} annotated classes that extend
+ * {@code com.bumptech.glide.RequestManager}.
+ *
+ * <p>If one or more method is found with this annotation, an additional API entry point that
+ * exposes a generated {@code com.bumptech.glide.RequestManager} subclass will be created. The
+ * generated API entry point acts as a drop in replacement for Glide. Glide.with(fragment) becomes
+ * GlideApp.with(fragment). Although the Glide.with variant will still be available, only the new
+ * API entry point will provide access to these additional methods.
+ *
+ * <p>The name of the API entry point created when one of these methods is found can be controlled
+ * by {@link GlideModule#glideName()}.
+ *
+ * <p>Methods with this annotation will only be found if they are contained in a class annotated
+ * with {@link GlideExtension}.
+ *
+ * <p>Methods annotated with GlideType must have a single parameter. The type of the
+ * single parameter must be {@code com.bumptech.glide.RequestBuilder}, with a type
+ * matching the value of {@link #value()}.
+ *
+ * <p>Compilation will fail if a method annotated with this method is identical to a method in
+ * {@code com.bumptech.glide.RequestManager}
+ */
+@Target(ElementType.METHOD)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+public @interface GlideType {
+
+  /**
+   * A Resource class name, like GifDrawable.class, Bitmap.class etc.
+   *
+   * <p>Must match the type of the {@code com.bumptech.glide.RequestBuilder} parameter in the
+   * annotated method.
+   */
+  Class<?> value();
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
new file mode 100644
index 000000000..81ba54ae1
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used to retrieve LibraryGlideModule and GlideExtension classes in our annotation processor from
+ * libraries and applications.
+ *
+ * <p>Part of the internals of Glide's annotation processor and not for public use.
+ */
+@Target(ElementType.TYPE)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+@interface Index {
+  String[] modules() default {};
+  String[] extensions() default {};
+}
diff --git a/build.gradle b/build.gradle
index ab3a44b96..d9423ea2d 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,15 +1,24 @@
+import se.bjurr.violations.gradle.plugin.ViolationsTask
+import org.gradle.api.tasks.testing.logging.TestExceptionFormat
+
 buildscript {
     repositories {
+        google()
         jcenter()
         maven {
             url "https://oss.sonatype.org/content/repositories/snapshots"
         }
+        maven {
+            url "https://plugins.gradle.org/m2/"
+        }
     }
 
     dependencies {
         classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}"
-        classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}"
-        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}"
+        if (!hasProperty('DISABLE_ERROR_PRONE')) {
+            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}"
+        }
+        classpath "se.bjurr.violations:violations-gradle-plugin:${VIOLATIONS_PLUGIN_VERSION}"
     }
 }
 
@@ -22,29 +31,65 @@ if (JavaVersion.current().isJava8Compatible()) {
     }
 }
 
-subprojects {
-    tasks.withType(JavaCompile) {
-        sourceCompatibility = 1.7
-        targetCompatibility = 1.7
-    }
-}
-
 subprojects { project ->
+
     repositories {
+        google()
         jcenter()
         maven {
             url "https://oss.sonatype.org/content/repositories/snapshots"
         }
     }
 
+    tasks.withType(JavaCompile) {
+        sourceCompatibility = 1.7
+        targetCompatibility = 1.7
+
+        options.setBootstrapClasspath(files("${System.getProperty('java.home')}/lib/rt.jar"))
+        // gifencoder is a legacy project that has a ton of warnings and is basically never
+        // modified, so we're not going to worry about cleaning it up.
+        if ("gifencoder" != project.getName()) {
+          options.compilerArgs \
+                /*
+                 * Treat all warnings as errors.
+                 */ \
+                << "-Werror" \
+                /*
+                 * Enable all warnings.
+                 */ \
+                << "-Xlint:all" \
+                /*
+                 * Java expects every annotation to have a processor, but we use
+                 * javax.annotation.Nullable, which doesn't have one.
+                 */ \
+                << "-Xlint:-processing" \
+                /*
+                 * See https://github.com/google/dagger/issues/945
+                 * and https://bugs.openjdk.java.net/browse/JDK-8190452
+                 */ \
+                << "-Xlint:-classfile"
+        }
+    }
+
+    tasks.withType(Test) {
+        testLogging {
+            exceptionFormat = TestExceptionFormat.FULL
+        }
+    }
+
+    // Avoid issues like #2452.
+    tasks.withType(Jar) {
+        duplicatesStrategy = DuplicatesStrategy.FAIL
+    }
+
     apply plugin: 'checkstyle'
 
     checkstyle {
-        toolVersion = "6.6"
+        toolVersion = '8.5'
     }
 
     checkstyle {
-        configFile = new File(rootDir, 'checkstyle.xml')
+        configFile = rootProject.file('checkstyle.xml')
         configProperties.checkStyleConfigDir = rootProject.rootDir
     }
 
@@ -52,26 +97,54 @@ subprojects { project ->
         source 'src'
         include '**/*.java'
         exclude '**/gen/**'
+        // Caught by the violations plugin.
+        ignoreFailures = true
 
         // empty classpath
         classpath = files()
     }
 
+    apply plugin: "se.bjurr.violations.violations-gradle-plugin"
+
+    task violations(type: ViolationsTask) {
+        minSeverity 'INFO'
+        detailLevel 'VERBOSE'
+        maxViolations = 0
+        diffMaxViolations = 0
+
+        // Formats are listed here: https://github.com/tomasbjerre/violations-lib
+        def dir = projectDir.absolutePath
+        violations = [
+                ["FINDBUGS",    dir, ".*/findbugs/.*\\.xml\$",   "Findbugs"],
+                ["PMD",         dir, ".*/pmd/.*\\.xml\$",        "PMD"],
+                ["ANDROIDLINT", dir, ".*/lint-results\\.xml\$",  "AndroidLint"],
+                ["CHECKSTYLE",  dir, ".*/checkstyle/.*\\.xml\$", "Checkstyle"],
+        ]
+    }
+
     afterEvaluate {
         if (project.tasks.findByName('check')) {
             check.dependsOn('checkstyle')
+            check.finalizedBy violations
         }
-    }
 
-    gradle.projectsEvaluated {
-        tasks.withType(JavaCompile) {
-            if (!name.contains('Test')) {
-                options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
+        if (project.hasProperty("android")
+                && project.name != 'pmd'
+                && project.name != 'findbugs') {
+            android {
+                lintOptions {
+                    warningsAsErrors true
+                    quiet true
+                    // Caught by the violations plugin.
+                    abortOnError false
+                }
+            }
+
+            android.variantFilter { variant ->
+                if(variant.buildType.name == 'release') {
+                    variant.setIgnore(true)
+                }
             }
         }
     }
 }
-
-task wrapper(type: Wrapper) {
-    gradleVersion = '2.2.1'
-}
diff --git a/checkstyle.xml b/checkstyle.xml
index a3c9878b7..52a2c2e5d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -15,7 +15,9 @@
     </module>
 
     <!-- Ensure trailling newline for compatibility -->
-    <module name="NewlineAtEndOfFile" />
+    <module name="NewlineAtEndOfFile">
+        <property name="lineSeparator" value="lf"/>
+    </module>
 
     <!-- Space after 'for' and 'if' -->
     <module name="RegexpSingleline">
@@ -69,7 +71,10 @@
         <module name="StaticVariableName" />
         <module name="TypeName" />
 
-        <module name="TrailingComment" />
+        <!-- Allow common trailing comments used to describe suppressions -->
+        <module name="TrailingComment">
+          <property name="legalComment" value="^Public API.?$|^NOPMD.*$" />
+        </module>
 
         <!-- Checks for imports. -->
         <!-- See http://checkstyle.sourceforge.net/config_imports.html -->
@@ -89,17 +94,26 @@
         <!-- Prevent importing Mockito matchers directly -->
         <module name="IllegalImport">
             <property name="illegalPkgs" value="org.mockito.internal" />
-            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />
+            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers." />
         </module>
+
+        <!-- ArgumentMatchers isn't available internally, the same methods are available on org.mockito.Mockito. -->
+        <module name="IllegalImport">
+            <property name="illegalClasses" value="org\.mockito\.ArgumentMatchers.*" />
+            <property name="regexp" value="true" />
+            <message key="import.illegal" value="Import from illegal class - {0}. Use org.mockito.Mockito to statically import matcher methods." />
+        </module>
+
         <module name="ImportOrder">
           <!-- Checks for out of order import statements. -->
 
           <property name="sortStaticImportsAlphabetically" value="true"/>
            <property name="severity" value="error"/>
-           <property name="groups" value="com.google,*,java,javax"/>
+           <property name="groups" value="*"/>
            <!-- This ensures that static imports go first. -->
            <property name="option" value="top"/>
            <property name="tokens" value="STATIC_IMPORT, IMPORT"/>
+           <property name="separated" value="true" />
          </module>
 
         <!-- Checks for whitespace. -->
@@ -124,7 +138,9 @@
 
         <!-- Checks for blocks. -->
         <!-- See http://checkstyle.sourceforge.net/config_blocks.html -->
-        <module name="AvoidNestedBlocks" />
+        <module name="AvoidNestedBlocks">
+          <property name="allowInSwitchCase" value="true" />
+        </module>
         <module name="EmptyBlock" >
             <property name="option" value="text"/>
         </module>
diff --git a/checkstyle_suppressions.xml b/checkstyle_suppressions.xml
index 9faf18dc8..32352561b 100644
--- a/checkstyle_suppressions.xml
+++ b/checkstyle_suppressions.xml
@@ -5,7 +5,11 @@
     "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">
 
 <suppressions>
-    <suppress files=".*[/\\]library[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]annotation[/\\]compiler[/\\]test[/\\]src[/\\]test[/\\]resources[/\\].*" checks=".*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>
+    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>
     <suppress files=".*[/\\]gif_encoder[/\\].*" checks=".*"/>
     <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />
 </suppressions>
diff --git a/debug.keystore b/debug.keystore
new file mode 100644
index 000000000..425f3d6a1
Binary files /dev/null and b/debug.keystore differ
diff --git a/gcloud-bumptech.json.enc b/gcloud-bumptech.json.enc
new file mode 100644
index 000000000..32dff8de0
Binary files /dev/null and b/gcloud-bumptech.json.enc differ
diff --git a/gcloud-sjudd.json.enc b/gcloud-sjudd.json.enc
new file mode 100644
index 000000000..1c9b64237
Binary files /dev/null and b/gcloud-sjudd.json.enc differ
diff --git a/glide/build.gradle b/glide/build.gradle
index cee746200..ac0ec536a 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -1,72 +1,152 @@
+import com.android.build.gradle.api.LibraryVariant
+
 apply plugin: 'java'
 
-evaluationDependsOn(':third_party:gif_decoder')
-evaluationDependsOn(':third_party:disklrucache')
-evaluationDependsOn(':library')
+// The paths of Android projects that should be included in the jar and javadoc.
+static def getAndroidPathsForJar() {
+    [':third_party:gif_decoder', ':library']
+}
+
+// The paths of Java projects that should be included in the jar and javadoc.
+static def getJavaPathsForJar() {
+    [':third_party:disklrucache']
+}
+
+// The paths of Android projects that should be included only in Javadoc, not in the jar.
+static def getAndroidPathsForJavadoc() {
+    [
+            ':integration:okhttp',
+            ':integration:okhttp3',
+            ':integration:volley',
+            ':integration:gifencoder',
+            ':integration:recyclerview'
+    ]
+}
+
+// The paths of Java projects that should be included only in Javadoc, not in the jar.
+static def getJavaPathsForJavadoc() {
+    [':annotation']
+}
+
+(getAndroidPathsForJavadoc() + getAndroidPathsForJar() +
+        getJavaPathsForJar() + getJavaPathsForJavadoc()).each {
+    evaluationDependsOn(it)
+}
+
+def asProjects(paths) {
+    paths.collect { String path -> project(path) }
+}
 
 def getAndroidSdkDirectory() {
-  project(':library').android.sdkDirectory
+    project(':library').android.sdkDirectory
 }
 
 def getAndroidCompileSdkVersion() {
-  project(':library').android.compileSdkVersion
+    project(':library').android.compileSdkVersion
 }
 
-def getInternalAndroidProjects() {
-    [':third_party:gif_decoder', ':library'].collect { project(it) }
+def getInternalAndroidProjectsForJar() {
+    asProjects(getAndroidPathsForJar())
 }
-def getInternalJavaProjects() {
-    [':third_party:disklrucache'].collect { project(it) }
+
+def getInternalJavaProjectsForJar() {
+    asProjects(getJavaPathsForJar())
+}
+
+def getInternalAndroidProjectsForJavadoc() {
+    asProjects(getAndroidPathsForJavadoc())
 }
 
-def getAllInternalProjects() {
-    getInternalAndroidProjects() + getInternalJavaProjects()
+def getInternalJavaProjectsForJavadoc() {
+    asProjects(getJavaPathsForJavadoc())
 }
 
-def getReleaseVariantAndroidProjects() {
-    getAndroidLibraryVariants('release')
+def getAndroidProjectsForJar() {
+    getAndroidLibraryVariantsForJar('debug')
 }
 
-def getAndroidLibraryVariants(variantName) {
-    getInternalAndroidProjects().collect { project ->
+def getAndroidLibraryVariantsForJar(variantName) {
+    getAndroidLibraryVariants(getInternalAndroidProjectsForJar(), variantName)
+}
+
+def getAndroidLibraryVariantsForJavadoc(variantName) {
+    getAndroidLibraryVariants(getInternalAndroidProjectsForJavadoc(), variantName)
+}
+
+static def getAndroidLibraryVariants(projects, variantName) {
+    projects.collect { project ->
         project.android.libraryVariants.findAll { type ->
             type.buildType.name.equalsIgnoreCase(variantName)
         }
     }.sum()
 }
 
-def getSourceFilesForVariant(variantName) {
-    getAndroidLibraryVariants(variantName).collect { it.javaCompile.source } +
-            getInternalJavaProjects().collect { it.sourceSets.main.allJava }
+def getSourceFilesForVariantJar(variantName) {
+    getAndroidLibraryVariantsForJar(variantName).collect {
+        it.getJavaCompiler().source.findAll {
+            return !it.getName().equals("R.java") && !it.getName().equals("BuildConfig.java")
+        }
+    } + getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }
+}
+
+def getSourceFilesForVariantJavadoc(variantName) {
+    getAndroidLibraryVariantsForJavadoc(variantName).collect { it.getJavaCompiler().source } +
+            getInternalJavaProjectsForJavadoc().collect { it.sourceSets.main.allJava }
 }
 
 def getAndroidJar() {
     "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar"
 }
 
-// Generate javadocs and sources containing batched documentation and sources for all internal projects.
-['release', 'debug'].each { variantName ->
+project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
+
+// Generate javadocs and sources containing batched documentation and sources for all internal
+// projects.
+['debug'].each { variantName ->
 
     task("${variantName}SourceJar", type: Jar) {
-      from getSourceFilesForVariant(variantName)
+        from getSourceFilesForVariantJar(variantName)
     }
 
-    def javadocTask = task("${variantName}Javadoc", type: Javadoc) {
-        source = getSourceFilesForVariant(variantName)
-
-        classpath = files(getAndroidLibraryVariants(variantName).collect {
-            files(it.javaCompile.classpath.files, getAndroidJar())
-        })
-        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }
+    def javadocTask = tasks.create("${variantName}Javadoc", Javadoc) {
+        source = getSourceFilesForVariantJar(variantName)
+        source += getSourceFilesForVariantJavadoc(variantName)
+
+        doFirst {
+            it.classpath =
+                    project.files(
+                            getAndroidJar(),
+                            getAndroidLibraryVariantsForJar(variantName).collect {
+                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files
+                            },
+                            getAndroidLibraryVariantsForJavadoc(variantName).collect {
+                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files
+                            },
+                            getInternalJavaProjectsForJavadoc().collect { Project project ->
+                                project.sourceSets.main.compileClasspath.files
+                            },
+                            getInternalJavaProjectsForJar().collect { Project project ->
+                                project.sourceSets.main.compileClasspath.files
+                            },
+                            // Finds dependencies of Android packages that would otherwise be
+                            // ignored (Volley in particular)
+                            getInternalAndroidProjectsForJavadoc().collect { Project project ->
+                                project.file('build/intermediates/classes/debug')
+                            }
+            )
+        }
 
         options {
             links("http://docs.oracle.com/javase/7/docs/api/")
-            linksOffline("http://d.android.com/reference", "${getAndroidSdkDirectory()}/docs/reference")
+            links("https://square.github.io/okhttp/3.x/okhttp/")
+            links("https://square.github.io/okhttp/2.x/okhttp/")
+            linksOffline("http://d.android.com/reference",
+                    "${getAndroidSdkDirectory()}/docs/reference")
         }
 
         exclude '**/BuildConfig.java'
         exclude '**/R.java'
-    } as Javadoc
+    }
 
     def cleanJavadocTask = task("clean${variantName.capitalize()}Javadoc", type: Delete) {
         delete javadocTask.destinationDir
@@ -74,33 +154,41 @@ def getAndroidJar() {
     clean.dependsOn(cleanJavadocTask)
 
     def javadocJarTask = task("${variantName}JavadocJar", type: Jar) {
-      from javadocTask.destinationDir
+        from javadocTask.destinationDir
     } as Task
     javadocJarTask.dependsOn(javadocTask)
 }
 
 jar {
     from files(
-            getReleaseVariantAndroidProjects().collect { variant ->
-                variant.javaCompile.destinationDir
+            getAndroidProjectsForJar().collect { LibraryVariant variant ->
+                variant.getJavaCompiler().destinationDir
             }
     )
+    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output })
     exclude "**/R.class"
     exclude "**/BuildConfig.class"
-    from files(getInternalJavaProjects().collect { it.sourceSets.main.output })
+    exclude "**/R\$*.class"
+    exclude "android/**"
 }
 
-getAllInternalProjects().each { project ->
-    jar.dependsOn(project.tasks.build)
+(getInternalAndroidProjectsForJar() + getInternalAndroidProjectsForJavadoc()).each {
+    project ->
+        debugJavadoc.dependsOn(project.tasks.compileDebugSources)
+        jar.dependsOn(project.tasks.compileDebugSources)
+}
+
+(getInternalJavaProjectsForJar() + getInternalJavaProjectsForJavadoc()).each {
+    project ->
+        debugJavadoc.dependsOn(project.tasks.compileJava)
+        jar.dependsOn(project.tasks.compileJava)
 }
 
 artifacts {
-    archives releaseJavadocJar {
+    archives debugJavadocJar {
         classifier 'javadoc'
     }
-    archives releaseSourceJar {
+    archives debugSourceJar {
         classifier 'sources'
     }
 }
-
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
diff --git a/glide/gradle.properties b/glide/gradle.properties
index f205a7f3f..ba722e44c 100644
--- a/glide/gradle.properties
+++ b/glide/gradle.properties
@@ -1,4 +1,3 @@
-POM_NAME=Glide
-POM_ARTIFACT_ID=glide
+POM_NAME=Glide Full
+POM_ARTIFACT_ID=glide-full
 POM_PACKAGING=jar
-
diff --git a/gradle.properties b/gradle.properties
index 2f1163513..6e13ac59c 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,8 +1,10 @@
-VERSION_NAME=4.0.0-SNAPSHOT
+org.gradle.daemon=true
+org.gradle.configureondemand=true
+
+VERSION_NAME=4.6.1
 VERSION_MAJOR=4
-VERSION_MINOR=0
-VERSION_PATCH=0
-VERSION_CODE=12
+VERSION_MINOR=6
+VERSION_PATCH=1
 GROUP=com.github.bumptech.glide
 
 POM_DESCRIPTION=A fast and efficient image loading library for Android focused on smooth scrolling.
@@ -13,26 +15,32 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
+ANDROID_SUPPORT_VERSION=27.0.2
+VOLLEY_VERSION=1.0.0
+OK_HTTP_VERSION=3.9.1
+ANDROID_GRADLE_VERSION=3.0.1
+DAGGER_VERSION=2.11
 
-SUPPORT_V4_VERSION=22.2.0
-SUPPORT_V7_VERSION=22.2.0
-VOLLEY_VERSION=1.0.16
-OK_HTTP_VERSION=2.3.0
-# TODO: use this in library/build.gradle.
-ANDROID_GRADLE_VERSION=1.2.3
-
-ROBOLECTRIC_GRADLE_VERSION=1.1.0
-COVERALLS_GRADLE_VERSION=2.4.0
-JUNIT_VERSION=4.12
-MOCKITO_VERSION=1.10.19
-ROBOLECTRIC_VERSION=3.0-rc3
-MOCKWEBSERVER_VERSION=2.3.0
-TRUTH_VERSION=0.25
+JUNIT_VERSION=4.13-SNAPSHOT
+# Matches the version in Google.
+MOCKITO_VERSION=1.9.5
+MOCKITO_ANDROID_VERSION=2.11.0
+ROBOLECTRIC_VERSION=3.6.1
+MOCKWEBSERVER_VERSION=3.0.0-RC1
+TRUTH_VERSION=0.36
+JSR_305_VERSION=3.0.2
+AUTO_SERVICE_VERSION=1.0-rc3
+JAVAPOET_VERSION=1.9.0
 
+PMD_VERSION=6.0.0
 FINDBUGS_VERSION=3.0.0
-JACOCO_VERSION=0.7.1.201405082137
+ERROR_PRONE_VERSION=2.1.4-SNAPSHOT
+ERROR_PRONE_PLUGIN_VERSION=0.0.13
+VIOLATIONS_PLUGIN_VERSION=1.8
+
+COMPILE_SDK_VERSION=27
+TARGET_SDK_VERSION=27
+MIN_SDK_VERSION=14
 
-COMPILE_SDK_VERSION=22
-BUILD_TOOLS_VERSION=22.0.1
-TARGET_SDK_VERSION=22
-MIN_SDK_VERSION=10
+org.gradle.jvmargs=-Xmx4096M
+TEST_JVM_MEMORY_SIZE=4096M
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index c97a8bdb9..c44b679ac 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 25f7d42d7..a8a029ed7 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed May 20 08:28:58 PDT 2015
+#Sun Feb 11 17:13:25 PST 2018
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.5.1-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269e..cccdd3d51 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
index aec99730b..e95643d6a 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,10 +46,9 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/instrumentation/build.gradle b/instrumentation/build.gradle
new file mode 100644
index 000000000..c9ab489a7
--- /dev/null
+++ b/instrumentation/build.gradle
@@ -0,0 +1,49 @@
+tasks.whenTaskAdded { task ->
+    if (task.name == "lint") {
+        task.enabled = false
+    }
+}
+apply plugin: 'com.android.application'
+
+dependencies {
+    // Appcompat is required to ensure that Glide's runtime detection the v7 support Drawable
+    // loading classes functions. It's not clear why androidTestImplementation isn't sufficient, but for
+    // whatever reason, compile is the only dependency that seems to work.
+    implementation ("com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}") {
+        exclude group: 'android.arch.core'
+    }
+    annotationProcessor project(":annotation:compiler")
+    implementation project(":library")
+
+    androidTestImplementation project(':library')
+    androidTestImplementation "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}"
+    androidTestImplementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    androidTestImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    androidTestImplementation 'com.android.support.test:runner:1.0.1'
+    androidTestImplementation 'com.android.support.test:rules:1.0.1'
+    androidTestImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    androidTestImplementation "junit:junit:${JUNIT_VERSION}"
+    // Not totally clear why this is required, but it seems to be missing when tests are run on
+    // 4.1.2 and 4.2.0 emulators.
+    androidTestImplementation 'com.google.code.findbugs:jsr305:3.0.2'
+
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        applicationId 'com.bumptech.glide.instrumentation'
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionCode 1
+        versionName '1.0'
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
diff --git a/instrumentation/src/androidTest/AndroidManifest.xml b/instrumentation/src/androidTest/AndroidManifest.xml
new file mode 100644
index 000000000..f12090f37
--- /dev/null
+++ b/instrumentation/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.instrumentation.test">
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+  <application android:label="GlideTest">
+    <uses-library android:name="android.test.runner" />
+  </application>
+
+  <instrumentation android:targetPackage="com.bumptech.glide.instrumentation"
+                   android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner"
+                   android:label="Glide Emulator Tests" />
+</manifest>
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
new file mode 100644
index 000000000..920e9635b
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
@@ -0,0 +1,221 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class AsBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadImageResourceId_asBytes_providesBytesOfBitmap() {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.canonical)
+                .submit());
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmap_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(bitmap)
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmapDrawable_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(new BitmapDrawable(context.getResources(), bitmap))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_withFrameTime_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile())
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(Uri.fromFile(writeVideoToFile()))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(Uri.fromFile(writeVideoToFile()))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  private File writeVideoToFile() throws IOException {
+    byte[] videoData = loadVideoBytes();
+    File parent = context.getCacheDir();
+    if (!parent.mkdirs() && (!parent.exists() || !parent.isDirectory())) {
+      throw new IllegalStateException("Failed to mkdirs for: " + parent);
+    }
+    File toWrite = new File(parent, "temp.jpeg");
+    if (toWrite.exists() && !toWrite.delete()) {
+      throw new IllegalStateException("Failed to delete existing temp file: " + toWrite);
+    }
+
+    OutputStream os = null;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(toWrite));
+      os.write(videoData);
+      os.close();
+    } finally {
+      if (os != null) {
+        os.close();
+      }
+    }
+    return toWrite;
+  }
+
+  private byte[] loadVideoBytes() throws IOException {
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(ResourceIds.raw.video);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
new file mode 100644
index 000000000..057c95c5a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
@@ -0,0 +1,124 @@
+package com.bumptech.glide;
+
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.MockModelLoader;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class AsFileTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Test
+  public void asFile_withUrl_succeeds() {
+    String url = "https://www.w3schools.com/howto/img_fjords.jpg";
+
+    MockModelLoader.mock(url, getData());
+
+    File file =
+        concurrency.get(
+            GlideApp.with(context)
+                .asFile()
+                .load("https://www.w3schools.com/howto/img_fjords.jpg")
+                .submit());
+    assertThat(file).isNotNull();
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyData_succeeds() {
+    String url = "https://www.w3schools.com/howto/img_fjords.jpg";
+
+    MockModelLoader.mock(url, getData());
+
+    File file =
+        concurrency.get(
+            GlideApp.with(context)
+                .asFile()
+                .diskCacheStrategy(DiskCacheStrategy.DATA)
+                .load("https://www.w3schools.com/howto/img_fjords.jpg")
+                .submit());
+    assertThat(file).isNotNull();
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyResource_fails() {
+    String url = "https://www.w3schools.com/howto/img_fjords.jpg";
+
+    MockModelLoader.mock(url, getData());
+
+    try {
+      concurrency.get(
+          GlideApp.with(context)
+              .asFile()
+              .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+              .load("https://www.w3schools.com/howto/img_fjords.jpg")
+              .submit());
+      fail();
+    } catch (RuntimeException e) {
+      // expected.
+    }
+  }
+
+  @Test
+  public void asFile_withUrlAndDiskCacheStrategyAll_fails() {
+    String url = "https://www.w3schools.com/howto/img_fjords.jpg";
+
+    MockModelLoader.mock(url, getData());
+
+    try {
+      concurrency.get(
+          GlideApp.with(context)
+              .asFile()
+              .diskCacheStrategy(DiskCacheStrategy.ALL)
+              .load("https://www.w3schools.com/howto/img_fjords.jpg")
+              .submit());
+      fail();
+    } catch (RuntimeException e) {
+      // Expected.
+    }
+  }
+
+  private InputStream getData() {
+    InputStream is = null;
+    try {
+      is = context.getResources().openRawResource(ResourceIds.raw.canonical);
+      byte[] buffer = new byte[1024 * 1024];
+      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+      int read;
+      while ((read = is.read(buffer)) != -1) {
+        outputStream.write(buffer, 0, read);
+      }
+      byte[] data = outputStream.toByteArray();
+      return new ByteArrayInputStream(data);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
new file mode 100644
index 000000000..194d5afbf
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -0,0 +1,493 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+import static org.mockito.AdditionalMatchers.not;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests various aspects of memory and disk caching to verify resources can be retrieved as we
+ * expect.
+ */
+@RunWith(AndroidJUnit4.class)
+public class CachingTest {
+  private static final int IMAGE_SIZE_PIXELS = 500;
+  // Store at least 10 500x500 pixel Bitmaps with the ARGB_8888 config to be safe.
+  private static final long CACHE_SIZE_BYTES =
+      IMAGE_SIZE_PIXELS * IMAGE_SIZE_PIXELS * 4 * 10;
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws InterruptedException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));
+  }
+
+  @Test
+  public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    FutureTarget<Drawable> first =
+        GlideApp.with(context)
+            .load(raw.canonical)
+            .submit();
+    concurrency.get(first);
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {
+    Glide.init(
+        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));
+
+    // Allow the request to be run and GCed without being cleared.
+    concurrency.loadOnOtherThread(new Runnable() {
+      @Override
+      public void run() {
+        FutureTarget<Drawable> first =
+            GlideApp.with(context)
+                .load(raw.canonical)
+                .submit();
+        concurrency.get(first);
+      }
+    });
+
+    // Wait for the weak reference to be cleared and the request to be removed from active
+    // resources.
+    // De-flake by allowing multiple tries
+    boolean isWeakRefCleared = false;
+    for (int j = 0; j < 100; j++) {
+      Runtime.getRuntime().gc();
+      concurrency.pokeMainThread();
+      try {
+        // Loading again here won't shuffle our resource around because it only changes our
+        // reference count from 1 to 2 and back. The reference we're waiting for will only be
+        // decremented when the target is GCed.
+        Target<Drawable> target =
+            concurrency.wait(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .onlyRetrieveFromCache(true)
+                    .diskCacheStrategy(DiskCacheStrategy.NONE)
+                    .submit());
+        GlideApp.with(context).clear(target);
+      } catch (RuntimeException e) {
+        // The item has been cleared from active resources.
+        isWeakRefCleared = true;
+        break;
+      }
+    }
+
+    if (!isWeakRefCleared) {
+      fail("Failed to clear weak ref.");
+    }
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            not(eq(DataSource.MEMORY_CACHE)),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache()
+      throws InterruptedException, ExecutionException, TimeoutException {
+    FutureTarget<Drawable> future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    GlideApp.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache()
+      throws InterruptedException, TimeoutException, ExecutionException {
+    // We can't allow any mocks (RequestListner, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+    concurrency.pokeMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecycleBitmap()
+      throws InterruptedException, TimeoutException, ExecutionException {
+    // We can't allow any mocks (RequestListener, Target etc) to reference this request or the test
+    // will fail due to the transient strong reference to the request.
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.canonical)
+                .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+                .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    // Force the collection of weak references now that the listener/request in the first load is no
+    // longer referenced.
+    Runtime.getRuntime().gc();
+    concurrency.pokeMainThread();
+
+    FutureTarget<Bitmap> future = GlideApp.with(context)
+        .asBitmap()
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    Glide.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+
+    BitmapSubject.assertThat(bitmap).isNotRecycled();
+  }
+
+  @Test
+  public void clearDiskCache_doesNotPreventFutureLoads()
+      throws ExecutionException, InterruptedException, TimeoutException {
+    FutureTarget<Drawable> future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+    GlideApp.with(context).clear(future);
+
+    clearMemoryCacheOnMainThread();
+    GlideApp.get(context).clearDiskCache();
+
+    future = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);
+    concurrency.get(future);
+
+    GlideApp.with(context).clear(future);
+    clearMemoryCacheOnMainThread();
+
+    concurrency.get(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+  }
+
+  // Tests #2428.
+  @Test
+  public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {
+    final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+
+    FutureTarget<Drawable> loadFromSourceFuture = GlideApp.with(context)
+        .load(waitModel)
+        .submit();
+
+    FutureTarget<Drawable> onlyFromCacheFuture = GlideApp.with(context)
+        .load(waitModel)
+        .onlyRetrieveFromCache(true)
+        .submit();
+    try {
+      onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);
+      fail("Expected only from cache Future to time out");
+    } catch (InterruptedException | TimeoutException e) {
+      throw new RuntimeException(e);
+    } catch (ExecutionException e) {
+      // Expected.
+    }
+    waitModel.countDown();
+
+    assertThat(concurrency.get(loadFromSourceFuture)).isNotNull();
+  }
+
+  // Tests #2428.
+  @Test
+  public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doesNotFail() {
+    // Block the main thread so that we know that both requests will be queued but not started at
+    // the same time.
+    final CountDownLatch blockMainThread = new CountDownLatch(1);
+    new Handler(Looper.getMainLooper()).post(new Runnable() {
+      @Override
+      public void run() {
+         try {
+          blockMainThread.await();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    });
+
+    // Queue the retrieve from cache request first.
+    final Future<Drawable> firstQueuedFuture = GlideApp.with(context)
+        .load(ResourceIds.raw.canonical)
+        .onlyRetrieveFromCache(true)
+        .submit();
+
+    // Then queue the normal request.
+    FutureTarget<Drawable> expectedFuture =
+        GlideApp.with(context).load(ResourceIds.raw.canonical).submit();
+
+    // Run the requests.
+    blockMainThread.countDown();
+
+    // Verify that the request that didn't have retrieve from cache succeeds
+    assertThat(concurrency.get(expectedFuture)).isNotNull();
+    // The first request only from cache should fail because the item is not in cache.
+    assertThrows(RuntimeException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        concurrency.get(firstQueuedFuture);
+      }
+    });
+  }
+
+  @Test
+  public void loadIntoView_withoutSkipMemoryCache_loadsFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform(),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we
+    // do end up re-using the old Target, our wait will always timeout anyway if we use
+    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener
+    // below, which expects to be called synchronously.
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .listener(requestListener)
+                .dontTransform()
+                .into(imageView);
+          }
+        });
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadIntoView_withSkipMemoryCacheFalse_loadsFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .skipMemoryCache(false)
+            .dontTransform(),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we
+    // do end up re-using the old Target, our wait will always timeout anyway if we use
+    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener
+    // below, which expects to be called synchronously.
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .listener(requestListener)
+                .skipMemoryCache(false)
+                .dontTransform()
+                .into(imageView);
+          }
+        });
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadIntoView_withSkipMemoryCache_doesNotLoadFromMemoryCacheIfPresent() {
+    final ImageView imageView = new ImageView(context);
+    imageView.setLayoutParams(new LayoutParams(100, 100));
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform()
+            .skipMemoryCache(true),
+        imageView);
+
+    // Casting avoids a varags array warning.
+    //noinspection rawtypes
+    reset((RequestListener) requestListener);
+
+    // If this test fails due to a timeout, it's because we re-used the Target from the previous
+    // request, which breaks the logic in loadOnMainThread that expects a new Target's
+    // onResourceReady callback to be called. This can be confirmed by changing this to
+    // runOnMainThread and verifying that the RequestListener assertion below fails because
+    // the DataSource was from the memory cache.
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .dontTransform()
+            .skipMemoryCache(true),
+        imageView);
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            not(eq(DataSource.MEMORY_CACHE)),
+            anyBoolean());
+  }
+
+  private void clearMemoryCacheOnMainThread() throws InterruptedException {
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
new file mode 100644
index 000000000..17e397879
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
@@ -0,0 +1,96 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@RegressionTest
+@SplitByCpu
+@SplitBySdk({24, 21, 16})
+public class CenterCropRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void centerCrop_withSquareSmallerThanImage_returnsSquareImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(50));
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(50);
+  }
+
+  @Test
+  public void centerCrop_withRectangleSmallerThanImage_returnsRectangularImage()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(60, 70));
+    assertThat(result.getWidth()).isEqualTo(60);
+    assertThat(result.getHeight()).isEqualTo(70);
+  }
+
+  @Test
+  public void centerCrop_withSquareLargerThanImage_returnsUpscaledRectangularImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+          bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(canonical.getWidth() * 2));
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() * 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getWidth() * 2);
+  }
+
+  @Test
+  public void centerCrop_withRectangleLargerThanImage_returnsUpscaledRectangularImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerCrop()
+                .override(canonical.getWidth() * 2, canonical.getHeight() * 2));
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() * 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() * 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
new file mode 100644
index 000000000..5643c3b73
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
@@ -0,0 +1,105 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({24, 21, 16})
+@RegressionTest
+public class CenterInsideRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void centerInside_withSquareSmallerThanImage_returnsImageFitWithinSquare()
+      throws ExecutionException, InterruptedException {
+
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .centerInside()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(37);
+  }
+
+  @Test
+  public void centerInside_withSquareLargerThanImage_returnsOriginalImage()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .centerInside()
+              .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth());
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight());
+  }
+
+  @Test
+  public void centerInside_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .centerInside()
+              .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
+  }
+
+  @Test
+  public void centerInside_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .centerInside()
+              .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
new file mode 100644
index 000000000..d64c521e9
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
@@ -0,0 +1,104 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({26, 24, 23, 21, 18, 16})
+@RegressionTest
+public class CircleCropRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void circleCrop_withSquareSmallerThanImage_returnsSquaredImage()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .circleCrop()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(50);
+  }
+
+  @Test
+  public void circleCrop_withSquareLargerThanImage_returnsUpscaledFitImage()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .circleCrop()
+              .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(multipliedWidth);
+    assertThat(result.getHeight()).isEqualTo(multipliedWidth);
+  }
+
+  @Test
+  public void circleCrop_withNarrowRectangle_cropsWithin()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .circleCrop()
+              .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getWidth() / 10);
+  }
+
+  @Test
+  public void circleCrop_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .circleCrop()
+              .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getHeight() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
new file mode 100644
index 000000000..87ae694a7
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
@@ -0,0 +1,109 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.support.v4.content.ContextCompat;
+import android.util.Base64;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Preconditions;
+import java.io.ByteArrayOutputStream;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DataUriTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Test
+  public void load_withJpegAsDataUriString_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUriString(CompressFormat.JPEG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withPngDataUriString_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUriString(CompressFormat.PNG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withJpegAsDataUri_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUri(CompressFormat.JPEG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withPngAsDataUri_returnsBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(getDataUri(CompressFormat.PNG))
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  private Uri getDataUri(CompressFormat format) {
+    return Uri.parse(getDataUriString(format));
+  }
+
+  private String getDataUriString(CompressFormat format) {
+    String bytes = getBase64BitmapBytes(format);
+    String imageType;
+    switch (format) {
+      case PNG:
+        imageType = "png";
+        break;
+      case JPEG:
+        imageType = "jpeg";
+        break;
+      case WEBP:
+        imageType = "webp";
+        break;
+      default:
+        throw new IllegalArgumentException("Unrecognized format: " + format);
+    }
+
+    String mimeType = "image/" + imageType;
+    return "data:" + mimeType + ";base64," + bytes;
+  }
+
+  @SuppressWarnings("deprecation")
+  private String getBase64BitmapBytes(CompressFormat format) {
+    ByteArrayOutputStream bos = new ByteArrayOutputStream();
+    Drawable drawable =
+        Preconditions.checkNotNull(ContextCompat.getDrawable(context, ResourceIds.raw.canonical));
+    Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();
+    bitmap.compress(format, 100, bos);
+    byte[] data = bos.toByteArray();
+    return Base64.encodeToString(data, /*flags=*/ 0);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
new file mode 100644
index 000000000..370805966
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
@@ -0,0 +1,209 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.TransformationUtils;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.GlideApp;
+import java.util.concurrent.ExecutionException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class DrawableTransformationTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.get(context).clearDiskCache();
+    Glide.tearDown();
+  }
+
+  @Test
+  public void load_withColorDrawable_sizeOriginal_optionalTransform_returnsColorDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+    Drawable result = Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .optionalCenterCrop())
+        .submit()
+        .get();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  /**
+   * Transformations that do nothing can simply return the original Bitmap.
+   */
+  @Test
+  public void load_withColorDrawable_fixedSize_requiredUnitTransform_returnsOriginalDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    Drawable result = Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .centerCrop())
+        .submit(100, 100)
+        .get();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  /**
+   * Transformations that produce a different output color/shape/image etc will end up returning
+   * a {@link Bitmap} based on the original {@link Drawable} but with the transformation applied.
+   */
+  @Test
+  public void load_withColorDrawable_fixedSize_nonUnitRequiredTransform_returnsBitmapDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    Drawable result = Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .circleCrop())
+        .submit(100, 100)
+        .get();
+
+    Bitmap redSquare = Bitmap.createBitmap(100, 100, Config.ARGB_8888);
+    Canvas canvas = new Canvas(redSquare);
+    canvas.drawColor(Color.RED);
+
+    BitmapPool bitmapPool = mock(BitmapPool.class);
+    when(bitmapPool.get(100, 100, Bitmap.Config.ARGB_8888))
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    Bitmap expected = TransformationUtils.circleCrop(bitmapPool, redSquare, 100, 100);
+
+    assertThat(result).isInstanceOf(BitmapDrawable.class);
+    Bitmap bitmap = ((BitmapDrawable) result).getBitmap();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(100);
+    for (int x = 0; x < bitmap.getWidth(); x++) {
+      for (int y = 0; y < bitmap.getHeight(); y++) {
+        assertThat(bitmap.getPixel(x, y)).isEqualTo(expected.getPixel(x, y));
+      }
+    }
+  }
+
+  @Test
+  public void load_withColorDrawable_sizeOriginal_requiredTransform_fails()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    expectedException.expect(ExecutionException.class);
+    Glide.with(context)
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .centerCrop())
+        .submit()
+        .get();
+  }
+
+  @Test
+  public void load_withBitmapDrawable_andDoNothingTransformation_doesNotRecycleBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+
+    Drawable result = GlideApp.with(context)
+        .load(drawable)
+        .fitCenter()
+        .override(bitmap.getWidth(), bitmap.getHeight())
+        .submit()
+        .get();
+
+    BitmapSubject.assertThat(result).isNotRecycled();
+  }
+
+  @Test
+  public void load_withBitmapDrawable_andFunctionalTransformation_doesNotRecycleBitmap()
+      throws ExecutionException, InterruptedException {
+      Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+
+    Drawable result = GlideApp.with(context)
+        .load(drawable)
+        .fitCenter()
+        .override(bitmap.getWidth() / 2, bitmap.getHeight() / 2)
+        .submit()
+        .get();
+
+    BitmapSubject.assertThat(result).isNotRecycled();
+  }
+
+  @Test
+  public void load_withColorDrawable_fixedSize_unitBitmapTransform_recyclesIntermediates()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    int width = 100;
+    int height = 200;
+
+    GlideApp.with(context)
+        .load(colorDrawable)
+        .fitCenter()
+        .override(width, height)
+        .submit()
+        .get();
+
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    // Make sure we didn't put the same Bitmap twice.
+    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);
+    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);
+
+    assertThat(first).isNotSameAs(second);
+  }
+   @Test
+  public void load_withColorDrawable_fixedSize_functionalBitmapTransform_doesNotRecycleOutput()
+      throws ExecutionException, InterruptedException {
+    Drawable colorDrawable = new ColorDrawable(Color.RED);
+
+    int width = 100;
+    int height = 200;
+
+    Drawable result = GlideApp.with(context)
+        .load(colorDrawable)
+        .circleCrop()
+        .override(width, height)
+        .submit()
+        .get();
+
+     BitmapSubject.assertThat(result).isNotRecycled();
+
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    // Make sure we didn't put the same Bitmap twice.
+    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);
+    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);
+
+    assertThat(first).isNotSameAs(second);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
new file mode 100644
index 000000000..2e4898227
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
@@ -0,0 +1,164 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.io.File;
+import java.util.concurrent.CountDownLatch;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class ErrorHandlingTest {
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  // ResourceEncoders are expected not to throw and to return true or false. If they do throw, it's
+  // a developer error, so we expect UncaughtThrowableStrategy to be called.
+  @Test
+  public void load_whenEncoderFails_callsUncaughtThrowableStrategy() {
+    WaitForErrorStrategy strategy = new WaitForErrorStrategy();
+    Glide.init(context,
+        new GlideBuilder()
+            .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
+            .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
+            .setDiskCacheExecutor(GlideExecutor.newDiskCacheExecutor(strategy)));
+    Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
+
+    concurrency.get(
+        Glide.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    // Writing to the disk cache and therefore the exception caused by our FailEncoder may happen
+    // after the request completes, so we should wait for the expected error explicitly.
+    ConcurrencyHelper.waitOnLatch(strategy.latch);
+    assertThat(strategy.error).isEqualTo(FailEncoder.TO_THROW);
+
+    verify(requestListener, never())
+        .onLoadFailed(any(GlideException.class), any(), anyDrawableTarget(), anyBoolean());
+  }
+
+  @Test
+  public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {
+    WaitForErrorStrategy strategy = new WaitForErrorStrategy();
+    Glide.init(context,
+        new GlideBuilder()
+            .setAnimationExecutor(GlideExecutor.newAnimationExecutor(/*threadCount=*/ 1, strategy))
+            .setSourceExecutor(GlideExecutor.newSourceExecutor(strategy))
+            .setDiskCacheExecutor(GlideExecutor.newDiskCacheExecutor(strategy)));
+    Glide.get(context).getRegistry().prepend(Bitmap.class, new FailEncoder());
+
+    concurrency.get(
+        Glide.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            any(DataSource.class),
+            anyBoolean());
+    verify(requestListener, never())
+        .onLoadFailed(any(GlideException.class), any(), anyDrawableTarget(), anyBoolean());
+  }
+
+  @Test
+  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {
+    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+
+    FutureTarget<Drawable> target =
+        Glide.with(context)
+            .load((Object) null)
+            .error(
+                Glide.with(context)
+                    .load(errorModel)
+                    .listener(requestListener))
+            .submit();
+
+    Glide.with(context).clear(target);
+    errorModel.countDown();
+
+    // Make sure any pending requests run.
+    concurrency.pokeMainThread();
+    Glide.tearDown();
+    // Make sure that any callbacks posted back to the main thread run.
+    concurrency.pokeMainThread();
+  }
+
+  private static final class WaitForErrorStrategy implements UncaughtThrowableStrategy {
+    final CountDownLatch latch = new CountDownLatch(1);
+    @Nullable Throwable error = null;
+
+    @Override
+    public void handle(Throwable t) {
+      if (error != null) {
+        throw new IllegalArgumentException("Received second error", t);
+      }
+      error = t;
+      latch.countDown();
+    }
+  }
+
+  private static final class FailEncoder implements ResourceEncoder<Bitmap> {
+
+    static final RuntimeException TO_THROW = new RuntimeException();
+
+    @NonNull
+    @Override
+    public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
+      return EncodeStrategy.TRANSFORMED;
+    }
+
+    @Override
+    public boolean encode(
+        @NonNull Resource<Bitmap> data, @NonNull File file, @NonNull Options options) {
+      throw TO_THROW;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
new file mode 100644
index 000000000..bdda5fed0
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
@@ -0,0 +1,125 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.DiskCache.Factory;
+import com.bumptech.glide.load.engine.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.File;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+// Tests #2465.
+@RunWith(AndroidJUnit4.class)
+public class ExternallyClearedDiskCacheTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private File cacheDir;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    cacheDir = context.getCacheDir();
+  }
+
+  @After
+  public void tearDown() {
+    // Force us to wait until Glide's threads shut down.
+    Glide.tearDown();
+    deleteRecursively(cacheDir);
+  }
+
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+  }
+
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeletedAndCleared_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(new Factory() {
+              @Override
+              public DiskCache build() {
+                return cache;
+              }
+            }));
+
+    Drawable drawable =
+        concurrency.get(
+            Glide.with(context)
+                .load(ResourceIds.raw.canonical)
+                .submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeleted_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(new Factory() {
+              @Override
+              public DiskCache build() {
+                return cache;
+              }
+            }));
+
+    Drawable drawable =
+        concurrency.get(Glide.with(context)
+            .load(raw.canonical)
+            .submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  private static void deleteRecursively(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursively(f);
+        }
+      }
+    }
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
new file mode 100644
index 000000000..b78a20779
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
@@ -0,0 +1,123 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({24, 23, 21, 19, 18, 16})
+@RegressionTest
+public class FitCenterRegressionTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private BitmapRegressionTester bitmapRegressionTester;
+  private Context context;
+  private CanonicalBitmap canonical;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonical = new CanonicalBitmap();
+  }
+
+  @Test
+  public void fitCenter_withSquareSmallerThanImage_returnsImageFitWithinSquare()
+      throws ExecutionException, InterruptedException {
+
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(canonical.getBitmap())
+                .fitCenter()
+                .override(50));
+
+    assertThat(result.getWidth()).isEqualTo(50);
+    assertThat(result.getHeight()).isEqualTo(37);
+  }
+
+  @Test
+  public void fitCenter_withSquareLargerThanImage_returnsUpscaledSquare()
+      throws ExecutionException, InterruptedException {
+    float multiplier = 1.1f;
+    int multipliedWidth = (int) (canonical.getWidth() * multiplier);
+    int multipliedHeight = (int) (canonical.getHeight() * multiplier);
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .fitCenter()
+              .override(multipliedWidth));
+
+    assertThat(result.getWidth()).isEqualTo(multipliedWidth);
+    assertThat(result.getHeight()).isEqualTo(multipliedHeight);
+  }
+
+  @Test
+  public void fitCenter_withNarrowRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+    Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .fitCenter()
+              .override(canonical.getWidth() / 10, canonical.getHeight()));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 10);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 10);
+  }
+
+  @Test
+  public void fitCenter_withShortRectangle_fitsWithinMaintainingAspectRatio()
+      throws ExecutionException, InterruptedException {
+     Bitmap result =
+        bitmapRegressionTester.test(
+            GlideApp.with(context)
+              .asBitmap()
+              .load(canonical.getBitmap())
+              .fitCenter()
+              .override(canonical.getWidth(), canonical.getHeight() / 2));
+
+    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() / 2);
+    assertThat(result.getHeight()).isEqualTo(canonical.getHeight() / 2);
+  }
+
+  @Test
+  public void fitCenter_withHugeRectangle_throwsOOM()
+      throws ExecutionException, InterruptedException {
+    float multiplier = Integer.MAX_VALUE / (canonical.getWidth() * canonical.getHeight() * 2);
+    int overrideWidth = (int) multiplier * canonical.getWidth();
+    int overrideHeight = (int) multiplier * canonical.getHeight();
+    expectedException.expect(ExecutionException.class);
+    GlideApp
+        .with(context)
+        .asBitmap()
+        .load(canonical.getBitmap())
+        .fitCenter()
+        .override(overrideWidth, overrideHeight)
+        .submit()
+        .get();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
new file mode 100644
index 000000000..4e9ff73da
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
@@ -0,0 +1,363 @@
+package com.bumptech.glide;
+
+
+import static com.bumptech.glide.test.Matchers.anyBitmap;
+import static com.bumptech.glide.test.Matchers.anyBitmapTarget;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBitmapTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Bitmap> bitmapListener;
+  @Mock private RequestListener<Drawable> drawableListener;
+
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void clearFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(
+            anyBitmap(),
+            any(),
+            anyBitmapTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(
+            anyBitmap(),
+            any(),
+            anyBitmapTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
new file mode 100644
index 000000000..b6abc374d
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
@@ -0,0 +1,525 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.GlideOptions.skipMemoryCacheOf;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.AbsListView.LayoutParams;
+import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> requestListener;
+
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+
+    imageView = new ImageView(context);
+    int[] dimensions = getCanonicalDimensions();
+    imageView.setLayoutParams(new LayoutParams(/*w=*/ dimensions[0], /*h=*/ dimensions[1]));
+
+    // Writes to the resource disk cache run in a non-blocking manner after the Target is notified.
+    // Unless we enforce a single threaded executor, the encode task races with our second decode
+    // task, causing the test to sometimes fail (when the second resource is started after the
+    // encode and loaded from the disk cache) and sometimes succeed (when the second resource is
+    // started before the encode and loads from source).
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    GlideExecutor glideExecutor = MockGlideExecutor.newTestExecutor(executor);
+    Glide.init(context, new GlideBuilder()
+        .setAnimationExecutor(glideExecutor)
+        .setDiskCacheExecutor(glideExecutor)
+        .setSourceExecutor(glideExecutor));
+  }
+
+  @Test
+  public void loadFromRequestManager_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(
+        Glide.with(context).load(canonicalBytes), imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context).load(modifiedBytes), imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void loadFromRequestBuilder_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(canonicalBytes),
+        imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(modifiedBytes),
+        imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void requestManager_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .load(canonicalBytes)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void requestBuilder_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .asDrawable()
+            .load(canonicalBytes)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .asDrawable()
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .skipMemoryCache(false)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .skipMemoryCache(false)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+       throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+       throws IOException {
+    byte[] data = getCanonicalBytes();
+    Target<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withDiskCacheStrategySetBeforeLoad_doesNotOverrideDiskCacheStrategy()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .load(data)
+            .submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withSkipMemoryCacheSetBeforeLoad_doesNotOverrideSkipMemoryCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .skipMemoryCache(false)
+            .load(data)
+            .submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withDataDiskCacheStrategy_returnsFromSource() throws IOException {
+    byte[] data = getCanonicalBytes();
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .load(data)
+            .submit());
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.DATA)
+            .skipMemoryCache(true)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(),
+        any(),
+        anyDrawableTarget(),
+        eq(DataSource.DATA_DISK_CACHE),
+        anyBoolean());
+  }
+
+  private Bitmap copyFromImageViewDrawable(ImageView imageView) {
+    if (imageView.getDrawable() == null) {
+      fail("Drawable unexpectedly null");
+    }
+
+    // Glide mutates Bitmaps, so it's possible that a Bitmap loaded into a View in one place may
+    // be re-used to load a different image later. Create a defensive copy just in case.
+    return Bitmap.createBitmap(((BitmapDrawable) imageView.getDrawable()).getBitmap());
+  }
+
+  private int[] getCanonicalDimensions() throws IOException {
+    byte[] canonicalBytes = getCanonicalBytes();
+    Bitmap bitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    return new int[] { bitmap.getWidth(), bitmap.getHeight() };
+  }
+
+  private byte[] getModifiedBytes() throws IOException {
+    int[] dimensions = getCanonicalDimensions();
+    Bitmap bitmap = Bitmap.createBitmap(dimensions[0], dimensions[1], Config.ARGB_8888);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
+    return os.toByteArray();
+  }
+
+  private byte[] getCanonicalBytes() throws IOException {
+    int resourceId = ResourceIds.raw.canonical;
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(resourceId);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
new file mode 100644
index 000000000..de411130c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
@@ -0,0 +1,212 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> listener;
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void clear_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(drawable)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    Target<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
new file mode 100644
index 000000000..b2299e54a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
@@ -0,0 +1,349 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.ColorSpace;
+import android.net.Uri;
+import android.os.Build;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Locale;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * On API 26, decoding a variety of different images can cause {@link BitmapFactory} with
+ * {@link BitmapFactory.Options#inJustDecodeBounds} set to {@code true} to set
+ * {@link BitmapFactory.Options#outConfig} to null instead of a valid value, even though the image
+ * can be decoded successfully. Glide can mask these failures by decoding some image sources
+ * (notably including resource ids) using other data types and decoders.
+ *
+ * <p>This test ensures that we've worked around the framework issue by loading a variety of images
+ * and image types without the normal fallback behavior.
+ */
+@RunWith(AndroidJUnit4.class)
+public class LoadResourcesWithDownsamplerTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Test
+  public void loadJpegResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadWideGamutJpegResource_withNoOtherLoaders_decodesWideGamutBitmap() {
+    assumeTrue(
+        "Wide gamut is only available on O+", Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.webkit_logo_p3));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+    assertThat(bitmap.getColorSpace())
+        .isEqualTo(ColorSpace.get(ColorSpace.Named.LINEAR_EXTENDED_SRGB));
+  }
+
+  @Test
+  public void loadOpaquePngResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical_png));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentPngResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.canonical_transparent_png));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentGifResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.transparent_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadTransparentGifResource_asHardware_withNoOtherLoaders_decodesResource() {
+    assumeTrue(
+        "Hardware Bitmaps are only supported on O+",
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.transparent_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                // Allow HARDWARE Bitmaps.
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.HARDWARE);
+  }
+
+  @Test
+  public void loadTransparentGifResource_withNoOtherLoaders_fromBytes_decodesResource() {
+    byte[] data = getBytes(ResourceIds.raw.transparent_gif);
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_withNoOtherLoaders_decodesResource() {
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_asBytes_decodesResource() {
+    byte[] data = getBytes(ResourceIds.raw.opaque_gif);
+     Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void loadOpaqueGifResource_asHardware_withNoOtherLoaders_decodesResource() {
+    assumeTrue(
+        "Hardware Bitmaps are only supported on O+",
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+
+    Glide.get(context).getRegistry()
+        .prepend(
+            Object.class,
+            InputStream.class,
+            new FakeModelLoader<>(ResourceIds.raw.opaque_gif));
+
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                // Allow HARDWARE Bitmaps.
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(new Object())
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+
+  private byte[] getBytes(int resourceId) {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    InputStream is = null;
+    try {
+      is = context.getResources().openRawResource(resourceId);
+      byte[] buffer = new byte[1024 * 1024];
+      int read;
+      while ((read = is.read(buffer)) != -1) {
+        os.write(buffer, 0, read);
+      }
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (is != null) {
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored;
+        }
+      }
+    }
+
+    return os.toByteArray();
+  }
+
+  private class FakeModelLoader<T> implements
+      ModelLoader<T, InputStream>,
+      ModelLoaderFactory<T, InputStream> {
+
+    private final int resourceId;
+
+    FakeModelLoader(int resourceId) {
+      this.resourceId = resourceId;
+    }
+
+    @android.support.annotation.Nullable
+    @Override
+    public LoadData<InputStream> buildLoadData(@NonNull Object o, int width, int height,
+        @NonNull Options options) {
+      return new LoadData<>(new ObjectKey(o), new Fetcher());
+    }
+
+    @Override
+    public boolean handles(@NonNull Object o) {
+      return true;
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<T, InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
+      return this;
+    }
+
+    @Override
+    public void teardown() { }
+
+    private final class Fetcher implements DataFetcher<InputStream> {
+      private InputStream inputStream;
+
+      @Override
+      public void loadData(@NonNull Priority priority,
+          @NonNull DataCallback<? super InputStream> callback) {
+        inputStream = getInputStreamForResource(context, resourceId);
+        callback.onDataReady(inputStream);
+      }
+
+      private InputStream getInputStreamForResource(
+          Context context, @DrawableRes int resourceId) {
+        Resources resources = context.getResources();
+        try {
+          Uri parse =
+              Uri.parse(
+                  String.format(
+                      Locale.US,
+                      "%s://%s/%s/%s",
+                      ContentResolver.SCHEME_ANDROID_RESOURCE,
+                      resources.getResourcePackageName(resourceId),
+                      resources.getResourceTypeName(resourceId),
+                      resources.getResourceEntryName(resourceId)));
+          return context.getContentResolver().openInputStream(parse);
+        } catch (Resources.NotFoundException | FileNotFoundException e) {
+          throw new IllegalArgumentException("Resource ID " + resourceId + " not found", e);
+        }
+      }
+
+      @Override
+      public void cleanup() {
+        InputStream local = inputStream;
+        if (local != null) {
+          try {
+            local.close();
+          } catch (IOException e) {
+            // Ignored.
+          }
+        }
+      }
+
+      @Override
+      public void cancel() {
+        // Do nothing.
+      }
+
+      @NonNull
+      @Override
+      public Class<InputStream> getDataClass() {
+        return InputStream.class;
+      }
+
+      @NonNull
+      @Override
+      public DataSource getDataSource() {
+        return DataSource.LOCAL;
+      }
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
new file mode 100644
index 000000000..d99570490
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
@@ -0,0 +1,323 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests that Glide is able to load videos stored in resources and loaded as
+ * {@link android.content.res.AssetFileDescriptor}s.
+ */
+@RunWith(AndroidJUnit4.class)
+public class LoadVideoResourceTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            Glide.with(context)
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            Glide.with(context)
+                .load(new Integer(ResourceIds.raw.video))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(new Integer(ResourceIds.raw.video))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_withFrameTime_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
new file mode 100644
index 000000000..e41db5705
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
@@ -0,0 +1,531 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.request.RequestOptions.bitmapTransform;
+import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class NonBitmapDrawableResourcesTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(android.R.drawable.star_big_off)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asDrawable_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(android.R.drawable.star_big_off)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(android.R.drawable.star_big_off)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.bitmap_alias)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asDrawable_withTransformation_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.bitmap_alias)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withBitmapAliasResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.bitmap_alias)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_sizeOriginal_fails()
+      throws ExecutionException, InterruptedException {
+    expectedException.expect(ExecutionException.class);
+    Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_validSize_succeeds()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(bitmapTransform(new RoundedCorners(10)))
+        .submit(100, 200)
+        .get();
+    assertThat(drawable).isNotNull();
+    assertThat(drawable.getIntrinsicWidth()).isEqualTo(100);
+    assertThat(drawable.getIntrinsicHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withSizeOriginal_fails()
+      throws ExecutionException, InterruptedException {
+    expectedException.expect(ExecutionException.class);
+    Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit()
+        .get();
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withValidSize_returnsNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .submit(100, 200)
+        .get();
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withShapeDrawableResourceId_asBitmap_withValidSizeAndTransform_nonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.shape_drawable)
+        .apply(centerCropTransform())
+        .submit(100, 200)
+        .get();
+    assertThat(bitmap).isNotNull();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(200);
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.state_list_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.state_list_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.state_list_drawable)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withStateListDrawableResourceId_asBitmap_withTransformation_nonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.state_list_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.vector_drawable)
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asDrawable_withTransformation_nonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.vector_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.vector_drawable)
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withVectorDrawableResourceId_asBitmap_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.vector_drawable)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .submit()
+        .get();
+
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asDrawable_withTransformation_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException {
+    Drawable drawable = Glide.with(context)
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .submit()
+        .get();
+
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withNinePatchResourceId_asBitmap_withTransformation_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException {
+    Bitmap bitmap = Glide.with(context)
+        .asBitmap()
+        .load(ResourceIds.drawable.googlelogo_color_120x44dp)
+        .apply(centerCropTransform())
+        .submit()
+        .get();
+
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asDrawable_producesNonNullDrawable()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asDrawable_withTransformation_nonNullDrawable()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .apply(centerCropTransform())
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asBitmap_producesNonNullBitmap()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceIdUri_asBitmap_withTransformation_nonNullBitmap()
+      throws NameNotFoundException, ExecutionException, InterruptedException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .apply(centerCropTransform())
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asDrawable_producesNonNullDrawable()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asDrawable_withTransform_nonNullDrawable()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Drawable drawable = Glide.with(context)
+          .load(uri)
+          .apply(centerCropTransform())
+          .submit()
+          .get();
+      assertThat(drawable).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asBitmap_producesNonNullBitmap()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  @Test
+  public void load_withApplicationIconResourceNameUri_asBitmap_withTransform_nonNullBitmap()
+      throws ExecutionException, InterruptedException, NameNotFoundException {
+    for (String packageName : getInstalledPackages()) {
+      int iconResourceId = getResourceId(packageName);
+
+      Context toUse = context.createPackageContext(packageName, /*flags=*/ 0);
+      Resources resources = toUse.getResources();
+      Uri uri = new Uri.Builder()
+          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+          .authority(packageName)
+          .path(resources.getResourceTypeName(iconResourceId))
+          .path(resources.getResourceEntryName(iconResourceId))
+          .path(String.valueOf(iconResourceId))
+          .build();
+
+      Bitmap bitmap = Glide.with(context)
+          .asBitmap()
+          .apply(centerCropTransform())
+          .load(uri)
+          .submit()
+          .get();
+      assertThat(bitmap).isNotNull();
+    }
+  }
+
+  private Set<String> getInstalledPackages() {
+    Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
+    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+    PackageManager packageManager = context.getPackageManager();
+    List<ResolveInfo> pkgAppsList =
+        packageManager.queryIntentActivities(mainIntent, /*flags=*/ 0);
+    Set<String> result = new HashSet<>();
+    for (ResolveInfo info : pkgAppsList) {
+      int iconResourceId = getResourceId(info.activityInfo.packageName);
+      if (iconResourceId != 0) {
+        result.add(info.activityInfo.packageName);
+      }
+    }
+    return result;
+  }
+
+  private int getResourceId(String packageName) {
+    PackageInfo packageInfo;
+    try {
+      packageInfo = context.getPackageManager().getPackageInfo(packageName, /*flags=*/ 0);
+    } catch (NameNotFoundException e) {
+      return 0;
+    }
+    return packageInfo.applicationInfo.icon;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
new file mode 100644
index 000000000..2019c1758
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
@@ -0,0 +1,96 @@
+package com.bumptech.glide;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.ImageView;
+import com.bumptech.glide.manager.Lifecycle;
+import com.bumptech.glide.manager.LifecycleListener;
+import com.bumptech.glide.manager.RequestManagerTreeNode;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.ResourceIds.raw;
+import com.bumptech.glide.test.TearDownGlide;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class RequestManagerTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestManagerTreeNode treeNode;
+
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private RequestManager requestManager;
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+    Glide glide = Glide.get(context);
+    requestManager = new RequestManager(glide, new Lifecycle() {
+      @Override
+      public void addListener(@NonNull LifecycleListener listener) {
+        listener.onStart();
+      }
+
+      @Override
+      public void removeListener(@NonNull LifecycleListener listener) {
+        // Do nothing.
+      }
+    }, treeNode, context);
+  }
+
+  /**
+   * Tests #2262.
+   */
+  @Test
+  public void clear_withNonOwningRequestManager_afterOwningManagerIsDestroyed_doesNotThrow() {
+    // First destroy our Fragment/Activity RequestManager.
+    requestManager.onDestroy();
+
+    final ImageView imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+    // Then start a new load with our now destroyed RequestManager.
+    concurrency.loadOnMainThread(requestManager.load(ResourceIds.raw.canonical), imageView);
+
+    // Finally clear our new load with any RequestManager other than the one we used to start it.
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(context).clear(imageView);
+      }
+    });
+  }
+
+  /**
+   * Tests b/69361054.
+   */
+  @Test
+  public void clear_withNonOwningRequestManager_onBackgroundTHread_doesNotThrow() {
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        requestManager.onDestroy();
+      }
+    });
+
+    final Target<Drawable> target =
+        concurrency.wait(requestManager.load(raw.canonical).submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(context).clear(target);
+      }
+    });
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
new file mode 100644
index 000000000..c89ea575c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -0,0 +1,254 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests the behaviors of Requests of all types.
+ */
+@RunWith(AndroidJUnit4.class)
+public class RequestTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+    imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+
+    // Some emulators only have a single resize thread, so waiting on a latch will block them
+    // forever.
+    Glide.init(context,
+        new GlideBuilder().setSourceExecutor(GlideExecutor.newUnlimitedSourceExecutor()));
+  }
+
+  @Test
+  public void clear_withSingleRequest_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void clear_withRequestWithThumbnail_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequest_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnail_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(
+                GlideApp.with(context)
+                  .load(ResourceIds.raw.canonical)
+                  .override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequestInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .into(imageView);
+          }
+        });
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnailBothInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(model)
+                .thumbnail(
+                    GlideApp.with(context)
+                    .load(model)
+                    .override(100, 100))
+                .into(imageView);
+
+          }
+        });
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  /** Tests #2555. */
+  @Test
+  public void onStop_withRequestWithOnlyFullInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> mainModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(mainModel)
+            .listener(requestListener)
+                .thumbnail(GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+    assertThat(imageView.getDrawable()).isNull();
+    mainModel.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithOnlyThumbnailInProgress_doesNotNullOutDrawableInView() {
+    final WaitModel<Integer> thumbModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+                .thumbnail(GlideApp.with(context)
+                    .load(thumbModel)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+
+    // Only requests that are running are paused in onStop. The full request should take priority
+    // over the thumbnail request. Therefore, if the full request is finished in onStop, it should
+    // not be cleared, even if the thumbnail request is still running.
+    assertThat(imageView.getDrawable()).isNotNull();
+    thumbModel.countDown();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
new file mode 100644
index 000000000..0b9404aed
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.BitmapRegressionTester;
+import com.bumptech.glide.test.CanonicalBitmap;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.RegressionTest;
+import com.bumptech.glide.test.SplitByCpu;
+import com.bumptech.glide.test.SplitBySdk;
+import com.bumptech.glide.test.TearDownGlide;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+
+/**
+ * Compares the output of RoundedCorners with canonical resource files for all SDKs Glide supports
+ * and fails on deltas.
+ */
+@RunWith(AndroidJUnit4.class)
+@SplitByCpu
+@SplitBySdk({26, 24, 23, 21, 19, 18, 16})
+@RegressionTest
+public class RoundedCornersRegressionTest {
+  @Rule public final TestRule tearDownGlide = new TearDownGlide();
+  @Rule public final TestName testName = new TestName();
+
+  private Context context;
+  private BitmapRegressionTester bitmapRegressionTester;
+  private CanonicalBitmap canonicalBitmap;
+
+  @Before
+  public void setUp() throws Exception {
+    context = InstrumentationRegistry.getTargetContext();
+    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);
+    canonicalBitmap = new CanonicalBitmap();
+  }
+
+  @Test
+  public void testRoundedCorners() throws ExecutionException, InterruptedException {
+    bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .transform(new RoundedCorners(5)));
+  }
+
+  @Test
+  public void testRoundedCorners_usePool() throws ExecutionException, InterruptedException {
+    canonicalBitmap = canonicalBitmap.scale(0.1f);
+
+    Bitmap redRect =
+        createRect(
+            Color.RED,
+            canonicalBitmap.getWidth(),
+            canonicalBitmap.getHeight(),
+            Bitmap.Config.ARGB_8888);
+
+    Glide.get(context).getBitmapPool().put(redRect);
+
+    Bitmap roundedRect = bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .override(canonicalBitmap.getWidth(), canonicalBitmap.getHeight())
+            .transform(new RoundedCorners(5)));
+
+    assertThat(roundedRect).isEqualTo(redRect);
+  }
+
+  @Test
+  public void testRoundedCorners_overRounded() throws ExecutionException, InterruptedException {
+    bitmapRegressionTester.test(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(canonicalBitmap.getBitmap())
+            .transform(new RoundedCorners(20)));
+  }
+
+  private Bitmap createRect(int color, int width, int height, Bitmap.Config config) {
+    final Bitmap result = Bitmap.createBitmap(width, height, config);
+    Canvas canvas = new Canvas(result);
+    canvas.drawColor(color);
+    return result;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
new file mode 100644
index 000000000..17db2efb4
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
@@ -0,0 +1,228 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.graphics.ColorSpace;
+import android.graphics.ColorSpace.Named;
+import android.os.Build;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.ByteArrayOutputStream;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class WideGamutTest {
+  @Rule public final TestRule tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  @Before
+  public void setUp() {
+    assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);
+  }
+
+  @Test
+  public void load_withWideGamutImage_returnsWideGamutBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+  }
+
+  @Test
+  public void load_withWideGamutImage_bitmapInPoolWithSizeAndConfig_usesBitmapFromPool() {
+    int bitmapDimension = 1000;
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setBitmapPool(new LruBitmapPool(bitmapDimension * bitmapDimension * 8 * 4)));
+    Bitmap expected = Bitmap.createBitmap(bitmapDimension, bitmapDimension, Bitmap.Config.RGBA_F16);
+
+    Glide.get(context)
+        .getBitmapPool()
+        .put(expected);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .submit());
+    assertThat(bitmap).isSameAs(expected);
+  }
+
+  @Test
+  public void load_withWideGamutImage_hardwareAllowed_returnsHardwareBitmap() {
+    Bitmap bitmap =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .format(DecodeFormat.PREFER_ARGB_8888)
+                .load(ResourceIds.raw.webkit_logo_p3)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.HARDWARE);
+  }
+
+  @Test
+  public void load_withEncodedPngWideGamutImage_decodesWideGamut() {
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asPng(toCompress);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);
+  }
+
+  @Test
+  public void load_withEncodedJpegWideGamutImage_decodesArgb8888() {
+    // TODO(b/71430152): Figure out whether or not this is supposed to pass in API 26 and fail in
+    // API 27.
+    assumeTrue(Build.VERSION.SDK_INT != Build.VERSION_CODES.O_MR1);
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asJpeg(toCompress);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void load_withEncodedWebpWideGamutImage_decodesArgb8888() {
+    Bitmap toCompress =
+        Bitmap.createBitmap(
+            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));
+
+    byte[] data = asWebp(toCompress);
+
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void load_withSmallerWideGamutInPool_decodesBitmap() {
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    Bitmap toPut = Bitmap.createBitmap(300, 298, Config.RGBA_F16);
+    bitmapPool.put(toPut);
+    // Add a second Bitmap to account for the InputStream decode.
+    bitmapPool.put(Bitmap.createBitmap(toPut));
+
+    Bitmap wideGamut = Bitmap.createBitmap(300, 300, Config.RGBA_F16);
+    byte[] data = asPng(wideGamut);
+    Bitmap bitmap =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+    assertThat(bitmap).isNotNull();
+  }
+
+  @Test
+  public void circleCrop_withWideGamutBitmap_producesWideGamutBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);
+    byte[] data = asPng(bitmap);
+
+    Bitmap result =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(data)
+                .circleCrop()
+                .submit());
+    assertThat(result).isNotNull();
+    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);
+  }
+
+  @Test
+  public void roundedCorners_withWideGamutBitmap_producesWideGamutBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);
+    byte[] data = asPng(bitmap);
+
+    Bitmap result =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(data)
+                .transform(new RoundedCorners(/*roundingRadius=*/ 10))
+                .submit());
+    assertThat(result).isNotNull();
+    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);
+  }
+
+  @Test
+  public void loadWideGamutImage_withArgb888OfSufficientSizeInPool_usesArgb8888Bitmap() {
+    Bitmap wideGamut = Bitmap.createBitmap(100, 50, Bitmap.Config.RGBA_F16);
+    byte[] data = asPng(wideGamut);
+
+    Bitmap argb8888 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Glide.init(context, new GlideBuilder()
+        .setBitmapPool(new LruBitmapPool(wideGamut.getAllocationByteCount() * 5)));
+    Glide.get(context).getBitmapPool().put(argb8888);
+
+    Bitmap result =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(data)
+                .submit());
+
+    assertThat(result).isSameAs(argb8888);
+  }
+
+  private static byte[] asJpeg(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.JPEG);
+  }
+
+  private static byte[] asPng(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.PNG);
+  }
+
+  private static byte[] asWebp(Bitmap bitmap) {
+    return toByteArray(bitmap, CompressFormat.WEBP);
+  }
+
+  private static byte[] toByteArray(Bitmap bitmap, CompressFormat format) {
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    assertThat(bitmap.compress(format, 100, os)).isTrue();
+    return os.toByteArray();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..94ef1782c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,116 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.StrictMode;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+@VisibleForTesting
+public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return newTestExecutor(new DirectExecutorService());
+  }
+
+  /**
+   * @deprecated Use {@link #newMainThreadExecutor} instead.
+   */
+  @Deprecated
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder()
+            .detectNetwork()
+            .penaltyDeath()
+            .build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(new Runnable() {
+        @Override
+        public void run() {
+          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+          StrictMode.setThreadPolicy(THREAD_POLICY);
+          try {
+            command.run();
+          } finally {
+            StrictMode.setThreadPolicy(oldPolicy);
+          }
+        }
+      });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
new file mode 100644
index 000000000..4aac56188
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
@@ -0,0 +1,619 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static android.graphics.Bitmap.CompressFormat.JPEG;
+import static android.graphics.Bitmap.CompressFormat.PNG;
+import static android.graphics.Bitmap.CompressFormat.WEBP;
+import static android.os.Build.VERSION_CODES.KITKAT;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.apis;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.atAndAbove;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.below;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Api.onAllApisAndAllFormatsExpect;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Formats.Builder.allFormats;
+import static com.bumptech.glide.load.resource.bitmap.DownsamplerEmulatorTest.Formats.Builder.formats;
+import static org.junit.Assert.fail;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.Nullable;
+import android.support.test.runner.AndroidJUnit4;
+import android.util.DisplayMetrics;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Runs tests to make sure that DownsampleStrategy provides the output we expect.
+ *
+ * WEBP at and above N rounds. Webp below N floors. PNG always floors. JPEG always rounds.
+ */
+@RunWith(AndroidJUnit4.class)
+@SuppressWarnings("VisibleForTests")
+public class DownsamplerEmulatorTest {
+
+  @Test
+  public void calculateScaling_withAtMost() throws IOException {
+    new Tester(DownsampleStrategy.AT_MOST)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(75, 75))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(99, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(99, 12)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(50, 6))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(13, 100),
+                    formats(PNG)
+                        .expect(12, 100)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 100),
+                    formats(PNG, WEBP)
+                        .expect(12, 100)))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        // This set of examples demonstrate that webp uses round on N+ and floor < N.
+        .setTargetDimensions(13, 13)
+        .givenSquareImageWithDimensionOf(99,
+            atAndAbove(KITKAT)
+                .with(
+                    // 99 / 8.0 = 12.375. ceil(12.375) = 13. round(12.375) = 12. floor(12.375) = 12.
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)))
+        .givenSquareImageWithDimensionOf(100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    // 100 / 8.0 = 12.5. ceil(12.5) = 13. round(12.5) = 13. floor(12.5) = 12.
+                    formats(JPEG, WEBP)
+                        .expect(13, 13),
+                    formats(PNG)
+                        .expect(12, 12)),
+            below(VERSION_CODES.N)
+                .with(
+                    formats(JPEG)
+                        .expect(13, 13),
+                    formats(PNG, WEBP)
+                        .expect(12, 12)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withAtLeast() throws IOException {
+    new Tester(DownsampleStrategy.AT_LEAST)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(150, 150))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withCenterInside() throws IOException {
+    new Tester(DownsampleStrategy.CENTER_INSIDE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(200, 25),
+                    formats(PNG, WEBP)
+                        .expect(199, 25)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT).with(allFormats().expect(200, 25)))
+        .givenImageWithDimensionsOf(801, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            apis(KITKAT, VERSION_CODES.M)
+              .with(
+                  formats(JPEG)
+                      .expect(100, 13),
+                  formats(PNG, WEBP)
+                      .expect(100, 12)),
+            below(KITKAT)
+                .with(
+                    // JPEG is correct because CENTER_INSIDE wants to give a subsequent
+                    // transformation an image that is greater in size than the requested size. On
+                    // Api > VERSION_CODES.KITKAT, CENTER_INSIDE can do the transformation itself.
+                    // On < VERSION_CODES.KITKAT, it has to assume a subsequent transformation will
+                    // be called.
+                    formats(JPEG)
+                        .expect(101, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
+            below(KITKAT).with(allFormats().expect(25, 200)))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        .setTargetDimensions(897, 897)
+        .givenImageWithDimensionsOf(2208, 1520,
+            atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
+            below(KITKAT).with(allFormats().expect(1104, 760)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withCenterOutside() throws IOException {
+    new Tester(DownsampleStrategy.CENTER_OUTSIDE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78,
+            atAndAbove(KITKAT).with(allFormats().expect(112, 100)),
+            below(KITKAT).with(allFormats().expect(87, 78)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(200, 200)))
+        .givenSquareImageWithDimensionOf(450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(450, 450)))
+        .givenImageWithDimensionsOf(200, 450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 1125)),
+            below(KITKAT).with(allFormats().expect(200, 450)))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withNone() throws IOException {
+    new Tester(DownsampleStrategy.NONE)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(400, 400))
+        .givenSquareImageWithDimensionOf(300, onAllApisAndAllFormatsExpect(300, 300))
+        .givenImageWithDimensionsOf(799, 100, onAllApisAndAllFormatsExpect(799, 100))
+        .givenImageWithDimensionsOf(800, 100, onAllApisAndAllFormatsExpect(800, 100))
+        .givenImageWithDimensionsOf(801, 100, onAllApisAndAllFormatsExpect(801, 100))
+        .givenImageWithDimensionsOf(100, 800, onAllApisAndAllFormatsExpect(100, 800))
+        .givenImageWithDimensionsOf(87, 78, onAllApisAndAllFormatsExpect(87, 78))
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
+        .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
+        .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        .run();
+  }
+
+  @Test
+  public void calculateScaling_withFitCenter() throws IOException {
+    new Tester(DownsampleStrategy.FIT_CENTER)
+        .setTargetDimensions(100, 100)
+        .givenSquareImageWithDimensionOf(100, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(100, 100))
+        .givenSquareImageWithDimensionOf(400, onAllApisAndAllFormatsExpect(100, 100))
+        .givenImageWithDimensionsOf(300, 300,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 100)),
+            below(KITKAT).with(allFormats().expect(150, 150)))
+        .givenImageWithDimensionsOf(799, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(200, 25),
+                    formats(PNG, WEBP)
+                        .expect(199, 25)))
+        .givenImageWithDimensionsOf(800, 100,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 13)),
+            below(KITKAT).with(allFormats().expect(200, 25)))
+        .givenImageWithDimensionsOf(801, 100,
+            atAndAbove(VERSION_CODES.N)
+                .with(
+                    formats(JPEG, WEBP)
+                        .expect(100, 13),
+                    formats(PNG)
+                        .expect(100, 12)),
+            apis(KITKAT, VERSION_CODES.M)
+                .with(
+                    formats(JPEG)
+                        .expect(100, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)),
+            below(KITKAT)
+                .with(
+                    // JPEG is correct because FIT_CENTER wants to give a subsequent transformation
+                    // an image that is greater in size than the requested size. On
+                    // Api > VERSION_CODES.KITKAT, FIT_CENTER can do the transformation itself.
+                    // On < VERSION_CODES.KITKAT, it has to assume a transformation will be run
+                    // after it that will fix the rounding error.
+                    formats(JPEG)
+                        .expect(101, 13),
+                    formats(PNG, WEBP)
+                        .expect(100, 12)))
+        .givenImageWithDimensionsOf(100, 800,
+            atAndAbove(KITKAT).with(allFormats().expect(13, 100)),
+            below(KITKAT).with(allFormats().expect(25, 200)))
+        .givenImageWithDimensionsOf(87, 78,
+            atAndAbove(KITKAT).with(allFormats().expect(100, 90)),
+            below(KITKAT).with(allFormats().expect(87, 78)))
+        .setTargetDimensions(897, 897)
+        .givenImageWithDimensionsOf(2208, 1520,
+            atAndAbove(KITKAT).with(allFormats().expect(897, 618)),
+            below(KITKAT).with(allFormats().expect(1104, 760)))
+        .setTargetDimensions(270, 270)
+        // This set of larger image examples exercises sample sizes > 8. Android' scaling logic
+        // varies for jpegs.
+        .givenImageWithDimensionsOf(9014, 1638,
+            // 15 and 16 will OOM so don't run them.
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
+                .with(allFormats().expect(281, 51)))
+        .givenImageWithDimensionsOf(1638, 9014,
+            // 15 and 16 will OOM so don't run them.
+            atAndAbove(KITKAT).with(allFormats().expect(49, 270)),
+            apis(VERSION_CODES.JELLY_BEAN_MR1, VERSION_CODES.JELLY_BEAN_MR2)
+                .with(allFormats().expect(51, 281)))
+        .givenImageWithDimensionsOf(1638, 1638,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 270)),
+            below(KITKAT)
+                .with(
+                    formats(JPEG)
+                        .expect(410, 410),
+                    formats(PNG, WEBP)
+                        .expect(409, 409)))
+        .givenImageWithDimensionsOf(4507, 819,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            below(KITKAT).with(
+                formats(JPEG)
+                    .expect(282, 51),
+                formats(PNG, WEBP)
+                    .expect(281, 51)))
+        .givenImageWithDimensionsOf(4503, 819,
+            atAndAbove(KITKAT).with(allFormats().expect(270, 49)),
+            below(KITKAT).with(allFormats().expect(281, 51)))
+        // Upscaling
+        .setTargetDimensions(500, 500)
+        .givenSquareImageWithDimensionOf(200,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(200, 200)))
+        .givenSquareImageWithDimensionOf(450,
+            atAndAbove(KITKAT).with(allFormats().expect(500, 500)),
+            below(KITKAT).with(allFormats().expect(450, 450)))
+        .givenImageWithDimensionsOf(200, 450,
+            atAndAbove(KITKAT).with(allFormats().expect(222, 500)),
+            below(KITKAT).with(allFormats().expect(200, 450)))
+        .run();
+  }
+
+  /** Returns an error string if the test failed, and {@code null} otherwise. */
+  @Nullable
+  private static String runScaleTest(
+      CompressFormat format,
+      int initialWidth,
+      int initialHeight,
+      int targetWidth,
+      int targetHeight,
+      DownsampleStrategy strategy,
+      int expectedWidth,
+      int expectedHeight) throws IOException {
+    Downsampler downsampler = buildDownsampler();
+
+    InputStream is = openBitmapStream(format, initialWidth, initialHeight);
+    Options options = new Options()
+        .set(Downsampler.DOWNSAMPLE_STRATEGY, strategy);
+    Bitmap bitmap = downsampler.decode(is, targetWidth, targetHeight, options).get();
+    try {
+      if (bitmap.getWidth() != expectedWidth || bitmap.getHeight() != expectedHeight) {
+        return "API: " + Build.VERSION.SDK_INT + ", os: " + Build.VERSION.RELEASE
+            + ", format: " + format + ", strategy: " + strategy + " -"
+            + " Initial " + readableDimens(initialWidth, initialHeight)
+            + " Target " + readableDimens(targetWidth, targetHeight)
+            + " Expected " + readableDimens(expectedWidth, expectedHeight)
+            + ", but Received " + readableDimens(bitmap.getWidth(), bitmap.getHeight());
+      }
+    } finally {
+      bitmap.recycle();
+    }
+    return null;
+  }
+
+  private static String readableDimens(int width, int height) {
+    return "[" + width + "x" + height + "]";
+  }
+
+  private static Downsampler buildDownsampler() {
+    List<ImageHeaderParser> parsers =
+        Collections.<ImageHeaderParser>singletonList(new DefaultImageHeaderParser());
+    DisplayMetrics displayMetrics = new DisplayMetrics();
+    // XHDPI.
+    displayMetrics.densityDpi = 320;
+    BitmapPool bitmapPool = new BitmapPoolAdapter();
+    ArrayPool arrayPool = new LruArrayPool();
+    return new Downsampler(parsers, displayMetrics, bitmapPool, arrayPool);
+  }
+
+  private static InputStream openBitmapStream(CompressFormat format, int width, int height) {
+    Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(format, 100 /*quality*/, os);
+    bitmap.recycle();
+    byte[] data = os.toByteArray();
+    return new ByteArrayInputStream(data);
+  }
+
+  static final class Tester {
+    private final DownsampleStrategy strategy;
+    private final List<TestCase> testCases = new ArrayList<>();
+
+    private int targetWidth;
+    private int targetHeight;
+
+    Tester(DownsampleStrategy strategy) {
+      this.strategy = strategy;
+    }
+
+    Tester setTargetDimensions(int targetWidth, int targetHeight) {
+      this.targetWidth = targetWidth;
+      this.targetHeight = targetHeight;
+      return this;
+    }
+
+    Tester givenSquareImageWithDimensionOf(int dimension, Api... apis) {
+      return givenImageWithDimensionsOf(dimension, dimension, apis);
+    }
+
+    Tester givenImageWithDimensionsOf(
+        int sourceWidth, int sourceHeight, Api... apis) {
+      testCases.add(new TestCase(sourceWidth, sourceHeight, targetWidth, targetHeight, apis));
+      return this;
+    }
+
+    void run() throws IOException {
+      List<String> results = new ArrayList<>();
+      for (TestCase testCase : testCases) {
+        results.addAll(testCase.test(strategy));
+      }
+
+      if (results.isEmpty()) {
+        return;
+      }
+
+      StringBuilder failure = new StringBuilder("Failing Tests:\n");
+      for (String result : results) {
+        failure.append(result).append("\n");
+      }
+      fail(failure.substring(0, failure.length() - 1));
+    }
+
+    private static final class TestCase {
+      private final int sourceWidth;
+      private final int sourceHeight;
+      private final int targetWidth;
+      private final int targetHeight;
+      private final Api[] apis;
+
+      TestCase(int sourceWidth, int sourceHeight, int targetWidth, int targetHeight, Api... apis) {
+        this.sourceWidth = sourceWidth;
+        this.sourceHeight = sourceHeight;
+        this.targetWidth = targetWidth;
+        this.targetHeight = targetHeight;
+        this.apis = apis;
+      }
+
+      List<String> test(DownsampleStrategy strategy)
+          throws IOException {
+        List<String> results = new ArrayList<>();
+        for (Api api : apis) {
+          results.addAll(api.test(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
+        }
+        return results;
+      }
+    }
+  }
+
+  static final class Api {
+    private final int startVersion;
+    private final int stopVersion;
+    private final Formats[] formats;
+
+    static Builder apis(int min, int max) {
+      return new Builder().min(min).max(max);
+    }
+
+    static Builder atAndAbove(int min) {
+      return new Builder().min(min);
+    }
+
+    static Builder below(int max) {
+      // max is inclusive.
+      return new Builder().max(max - 1);
+    }
+
+    static Builder allApis() {
+      return new Builder();
+    }
+
+    static Api onAllApisAndAllFormatsExpect(int width, int height) {
+      return allApis().with(allFormats().expect(width, height));
+    }
+
+    static final class Builder {
+      private int maxVersion = Integer.MAX_VALUE;
+      private int minVersion = Integer.MIN_VALUE;
+
+      Builder min(int version) {
+        minVersion = version;
+        return this;
+      }
+
+      Builder max(int version) {
+        this.maxVersion = version;
+        return this;
+      }
+
+      Api with(Formats... formats) {
+        return new Api(minVersion, maxVersion, formats);
+      }
+    }
+
+    Api(int startVersion, int stopVersion, Formats... formats) {
+      this.startVersion = startVersion;
+      this.stopVersion = stopVersion;
+      this.formats = formats;
+    }
+
+    List<String> test(
+        int sourceWidth,
+        int sourceHeight,
+        int targetWidth,
+        int targetHeight,
+        DownsampleStrategy strategy)
+        throws IOException {
+      if (Build.VERSION.SDK_INT < startVersion || Build.VERSION.SDK_INT > stopVersion) {
+        return Collections.emptyList();
+      }
+
+      List<String> results = new ArrayList<>();
+      for (Formats format : formats) {
+        results.addAll(
+            format.runTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy));
+
+      }
+      return results;
+    }
+  }
+
+  static final class Formats {
+    private final int expectedWidth;
+    private final int expectedHeight;
+    private final CompressFormat[] formats;
+
+    static final class Builder {
+      private final CompressFormat[] formats;
+
+      static Builder allFormats() {
+        return formats(CompressFormat.values());
+      }
+
+      static Builder formats(CompressFormat... formats) {
+        return new Builder(formats);
+      }
+
+      Builder(CompressFormat... formats) {
+        this.formats = formats;
+      }
+
+      Formats expect(int width, int height) {
+        return new Formats(formats, width, height);
+      }
+    }
+
+    Formats(CompressFormat[] formats, int expectedWidth, int expectedHeight) {
+      this.formats = formats;
+      this.expectedWidth = expectedWidth;
+      this.expectedHeight = expectedHeight;
+    }
+
+    List<String> runTest(
+        int sourceWidth,
+        int sourceHeight,
+        int targetWidth,
+        int targetHeight,
+        DownsampleStrategy strategy) throws IOException {
+      List<String> result = new ArrayList<>();
+      for (CompressFormat format : formats) {
+        String testResult = runScaleTest(
+            format,
+            sourceWidth,
+            sourceHeight,
+            targetWidth,
+            targetHeight,
+            strategy,
+            expectedWidth,
+            expectedHeight);
+        if (testResult != null) {
+          result.add(testResult);
+        }
+      }
+      return result;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
new file mode 100644
index 000000000..57c48916e
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -0,0 +1,220 @@
+package com.bumptech.glide.load.resource.gif;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.Manifest.permission;
+import android.content.Context;
+import android.os.Build;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.rule.GrantPermissionRule;
+import android.support.test.runner.AndroidJUnit4;
+import android.view.View;
+import android.view.WindowManager;
+import android.view.WindowManager.LayoutParams;
+import android.widget.ImageView;
+import com.bumptech.glide.load.resource.gif.GifDrawable.GifState;
+import com.bumptech.glide.load.resource.gif.GifFrameLoader.OnEveryFrameListener;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Preconditions;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class GifDrawableTest {
+  @Rule public final TestName testName = new TestName();
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Rule public final GrantPermissionRule grantPermissionRule;
+  private final ConcurrencyHelper concurrencyHelper = new ConcurrencyHelper();
+
+  {
+    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
+      grantPermissionRule = GrantPermissionRule.grant(permission.SYSTEM_ALERT_WINDOW);
+    } else {
+      grantPermissionRule = GrantPermissionRule.grant();
+    }
+  }
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadGif_withInterlacedTransparentGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.interlaced_transparent_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withInterlacedTransparentGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.interlaced_transparent_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withTransparentGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.transparent_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withTransparentGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.transparent_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_gif)
+                .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueInterlacedGif_sizeOriginal_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+              .load(ResourceIds.raw.opaque_interlaced_gif)
+              .submit());
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_withOpaqueInterlacedGif_downsampled_succeeds()
+      throws ExecutionException, InterruptedException {
+    GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.opaque_interlaced_gif)
+                .submit(10, 10));
+    assertThat(gifDrawable).isNotNull();
+  }
+
+  @Test
+  public void loadGif_intoImageView_afterStop_restartsGif()
+      throws ExecutionException, InterruptedException {
+    // Mimic the state the Drawable can get into if it was loaded into a View previously and stopped
+    // so that it ended up with a pending frame that finished after the stop call.
+    final GifDrawable gifDrawable =
+        concurrencyHelper.get(
+            GlideApp.with(context)
+                .asGif()
+                .load(ResourceIds.raw.dl_world_anim)
+                .submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL));
+
+    final CountDownLatch waitForGifFrame = new CountDownLatch(1);
+    // Starting/Stopping loads in GIFs must happen on the main thread.
+    concurrencyHelper.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            // Make sure a frame is loaded while the drawable is stopped.
+            GifState gifState =
+                (GifState) Preconditions.checkNotNull(gifDrawable.getConstantState());
+            gifState.frameLoader.setOnEveryFrameReadyListener(new OnEveryFrameListener() {
+              @Override
+              public void onFrameReady() {
+                waitForGifFrame.countDown();
+              }
+            });
+            gifDrawable.start();
+            gifDrawable.stop();
+          }
+        });
+    ConcurrencyHelper.waitOnLatch(waitForGifFrame);
+
+    // Load the Drawable with the pending frame into a new View and make sure it ends up in the
+    // running state.
+    final ImageView imageView = new ImageView(context);
+    concurrencyHelper.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            addViewToWindow(imageView);
+          }
+        });
+
+    concurrencyHelper.loadOnMainThread(
+        GlideApp.with(context)
+            .load(gifDrawable)
+            .override(Target.SIZE_ORIGINAL),
+        imageView);
+
+    GifDrawable drawableFromView = (GifDrawable) imageView.getDrawable();
+    assertThat(drawableFromView.isRunning()).isTrue();
+
+    drawableFromView.stop();
+    gifDrawable.stop();
+  }
+
+  @SuppressWarnings("deprecation")
+  private void addViewToWindow(View view) {
+    WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams();
+    layoutParams.height = WindowManager.LayoutParams.MATCH_PARENT;
+    layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
+    layoutParams.type =
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
+            ? LayoutParams.TYPE_APPLICATION_OVERLAY
+            : Build.VERSION.SDK_INT == Build.VERSION_CODES.M
+                ? LayoutParams.TYPE_TOAST : LayoutParams.TYPE_SYSTEM_ALERT;
+    WindowManager windowManager =
+        (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    Preconditions.checkNotNull(windowManager).addView(view, layoutParams);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
new file mode 100644
index 000000000..f0510cca1
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
@@ -0,0 +1,186 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import android.os.Environment;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.RequestBuilder;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.concurrent.ExecutionException;
+import org.junit.rules.TestName;
+
+/**
+ * Checks for regressions for a given Glide load by comparing the result of a load to a previously
+ * saved Bitmap.
+ *
+ * <p>Can be used to generate or re-generate expected {@link Bitmap}s by placing a file named
+ * "regenerate" in /sdcard/DCIM/test_files. The apks containing this tester will need to have
+ * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE}. Resources can be split by apk
+ * by adding {@link SplitBySdk} to test methods or classes. If {@link SplitBySdk} is added to both
+ * a test class and a particular method, the values from the method will be used.
+ *
+ * <p>This class only handles exactly one Bitmap comparison per test method because the resource
+ * names it expects and generates are based on the method name.
+ */
+public final class BitmapRegressionTester {
+  private static final String RESOURCE_TYPE = "raw";
+  private static final String EXTENSION = ".png";
+  private static final String REGENERATE_SIGNAL_FILE_NAME = "regenerate";
+  private static final String GENERATED_FILES_DIR = "test_files";
+  private static final String SEPARATOR = "_";
+
+  private final Class<?> testClass;
+  private final TestName testName;
+  private final Context context = InstrumentationRegistry.getTargetContext();
+
+  public BitmapRegressionTester(Class<?> testClass, TestName testName) {
+    this.testClass = testClass;
+    this.testName = testName;
+
+    if (testClass.getAnnotation(RegressionTest.class) == null) {
+      throw new IllegalArgumentException(
+          testClass + " must be annotated with " + RegressionTest.class);
+    }
+  }
+
+  public Bitmap test(RequestBuilder<Bitmap> request)
+      throws ExecutionException, InterruptedException {
+    Bitmap result = request
+        .submit()
+        .get();
+    if (writeNewExpected()) {
+      writeBitmap(result);
+    }
+    Bitmap expected = decodeExpected();
+    BitmapSubject.assertThat(result).sameAs(expected);
+    return result;
+  }
+
+  private String getResourceName() {
+    return getClassNameString()
+        + SEPARATOR + testName.getMethodName().toLowerCase()
+        + getSdkIntString()
+        + getCpuString();
+  }
+
+  private String getClassNameString() {
+    StringBuilder result = new StringBuilder();
+    for (char c : testClass.getSimpleName().toCharArray()) {
+      if (Character.isUpperCase(c)) {
+        result.append(Character.toLowerCase(c));
+      }
+    }
+    return result.toString();
+  }
+
+  @Nullable
+  private SplitBySdk getSplitBySdkValues() {
+    SplitBySdk result;
+    try {
+      Method method =
+          testClass.getMethod(testName.getMethodName(), /*parameterTypes=*/ (Class[]) null);
+      result = method.getAnnotation(SplitBySdk.class);
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException(e);
+    }
+
+    if (result == null) {
+      result = testClass.getAnnotation(SplitBySdk.class);
+    }
+    return result;
+  }
+
+  @SuppressWarnings("deprecation")
+  private String getCpuString() {
+    return splitByCpu() ? SEPARATOR + Build.CPU_ABI.replace("-", "_") : "";
+  }
+
+  private boolean splitByCpu() {
+    return testClass.getAnnotation(SplitByCpu.class) != null;
+  }
+
+  private String getSdkIntString() {
+    SplitBySdk splitBySdk = getSplitBySdkValues();
+    if (splitBySdk == null) {
+      return "";
+    }
+    int targetSdk = -1;
+    int[] values = splitBySdk.value();
+    Arrays.sort(values);
+    for (int value : values) {
+      if (value > Build.VERSION.SDK_INT) {
+        break;
+      }
+      targetSdk = value;
+    }
+
+    if (targetSdk == -1) {
+      return "";
+    }
+
+    return SEPARATOR + targetSdk;
+  }
+
+  private File getTestFilesDir() {
+    File dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM);
+    return new File(dir, GENERATED_FILES_DIR);
+  }
+
+  private void writeBitmap(Bitmap bitmap) {
+    File testFilesDir = getTestFilesDir();
+    File subdirectory = new File(testFilesDir, RESOURCE_TYPE);
+    if (!subdirectory.exists() && !subdirectory.mkdirs()) {
+      throw new IllegalArgumentException("Failed to make directory: " + subdirectory);
+    }
+
+    File file = new File(subdirectory, getResourceName() + EXTENSION);
+    if (file.exists() && !file.delete()) {
+      throw new IllegalStateException("Failed to remove existing file: " + file);
+    }
+
+    OutputStream os = null;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(file));
+      bitmap.compress(CompressFormat.PNG, /*quality=*/100, os);
+      os.close();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      if (os != null) {
+        try {
+          os.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+
+  private boolean writeNewExpected() {
+    File testFiles = getTestFilesDir();
+    return new File(testFiles, REGENERATE_SIGNAL_FILE_NAME).exists();
+  }
+
+  private Bitmap decodeExpected() {
+    int resourceId =
+        context.getResources()
+            .getIdentifier(getResourceName(), RESOURCE_TYPE, context.getPackageName());
+    if (resourceId == 0) {
+      throw new IllegalArgumentException("Failed to find resource for: " + getResourceName()
+       + " with type: " + RESOURCE_TYPE + " and package: " + context.getPackageName());
+    }
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inScaled = false;
+    return BitmapFactory.decodeResource(context.getResources(), resourceId, options);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
new file mode 100644
index 000000000..fede0a765
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
@@ -0,0 +1,103 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import android.support.v4.content.res.ResourcesCompat;
+import com.google.common.truth.FailureMetadata;
+import com.google.common.truth.Subject;
+import com.google.common.truth.Truth;
+
+/**
+ * Truth assertions for comparing {@link Bitmap}s.
+ */
+// Test APIs.
+@SuppressWarnings({"WeakerAccess", "unused"})
+public final class BitmapSubject extends Subject<BitmapSubject, Bitmap> {
+
+  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =
+      new Subject.Factory<BitmapSubject, Bitmap>() {
+        @Override
+        public BitmapSubject createSubject(
+            @NonNull FailureMetadata metadata, @NonNull Bitmap actual) {
+          return new BitmapSubject(metadata, actual);
+        }
+      };
+
+  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {
+    super(failureMetadata, subject);
+  }
+
+  public static BitmapSubject assertThat(Drawable drawable) {
+    if (!(drawable instanceof BitmapDrawable)) {
+      throw new IllegalArgumentException("Not a BitmapDrawable: " + drawable);
+    }
+    return assertThat(((BitmapDrawable) drawable).getBitmap());
+  }
+
+  public static BitmapSubject assertThat(Bitmap bitmap) {
+    return Truth.assertAbout(FACTORY).that(bitmap);
+  }
+
+  @Override
+  protected String actualCustomStringRepresentation() {
+    return getDisplayString(actual());
+  }
+
+  private static String getDisplayString(Bitmap bitmap) {
+     return "<"
+        + "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "]"
+        + " "
+        + bitmap.getConfig()
+        + ">";
+  }
+
+  public void sameAs(@DrawableRes int resourceId) {
+    Context context = InstrumentationRegistry.getTargetContext();
+    Drawable drawable =
+        ResourcesCompat.getDrawable(context.getResources(), resourceId, context.getTheme());
+    sameAs(drawable);
+  }
+
+  public void isMutable()  {
+    if (!actual().isMutable()) {
+      fail("is mutable");
+    }
+  }
+
+  public void isImmutable() {
+    if (actual().isMutable()) {
+      fail("is immutable");
+    }
+  }
+
+  public void isNotRecycled() {
+    if (actual().isRecycled()) {
+      fail("is not recycled");
+    }
+  }
+
+  @SuppressWarnings({"unchecked", "ConstantConditions"})
+  public void sameAs(Drawable other) {
+    if (!(other instanceof BitmapDrawable)) {
+      fail("Not a BitmapDrawable");
+    }
+    sameAs(((BitmapDrawable) other).getBitmap());
+  }
+
+  public void sameAs(Bitmap other) {
+    if (!actual().sameAs(other)) {
+      fail("is the same as " + getDisplayString(other));
+    }
+  }
+
+  public void isNotSameAs(Bitmap other) {
+    if (actual().sameAs(other)) {
+      fail("is not the same as " + getDisplayString(other));
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
new file mode 100644
index 000000000..e71aadaf0
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.util.Preconditions;
+
+public final class CanonicalBitmap {
+  @Nullable
+  private Bitmap bitmap;
+  @Nullable
+  private Float scaleFactor;
+
+  @NonNull
+  public synchronized Bitmap getBitmap() {
+    if (bitmap == null) {
+      bitmap = decodeBitmap();
+    }
+    return bitmap;
+  }
+
+  public CanonicalBitmap scale(float scaleFactor) {
+    Preconditions.checkArgument(bitmap == null, "Can't set scale factor after decoding image");
+    this.scaleFactor = scaleFactor;
+    return this;
+  }
+
+  public int getWidth() {
+    return getBitmap().getWidth();
+  }
+
+  public int getHeight() {
+    return getBitmap().getHeight();
+  }
+
+  private Bitmap decodeBitmap() {
+    Context context = InstrumentationRegistry.getTargetContext();
+    BitmapFactory.Options options = new BitmapFactory.Options();
+    options.inScaled = false;
+    int resourceId = ResourceIds.raw.canonical;
+    Bitmap result = BitmapFactory.decodeResource(context.getResources(), resourceId, options);
+    if (scaleFactor != null) {
+      result = Bitmap.createScaledBitmap(
+          result,
+          (int) (result.getWidth() * scaleFactor),
+          (int) (result.getHeight() * scaleFactor),
+          /*filter=*/false);
+    }
+    // Make sure the Bitmap is immutable.
+    return result;
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
new file mode 100644
index 000000000..edca18631
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -0,0 +1,327 @@
+package com.bumptech.glide.test;
+
+import android.graphics.drawable.Drawable;
+import android.os.Debug;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import android.widget.ImageView;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestBuilder;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.target.DrawableImageViewTarget;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Helper for running sections of code on the main thread in emulator tests.
+ */
+public class ConcurrencyHelper {
+  private final Handler handler = new Handler(Looper.getMainLooper());
+  private static final long TIMEOUT_SECONDS = 10;
+  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.SECONDS;
+
+  public <T> T get(final Future<T> future) {
+    final AtomicReference<T> reference = new AtomicReference<>();
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        try {
+          reference.set(future.get(timeout, timeUnit));
+          return true;
+        } catch (ExecutionException e) {
+          throw new RuntimeException(e.getCause());
+        } catch (TimeoutException e) {
+          return false;
+        }
+      }
+    });
+    return reference.get();
+  }
+
+  public <T> Target<T> wait(FutureTarget<T> future) {
+    get(future);
+    return future;
+  }
+
+  public void loadOnOtherThread(final Runnable runnable) {
+    final AtomicBoolean isDone = new AtomicBoolean();
+    final Thread thread = new Thread(new Runnable() {
+      @Override
+      public void run() {
+        runnable.run();
+        isDone.set(true);
+      }
+    });
+    thread.start();
+
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        thread.join(timeUnit.toMillis(timeout));
+        return isDone.get();
+      }
+    });
+  }
+
+  public void loadOnMainThread(
+      final RequestBuilder<Drawable> builder, ImageView imageView) {
+    loadOnMainThread(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  public void clearOnMainThread(final ImageView imageView) {
+    runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.with(InstrumentationRegistry.getTargetContext())
+            .clear(imageView);
+      }
+    });
+  }
+
+  public void loadUntilFirstFinish(
+      final RequestBuilder<Drawable> builder, ImageView imageView) {
+    loadUntilFirstFinish(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  private <T> void loadUntilFirstFinish(
+      final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    callOnMainThread(new Callable<Target<T>>() {
+      @Override
+      public Target<T> call() {
+        builder.into(new Target<T>() {
+          @Override
+          public void onStart() {
+            target.onStart();
+          }
+
+          @Override
+          public void onStop() {
+            target.onStop();
+          }
+
+          @Override
+          public void onDestroy() {
+            target.onDestroy();
+          }
+
+          @Override
+          public void onResourceReady(@NonNull T resource,
+              @Nullable Transition<? super T> transition) {
+            target.onResourceReady(resource, transition);
+            latch.countDown();
+          }
+
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {
+            target.onLoadCleared(placeholder);
+          }
+
+          @Override
+          public void onLoadStarted(@Nullable Drawable placeholder) {
+            target.onLoadStarted(placeholder);
+          }
+
+          @Override
+          public void onLoadFailed(@Nullable Drawable errorDrawable) {
+            target.onLoadFailed(errorDrawable);
+            latch.countDown();
+          }
+
+          @Override
+          public void getSize(@NonNull SizeReadyCallback cb) {
+            target.getSize(cb);
+          }
+
+          @Override
+          public void removeCallback(@NonNull SizeReadyCallback cb) {
+            target.removeCallback(cb);
+          }
+
+          @Override
+          public void setRequest(@Nullable Request request) {
+            target.setRequest(request);
+          }
+
+          @Nullable
+          @Override
+          public Request getRequest() {
+            return target.getRequest();
+          }
+        });
+        return target;
+      }
+    });
+    waitOnLatch(latch);
+  }
+
+  private <T> void loadOnMainThread(final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    callOnMainThread(new Callable<Target<T>>() {
+      @Override
+      public Target<T> call() {
+        builder.into(new Target<T>() {
+          @Override
+          public void onStart() {
+            target.onStart();
+          }
+
+          @Override
+          public void onStop() {
+            target.onStop();
+          }
+
+          @Override
+          public void onDestroy() {
+            target.onDestroy();
+          }
+
+          @Override
+          public void onResourceReady(@NonNull T resource,
+              @Nullable Transition<? super T> transition) {
+            target.onResourceReady(resource, transition);
+            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+              latch.countDown();
+            }
+          }
+
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {
+            target.onLoadCleared(placeholder);
+          }
+
+          @Override
+          public void onLoadStarted(@Nullable Drawable placeholder) {
+            target.onLoadStarted(placeholder);
+          }
+
+          @Override
+          public void onLoadFailed(@Nullable Drawable errorDrawable) {
+            target.onLoadFailed(errorDrawable);
+            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+              latch.countDown();
+            }
+          }
+
+          @Override
+          public void getSize(@NonNull SizeReadyCallback cb) {
+            target.getSize(cb);
+          }
+
+          @Override
+          public void removeCallback(@NonNull SizeReadyCallback cb) {
+            target.removeCallback(cb);
+          }
+
+          @Override
+          public void setRequest(@Nullable Request request) {
+            target.setRequest(request);
+          }
+
+          @Nullable
+          @Override
+          public Request getRequest() {
+            return target.getRequest();
+          }
+        });
+        return target;
+      }
+    });
+    waitOnLatch(latch);
+  }
+
+  public void pokeMainThread() {
+    runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        // Do nothing.
+      }
+    });
+  }
+
+  public void runOnMainThread(final Runnable runnable) {
+    callOnMainThread(new Callable<Void>() {
+      @Override
+      public Void call() {
+        runnable.run();
+        return null;
+      }
+    });
+  }
+
+  private <T> void callOnMainThread(final Callable<T> callable) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    handler.post(new Runnable() {
+      @Override
+      public void run() {
+        try {
+          callable.call();
+        } catch (Exception e) {
+          throw new RuntimeException(e);
+        }
+        latch.countDown();
+      }
+    });
+    waitOnLatch(latch);
+  }
+
+  public static void waitOnLatch(final CountDownLatch latch) {
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        return latch.await(timeout, timeUnit);
+      }
+    });
+  }
+
+  private interface Waiter {
+    boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException;
+  }
+
+  private static void wait(Waiter waiter) {
+    boolean isFinished = false;
+    do {
+      try {
+        try {
+          isFinished = waiter.await(TIMEOUT_SECONDS, TIMEOUT_UNIT);
+          if (!isFinished) {
+            throw new WaiterException("Timed out while waiting");
+          }
+        } catch (InterruptedException e) {
+          throw new WaiterException(e);
+        }
+      } catch (WaiterException e) {
+        if (Debug.isDebuggerConnected()) {
+          continue;
+        }
+        throw e;
+      }
+    } while (Debug.isDebuggerConnected() && !isFinished);
+  }
+
+  private static final class WaiterException extends RuntimeException {
+    private static final long serialVersionUID = -627297254223169728L;
+
+    WaiterException(String message) {
+      super(message);
+    }
+
+    WaiterException(Throwable cause) {
+      super(cause);
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
new file mode 100644
index 000000000..d941793ea
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
@@ -0,0 +1,38 @@
+package com.bumptech.glide.test;
+
+import static org.mockito.Mockito.any;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * Mockito matchers for various common classes.
+ */
+public final class Matchers {
+
+  private Matchers() {
+    // Utility class.
+  }
+
+  public static Target<Drawable> anyDrawableTarget() {
+    return anyTarget();
+  }
+
+  public static Target<Bitmap> anyBitmapTarget() {
+    return anyTarget();
+  }
+
+  @SuppressWarnings("unchecked")
+  public static <T> Target<T> anyTarget() {
+    return (Target<T>) any(Target.class);
+  }
+
+  public static Bitmap anyBitmap() {
+    return any();
+  }
+
+  public static Drawable anyDrawable() {
+    return any();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
new file mode 100644
index 000000000..c1f14110d
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
@@ -0,0 +1,97 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.signature.ObjectKey;
+
+public final class MockModelLoader<ModelT, DataT> implements ModelLoader<ModelT, DataT> {
+  private final ModelT model;
+  private final DataT data;
+
+  @SuppressWarnings("unchecked")
+  public static <ModelT, DataT> void mock(final ModelT model, final DataT data) {
+    Context context = InstrumentationRegistry.getTargetContext();
+
+    Glide.get(context)
+        .getRegistry()
+        .replace(
+            (Class<ModelT>) model.getClass(),
+            (Class<DataT>) data.getClass(),
+            new ModelLoaderFactory<ModelT, DataT>() {
+              @NonNull
+              @Override
+              public ModelLoader<ModelT, DataT> build(
+                  @NonNull MultiModelLoaderFactory multiFactory) {
+                return new MockModelLoader<>(model, data);
+              }
+
+              @Override
+              public void teardown() {
+                // Do nothing.
+              }
+            });
+  }
+
+  private MockModelLoader(ModelT model, DataT data) {
+    this.model = model;
+    this.data = data;
+  }
+
+  @Override
+  public LoadData<DataT> buildLoadData(@NonNull ModelT modelT, int width, int height,
+      @NonNull Options options) {
+    return new LoadData<>(new ObjectKey(modelT), new MockDataFetcher<>(data));
+  }
+
+  @Override
+  public boolean handles(@NonNull ModelT model) {
+    return this.model.equals(model);
+  }
+
+  private static final class MockDataFetcher<DataT> implements DataFetcher<DataT> {
+
+    private final DataT data;
+
+    MockDataFetcher(DataT data) {
+      this.data = data;
+    }
+
+    @Override
+    public void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super DataT> callback) {
+      callback.onDataReady(data);
+    }
+
+    @Override
+    public void cleanup() {
+      // Do nothing.
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @NonNull
+    @Override
+    @SuppressWarnings("unchecked")
+    public Class<DataT> getDataClass() {
+      return (Class<DataT>) data.getClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.REMOTE;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
new file mode 100644
index 000000000..a6dd3629e
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/RegressionTest.java
@@ -0,0 +1,17 @@
+package com.bumptech.glide.test;
+
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that a test is a regression test that relies on comparing a newly transformed image to
+ * a previously generated copy of the same image to detect changes.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface RegressionTest {
+  // Intentionally empty.
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
new file mode 100644
index 000000000..d751f0f07
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.test;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.support.test.InstrumentationRegistry;
+
+/**
+ * Internally in google we don't appear to be able to reference resource ids directly, this class is
+ * a hack around that until we figure out what's going wrong.
+ */
+public final class ResourceIds {
+  private ResourceIds() {
+    // Utility class.
+  }
+
+  public interface raw {
+    int dl_world_anim = getResourceId("raw", "dl_world_anim");
+    int canonical = getResourceId("raw", "canonical");
+    int canonical_png = getResourceId("raw", "canonical_png");
+    int canonical_transparent_png = getResourceId("raw", "canonical_transparent_png");
+    int interlaced_transparent_gif = getResourceId("raw", "interlaced_transparent_gif");
+    int transparent_gif = getResourceId("raw", "transparent_gif");
+    int opaque_gif = getResourceId("raw", "opaque_gif");
+    int opaque_interlaced_gif = getResourceId("raw", "opaque_interlaced_gif");
+    int webkit_logo_p3 = getResourceId("raw", "webkit_logo_p3");
+    int video = getResourceId("raw", "video");
+  }
+
+  public interface drawable {
+    int bitmap_alias = getResourceId("drawable", "bitmap_alias");
+    int googlelogo_color_120x44dp= getResourceId("drawable", "googlelogo_color_120x44dp");
+    int shape_drawable = getResourceId("drawable", "shape_drawable");
+    int state_list_drawable = getResourceId("drawable", "state_list_drawable");
+    int vector_drawable = getResourceId("drawable", "vector_drawable");
+  }
+
+  private static int getResourceId(String type, String resourceName) {
+    Context context = InstrumentationRegistry.getTargetContext();
+    Resources res = context.getResources();
+    return res.getIdentifier(resourceName, type, context.getPackageName());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
new file mode 100644
index 000000000..05fc9cc50
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitByCpu.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that the test relies on transformations or operations that may produce different
+ * outputs on different CPUs.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SplitByCpu {
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
new file mode 100644
index 000000000..bc882430a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/SplitBySdk.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.test;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used by {@link BitmapRegressionTester} to generate SDK specific resources to account for
+ * differences in Android's image decoding APIs across versions.
+ */
+@Target({ ElementType.METHOD, ElementType.TYPE })
+@Retention(RetentionPolicy.RUNTIME)
+public @interface SplitBySdk {
+  int[] value();
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
new file mode 100644
index 000000000..a99644ddb
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
@@ -0,0 +1,37 @@
+package com.bumptech.glide.test;
+
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.RequestManager;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Clears out Glide's disk cache and the Glide singleton after every test method.
+ */
+public final class TearDownGlide implements TestRule {
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          new ConcurrencyHelper().runOnMainThread(new Runnable() {
+            @Override
+            public void run() {
+              RequestManager requestManager =
+                  Glide.with(InstrumentationRegistry.getTargetContext());
+              requestManager.onStop();
+              requestManager.onDestroy();
+            }
+          });
+          Glide.tearDown();
+        }
+      }
+    };
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
new file mode 100644
index 000000000..2c89c9227
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
@@ -0,0 +1,137 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.io.InputStream;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * Allows callers to load an object but force the load to pause until {@link WaitModel#countDown()}
+ * is called.
+ */
+public final class WaitModelLoader<Model, Data>
+    implements ModelLoader<WaitModel<Model>, Data> {
+
+  private final ModelLoader<Model, Data> wrapped;
+
+  private WaitModelLoader(ModelLoader<Model, Data> wrapped) {
+    this.wrapped = wrapped;
+  }
+
+  @Nullable
+  @Override
+  public LoadData<Data> buildLoadData(
+      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {
+    LoadData<Data> wrappedLoadData = wrapped
+        .buildLoadData(waitModel.wrapped, width, height, options);
+    if (wrappedLoadData == null) {
+      return null;
+    }
+    return new LoadData<>(
+        wrappedLoadData.sourceKey, new WaitFetcher<>(wrappedLoadData.fetcher, waitModel.latch));
+  }
+
+  @Override
+  public boolean handles(@NonNull WaitModel<Model> waitModel) {
+    return wrapped.handles(waitModel.wrapped);
+  }
+
+  public static final class WaitModel<T> {
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private final T wrapped;
+
+    WaitModel(T wrapped) {
+      this.wrapped = wrapped;
+    }
+
+    public void countDown() {
+      if (latch.getCount() != 1) {
+        throw new IllegalStateException();
+      }
+      latch.countDown();
+    }
+  }
+
+  public static final class Factory<Model, Data>
+      implements ModelLoaderFactory<WaitModel<Model>, Data> {
+
+    private final Class<Model> modelClass;
+    private final Class<Data> dataClass;
+
+    Factory(Class<Model> modelClass, Class<Data> dataClass) {
+      this.modelClass = modelClass;
+      this.dataClass = dataClass;
+    }
+
+    public static synchronized <T> WaitModel<T> waitOn(T model) {
+      @SuppressWarnings("unchecked") ModelLoaderFactory<WaitModel<T>, InputStream> streamFactory =
+          new Factory<>((Class<T>) model.getClass(), InputStream.class);
+      Glide.get(InstrumentationRegistry.getTargetContext())
+          .getRegistry()
+          .replace(WaitModel.class, InputStream.class, streamFactory);
+
+      return new WaitModel<>(model);
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<WaitModel<Model>, Data> build(
+        MultiModelLoaderFactory multiFactory) {
+      return new WaitModelLoader<>(multiFactory.build(modelClass, dataClass));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  private static final class WaitFetcher<Data> implements DataFetcher<Data> {
+
+    private final DataFetcher<Data> wrapped;
+    private final CountDownLatch toWaitOn;
+
+    WaitFetcher(DataFetcher<Data> wrapped, CountDownLatch toWaitOn) {
+      this.wrapped = wrapped;
+      this.toWaitOn = toWaitOn;
+    }
+
+    @Override
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
+      ConcurrencyHelper.waitOnLatch(toWaitOn);
+      wrapped.loadData(priority, callback);
+    }
+
+    @Override
+    public void cleanup() {
+      wrapped.cleanup();
+    }
+
+    @Override
+    public void cancel() {
+      wrapped.cancel();
+    }
+
+    @NonNull
+    @Override
+    public Class<Data> getDataClass() {
+      return wrapped.getDataClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return wrapped.getDataSource();
+    }
+  }
+}
diff --git a/instrumentation/src/main/AndroidManifest.xml b/instrumentation/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..fa6e2915f
--- /dev/null
+++ b/instrumentation/src/main/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.instrumentation">
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+  <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
+  <application />
+</manifest>
diff --git a/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java b/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java
new file mode 100644
index 000000000..056d6140a
--- /dev/null
+++ b/instrumentation/src/main/java/com/bumptech/glide/test/InstrumentationAppGlideModule.java
@@ -0,0 +1,9 @@
+package com.bumptech.glide.test;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+@GlideModule
+public class InstrumentationAppGlideModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/instrumentation/src/main/res/drawable/bitmap_alias.xml b/instrumentation/src/main/res/drawable/bitmap_alias.xml
new file mode 100644
index 000000000..7dc0bb70a
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/bitmap_alias.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
+  android:src="@android:drawable/star_big_off" />
diff --git a/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png b/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png
new file mode 100644
index 000000000..1ab50e6cf
Binary files /dev/null and b/instrumentation/src/main/res/drawable/googlelogo_color_120x44dp.9.png differ
diff --git a/instrumentation/src/main/res/drawable/shape_drawable.xml b/instrumentation/src/main/res/drawable/shape_drawable.xml
new file mode 100644
index 000000000..3b19d1445
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/shape_drawable.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+  android:shape="rectangle">
+  <solid android:color="#ffabcdef"/>
+</shape>
diff --git a/instrumentation/src/main/res/drawable/state_list_drawable.xml b/instrumentation/src/main/res/drawable/state_list_drawable.xml
new file mode 100644
index 000000000..d43039f86
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/state_list_drawable.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+
+  <item android:drawable="@android:drawable/checkbox_on_background"
+    android:state_pressed="true" />
+  <item android:drawable="@android:drawable/checkbox_on_background"
+    android:state_checked="true" />
+  <item android:drawable="@android:drawable/checkbox_off_background" />
+
+</selector>
diff --git a/instrumentation/src/main/res/drawable/vector_drawable.xml b/instrumentation/src/main/res/drawable/vector_drawable.xml
new file mode 100644
index 000000000..1732bb9ba
--- /dev/null
+++ b/instrumentation/src/main/res/drawable/vector_drawable.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+  android:width="64dp"
+  android:height="64dp"
+  android:viewportHeight="24.0"
+  android:viewportWidth="24.0">
+  <path
+    android:fillColor="#f9b840"
+    android:pathData="M15.5,5.5c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9
+        -2,2 0.9,2 2,2zM5,12c-2.8,0 -5,2.2 -5,5s2.2,5 5,5 5,-2.2 5,-5 -2.2,
+        -5 -5,-5zM5,20.5c-1.9,0 -3.5,-1.6 -3.5,-3.5s1.6,-3.5 3.5,-3.5 3.5,
+        1.6 3.5,3.5 -1.6,3.5 -3.5,3.5zM10.8,10.5l2.4,-2.4 0.8,0.8c1.3,1.3
+        3,2.1 5.1,2.1L19.1,9c-1.5,0 -2.7,-0.6 -3.6,-1.5l-1.9,-1.9c-0.5,-0.4
+        -1,-0.6 -1.6,-0.6s-1.1,0.2 -1.4,0.6L7.8,8.4c-0.4,0.4 -0.6,0.9 -0.6,
+        1.4 0,0.6 0.2,1.1 0.6,1.4L11,14v5h2v-6.2l-2.2,-2.3zM19,12c-2.8,0 -5,
+        2.2 -5,5s2.2,5 5,5 5,-2.2 5,-5 -2.2,-5 -5,-5zM19,20.5c-1.9,0 -3.5,-1.6
+         -3.5,-3.5s1.6,-3.5 3.5,-3.5 3.5,1.6 3.5,3.5 -1.6,3.5 -3.5,3.5z" />
+</vector>
diff --git a/instrumentation/src/main/res/raw/canonical.jpg b/instrumentation/src/main/res/raw/canonical.jpg
new file mode 100644
index 000000000..889ba2762
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical.jpg differ
diff --git a/instrumentation/src/main/res/raw/canonical_png.png b/instrumentation/src/main/res/raw/canonical_png.png
new file mode 100644
index 000000000..475aa74c4
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical_png.png differ
diff --git a/instrumentation/src/main/res/raw/canonical_transparent_png.png b/instrumentation/src/main/res/raw/canonical_transparent_png.png
new file mode 100644
index 000000000..6e8e3eb97
Binary files /dev/null and b/instrumentation/src/main/res/raw/canonical_transparent_png.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..a001e38f1
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png
new file mode 100644
index 000000000..3a08a9026
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..a001e38f1
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png
new file mode 100644
index 000000000..515b8e4d3
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png
new file mode 100644
index 000000000..16efb6214
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglelargerthanimage_returnsupscaledrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..33ae114e4
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png
new file mode 100644
index 000000000..930e93090
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..33ae114e4
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png
new file mode 100644
index 000000000..cfd574f85
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png
new file mode 100644
index 000000000..f8bd1018a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withrectanglesmallerthanimage_returnsrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..3c4f98d1b
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png
new file mode 100644
index 000000000..fdc961ec6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..3c4f98d1b
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png
new file mode 100644
index 000000000..1cd39b7e8
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png
new file mode 100644
index 000000000..25ca7a8d8
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquarelargerthanimage_returnsupscaledrectangularimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..63613050c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png
new file mode 100644
index 000000000..a6f2ebb73
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..63613050c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png
new file mode 100644
index 000000000..fce9cc8e9
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png
new file mode 100644
index 000000000..889309568
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_centercrop_withsquaresmallerthanimage_returnssquareimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png
new file mode 100644
index 000000000..7d9667d0c
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png
new file mode 100644
index 000000000..1515a3629
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png
new file mode 100644
index 000000000..b6cccc383
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png
new file mode 100644
index 000000000..040a0cb58
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png
new file mode 100644
index 000000000..b6cccc383
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png
new file mode 100644
index 000000000..3746332ad
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png
new file mode 100644
index 000000000..c0e1a463f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_cropswithin_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1515a3629
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..040a0cb58
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..3746332ad
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..c0e1a463f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png
new file mode 100644
index 000000000..84ce56297
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withnarrowrectangle_fitswithinmaintainingaspectratio_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..bba6152db
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..b667fbe14
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..3d86fa33a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..5829492f9
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..3d86fa33a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..7de62e0ea
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..fdc93c5f0
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..0f6e9e1df
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png
new file mode 100644
index 000000000..060028372
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withshortrectangle_fitswithinmaintainingaspectratio_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..6d5494869
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png
new file mode 100644
index 000000000..80aa1e15a
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png
new file mode 100644
index 000000000..1c0e76eb5
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png
new file mode 100644
index 000000000..95a70ed33
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..1c0e76eb5
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png
new file mode 100644
index 000000000..466ab5d9f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png
new file mode 100644
index 000000000..810cec1b2
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png
new file mode 100644
index 000000000..43b654ec6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png
new file mode 100644
index 000000000..ceca292da
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquarelargerthanimage_returnsupscaledfitimage_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..cab94eaaa
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png
new file mode 100644
index 000000000..640c93085
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..9ead8030f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png
new file mode 100644
index 000000000..6f4a4e311
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..6ab29373f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png
new file mode 100644
index 000000000..54d467fb6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_retunsimagefitwithinsquare_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..288e5f0a3
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png
new file mode 100644
index 000000000..cab94eaaa
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png
new file mode 100644
index 000000000..14f685740
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png
new file mode 100644
index 000000000..640c93085
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..14f685740
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png
new file mode 100644
index 000000000..9ead8030f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png
new file mode 100644
index 000000000..6f4a4e311
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png
new file mode 100644
index 000000000..6ab29373f
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png
new file mode 100644
index 000000000..54d467fb6
Binary files /dev/null and b/instrumentation/src/main/res/raw/ccrt_circlecrop_withsquaresmallerthanimage_returnssquaredimage_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..396837460
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..fb6a40f75
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png
new file mode 100644
index 000000000..9f7ad2686
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png
new file mode 100644
index 000000000..2e1cbbf18
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png
new file mode 100644
index 000000000..9f7ad2686
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png
new file mode 100644
index 000000000..afe43f81a
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png
new file mode 100644
index 000000000..5c0019916
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquarelargerthanimage_returnsoriginalimage_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..e7eb65010
Binary files /dev/null and b/instrumentation/src/main/res/raw/cirt_centerinside_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/dl_world_anim.gif b/instrumentation/src/main/res/raw/dl_world_anim.gif
new file mode 100644
index 000000000..1e3b8dea2
Binary files /dev/null and b/instrumentation/src/main/res/raw/dl_world_anim.gif differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png
new file mode 100644
index 000000000..1262ce7c0
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..b83034ff1
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..5a64e7e63
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..396837460
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withnarrowrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png
new file mode 100644
index 000000000..1a6a857c7
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png
new file mode 100644
index 000000000..31351c2ac
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png
new file mode 100644
index 000000000..9320e9f76
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png
new file mode 100644
index 000000000..fb6a40f75
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withshortrectangle_fitswithinmaintainingaspectratio_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png
new file mode 100644
index 000000000..6834ef69e
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..e1abe0fae
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png
new file mode 100644
index 000000000..cbf40ecec
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png
new file mode 100644
index 000000000..cbf40ecec
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png
new file mode 100644
index 000000000..a2a03bfe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquarelargerthanimage_returnsupscaledsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png
new file mode 100644
index 000000000..7e45a3dc9
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png
new file mode 100644
index 000000000..fe7204f45
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png
new file mode 100644
index 000000000..c1e4e13fc
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png
new file mode 100644
index 000000000..e7eb65010
Binary files /dev/null and b/instrumentation/src/main/res/raw/fcrt_fitcenter_withsquaresmallerthanimage_returnsimagefitwithinsquare_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif b/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif
new file mode 100644
index 000000000..283e0fb16
Binary files /dev/null and b/instrumentation/src/main/res/raw/interlaced_transparent_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/opaque_gif.gif b/instrumentation/src/main/res/raw/opaque_gif.gif
new file mode 100644
index 000000000..3b50db910
Binary files /dev/null and b/instrumentation/src/main/res/raw/opaque_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif b/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif
new file mode 100644
index 000000000..4ebf12daf
Binary files /dev/null and b/instrumentation/src/main/res/raw/opaque_interlaced_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png
new file mode 100644
index 000000000..caa7c5963
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png
new file mode 100644
index 000000000..45956c505
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png
new file mode 100644
index 000000000..669269f2b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png
new file mode 100644
index 000000000..3e4aab0a0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png
new file mode 100644
index 000000000..669269f2b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png
new file mode 100644
index 000000000..3e4aab0a0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png
new file mode 100644
index 000000000..6c4dab5b5
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png
new file mode 100644
index 000000000..28cfaf4bf
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png
new file mode 100644
index 000000000..28cfaf4bf
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png
new file mode 100644
index 000000000..cd56aa644
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png
new file mode 100644
index 000000000..e68bc997c
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png
new file mode 100644
index 000000000..e1eda26d6
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png
new file mode 100644
index 000000000..6a53e1dd8
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png
new file mode 100644
index 000000000..683d55fe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png
new file mode 100644
index 000000000..c70fdea57
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png
new file mode 100644
index 000000000..683d55fe4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png
new file mode 100644
index 000000000..c70fdea57
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png
new file mode 100644
index 000000000..ecbff14cb
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png
new file mode 100644
index 000000000..cbb3895b0
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png
new file mode 100644
index 000000000..843b78f9b
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png
new file mode 100644
index 000000000..fd26de305
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png
new file mode 100644
index 000000000..098a5da5e
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_overrounded_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png
new file mode 100644
index 000000000..c8bc48aa4
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png
new file mode 100644
index 000000000..e42fb5cf8
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_16_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png
new file mode 100644
index 000000000..a5cda420f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png
new file mode 100644
index 000000000..42229a13f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_18_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png
new file mode 100644
index 000000000..a5cda420f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png
new file mode 100644
index 000000000..42229a13f
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_19_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png
new file mode 100644
index 000000000..b29b0da31
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_armeabi_v7a.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png
new file mode 100644
index 000000000..0f4b78b5d
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_21_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png
new file mode 100644
index 000000000..0f4b78b5d
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_23_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png
new file mode 100644
index 000000000..2295f8881
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_24_x86.png differ
diff --git a/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png
new file mode 100644
index 000000000..2295f8881
Binary files /dev/null and b/instrumentation/src/main/res/raw/rcrt_testroundedcorners_usepool_26_x86.png differ
diff --git a/instrumentation/src/main/res/raw/transparent_gif.gif b/instrumentation/src/main/res/raw/transparent_gif.gif
new file mode 100644
index 000000000..88c7097e7
Binary files /dev/null and b/instrumentation/src/main/res/raw/transparent_gif.gif differ
diff --git a/instrumentation/src/main/res/raw/video.mp4 b/instrumentation/src/main/res/raw/video.mp4
new file mode 100644
index 000000000..3ffc91a98
Binary files /dev/null and b/instrumentation/src/main/res/raw/video.mp4 differ
diff --git a/instrumentation/src/main/res/raw/webkit_logo_p3.png b/instrumentation/src/main/res/raw/webkit_logo_p3.png
new file mode 100644
index 000000000..55bad7f81
Binary files /dev/null and b/instrumentation/src/main/res/raw/webkit_logo_p3.png differ
diff --git a/instrumentation/src/main/res/values/strings.xml b/instrumentation/src/main/res/values/strings.xml
new file mode 100644
index 000000000..55344e519
--- /dev/null
+++ b/instrumentation/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+</resources>
\ No newline at end of file
diff --git a/integration/build.gradle b/integration/build.gradle
index 5467b8ace..d4e8437e3 100644
--- a/integration/build.gradle
+++ b/integration/build.gradle
@@ -1,15 +1 @@
-evaluationDependsOnChildren()
-
-import com.android.build.gradle.api.BaseVariant
-subprojects {
-    android.libraryVariants.all { BaseVariant variant ->
-        def jarTask = project.tasks.create(name: "jar${variant.name.capitalize()}", type: Jar) {
-            from variant.javaCompile.destinationDir
-            exclude "**/R.class"
-            exclude "**/BuildConfig.class"
-            baseName "glide-${project.name}-integration"
-        }
-        jarTask.dependsOn variant.javaCompile
-        artifacts.add('archives', jarTask);
-    }
-}
+// keep an empty file to make sure Gradle recognizes the properties
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index 603500c46..a2ebd546b 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -1,24 +1,18 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
-
-repositories {
-    mavenCentral()
-}
 
 dependencies {
-    compile project(':glide')
-
-    testCompile project(":testutil")
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    implementation project(':library')
+
+    testImplementation project(":testutil")
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     sourceSets {
         main {
@@ -30,7 +24,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode = VERSION_CODE as int
         versionName = VERSION_NAME as String
     }
 
@@ -40,4 +33,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/gifencoder/gradle.properties b/integration/gifencoder/gradle.properties
index 15bd7b334..1ceaa1dac 100644
--- a/integration/gifencoder/gradle.properties
+++ b/integration/gifencoder/gradle.properties
@@ -1,15 +1,4 @@
 POM_NAME=Glide GifEncoder Integration
 POM_ARTIFACT_ID=gifencoder-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-VERSION_CODE=8
-
 POM_DESCRIPTION=An integration library allowing users to re-encode or create animated GIFs
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index f3ca40290..0d67e6fd7 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -1,11 +1,14 @@
 package com.bumptech.glide.integration.gifencoder;
 
+import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
 import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
@@ -20,7 +23,6 @@
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.ByteBufferUtil;
 import com.bumptech.glide.util.LogTime;
-
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -37,19 +39,22 @@
 
   private static final String KEY_ENCODE_TRANSFORMATION =
       "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";
-   /**
+  /**
    * A boolean option that, if set to <code>true</code>, causes the fully transformed
    * GIF to be written to cache.
    *
-   * <p> Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than
-   * the originals. Re-encoding may be worth it to decrease the size of very large GIFs. </p>
+   * <p>Warning - encoding GIFs is slow and often produces larger and less efficient GIFs than
+   * the originals. Re-encoding may be worth it to decrease the size of very large GIFs.
    *
-   * <p> Defaults to <code>false</code>. </p>
+   * <p>Defaults to <code>false</code>.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final Option<Boolean> ENCODE_TRANSFORMATION =
       Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {
         @Override
-        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {
+        public void update(@NonNull byte[] keyBytes, @NonNull Boolean value,
+            @NonNull MessageDigest messageDigest) {
           if (value) {
             messageDigest.update(keyBytes);
           }
@@ -59,29 +64,35 @@ public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest)
   private static final Factory FACTORY = new Factory();
   private static final String TAG = "GifEncoder";
   private final GifDecoder.BitmapProvider provider;
+  private final Context context;
   private final BitmapPool bitmapPool;
   private final Factory factory;
 
-  public ReEncodingGifResourceEncoder(BitmapPool bitmapPool) {
-    this(bitmapPool, FACTORY);
+  // Public API.
+  @SuppressWarnings("unused")
+  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {
+    this(context, bitmapPool, FACTORY);
   }
 
-  // Visible for testing.
-  ReEncodingGifResourceEncoder(BitmapPool bitmapPool, Factory factory) {
+  @VisibleForTesting
+  ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {
+    this.context = context;
     this.bitmapPool = bitmapPool;
     provider = new GifBitmapProvider(bitmapPool);
     this.factory = factory;
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     Boolean encodeTransformation = options.get(ENCODE_TRANSFORMATION);
     return encodeTransformation != null && encodeTransformation
         ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;
   }
 
   @Override
-  public boolean encode(Resource<GifDrawable> resource, File file, Options options) {
+  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,
+      @NonNull Options options) {
     GifDrawable drawable = resource.get();
     Transformation<Bitmap> transformation = drawable.getFrameTransformation();
     boolean isTransformed = !(transformation instanceof UnitTransformation);
@@ -115,7 +126,7 @@ private boolean encodeTransformedToFile(GifDrawable drawable, File file) {
 
     }
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Re-encoded gif with " + drawable.getFrameCount() + " frames and "
+      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and "
           + drawable.getBuffer().limit() + " bytes in " + LogTime.getElapsedMillis(startTime)
           + " ms");
     }
@@ -157,7 +168,7 @@ private boolean writeDataDirect(ByteBuffer data, File file) {
       ByteBufferUtil.toFile(data, file);
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Failed to write gif data", e);
+        Log.w(TAG, "Failed to write GIF data", e);
       }
       return false;
     }
@@ -180,30 +191,32 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
       Transformation<Bitmap> transformation, GifDrawable drawable) {
     // TODO: what if current frame is null?
     Resource<Bitmap> bitmapResource = factory.buildFrameResource(currentFrame, bitmapPool);
-    Resource<Bitmap> transformedResource = transformation
-        .transform(bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
+    Resource<Bitmap> transformedResource =
+        transformation.transform(
+            context, bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
     if (!bitmapResource.equals(transformedResource)) {
       bitmapResource.recycle();
     }
     return transformedResource;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Factory {
 
-    public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
-      return new GifDecoder(bitmapProvider);
+    GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
+      return new StandardGifDecoder(bitmapProvider);
     }
 
-    public GifHeaderParser buildParser() {
+    GifHeaderParser buildParser() {
       return new GifHeaderParser();
     }
 
-    public AnimatedGifEncoder buildEncoder() {
+    AnimatedGifEncoder buildEncoder() {
       return new AnimatedGifEncoder();
     }
 
-    public Resource<Bitmap> buildFrameResource(Bitmap bitmap, BitmapPool bitmapPool) {
+    @NonNull
+    Resource<Bitmap> buildFrameResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
       return new BitmapResource(bitmap, bitmapPool);
     }
   }
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index 1d104591b..641dc7357 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -12,8 +12,9 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
+import android.content.Context;
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
@@ -26,7 +27,10 @@
 import com.bumptech.glide.load.resource.UnitTransformation;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -38,25 +42,20 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.nio.ByteBuffer;
-
 /**
  * Tests for {@link com.bumptech.glide.integration.gifencoder.ReEncodingGifResourceEncoder}.
  */
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ReEncodingGifResourceEncoderTest {
-  @Mock Resource<GifDrawable> resource;
-  @Mock GifDecoder decoder;
-  @Mock GifHeaderParser parser;
-  @Mock AnimatedGifEncoder gifEncoder;
-  @Mock Resource<Bitmap> frameResource;
-  @Mock GifDrawable gifDrawable;
-  @Mock Transformation<Bitmap> frameTransformation;
-  @Mock Resource<Bitmap> transformedResource;
+  @Mock private Resource<GifDrawable> resource;
+  @Mock private GifDecoder decoder;
+  @Mock private GifHeaderParser parser;
+  @Mock private AnimatedGifEncoder gifEncoder;
+  @Mock private Resource<Bitmap> frameResource;
+  @Mock private GifDrawable gifDrawable;
+  @Mock private Transformation<Bitmap> frameTransformation;
+  @Mock private Resource<Bitmap> transformedResource;
 
   private ReEncodingGifResourceEncoder encoder;
   private Options options;
@@ -67,14 +66,18 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
+    Application context = RuntimeEnvironment.application;
+
     ReEncodingGifResourceEncoder.Factory factory = mock(ReEncodingGifResourceEncoder.Factory.class);
+    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
     when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
     when(factory.buildParser()).thenReturn(parser);
     when(factory.buildEncoder()).thenReturn(gifEncoder);
     when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class)))
         .thenReturn(frameResource);
 
-    when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt()))
+    // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!)
+    when(frameTransformation.transform(anyContext(), any(Resource.class), anyInt(), anyInt()))
         .thenReturn(frameResource);
 
     when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
@@ -82,15 +85,17 @@ public void setUp() {
 
     when(resource.get()).thenReturn(gifDrawable);
 
-    encoder = new ReEncodingGifResourceEncoder(mock(BitmapPool.class), factory);
+    encoder = new ReEncodingGifResourceEncoder(context, mock(BitmapPool.class), factory);
     options = new Options();
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, true);
 
-    file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    file = new File(context.getCacheDir(), "test");
   }
 
   @After
   public void tearDown() {
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
     if (file.exists() && !file.delete()) {
       throw new RuntimeException("Failed to delete file");
     }
@@ -128,7 +133,6 @@ public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
   @Test
   public void testEncode_WithEncodeTransformationFalse_whenOsThrows_returnsFalse()
       throws IOException {
-
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     byte[] data = "testString".getBytes("UTF-8");
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(data));
@@ -244,7 +248,8 @@ public void testWritesTransformedBitmaps() {
 
     Bitmap transformedFrame = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
     when(transformedResource.get()).thenReturn(transformedFrame);
-    when(frameTransformation.transform(eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
+    when(frameTransformation.transform(
+        anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
         .thenReturn(transformedResource);
     when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
 
@@ -256,7 +261,7 @@ public void testWritesTransformedBitmaps() {
   @Test
   public void testRecyclesFrameResourceBeforeWritingIfTransformedResourceIsDifferent() {
     when(decoder.getFrameCount()).thenReturn(1);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(transformedResource);
     Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
     when(transformedResource.get()).thenReturn(expected);
@@ -275,7 +280,7 @@ public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDi
     when(decoder.getFrameCount()).thenReturn(1);
     Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
     when(transformedResource.get()).thenReturn(expected);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(transformedResource);
 
     when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
@@ -290,7 +295,7 @@ public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDi
   @Test
   public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed() {
     when(decoder.getFrameCount()).thenReturn(1);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(frameResource);
     Bitmap expected = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
     when(frameResource.get()).thenReturn(expected);
@@ -305,8 +310,7 @@ public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed
   }
 
   @Test
-  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation()
-      throws IOException {
+  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation() {
     when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
     String expected = "expected";
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(expected.getBytes()));
@@ -327,4 +331,8 @@ private String getEncodedData() {
       throw new RuntimeException(e);
     }
   }
+
+  private static Context anyContext() {
+    return any(Context.class);
+  }
 }
diff --git a/integration/gradle.properties b/integration/gradle.properties
new file mode 100644
index 000000000..9a3b597f9
--- /dev/null
+++ b/integration/gradle.properties
@@ -0,0 +1,3 @@
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-integration
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index c70aad959..a8cd599a1 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -1,24 +1,20 @@
 apply plugin: 'com.android.library'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    implementation project(':library')
+    annotationProcessor project(':annotation:compiler')
 
-    compile "com.squareup.okhttp:okhttp:${OK_HTTP_VERSION}"
+    api "com.squareup.okhttp:okhttp:2.7.5"
+    api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -28,4 +24,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/okhttp/gradle.properties b/integration/okhttp/gradle.properties
index 636a1a822..e725ea973 100644
--- a/integration/okhttp/gradle.properties
+++ b/integration/okhttp/gradle.properties
@@ -1,15 +1,4 @@
 POM_NAME=Glide OkHttp Integration
 POM_ARTIFACT_ID=okhttp-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-VERSION_CODE=8
-
-POM_DESCRIPTION=An integration library to use OkHttp to fetch data over http/https in Glide
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
+POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide
diff --git a/integration/okhttp/src/main/AndroidManifest.xml b/integration/okhttp/src/main/AndroidManifest.xml
index c11d7167d..738e5c900 100644
--- a/integration/okhttp/src/main/AndroidManifest.xml
+++ b/integration/okhttp/src/main/AndroidManifest.xml
@@ -1,9 +1,5 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.bumptech.glide.integration.okhttp">
 
-    <application>
-        <meta-data
-            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule"
-            android:value="GlideModule"/>
-    </application>
+    <application />
 </manifest>
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index 738e9602d..1bc1047a9 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.content.Context;
-
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.module.GlideModule;
-
 import java.io.InputStream;
 
 /**
@@ -17,15 +16,18 @@
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
  * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule.
  */
-public class OkHttpGlideModule implements GlideModule {
+@Deprecated
+public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
   }
 }
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
new file mode 100644
index 000000000..bc81dabc0
--- /dev/null
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
@@ -0,0 +1,28 @@
+package com.bumptech.glide.integration.okhttp;
+
+import android.content.Context;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * Registers OkHttp related classes via Glide's annotation processor.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ *
+ * @deprecated Prefer the okhttp3 version instead.
+ */
+@GlideModule
+@Deprecated
+public class OkHttpLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Glide glide, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 1985ca24a..dcac2f768 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -1,40 +1,46 @@
 package com.bumptech.glide.integration.okhttp;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.HttpException;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
+import com.bumptech.glide.util.Synthetic;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Map;
 
 /**
  * Fetches an {@link InputStream} using the okhttp library.
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpStreamFetcher.
  */
+@Deprecated
 public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "OkHttpFetcher";
   private final OkHttpClient client;
   private final GlideUrl url;
-  private InputStream stream;
-  private ResponseBody responseBody;
+  @SuppressWarnings("WeakerAccess") @Synthetic InputStream stream;
+  @SuppressWarnings("WeakerAccess") @Synthetic ResponseBody responseBody;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
     this.client = client;
     this.url = url;
   }
 
   @Override
-  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
-    boolean isUserAgentSet = false;
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
       requestBuilder.addHeader(key, headerEntry.getValue());
@@ -52,14 +58,14 @@ public void onFailure(Request request, IOException e) {
 
       @Override
       public void onResponse(Response response) throws IOException {
+        responseBody = response.body();
         if (response.isSuccessful()) {
-          long contentLength = response.body().contentLength();
-          responseBody = response.body();
+          long contentLength = responseBody.contentLength();
           stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
-        } else if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
+          callback.onDataReady(stream);
+        } else {
+          callback.onLoadFailed(new HttpException(response.message(), response.code()));
         }
-        callback.onDataReady(stream);
       }
     });
   }
@@ -87,11 +93,13 @@ public void cancel() {
     // TODO: call cancel on the client when this method is called on a background thread. See #257
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.REMOTE;
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 05c0fe683..174c446f2 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -1,44 +1,50 @@
 package com.bumptech.glide.integration.okhttp;
 
-import android.content.Context;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.squareup.okhttp.OkHttpClient;
-
 import java.io.InputStream;
 
 /**
  * A simple model loader for fetching media over http/https using OkHttp.
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader.
  */
+@Deprecated
 public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
   private final OkHttpClient client;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public OkHttpUrlLoader(OkHttpClient client) {
     this.client = client;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
+  @SuppressWarnings("deprecation")
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
   }
 
   /**
    * The default factory for {@link OkHttpUrlLoader}s.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "deprecation"})
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile OkHttpClient internalClient;
-    private OkHttpClient client;
+    private final OkHttpClient client;
 
     private static OkHttpClient getInternalClient() {
       if (internalClient == null) {
@@ -65,9 +71,10 @@ public Factory(OkHttpClient client) {
       this.client = client;
     }
 
+    @NonNull
+    @SuppressWarnings("deprecation")
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
     }
 
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
new file mode 100644
index 000000000..8e8590841
--- /dev/null
+++ b/integration/okhttp3/build.gradle
@@ -0,0 +1,27 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    implementation project(':library')
+    annotationProcessor project(':annotation:compiler')
+
+    api "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/okhttp3/gradle.properties b/integration/okhttp3/gradle.properties
new file mode 100644
index 000000000..f241acfb1
--- /dev/null
+++ b/integration/okhttp3/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide OkHttp 3.x Integration
+POM_ARTIFACT_ID=okhttp3-integration
+POM_PACKAGING=aar
+POM_DESCRIPTION=An integration library to use OkHttp 3.x to fetch data over http/https in Glide
diff --git a/integration/okhttp3/lint.xml b/integration/okhttp3/lint.xml
new file mode 100644
index 000000000..8b0842417
--- /dev/null
+++ b/integration/okhttp3/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore"/>
+    <!-- See https://github.com/square/okio/issues/58 -->
+    <issue id="InvalidPackage" severity="ignore">
+        <ignore regexp="okio-1.0.0.jar"/>
+    </issue>
+</lint>
diff --git a/integration/okhttp3/src/main/AndroidManifest.xml b/integration/okhttp3/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..bc8e5a72c
--- /dev/null
+++ b/integration/okhttp3/src/main/AndroidManifest.xml
@@ -0,0 +1,9 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.bumptech.glide.integration.okhttp">
+
+    <application>
+        <meta-data
+            android:name="com.bumptech.glide.integration.okhttp3.OkHttpGlideModule"
+            android:value="GlideModule"/>
+    </application>
+</manifest>
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
new file mode 100644
index 000000000..e58b041dd
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -0,0 +1,34 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.load.model.GlideUrl;
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader}
+ * with an OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p> If you're using gradle, you can include this module simply by depending on the aar, the
+ * module will be merged in by manifest merger. For other build systems or for more more
+ * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ *
+ * @deprecated Replaced by {@link OkHttpLibraryGlideModule} for Applications that use Glide's
+ * annotations.
+ */
+@Deprecated
+public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    // Do nothing.
+  }
+
+  @Override
+  public void registerComponents(Context context, Glide glide, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
new file mode 100644
index 000000000..b315acbd7
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * Registers OkHttp related classes via Glide's annotation processor.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
new file mode 100644
index 000000000..2b6a69b38
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -0,0 +1,111 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.HttpException;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.ContentLengthInputStream;
+import com.bumptech.glide.util.Preconditions;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Map;
+import okhttp3.Call;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+/**
+ * Fetches an {@link InputStream} using the okhttp library.
+ */
+public class OkHttpStreamFetcher implements DataFetcher<InputStream>, okhttp3.Callback {
+  private static final String TAG = "OkHttpFetcher";
+  private final Call.Factory client;
+  private final GlideUrl url;
+  private InputStream stream;
+  private ResponseBody responseBody;
+  private DataCallback<? super InputStream> callback;
+  // call may be accessed on the main thread while the object is in use on other threads. All other
+  // accesses to variables may occur on different threads, but only one at a time.
+  private volatile Call call;
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
+    this.client = client;
+    this.url = url;
+  }
+
+  @Override
+  public void loadData(@NonNull Priority priority,
+      @NonNull final DataCallback<? super InputStream> callback) {
+    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
+    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
+      String key = headerEntry.getKey();
+      requestBuilder.addHeader(key, headerEntry.getValue());
+    }
+    Request request = requestBuilder.build();
+    this.callback = callback;
+
+    call = client.newCall(request);
+    call.enqueue(this);
+  }
+
+  @Override
+  public void onFailure(@NonNull Call call, @NonNull IOException e) {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "OkHttp failed to obtain result", e);
+    }
+
+    callback.onLoadFailed(e);
+  }
+
+  @Override
+  public void onResponse(@NonNull Call call, @NonNull Response response) {
+    responseBody = response.body();
+    if (response.isSuccessful()) {
+      long contentLength = Preconditions.checkNotNull(responseBody).contentLength();
+      stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
+      callback.onDataReady(stream);
+    } else {
+      callback.onLoadFailed(new HttpException(response.message(), response.code()));
+    }
+  }
+
+  @Override
+  public void cleanup() {
+    try {
+      if (stream != null) {
+        stream.close();
+      }
+    } catch (IOException e) {
+      // Ignored
+    }
+    if (responseBody != null) {
+      responseBody.close();
+    }
+    callback = null;
+  }
+
+  @Override
+  public void cancel() {
+    Call local = call;
+    if (local != null) {
+      local.cancel();
+    }
+  }
+
+  @NonNull
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
+
+  @NonNull
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.REMOTE;
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
new file mode 100644
index 000000000..8f8f9066c
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -0,0 +1,84 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import java.io.InputStream;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+
+/**
+ * A simple model loader for fetching media over http/https using OkHttp.
+ */
+public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
+
+  private final Call.Factory client;
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public OkHttpUrlLoader(@NonNull Call.Factory client) {
+    this.client = client;
+  }
+
+  @Override
+  public boolean handles(@NonNull GlideUrl url) {
+    return true;
+  }
+
+  @Override
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
+      @NonNull Options options) {
+    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
+  }
+
+  /**
+   * The default factory for {@link OkHttpUrlLoader}s.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
+    private static volatile Call.Factory internalClient;
+    private final Call.Factory client;
+
+    private static Call.Factory getInternalClient() {
+      if (internalClient == null) {
+        synchronized (Factory.class) {
+          if (internalClient == null) {
+            internalClient = new OkHttpClient();
+          }
+        }
+      }
+      return internalClient;
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using a static singleton client.
+     */
+    public Factory() {
+      this(getInternalClient());
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using given client.
+     *
+     * @param client this is typically an instance of {@code OkHttpClient}.
+     */
+    public Factory(@NonNull Call.Factory client) {
+      this.client = client;
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new OkHttpUrlLoader(client);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing, this instance doesn't own the client.
+    }
+  }
+}
diff --git a/integration/recyclerview/build.gradle b/integration/recyclerview/build.gradle
index 854dcefdd..2a6154e9f 100644
--- a/integration/recyclerview/build.gradle
+++ b/integration/recyclerview/build.gradle
@@ -1,24 +1,18 @@
 apply plugin: 'com.android.library'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    implementation project(':library')
+    compileOnly "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    compileOnly "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -28,4 +22,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/recyclerview/gradle.properties b/integration/recyclerview/gradle.properties
index 06c3c48dc..700106ff1 100644
--- a/integration/recyclerview/gradle.properties
+++ b/integration/recyclerview/gradle.properties
@@ -1,15 +1,4 @@
 POM_NAME=Glide RecyclerView Integration
 POM_ARTIFACT_ID=recyclerview-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-VERSION_CODE=8
-
 POM_DESCRIPTION=An integration library to display images in RecyclerView.
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
index a3fd25880..30bf14dcb 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.recyclerview;
 
+import android.support.annotation.NonNull;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
 import android.widget.AbsListView;
@@ -11,6 +12,8 @@
  *
  * <p>Requires that the the recycler view be using a {@link LinearLayoutManager} subclass.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class RecyclerToListViewScrollListener extends RecyclerView.OnScrollListener {
   public static final int UNKNOWN_SCROLL_STATE = Integer.MIN_VALUE;
   private final AbsListView.OnScrollListener scrollListener;
@@ -18,7 +21,7 @@
   private int lastVisibleCount = -1;
   private int lastItemCount = -1;
 
-  public RecyclerToListViewScrollListener(AbsListView.OnScrollListener scrollListener) {
+  public RecyclerToListViewScrollListener(@NonNull AbsListView.OnScrollListener scrollListener) {
     this.scrollListener = scrollListener;
   }
 
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
index 6e062e393..988561eac 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.integration.recyclerview;
 
 import android.app.Activity;
-import android.app.Fragment;
+import android.support.annotation.NonNull;
+import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v7.widget.RecyclerView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.ListPreloader.PreloadModelProvider;
@@ -35,17 +35,18 @@
   /**
    * Helper constructor that accepts an {@link Activity}.
    */
-  public RecyclerViewPreloader(Activity activity,
-      PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public RecyclerViewPreloader(@NonNull Activity activity,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
     this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
   /**
    * Helper constructor that accepts an {@link FragmentActivity}.
    */
-  public RecyclerViewPreloader(FragmentActivity fragmentActivity,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  public RecyclerViewPreloader(@NonNull FragmentActivity fragmentActivity,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
@@ -53,20 +54,26 @@ public RecyclerViewPreloader(FragmentActivity fragmentActivity,
   /**
    * Helper constructor that accepts an {@link Fragment}.
    */
-  public RecyclerViewPreloader(Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  public RecyclerViewPreloader(@NonNull Fragment fragment,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
 
   /**
-   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
+   * Helper constructor that accepts an {@link android.app.Fragment}.
+   * @deprecated Use constructor <code>RecyclerViewPreloader(Fragment, PreloadModelProvider<T>,
+   * PreloadSizeProvider<T>)</code> instead.
    */
-  public RecyclerViewPreloader(android.support.v4.app.Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
+  @Deprecated
+  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,
       int maxPreload) {
     this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
   }
+
   /**
    * Constructor that accepts interfaces for providing the dimensions of images to preload, the list
    * of models to preload for a given position, and the request to use to load images.
@@ -75,9 +82,9 @@ public RecyclerViewPreloader(android.support.v4.app.Fragment fragment,
    * @param preloadDimensionProvider Provides the dimensions of images to load.
    * @param maxPreload               Maximum number of items to preload.
    */
-  public RecyclerViewPreloader(RequestManager requestManager,
-      PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public RecyclerViewPreloader(@NonNull RequestManager requestManager,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
 
     ListPreloader<T> listPreloader = new ListPreloader<>(requestManager, preloadModelProvider,
         preloadDimensionProvider, maxPreload);
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index 3a592592b..a6776127a 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -1,31 +1,26 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
-
-repositories {
-    mavenCentral()
-}
 
 dependencies {
-    compile project(':glide')
-    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
-
-    testCompile project(":testutil")
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    implementation project(':library')
+    api "com.android.volley:volley:${VOLLEY_VERSION}"
+    api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
+    annotationProcessor project(':annotation:compiler')
+
+    testImplementation project(":testutil")
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -35,4 +30,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/volley/gradle.properties b/integration/volley/gradle.properties
index 0fad11225..198619280 100644
--- a/integration/volley/gradle.properties
+++ b/integration/volley/gradle.properties
@@ -1,15 +1,4 @@
 POM_NAME=Glide Volley Integration
 POM_ARTIFACT_ID=volley-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-VERSION_CODE=8
-
 POM_DESCRIPTION=An integration library to use Volley to fetch data over http/https in Glide
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
index 85f2b5add..5756c6172 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
-
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.module.GlideModule;
-
 import java.io.InputStream;
 
 /**
@@ -16,16 +15,20 @@
  *
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ * information, see {@link com.bumptech.glide.module.GlideModule}.
+ *
+ * @deprecated Replaced with {@link VolleyLibraryGlideModule}.
  */
-public class VolleyGlideModule implements GlideModule {
+@Deprecated
+@SuppressWarnings("deprecation")
+public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     // Do nothing.
   }
 
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
   }
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
new file mode 100644
index 000000000..514c62008
--- /dev/null
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
@@ -0,0 +1,29 @@
+package com.bumptech.glide.integration.volley;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a
+ * Volley based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public class VolleyLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
+  }
+}
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
index 837efdc8a..bbc313217 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
@@ -3,7 +3,6 @@
 import com.android.volley.Request;
 import com.android.volley.Request.Priority;
 import com.bumptech.glide.load.data.DataFetcher.DataCallback;
-
 import java.io.InputStream;
 import java.util.Map;
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
deleted file mode 100644
index b1cd97f05..000000000
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.bumptech.glide.integration.volley;
-
-import com.android.volley.Request;
-import com.android.volley.Response;
-import com.android.volley.VolleyError;
-
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-/**
- * TODO: contribute cancel modifications to volley and remove this class.
- *
- * A Future that represents a Volley request.
- *
- * Used by providing as your response and error listeners. For example:
- * <pre>
- * RequestFuture&lt;JSONObject&gt; future = RequestFuture.newFuture();
- * MyRequest request = new MyRequest(URL, future, future);
- *
- * // If you want to be able to cancel the request:
- * future.setRequest(requestQueue.add(request));
- *
- * // Otherwise:
- * requestQueue.add(request);
- *
- * try {
- *   JSONObject response = future.get();
- *   // do something with response
- * } catch (InterruptedException e) {
- *   // handle the error
- * } catch (ExecutionException e) {
- *   // handle the error
- * }
- * </pre>
- *
- * @param <T> The type of parsed response this future expects.
- */
-public class VolleyRequestFuture<T> implements Future<T>,
-    Response.Listener<T>,
-    Response.ErrorListener {
-  private Request<?> mRequest;
-  private boolean mResultReceived = false;
-  private T mResult;
-  private VolleyError mException;
-  private boolean mIsCancelled = false;
-
-  public static <E> VolleyRequestFuture<E> newFuture() {
-    return new VolleyRequestFuture<E>();
-  }
-
-  public synchronized void setRequest(Request<?> request) {
-    mRequest = request;
-    if (mIsCancelled && mRequest != null) {
-      mRequest.cancel();
-    }
-  }
-
-  @Override
-  public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-    if (isDone()) {
-      return false;
-    }
-    mIsCancelled = true;
-    if (mRequest != null) {
-      mRequest.cancel();
-    }
-    notifyAll();
-
-    return true;
-  }
-
-  @Override
-  public T get() throws InterruptedException, ExecutionException {
-    try {
-      return doGet(null);
-    } catch (TimeoutException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override
-  public T get(long timeout, TimeUnit unit)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    return doGet(TimeUnit.MILLISECONDS.convert(timeout, unit));
-  }
-
-  private synchronized T doGet(Long timeoutMs)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    if (mException != null) {
-      throw new ExecutionException(mException);
-    }
-
-    if (mResultReceived) {
-      return mResult;
-    }
-
-    if (isCancelled()) {
-      throw new CancellationException();
-    }
-
-    if (timeoutMs == null) {
-      wait(0);
-    } else if (timeoutMs > 0) {
-      wait(timeoutMs);
-    }
-
-    if (mException != null) {
-      throw new ExecutionException(mException);
-    }
-
-    if (isCancelled()) {
-      throw new CancellationException();
-    }
-
-    if (!mResultReceived) {
-      throw new TimeoutException();
-    }
-
-    return mResult;
-  }
-
-  @Override
-  public boolean isCancelled() {
-    return mIsCancelled;
-  }
-
-  @Override
-  public synchronized boolean isDone() {
-    return mResultReceived || mException != null || isCancelled();
-  }
-
-  @Override
-  public synchronized void onResponse(T response) {
-    mResultReceived = true;
-    mResult = response;
-    notifyAll();
-  }
-
-  @Override
-  public synchronized void onErrorResponse(VolleyError error) {
-    mException = error;
-    notifyAll();
-  }
-}
-
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index 02e517cc0..3137fdcdb 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -1,8 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
-
-import com.android.volley.AuthFailureError;
 import com.android.volley.NetworkResponse;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
@@ -13,7 +12,6 @@
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
-
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.util.Collections;
@@ -22,6 +20,8 @@
 /**
  * A DataFetcher backed by volley for fetching images via http.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class VolleyStreamFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "VolleyStreamFetcher";
   public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
@@ -50,7 +50,8 @@ public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super InputStream> callback) {
     request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),
         url.getHeaders());
     requestQueue.add(request);
@@ -69,17 +70,19 @@ public void cancel() {
     }
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.REMOTE;
   }
 
-  private static Request.Priority glideToVolleyPriority(Priority priority) {
+  private static Request.Priority glideToVolleyPriority(@NonNull Priority priority) {
     switch (priority) {
       case LOW:
         return Request.Priority.LOW;
@@ -93,9 +96,11 @@ public DataSource getDataSource() {
   }
 
   /**
-   * Default {@link com.android.volley.Request} implementation for Glide that recives errors and
+   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and
    * results on volley's background thread.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static class GlideRequest extends Request<byte[]> {
     private final DataCallback<? super InputStream> callback;
     private final Priority priority;
@@ -114,7 +119,7 @@ public GlideRequest(String url, DataCallback<? super InputStream> callback, Prio
     }
 
     @Override
-    public Map<String, String> getHeaders() throws AuthFailureError {
+    public Map<String, String> getHeaders() {
       return headers;
     }
 
@@ -128,13 +133,17 @@ protected VolleyError parseNetworkError(VolleyError volleyError) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Volley failed to retrieve response", volleyError);
       }
-      callback.onLoadFailed(volleyError);
+      if (!isCanceled()) {
+        callback.onLoadFailed(volleyError);
+      }
       return super.parseNetworkError(volleyError);
     }
 
     @Override
     protected Response<byte[]> parseNetworkResponse(NetworkResponse response) {
-      callback.onDataReady(new ByteArrayInputStream(response.data));
+      if (!isCanceled()) {
+        callback.onDataReady(new ByteArrayInputStream(response.data));
+      }
       return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));
     }
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index a07ef442e..a5ceda30a 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
-
+import android.support.annotation.NonNull;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.load.Options;
@@ -9,7 +9,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 
 /**
@@ -20,29 +19,35 @@
   private final RequestQueue requestQueue;
   private final VolleyRequestFactory requestFactory;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public VolleyUrlLoader(RequestQueue requestQueue) {
     this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public VolleyUrlLoader(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
     this.requestQueue = requestQueue;
     this.requestFactory = requestFactory;
   }
 
   @Override
-  public boolean handles(GlideUrl url) {
+  public boolean handles(@NonNull GlideUrl url) {
     return true;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl url, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));
   }
 
   /**
    * The default factory for {@link VolleyUrlLoader}s.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private static volatile RequestQueue internalQueue;
 
@@ -72,9 +77,9 @@ public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
       this.requestQueue = requestQueue;
     }
 
+    @NonNull
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory factory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {
       return new VolleyUrlLoader(requestQueue, requestFactory);
     }
 
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index 6adda6f3f..740acc113 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -10,7 +10,6 @@
 import static org.mockito.Mockito.when;
 
 import android.os.SystemClock;
-
 import com.android.volley.RequestQueue;
 import com.android.volley.VolleyError;
 import com.android.volley.toolbox.Volley;
@@ -18,9 +17,14 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -37,13 +41,6 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowSystemClock;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.CountDownLatch;
-
 /**
  * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server
  * responses.
@@ -54,8 +51,7 @@
 public class VolleyStreamFetcherServerTest {
   private static final String DEFAULT_PATH = "/fakepath";
 
-  @Mock VolleyRequestFactory requestFactory;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private MockWebServer mockWebServer;
   private RequestQueue requestQueue;
@@ -97,7 +93,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -109,7 +105,7 @@ public void testHandlesRedirect301s() throws Exception {
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -124,7 +120,7 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -162,7 +158,7 @@ public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {
   public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 20; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
     waitForResponseLatch.await();
@@ -202,11 +198,11 @@ public void testAppliesHeadersInGlideUrl() throws Exception {
   }
 
   private DataFetcher<InputStream> getFetcher() {
-    return getFetcher(Headers.NONE);
+    return getFetcher(Headers.DEFAULT);
   }
 
   private DataFetcher<InputStream> getFetcher(Headers headers) {
-    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    URL url = mockWebServer.url(DEFAULT_PATH).url();
     return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));
   }
 
diff --git a/library/build.gradle b/library/build.gradle
index 0b745203f..a47b7173b 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,130 +1,52 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
-apply plugin: 'maven'
-apply plugin: 'findbugs'
-apply plugin: 'pmd'
-apply plugin: 'jacoco'
-apply plugin: 'com.github.kt3k.coveralls'
 
-findbugs {
-    toolVersion = FINDBUGS_VERSION
+if (!hasProperty('DISABLE_ERROR_PRONE')) {
+    apply plugin: "net.ltgt.errorprone"
 }
-jacoco {
-    toolVersion = JACOCO_VERSION
-}
-coveralls {
-    jacocoReportPath = 'build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml'
-}
-
-dependencies {
-    compile project(':third_party:gif_decoder')
-    compile project(':third_party:disklrucache')
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
 
-    testCompile project(':testutil')
-    testCompile 'com.google.guava:guava-testlib:18.0'
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+tasks.withType(JavaCompile) {
+    options.fork = true
 }
 
-android.testOptions.unitTests.all {
-    // configure max heap size of the test JVM
-    maxHeapSize = '2048m'
+dependencies {
+    api project(':third_party:gif_decoder')
+    api project(':third_party:disklrucache')
+    api project(':annotation')
+    api "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    compileOnly "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+
+    if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
+        errorprone "com.google.errorprone:error_prone_core:${ERROR_PRONE_VERSION}"
+    }
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
-
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
-    buildTypes {
-        debug {
-            testCoverageEnabled = true
-        }
-    }
-
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_7
         targetCompatibility JavaVersion.VERSION_1_7
     }
 }
 
-afterEvaluate {
-    task findbugs(type: FindBugs, dependsOn: assembleDebug) {
-
-        description 'Run findbugs'
-        group 'verification'
-
-        classes = fileTree('build/intermediates/classes/debug/')
-        source = fileTree('src/main/java')
-        classpath = project.configurations.compile
-
-        effort = 'max'
-
-        excludeFilter = file("findbugs-exclude.xml")
-
-        reports {
-            xml.enabled = false
-            html.enabled = true
-        }
-    }
-
-    check.dependsOn('findbugs')
-
-    task pmd(type: Pmd) {
-        targetJdk = TargetJdk.VERSION_1_7
-
-        description 'Run pmd'
-        group 'verification'
-
-        // If ruleSets is not empty, it seems to contain some
-        // defaults which override rules in the ruleset file...
-        ruleSets = []
-        ruleSetFiles = files('pmd-ruleset.xml')
-        source = fileTree('src/main/java')
-
-        reports {
-            xml.enabled = false
-            html.enabled = true
-        }
-    }
-
-    check.dependsOn('pmd')
-
-    task jacocoTestReport(type: JacocoReport, dependsOn: testDebug) {
-        def coverageSourceDirs = ['src/main/java']
-        group = "Reporting"
-        description = "Generate Jacoco coverage reports"
-
-        classDirectories = fileTree(
-                dir: 'build/intermediates/classes/debug',
-                excludes: ['**/R.class',
-                           '**/R$*.class',
-                           '**/BuildConfig.*',
-                           '**/Manifest*.*',
-                           '**/BitmapRequestBuilder.class',
-                           '**/DrawableRequestBuilder.class',
-                           '**/GifRequestBuilder.class',]
-        )
-
-        additionalSourceDirs = files(coverageSourceDirs)
-        sourceDirectories = files(coverageSourceDirs)
-        executionData = files('build/jacoco/testDebug.exec')
-
-        reports {
-            xml.enabled = true
-            html.enabled = true
-        }
-    }
+check.dependsOn(':library:findbugs:findbugs')
+check.dependsOn(':library:pmd:pmd')
+check.dependsOn(':library:test:check')
+
+// Used in pmd and findbugs subprojects.
+@SuppressWarnings("GroovyUnusedDeclaration")
+def classPathForQuality() {
+    return files(
+            android.bootClasspath,
+            project.configurations.compile,
+            project.android.libraryVariants.collect { it.javaCompile.classpath }
+    )
 }
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/library/findbugs-exclude.xml b/library/findbugs-exclude.xml
index f929a391d..bd1e9afd3 100644
--- a/library/findbugs-exclude.xml
+++ b/library/findbugs-exclude.xml
@@ -36,4 +36,16 @@
        <Bug pattern="DM_DEFAULT_ENCODING" />
     </Match>
 
+    <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->
+    <Match>
+      <Class name="com.bumptech.glide.load.engine.executor.RuntimeCompat" />
+      <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
+    </Match>
+
+    <!-- Re-using the byte array saves allocations, there's no serious risk of mutations. -->
+    <Match>
+      <Class name="com.bumptech.glide.util.FixedPreloadSizeProvider" />
+      <Bug pattern="EI_EXPOSE_REP" />
+    </Match>
+
 </FindBugsFilter>
diff --git a/library/findbugs/build.gradle b/library/findbugs/build.gradle
new file mode 100644
index 000000000..a2e5b3f2a
--- /dev/null
+++ b/library/findbugs/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'findbugs'
+
+findbugs {
+    toolVersion FINDBUGS_VERSION
+}
+
+def library = project(':library')
+
+tasks.create('findbugs', FindBugs) {
+    dependsOn library.tasks.compileDebugJavaWithJavac
+
+    description 'Run findbugs'
+    group 'verification'
+
+    classes = fileTree(library.tasks.compileDebugJavaWithJavac.destinationDir)
+    source library.android.sourceSets.main.java.srcDirs
+    classpath = files()
+    doFirst {
+        classpath += library.classPathForQuality()
+    }
+    effort = 'max'
+    excludeFilter = file("${library.projectDir}/findbugs-exclude.xml")
+
+    // Failures are caught and printed by the violations plugin.
+    ignoreFailures = true
+
+    reports {
+        xml.enabled = true
+        html.enabled = false
+    }
+}
diff --git a/library/gradle.properties b/library/gradle.properties
index 6f3b84292..b361d87c5 100644
--- a/library/gradle.properties
+++ b/library/gradle.properties
@@ -1,3 +1,7 @@
-POM_NAME=Glide Library
-POM_ARTIFACT_ID=library
+POM_NAME=Glide
+POM_ARTIFACT_ID=glide
 POM_PACKAGING=aar
+
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=
diff --git a/library/lint.xml b/library/lint.xml
index ff7e5955c..c6cf01b20 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -1,4 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="AllowBackup" severity="ignore"/>
+    <issue id="ExifInterface" severity="ignore"/>
 </lint>
diff --git a/library/pmd-ruleset.xml b/library/pmd-ruleset.xml
index 01bb11a73..8297a5c09 100644
--- a/library/pmd-ruleset.xml
+++ b/library/pmd-ruleset.xml
@@ -3,36 +3,168 @@
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
 
-    <description>This ruleset was created from PMD.rul</description>
+    <description>Check for flaws in Glide's codebase.</description>
 
-    <rule ref="rulesets/java/basic.xml">
+    <rule ref="category/java/errorprone.xml">
         <exclude name="AvoidBranchingStatementAsLastInLoop"/>
+        <!-- Not using beans. -->
+        <exclude name="BeanMembersShouldSerialize" />
+        <!-- wat -->
+        <exclude name="AvoidFieldNameMatchingTypeName" />
+        <!-- This is identifying trivial cases that are clearly correct. -->
+        <exclude name="DataflowAnomalyAnalysis" />
+        <!-- Used regularly for object pooling. -->
+        <exclude name="NullAssignment" />
+        <!-- This can make the code easier to read and avoid duplicated logic in some cases. -->
+        <exclude name="AssignmentInOperand" />
+        <!-- I don't think this is confusing. -->
+        <exclude name="AvoidFieldNameMatchingMethodName" />
+        <!-- There are enough cases where this makes sense (typically related to logic around the number of items in a collection) that a blanket ban doesn't seem like a good idea. -->
+        <exclude name="AvoidLiteralsInIfCondition" />
+        <!-- It's clear that this is bad, but we have a number of cases where it makes sense and a blanket ban is irritating. -->
+        <exclude name="AvoidCatchingThrowable" />
     </rule>
-    <rule ref="rulesets/java/braces.xml"/>
-    <rule ref="rulesets/java/strings.xml">
-        <!-- TODO: This warns about annotations, apparently fixed in a later version. -->
-        <exclude name="AvoidDuplicateLiterals"/>
+    <rule ref="category/java/errorprone.xml/AvoidDuplicateLiterals">
+      <properties>
+        <property name="skipAnnotations" value="true" />
+      </properties>
+    </rule>
+    <rule ref="category/java/codestyle.xml">
+      <!-- Abstract classes don't need to have Abstract in the name -->
+      <exclude name="AbstractNaming" />
+      <!-- Who cares? -->
+      <exclude name="AtLeastOneConstructor" />
+      <!-- Don't need to annotate package private methods. -->
+      <exclude name="DefaultPackage" />
+      <exclude name="CommentDefaultAccessModifier" />
+      <!-- Optionally implemented default empty methods are fine. -->
+      <exclude name="EmptyMethodInAbstractClassShouldBeAbstract" />
+      <!-- Why make generics less clear by using shorter names? -->
+      <exclude name="GenericsNaming" />
+      <!-- No need to enforce final if it's not necessary. -->
+      <exclude name="MethodArgumentCouldBeFinal" />
+      <exclude name="LocalVariableCouldBeFinal" />
+      <!-- This isn't always the easiest way to read a method. -->
+      <exclude name="OnlyOneReturn" />
+      <!-- Obfuscated code is best code? -->
+      <exclude name="LongVariable" />
+      <!-- This is not always true. -->
+      <exclude name="ShortClassName" />
+      <!-- A good idea but we have tons of violations. FIXME. -->
+      <exclude name="ShortMethodName" />
+      <exclude name="ShortVariable" />
+      <!-- We don't use in and out to mean modified or not modified by the method, it's useful to match framework methods. -->
+      <exclude name="AvoidPrefixingMethodParameters" />
+      <!-- No idea what this is supposed to accomplish. -->
+      <exclude name="AvoidFinalLocalVariable" />
+      <!-- These are often useful for clarity and explicitly suggested by Google's code style. -->
+      <exclude name="UselessParentheses" />
+      <!-- Theoretically this might be reasonable but the number of imports probably varies from class to class and this doesn't seem worth the overhead to maintain. -->
+      <exclude name="TooManyStaticImports" />
+      <!-- Lots of existing violations, not clear that the overhead is worthwhile though there are some cases where we definitely need to call super. FIXME. -->
+      <exclude name="CallSuperInConstructor" />
+      <!-- This is a reasonable idea, but in practice often the != null case is the expected case and it makes sense for it to come first. -->
+      <exclude name="ConfusingTernary" />
+    </rule>
+    <rule ref="category/java/performance.xml" >
+      <!-- Android may not behave the same as java VMs, using short can be clearer when working with binary data. -->
+      <exclude name="AvoidUsingShortType" />
+      <!-- The suggsted alternatives are not available until Glide's minsdk level is 26+ -->
+      <exclude name="AvoidFileStream" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml" >
+      <!-- Catches any method, test or not, that has the name "tearDown". -->
+      <exclude name="JUnit4TestShouldUseAfterAnnotation" />
+      <!-- This is a good idea, but in practice it's often somewhat clearer than defining a temporary variable and we do it all over the place. -->
+      <exclude name="AvoidReassigningParameters" />
+      <!-- This ignores imports used by javadocs and is worse than the existing checkstyle check. -->
+      <exclude name="UnusedImports" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml/OneDeclarationPerLine">
+      <properties>
+        <property name="strictMode" value="true" />
+        <!-- Allow `for (int i = 0, size = list.size(); i < size; i++) {`
+             Somewhat clearer to set size along with the index. -->
+        <property name="violationSuppressXPath"
+                  value="self::LocalVariableDeclaration
+                           [parent::ForInit]
+                           [Type/PrimitiveType[@Image = 'int']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='i']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='size']
+                           ]
+                        " />
+      </properties>
+    </rule>
+    <rule ref="category/java/bestpractices.xml/AccessorMethodGeneration"
+      message="Avoid autogenerated methods to access private fields and methods of inner / outer classes.
+                       Use @Synthetic to flag members made more visible than necessary to prevent accessors.">
+      <properties>
+        <!-- Ignore references to `private static final * * = <literal>`
+             Suppress via XPath: current node (access that generates the accessor) is .
+             Check if there exists a FieldDeclaration (private static final)
+             which has a VariableInitializer with a Literal
+             and the name (@Image) of the declaration is the same as the accessed member.
+             TODO calculated constants are false positive https://github.com/pmd/pmd/issues/808
+        -->
+        <property name="violationSuppressXPath" value="
+                .[@Image =
+                    //FieldDeclaration[@Private = 'true' and @Static='true' and @Final='true']
+                    /VariableDeclarator[
+                        VariableInitializer/Expression/PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Literal
+                    ]/VariableDeclaratorId/@Image
+                 ]" />
+      </properties>
     </rule>
-    <rule ref="rulesets/java/unusedcode.xml"/>
 
-    <rule ref="rulesets/java/design.xml">
-        <exclude name="ConfusingTernary"/>
-        <exclude name="EmptyMethodInAbstractClassShouldBeAbstract"/>
-        <exclude name="AvoidSynchronizedAtMethodLevel"/>
+    <rule ref="category/java/design.xml">
+        <exclude name="GodClass" />
+        <!-- No idea how you reasonably define this. -->
+        <exclude name="ExcessiveImports" />
+        <exclude name="CouplingBetweenObjects" />
+        <exclude name="TooManyMethods" />
+        <exclude name="LawOfDemeter" />
+        <exclude name="NcssCount" />
+        <exclude name="ExcessiveParameterList" />
+        <exclude name="TooManyFields" />
+        <!-- We don't define any packages to use with this rule. -->
+        <exclude name="LoosePackageCoupling" />
+        <!-- Throwing other types of exceptions doesn't seem to add much to clarify. -->
+        <exclude name="AvoidThrowingRawExceptionTypes" />
+        <exclude name="AvoidThrowingNullPointerException" />
+        <!-- TODO: explore these further. -->
+        <exclude name="CyclomaticComplexity" />
+        <exclude name="NPathComplexity" />
+        <exclude name="ExcessiveMethodLength" />
+        <exclude name="ExcessiveClassLength" />
+        <exclude name="ExcessivePublicCount" />
+        <!-- This is redundant, also caught with AvoidCatchingNPEs. -->
+        <exclude name="AvoidCatchingGenericException" />
+    </rule>
 
+    <rule ref="category/java/multithreading.xml">
+        <exclude name="AvoidSynchronizedAtMethodLevel"/>
         <!-- This check breaks on double checked locking which is safe in Java 6/7 -->
         <exclude name="NonThreadSafeSingleton"/>
-
-        <!-- TODO: Fix these -->
-        <exclude name="AvoidReassigningParameters"/>
-        <exclude name="GodClass"/>
+        <!-- Used frequently in the singleton pattern. -->
+        <exclude name="AvoidUsingVolatile" />
+        <!-- No reason to do this by default. -->
+        <exclude name="UseConcurrentHashMap" />
+        <exclude name="DoNotUseThreads" />
     </rule>
 
-    <rule ref="rulesets/java/empty.xml/EmptyCatchBlock" message="Commented blocks are ok">
+    <rule ref="category/java/errorprone.xml/EmptyCatchBlock" message="Commented blocks are ok">
         <properties>
             <property name="allowCommentedBlocks" value="true"/>
         </properties>
     </rule>
 
 
+  <!-- Configures check to avoid violation when @Synthetic annotation is present. -->
+    <rule ref="category/java/documentation.xml/UncommentedEmptyConstructor">
+      <properties>
+        <property name="violationSuppressXPath"
+          value="../Annotation/MarkerAnnotation/Name[@Image='Synthetic']" />
+      </properties>
+    </rule>
+
 </ruleset>
diff --git a/library/pmd/build.gradle b/library/pmd/build.gradle
new file mode 100644
index 000000000..d02349082
--- /dev/null
+++ b/library/pmd/build.gradle
@@ -0,0 +1,39 @@
+apply plugin: 'pmd'
+
+def library = project(':library')
+
+pmd {
+    toolVersion PMD_VERSION
+}
+
+tasks.create('pmd', Pmd) {
+    dependsOn library.tasks.compileDebugJavaWithJavac
+    targetJdk = TargetJdk.VERSION_1_7
+
+    description 'Run pmd'
+    group 'verification'
+
+    // If ruleSets is not empty, it seems to contain some
+    // defaults which override rules in the ruleset file...
+    ruleSets = []
+    ruleSetFiles = files("${library.projectDir}/pmd-ruleset.xml")
+    source library.android.sourceSets.main.java.srcDirs
+    classpath = files()
+    classpath += files(library.tasks.compileDebugJavaWithJavac.destinationDir)
+    doFirst {
+        classpath += library.classPathForQuality()
+    }
+
+    //TODO enable this once new Gradle containing this flag is out
+    //see https://github.com/gradle/gradle/pull/3125#issuecomment-352442432
+    //incrementalAnalysis = true
+
+    // Failures are caught and printed by the violations plugin.
+    ignoreFailures = true
+
+    reports {
+        xml.enabled = true
+        html.enabled = false
+    }
+}
+
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
new file mode 100644
index 000000000..bfb14d052
--- /dev/null
+++ b/library/proguard-rules.txt
@@ -0,0 +1,9 @@
+-keep public class * implements com.bumptech.glide.module.GlideModule
+-keep public class * extends com.bumptech.glide.module.AppGlideModule
+-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
+  **[] $VALUES;
+  public *;
+}
+
+# Uncomment for DexGuard only
+#-keepresourcexmlelements manifest/application/meta-data@value=GlideModule
\ No newline at end of file
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 06f5c692a..2e0f06b5f 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.bumptech.glide">
+<manifest package="com.bumptech.glide">
 
     <application/>
 </manifest>
diff --git a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
new file mode 100644
index 000000000..5f480de80
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.module.AppGlideModule;
+import java.util.Set;
+
+/**
+ * Allows {@link AppGlideModule}s to exclude {@link com.bumptech.glide.annotation.GlideModule}s to
+ * ease the migration from {@link com.bumptech.glide.annotation.GlideModule}s to Glide's annotation
+ * processing system and optionally provides a
+ * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} impl.
+ */
+abstract class GeneratedAppGlideModule extends AppGlideModule {
+  /**
+   * This method can be removed when manifest parsing is no longer supported.
+   */
+  @NonNull
+  abstract Set<Class<?>> getExcludedModuleClasses();
+
+  @Nullable
+  RequestManagerRetriever.RequestManagerFactory getRequestManagerFactory() {
+    return null;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
index 47657e942..a630b4f86 100644
--- a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
@@ -1,16 +1,59 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
+import com.bumptech.glide.request.transition.TransitionFactory;
+import com.bumptech.glide.request.transition.ViewPropertyTransition;
+
 /**
  * Implementation of {@link TransitionOptions} that exposes only generic methods that can be applied
  * to any resource type.
  *
  * @param <TranscodeType> The type of the resource that will be displayed.
  */
-@SuppressWarnings("PMD.UseUtilityClass")
+// Public API.
+@SuppressWarnings({"PMD.UseUtilityClass", "unused"})
 public final class GenericTransitionOptions<TranscodeType> extends
-  TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
-
+    TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
+  /**
+   * Removes any existing animation put on the builder.
+   *
+   * @see GenericTransitionOptions#dontTransition()
+   */
+  @NonNull
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {
     return new GenericTransitionOptions<TranscodeType>().dontTransition();
   }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given view animation.
+   *
+   * @see GenericTransitionOptions#transition(int)
+   */
+  @NonNull
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      int viewAnimationId) {
+    return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);
+  }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given animator.
+   *
+   * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator)
+   */
+  @NonNull
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      @NonNull ViewPropertyTransition.Animator animator) {
+    return new GenericTransitionOptions<TranscodeType>().transition(animator);
+  }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given transition factory.
+   *
+   * @see GenericTransitionOptions#transition(TransitionFactory)
+   */
+  @NonNull
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      @NonNull TransitionFactory<? super TranscodeType> transitionFactory) {
+    return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index a7ce42d77..ea9fcea8f 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -1,27 +1,31 @@
 package com.bumptech.glide;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ComponentCallbacks2;
+import android.content.ContentResolver;
 import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
-import android.os.Build;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
-
+import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.InputStreamRewinder;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.prefill.BitmapPreFiller;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
@@ -29,6 +33,7 @@
 import com.bumptech.glide.load.model.ByteArrayLoader;
 import com.bumptech.glide.load.model.ByteBufferEncoder;
 import com.bumptech.glide.load.model.ByteBufferFileLoader;
+import com.bumptech.glide.load.model.DataUrlLoader;
 import com.bumptech.glide.load.model.FileLoader;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.MediaStoreFileLoader;
@@ -47,10 +52,15 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableEncoder;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.ResourceBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.load.resource.bytes.ByteBufferRewinder;
+import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
+import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;
 import com.bumptech.glide.load.resource.file.FileDecoder;
 import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -59,32 +69,38 @@
 import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
 import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder;
+import com.bumptech.glide.load.resource.transcode.DrawableBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
-import com.bumptech.glide.module.GlideModule;
 import com.bumptech.glide.module.ManifestParser;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 /**
  * A singleton to present a simple static interface for building requests with
  * {@link RequestBuilder} and maintaining an {@link Engine}, {@link BitmapPool},
  * {@link com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
  */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class Glide implements ComponentCallbacks2 {
   private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
   private static final String TAG = "Glide";
   private static volatile Glide glide;
+  private static volatile boolean isInitializing;
 
   private final Engine engine;
   private final BitmapPool bitmapPool;
@@ -92,8 +108,11 @@
   private final BitmapPreFiller bitmapPreFiller;
   private final GlideContext glideContext;
   private final Registry registry;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool arrayPool;
+  private final RequestManagerRetriever requestManagerRetriever;
+  private final ConnectivityMonitorFactory connectivityMonitorFactory;
   private final List<RequestManager> managers = new ArrayList<>();
+  private MemoryCategory memoryCategory = MemoryCategory.NORMAL;
 
   /**
    * Returns a directory with a default name in the private cache directory of the application to
@@ -103,7 +122,7 @@
    * @see #getPhotoCacheDir(android.content.Context, String)
    */
   @Nullable
-  public static File getPhotoCacheDir(Context context) {
+  public static File getPhotoCacheDir(@NonNull Context context) {
     return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
   }
 
@@ -116,7 +135,7 @@ public static File getPhotoCacheDir(Context context) {
    * @see #getPhotoCacheDir(android.content.Context)
    */
   @Nullable
-  public static File getPhotoCacheDir(Context context, String cacheName) {
+  public static File getPhotoCacheDir(@NonNull Context context, @NonNull String cacheName) {
     File cacheDir = context.getCacheDir();
     if (cacheDir != null) {
       File result = new File(cacheDir, cacheName);
@@ -137,21 +156,12 @@ public static File getPhotoCacheDir(Context context, String cacheName) {
    *
    * @return the singleton
    */
-  public static Glide get(Context context) {
+  @NonNull
+  public static Glide get(@NonNull Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
-          Context applicationContext = context.getApplicationContext();
-          List<GlideModule> modules = new ManifestParser(applicationContext).parse();
-
-          GlideBuilder builder = new GlideBuilder(applicationContext);
-          for (GlideModule module : modules) {
-            module.applyOptions(applicationContext, builder);
-          }
-          glide = builder.createGlide();
-          for (GlideModule module : modules) {
-            module.registerComponents(applicationContext, glide.registry);
-          }
+          checkAndInitializeGlide(context);
         }
       }
     }
@@ -159,94 +169,342 @@ public static Glide get(Context context) {
     return glide;
   }
 
-  // For testing.
-  static void tearDown() {
+  private static void checkAndInitializeGlide(@NonNull Context context) {
+    // In the thread running initGlide(), one or more classes may call Glide.get(context).
+    // Without this check, those calls could trigger infinite recursion.
+    if (isInitializing) {
+      throw new IllegalStateException("You cannot call Glide.get() in registerComponents(),"
+          + " use the provided Glide instance instead");
+    }
+    isInitializing = true;
+    initializeGlide(context);
+    isInitializing = false;
+  }
+
+  /**
+   * @deprecated Use {@link #init(Context, GlideBuilder)} to get a singleton compatible with
+   * Glide's generated API.
+   *
+   * <p>This method will be removed in a future version of Glide.
+   */
+  @VisibleForTesting
+  @Deprecated
+  public static synchronized void init(Glide glide) {
+    if (Glide.glide != null) {
+      tearDown();
+    }
+    Glide.glide = glide;
+  }
+
+  @VisibleForTesting
+  public static synchronized void init(@NonNull Context context, @NonNull GlideBuilder builder) {
+    if (Glide.glide != null) {
+      tearDown();
+    }
+    initializeGlide(context, builder);
+  }
+
+  @VisibleForTesting
+  public static synchronized void tearDown() {
+    if (glide != null) {
+      glide.getContext()
+          .getApplicationContext()
+          .unregisterComponentCallbacks(glide);
+      glide.engine.shutdown();
+    }
     glide = null;
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,
-      Context context, int logLevel, RequestOptions defaultRequestOptions) {
+  private static void initializeGlide(@NonNull Context context) {
+    initializeGlide(context, new GlideBuilder());
+  }
+
+  @SuppressWarnings("deprecation")
+  private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
+    Context applicationContext = context.getApplicationContext();
+    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
+    List<com.bumptech.glide.module.GlideModule> manifestModules = Collections.emptyList();
+    if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
+      manifestModules = new ManifestParser(applicationContext).parse();
+    }
+
+    if (annotationGeneratedModule != null
+        && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
+      Set<Class<?>> excludedModuleClasses =
+          annotationGeneratedModule.getExcludedModuleClasses();
+      Iterator<com.bumptech.glide.module.GlideModule> iterator = manifestModules.iterator();
+      while (iterator.hasNext()) {
+        com.bumptech.glide.module.GlideModule current = iterator.next();
+        if (!excludedModuleClasses.contains(current.getClass())) {
+          continue;
+        }
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "AppGlideModule excludes manifest GlideModule: " + current);
+        }
+        iterator.remove();
+      }
+    }
+
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) {
+        Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
+      }
+    }
+
+    RequestManagerRetriever.RequestManagerFactory factory =
+        annotationGeneratedModule != null
+            ? annotationGeneratedModule.getRequestManagerFactory() : null;
+    builder.setRequestManagerFactory(factory);
+    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
+      module.applyOptions(applicationContext, builder);
+    }
+    if (annotationGeneratedModule != null) {
+      annotationGeneratedModule.applyOptions(applicationContext, builder);
+    }
+    Glide glide = builder.build(applicationContext);
+    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
+      module.registerComponents(applicationContext, glide, glide.registry);
+    }
+    if (annotationGeneratedModule != null) {
+      annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
+    }
+    applicationContext.registerComponentCallbacks(glide);
+    Glide.glide = glide;
+  }
+
+  @Nullable
+  @SuppressWarnings({"unchecked", "deprecation", "TryWithIdenticalCatches"})
+  private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
+    GeneratedAppGlideModule result = null;
+    try {
+      Class<GeneratedAppGlideModule> clazz =
+          (Class<GeneratedAppGlideModule>)
+              Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
+      result = clazz.getDeclaredConstructor().newInstance();
+    } catch (ClassNotFoundException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
+            + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"
+            + " in your application and a @GlideModule annotated AppGlideModule implementation or"
+            + " LibraryGlideModules will be silently ignored");
+      }
+    // These exceptions can't be squashed across all versions of Android.
+    } catch (InstantiationException e) {
+      throwIncorrectGlideModule(e);
+    } catch (IllegalAccessException e) {
+      throwIncorrectGlideModule(e);
+    } catch (NoSuchMethodException e) {
+      throwIncorrectGlideModule(e);
+    } catch (InvocationTargetException e) {
+      throwIncorrectGlideModule(e);
+    }
+    return result;
+  }
+
+  private static void throwIncorrectGlideModule(Exception e) {
+    throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+        + " If you've manually implemented this class, remove your implementation. The Annotation"
+        + " processor will generate a correct implementation.", e);
+  }
+
+  Glide(
+      @NonNull Context context,
+      @NonNull Engine engine,
+      @NonNull MemoryCache memoryCache,
+      @NonNull BitmapPool bitmapPool,
+      @NonNull ArrayPool arrayPool,
+      @NonNull RequestManagerRetriever requestManagerRetriever,
+      @NonNull ConnectivityMonitorFactory connectivityMonitorFactory,
+      int logLevel,
+      @NonNull RequestOptions defaultRequestOptions,
+      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
+    this.arrayPool = arrayPool;
     this.memoryCache = memoryCache;
+    this.requestManagerRetriever = requestManagerRetriever;
+    this.connectivityMonitorFactory = connectivityMonitorFactory;
 
     DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
     bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
 
-    Resources resources = context.getResources();
-
-    Downsampler downsampler =
-        new Downsampler(resources.getDisplayMetrics(), bitmapPool, byteArrayPool);
-    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,
-        byteArrayPool);
-    registry = new Registry(context)
-        .register(ByteBuffer.class, new ByteBufferEncoder())
-        .register(InputStream.class, new StreamEncoder(byteArrayPool))
+    final Resources resources = context.getResources();
+
+    registry = new Registry();
+    registry.register(new DefaultImageHeaderParser());
+
+    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
+        resources.getDisplayMetrics(), bitmapPool, arrayPool);
+    ByteBufferGifDecoder byteBufferGifDecoder =
+        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+    ResourceDecoder<ParcelFileDescriptor, Bitmap> parcelFileDescriptorVideoDecoder =
+        VideoDecoder.parcel(bitmapPool);
+    ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
+    StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
+    ResourceDrawableDecoder resourceDrawableDecoder =
+        new ResourceDrawableDecoder(context);
+    ResourceLoader.StreamFactory resourceLoaderStreamFactory =
+        new ResourceLoader.StreamFactory(resources);
+    ResourceLoader.UriFactory resourceLoaderUriFactory =
+        new ResourceLoader.UriFactory(resources);
+    ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
+        new ResourceLoader.FileDescriptorFactory(resources);
+    ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory =
+        new ResourceLoader.AssetFileDescriptorFactory(resources);
+    BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);
+
+    BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();
+    GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();
+
+    ContentResolver contentResolver = context.getContentResolver();
+
+    registry
+        .append(ByteBuffer.class, new ByteBufferEncoder())
+        .append(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
-        .append(ByteBuffer.class, Bitmap.class,
-            new ByteBufferBitmapDecoder(downsampler))
-        .append(InputStream.class, Bitmap.class,
-            new StreamBitmapDecoder(downsampler, byteArrayPool))
-        .append(ParcelFileDescriptor.class, Bitmap.class, new VideoBitmapDecoder(bitmapPool))
-        .register(Bitmap.class, new BitmapEncoder())
-        /* GlideBitmapDrawables */
-        .append(ByteBuffer.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new ByteBufferBitmapDecoder(downsampler)))
-        .append(InputStream.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool,
-                new StreamBitmapDecoder(downsampler, byteArrayPool)))
-        .append(ParcelFileDescriptor.class, BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
-        .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
-        /* Gifs */
-        .prepend(InputStream.class, GifDrawable.class,
-            new StreamGifDecoder(byteBufferGifDecoder, byteArrayPool))
-        .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
-        .register(GifDrawable.class, new GifDrawableEncoder())
-        /* Gif Frames */
-        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
-        .append(GifDecoder.class, Bitmap.class, new GifFrameResourceDecoder(bitmapPool))
+        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)
+        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)
+        .append(
+            Registry.BUCKET_BITMAP,
+            ParcelFileDescriptor.class,
+            Bitmap.class,
+            parcelFileDescriptorVideoDecoder)
+        .append(
+            Registry.BUCKET_BITMAP,
+            AssetFileDescriptor.class,
+            Bitmap.class,
+            VideoDecoder.asset(bitmapPool))
+        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance())
+        .append(
+            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
+        .append(Bitmap.class, bitmapEncoder)
+        /* BitmapDrawables */
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ByteBuffer.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, byteBufferBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            InputStream.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, streamBitmapDecoder))
+        .append(
+            Registry.BUCKET_BITMAP_DRAWABLE,
+            ParcelFileDescriptor.class,
+            BitmapDrawable.class,
+            new BitmapDrawableDecoder<>(resources, parcelFileDescriptorVideoDecoder))
+        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))
+        /* GIFs */
+        .append(
+            Registry.BUCKET_GIF,
+            InputStream.class,
+            GifDrawable.class,
+            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
+        .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
+        .append(GifDrawable.class, new GifDrawableEncoder())
+        /* GIF Frames */
+        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
+        .append(
+            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.<GifDecoder>getInstance())
+        .append(
+            Registry.BUCKET_BITMAP,
+            GifDecoder.class,
+            Bitmap.class,
+            new GifFrameResourceDecoder(bitmapPool))
+        /* Drawables */
+        .append(Uri.class, Drawable.class, resourceDrawableDecoder)
+        .append(
+            Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool))
         /* Files */
         .register(new ByteBufferRewinder.Factory())
         .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
         .append(File.class, InputStream.class, new FileLoader.StreamFactory())
         .append(File.class, File.class, new FileDecoder())
         .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
-        .append(File.class, File.class, new UnitModelLoader.Factory<File>())
+        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
+        .append(File.class, File.class, UnitModelLoader.Factory.<File>getInstance())
         /* Models */
-        .register(new InputStreamRewinder.Factory(byteArrayPool))
-        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(int.class, ParcelFileDescriptor.class, new ResourceLoader.FileDescriptorFactory())
-        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(Integer.class, ParcelFileDescriptor.class,
-            new ResourceLoader.FileDescriptorFactory())
+        .register(new InputStreamRewinder.Factory(arrayPool))
+        .append(int.class, InputStream.class, resourceLoaderStreamFactory)
+        .append(
+            int.class,
+            ParcelFileDescriptor.class,
+            resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, InputStream.class, resourceLoaderStreamFactory)
+        .append(
+            Integer.class,
+            ParcelFileDescriptor.class,
+            resourceLoaderFileDescriptorFactory)
+        .append(Integer.class, Uri.class, resourceLoaderUriFactory)
+        .append(
+            int.class,
+            AssetFileDescriptor.class,
+            resourceLoaderAssetFileDescriptorFactory)
+        .append(
+            Integer.class,
+            AssetFileDescriptor.class,
+            resourceLoaderAssetFileDescriptorFactory)
+        .append(int.class, Uri.class, resourceLoaderUriFactory)
+        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory<String>())
+        .append(Uri.class, InputStream.class, new DataUrlLoader.StreamFactory<Uri>())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
+        .append(
+            String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
-        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new AssetUriLoader.FileDescriptorFactory())
-        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new UriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new UriLoader.FileDescriptorFactory())
+        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
+        .append(
+            Uri.class,
+            ParcelFileDescriptor.class,
+            new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
+        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
+        .append(
+            Uri.class,
+            InputStream.class,
+            new UriLoader.StreamFactory(contentResolver))
+        .append(
+            Uri.class,
+            ParcelFileDescriptor.class,
+             new UriLoader.FileDescriptorFactory(contentResolver))
+        .append(
+            Uri.class,
+            AssetFileDescriptor.class,
+            new UriLoader.AssetFileDescriptorFactory(contentResolver))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
-        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory())
+        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
         .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
         .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
         .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
+        .append(Uri.class, Uri.class, UnitModelLoader.Factory.<Uri>getInstance())
+        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance())
+        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder())
         /* Transcoders */
-        .register(Bitmap.class, BitmapDrawable.class,
-            new BitmapDrawableTranscoder(resources, bitmapPool))
-        .register(Bitmap.class, byte[].class, new BitmapBytesTranscoder())
-        .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
+        .register(
+            Bitmap.class,
+            BitmapDrawable.class,
+            new BitmapDrawableTranscoder(resources))
+        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)
+        .register(
+            Drawable.class,
+            byte[].class,
+            new DrawableBytesTranscoder(
+                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))
+        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);
 
     ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
-    glideContext = new GlideContext(context, registry, imageViewTargetFactory,
-        defaultRequestOptions, engine, this, logLevel);
+    glideContext =
+        new GlideContext(
+            context,
+            arrayPool,
+            registry,
+            imageViewTargetFactory,
+            defaultRequestOptions,
+            defaultTransitionOptions,
+            engine,
+            logLevel);
   }
 
   /**
@@ -268,14 +526,29 @@ static void tearDown() {
    * {@link com.bumptech.glide.load.Transformation}s. Use outside of these classes is not generally
    * recommended. </p>
    */
+  @NonNull
   public BitmapPool getBitmapPool() {
     return bitmapPool;
   }
 
-  public ByteArrayPool getByteArrayPool() {
-    return byteArrayPool;
+  @NonNull
+  public ArrayPool getArrayPool() {
+    return arrayPool;
+  }
+
+  /**
+   * @return The context associated with this instance.
+   */
+  @NonNull
+  public Context getContext() {
+    return glideContext.getBaseContext();
+  }
+
+  ConnectivityMonitorFactory getConnectivityMonitorFactory() {
+    return connectivityMonitorFactory;
   }
 
+  @NonNull
   GlideContext getGlideContext() {
     return glideContext;
   }
@@ -305,7 +578,8 @@ GlideContext getGlideContext() {
    * {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
    * individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
    */
-  public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
+  @SuppressWarnings("unused") // Public API
+  public void preFillBitmapPool(@NonNull PreFillType.Builder... bitmapAttributeBuilders) {
     bitmapPreFiller.preFill(bitmapAttributeBuilders);
   }
 
@@ -316,9 +590,12 @@ public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
    * @see android.content.ComponentCallbacks2#onLowMemory()
    */
   public void clearMemory() {
-    bitmapPool.clearMemory();
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be cleared before bitmap pool to clear re-pooled Bitmaps too. See #687.
     memoryCache.clearMemory();
-    byteArrayPool.clearMemory();
+    bitmapPool.clearMemory();
+    arrayPool.clearMemory();
   }
 
   /**
@@ -327,9 +604,12 @@ public void clearMemory() {
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
    */
   public void trimMemory(int level) {
-    bitmapPool.trimMemory(level);
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.trimMemory(level);
-    byteArrayPool.trimMemory(level);
+    bitmapPool.trimMemory(level);
+    arrayPool.trimMemory(level);
   }
 
   /**
@@ -339,11 +619,21 @@ public void trimMemory(int level) {
    *     This method should always be called on a background thread, since it is a blocking call.
    * </p>
    */
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public void clearDiskCache() {
     Util.assertBackgroundThread();
     engine.clearDiskCache();
   }
 
+  /**
+   * Internal method.
+   */
+  @NonNull
+  public RequestManagerRetriever getRequestManagerRetriever() {
+    return requestManagerRetriever;
+  }
+
   /**
    * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
    *
@@ -353,10 +643,32 @@ public void clearDiskCache() {
    * used to temporarily increase or decrease memory usage for a single Activity or part of the app.
    * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want
    * to change the default. </p>
+   *
+   * @return the previous MemoryCategory used by Glide.
    */
-  public void setMemoryCategory(MemoryCategory memoryCategory) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public MemoryCategory setMemoryCategory(@NonNull MemoryCategory memoryCategory) {
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.setSizeMultiplier(memoryCategory.getMultiplier());
     bitmapPool.setSizeMultiplier(memoryCategory.getMultiplier());
+    MemoryCategory oldCategory = this.memoryCategory;
+    this.memoryCategory = memoryCategory;
+    return oldCategory;
+  }
+
+  @NonNull
+  private static RequestManagerRetriever getRetriever(@Nullable Context context) {
+    // Context could be null for other reasons (ie the user passes in null), but in practice it will
+    // only occur due to errors with the Fragment lifecycle.
+    Preconditions.checkNotNull(
+        context,
+        "You cannot start a load on a not yet attached View or a Fragment where getActivity() "
+            + "returns null (which usually occurs when getActivity() is called before the Fragment "
+            + "is attached or after the Fragment is destroyed).");
+    return Glide.get(context).getRequestManagerRetriever();
   }
 
   /**
@@ -381,9 +693,9 @@ public void setMemoryCategory(MemoryCategory memoryCategory) {
    * @see #with(android.support.v4.app.Fragment)
    * @see #with(android.support.v4.app.FragmentActivity)
    */
-  public static RequestManager with(Context context) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(context);
+  @NonNull
+  public static RequestManager with(@NonNull Context context) {
+    return getRetriever(context).get(context);
   }
 
   /**
@@ -393,9 +705,9 @@ public static RequestManager with(Context context) {
    * @param activity The activity to use.
    * @return A RequestManager for the given activity that can be used to start a load.
    */
-  public static RequestManager with(Activity activity) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(activity);
+  @NonNull
+  public static RequestManager with(@NonNull Activity activity) {
+    return getRetriever(activity).get(activity);
   }
 
   /**
@@ -406,50 +718,86 @@ public static RequestManager with(Activity activity) {
    * @param activity The activity to use.
    * @return A RequestManager for the given FragmentActivity that can be used to start a load.
    */
-  public static RequestManager with(FragmentActivity activity) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(activity);
+  @NonNull
+  public static RequestManager with(@NonNull FragmentActivity activity) {
+    return getRetriever(activity).get(activity);
   }
 
   /**
-   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle
-   * and that uses the given {@link android.app.Fragment}'s default options.
+   * Begin a load with Glide that will be tied to the given
+   * {@link android.support.v4.app.Fragment}'s lifecycle and that uses the given
+   * {@link android.support.v4.app.Fragment}'s default options.
    *
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  public static RequestManager with(android.app.Fragment fragment) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(fragment);
+  @NonNull
+  public static RequestManager with(@NonNull Fragment fragment) {
+    return getRetriever(fragment.getActivity()).get(fragment);
   }
 
   /**
-   * Begin a load with Glide that will be tied to the given
-   * {@link android.support.v4.app.Fragment}'s lifecycle and that uses the given
-   * {@link android.support.v4.app.Fragment}'s default options.
+   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle
+   * and that uses the given {@link android.app.Fragment}'s default options.
    *
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
+   * @deprecated Prefer support Fragments and {@link #with(Fragment)} instead,
+   * {@link android.app.Fragment} will be deprecated. See
+   * https://github.com/android/android-ktx/pull/161#issuecomment-363270555.
    */
-  public static RequestManager with(Fragment fragment) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(fragment);
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @NonNull
+  public static RequestManager with(@NonNull android.app.Fragment fragment) {
+    return getRetriever(fragment.getActivity()).get(fragment);
   }
 
+  /**
+   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},
+   * {@link android.app.Fragment}, or {@link Activity} that contains the View.
+   *
+   * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View
+   * is a child of the View returned by the {@link Fragment#getView()}} method.
+   *
+   * <p>This method will not work if the View is not attached. Prefer the Activity and Fragment
+   * variants unless you're loading in a View subclass.
+   *
+   * <p>This method may be inefficient aways and is definitely inefficient for large hierarchies.
+   * Consider memoizing the result after the View is attached or again, prefer the Activity and
+   * Fragment variants whenever possible.
+   *
+   * <p>When used in Applications that use the non-support {@link android.app.Fragment} classes,
+   * calling this method will produce noisy logs from {@link android.app.FragmentManager}. Consider
+   * avoiding entirely or using the {@link Fragment}s from the support library instead.
+   *
+   * <p>If the support {@link FragmentActivity} class is used, this method will only attempt to
+   * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached
+   * to the {@link FragmentActivity} will be ignored.
+   *
+   * @param view The view to search for a containing Fragment or Activity from.
+   * @return A RequestManager that can be used to start a load.
+   */
+  @NonNull
+  public static RequestManager with(@NonNull View view) {
+    return getRetriever(view.getContext()).get(view);
+  }
+
+  @NonNull
   public Registry getRegistry() {
     return registry;
   }
 
-  void removeFromManagers(Target<?> target) {
+  boolean removeFromManagers(@NonNull Target<?> target) {
     synchronized (managers) {
       for (RequestManager requestManager : managers) {
         if (requestManager.untrack(target)) {
-          return;
+          return true;
         }
       }
     }
-    throw new IllegalStateException("Failed to remove target from managers");
+
+    return false;
   }
 
   void registerRequestManager(RequestManager requestManager) {
@@ -464,7 +812,7 @@ void registerRequestManager(RequestManager requestManager) {
   void unregisterRequestManager(RequestManager requestManager) {
     synchronized (managers) {
       if (!managers.contains(requestManager)) {
-        throw new IllegalStateException("Cannot register not yet registered manager");
+        throw new IllegalStateException("Cannot unregister not yet registered manager");
       }
       managers.remove(requestManager);
     }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 5f29cad0e..431eddae8 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -1,44 +1,52 @@
 package com.bumptech.glide;
 
 import android.content.Context;
-import android.os.Build;
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.util.ArrayMap;
 import android.util.Log;
-
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.InternalCacheDiskCacheFactory;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.cache.MemorySizeCalculator;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
+import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;
 import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+import java.util.Map;
 
 /**
  * A builder class for setting default structural classes for Glide to use.
  */
 public final class GlideBuilder {
-  private final Context context;
-
+  private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions = new ArrayMap<>();
   private Engine engine;
   private BitmapPool bitmapPool;
-  private ByteArrayPool byteArrayPool;
+  private ArrayPool arrayPool;
   private MemoryCache memoryCache;
   private GlideExecutor sourceExecutor;
   private GlideExecutor diskCacheExecutor;
   private DiskCache.Factory diskCacheFactory;
   private MemorySizeCalculator memorySizeCalculator;
+  private ConnectivityMonitorFactory connectivityMonitorFactory;
   private int logLevel = Log.INFO;
   private RequestOptions defaultRequestOptions = new RequestOptions();
-
-  GlideBuilder(Context context) {
-    this.context = context.getApplicationContext();
-  }
+  @Nullable
+  private RequestManagerFactory requestManagerFactory;
+  private GlideExecutor animationExecutor;
+  private boolean isActiveResourceRetentionAllowed;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -47,20 +55,22 @@
    * @param bitmapPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
+  @NonNull
+  public GlideBuilder setBitmapPool(@Nullable BitmapPool bitmapPool) {
     this.bitmapPool = bitmapPool;
     return this;
   }
 
   /**
-   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored
+   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored
    * and retrieved as needed.
    *
-   * @param byteArrayPool The pool to use.
+   * @param arrayPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setByteArrayPool(ByteArrayPool byteArrayPool) {
-    this.byteArrayPool = byteArrayPool;
+  @NonNull
+  public GlideBuilder setArrayPool(@Nullable ArrayPool arrayPool) {
+    this.arrayPool = arrayPool;
     return this;
   }
 
@@ -71,7 +81,10 @@ public GlideBuilder setByteArrayPool(ByteArrayPool byteArrayPool) {
    * @param memoryCache The cache to use.
    * @return This builder.
    */
-  public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setMemoryCache(@Nullable MemoryCache memoryCache) {
     this.memoryCache = memoryCache;
     return this;
   }
@@ -86,6 +99,8 @@ public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
    * use {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead.
    * Scheduled to be removed in Glide 4.0.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   @Deprecated
   public GlideBuilder setDiskCache(final DiskCache diskCache) {
     return setDiskCache(new DiskCache.Factory() {
@@ -104,60 +119,143 @@ public DiskCache build() {
    * @param diskCacheFactory The disk cache factory to use.
    * @return This builder.
    */
-  public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setDiskCache(@Nullable DiskCache.Factory diskCacheFactory) {
     this.diskCacheFactory = diskCacheFactory;
     return this;
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
+   * Sets the {@link GlideExecutor} to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
+   *
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
+   *
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
+   *
+   * @param service The ExecutorService to use.
+   * @return This builder.
+   * @see #setDiskCacheExecutor(GlideExecutor)
+   * @see GlideExecutor
+   *
+   * @deprecated Use {@link #setSourceExecutor(GlideExecutor)}
+   */
+  @Deprecated
+  public GlideBuilder setResizeExecutor(@Nullable GlideExecutor service) {
+    return setSourceExecutor(service);
+  }
+
+  /**
+   * Sets the {@link GlideExecutor} to use when retrieving
    * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>The thread count defaults to the number of cores available on the device, with a maximum of
+   * 4.
+   *
+   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options
+   * for the source executor.
    *
    * @param service The ExecutorService to use.
    * @return This builder.
    * @see #setDiskCacheExecutor(GlideExecutor)
    * @see GlideExecutor
    */
-  public GlideBuilder setResizeExecutor(GlideExecutor service) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setSourceExecutor(@Nullable GlideExecutor service) {
     this.sourceExecutor = service;
     return this;
   }
 
   /**
-   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
-   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
+   * Sets the {@link GlideExecutor} to use when retrieving
+   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in Glide's disk caches.
    *
-   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
-   * for thumbnail requests to work properly.
+   * <p>Defaults to a single thread which is usually the best combination of memory usage,
+   * jank, and performance, even on high end devices.
    *
-   * @param service The ExecutorService to use.
+   * <p>Use the {@link GlideExecutor#newDiskCacheExecutor()} if you'd like to specify options
+   * for the disk cache executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
    * @return This builder.
-   * @see #setResizeExecutor(GlideExecutor)
+   * @see #setSourceExecutor(GlideExecutor)
    * @see GlideExecutor
    */
-  public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setDiskCacheExecutor(@Nullable GlideExecutor service) {
     this.diskCacheExecutor = service;
     return this;
   }
 
+  /**
+   * Sets the {@link GlideExecutor} to use when loading frames of animated images and particularly
+   * of {@link com.bumptech.glide.load.resource.gif.GifDrawable}s.
+   *
+   * <p>Defaults to one or two threads, depending on the number of cores available.
+   *
+   * <p>Use the {@link GlideExecutor#newAnimationExecutor()} methods  if you'd like to specify
+   * options for the animation executor.
+   *
+   * @param service The {@link GlideExecutor} to use.
+   * @return This builder.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setAnimationExecutor(@Nullable GlideExecutor service) {
+    this.animationExecutor = service;
+    return this;
+  }
+
   /**
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
    * <p>Applying additional options with {@link
-   * RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions)} will override defaults
+   * RequestBuilder#apply(RequestOptions)} will override defaults
    * set here.
    *
    * @param requestOptions The options to use by default.
    * @return This builder.
    */
-  public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
+  @NonNull
+  public GlideBuilder setDefaultRequestOptions(@Nullable RequestOptions requestOptions) {
     this.defaultRequestOptions = requestOptions;
     return this;
   }
 
+  /**
+   * Sets the default {@link TransitionOptions} to use when starting a request that will load a
+   * resource with the given {@link Class}.
+   *
+   * <p>It's preferable but not required for the requested resource class to match the resource
+   * class applied here as long as the resource class applied here is assignable from the requested
+   * resource class. For example you can set a default transition for
+   * {@link android.graphics.drawable.Drawable} and that default transition will be used if you
+   * subsequently start requests for specific {@link android.graphics.drawable.Drawable} types like
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} or
+   * {@link android.graphics.drawable.BitmapDrawable}. Specific types are always preferred so if you
+   * register a default transition for both {@link android.graphics.drawable.Drawable} and
+   * {@link android.graphics.drawable.BitmapDrawable} and then start a request for
+   * {@link android.graphics.drawable.BitmapDrawable}s, the transition you registered for
+   * {@link android.graphics.drawable.BitmapDrawable}s will be used.
+   */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public <T> GlideBuilder setDefaultTransitionOptions(
+      @NonNull Class<T> clazz, @Nullable TransitionOptions<?, T> options) {
+    defaultTransitionOptions.put(clazz, options);
+    return this;
+  }
+
   /**
    * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all
    * the default decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link
@@ -171,9 +269,11 @@ public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
    *
    * @deprecated Use {@link #setDefaultRequestOptions(RequestOptions)} instead.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   @Deprecated
   public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
-    defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));
+    defaultRequestOptions = defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));
     return this;
   }
 
@@ -186,7 +286,10 @@ public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
    * @param builder The builder to use (will not be modified).
    * @return This builder.
    */
-  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator.Builder builder) {
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public GlideBuilder setMemorySizeCalculator(@NonNull MemorySizeCalculator.Builder builder) {
     return setMemorySizeCalculator(builder.build());
   }
 
@@ -200,11 +303,30 @@ public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator.Builder builder
    * @param calculator The calculator to use.
    * @return This builder.
    */
-  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  public GlideBuilder setMemorySizeCalculator(@Nullable MemorySizeCalculator calculator) {
     this.memorySizeCalculator = calculator;
     return this;
   }
 
+  /**
+   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory}
+   * to use to notify {@link com.bumptech.glide.RequestManager} of connectivity events.
+   * If not set {@link com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used.
+   *
+   * @param factory The factory to use
+   * @return This builder.
+   */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public GlideBuilder setConnectivityMonitorFactory(@Nullable ConnectivityMonitorFactory factory) {
+    this.connectivityMonitorFactory = factory;
+    return this;
+  }
+
   /**
    * Sets a log level constant from those in {@link Log} to indicate the desired log verbosity.
    *
@@ -230,6 +352,9 @@ public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
    * @param logLevel The log level to use from {@link Log}.
    * @return This builder.
    */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
   public GlideBuilder setLogLevel(int logLevel) {
     if (logLevel < Log.VERBOSE || logLevel > Log.ERROR) {
       throw new IllegalArgumentException("Log level must be one of Log.VERBOSE, Log.DEBUG,"
@@ -239,36 +364,101 @@ public GlideBuilder setLogLevel(int logLevel) {
     return this;
   }
 
+  /**
+   * If set to {@code true}, allows Glide to re-capture resources that are loaded into
+   * {@link com.bumptech.glide.request.target.Target}s which are subsequently de-referenced and
+   * garbage collected without being cleared.
+   *
+   * <p>Defaults to {@code false}.
+   *
+   * <p>Glide's resource re-use system is permissive, which means that's acceptable for callers to
+   * load resources into {@link com.bumptech.glide.request.target.Target}s and then never clear the
+   * {@link com.bumptech.glide.request.target.Target}. To do so, Glide uses
+   * {@link java.lang.ref.WeakReference}s to track resources that belong to
+   * {@link com.bumptech.glide.request.target.Target}s that haven't yet been cleared. Setting
+   * this method to {@code true} allows Glide to also maintain a hard reference to the underlying
+   * resource so that if the {@link com.bumptech.glide.request.target.Target} is garbage collected,
+   * Glide can return the underlying resource to it's memory cache so that subsequent requests will
+   * not unexpectedly re-load the resource from disk or source. As a side affect, it will take
+   * the system slightly longer to garbage collect the underlying resource because the weak
+   * reference has to be cleared and processed before the hard reference is removed. As a result,
+   * setting this method to {@code true} may transiently increase the memory usage of an
+   * application.
+   *
+   * <p>Leaving this method at the default {@code false} value will allow the platform to garbage
+   * collect resources more quickly, but will lead to unexpected memory cache misses if callers load
+   * resources into {@link com.bumptech.glide.request.target.Target}s but never clear them.
+   *
+   * <p>If you set this method to {@code true} you <em>must not</em> call
+   * {@link Bitmap#recycle()} or mutate any Bitmaps returned by Glide. If this method is set to
+   * {@code false}, recycling or mutating Bitmaps is inefficient but safe as long as you do not
+   * clear the corresponding {@link com.bumptech.glide.request.target.Target} used to load the
+   * {@link Bitmap}. However, if you set this method to {@code true} and recycle or mutate any
+   * returned {@link Bitmap}s or other mutable resources, Glide may recover those resources and
+   * attempt to use them later on, resulting in crashes, graphical corruption or undefined behavior.
+   *
+   * <p>Regardless of what value this method is set to, it's always good practice to clear
+   * {@link com.bumptech.glide.request.target.Target}s when you're done with the corresponding
+   * resource. Clearing {@link com.bumptech.glide.request.target.Target}s allows Glide to maximize
+   * resource re-use, minimize memory overhead and minimize unexpected behavior resulting from
+   * edge cases. If you use {@link RequestManager#clear(Target)}, calling {@link Bitmap#recycle()}
+   * or mutating {@link Bitmap}s is not only unsafe, it's also totally unnecessary and should be
+   * avoided. In all cases, prefer {@link RequestManager#clear(Target)} to {@link Bitmap#recycle()}.
+   *
+   * @return This builder.
+   */
+  // Public API.
+  @SuppressWarnings("unused")
+  @NonNull
+  public GlideBuilder setIsActiveResourceRetentionAllowed(
+      boolean isActiveResourceRetentionAllowed) {
+    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
+    return this;
+  }
+
+  void setRequestManagerFactory(@Nullable RequestManagerFactory factory) {
+    this.requestManagerFactory = factory;
+  }
+
   // For testing.
   GlideBuilder setEngine(Engine engine) {
     this.engine = engine;
     return this;
   }
 
-  Glide createGlide() {
+  @NonNull
+  Glide build(@NonNull Context context) {
     if (sourceExecutor == null) {
-      final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());
-      sourceExecutor = new GlideExecutor("source", cores);
+      sourceExecutor = GlideExecutor.newSourceExecutor();
     }
+
     if (diskCacheExecutor == null) {
-      diskCacheExecutor = new GlideExecutor("disk-cache", 1);
+      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
+    }
+
+    if (animationExecutor == null) {
+      animationExecutor = GlideExecutor.newAnimationExecutor();
     }
 
     if (memorySizeCalculator == null) {
       memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
     }
 
+    if (connectivityMonitorFactory == null) {
+      connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();
+    }
+
     if (bitmapPool == null) {
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-        int size = memorySizeCalculator.getBitmapPoolSize();
+      int size = memorySizeCalculator.getBitmapPoolSize();
+      if (size > 0) {
         bitmapPool = new LruBitmapPool(size);
       } else {
         bitmapPool = new BitmapPoolAdapter();
       }
     }
 
-    if (byteArrayPool == null) {
-      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());
+    if (arrayPool == null) {
+      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
     }
 
     if (memoryCache == null) {
@@ -280,10 +470,30 @@ Glide createGlide() {
     }
 
     if (engine == null) {
-      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor);
+      engine =
+          new Engine(
+              memoryCache,
+              diskCacheFactory,
+              diskCacheExecutor,
+              sourceExecutor,
+              GlideExecutor.newUnlimitedSourceExecutor(),
+              GlideExecutor.newAnimationExecutor(),
+              isActiveResourceRetentionAllowed);
     }
 
-    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, logLevel,
-        defaultRequestOptions.lock());
+    RequestManagerRetriever requestManagerRetriever =
+        new RequestManagerRetriever(requestManagerFactory);
+
+    return new Glide(
+        context,
+        engine,
+        memoryCache,
+        bitmapPool,
+        arrayPool,
+        requestManagerRetriever,
+        connectivityMonitorFactory,
+        logLevel,
+        defaultRequestOptions.lock(),
+        defaultTransitionOptions);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index 2753b6503..eeb98cc5f 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -1,43 +1,53 @@
 package com.bumptech.glide;
 
-import android.annotation.TargetApi;
-import android.content.ComponentCallbacks2;
 import android.content.Context;
 import android.content.ContextWrapper;
-import android.content.res.Configuration;
-import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
-import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.target.ViewTarget;
+import java.util.Map;
+import java.util.Map.Entry;
 
 /**
  * Global context for all loads in Glide containing and exposing the various registries and classes
  * required to load resources.
  */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-public class GlideContext extends ContextWrapper implements ComponentCallbacks2 {
+public class GlideContext extends ContextWrapper {
+  @VisibleForTesting
+  static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =
+      new GenericTransitionOptions<>();
   private final Handler mainHandler;
+  private final ArrayPool arrayPool;
   private final Registry registry;
   private final ImageViewTargetFactory imageViewTargetFactory;
   private final RequestOptions defaultRequestOptions;
+  private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions;
   private final Engine engine;
-  private final ComponentCallbacks2 componentCallbacks;
   private final int logLevel;
 
-  public GlideContext(Context context, Registry registry,
-      ImageViewTargetFactory imageViewTargetFactory, RequestOptions defaultRequestOptions,
-      Engine engine, ComponentCallbacks2 componentCallbacks, int logLevel) {
+  public GlideContext(
+      @NonNull Context context,
+      @NonNull ArrayPool arrayPool,
+      @NonNull Registry registry,
+      @NonNull ImageViewTargetFactory imageViewTargetFactory,
+      @NonNull RequestOptions defaultRequestOptions,
+      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
+      @NonNull Engine engine,
+      int logLevel) {
     super(context.getApplicationContext());
+    this.arrayPool = arrayPool;
     this.registry = registry;
     this.imageViewTargetFactory = imageViewTargetFactory;
     this.defaultRequestOptions = defaultRequestOptions;
+    this.defaultTransitionOptions = defaultTransitionOptions;
     this.engine = engine;
-    this.componentCallbacks = componentCallbacks;
     this.logLevel = logLevel;
 
     mainHandler = new Handler(Looper.getMainLooper());
@@ -47,18 +57,40 @@ public RequestOptions getDefaultRequestOptions() {
     return defaultRequestOptions;
   }
 
-  public <X> Target<X> buildImageViewTarget(ImageView imageView, Class<X> transcodeClass) {
+  @SuppressWarnings("unchecked")
+  @NonNull
+  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(@NonNull Class<T> transcodeClass) {
+    TransitionOptions<?, ?> result = defaultTransitionOptions.get(transcodeClass);
+    if (result == null) {
+      for (Entry<Class<?>, TransitionOptions<?, ?>> value : defaultTransitionOptions.entrySet()) {
+        if (value.getKey().isAssignableFrom(transcodeClass)) {
+          result = value.getValue();
+        }
+      }
+    }
+    if (result == null) {
+      result = DEFAULT_TRANSITION_OPTIONS;
+    }
+    return (TransitionOptions<?, T>) result;
+  }
+
+  @NonNull
+  public <X> ViewTarget<ImageView, X> buildImageViewTarget(
+      @NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
     return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
   }
 
+  @NonNull
   public Handler getMainHandler() {
     return mainHandler;
   }
 
+  @NonNull
   public Engine getEngine() {
     return engine;
   }
 
+  @NonNull
   public Registry getRegistry() {
     return registry;
   }
@@ -67,18 +99,8 @@ public int getLogLevel() {
     return logLevel;
   }
 
-  @Override
-  public void onTrimMemory(int level) {
-    componentCallbacks.onTrimMemory(level);
-  }
-
-  @Override
-  public void onConfigurationChanged(Configuration newConfig) {
-    componentCallbacks.onConfigurationChanged(newConfig);
-  }
-
-  @Override
-  public void onLowMemory() {
-    componentCallbacks.onLowMemory();
+  @NonNull
+  public ArrayPool getArrayPool() {
+    return arrayPool;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index fba351ea0..a6f5835f8 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -1,16 +1,13 @@
 package com.bumptech.glide;
 
-import android.app.Activity;
-import android.app.Fragment;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.v4.app.FragmentActivity;
 import android.widget.AbsListView;
-
 import com.bumptech.glide.request.target.BaseTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.util.List;
 import java.util.Queue;
 
@@ -28,7 +25,6 @@
  * @param <T> The type of the model being displayed in the list.
  */
 public class ListPreloader<T> implements AbsListView.OnScrollListener {
-
   private final int maxPreload;
   private final PreloadTargetQueue preloadTargetQueue;
   private final RequestManager requestManager;
@@ -51,25 +47,45 @@
   public interface PreloadModelProvider<U> {
 
     /**
-     * Returns a non null list of all models that need to be loaded for the list to display adapter
-     * items in positions between {@code start} and {@code end}.
+     * Returns a {@link List} of models that need to be loaded for the list to display adapter items
+     * in positions between {@code start} and {@code end}.
+     *
+     * <p>A list of any size can be returned so there can be multiple models per adapter position.
      *
-     * <p> A list of any size can be returned so there can be multiple models per adapter position.
-     * </p>
+     * <p>Every model returned by this method is expected to produce a valid {@link RequestBuilder}
+     * in {@link #getPreloadRequestBuilder(Object)}. If that's not possible for any set of models,
+     * avoid including them in the {@link List} returned by this method.
+     *
+     * <p>Although it's acceptable for the returned {@link List} to contain {@code null} models,
+     * it's best to filter them from the list instead of adding {@code null} to avoid unnecessary
+     * logic and expanding the size of the {@link List}
      *
      * @param position The adapter position.
      */
+    @NonNull
     List<U> getPreloadItems(int position);
 
     /**
-     * Returns a non null {@link RequestBuilder} for a given item. Must exactly match the request
-     * used to load the resource in the list.
+     * Returns a {@link RequestBuilder} for a given item on which
+     * {@link RequestBuilder#load(Object)}} has been called or {@code null} if no valid load can be
+     * started.
+     *
+     * <p>For the preloader to be effective, the {@link RequestBuilder} returned here must use
+     * exactly the same size and set of options as the {@link RequestBuilder} used when the ``View``
+     * is bound. You may need to specify a size in both places to ensure that the width and height
+     * match exactly. If so, you can use
+     * {@link com.bumptech.glide.request.RequestOptions#override(int, int)} to do so.
      *
-     * <p> The target and context will be provided by the preloader. </p>
+     * <p>The target and context will be provided by the preloader.
+     *
+     * <p>If {@link RequestBuilder#load(Object)} is not called by this method, the preloader will
+     * trigger a {@link RuntimeException}. If you don't want to load a particular item or position,
+     * filter it from the list returned by {@link #getPreloadItems(int)}.
      *
      * @param item The model to load.
      */
-    RequestBuilder getPreloadRequestBuilder(U item);
+    @Nullable
+    RequestBuilder<?> getPreloadRequestBuilder(@NonNull U item);
   }
 
   /**
@@ -84,48 +100,14 @@
      * Returns the size of the view in the list where the resources will be displayed in pixels in
      * the format [x, y], or {@code null} if no size is currently available.
      *
-     * <p> Note - The dimensions returned here must precisely match those of the view in the list.
-     * </p>
+     * <p>Note - The dimensions returned here must precisely match those of the view in the list.
+     *
+     * <p>If this method returns {@code null}, then no request will be started for the given item.
      *
      * @param item A model
      */
     @Nullable
-    int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link Activity}.
-   */
-  public ListPreloader(Activity activity, PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
-    this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link FragmentActivity}.
-   */
-  public ListPreloader(FragmentActivity fragmentActivity,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link Fragment}.
-   */
-  public ListPreloader(Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
-   */
-  public ListPreloader(android.support.v4.app.Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
+    int[] getPreloadSize(@NonNull T item, int adapterPosition, int perItemPosition);
   }
 
   /**
@@ -137,8 +119,9 @@ public ListPreloader(android.support.v4.app.Fragment fragment,
    * @param preloadDimensionProvider Provides the dimensions of images to load.
    * @param maxPreload               Maximum number of items to preload.
    */
-  public ListPreloader(RequestManager requestManager, PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
+  public ListPreloader(@NonNull RequestManager requestManager,
+      @NonNull PreloadModelProvider<T> preloadModelProvider,
+      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
     this.requestManager = requestManager;
     this.preloadModelProvider = preloadModelProvider;
     this.preloadDimensionProvider = preloadDimensionProvider;
@@ -187,12 +170,12 @@ private void preload(int from, int to) {
     if (from < to) {
       // Increasing
       for (int i = start; i < end; i++) {
-        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, true);
+        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, true);
       }
     } else {
       // Decreasing
       for (int i = end - 1; i >= start; i--) {
-        preloadAdapterPosition(this.preloadModelProvider.getPreloadItems(i), i, false);
+        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, false);
       }
     }
 
@@ -214,13 +197,22 @@ private void preloadAdapterPosition(List<T> items, int position, boolean isIncre
   }
 
   @SuppressWarnings("unchecked")
-  private void preloadItem(T item, int position, int i) {
-    final int[] dimensions = this.preloadDimensionProvider.getPreloadSize(item, position, i);
-    if (dimensions != null) {
-      RequestBuilder preloadRequestBuilder =
-          this.preloadModelProvider.getPreloadRequestBuilder(item);
-      preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
+  private void preloadItem(@Nullable T item, int position, int perItemPosition) {
+    if (item == null) {
+      return;
+    }
+    int[] dimensions =
+        preloadDimensionProvider.getPreloadSize(item, position, perItemPosition);
+    if (dimensions == null) {
+      return;
     }
+    RequestBuilder<Object> preloadRequestBuilder =
+        (RequestBuilder<Object>) preloadModelProvider.getPreloadRequestBuilder(item);
+    if (preloadRequestBuilder == null) {
+      return;
+    }
+
+    preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
   }
 
   private void cancelAll() {
@@ -232,7 +224,9 @@ private void cancelAll() {
   private static final class PreloadTargetQueue {
     private final Queue<PreloadTarget> queue;
 
-    public PreloadTargetQueue(int size) {
+    // The loop is short and the only point is to create the objects.
+    @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+    PreloadTargetQueue(int size) {
       queue = Util.createQueue(size);
 
       for (int i = 0; i < size; i++) {
@@ -249,18 +243,27 @@ public PreloadTarget next(int width, int height) {
     }
   }
 
-  private static class PreloadTarget extends BaseTarget<Object> {
-    private int photoHeight;
-    private int photoWidth;
+  private static final class PreloadTarget extends BaseTarget<Object> {
+    @Synthetic int photoHeight;
+    @Synthetic int photoWidth;
+
+    @Synthetic
+    PreloadTarget() { }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
       // Do nothing.
     }
 
     @Override
-    public void getSize(SizeReadyCallback cb) {
+    public void getSize(@NonNull SizeReadyCallback cb) {
       cb.onSizeReady(photoWidth, photoHeight);
     }
+
+    @Override
+    public void removeCallback(@NonNull SizeReadyCallback cb) {
+      // Do nothing because we don't retain references to SizeReadyCallbacks.
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/MemoryCategory.java b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
index a5781f62d..af84e0454 100644
--- a/library/src/main/java/com/bumptech/glide/MemoryCategory.java
+++ b/library/src/main/java/com/bumptech/glide/MemoryCategory.java
@@ -18,7 +18,7 @@
    */
   HIGH(1.5f);
 
-  private float multiplier;
+  private final float multiplier;
 
   MemoryCategory(float multiplier) {
     this.multiplier = multiplier;
diff --git a/library/src/main/java/com/bumptech/glide/ModelTypes.java b/library/src/main/java/com/bumptech/glide/ModelTypes.java
new file mode 100644
index 000000000..42a14053e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/ModelTypes.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Ensures that the set of explicitly supported model types remains consistent across Glide's
+ * API surface.
+ */
+interface ModelTypes<T> {
+  @NonNull
+  @CheckResult
+  T load(@Nullable Bitmap bitmap);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable Drawable drawable);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable String string);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable Uri uri);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable File file);
+
+  @NonNull
+  @CheckResult
+  T load(@RawRes @DrawableRes @Nullable Integer resourceId);
+
+  @Deprecated
+  @CheckResult
+  T load(@Nullable URL url);
+
+  @NonNull
+  @CheckResult
+  T load(@Nullable byte[] model);
+
+  @NonNull
+  @CheckResult
+  @SuppressWarnings("unchecked")
+  T load(@Nullable Object model);
+}
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index dea54a6b9..62f135d7d 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -1,9 +1,11 @@
 package com.bumptech.glide;
 
-import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.data.DataRewinder;
@@ -17,115 +19,464 @@
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.load.resource.transcode.TranscoderRegistry;
 import com.bumptech.glide.provider.EncoderRegistry;
+import com.bumptech.glide.provider.ImageHeaderParserRegistry;
 import com.bumptech.glide.provider.LoadPathCache;
 import com.bumptech.glide.provider.ModelToResourceClassCache;
 import com.bumptech.glide.provider.ResourceDecoderRegistry;
 import com.bumptech.glide.provider.ResourceEncoderRegistry;
 import com.bumptech.glide.util.pool.FactoryPools;
-
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 /**
- * Manages component registration.
+ * Manages component registration to extend or replace Glide's default loading, decoding, and
+ * encoding logic.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public class Registry {
+  public static final String BUCKET_GIF = "Gif";
+  public static final String BUCKET_BITMAP = "Bitmap";
+  public static final String BUCKET_BITMAP_DRAWABLE = "BitmapDrawable";
+  private static final String BUCKET_PREPEND_ALL = "legacy_prepend_all";
+  private static final String BUCKET_APPEND_ALL = "legacy_append";
+
   private final ModelLoaderRegistry modelLoaderRegistry;
   private final EncoderRegistry encoderRegistry;
   private final ResourceDecoderRegistry decoderRegistry;
   private final ResourceEncoderRegistry resourceEncoderRegistry;
   private final DataRewinderRegistry dataRewinderRegistry;
   private final TranscoderRegistry transcoderRegistry;
+  private final ImageHeaderParserRegistry imageHeaderParserRegistry;
 
   private final ModelToResourceClassCache modelToResourceClassCache =
       new ModelToResourceClassCache();
   private final LoadPathCache loadPathCache = new LoadPathCache();
-  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();
+  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();
 
-  public Registry(Context context) {
-    this.modelLoaderRegistry =
-        new ModelLoaderRegistry(context.getApplicationContext(), exceptionListPool);
+  public Registry() {
+    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);
     this.encoderRegistry = new EncoderRegistry();
     this.decoderRegistry = new ResourceDecoderRegistry();
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
     this.dataRewinderRegistry = new DataRewinderRegistry();
     this.transcoderRegistry = new TranscoderRegistry();
+    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();
+    setResourceDecoderBucketPriorityList(
+        Arrays.asList(BUCKET_GIF, BUCKET_BITMAP, BUCKET_BITMAP_DRAWABLE));
+  }
+
+  /**
+   * Registers the given {@link Encoder} for the given data class (InputStream, FileDescriptor etc).
+   *
+   * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
+   * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
+   * {@link Encoder} being used for
+   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
+   * {@link java.io.FileInputStream} and any other subclass.
+   *
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
+   * {@link Encoder} that is registered first will be used.
+   *
+   * @deprecated Use the equivalent {@link #append(Class, Class, ModelLoaderFactory)} method
+   * instead.
+   */
+  @NonNull
+  @Deprecated
+  public <Data> Registry register(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
+    return append(dataClass, encoder);
   }
 
-  public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
-    encoderRegistry.add(dataClass, encoder);
+  /**
+   * Appends the given {@link Encoder} onto the list of available {@link Encoder}s so that it is
+   * attempted after all earlier and default {@link Encoder}s for the given data class.
+   *
+   * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
+   * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
+   * {@link Encoder} being used for
+   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
+   * {@link java.io.FileInputStream} and any other subclass.
+   *
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
+   * {@link Encoder} that is registered first will be used.
+   *
+   * @see #prepend(Class, Encoder)
+   */
+  @NonNull
+  public <Data> Registry append(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
+    encoderRegistry.append(dataClass, encoder);
     return this;
   }
 
-  public <Data, TResource> Registry append(Class<Data> dataClass, Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
-    decoderRegistry.append(decoder, dataClass, resourceClass);
+  /**
+   * Prepends the given {@link Encoder} into the list of available {@link Encoder}s
+   * so that it is attempted before all later and default {@link Encoder}s for the given
+   * data class.
+   *
+   * <p>This method allows you to replace the default {@link Encoder} because it ensures
+   * the registered {@link Encoder} will run first. If multiple {@link Encoder}s are registered for
+   * the same type or super type, the {@link Encoder} that is registered first will be used.
+   *
+   * @see #append(Class, Encoder)
+   */
+  @NonNull
+  public <Data> Registry prepend(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {
+    encoderRegistry.prepend(dataClass, encoder);
     return this;
   }
 
-  public <Data, TResource> Registry prepend(Class<Data> dataClass, Class<TResource> resourceClass,
-      ResourceDecoder<Data, TResource> decoder) {
-    decoderRegistry.prepend(decoder, dataClass, resourceClass);
+  /**
+   * Appends the given {@link ResourceDecoder} onto the list of all available
+   * {@link ResourceDecoder}s allowing it to be used if all earlier and default
+   * {@link ResourceDecoder}s for the given types fail (or there are none).
+   *
+   * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
+   * that your {@link ResourceDecoder} gets the chance to run before an existing
+   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
+   * best for new types of resources and data or as a way to add an additional fallback decoder
+   * for an existing type of data.
+   *
+   * @see #append(String, Class, Class, ResourceDecoder)
+   * @see #prepend(Class, Class, ResourceDecoder)
+   *
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  @NonNull
+  public <Data, TResource> Registry append(
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
+    append(BUCKET_APPEND_ALL, dataClass, resourceClass, decoder);
     return this;
   }
 
-  public <TResource> Registry register(Class<TResource> resourceClass,
-      ResourceEncoder<TResource> encoder) {
-    resourceEncoderRegistry.add(resourceClass, encoder);
+  /**
+   * Appends the given {@link ResourceDecoder} onto the list of available {@link ResourceDecoder}s
+   * in this bucket, allowing it to be used if all earlier and default {@link ResourceDecoder}s for
+   * the given types in this bucket fail (or there are none).
+   *
+   * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
+   * that your {@link ResourceDecoder} gets the chance to run before an existing
+   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
+   * best for new types of resources and data or as a way to add an additional fallback decoder
+   * for an existing type of data.
+   *
+   * @see #prepend(String, Class, Class, ResourceDecoder)
+   * @see #setResourceDecoderBucketPriorityList(List)
+   *
+   * @param bucket The bucket identifier to add this decoder to.
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  @NonNull
+  public <Data, TResource> Registry append(
+      @NonNull String bucket,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
+    decoderRegistry.append(bucket, decoder, dataClass, resourceClass);
+    return this;
+  }
+
+  /**
+   * Prepends the given {@link ResourceDecoder} into the list of all available
+   * {@link ResourceDecoder}s so that it is attempted before all later and default
+   * {@link ResourceDecoder}s for the given types.
+   *
+   * <p>This method allows you to replace the default {@link ResourceDecoder} because it ensures
+   * the registered {@link ResourceDecoder} will run first. You can use the
+   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
+   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
+   * types of data.
+   *
+   * @see #prepend(String, Class, Class, ResourceDecoder)
+   * @see #append(Class, Class, ResourceDecoder)
+   *
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  @NonNull
+  public <Data, TResource> Registry prepend(
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
+    prepend(BUCKET_PREPEND_ALL, dataClass, resourceClass, decoder);
     return this;
   }
 
-  public Registry register(DataRewinder.Factory factory) {
+  /**
+   * Prepends the given {@link ResourceDecoder} into the list of available {@link ResourceDecoder}s
+   * in the same bucket so that it is attempted before all later and default
+   * {@link ResourceDecoder}s for the given types in that bucket.
+   *
+   * <p>This method allows you to replace the default {@link ResourceDecoder} for this bucket
+   * because it ensures the registered {@link ResourceDecoder} will run first. You can use the
+   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
+   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
+   * types of data.
+   *
+   * @see #append(String, Class, Class, ResourceDecoder)
+   * @see #setResourceDecoderBucketPriorityList(List)
+   *
+   * @param bucket The bucket identifier to add this decoder to.
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  @NonNull
+  public <Data, TResource> Registry prepend(
+      @NonNull String bucket,
+      @NonNull Class<Data> dataClass,
+      @NonNull Class<TResource> resourceClass,
+      @NonNull ResourceDecoder<Data, TResource> decoder) {
+    decoderRegistry.prepend(bucket, decoder, dataClass, resourceClass);
+    return this;
+  }
+
+  /**
+   * Overrides the default ordering of resource decoder buckets. You may also add custom buckets
+   * which are identified as a unique string. Glide will attempt to decode using decoders in the
+   * highest priority bucket before moving on to the next one.
+   *
+   * <p>The default order is [{@link #BUCKET_GIF}, {@link #BUCKET_BITMAP},
+   * {@link #BUCKET_BITMAP_DRAWABLE}].
+   *
+   * <p>When registering decoders, you can use these buckets to specify the ordering relative only
+   * to other decoders in that bucket.
+   * @see #append(String, Class, Class, ResourceDecoder)
+   * @see #prepend(String, Class, Class, ResourceDecoder)
+   *
+   * @param buckets The list of bucket identifiers in order from highest priority to least priority.
+   */
+  // Final to avoid a PMD error.
+  @NonNull
+  public final Registry setResourceDecoderBucketPriorityList(@NonNull List<String> buckets) {
+    List<String> modifiedBuckets = new ArrayList<>(buckets);
+    modifiedBuckets.add(0, BUCKET_PREPEND_ALL);
+    modifiedBuckets.add(BUCKET_APPEND_ALL);
+    decoderRegistry.setBucketPriorityList(modifiedBuckets);
+    return this;
+  }
+
+  /**
+   * Appends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted after all earlier and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
+   * For example, registering an {@link ResourceEncoder} for
+   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
+   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   *
+   * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
+   * {@link ResourceEncoder} that is registered first will be used.
+   *
+   * @deprecated Use the equivalent {@link #append(Class, ResourceEncoder)} method instead.
+   */
+  @NonNull
+  @Deprecated
+  public <TResource> Registry register(
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
+    return append(resourceClass, encoder);
+  }
+
+  /**
+   * Appends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted after all earlier and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
+   * For example, registering an {@link ResourceEncoder} for
+   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
+   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   *
+   * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
+   * {@link ResourceEncoder} that is registered first will be used.
+   *
+   * @see #prepend(Class, ResourceEncoder)
+   */
+  @NonNull
+  public <TResource> Registry append(
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
+    resourceEncoderRegistry.append(resourceClass, encoder);
+    return this;
+  }
+
+  /**
+   * Prepends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted before all later and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>This method allows you to replace the default {@link ResourceEncoder} because it ensures
+   * the registered {@link ResourceEncoder} will run first. If multiple {@link ResourceEncoder}s are
+   * registered for the same type or super type, the {@link ResourceEncoder} that is registered
+   * first will be used.
+   *
+   * @see #append(Class, ResourceEncoder)
+   */
+  @NonNull
+  public <TResource> Registry prepend(
+      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {
+    resourceEncoderRegistry.prepend(resourceClass, encoder);
+    return this;
+  }
+
+  /**
+   * Registers a new {@link com.bumptech.glide.load.data.DataRewinder.Factory} to handle a
+   * non-default data type that can be rewind to allow for efficient reads of file headers.
+   */
+  @NonNull
+  public Registry register(@NonNull DataRewinder.Factory<?> factory) {
     dataRewinderRegistry.register(factory);
     return this;
   }
 
-  public <TResource, Transcode> Registry register(Class<TResource> resourceClass,
-      Class<Transcode> transcodeClass, ResourceTranscoder<TResource, Transcode> transcoder) {
+  /**
+   * Registers the given {@link ResourceTranscoder} to convert from the given resource {@link Class}
+   * to the given transcode {@link Class}.
+   *
+   * @param resourceClass The class that will be transcoded from (e.g.
+   * {@link android.graphics.Bitmap}).
+   * @param transcodeClass The class that will be transcoded to (e.g.
+   * {@link android.graphics.drawable.BitmapDrawable}).
+   * @param transcoder The {@link ResourceTranscoder} to register.
+   */
+  @NonNull
+  public <TResource, Transcode> Registry register(
+      @NonNull Class<TResource> resourceClass, @NonNull Class<Transcode> transcodeClass,
+      @NonNull ResourceTranscoder<TResource, Transcode> transcoder) {
     transcoderRegistry.register(resourceClass, transcodeClass, transcoder);
     return this;
   }
 
   /**
-   * Use the given factory to build a {@link com.bumptech.glide.load.model.ModelLoader} for models
-   * of the given class. Generally the best use of this method is to replace one of the default
-   * factories or add an implementation for other similar low level models. Any factory replaced by
-   * the given factory will have its {@link ModelLoaderFactory#teardown()}} method called.
+   * Registers a new {@link ImageHeaderParser} that can obtain some basic metadata from an image
+   * header (orientation, type etc).
+   */
+  @NonNull
+  public Registry register(@NonNull ImageHeaderParser parser) {
+    imageHeaderParserRegistry.add(parser);
+    return this;
+  }
+
+  /**
+   * Appends a new {@link ModelLoaderFactory} onto the end of the existing set so that the
+   * constructed {@link ModelLoader} will be tried after all default and previously registered
+   * {@link ModelLoader}s for the given model and data classes.
+   *
+   * <p>If you're attempting to replace an existing {@link ModelLoader}, use
+   * {@link #prepend(Class, Class, ModelLoaderFactory)}. This method is best for new types of models
+   * and/or data or as a way to add an additional fallback loader for an existing type of
+   * model/data.
    *
-   * <p> Note - If a factory already exists for the given class, it will be replaced. If that
-   * factory is not being used for any other model class, {@link ModelLoaderFactory#teardown()} will
-   * be called. </p>
+   * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
+   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
+   * entire request fail.
    *
-   * <p> Note - The factory must not be an anonymous inner class of an Activity or another object
-   * that cannot be retained statically. </p>
+   * @see #prepend(Class, Class, ModelLoaderFactory)
+   * @see #replace(Class, Class, ModelLoaderFactory)
    *
-   * @param modelClass The model class.
-   * @param dataClass  the data class.
+   * @param modelClass The model class (e.g. URL, file path).
+   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
+   * {@link java.io.FileDescriptor}).
    */
-  public <Model, Data> Registry append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  @NonNull
+  public <Model, Data> Registry append(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.append(modelClass, dataClass, factory);
     return this;
   }
 
-  public <Model, Data> Registry prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  /**
+   * Prepends a new {@link ModelLoaderFactory} onto the beginning of the existing set so that the
+   * constructed {@link ModelLoader} will be tried before all default and previously registered
+   * {@link ModelLoader}s for the given model and data classes.
+   *
+   * <p>If you're attempting to add additional functionality or add a backup that should run only
+   * after the default {@link ModelLoader}s run, use
+   * {@link #append(Class, Class, ModelLoaderFactory)}. This method is best for adding an additional
+   * case to Glide's existing functionality that should run first. This method will still run
+   * Glide's default {@link ModelLoader}s if the prepended {@link ModelLoader}s fail.
+   *
+   * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
+   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
+   * entire request fail.
+   *
+   * @see #append(Class, Class, ModelLoaderFactory)
+   * @see #replace(Class, Class, ModelLoaderFactory)
+   *
+   * @param modelClass The model class (e.g. URL, file path).
+   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
+   * {@link java.io.FileDescriptor}).
+   */
+  @NonNull
+  public <Model, Data> Registry prepend(
+      @NonNull Class<Model> modelClass, @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.prepend(modelClass, dataClass, factory);
     return this;
   }
 
-  public <Model, Data> Registry replace(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  /**
+   * Removes all default and previously registered {@link ModelLoaderFactory}s for the given data
+   * and model class and replaces all of them with the single {@link ModelLoader} provided.
+   *
+   * <p>If you're attempting to add additional functionality or add a backup that should run only
+   * after the default {@link ModelLoader}s run, use
+   * {@link #append(Class, Class, ModelLoaderFactory)}. This method should be used only when you
+   * want to ensure that Glide's default {@link ModelLoader}s do not run.
+   *
+   * <p>One good use case for this method is when you want to replace Glide's default networking
+   * library with your OkHttp, Volley, or your own implementation. Using
+   * {@link #prepend(Class, Class, ModelLoaderFactory)} or
+   * {@link #append(Class, Class, ModelLoaderFactory)} may still allow Glide's default networking
+   * library to run in some cases. Using this method will ensure that only your networking library
+   * will run and that the request will fail otherwise.
+   *
+   * @see #prepend(Class, Class, ModelLoaderFactory)
+   * @see #append(Class, Class, ModelLoaderFactory)
+   *
+   * @param modelClass The model class (e.g. URL, file path).
+   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
+   * {@link java.io.FileDescriptor}).
+   */
+  @NonNull
+  public <Model, Data> Registry replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     modelLoaderRegistry.replace(modelClass, dataClass, factory);
     return this;
   }
 
+  @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> getLoadPath(
-      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     LoadPath<Data, TResource, Transcode> result =
         loadPathCache.get(dataClass, resourceClass, transcodeClass);
-    if (result == null && !loadPathCache.contains(dataClass, resourceClass, transcodeClass)) {
+    if (loadPathCache.isEmptyLoadPath(result)) {
+      return null;
+    } else if (result == null) {
       List<DecodePath<Data, TResource, Transcode>> decodePaths =
           getDecodePaths(dataClass, resourceClass, transcodeClass);
       // It's possible there is no way to decode or transcode to the desired types from a given
@@ -133,17 +484,19 @@ public Registry register(DataRewinder.Factory factory) {
       if (decodePaths.isEmpty()) {
         result = null;
       } else {
-        result = new LoadPath<>(dataClass, resourceClass, transcodeClass, decodePaths,
-            exceptionListPool);
+        result =
+            new LoadPath<>(
+                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);
       }
       loadPathCache.put(dataClass, resourceClass, transcodeClass, result);
     }
     return result;
   }
 
+  @NonNull
   private <Data, TResource, Transcode> List<DecodePath<Data, TResource, Transcode>> getDecodePaths(
-      Class<Data> dataClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
-
+      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     List<DecodePath<Data, TResource, Transcode>> decodePaths = new ArrayList<>();
     List<Class<TResource>> registeredResourceClasses =
         decoderRegistry.getResourceClasses(dataClass, resourceClass);
@@ -158,15 +511,20 @@ public Registry register(DataRewinder.Factory factory) {
             decoderRegistry.getDecoders(dataClass, registeredResourceClass);
         ResourceTranscoder<TResource, Transcode> transcoder =
             transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);
-        decodePaths.add(new DecodePath<>(dataClass, registeredResourceClass,
-            registeredTranscodeClass, decoders, transcoder, exceptionListPool));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        DecodePath<Data, TResource, Transcode> path =
+            new DecodePath<>(dataClass, registeredResourceClass, registeredTranscodeClass,
+                decoders, transcoder, throwableListPool);
+        decodePaths.add(path);
       }
     }
     return decodePaths;
   }
 
+  @NonNull
   public <Model, TResource, Transcode> List<Class<?>> getRegisteredResourceClasses(
-      Class<Model> modelClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {
+      @NonNull Class<Model> modelClass, @NonNull Class<TResource> resourceClass,
+      @NonNull Class<Transcode> transcodeClass) {
     List<Class<?>> result = modelToResourceClassCache.get(modelClass, resourceClass);
 
     if (result == null) {
@@ -179,7 +537,7 @@ public Registry register(DataRewinder.Factory factory) {
           List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry
               .getTranscodeClasses(registeredResourceClass, transcodeClass);
           if (!registeredTranscodeClasses.isEmpty() && !result.contains(registeredResourceClass)) {
-              result.add(registeredResourceClass);
+            result.add(registeredResourceClass);
           }
         }
       }
@@ -190,11 +548,12 @@ public Registry register(DataRewinder.Factory factory) {
     return result;
   }
 
-  public boolean isResourceEncoderAvailable(Resource<?> resource) {
+  public boolean isResourceEncoderAvailable(@NonNull Resource<?> resource) {
     return resourceEncoderRegistry.get(resource.getResourceClass()) != null;
   }
 
-  public <X> ResourceEncoder<X> getResultEncoder(Resource<X> resource)
+  @NonNull
+  public <X> ResourceEncoder<X> getResultEncoder(@NonNull Resource<X> resource)
       throws NoResultEncoderAvailableException {
     ResourceEncoder<X> resourceEncoder = resourceEncoderRegistry.get(resource.getResourceClass());
     if (resourceEncoder != null) {
@@ -203,8 +562,9 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     throw new NoResultEncoderAvailableException(resource.getResourceClass());
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public <X> Encoder<X> getSourceEncoder(X data) throws NoSourceEncoderAvailableException {
+  public <X> Encoder<X> getSourceEncoder(@NonNull X data) throws NoSourceEncoderAvailableException {
     Encoder<X> encoder = encoderRegistry.getEncoder((Class<X>) data.getClass());
     if (encoder != null) {
       return encoder;
@@ -212,11 +572,13 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     throw new NoSourceEncoderAvailableException(data.getClass());
   }
 
-  public <X> DataRewinder<X> getRewinder(X data) {
+  @NonNull
+  public <X> DataRewinder<X> getRewinder(@NonNull X data) {
     return dataRewinderRegistry.build(data);
   }
 
-  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(Model model) {
+  @NonNull
+  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(@NonNull Model model) {
     List<ModelLoader<Model, ?>> result = modelLoaderRegistry.getModelLoaders(model);
     if (result.isEmpty()) {
       throw new NoModelLoaderAvailableException(model);
@@ -224,16 +586,28 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     return result;
   }
 
+  @NonNull
+  public List<ImageHeaderParser> getImageHeaderParsers() {
+    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();
+    if (result.isEmpty()) {
+      throw new NoImageHeaderParserException();
+    }
+    return result;
+  }
+
   /**
    * Thrown when no {@link com.bumptech.glide.load.model.ModelLoader} is registered for a given
    * model class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoModelLoaderAvailableException extends MissingComponentException {
-    public NoModelLoaderAvailableException(Object model) {
+    public NoModelLoaderAvailableException(@NonNull Object model) {
       super("Failed to find any ModelLoaders for model: " + model);
     }
 
-    public NoModelLoaderAvailableException(Class modelClass, Class dataClass) {
+    public NoModelLoaderAvailableException(@NonNull Class<?> modelClass,
+        @NonNull Class<?> dataClass) {
       super("Failed to find any ModelLoaders for model: " + modelClass + " and data: " + dataClass);
     }
   }
@@ -241,17 +615,24 @@ public NoModelLoaderAvailableException(Class modelClass, Class dataClass) {
   /**
    * Thrown when no {@link ResourceEncoder} is registered for a given resource class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoResultEncoderAvailableException extends MissingComponentException {
-    public NoResultEncoderAvailableException(Class<?> resourceClass) {
-      super("Failed to find result encoder for resource class: " + resourceClass);
+    public NoResultEncoderAvailableException(@NonNull Class<?> resourceClass) {
+      super("Failed to find result encoder for resource class: " + resourceClass
+          + ", you may need to consider registering a new Encoder for the requested type or"
+          + " DiskCacheStrategy.DATA/DiskCacheStrategy.NONE if caching your transformed resource is"
+          + " unnecessary.");
     }
   }
 
   /**
    * Thrown when no {@link Encoder} is registered for a given data class.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class NoSourceEncoderAvailableException extends MissingComponentException {
-    public NoSourceEncoderAvailableException(Class<?> dataClass) {
+    public NoSourceEncoderAvailableException(@NonNull Class<?> dataClass) {
       super("Failed to find source encoder for data class: " + dataClass);
     }
   }
@@ -259,9 +640,22 @@ public NoSourceEncoderAvailableException(Class<?> dataClass) {
   /**
    * Thrown when some necessary component is missing for a load.
    */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
   public static class MissingComponentException extends RuntimeException {
-    public MissingComponentException(String message) {
+    public MissingComponentException(@NonNull String message) {
       super(message);
     }
   }
+
+  /**
+   * Thrown when no {@link ImageHeaderParser} is registered.
+   */
+  // Never serialized by Glide.
+  @SuppressWarnings("serial")
+  public static final class NoImageHeaderParserException extends MissingComponentException {
+    public NoImageHeaderParserException() {
+      super("Failed to find image header parser.");
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index b44e50b6e..3f8056407 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -1,14 +1,22 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
+import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
 
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
 import android.widget.ImageView;
-
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.request.BaseRequestOptions;
+import com.bumptech.glide.request.ErrorRequestCoordinator;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestCoordinator;
@@ -19,14 +27,13 @@
 import com.bumptech.glide.request.ThumbnailRequestCoordinator;
 import com.bumptech.glide.request.target.PreloadTarget;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.signature.ApplicationVersionSignature;
-import com.bumptech.glide.signature.StringSignature;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 import java.net.URL;
-import java.util.UUID;
 
 /**
  * A generic class that can handle setting options and staring loads for generic resource types.
@@ -34,71 +41,114 @@
  * @param <TranscodeType> The type of resource that will be delivered to the
  * {@link com.bumptech.glide.request.target.Target}.
  */
-public class RequestBuilder<TranscodeType> implements Cloneable {
-  private static final TransitionOptions<?, ?> DEFAULT_ANIMATION_OPTIONS =
-      new GenericTransitionOptions<Object>();
-  private static final BaseRequestOptions DOWNLOAD_ONLY_OPTIONS =
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+public class RequestBuilder<TranscodeType> implements Cloneable,
+    ModelTypes<RequestBuilder<TranscodeType>> {
+  // Used in generated subclasses
+  protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
-  private final GlideContext context;
+  private final Context context;
   private final RequestManager requestManager;
   private final Class<TranscodeType> transcodeClass;
-  private final BaseRequestOptions<?> defaultRequestOptions;
+  private final RequestOptions defaultRequestOptions;
+  private final Glide glide;
+  private final GlideContext glideContext;
+
+  @NonNull protected RequestOptions requestOptions;
 
-  @NonNull private BaseRequestOptions<?> requestOptions;
+  @NonNull
   @SuppressWarnings("unchecked")
-  private TransitionOptions<?, ? super TranscodeType> transitionOptions =
-      (TransitionOptions<?, ? super TranscodeType>) DEFAULT_ANIMATION_OPTIONS;
+  private TransitionOptions<?, ? super TranscodeType> transitionOptions;
 
   @Nullable private Object model;
   // model may occasionally be null, so to enforce that load() was called, put a boolean rather
   // than relying on model not to be null.
   @Nullable private RequestListener<TranscodeType> requestListener;
   @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
+  @Nullable private RequestBuilder<TranscodeType> errorBuilder;
   @Nullable private Float thumbSizeMultiplier;
+  private boolean isDefaultTransitionOptionsSet = true;
   private boolean isModelSet;
   private boolean isThumbnailBuilt;
 
-  RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
-    this(other.context, other.requestManager, transcodeClass);
-    model = other.model;
-    isModelSet = other.isModelSet;
-    requestOptions = other.requestOptions;
-  }
-
-  RequestBuilder(GlideContext context, RequestManager requestManager,
-      Class<TranscodeType> transcodeClass) {
+  protected RequestBuilder(Glide glide, RequestManager requestManager,
+      Class<TranscodeType> transcodeClass, Context context) {
+    this.glide = glide;
     this.requestManager = requestManager;
-    this.context = Preconditions.checkNotNull(context);
     this.transcodeClass = transcodeClass;
-
     this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
+    this.context = context;
+    this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
     this.requestOptions = defaultRequestOptions;
+    this.glideContext = glide.getGlideContext();
   }
 
-  public RequestBuilder<TranscodeType> apply(BaseRequestOptions requestOptions) {
+  protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+    this(other.glide, other.requestManager, transcodeClass, other.context);
+    model = other.model;
+    isModelSet = other.isModelSet;
+    requestOptions = other.requestOptions;
+  }
+
+  /**
+   * Applies the given options to the request.
+   *
+   * <p>As with {@link RequestOptions#apply(RequestOptions)}, {@code #apply} only replaces those
+   * values that are explicitly set in the given {@link RequestOptions} object. If you need to
+   * completely reset all previously set options, create a new {@code RequestBuilder} instead of
+   * using this method.
+   *
+   * @see RequestOptions#apply(RequestOptions)
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
     Preconditions.checkNotNull(requestOptions);
-    BaseRequestOptions<?> toMutate = defaultRequestOptions == this.requestOptions
-        ? this.requestOptions.clone() : this.requestOptions;
-    this.requestOptions = toMutate.apply(requestOptions);
+    this.requestOptions = getMutableOptions().apply(requestOptions);
     return this;
   }
 
+  // We're checking to see if we need to clone our options object because we want to make sure the
+  // original is never modified, so we need reference equality.
+  @SuppressWarnings("ReferenceEquality")
+  @NonNull
+  protected RequestOptions getMutableOptions() {
+    return defaultRequestOptions == this.requestOptions
+        ? this.requestOptions.clone() : this.requestOptions;
+  }
+
+  /**
+   * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
+   * this load completes.
+   *
+   * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
+   * previously.
+   *
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
   public RequestBuilder<TranscodeType> transition(
-      TransitionOptions<?, ? super TranscodeType> transitionOptions) {
+      @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
     this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
+    isDefaultTransitionOptionsSet = false;
     return this;
   }
 
   /**
-   * Sets a RequestBuilder listener to monitor the resource load. It's best to create a single
+   * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single
    * instance of an exception handler per type of request (usually activity/fragment) rather than
    * pass one in per request to avoid some redundant object allocation.
    *
    * @param requestListener The request listener to use.
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> listener(
       @Nullable RequestListener<TranscodeType> requestListener) {
@@ -107,6 +157,34 @@
     return this;
   }
 
+  /**
+   * Sets a {@link RequestBuilder} that is built and run iff the load started by this
+   * {@link RequestBuilder} fails.
+   *
+   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
+   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
+   *
+   * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
+   * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
+   *
+   * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
+   * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
+   * Options like priority, override widths and heights and transitions must be applied
+   * independently to the error builder.
+   *
+   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
+   * if it's set on this {@link RequestBuilder} via
+   * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
+   * {@link RequestOptions#fallback(int)}.
+   *
+   * @return This {@link RequestBuilder}.
+   */
+  @NonNull
+  public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
+    this.errorBuilder = errorBuilder;
+    return this;
+  }
+
   /**
    * Loads and displays the resource retrieved by the given thumbnail request if it finishes before
    * this request. Best used for loading thumbnail resources that are smaller and will be loaded
@@ -114,12 +192,19 @@
    * requests will actually finish. However, if the thumb request completes after the full request,
    * the thumb resource will never replace the full resource.
    *
-   * @param thumbnailRequest The request to use to load the thumbnail.
-   * @return This request builder.
+   * <p>Recursive calls to thumbnail are supported.
+   *
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
+   * {@link #thumbnail(RequestBuilder[])}.
+   *
    * @see #thumbnail(float)
+   * @see #thumbnail(RequestBuilder[])
    *
-   * <p> Recursive calls to thumbnail are supported. </p>
+   * @param thumbnailRequest The request to use to load the thumbnail.
+   * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> thumbnail(
       @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
@@ -128,30 +213,99 @@
     return this;
   }
 
+  /**
+   * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
+   * loaded as thumbnails in the given priority order.
+   *
+   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
+   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
+   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
+   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
+   *
+   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
+   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
+   * {@link #thumbnail(RequestBuilder)} with {@code null}.
+   *
+   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
+   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
+   * chain.
+   *
+   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
+   * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
+   *
+   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
+   * {@link #thumbnail(float)} and this method.
+   *
+   * @see #thumbnail(float)
+   * @see #thumbnail(RequestBuilder)
+   *
+   * @return This request builder.
+   */
+  @SuppressWarnings({"CheckResult", "unchecked"})
+  @NonNull
+  @CheckResult
+  public RequestBuilder<TranscodeType> thumbnail(
+      @Nullable RequestBuilder<TranscodeType>... thumbnails) {
+    if (thumbnails == null || thumbnails.length == 0) {
+      return thumbnail((RequestBuilder<TranscodeType>) null);
+    }
+
+    RequestBuilder<TranscodeType> previous = null;
+
+    // Start with the lowest priority thumbnail so that we can safely handle mutations if
+    // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
+    // Starting with the highest priority thumbnail would prevent us from assigning the result of
+    // thumbnail because the mutated request wouldn't be used in the next iteration.
+    for (int i = thumbnails.length - 1; i >= 0; i--) {
+      RequestBuilder<TranscodeType> current = thumbnails[i];
+      // Ignore null thumbnails.
+      if (current == null) {
+        continue;
+      }
+
+      if (previous == null) {
+        // If we don't yet have our first non-null request, set it and continue.
+        previous = current;
+      } else {
+        // Otherwise make our next lowest priority request the thumbnail of our current request.
+        previous = current.thumbnail(previous);
+      }
+    }
+    return thumbnail(previous);
+  }
+
   /**
    * Loads a resource in an identical manner to this request except with the dimensions of the
-   * target multiplied by the given size multiplier. If the thumbnail load completes before the
-   * fullsize load, the thumbnail will be shown. If the thumbnail load completes after the fullsize
+   * target multiplied by the given size multiplier. If the thumbnail load completes before the full
+   * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
    * load, the thumbnail will not be shown.
    *
-   * <p> Note - The thumbnail resource will be smaller than the size requested so the target (or
+   * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
    * {@link ImageView}) must be able to scale the thumbnail appropriately. See
-   * {@link android.widget.ImageView.ScaleType}. </p>
+   * {@link android.widget.ImageView.ScaleType}.
    *
-   * <p> Almost all options will be copied from the original load, including the {@link
+   * <p>Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
    * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.BaseRequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.BaseRequestOptions#error(int)}, and
-   * {@link #listener(RequestListener)} will only be used on the fullsize load and will not be
-   * copied for the thumbnail load. </p>
+   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
+   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
+   * {@link #listener(RequestListener)} will only be used on the full size load and will not be
+   * copied for the thumbnail load.
+   *
+   * <p>Recursive calls to thumbnail are supported.
    *
-   * <p> Recursive calls to thumbnail are supported. </p>
+   * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
+   *  and {@link #thumbnail(RequestBuilder)}.
+   *
+   * @see #thumbnail(RequestBuilder)
+   * @see #thumbnail(RequestBuilder[])
    *
    * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
    *                       the thumbnail.
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
   public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
     if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
@@ -165,34 +319,88 @@
   /**
    * Sets the specific model to load data for.
    *
-   * <p> This method must be called at least once before
-   * {@link #into(com.bumptech.glide.request.target.Target)} is called. </p>
-   *
    * @param model The model to load data for, or null.
    * @return This request builder.
    */
+  @NonNull
+  @CheckResult
   @SuppressWarnings("unchecked")
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Object model) {
     return loadGeneric(model);
   }
 
+  @NonNull
   private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
     this.model = model;
     isModelSet = true;
     return this;
   }
+  /**
+   * Returns an object to load the given {@link Bitmap}.
+   *
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
+   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
+   * not supported by Glide by default, consider registering a custom
+   * {@link com.bumptech.glide.load.model.ModelLoader} or
+   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
+   * compared.
+   *
+   * @see #load(Object)
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
+    return loadGeneric(bitmap)
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
 
   /**
-   * Returns a request builder to load the given {@link java.lang.String}. signature.
+   * Returns a request builder to load the given {@link Drawable}.
+   *
+   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
+   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
+   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
+   * {@link com.bumptech.glide.load.model.ModelLoader} or
+   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+   *
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+   *
+   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
+   * compared.
+   *
+   * @see #load(Object)
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
+    return loadGeneric(drawable)
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+  }
+
+  /**
+   * Returns a request builder to load the given {@link java.lang.String}.
    *
    * <p> Note - this method caches data using only the given String as the cache key. If the data is
    * a Uri outside of your control, or you otherwise expect the data represented by the given String
    * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create that identifies the data currently at the given String that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
    * </p>
    *
@@ -201,6 +409,9 @@
    * @param string A file path, or a uri or url handled by
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
+  @NonNull
+  @Override
+  @CheckResult
   public RequestBuilder<TranscodeType> load(@Nullable String string) {
     return loadGeneric(string);
   }
@@ -211,11 +422,11 @@
    * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
    * represented by Uris from some content providers may change without the Uri changing, which
    * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create based on the data at the given Uri that will invalidate the cache
    * if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate. </p>
    *
    * @see #load(Object)
@@ -223,6 +434,9 @@
    * @param uri The Uri representing the image. Must be of a type handled by
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
     return loadGeneric(uri);
   }
@@ -230,45 +444,63 @@
   /**
    * Returns a request builder to load the given {@link File}.
    *
-   * <p> Note - this method caches data for Files using only the file path itself as the cache key.
+   * <p>Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
    * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)}
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
    * to mixin a signature you create that identifies the data currently in the File that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
-   * </p>
    *
    * @see #load(Object)
    *
    * @param file The File containing the image
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable File file) {
     return loadGeneric(file);
   }
 
   /**
-   * Returns a request builder to load the given resource id. Returns a request builder that uses
-   * the {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
+   * Returns a request builder that uses the
+   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
    * {@link Integer} to load the image represented by the given {@link Integer} resource id.
    * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
    *
-   * <p> By default this method adds a version code based signature to the cache key used to cache
+   * <p>By default this method adds a version code based signature to the cache key used to cache
    * this resource in Glide. This signature is sufficient to guarantee that end users will see the
    * most up to date versions of your Drawables, but during development if you do not increment your
    * version code before each install and you replace a Drawable with different data without
    * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
    * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link BaseRequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
+   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
    * during development, and re-enabling the default
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds. </p>
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+   *
+   * <p>This method will load non-{@link android.graphics.Bitmap} resources like
+   * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
+   * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
+   * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
+   * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
+   * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
+   * load failures if a {@link Drawable} can't be transformed, use the optional transformation
+   * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
+   *
+   * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
+   * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
+   * caution for non-{@link Bitmap} {@link Drawable}s.
    *
    * @see #load(Integer)
    * @see com.bumptech.glide.signature.ApplicationVersionSignature
    */
-  public RequestBuilder<TranscodeType> load(@Nullable Integer resourceId) {
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
     return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
   }
 
@@ -277,11 +509,13 @@
    *
    * @param url The URL representing the image.
    * @see #load(Object)
-   * @deprecated The {@link java.net.URL} class has <a href="http://goo.gl/c4hHNu">a number of
-   * performance problems</a> and should generally be avoided when possible. Prefer
-   * {@link #load(android.net.Uri)} or {@link #load(String)}.
+   * @deprecated The {@link java.net.URL} class has
+   * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
+   * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
    */
   @Deprecated
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable URL url) {
     return loadGeneric(url);
   }
@@ -289,15 +523,23 @@
   /**
    * Returns a request to load the given byte array.
    *
-   * <p> Note - by default loads for bytes are not cached in either the memory or the disk cache.
-   * </p>
+   * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
    *
    * @param model the data to load.
    * @see #load(Object)
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
-    return loadGeneric(model).apply(signatureOf(new StringSignature(UUID.randomUUID().toString()))
-        .diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(true /*skipMemoryCache*/));
+    RequestBuilder<TranscodeType> result = loadGeneric(model);
+    if (!result.requestOptions.isDiskCacheStrategySet()) {
+        result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    }
+    if (!result.requestOptions.isSkipMemoryCacheSet()) {
+      result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+    }
+    return result;
   }
 
   /**
@@ -308,7 +550,12 @@
    * arguments, the current model is not copied copied so changes to the model will affect both
    * builders. </p>
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      "unchecked",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
+  @CheckResult
   @Override
   public RequestBuilder<TranscodeType> clone() {
     try {
@@ -328,29 +575,65 @@
    * @return The given target.
    * @see RequestManager#clear(Target)
    */
-  public <Y extends Target<TranscodeType>> Y into(Y target) {
+  @NonNull
+  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
+    return into(target, /*targetListener=*/ null);
+  }
+
+  @NonNull
+  @Synthetic <Y extends Target<TranscodeType>> Y into(
+      @NonNull Y target,
+      @Nullable RequestListener<TranscodeType> targetListener) {
+    return into(target, targetListener, getMutableOptions());
+  }
+
+  private <Y extends Target<TranscodeType>> Y into(
+      @NonNull Y target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      @NonNull RequestOptions options) {
     Util.assertMainThread();
-    if (target == null) {
-      throw new IllegalArgumentException("You must pass in a non null Target");
-    }
+    Preconditions.checkNotNull(target);
     if (!isModelSet) {
       throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
 
-    Request previous = target.getRequest();
+    options = options.autoClone();
+    Request request = buildRequest(target, targetListener, options);
 
-    if (previous != null) {
-      requestManager.clear(target);
+    Request previous = target.getRequest();
+    if (request.isEquivalentTo(previous)
+        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
+      request.recycle();
+      // If the request is completed, beginning again will ensure the result is re-delivered,
+      // triggering RequestListeners and Targets. If the request is failed, beginning again will
+      // restart the request, giving it another chance to complete. If the request is already
+      // running, we can let it continue running without interruption.
+      if (!Preconditions.checkNotNull(previous).isRunning()) {
+        // Use the previous request rather than the new one to allow for optimizations like skipping
+        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
+        // that are done in the individual Request.
+        previous.begin();
+      }
+      return target;
     }
 
-    requestOptions.lock();
-    Request request = buildRequest(target);
+    requestManager.clear(target);
     target.setRequest(request);
     requestManager.track(target, request);
 
     return target;
   }
 
+  // If the caller is using skipMemoryCache and the previous request is finished, calling begin on
+  // the previous request will complete from memory because it will just use the resource that had
+  // already been loaded. If the previous request isn't complete, we can wait for it to finish
+  // because the previous request must also be using skipMemoryCache for the requests to be
+  // equivalent. See #2663 for additional context.
+  private boolean isSkipMemoryCacheWithCompletePreviousRequest(
+      RequestOptions options, Request previous) {
+    return !options.isMemoryCacheable() && previous.isComplete();
+  }
+
   /**
    * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
    * the view, and frees any resources Glide may have previously loaded into the view so they may be
@@ -362,32 +645,44 @@
    * @return The
    * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
    */
-  public Target<TranscodeType> into(ImageView view) {
+  @NonNull
+  public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
     Util.assertMainThread();
-    if (view == null) {
-      throw new IllegalArgumentException("You must pass in a non null View");
-    }
+    Preconditions.checkNotNull(view);
 
-    if (!requestOptions.isTransformationSet() && view.getScaleType() != null) {
-      if (requestOptions.isLocked()) {
-        requestOptions = requestOptions.clone();
-      }
+    RequestOptions requestOptions = this.requestOptions;
+    if (!requestOptions.isTransformationSet()
+        && requestOptions.isTransformationAllowed()
+        && view.getScaleType() != null) {
+      // Clone in this method so that if we use this RequestBuilder to load into a View and then
+      // into a different target, we don't retain the transformation applied based on the previous
+      // View's scale type.
       switch (view.getScaleType()) {
         case CENTER_CROP:
-          requestOptions.optionalCenterCrop(context);
+          requestOptions = requestOptions.clone().optionalCenterCrop();
+          break;
+        case CENTER_INSIDE:
+          requestOptions = requestOptions.clone().optionalCenterInside();
           break;
         case FIT_CENTER:
         case FIT_START:
         case FIT_END:
-          requestOptions.optionalFitCenter(context);
+          requestOptions = requestOptions.clone().optionalFitCenter();
+          break;
+        case FIT_XY:
+          requestOptions = requestOptions.clone().optionalCenterInside();
           break;
-        //$CASES-OMITTED$
+        case CENTER:
+        case MATRIX:
         default:
           // Do nothing.
       }
     }
 
-    return into(context.buildImageViewTarget(view, transcodeClass));
+    return into(
+        glideContext.buildImageViewTarget(view, transcodeClass),
+        /*targetListener=*/ null,
+        requestOptions);
   }
 
   /**
@@ -395,11 +690,11 @@
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    * @see RequestManager#clear(Target)
    *
@@ -414,7 +709,7 @@
    * Returns a future that can be used to do a blocking get on a background thread.
    *
    * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
-   * since the width and height will be overriden by values passed to {@link
+   * since the width and height will be overridden by values passed to {@link
    * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
    * with override values are applied, or whenever you want to retrieve the image in its original
    * size.
@@ -422,6 +717,7 @@
    * @see #submit(int, int)
    * @see #into(Target)
    */
+  @NonNull
   public FutureTarget<TranscodeType> submit() {
     return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
@@ -431,28 +727,29 @@
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    */
+  @NonNull
   public FutureTarget<TranscodeType> submit(int width, int height) {
     final RequestFutureTarget<TranscodeType> target =
-        new RequestFutureTarget<>(context.getMainHandler(), width, height);
+        new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);
 
     if (Util.isOnBackgroundThread()) {
-      context.getMainHandler().post(new Runnable() {
+      glideContext.getMainHandler().post(new Runnable() {
         @Override
         public void run() {
           if (!target.isCancelled()) {
-            into(target);
+            into(target, target);
           }
         }
       });
     } else {
-      into(target);
+      into(target, target);
     }
 
     return target;
@@ -466,16 +763,17 @@ public void run() {
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    * @return A {@link Target} that can be used to cancel the load via
    * {@link RequestManager#clear(Target)}.
    * @see com.bumptech.glide.ListPreloader
    */
+  @NonNull
   public Target<TranscodeType> preload(int width, int height) {
     final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
     return into(target);
@@ -490,6 +788,7 @@ public void run() {
    * {@link RequestManager#clear(Target)}
    * @see #preload(int, int)
    */
+  @NonNull
   public Target<TranscodeType> preload() {
     return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
@@ -505,7 +804,8 @@ public void run() {
    * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
    */
   @Deprecated
-  public <Y extends Target<File>> Y downloadOnly(Y target) {
+  @CheckResult
+  public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
     return getDownloadOnlyRequest().into(target);
   }
 
@@ -522,15 +822,19 @@ public void run() {
    * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}.
    */
   @Deprecated
+  @CheckResult
   public FutureTarget<File> downloadOnly(int width, int height) {
-    return getDownloadOnlyRequest().into(width, height);
+    return getDownloadOnlyRequest().submit(width, height);
   }
 
-  private RequestBuilder<File> getDownloadOnlyRequest() {
+  @NonNull
+  @CheckResult
+  protected RequestBuilder<File> getDownloadOnlyRequest() {
     return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
   }
 
-  private Priority getThumbnailPriority(Priority current) {
+  @NonNull
+  private Priority getThumbnailPriority(@NonNull Priority current) {
     switch (current) {
       case LOW:
         return Priority.NORMAL;
@@ -544,15 +848,83 @@ private Priority getThumbnailPriority(Priority current) {
     }
   }
 
-  private Request buildRequest(Target<TranscodeType> target) {
-    return buildRequestRecursive(target, null, transitionOptions, requestOptions.getPriority(),
-        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight());
+  private Request buildRequest(
+      Target<TranscodeType> target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      RequestOptions requestOptions) {
+    return buildRequestRecursive(
+        target,
+        targetListener,
+        /*parentCoordinator=*/ null,
+        transitionOptions,
+        requestOptions.getPriority(),
+        requestOptions.getOverrideWidth(),
+        requestOptions.getOverrideHeight(),
+        requestOptions);
+  }
+
+  private Request buildRequestRecursive(
+      Target<TranscodeType> target,
+      @Nullable RequestListener<TranscodeType> targetListener,
+      @Nullable RequestCoordinator parentCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions,
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight,
+      RequestOptions requestOptions) {
+
+    // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
+    ErrorRequestCoordinator errorRequestCoordinator = null;
+    if (errorBuilder != null) {
+      errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
+      parentCoordinator = errorRequestCoordinator;
+    }
+
+    Request mainRequest =
+        buildThumbnailRequestRecursive(
+            target,
+            targetListener,
+            parentCoordinator,
+            transitionOptions,
+            priority,
+            overrideWidth,
+            overrideHeight,
+            requestOptions);
+
+    if (errorRequestCoordinator == null) {
+      return mainRequest;
+    }
+
+    int errorOverrideWidth = errorBuilder.requestOptions.getOverrideWidth();
+    int errorOverrideHeight = errorBuilder.requestOptions.getOverrideHeight();
+    if (Util.isValidDimensions(overrideWidth, overrideHeight)
+        && !errorBuilder.requestOptions.isValidOverride()) {
+      errorOverrideWidth = requestOptions.getOverrideWidth();
+      errorOverrideHeight = requestOptions.getOverrideHeight();
+    }
+
+    Request errorRequest = errorBuilder.buildRequestRecursive(
+        target,
+        targetListener,
+        errorRequestCoordinator,
+        errorBuilder.transitionOptions,
+        errorBuilder.requestOptions.getPriority(),
+        errorOverrideWidth,
+        errorOverrideHeight,
+        errorBuilder.requestOptions);
+    errorRequestCoordinator.setRequests(mainRequest, errorRequest);
+    return errorRequestCoordinator;
   }
 
-  private Request buildRequestRecursive(Target<TranscodeType> target,
-      @Nullable ThumbnailRequestCoordinator parentCoordinator,
+  private Request buildThumbnailRequestRecursive(
+      Target<TranscodeType> target,
+      RequestListener<TranscodeType> targetListener,
+      @Nullable RequestCoordinator parentCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority, int overrideWidth, int overrideHeight) {
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight,
+      RequestOptions requestOptions) {
     if (thumbnailBuilder != null) {
       // Recursive case: contains a potentially recursive thumbnail request builder.
       if (isThumbnailBuilt) {
@@ -562,7 +934,10 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
 
       TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
           thumbnailBuilder.transitionOptions;
-      if (DEFAULT_ANIMATION_OPTIONS.equals(thumbTransitionOptions)) {
+
+      // Apply our transition by default to thumbnail requests but avoid overriding custom options
+      // that may have been applied on the thumbnail request explicitly.
+      if (thumbnailBuilder.isDefaultTransitionOptionsSet) {
         thumbTransitionOptions = transitionOptions;
       }
 
@@ -578,43 +953,86 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
       }
 
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest = obtainRequest(target, requestOptions, coordinator,
-          transitionOptions, priority, overrideWidth, overrideHeight);
+      Request fullRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              requestOptions,
+              coordinator,
+              transitionOptions,
+              priority,
+              overrideWidth,
+              overrideHeight);
       isThumbnailBuilt = true;
       // Recursively generate thumbnail requests.
-      Request thumbRequest = thumbnailBuilder.buildRequestRecursive(target, coordinator,
-          thumbTransitionOptions, thumbPriority, thumbOverrideWidth, thumbOverrideHeight);
+      Request thumbRequest =
+          thumbnailBuilder.buildRequestRecursive(
+              target,
+              targetListener,
+              coordinator,
+              thumbTransitionOptions,
+              thumbPriority,
+              thumbOverrideWidth,
+              thumbOverrideHeight,
+              thumbnailBuilder.requestOptions);
       isThumbnailBuilt = false;
       coordinator.setRequests(fullRequest, thumbRequest);
       return coordinator;
     } else if (thumbSizeMultiplier != null) {
       // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,
-          priority, overrideWidth, overrideHeight);
-      BaseRequestOptions<?> thumbnailOptions = requestOptions.clone()
+      Request fullRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              requestOptions,
+              coordinator,
+              transitionOptions,
+              priority,
+              overrideWidth,
+              overrideHeight);
+      RequestOptions thumbnailOptions = requestOptions.clone()
           .sizeMultiplier(thumbSizeMultiplier);
 
-      Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,
-          transitionOptions, getThumbnailPriority(priority), overrideWidth, overrideHeight);
+      Request thumbnailRequest =
+          obtainRequest(
+              target,
+              targetListener,
+              thumbnailOptions,
+              coordinator,
+              transitionOptions,
+              getThumbnailPriority(priority),
+              overrideWidth,
+              overrideHeight);
 
       coordinator.setRequests(fullRequest, thumbnailRequest);
       return coordinator;
     } else {
       // Base case: no thumbnail.
-      return obtainRequest(target, requestOptions, parentCoordinator, transitionOptions, priority,
-          overrideWidth, overrideHeight);
+      return obtainRequest(
+          target,
+          targetListener,
+          requestOptions,
+          parentCoordinator,
+          transitionOptions,
+          priority,
+          overrideWidth,
+          overrideHeight);
     }
   }
 
-  private Request obtainRequest(Target<TranscodeType> target,
-      BaseRequestOptions<?> requestOptions, RequestCoordinator requestCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,
-      int overrideWidth, int overrideHeight) {
-    requestOptions.lock();
-
+  private Request obtainRequest(
+      Target<TranscodeType> target,
+      RequestListener<TranscodeType> targetListener,
+      RequestOptions requestOptions,
+      RequestCoordinator requestCoordinator,
+      TransitionOptions<?, ? super TranscodeType> transitionOptions,
+      Priority priority,
+      int overrideWidth,
+      int overrideHeight) {
     return SingleRequest.obtain(
         context,
+        glideContext,
         model,
         transcodeClass,
         requestOptions,
@@ -622,9 +1040,10 @@ private Request obtainRequest(Target<TranscodeType> target,
         overrideHeight,
         priority,
         target,
+        targetListener,
         requestListener,
         requestCoordinator,
-        context.getEngine(),
+        glideContext.getEngine(),
         transitionOptions.getTransitionFactory());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 40078f8b7..f05ad0d83 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -7,15 +7,14 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.view.View;
-
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.BitmapTransitionOptions;
-import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
@@ -24,15 +23,15 @@
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.manager.TargetTracker;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
+import java.net.URL;
 
 /**
  * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity
@@ -46,15 +45,17 @@
  * @see Glide#with(android.support.v4.app.Fragment)
  * @see Glide#with(Context)
  */
-public class RequestManager implements LifecycleListener {
+public class RequestManager implements LifecycleListener,
+    ModelTypes<RequestBuilder<Drawable>> {
   private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
   private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
   private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
-  private final GlideContext context;
-  private final Lifecycle lifecycle;
+  protected final Glide glide;
+  protected final Context context;
+  @Synthetic final Lifecycle lifecycle;
   private final RequestTracker requestTracker;
   private final RequestManagerTreeNode treeNode;
   private final TargetTracker targetTracker = new TargetTracker();
@@ -67,24 +68,39 @@ public void run() {
   private final Handler mainHandler = new Handler(Looper.getMainLooper());
   private final ConnectivityMonitor connectivityMonitor;
 
-  @NonNull
-  private BaseRequestOptions<?> defaultRequestOptions;
-  @NonNull
-  private BaseRequestOptions<?> requestOptions;
-
-  public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
-    this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());
+  private RequestOptions requestOptions;
+
+  public RequestManager(
+      @NonNull Glide glide, @NonNull Lifecycle lifecycle,
+      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {
+    this(
+        glide,
+        lifecycle,
+        treeNode,
+        new RequestTracker(),
+        glide.getConnectivityMonitorFactory(),
+        context);
   }
 
-  RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,
-      RequestTracker requestTracker, ConnectivityMonitorFactory factory) {
-    this.context = Glide.get(context).getGlideContext();
+  // Our usage is safe here.
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+  RequestManager(
+      Glide glide,
+      Lifecycle lifecycle,
+      RequestManagerTreeNode treeNode,
+      RequestTracker requestTracker,
+      ConnectivityMonitorFactory factory,
+      Context context) {
+    this.glide = glide;
     this.lifecycle = lifecycle;
     this.treeNode = treeNode;
     this.requestTracker = requestTracker;
+    this.context = context;
 
     connectivityMonitor =
-        factory.build(context, new RequestManagerConnectivityListener(requestTracker));
+        factory.build(
+            context.getApplicationContext(),
+            new RequestManagerConnectivityListener(requestTracker));
 
     // If we're the application level request manager, we may be created on a background thread.
     // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the
@@ -97,10 +113,17 @@ public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNo
     }
     lifecycle.addListener(connectivityMonitor);
 
-    defaultRequestOptions = this.context.getDefaultRequestOptions();
-    requestOptions = defaultRequestOptions;
+    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
+
+    glide.registerRequestManager(this);
+  }
 
-    Glide.get(context).registerRequestManager(this);
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    requestOptions = toSet.clone().autoClone();
+  }
+
+  private void updateRequestOptions(@NonNull RequestOptions toUpdate) {
+    requestOptions = requestOptions.apply(toUpdate);
   }
 
   /**
@@ -117,14 +140,13 @@ public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNo
    *
    * <p>The modified options will only be applied to loads started after this method is called.
    *
-   * @see RequestBuilder#apply(BaseRequestOptions)
+   * @see RequestBuilder#apply(RequestOptions)
    *
    * @return This request manager.
    */
-  public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions) {
-    BaseRequestOptions<?> toMutate = this.requestOptions == defaultRequestOptions
-        ? this.requestOptions.clone() : this.defaultRequestOptions;
-    this.requestOptions = toMutate.apply(requestOptions);
+  @NonNull
+  public RequestManager applyDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
+    updateRequestOptions(requestOptions);
     return this;
   }
 
@@ -133,9 +155,8 @@ public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions)
    * with the given {@link RequestOptions}.
    *
    * <p>The {@link RequestOptions} provided here replace those that have been previously provided
-   * via {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, {@link
-   * #setDefaultRequestOptions(RequestOptions)} and {@link
-   * #applyDefaultRequestOptions(RequestOptions)}.
+   * via this method, {@link GlideBuilder#setDefaultRequestOptions(RequestOptions)}, and
+   * {@link #applyDefaultRequestOptions(RequestOptions)}.
    *
    * <p>Subsequent calls to {@link #applyDefaultRequestOptions(RequestOptions)} will not mutate
    * the {@link RequestOptions} provided here. Instead the manager will create a clone of these
@@ -145,24 +166,32 @@ public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions)
    *
    * @return This request manager.
    */
-  public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
-    this.defaultRequestOptions = requestOptions;
-    this.requestOptions = requestOptions;
+  @NonNull
+  public RequestManager setDefaultRequestOptions(@NonNull RequestOptions requestOptions) {
+    setRequestOptions(requestOptions);
     return this;
   }
 
   /**
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
+   *
+   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
+   * externally.
    */
+  @Deprecated
   public void onTrimMemory(int level) {
-    context.onTrimMemory(level);
+    glide.onTrimMemory(level);
   }
 
   /**
    * @see android.content.ComponentCallbacks2#onLowMemory()
+   *
+   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
+   * externally.
    */
+  @Deprecated
   public void onLowMemory() {
-    context.onLowMemory();
+    glide.onLowMemory();
   }
 
   /**
@@ -179,6 +208,10 @@ public boolean isPaused() {
   /**
    * Cancels any in progress loads, but does not clear resources of completed loads.
    *
+   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+   * manager is paused to complete. RequestManagers attached to Fragments and Activities
+   * automatically resume onStart().
+   *
    * @see #isPaused()
    * @see #resumeRequests()
    */
@@ -187,6 +220,27 @@ public void pauseRequests() {
     requestTracker.pauseRequests();
   }
 
+  /**
+   * Cancels any in progress loads and clears resources of completed loads.
+   *
+   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the
+   * manager is paused to complete. RequestManagers attached to Fragments and Activities
+   * automatically resume onStart().
+   *
+   * <p>This will release the memory used by completed bitmaps but leaves them in any configured
+   * caches. When an #{@link android.app.Activity} receives #{@link
+   * android.app.Activity#onTrimMemory(int)} at a level of #{@link
+   * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep
+   * your process alive longer.
+   *
+   * @see #isPaused()
+   * @see #resumeRequests()
+   */
+  public void pauseAllRequests() {
+    Util.assertMainThread();
+    requestTracker.pauseAllRequests();
+  }
+
   /**
    * Performs {@link #pauseRequests()} recursively for all managers that are contextually
    * descendant to this manager based on the Activity/Fragment hierarchy:
@@ -201,6 +255,8 @@ public void pauseRequests() {
    * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to
    * pause, in this case either call pause on the Activity or use a support Fragment.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "unused"})
   public void pauseRequestsRecursive() {
     Util.assertMainThread();
     pauseRequests();
@@ -225,6 +281,8 @@ public void resumeRequests() {
    * descendant to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics
    * are identical as for {@link #pauseRequestsRecursive()}.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public void resumeRequestsRecursive() {
     Util.assertMainThread();
     resumeRequests();
@@ -269,7 +327,7 @@ public void onDestroy() {
     lifecycle.removeListener(this);
     lifecycle.removeListener(connectivityMonitor);
     mainHandler.removeCallbacks(addSelfToLifecycle);
-    Glide.get(context).unregisterRequestManager(this);
+    glide.unregisterRequestManager(this);
   }
 
   /**
@@ -278,8 +336,10 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link android.graphics.Bitmap}
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<Bitmap> asBitmap() {
-    return as(Bitmap.class).transition(new BitmapTransitionOptions()).apply(DECODE_TYPE_BITMAP);
+    return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
   }
 
   /**
@@ -295,8 +355,10 @@ public void onDestroy() {
    * @return A new request builder for loading a
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<GifDrawable> asGif() {
-    return as(GifDrawable.class).transition(new DrawableTransitionOptions()).apply(DECODE_TYPE_GIF);
+    return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
   }
 
   /**
@@ -309,8 +371,109 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link Drawable}.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<Drawable> asDrawable() {
-    return as(Drawable.class).transition(new DrawableTransitionOptions());
+    return as(Drawable.class);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Bitmap)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
+    return asDrawable().load(bitmap);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Drawable)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
+    return asDrawable().load(drawable);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable String string) {
+    return asDrawable().load(string);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Uri)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Uri uri) {
+    return asDrawable().load(uri);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(File)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable File file) {
+    return asDrawable().load(file);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Integer)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Integer resourceId) {
+    return asDrawable().load(resourceId);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @CheckResult
+  @Override
+  @Deprecated
+  public RequestBuilder<Drawable> load(@Nullable URL url) {
+    return asDrawable().load(url);
+  }
+
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @NonNull
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable byte[] model) {
+    return asDrawable().load(model);
   }
 
   /**
@@ -319,6 +482,9 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
+  @NonNull
+  @CheckResult
+  @Override
   public RequestBuilder<Drawable> load(@Nullable Object model) {
     return asDrawable().load(model);
   }
@@ -334,6 +500,8 @@ public void onDestroy() {
    *
    * @return A new request builder for downloading content to cache and returning the cache File.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<File> downloadOnly() {
     return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);
   }
@@ -344,6 +512,8 @@ public void onDestroy() {
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<File> download(@Nullable Object model) {
     return downloadOnly().load(model);
   }
@@ -357,6 +527,8 @@ public void onDestroy() {
    *
    * @return A new request builder for obtaining File paths to content.
    */
+  @NonNull
+  @CheckResult
   public RequestBuilder<File> asFile() {
     return as(File.class).apply(skipMemoryCacheOf(true));
   }
@@ -369,8 +541,11 @@ public void onDestroy() {
    * @param resourceClass The resource to decode.
    * @return A new request builder for loading the given resource class.
    */
-  public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(context, this, resourceClass);
+  @NonNull
+  @CheckResult
+  public <ResourceType> RequestBuilder<ResourceType> as(
+      @NonNull Class<ResourceType> resourceClass) {
+    return new RequestBuilder<>(glide, this, resourceClass, context);
   }
 
   /**
@@ -383,9 +558,9 @@ public void onDestroy() {
    * @param view The view to cancel loads and free resources for.
    * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
    *                                  tag.
-   * @see #clear(Target).
+   * @see #clear(Target)
    */
-  public void clear(View view) {
+  public void clear(@NonNull View view) {
     clear(new ClearTarget(view));
   }
 
@@ -412,14 +587,33 @@ public void run() {
     }
   }
 
-  private void untrackOrDelegate(Target<?> target) {
+  private void untrackOrDelegate(@NonNull Target<?> target) {
     boolean isOwnedByUs = untrack(target);
-    if (!isOwnedByUs) {
-      Glide.get(context).removeFromManagers(target);
+    // We'll end up here if the Target was cleared after the RequestManager that started the request
+    // is destroyed. That can happen for at least two reasons:
+    // 1. We call clear() on a background thread using something other than Application Context
+    // RequestManager.
+    // 2. The caller retains a reference to the RequestManager after the corresponding Activity or
+    // Fragment is destroyed, starts a load with it, and then clears that load with a different
+    // RequestManager. Callers seem especially likely to do this in retained Fragments (#2262).
+    //
+    // #1 is always an error. At best the caller is leaking memory briefly in something like an
+    // AsyncTask. At worst the caller is leaking an Activity or Fragment for a sustained period of
+    // time if they do something like reference the Activity RequestManager in a long lived
+    // background thread or task.
+    //
+    // #2 is always an error. Callers shouldn't be starting new loads using RequestManagers after
+    // the corresponding Activity or Fragment is destroyed because retaining any reference to the
+    // RequestManager leaks memory. It's possible that there's some brief period of time during or
+    // immediately after onDestroy where this is reasonable, but I can't think of why.
+    if (!isOwnedByUs && !glide.removeFromManagers(target) && target.getRequest() != null) {
+      Request request = target.getRequest();
+      target.setRequest(null);
+      request.clear();
     }
   }
 
-  boolean untrack(Target<?> target) {
+  boolean untrack(@NonNull Target<?> target) {
     Request request = target.getRequest();
     // If the Target doesn't have a request, it's already been cleared.
     if (request == null) {
@@ -435,15 +629,20 @@ boolean untrack(Target<?> target) {
     }
   }
 
-  void track(Target<?> target, Request request) {
+  void track(@NonNull Target<?> target, @NonNull Request request) {
     targetTracker.track(target);
     requestTracker.runRequest(request);
   }
 
-  BaseRequestOptions<?> getDefaultRequestOptions() {
+  RequestOptions getDefaultRequestOptions() {
     return requestOptions;
   }
 
+  @NonNull
+  <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
+    return glide.getGlideContext().getDefaultTransitionOptions(transcodeClass);
+  }
+
   @Override
   public String toString() {
     return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
@@ -453,7 +652,7 @@ public String toString() {
       .ConnectivityListener {
     private final RequestTracker requestTracker;
 
-    public RequestManagerConnectivityListener(RequestTracker requestTracker) {
+    RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) {
       this.requestTracker = requestTracker;
     }
 
@@ -467,12 +666,13 @@ public void onConnectivityChanged(boolean isConnected) {
 
   private static class ClearTarget extends ViewTarget<View, Object> {
 
-    public ClearTarget(View view) {
+    ClearTarget(@NonNull View view) {
       super(view);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition<? super Object> transition) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
       // Do nothing.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/TransitionOptions.java b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
index ea285ebf3..ce2cfe469 100644
--- a/library/src/main/java/com/bumptech/glide/TransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.request.transition.NoTransition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.request.transition.ViewAnimationFactory;
@@ -23,44 +24,63 @@
    *
    * @return This request builder.
    */
+  @NonNull
   public final CHILD dontTransition() {
     return transition(NoTransition.getFactory());
   }
 
   /**
-   * Sets a {@link android.view.animation} to run on the wrapped target when an resource load
-   * finishes. Will only be run if the resource was loaded asynchronously (ie was not in the memory
-   * cache)
+   * Sets an {@link android.view.animation.Animation} to run on the wrapped target when an resource
+   * load finishes.
+   * Will only be run if the resource was loaded asynchronously (i.e. was not in the memory cache).
    *
    * @param viewAnimationId The resource id of the {@link android.view.animation} to use as the
    *                        transition.
    * @return This request builder.
    */
+  @NonNull
   public final CHILD transition(int viewAnimationId) {
-    return transition(new ViewAnimationFactory<TranscodeType>(viewAnimationId));
+    return transition(new ViewAnimationFactory<>(viewAnimationId));
   }
 
   /**
    * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target
-   * may be wrapping when a resource load finishes. Will only be run if the load was loaded
-   * asynchronously (ie was not in the memory cache).
+   * may be wrapping when a resource load finishes.
+   * Will only be run if the load was loaded asynchronously (i.e. was not in the memory cache).
    *
    * @param animator The {@link com.bumptech.glide.request.transition.ViewPropertyTransition
    *                 .Animator} to run.
    * @return This request builder.
    */
-  public final CHILD transition(ViewPropertyTransition.Animator animator) {
-    return transition(new ViewPropertyAnimationFactory<TranscodeType>(animator));
+  @NonNull
+  public final CHILD transition(@NonNull ViewPropertyTransition.Animator animator) {
+    return transition(new ViewPropertyAnimationFactory<>(animator));
   }
 
-  public final CHILD transition(TransitionFactory<? super TranscodeType> transitionFactory) {
+  /**
+   * Uses the given {@link TransitionFactory} to build a
+   * {@link com.bumptech.glide.request.transition.Transition} for each request started with these
+   * {@code TransitionOptions}.
+   *
+   * @return This request builder.
+   */
+  @NonNull
+  public final CHILD transition(
+      @NonNull TransitionFactory<? super TranscodeType> transitionFactory) {
     this.transitionFactory = Preconditions.checkNotNull(transitionFactory);
     return self();
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      // cast to CHILD is safe given the generic argument represents the object's runtime class
+      "unchecked",
+      // CHILD is the correct class name.
+      "PMD.CloneMethodReturnTypeMustMatchClassName",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @Override
-  protected final CHILD clone() {
+  public final CHILD clone() {
     try {
       return (CHILD) super.clone();
     } catch (CloneNotSupportedException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
index 118d407dd..4837ec515 100644
--- a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
@@ -15,24 +15,41 @@
    * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
    * {@link android.graphics.Bitmap#getConfig()} when possible.
    *
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
+   * {@link android.graphics.Bitmap.Config#HARDWARE}.
+   *
    * <p> GIF images decoded by {@link android.graphics.BitmapFactory} currently use an internal
    * hidden format that is returned as null from {@link android.graphics.Bitmap#getConfig()}. Since
    * we cannot force {@link android.graphics.BitmapFactory} to always return our desired config,
-   * this setting is a preference, not a promise.</p>
+   * this setting is a preference, not a promise.
    */
   PREFER_ARGB_8888,
 
+  /**
+   * Identical to {@link #PREFER_ARGB_8888} but prevents Glide from using {@link
+   * android.graphics.Bitmap.Config#HARDWARE} on Android O+.
+   *
+   * @deprecated If you must disable hardware bitmaps, set
+   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false
+   * instead.
+   */
+  @Deprecated
+  PREFER_ARGB_8888_DISALLOW_HARDWARE,
+
   /**
    * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc)
    * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
    * {@link android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or
    * use alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for
    * {@link android.graphics.Bitmap#getConfig()}.
+   *
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
+   * {@link android.graphics.Bitmap.Config#HARDWARE}.
    */
   PREFER_RGB_565;
 
   /**
    * The default value for DecodeFormat.
    */
-  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;
+  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Encoder.java b/library/src/main/java/com/bumptech/glide/load/Encoder.java
index db652b1ad..400cc7422 100644
--- a/library/src/main/java/com/bumptech/glide/load/Encoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import java.io.File;
 
 /**
@@ -8,7 +9,6 @@
  * @param <T> The type of the data that will be written.
  */
 public interface Encoder<T> {
-
   /**
    * Writes the given data to the given output stream and returns True if the write completed
    * successfully and should be committed.
@@ -17,5 +17,5 @@
    * @param file The File to write the data to.
    * @param options The put of options to apply when encoding.
    */
-  boolean encode(T data, File file, Options options);
+  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/HttpException.java b/library/src/main/java/com/bumptech/glide/load/HttpException.java
index ad53292c1..b13edc5d7 100644
--- a/library/src/main/java/com/bumptech/glide/load/HttpException.java
+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load;
 
 import android.support.annotation.Nullable;
-
 import java.io.IOException;
 
 /**
@@ -11,7 +10,11 @@
  * users may attempt to retry or otherwise uniformly handle certain types of errors regardless of
  * the underlying http library.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public final class HttpException extends IOException {
+  private static final long serialVersionUID = 1L;
+
   public static final int UNKNOWN = -1;
   private final int statusCode;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
new file mode 100644
index 000000000..b188c4df3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
@@ -0,0 +1,67 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * Interface for the ImageHeaderParser.
+ */
+public interface ImageHeaderParser {
+  /**
+   * A constant indicating we were unable to parse the orientation from the image either because no
+   * exif segment containing orientation data existed, or because of an I/O error attempting to read
+   * the exif segment.
+   */
+  int UNKNOWN_ORIENTATION = -1;
+
+  /**
+   * The format of the image data including whether or not the image may include transparent
+   * pixels.
+   */
+  enum ImageType {
+    GIF(true),
+    JPEG(false),
+    RAW(false),
+    /** PNG type with alpha. */
+    PNG_A(true),
+    /** PNG type without alpha. */
+    PNG(false),
+    /** WebP type with alpha. */
+    WEBP_A(true),
+    /** WebP type without alpha. */
+    WEBP(false),
+    /** Unrecognized type. */
+    UNKNOWN(false);
+
+    private final boolean hasAlpha;
+
+    ImageType(boolean hasAlpha) {
+      this.hasAlpha = hasAlpha;
+    }
+
+    public boolean hasAlpha() {
+      return hasAlpha;
+    }
+  }
+
+  @NonNull
+  ImageType getType(@NonNull InputStream is) throws IOException;
+
+  @NonNull
+  ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException;
+
+  /**
+   * Parse the orientation from the image header. If it doesn't handle this image type (or this is
+   * not an image) it will return a default value rather than throwing an exception.
+   *
+   * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
+   * contain an orientation
+   */
+  int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException;
+
+  int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException;
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
new file mode 100644
index 000000000..97930be11
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
@@ -0,0 +1,102 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+/**
+ * Utilities for the ImageHeaderParser.
+ */
+public final class ImageHeaderParserUtils {
+  // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer but
+  // will resize up to this amount if necessary.
+  private static final int MARK_POSITION = 5 * 1024 * 1024;
+
+  private ImageHeaderParserUtils() { }
+
+  /** Returns the ImageType for the given InputStream. */
+  @NonNull
+  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
+      try {
+        ImageType type = parser.getType(is);
+        if (type != ImageType.UNKNOWN) {
+          return type;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /** Returns the ImageType for the given ByteBuffer. */
+  @NonNull
+  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,
+      @Nullable ByteBuffer buffer)
+      throws IOException {
+    if (buffer == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
+      ImageType type = parser.getType(buffer);
+      if (type != ImageType.UNKNOWN) {
+        return type;
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /**
+   * Returns the orientation for the given InputStream.
+   */
+  public static int getOrientation(@NonNull List<ImageHeaderParser> parsers,
+      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageHeaderParser.UNKNOWN_ORIENTATION;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = parsers.size(); i < size; i++) {
+      ImageHeaderParser parser = parsers.get(i);
+      try {
+        int orientation = parser.getOrientation(is, byteArrayPool);
+        if (orientation != ImageHeaderParser.UNKNOWN_ORIENTATION) {
+          return orientation;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/Key.java b/library/src/main/java/com/bumptech/glide/load/Key.java
index 47bb2e01a..f78a7b168 100644
--- a/library/src/main/java/com/bumptech/glide/load/Key.java
+++ b/library/src/main/java/com/bumptech/glide/load/Key.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
 
@@ -21,11 +22,19 @@
    * <p> Note - Using {@link java.security.MessageDigest#reset()} inside of this method will result
    * in undefined behavior. </p>
    */
-  void updateDiskCacheKey(MessageDigest messageDigest);
+  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);
 
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and
+   * {@link #hashCode()}.
+   */
   @Override
   boolean equals(Object o);
 
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and
+   * {@link #equals(Object)}.
+   */
   @Override
   int hashCode();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index 99a177abc..6b1d038f2 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load;
 
+import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.security.MessageDigest;
 import java.util.Arrays;
 import java.util.Collection;
@@ -15,28 +16,31 @@
   private final Collection<? extends Transformation<T>> transformations;
 
   @SafeVarargs
-  public MultiTransformation(Transformation<T>... transformations) {
-    if (transformations.length < 1) {
+  @SuppressWarnings("varargs")
+  public MultiTransformation(@NonNull Transformation<T>... transformations) {
+    if (transformations.length == 0) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
     }
     this.transformations = Arrays.asList(transformations);
   }
 
-  public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {
-    if (transformationList.size() < 1) {
+  public MultiTransformation(@NonNull Collection<? extends Transformation<T>> transformationList) {
+    if (transformationList.isEmpty()) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
     }
     this.transformations = transformationList;
   }
 
+  @NonNull
   @Override
-  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(
+      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {
     Resource<T> previous = resource;
 
     for (Transformation<T> transformation : transformations) {
-      Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);
+      Resource<T> transformed = transformation.transform(context, previous, outWidth, outHeight);
       if (previous != null && !previous.equals(resource) && !previous.equals(transformed)) {
         previous.recycle();
       }
@@ -60,7 +64,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     for (Transformation<T> transformation : transformations) {
       transformation.updateDiskCacheKey(messageDigest);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
index 04a03e5b6..561264871 100644
--- a/library/src/main/java/com/bumptech/glide/load/Option.java
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -28,7 +27,8 @@
 public final class Option<T> {
   private static final CacheKeyUpdater<Object> EMPTY_UPDATER = new CacheKeyUpdater<Object>() {
     @Override
-    public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
+    public void update(@NonNull byte[] keyBytes, @NonNull Object value,
+        @NonNull MessageDigest messageDigest) {
       // Do nothing.
     }
   };
@@ -45,8 +45,9 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> memory(String key) {
-    return new Option<>(key, null /*defaultValue*/, Option.<T>emptyUpdater());
+  @NonNull
+  public static <T> Option<T> memory(@NonNull String key) {
+    return new Option<>(key, null, Option.<T>emptyUpdater());
   }
 
   /**
@@ -56,7 +57,8 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> memory(String key, T defaultValue) {
+  @NonNull
+  public static <T> Option<T> memory(@NonNull String key, @NonNull T defaultValue) {
     return new Option<>(key, defaultValue, Option.<T>emptyUpdater());
   }
 
@@ -67,8 +69,10 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> disk(String key, CacheKeyUpdater<T> cacheKeyUpdater) {
-    return new Option<>(key, null /*defaultValue*/, cacheKeyUpdater);
+  @NonNull
+  public static <T> Option<T> disk(@NonNull String key,
+      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
+    return new Option<>(key, null, cacheKeyUpdater);
   }
 
   /**
@@ -79,11 +83,14 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
    * @param key A unique package prefixed {@link String} that identifies this option (must be
    *            stable across builds, so {@link Class#getName()} should <em>not</em> be used).
    */
-  public static <T> Option<T> disk(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+  @NonNull
+  public static <T> Option<T> disk(@NonNull String key, @Nullable T defaultValue,
+      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     return new Option<>(key, defaultValue, cacheKeyUpdater);
   }
 
-  Option(String key, T defaultValue, CacheKeyUpdater<T> cacheKeyUpdater) {
+  private Option(@NonNull String key, @Nullable T defaultValue,
+      @NonNull CacheKeyUpdater<T> cacheKeyUpdater) {
     this.key = Preconditions.checkNotEmpty(key);
     this.defaultValue = defaultValue;
     this.cacheKeyUpdater = Preconditions.checkNotNull(cacheKeyUpdater);
@@ -92,6 +99,8 @@ public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {
   /**
    * Returns a reasonable default to use if no other value is set, or {@code null}.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   @Nullable
   public T getDefaultValue() {
     return defaultValue;
@@ -102,10 +111,11 @@ public T getDefaultValue() {
    * value using the {@link com.bumptech.glide.load.Option.CacheKeyUpdater} optionally provided in
    * the constructor.
    */
-  public void update(T value, MessageDigest messageDigest) {
+  public void update(@NonNull T value, @NonNull MessageDigest messageDigest) {
     cacheKeyUpdater.update(getKeyBytes(), value, messageDigest);
   }
 
+  @NonNull
   private byte[] getKeyBytes() {
     if (keyBytes == null) {
       keyBytes = key.getBytes(Key.CHARSET);
@@ -127,6 +137,7 @@ public int hashCode() {
     return key.hashCode();
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <T> CacheKeyUpdater<T> emptyUpdater() {
     return (CacheKeyUpdater<T>) EMPTY_UPDATER;
@@ -142,12 +153,26 @@ public String toString() {
   /**
    * An interface that updates a {@link MessageDigest} with the given value as part of a process to
    * generate a disk cache key.
+   *
+   * @param <T> The type of the option.
    */
   public interface CacheKeyUpdater<T> {
     /**
      * Updates the given {@link MessageDigest} with the bytes of the given key (to avoid incidental
      * value collisions when values are not particularly unique) and value.
+     *
+     * <p>If your {@link Option} shouldn't affect the disk cache key, you should not implement this
+     * class and use {@link Option#memory(String)} or {@link Option#memory(String, Object)} instead.
+     *
+     * @param keyBytes The bytes of the {@link String} used as the key for this particular
+     * {@link Option}. Should be added to the {@code messageDigest} using
+     * {@link MessageDigest#update(byte[])} by all implementations if the digest is updated with
+     * the given {@code value} parameter.
+     *
+     * @param value The value of of this particular option. Typically you should convert the value
+     * to a byte array using some stable mechanism and then call
+     * {@link MessageDigest#update(byte[])} to update the given digest.
      */
-    void update(byte[] keyBytes, T value, MessageDigest messageDigest);
+    void update(@NonNull byte[] keyBytes, @NonNull T value, @NonNull MessageDigest messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Options.java b/library/src/main/java/com/bumptech/glide/load/Options.java
index 909cb3620..bf2685323 100644
--- a/library/src/main/java/com/bumptech/glide/load/Options.java
+++ b/library/src/main/java/com/bumptech/glide/load/Options.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
 import android.support.v4.util.SimpleArrayMap;
-
 import java.security.MessageDigest;
-import java.util.Map;
 
 /**
  * A set of {@link Option Options} to apply to in memory and disk cache keys.
@@ -12,17 +12,19 @@
 public final class Options implements Key {
   private final ArrayMap<Option<?>, Object> values = new ArrayMap<>();
 
-  public void putAll(Options other) {
+  public void putAll(@NonNull Options other) {
     values.putAll((SimpleArrayMap<Option<?>, Object>) other.values);
   }
 
-  public <T> Options set(Option<T> option, T value) {
+  @NonNull
+  public <T> Options set(@NonNull Option<T> option, @NonNull T value) {
     values.put(option, value);
     return this;
   }
 
+  @Nullable
   @SuppressWarnings("unchecked")
-  public <T> T get(Option<T> option) {
+  public <T> T get(@NonNull Option<T> option) {
     return values.containsKey(option) ? (T) values.get(option) : option.getDefaultValue();
   }
 
@@ -41,9 +43,11 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    for (Map.Entry<Option<?>, Object> entry : values.entrySet()) {
-      updateDiskCacheKey(entry.getKey(), entry.getValue(), messageDigest);
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    for (int i = 0; i < values.size(); i++) {
+      Option<?> key = values.keyAt(i);
+      Object value = values.valueAt(i);
+      updateDiskCacheKey(key, value, messageDigest);
     }
   }
 
@@ -55,7 +59,8 @@ public String toString() {
   }
 
   @SuppressWarnings("unchecked")
-  private static <T> void updateDiskCacheKey(Option<T> option, Object value, MessageDigest md) {
+  private static <T> void updateDiskCacheKey(@NonNull Option<T> option, @NonNull Object value,
+      @NonNull MessageDigest md) {
     option.update((T) value, md);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
index ebac41d1e..977339e25 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.engine.Resource;
-
 import java.io.IOException;
 
 /**
@@ -18,29 +17,26 @@
    * Returns {@code true} if this decoder is capable of decoding the given source with the given
    * options, and {@code false} otherwise.
    *
-   * <p> Decoders should make a best effort attempt to quickly determine if they are likely to be
+   * <p>Decoders should make a best effort attempt to quickly determine if they are likely to be
    * able to decode data, but should not attempt to completely read the given data. A typical
    * implementation would check the file headers verify they match content the decoder expects to
-   * handle (ie a GIF decoder should verify that the image contains the GIF header block. </p>
-   *
-   * <p> Decoders that return {@code true} from {@link #handles(Object, Options)} may still
-   * return {@code null} from {@link #decode(Object, int, int, Options)} if the data is
-   * partial or formatted incorrectly. </p>
+   * handle (i.e. a GIF decoder should verify that the image contains the GIF header block.
    *
-   * @throws IOException
+   * <p>Decoders that return {@code true} from {@code handles} may still return {@code null} from
+   * {@link #decode(Object, int, int, Options)} if the data is partial or formatted incorrectly.
    */
-  boolean handles(T source, Options options) throws IOException;
+  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;
 
   /**
    * Returns a decoded resource from the given data or null if no resource could be decoded.
    *
-   * <p> The {@code source} is managed by the caller, there's no need to close it. The returned
-   * {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit. </p>
+   * <p>The {@code source} is managed by the caller, there's no need to close it. The returned
+   * {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit.
    *
-   * <p> Note - The {@code width} and {@code height} arguments are hints only, there is no
+   * <p>Note - The {@code width} and {@code height} arguments are hints only, there is no
    * requirement that the decoded resource exactly match the given dimensions. A typical use case
    * would be to use the target dimensions to determine how much to downsample Bitmaps by to avoid
-   * overly large allocations. </p>
+   * overly large allocations.
    *
    * @param source  The data the resource should be decoded from.
    * @param width   The ideal width in pixels of the decoded resource, or {@link
@@ -54,8 +50,8 @@
    *                all of their option keys are present. However, implementations may assume that
    *                if one of their option keys is present, it's value is non-null and is of the
    *                expected type.
-   * @throws IOException
    */
   @Nullable
-  Resource<Z> decode(T source, int width, int height, Options options) throws IOException;
+  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options)
+      throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
index 941d3845d..d17985845 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -10,5 +11,6 @@
  */
 public interface ResourceEncoder<T> extends Encoder<Resource<T>> {
   // specializing the generic arguments
-  EncodeStrategy getEncodeStrategy(Options options);
+  @NonNull
+  EncodeStrategy getEncodeStrategy(@NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index b11a635bd..2e9ab29d9 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -1,6 +1,10 @@
 package com.bumptech.glide.load;
 
+import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
 
 /**
  * A class for performing an arbitrary transformation on a resource that implements
@@ -8,9 +12,17 @@
  * cache and {@link #updateDiskCacheKey(java.security.MessageDigest)}} to identify the
  * transformation in disk caches.
  *
- * <p>Using the fully qualified class name (not {@link Class#getName()} to avoid proguard
- * obfuscation) is an easy way to implement
- * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly.
+ * <p>Using the fully qualified class name as a static final {@link String} (not
+ * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * required they can be passed in to the constructor of the {@code Transformation} and then used to
+ * update the {@link java.security.MessageDigest} passed in to
+ * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically
+ * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized
+ * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
+ *
+ * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()} for
+ * memory caching to work correctly.
  *
  * @param <T> The type of the resource being transformed.
  */
@@ -40,6 +52,7 @@
    * Transformation. Otherwise the resource you request may be loaded from disk cache and your
    * Transformation may not be called.
    *
+   * @param context The Application context
    * @param resource  The resource to transform.
    * @param outWidth  The width of the view or target the resource will be displayed in, or {@link
    *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
@@ -49,5 +62,7 @@
    *                  original resource height.
    * @return The transformed resource.
    */
-  Resource<T> transform(Resource<T> resource, int outWidth, int outHeight);
+  @NonNull
+  Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,
+      int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
new file mode 100644
index 000000000..66a287823
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
@@ -0,0 +1,39 @@
+package com.bumptech.glide.load.data;
+
+import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+/**
+ * Fetches an {@link AssetFileDescriptor} for a local {@link android.net.Uri}.
+ */
+public final class AssetFileDescriptorLocalUriFetcher extends LocalUriFetcher<AssetFileDescriptor> {
+
+  public AssetFileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
+  }
+
+  @Override
+  protected AssetFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    AssetFileDescriptor result = contentResolver.openAssetFileDescriptor(uri, "r");
+    if (result == null) {
+      throw new FileNotFoundException("FileDescriptor is null for: " + uri);
+    }
+    return result;
+  }
+
+  @Override
+  protected void close(AssetFileDescriptor data) throws IOException {
+    data.close();
+  }
+
+  @NonNull
+  @Override
+  public Class<AssetFileDescriptor> getDataClass() {
+    return AssetFileDescriptor.class;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 823ed42bf..f21eb6c64 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -1,11 +1,10 @@
 package com.bumptech.glide.load.data;
 
 import android.content.res.AssetManager;
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
-
 import java.io.IOException;
 
 /**
@@ -20,13 +19,15 @@
   private final AssetManager assetManager;
   private T data;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public AssetPathFetcher(AssetManager assetManager, String assetPath) {
     this.assetManager = assetManager;
     this.assetPath = assetPath;
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super T> callback) {
+  public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super T> callback) {
     try {
       data = loadResource(assetManager, assetPath);
     } catch (IOException e) {
@@ -56,6 +57,7 @@ public void cancel() {
     // Do nothing.
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.LOCAL;
@@ -63,7 +65,7 @@ public DataSource getDataSource() {
 
   /**
    * Opens the given asset path with the given {@link android.content.res.AssetManager} and returns
-   * the conrete data type returned by the AssetManager.
+   * the concrete data type returned by the AssetManager.
    *
    * @param assetManager An AssetManager to use to open the given path.
    * @param path         A string path pointing to a resource in assets to open.
@@ -74,7 +76,6 @@ public DataSource getDataSource() {
    * Closes the concrete data type if necessary.
    *
    * @param data The data to close.
-   * @throws IOException
    */
   protected abstract void close(T data) throws IOException;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
new file mode 100644
index 000000000..ce9cd17b1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java
@@ -0,0 +1,102 @@
+package com.bumptech.glide.load.data;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * An {@link OutputStream} implementation that recycles and re-uses {@code byte[]}s using the
+ * provided {@link ArrayPool}.
+ */
+public final class BufferedOutputStream extends OutputStream {
+  @NonNull
+  private final OutputStream out;
+  private byte[] buffer;
+  private ArrayPool arrayPool;
+  private int index;
+
+  public BufferedOutputStream(@NonNull OutputStream out, @NonNull ArrayPool arrayPool) {
+    this(out, arrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+  }
+
+  @VisibleForTesting
+  BufferedOutputStream(@NonNull OutputStream out, ArrayPool arrayPool, int bufferSize) {
+    this.out = out;
+    this.arrayPool = arrayPool;
+    buffer = arrayPool.get(bufferSize, byte[].class);
+  }
+
+  @Override
+  public void write(int b) throws IOException {
+    buffer[index++] = (byte) b;
+    maybeFlushBuffer();
+  }
+
+  @Override
+  public void write(@NonNull byte[] b) throws IOException {
+    write(b, 0, b.length);
+  }
+
+  @Override
+  public void write(@NonNull byte[] b, int initialOffset, int length) throws IOException {
+    int writtenSoFar = 0;
+    do {
+      int remainingToWrite = length - writtenSoFar;
+      int currentOffset = initialOffset + writtenSoFar;
+      // If we still need to write at least the buffer size worth of bytes, we might as well do so
+      // directly and avoid the overhead of copying to the buffer first.
+      if (index == 0 && remainingToWrite >= buffer.length) {
+        out.write(b, currentOffset, remainingToWrite);
+        return;
+      }
+
+      int remainingSpaceInBuffer = buffer.length - index;
+      int totalBytesToWriteToBuffer = Math.min(remainingToWrite, remainingSpaceInBuffer);
+
+      System.arraycopy(b, currentOffset, buffer, index, totalBytesToWriteToBuffer);
+
+      index += totalBytesToWriteToBuffer;
+      writtenSoFar += totalBytesToWriteToBuffer;
+
+      maybeFlushBuffer();
+    } while (writtenSoFar < length);
+  }
+
+  @Override
+  public void flush() throws IOException {
+    flushBuffer();
+    out.flush();
+  }
+
+  private void flushBuffer() throws IOException {
+    if (index > 0) {
+      out.write(buffer, 0, index);
+      index = 0;
+    }
+  }
+
+  private void maybeFlushBuffer() throws IOException {
+    if (index == buffer.length) {
+      flushBuffer();
+    }
+  }
+
+  @Override
+  public void close() throws IOException {
+    try {
+      flush();
+    } finally {
+      out.close();
+    }
+    release();
+  }
+
+  private void release() {
+    if (buffer != null) {
+      arrayPool.put(buffer);
+      buffer = null;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
index 1bd464284..4a1674fd9 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 
@@ -22,12 +22,13 @@
 public interface DataFetcher<T> {
 
   /**
-   * Callback that should be called when data has been loaded and is available, or when the load
+   * Callback that must be called when data has been loaded and is available, or when the load
    * fails.
    *
    * @param <T> The type of data that will be loaded.
    */
   interface DataCallback<T> {
+
     /**
      * Called with the loaded data if the load succeeded, or with {@code null} if the load failed.
      */
@@ -35,27 +36,34 @@
 
     /**
      * Called when the load fails.
+     *
      * @param e a non-null {@link Exception} indicating why the load failed.
      */
-    void onLoadFailed(Exception e);
+    void onLoadFailed(@NonNull Exception e);
   }
 
   /**
-   * Synchronously fetch data from which a resource can be decoded.
+   * Fetch data from which a resource can be decoded.
+   *
+   * <p> This will always be called on background thread so it is safe to perform long running tasks
+   * here. Any third party libraries called must be thread safe (or move the work to another thread)
+   * since this method will be called from a thread in a
+   * {@link java.util.concurrent.ExecutorService}
+   * that may have more than one background thread. </p>
+   *
+   * You <b>MUST</b> use the {@link DataCallback} once the request is complete.
    *
-   * <p> This will always be called on
-   * background thread so it is safe to perform long running tasks here. Any third party libraries
-   * called must be thread safe since this method will be called from a thread in a {@link
-   * java.util.concurrent.ExecutorService} that may have more than one background thread. </p>
+   * You are free to move the fetch work to another thread and call the callback from there.
    *
    * <p> This method will only be called when the corresponding resource is not in the cache. </p>
    *
    * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
    *
    * @param priority The priority with which the request should be completed.
+   * @param callback The callback to use when the request is complete
    * @see #cleanup() where the data retuned will be cleaned up
    */
-  void loadData(Priority priority, DataCallback<? super T> callback);
+  void loadData(@NonNull Priority priority, @NonNull DataCallback<? super T> callback);
 
   /**
    * Cleanup or recycle any resources used by this data fetcher. This method will be called in a
@@ -84,10 +92,12 @@
   /**
    * Returns the class of the data this fetcher will attempt to obtain.
    */
+  @NonNull
   Class<T> getDataClass();
 
   /**
    * Returns the {@link com.bumptech.glide.load.DataSource} this fetcher will return data from.
    */
+  @NonNull
   DataSource getDataSource();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
index 73dd6411e..805198ca6 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import java.io.IOException;
 
 /**
@@ -20,12 +21,14 @@
     /**
      * Returns a new {@link com.bumptech.glide.load.data.DataRewinder} wrapping the given data.
      */
-    DataRewinder<T> build(T data);
+    @NonNull
+    DataRewinder<T> build(@NonNull T data);
 
     /**
      * Returns the class of data this factory can produce
      * {@link com.bumptech.glide.load.data.DataRewinder}s for.
      */
+    @NonNull
     Class<T> getDataClass();
   }
 
@@ -34,8 +37,8 @@
    * returns the re-wound data (or a wrapper for the re-wound data).
    *
    * @return An object pointing to the wrapped data.
-   * @throws IOException
    */
+  @NonNull
   T rewindAndGet() throws IOException;
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
index 63914f07c..9aa20bc8f 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
@@ -1,58 +1,63 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.HashMap;
 import java.util.Map;
 
 /**
  * Stores a mapping of data class to {@link com.bumptech.glide.load.data.DataRewinder.Factory} and
- * allows  registation of new types and factories.
+ * allows registration of new types and factories.
  */
 public class DataRewinderRegistry {
-  private final Map<Class, DataRewinder.Factory> rewinders = new HashMap<>();
-  private static final DataRewinder.Factory DEFAULT_FACTORY = new DataRewinder.Factory<Object>() {
-    @Override
-    public DataRewinder<Object> build(Object data) {
-      return new DefaultRewinder(data);
-    }
+  private final Map<Class<?>, DataRewinder.Factory<?>> rewinders = new HashMap<>();
+  private static final DataRewinder.Factory<?> DEFAULT_FACTORY =
+      new DataRewinder.Factory<Object>() {
+        @NonNull
+        @Override
+        public DataRewinder<Object> build(@NonNull Object data) {
+          return new DefaultRewinder(data);
+        }
 
-    @Override
-    public Class<Object> getDataClass() {
-      throw new UnsupportedOperationException("Not implemented");
-    }
-  };
+        @NonNull
+        @Override
+        public Class<Object> getDataClass() {
+          throw new UnsupportedOperationException("Not implemented");
+        }
+      };
 
-  public synchronized void register(DataRewinder.Factory factory) {
+  public synchronized void register(@NonNull DataRewinder.Factory<?> factory) {
     rewinders.put(factory.getDataClass(), factory);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T> DataRewinder<T> build(T data) {
+  public synchronized <T> DataRewinder<T> build(@NonNull T data) {
     Preconditions.checkNotNull(data);
-    DataRewinder.Factory result = rewinders.get(data.getClass());
+    DataRewinder.Factory<T> result = (DataRewinder.Factory<T>) rewinders.get(data.getClass());
     if (result == null) {
       for (DataRewinder.Factory<?> registeredFactory : rewinders.values()) {
         if (registeredFactory.getDataClass().isAssignableFrom(data.getClass())) {
-          result = registeredFactory;
+          result = (DataRewinder.Factory<T>) registeredFactory;
           break;
         }
       }
     }
 
     if (result == null) {
-      result = DEFAULT_FACTORY;
+      result = (DataRewinder.Factory<T>) DEFAULT_FACTORY;
     }
     return result.build(data);
   }
 
-  private static class DefaultRewinder implements DataRewinder<Object> {
+  private static final class DefaultRewinder implements DataRewinder<Object> {
     private final Object data;
 
-    public DefaultRewinder(Object data) {
+    DefaultRewinder(@NonNull Object data) {
       this.data = data;
     }
 
+    @NonNull
     @Override
     public Object rewindAndGet() {
       return data;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
index de4436d93..9f5d79e62 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -15,46 +16,46 @@
   /** Allow two bytes for the file format. */
   private static final int SEGMENT_START_POSITION = 2;
   private static final byte[] EXIF_SEGMENT = new byte[] {
-      /** segment start id. */
+      /* segment start id. */
       (byte) 0xFF,
-      /** segment type. */
+      /* segment type. */
       (byte) 0xE1,
-      /** segmentLength. */
+      /* segmentLength. */
       0x00,
       (byte) 0x1C,
-      /** exif identifier. */
+      /* exif identifier. */
       0x45,
       0x78,
       0x69,
       0x66,
       0x00,
       0x00,
-      /** motorola byte order (big endian). */
+      /* motorola byte order (big endian). */
       (byte) 0x4D,
       (byte) 0x4D,
-      /** filler? */
+      /* filler? */
       0x00,
       0x00,
-      /** first id offset. */
+      /* first id offset. */
       0x00,
       0x00,
       0x00,
       0x08,
-      /** tagCount. */
+      /* tagCount. */
       0x00,
       0x01,
-      /** exif tag type. */
+      /* exif tag type. */
       0x01,
       0x12,
-      /** 2 byte format. */
+      /* 2 byte format. */
       0x00,
       0x02,
-      /** component count. */
+      /* component count. */
       0x00,
       0x00,
       0x00,
       0x01,
-      /** 2 byte orientation value, the first byte of which is always 0. */
+      /* 2 byte orientation value, the first byte of which is always 0. */
       0x00,
   };
   private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
@@ -75,8 +76,10 @@ public boolean markSupported() {
     return false;
   }
 
+  // No need for synchronized since all we do is throw.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
-  public void mark(int readlimit) {
+  public void mark(int readLimit) {
     throw new UnsupportedOperationException();
   }
 
@@ -97,7 +100,7 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
     int read;
     if (position > ORIENTATION_POSITION) {
       read = super.read(buffer, byteOffset, byteCount);
@@ -120,11 +123,14 @@ public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException
   public long skip(long byteCount) throws IOException {
     long skipped = super.skip(byteCount);
     if (skipped > 0) {
-      position += skipped;
+      // See http://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      position = (int) (position + skipped);
     }
     return skipped;
   }
 
+  // No need for synchronized since all we do is throw.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
   public void reset() throws IOException {
     throw new UnsupportedOperationException();
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
index 6adf9ffa5..176f206d9 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
@@ -2,7 +2,7 @@
 
 import android.content.res.AssetManager;
 import android.os.ParcelFileDescriptor;
-
+import android.support.annotation.NonNull;
 import java.io.IOException;
 
 /**
@@ -24,6 +24,7 @@ protected void close(ParcelFileDescriptor data) throws IOException {
     data.close();
   }
 
+  @NonNull
   @Override
   public Class<ParcelFileDescriptor> getDataClass() {
     return ParcelFileDescriptor.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 76a9ea297..2a159b92b 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
+import android.support.annotation.NonNull;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
@@ -12,14 +12,18 @@
  * Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}.
  */
 public class FileDescriptorLocalUriFetcher extends LocalUriFetcher<ParcelFileDescriptor> {
-  public FileDescriptorLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  public FileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
   }
 
   @Override
   protected ParcelFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    return contentResolver.openAssetFileDescriptor(uri, "r").getParcelFileDescriptor();
+    AssetFileDescriptor assetFileDescriptor = contentResolver.openAssetFileDescriptor(uri, "r");
+    if (assetFileDescriptor == null) {
+      throw new FileNotFoundException("FileDescriptor is null for: " + uri);
+    }
+    return assetFileDescriptor.getParcelFileDescriptor();
   }
 
   @Override
@@ -27,6 +31,7 @@ protected void close(ParcelFileDescriptor data) throws IOException {
     data.close();
   }
 
+  @NonNull
   @Override
   public Class<ParcelFileDescriptor> getDataClass() {
     return ParcelFileDescriptor.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index d9062bb12..e8f914b6e 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -1,15 +1,16 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.HttpException;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
 import com.bumptech.glide.util.LogTime;
-
+import com.bumptech.glide.util.Synthetic;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
@@ -23,10 +24,13 @@
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "HttpUrlFetcher";
   private static final int MAXIMUM_REDIRECTS = 5;
-  private static final int DEFAULT_TIMEOUT_MS = 2500;
-  // Visible for testing.
+  @VisibleForTesting
   static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
       new DefaultHttpUrlConnectionFactory();
+  /**
+   * Returned when a connection error prevented us from receiving an http error.
+   */
+  private static final int INVALID_STATUS_CODE = -1;
 
   private final GlideUrl glideUrl;
   private final int timeout;
@@ -36,11 +40,11 @@
   private InputStream stream;
   private volatile boolean isCancelled;
 
-  public HttpUrlFetcher(GlideUrl glideUrl) {
-    this(glideUrl, DEFAULT_TIMEOUT_MS, DEFAULT_CONNECTION_FACTORY);
+  public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
+    this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
     this.glideUrl = glideUrl;
     this.timeout = timeout;
@@ -48,25 +52,22 @@ public HttpUrlFetcher(GlideUrl glideUrl) {
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super InputStream> callback) {
     long startTime = LogTime.getLogTime();
-    final InputStream result;
     try {
-      result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
-          glideUrl.getHeaders());
+      InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
+      callback.onDataReady(result);
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Failed to load data for url", e);
       }
       callback.onLoadFailed(e);
-      return;
-    }
-
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime)
-          + " ms and loaded " + result);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-    callback.onDataReady(result);
   }
 
   private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
@@ -95,28 +96,47 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
     urlConnection.setUseCaches(false);
     urlConnection.setDoInput(true);
 
+    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that
+    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.
+    urlConnection.setInstanceFollowRedirects(false);
+
     // Connect explicitly to avoid errors in decoders if connection fails.
     urlConnection.connect();
+    // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.
+    stream = urlConnection.getInputStream();
     if (isCancelled) {
       return null;
     }
     final int statusCode = urlConnection.getResponseCode();
-    if (statusCode / 100 == 2) {
+    if (isHttpOk(statusCode)) {
       return getStreamForSuccessfulRequest(urlConnection);
-    } else if (statusCode / 100 == 3) {
+    } else if (isHttpRedirect(statusCode)) {
       String redirectUrlString = urlConnection.getHeaderField("Location");
       if (TextUtils.isEmpty(redirectUrlString)) {
         throw new HttpException("Received empty or null redirect url");
       }
       URL redirectUrl = new URL(url, redirectUrlString);
+      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition
+      // to disconnecting the url connection below. See #2352.
+      cleanup();
       return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
-    } else if (statusCode == -1) {
+    } else if (statusCode == INVALID_STATUS_CODE) {
       throw new HttpException(statusCode);
     } else {
       throw new HttpException(urlConnection.getResponseMessage(), statusCode);
     }
   }
 
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpOk(int statusCode) {
+    return statusCode / 100 == 2;
+  }
+
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpRedirect(int statusCode) {
+    return statusCode / 100 == 3;
+  }
+
   private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
       throws IOException {
     if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
@@ -143,6 +163,7 @@ public void cleanup() {
     if (urlConnection != null) {
       urlConnection.disconnect();
     }
+    urlConnection = null;
   }
 
   @Override
@@ -152,11 +173,13 @@ public void cancel() {
     isCancelled = true;
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.REMOTE;
@@ -167,6 +190,10 @@ public DataSource getDataSource() {
   }
 
   private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
+
+    @Synthetic
+    DefaultHttpUrlConnectionFactory() { }
+
     @Override
     public HttpURLConnection build(URL url) throws IOException {
       return (HttpURLConnection) url.openConnection();
diff --git a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
index 13d0700fd..9a0766ce7 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.load.data;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
-
+import com.bumptech.glide.util.Synthetic;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -16,11 +17,13 @@
 
   private final RecyclableBufferedInputStream bufferedStream;
 
-  InputStreamRewinder(InputStream is, ByteArrayPool byteArrayPool) {
+  @Synthetic
+  InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {
     bufferedStream = new RecyclableBufferedInputStream(is, byteArrayPool);
     bufferedStream.mark(MARK_LIMIT);
   }
 
+  @NonNull
   @Override
   public InputStream rewindAndGet() throws IOException {
     bufferedStream.reset();
@@ -37,17 +40,19 @@ public void cleanup() {
    * java.io.InputStream}s.
    */
   public static final class Factory implements DataRewinder.Factory<InputStream> {
-    private final ByteArrayPool byteArrayPool;
+    private final ArrayPool byteArrayPool;
 
-    public Factory(ByteArrayPool byteArrayPool) {
+    public Factory(ArrayPool byteArrayPool) {
       this.byteArrayPool = byteArrayPool;
     }
 
+    @NonNull
     @Override
     public DataRewinder<InputStream> build(InputStream data) {
       return new InputStreamRewinder(data, byteArrayPool);
     }
 
+    @NonNull
     @Override
     public Class<InputStream> getDataClass() {
       return InputStream.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index add61c095..68ee75305 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
@@ -21,25 +19,27 @@
 public abstract class LocalUriFetcher<T> implements DataFetcher<T> {
   private static final String TAG = "LocalUriFetcher";
   private final Uri uri;
-  private final Context context;
+  private final ContentResolver contentResolver;
   private T data;
 
   /**
    * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
    *
-   * @param context Any {@link android.content.Context}.
+   * @param contentResolver Any {@link android.content.ContentResolver}.
    * @param uri     A Uri pointing to a local asset. This load will fail if the uri isn't openable
    *                by {@link ContentResolver#openInputStream(android.net.Uri)}
    * @see ContentResolver#openInputStream(android.net.Uri)
    */
-  public LocalUriFetcher(Context context, Uri uri) {
-    this.context = context.getApplicationContext();
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public LocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    this.contentResolver = contentResolver;
     this.uri = uri;
   }
 
   @Override
-  public final void loadData(Priority priority, DataCallback<? super T> callback) {
-    ContentResolver contentResolver = context.getContentResolver();
+  public final void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super T> callback) {
     try {
       data = loadResource(uri, contentResolver);
     } catch (FileNotFoundException e) {
@@ -68,6 +68,7 @@ public void cancel() {
     // Do nothing.
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
index 3fb7b3974..aaad13214 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.data;
 
 import android.content.res.AssetManager;
-
+import android.support.annotation.NonNull;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -23,6 +23,7 @@ protected void close(InputStream data) throws IOException {
     data.close();
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index aafdc25aa..758e4a543 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -1,9 +1,10 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
+import android.content.UriMatcher;
 import android.net.Uri;
-
+import android.provider.ContactsContract;
+import android.support.annotation.NonNull;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -12,14 +13,82 @@
  * Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}.
  */
 public class StreamLocalUriFetcher extends LocalUriFetcher<InputStream> {
-  public StreamLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  /**
+   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537)
+   */
+  private static final int ID_CONTACTS_LOOKUP = 1;
+  /**
+   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo)
+   */
+  private static final int ID_CONTACTS_THUMBNAIL = 2;
+  /**
+   * A contact uri (e.g. content://com.android.contacts/contacts/38)
+   */
+  private static final int ID_CONTACTS_CONTACT = 3;
+  /**
+   * A contact display photo (high resolution) uri
+   * (e.g. content://com.android.contacts/5/display_photo)
+   */
+  private static final int ID_CONTACTS_PHOTO = 4;
+  /**
+   * Uri for optimized search of phones by number
+   * (e.g. content://com.android.contacts/phone_lookup/232323232
+   */
+  private static final int ID_LOOKUP_BY_PHONE = 5;
+  /**
+   * Match the incoming Uri for special cases which we can handle nicely.
+   */
+  private static final UriMatcher URI_MATCHER;
+
+  static {
+    URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_CONTACTS_LOOKUP);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_CONTACTS_LOOKUP);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_CONTACTS_THUMBNAIL);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACTS_CONTACT);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/display_photo", ID_CONTACTS_PHOTO);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "phone_lookup/*", ID_LOOKUP_BY_PHONE);
+  }
+
+  public StreamLocalUriFetcher(ContentResolver resolver, Uri uri) {
+    super(resolver, uri);
   }
 
   @Override
   protected InputStream loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    return contentResolver.openInputStream(uri);
+    InputStream inputStream = loadResourceFromUri(uri, contentResolver);
+    if (inputStream == null) {
+      throw new FileNotFoundException("InputStream is null for " + uri);
+    }
+    return inputStream;
+  }
+
+
+  private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    switch (URI_MATCHER.match(uri)) {
+      case ID_CONTACTS_CONTACT:
+        return openContactPhotoInputStream(contentResolver, uri);
+      case ID_CONTACTS_LOOKUP:
+      case ID_LOOKUP_BY_PHONE:
+        // If it was a Lookup uri then resolve it first, then continue loading the contact uri.
+        uri = ContactsContract.Contacts.lookupContact(contentResolver, uri);
+        if (uri == null) {
+          throw new FileNotFoundException("Contact cannot be found");
+        }
+        return openContactPhotoInputStream(contentResolver, uri);
+      case ID_CONTACTS_THUMBNAIL:
+      case ID_CONTACTS_PHOTO:
+      case UriMatcher.NO_MATCH:
+      default:
+        return contentResolver.openInputStream(uri);
+    }
+  }
+
+  private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {
+    return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
+        true /*preferHighres*/);
   }
 
   @Override
@@ -27,6 +96,7 @@ protected void close(InputStream data) throws IOException {
     data.close();
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
index dc6cbef6e..d7f7e44af 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java
@@ -3,6 +3,7 @@
 import android.content.ContentResolver;
 import android.net.Uri;
 import android.provider.MediaStore;
+import com.bumptech.glide.request.target.Target;
 
 /**
  * Utility classes for interacting with the media store.
@@ -33,6 +34,9 @@ public static boolean isMediaStoreImageUri(Uri uri) {
   }
 
   public static boolean isThumbnailSize(int width, int height) {
-    return width <= MINI_THUMB_WIDTH && height <= MINI_THUMB_HEIGHT;
+    return width != Target.SIZE_ORIGINAL
+        && height != Target.SIZE_ORIGINAL
+        && width <= MINI_THUMB_WIDTH
+        && height <= MINI_THUMB_HEIGHT;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index 307f2385e..3b90b0a6b 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -1,18 +1,19 @@
 package com.bumptech.glide.load.data.mediastore;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.MediaStore;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.ExifOrientationStream;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -21,35 +22,38 @@
  * A {@link DataFetcher} implementation for {@link InputStream}s that loads data from thumbnail
  * files obtained from the {@link MediaStore}.
  */
+@SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
 public class ThumbFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "MediaStoreThumbFetcher";
-  private final Context context;
   private final Uri mediaStoreImageUri;
   private final ThumbnailStreamOpener opener;
   private InputStream inputStream;
 
   public static ThumbFetcher buildImageFetcher(Context context, Uri uri) {
-    return build(context, uri, new ImageThumbnailQuery());
+    return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));
   }
 
   public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
-    return build(context, uri, new VideoThumbnailQuery());
+    return build(context, uri, new VideoThumbnailQuery(context.getContentResolver()));
   }
 
   private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
-    ByteArrayPool byteArrayPool = Glide.get(context).getByteArrayPool();
-    return new ThumbFetcher(context, uri, new ThumbnailStreamOpener(query, byteArrayPool));
+    ArrayPool byteArrayPool = Glide.get(context).getArrayPool();
+    ThumbnailStreamOpener opener = new ThumbnailStreamOpener(
+        Glide.get(context).getRegistry().getImageHeaderParsers(), query, byteArrayPool,
+        context.getContentResolver());
+    return new ThumbFetcher(uri, opener);
   }
 
-  // Visible for testing.
-  ThumbFetcher(Context context, Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
-    this.context = context;
+  @VisibleForTesting
+  ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
     this.mediaStoreImageUri = mediaStoreImageUri;
     this.opener = opener;
   }
 
   @Override
-  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
+  public void loadData(@NonNull Priority priority,
+      @NonNull DataCallback<? super InputStream> callback) {
     try {
       inputStream = openThumbInputStream();
     } catch (FileNotFoundException e) {
@@ -64,11 +68,11 @@ public void loadData(Priority priority, DataCallback<? super InputStream> callba
   }
 
   private InputStream openThumbInputStream() throws FileNotFoundException {
-    InputStream result = opener.open(context, mediaStoreImageUri);
+    InputStream result = opener.open(mediaStoreImageUri);
 
     int orientation = -1;
     if (result != null) {
-      orientation = opener.getOrientation(context, mediaStoreImageUri);
+      orientation = opener.getOrientation(mediaStoreImageUri);
     }
 
     if (orientation != -1) {
@@ -93,53 +97,69 @@ public void cancel() {
     // Do nothing.
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.LOCAL;
   }
 
   static class VideoThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    VideoThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
-      MediaStore.Video.Thumbnails.DATA
+        MediaStore.Video.Thumbnails.DATA
     };
     private static final String PATH_SELECTION =
         MediaStore.Video.Thumbnails.KIND + " = " + MediaStore.Video.Thumbnails.MINI_KIND
-        + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
+            + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String videoId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { videoId },
+          new String[] {videoId},
           null /*sortOrder*/);
     }
   }
 
 
   static class ImageThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    ImageThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
-      MediaStore.Images.Thumbnails.DATA,
+        MediaStore.Images.Thumbnails.DATA,
     };
     private static final String PATH_SELECTION =
         MediaStore.Images.Thumbnails.KIND + " = " + MediaStore.Images.Thumbnails.MINI_KIND
-        + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
+            + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String imageId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { imageId },
+          new String[] {imageId},
           null /*sortOrder*/);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
index befebff43..07474cd13 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
 
 interface ThumbnailQuery {
-  Cursor query(Context context, Uri uri);
+  Cursor query(Uri uri);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index 9b9f899f8..7749477ac 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -1,85 +1,110 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
+import android.content.ContentResolver;
 import android.database.Cursor;
 import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.List;
 
 class ThumbnailStreamOpener {
   private static final String TAG = "ThumbStreamOpener";
   private static final FileService DEFAULT_SERVICE = new FileService();
+
   private final FileService service;
   private final ThumbnailQuery query;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
+  private final ContentResolver contentResolver;
+  private final List<ImageHeaderParser> parsers;
 
-  public ThumbnailStreamOpener(ThumbnailQuery query, ByteArrayPool byteArrayPool) {
-    this(DEFAULT_SERVICE, query, byteArrayPool);
+  ThumbnailStreamOpener(
+      List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
+    this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
-  public ThumbnailStreamOpener(FileService service, ThumbnailQuery query,
-      ByteArrayPool byteArrayPool) {
+  ThumbnailStreamOpener(
+      List<ImageHeaderParser> parsers,
+      FileService service,
+      ThumbnailQuery query,
+      ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
     this.service = service;
     this.query = query;
     this.byteArrayPool = byteArrayPool;
+    this.contentResolver = contentResolver;
+    this.parsers = parsers;
   }
 
-  public int getOrientation(Context context, Uri uri) {
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
+  int getOrientation(Uri uri) {
     InputStream is = null;
     try {
-      is = context.getContentResolver().openInputStream(uri);
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
-    } catch (IOException e) {
+      is = contentResolver.openInputStream(uri);
+      return ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") IOException | NullPointerException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "Failed to open uri: " + uri, e);
+        Log.d(TAG, "Failed to open uri: " + uri, e);
       }
     } finally {
       if (is != null) {
-          try {
-              is.close();
-          } catch (IOException e) {
-              // Ignored.
-          }
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
       }
     }
-    return orientation;
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
   }
 
-  public InputStream open(Context context, Uri uri) throws FileNotFoundException {
-    Uri thumbnailUri = null;
-    InputStream inputStream = null;
+  public InputStream open(Uri uri) throws FileNotFoundException {
+    String path = getPath(uri);
+    if (TextUtils.isEmpty(path)) {
+      return null;
+    }
 
-    final Cursor cursor = query.query(context, uri);
+    File file = service.get(path);
+    if (!isValid(file)) {
+      return null;
+    }
+
+    Uri thumbnailUri = Uri.fromFile(file);
     try {
-      if (cursor == null || !cursor.moveToFirst()) {
-        return null;
-      }
-      String path = cursor.getString(0);
-      if (TextUtils.isEmpty(path)) {
-        return null;
-      }
+      return contentResolver.openInputStream(thumbnailUri);
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
+      throw (FileNotFoundException)
+          new FileNotFoundException("NPE opening uri: " + uri + " -> " + thumbnailUri).initCause(e);
+    }
+  }
 
-      File file = service.get(path);
-      if (service.exists(file) && service.length(file) > 0) {
-        thumbnailUri = Uri.fromFile(file);
+  @Nullable
+  private String getPath(@NonNull Uri uri) {
+    final Cursor cursor = query.query(uri);
+    try {
+      if (cursor != null && cursor.moveToFirst()) {
+        return cursor.getString(0);
+      } else {
+        return null;
       }
     } finally {
       if (cursor != null) {
         cursor.close();
       }
     }
-    if (thumbnailUri != null) {
-      inputStream = context.getContentResolver().openInputStream(thumbnailUri);
-    }
-    return inputStream;
+  }
+
+  private boolean isValid(File file) {
+    return service.exists(file) && 0 < service.length(file);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
new file mode 100644
index 000000000..5ccbf7b7f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -0,0 +1,201 @@
+package com.bumptech.glide.load.engine;
+
+import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import com.bumptech.glide.util.Util;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+final class ActiveResources {
+  private static final int MSG_CLEAN_REF = 1;
+
+  private final boolean isActiveResourceRetentionAllowed;
+  private final Handler mainHandler = new Handler(Looper.getMainLooper(), new Callback() {
+    @Override
+    public boolean handleMessage(Message msg) {
+      if (msg.what == MSG_CLEAN_REF) {
+        cleanupActiveReference((ResourceWeakReference) msg.obj);
+        return true;
+      }
+      return false;
+    }
+  });
+  @VisibleForTesting
+  final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
+
+  private ResourceListener listener;
+
+  /**
+   * Lazily instantiate to avoid exceptions if Glide is initialized on a background thread.
+   *
+   * @see <a href="https://github.com/bumptech/glide/issues/295">#295</a>
+   */
+  @Nullable
+  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
+  @Nullable
+  private Thread cleanReferenceQueueThread;
+  private volatile boolean isShutdown;
+  @Nullable
+  private volatile DequeuedResourceCallback cb;
+
+  ActiveResources(boolean isActiveResourceRetentionAllowed) {
+    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
+  }
+
+  void setListener(ResourceListener listener) {
+    this.listener = listener;
+  }
+
+  void activate(Key key, EngineResource<?> resource) {
+    ResourceWeakReference toPut =
+        new ResourceWeakReference(
+            key,
+            resource,
+            getReferenceQueue(),
+            isActiveResourceRetentionAllowed);
+
+    ResourceWeakReference removed = activeEngineResources.put(key, toPut);
+    if (removed != null) {
+      removed.reset();
+    }
+  }
+
+  void deactivate(Key key) {
+    ResourceWeakReference removed = activeEngineResources.remove(key);
+    if (removed != null) {
+      removed.reset();
+    }
+  }
+
+  @Nullable
+  EngineResource<?> get(Key key) {
+    ResourceWeakReference activeRef = activeEngineResources.get(key);
+    if (activeRef == null) {
+      return null;
+    }
+
+    EngineResource<?> active = activeRef.get();
+    if (active == null) {
+      cleanupActiveReference(activeRef);
+    }
+    return active;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
+    Util.assertMainThread();
+    activeEngineResources.remove(ref.key);
+
+    if (!ref.isCacheable || ref.resource == null) {
+      return;
+    }
+    EngineResource<?> newResource =
+        new EngineResource<>(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
+    newResource.setResourceListener(ref.key, listener);
+    listener.onResourceReleased(ref.key, newResource);
+  }
+
+  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
+    if (resourceReferenceQueue == null) {
+      resourceReferenceQueue = new ReferenceQueue<>();
+      cleanReferenceQueueThread = new Thread(new Runnable() {
+        @SuppressWarnings("InfiniteLoopStatement")
+        @Override
+        public void run() {
+          Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+          cleanReferenceQueue();
+        }
+      }, "glide-active-resources");
+      cleanReferenceQueueThread.start();
+    }
+    return resourceReferenceQueue;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void cleanReferenceQueue() {
+    while (!isShutdown) {
+      try {
+        ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();
+        mainHandler.obtainMessage(MSG_CLEAN_REF, ref).sendToTarget();
+
+        // This section for testing only.
+        DequeuedResourceCallback current = cb;
+        if (current != null) {
+          current.onResourceDequeued();
+        }
+        // End for testing only.
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
+  @VisibleForTesting
+  void setDequeuedResourceCallback(DequeuedResourceCallback cb) {
+    this.cb = cb;
+  }
+
+  @VisibleForTesting
+  interface DequeuedResourceCallback {
+    void onResourceDequeued();
+  }
+
+  @VisibleForTesting
+  void shutdown() {
+    isShutdown = true;
+    if (cleanReferenceQueueThread == null) {
+      return;
+    }
+
+    cleanReferenceQueueThread.interrupt();
+    try {
+      cleanReferenceQueueThread.join(TimeUnit.SECONDS.toMillis(5));
+      if (cleanReferenceQueueThread.isAlive()) {
+        throw new RuntimeException("Failed to join in time");
+      }
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  @VisibleForTesting
+  static final class ResourceWeakReference extends WeakReference<EngineResource<?>> {
+    @SuppressWarnings("WeakerAccess") @Synthetic final Key key;
+    @SuppressWarnings("WeakerAccess") @Synthetic final boolean isCacheable;
+
+    @Nullable @SuppressWarnings("WeakerAccess") @Synthetic Resource<?> resource;
+
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    ResourceWeakReference(
+        @NonNull Key key,
+        @NonNull EngineResource<?> referent,
+        @NonNull ReferenceQueue<? super EngineResource<?>> queue,
+        boolean isActiveResourceRetentionAllowed) {
+      super(referent, queue);
+      this.key = Preconditions.checkNotNull(key);
+      this.resource =
+          referent.isCacheable() && isActiveResourceRetentionAllowed
+              ? Preconditions.checkNotNull(referent.getResource()) : null;
+      isCacheable = referent.isCacheable();
+    }
+
+    void reset() {
+      resource = null;
+      clear();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
index bb8284dec..bc19d18eb 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
@@ -1,11 +1,11 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
-
 import java.io.File;
 import java.util.List;
 
@@ -16,7 +16,7 @@
 class DataCacheGenerator implements DataFetcherGenerator,
     DataFetcher.DataCallback<Object> {
 
-  private List<Key> cacheKeys;
+  private final List<Key> cacheKeys;
   private final DecodeHelper<?> helper;
   private final FetcherReadyCallback cb;
 
@@ -51,6 +51,9 @@ public boolean startNext() {
       }
 
       Key sourceId = cacheKeys.get(sourceIdIndex);
+      // PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times
+      // and the actions it performs are much more expensive than a single allocation.
+      @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
       Key originalKey = new DataCacheKey(sourceId, helper.getSignature());
       cacheFile = helper.getDiskCache().get(originalKey);
       if (cacheFile != null) {
@@ -93,7 +96,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(sourceKey, e, loadData.fetcher, DataSource.DATA_DISK_CACHE);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
index 36e9ac5fb..5177438a9 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
-
 import java.security.MessageDigest;
 
 /**
@@ -12,12 +12,12 @@
   private final Key sourceKey;
   private final Key signature;
 
-  public DataCacheKey(Key sourceKey, Key signature) {
+  DataCacheKey(Key sourceKey, Key signature) {
     this.sourceKey = sourceKey;
     this.signature = signature;
   }
 
-  public Key getSourceKey() {
+  Key getSourceKey() {
     return sourceKey;
   }
 
@@ -46,7 +46,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     sourceKey.updateDiskCacheKey(messageDigest);
     signature.updateDiskCacheKey(messageDigest);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
index 85e274eca..59f39bd00 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
@@ -1,9 +1,9 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.cache.DiskCache;
-
 import java.io.File;
 
 /**
@@ -27,7 +27,7 @@
   }
 
   @Override
-  public boolean write(File file) {
+  public boolean write(@NonNull File file) {
     return encoder.encode(data, file, options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
index bd1899d7a..ae7cddb8d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -28,7 +27,7 @@
      * @param sourceKey The id of the loaded data.
      * @param data The loaded data, or null if the load failed.
      * @param fetcher The data fetcher we attempted to load from.
-     * @param dataSource The data souce we were loading from.
+     * @param dataSource The data source we were loading from.
      * @param attemptedKey The key we were loading data from (may be an alternate).
      */
     void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fetcher,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index 285e5fe3e..6a4283f1c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -8,15 +8,17 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DecodeJob.DiskCacheProvider;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
 import com.bumptech.glide.load.resource.UnitTransformation;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 
 final class DecodeHelper<Transcode> {
 
@@ -38,9 +40,10 @@
   private Priority priority;
   private DiskCacheStrategy diskCacheStrategy;
   private boolean isTransformationRequired;
+  private boolean isScaleOnlyOrNoTransform;
 
   @SuppressWarnings("unchecked")
-  <R> DecodeHelper<R> init(
+  <R> void init(
       GlideContext glideContext,
       Object model,
       Key signature,
@@ -53,7 +56,8 @@
       Options options,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
-      DecodeJob.DiskCacheProvider diskCacheProvider) {
+      boolean isScaleOnlyOrNoTransform,
+      DiskCacheProvider diskCacheProvider) {
     this.glideContext = glideContext;
     this.model = model;
     this.signature = signature;
@@ -67,12 +71,8 @@
     this.options = options;
     this.transformations = transformations;
     this.isTransformationRequired = isTransformationRequired;
+    this.isScaleOnlyOrNoTransform = isScaleOnlyOrNoTransform;
 
-    return (DecodeHelper<R>) this;
-  }
-
-  Object getModel() {
-    return model;
   }
 
   void clear() {
@@ -120,6 +120,18 @@ int getHeight() {
     return height;
   }
 
+  ArrayPool getArrayPool() {
+    return glideContext.getArrayPool();
+  }
+
+  Class<?> getTranscodeClass() {
+    return transcodeClass;
+  }
+
+  Class<?> getModelClass() {
+    return model.getClass();
+  }
+
   List<Class<?>> getRegisteredResourceClasses() {
     return glideContext.getRegistry()
         .getRegisteredResourceClasses(model.getClass(), resourceClass, transcodeClass);
@@ -133,11 +145,24 @@ boolean hasLoadPath(Class<?> dataClass) {
     return glideContext.getRegistry().getLoadPath(dataClass, resourceClass, transcodeClass);
   }
 
+  boolean isScaleOnlyOrNoTransform() {
+    return isScaleOnlyOrNoTransform;
+  }
+
   @SuppressWarnings("unchecked")
   <Z> Transformation<Z> getTransformation(Class<Z> resourceClass) {
     Transformation<Z> result = (Transformation<Z>) transformations.get(resourceClass);
-     if (result == null) {
-      if (!transformations.isEmpty() && isTransformationRequired) {
+    if (result == null) {
+      for (Entry<Class<?>, Transformation<?>> entry : transformations.entrySet()) {
+        if (entry.getKey().isAssignableFrom(resourceClass)) {
+          result = (Transformation<Z>) entry.getValue();
+          break;
+        }
+      }
+    }
+
+    if (result == null) {
+      if (transformations.isEmpty() && isTransformationRequired) {
         throw new IllegalArgumentException(
             "Missing transformation for " + resourceClass + ". If you wish to"
                 + " ignore unknown resource types, use the optional transformation methods.");
@@ -163,8 +188,8 @@ boolean isResourceEncoderAvailable(Resource<?> resource) {
 
   boolean isSourceKey(Key key) {
     List<LoadData<?>> loadData = getLoadData();
-    int size = loadData.size();
-    for (int i = 0; i < size; i++) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = loadData.size(); i < size; i++) {
       LoadData<?> current = loadData.get(i);
       if (current.sourceKey.equals(key)) {
         return true;
@@ -178,8 +203,8 @@ boolean isSourceKey(Key key) {
       isLoadDataSet = true;
       loadData.clear();
       List<ModelLoader<Object, ?>> modelLoaders = glideContext.getRegistry().getModelLoaders(model);
-      int size = modelLoaders.size();
-      for (int i = 0; i < size; i++) {
+      //noinspection ForLoopReplaceableByForEach to improve perf
+      for (int i = 0, size = modelLoaders.size(); i < size; i++) {
         ModelLoader<Object, ?> modelLoader = modelLoaders.get(i);
         LoadData<?> current =
             modelLoader.buildLoadData(model, width, height, options);
@@ -196,11 +221,17 @@ boolean isSourceKey(Key key) {
       isCacheKeysSet = true;
       cacheKeys.clear();
       List<LoadData<?>> loadData = getLoadData();
-      int size = loadData.size();
-      for (int i = 0; i < size; i++) {
+      //noinspection ForLoopReplaceableByForEach to improve perf
+      for (int i = 0, size = loadData.size(); i < size; i++) {
         LoadData<?> data = loadData.get(i);
-        cacheKeys.add(data.sourceKey);
-        cacheKeys.addAll(data.alternateKeys);
+        if (!cacheKeys.contains(data.sourceKey)) {
+          cacheKeys.add(data.sourceKey);
+        }
+        for (int j = 0; j < data.alternateKeys.size(); j++) {
+          if (!cacheKeys.contains(data.alternateKeys.get(j))) {
+            cacheKeys.add(data.alternateKeys.get(j));
+          }
+        }
       }
     }
     return cacheKeys;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 222d32249..3fe0bb3d5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -1,8 +1,10 @@
 package com.bumptech.glide.load.engine;
 
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.v4.os.TraceCompat;
 import android.support.v4.util.Pools;
 import android.util.Log;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.Registry;
@@ -15,10 +17,11 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -39,7 +42,7 @@
   private static final String TAG = "DecodeJob";
 
   private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
-  private final List<Exception> exceptions = new ArrayList<>();
+  private final List<Throwable> throwables = new ArrayList<>();
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private final DiskCacheProvider diskCacheProvider;
   private final Pools.Pool<DecodeJob<?>> pool;
@@ -59,6 +62,7 @@
   private Stage stage;
   private RunReason runReason;
   private long startFetchTime;
+  private boolean onlyRetrieveFromCache;
 
   private Thread currentThread;
   private Key currentSourceKey;
@@ -89,6 +93,8 @@
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean isScaleOnlyOrNoTransform,
+      boolean onlyRetrieveFromCache,
       Options options,
       Callback<R> callback,
       int order) {
@@ -105,6 +111,7 @@
         options,
         transformations,
         isTransformationRequired,
+        isScaleOnlyOrNoTransform,
         diskCacheProvider);
     this.glideContext = glideContext;
     this.signature = signature;
@@ -113,6 +120,7 @@
     this.width = width;
     this.height = height;
     this.diskCacheStrategy = diskCacheStrategy;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     this.options = options;
     this.callback = callback;
     this.order = order;
@@ -132,8 +140,8 @@ boolean willDecodeFromCache() {
   /**
    * Called when this object is no longer in use externally.
    *
-   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run}
-   *                           is neither in progress nor will ever be called again.
+   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run} is
+   *                           neither in progress nor will ever be called again.
    */
   void release(boolean isRemovedFromQueue) {
     if (releaseManager.release(isRemovedFromQueue)) {
@@ -142,7 +150,7 @@ void release(boolean isRemovedFromQueue) {
   }
 
   /**
-   * Called when we've finished encoding (either becasue the encode process is complete, or because
+   * Called when we've finished encoding (either because the encode process is complete, or because
    * we don't have anything to encode).
    */
   private void onEncodeComplete() {
@@ -180,12 +188,12 @@ private void releaseInternal() {
     currentFetcher = null;
     startFetchTime = 0L;
     isCancelled = false;
-    exceptions.clear();
+    throwables.clear();
     pool.release(this);
   }
 
   @Override
-  public int compareTo(DecodeJob<?> other) {
+  public int compareTo(@NonNull DecodeJob<?> other) {
     int result = getPriority() - other.getPriority();
     if (result == 0) {
       result = order - other.order;
@@ -210,30 +218,48 @@ public void run() {
     // This should be much more fine grained, but since Java's thread pool implementation silently
     // swallows all otherwise fatal exceptions, this will at least make it obvious to developers
     // that something is failing.
+    TraceCompat.beginSection("DecodeJob#run");
+    // Methods in the try statement can invalidate currentFetcher, so set a local variable here to
+    // ensure that the fetcher is cleaned up either way.
+    DataFetcher<?> localFetcher = currentFetcher;
     try {
       if (isCancelled) {
         notifyFailed();
         return;
       }
       runWrapped();
-    } catch (RuntimeException e) {
+    } catch (Throwable t) {
+      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our
+      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We
+      // are however ensuring that our callbacks are always notified when a load fails. Without this
+      // notification, uncaught throwables never notify the corresponding callbacks, which can cause
+      // loads to silently hang forever, a case that's especially bad for users using Futures on
+      // background threads.
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "DecodeJob threw unexpectedly"
             + ", isCancelled: " + isCancelled
-            + ", stage: " + stage, e);
+            + ", stage: " + stage, t);
       }
       // When we're encoding we've already notified our callback and it isn't safe to do so again.
       if (stage != Stage.ENCODE) {
+        throwables.add(t);
         notifyFailed();
       }
       if (!isCancelled) {
-        throw e;
+        throw t;
+      }
+    } finally {
+      // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call
+      // close in all cases anyway.
+      if (localFetcher != null) {
+        localFetcher.cleanup();
       }
+      TraceCompat.endSection();
     }
   }
 
   private void runWrapped() {
-     switch (runReason) {
+    switch (runReason) {
       case INITIALIZE:
         stage = getNextStage(Stage.INITIALIZE);
         currentGenerator = getNextGenerator();
@@ -290,7 +316,7 @@ private void runGenerators() {
 
   private void notifyFailed() {
     setNotifiedOrThrow();
-    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(exceptions));
+    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));
     callback.onLoadFailed(e);
     onLoadFailed();
   }
@@ -317,7 +343,8 @@ private Stage getNextStage(Stage current) {
         return diskCacheStrategy.decodeCachedData()
             ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
       case DATA_CACHE:
-        return Stage.SOURCE;
+        // Skip loading from source if the user opted to only retrieve the resource from cache.
+        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
       case SOURCE:
       case FINISHED:
         return Stage.FINISHED;
@@ -344,16 +371,22 @@ public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetche
       runReason = RunReason.DECODE_DATA;
       callback.reschedule(this);
     } else {
-      decodeFromRetrievedData();
+      TraceCompat.beginSection("DecodeJob.decodeFromRetrievedData");
+      try {
+        decodeFromRetrievedData();
+      } finally {
+        TraceCompat.endSection();
+      }
     }
   }
 
   @Override
   public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
       DataSource dataSource) {
+    fetcher.cleanup();
     GlideException exception = new GlideException("Fetching data failed", e);
     exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
-    exceptions.add(exception);
+    throwables.add(exception);
     if (Thread.currentThread() != currentThread) {
       runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
       callback.reschedule(this);
@@ -366,15 +399,15 @@ private void decodeFromRetrievedData() {
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logWithTimeAndKey("Retrieved data", startFetchTime,
           "data: " + currentData
-          + ", cache key: " + currentSourceKey
-          + ", fetcher: " + currentFetcher);
+              + ", cache key: " + currentSourceKey
+              + ", fetcher: " + currentFetcher);
     }
     Resource<R> resource = null;
     try {
       resource = decodeFromData(currentFetcher, currentData, currentDataSource);
     } catch (GlideException e) {
       e.setLoggingDetails(currentAttemptingKey, currentDataSource);
-      exceptions.add(e);
+      throwables.add(e);
     }
     if (resource != null) {
       notifyEncodeAndRelease(resource, currentDataSource);
@@ -384,6 +417,10 @@ private void decodeFromRetrievedData() {
   }
 
   private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {
+    if (resource instanceof Initializable) {
+      ((Initializable) resource).initialize();
+    }
+
     Resource<R> result = resource;
     LockedResource<R> lockedResource = null;
     if (deferredEncodeManager.hasResourceToEncode()) {
@@ -402,8 +439,10 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
       if (lockedResource != null) {
         lockedResource.unlock();
       }
-      onEncodeComplete();
     }
+    // Call onEncodeComplete outside the finally block so that it's not called if the encode process
+    // throws.
+    onEncodeComplete();
   }
 
   private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
@@ -430,12 +469,34 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
     return runLoadPath(data, dataSource, path);
   }
 
+  @NonNull
+  private Options getOptionsWithHardwareConfig(DataSource dataSource) {
+    Options options = this.options;
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+      return options;
+    }
+
+    if (options.get(Downsampler.ALLOW_HARDWARE_CONFIG) != null) {
+      return options;
+    }
+
+    if (dataSource == DataSource.RESOURCE_DISK_CACHE
+        || decodeHelper.isScaleOnlyOrNoTransform()) {
+      options = new Options();
+      options.putAll(this.options);
+      options.set(Downsampler.ALLOW_HARDWARE_CONFIG, true);
+    }
+    return options;
+  }
+
   private <Data, ResourceType> Resource<R> runLoadPath(Data data, DataSource dataSource,
       LoadPath<Data, ResourceType, R> path) throws GlideException {
+    Options options = getOptionsWithHardwareConfig(dataSource);
     DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);
     try {
-      return path.load(rewinder, options, width, height,
-          new DecodeCallback<ResourceType>(dataSource));
+      // ResourceType in DecodeCallback below is required for compilation to work with gradle.
+      return path.load(
+          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));
     } finally {
       rewinder.cleanup();
     }
@@ -451,70 +512,87 @@ private void logWithTimeAndKey(String message, long startTime, String extraArgs)
         + Thread.currentThread().getName());
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
-  class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
-
-    private final DataSource dataSource;
-
-    public DecodeCallback(DataSource dataSource) {
-      this.dataSource = dataSource;
+  @Synthetic
+  @NonNull
+  <Z> Resource<Z> onResourceDecoded(DataSource dataSource,
+      @NonNull Resource<Z> decoded) {
+    @SuppressWarnings("unchecked")
+    Class<Z> resourceSubClass = (Class<Z>) decoded.get().getClass();
+    Transformation<Z> appliedTransformation = null;
+    Resource<Z> transformed = decoded;
+    if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
+      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
+      transformed = appliedTransformation.transform(glideContext, decoded, width, height);
+    }
+    // TODO: Make this the responsibility of the Transformation.
+    if (!decoded.equals(transformed)) {
+      decoded.recycle();
+    }
+
+    final EncodeStrategy encodeStrategy;
+    final ResourceEncoder<Z> encoder;
+    if (decodeHelper.isResourceEncoderAvailable(transformed)) {
+      encoder = decodeHelper.getResultEncoder(transformed);
+      encodeStrategy = encoder.getEncodeStrategy(options);
+    } else {
+      encoder = null;
+      encodeStrategy = EncodeStrategy.NONE;
     }
 
-    @Override
-    public Resource<Z> onResourceDecoded(Resource<Z> decoded) {
-      Class<Z> resourceSubClass = getResourceClass(decoded);
-      Transformation<Z> appliedTransformation = null;
-      Resource<Z> transformed = decoded;
-      if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
-        appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
-        transformed = appliedTransformation.transform(decoded, width, height);
+    Resource<Z> result = transformed;
+    boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
+    if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
+        encodeStrategy)) {
+      if (encoder == null) {
+        throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
       }
-      // TODO: Make this the responsibility of the Transformation.
-      if (!decoded.equals(transformed)) {
-        decoded.recycle();
+      final Key key;
+      switch (encodeStrategy) {
+        case SOURCE:
+          key = new DataCacheKey(currentSourceKey, signature);
+          break;
+        case TRANSFORMED:
+          key =
+              new ResourceCacheKey(
+                  decodeHelper.getArrayPool(),
+                  currentSourceKey,
+                  signature,
+                  width,
+                  height,
+                  appliedTransformation,
+                  resourceSubClass,
+                  options);
+          break;
+        default:
+          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
       }
 
-      final EncodeStrategy encodeStrategy;
-      final ResourceEncoder<Z> encoder;
-      if (decodeHelper.isResourceEncoderAvailable(transformed)) {
-        encoder = decodeHelper.getResultEncoder(transformed);
-        encodeStrategy = encoder.getEncodeStrategy(options);
-      } else {
-        encoder = null;
-        encodeStrategy = EncodeStrategy.NONE;
-      }
+      LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
+      deferredEncodeManager.init(key, encoder, lockedResult);
+      result = lockedResult;
+    }
+    return result;
+  }
 
-      Resource<Z> result = transformed;
-      boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
-      if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
-          encodeStrategy)) {
-        if (encoder == null) {
-          throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
-        }
-        final Key key;
-        if (encodeStrategy == EncodeStrategy.SOURCE) {
-          key = new DataCacheKey(currentSourceKey, signature);
-        } else if (encodeStrategy == EncodeStrategy.TRANSFORMED) {
-          key = new ResourceCacheKey(currentSourceKey, signature, width, height,
-              appliedTransformation, resourceSubClass, options);
-        } else {
-          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
-        }
+  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
 
-        LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
-        deferredEncodeManager.init(key, encoder, lockedResult);
-        result = lockedResult;
-      }
-      return result;
+    private final DataSource dataSource;
+
+    @Synthetic
+    DecodeCallback(DataSource dataSource) {
+      this.dataSource = dataSource;
     }
 
-    @SuppressWarnings("unchecked")
-    private Class<Z> getResourceClass(Resource<Z> resource) {
-      return (Class<Z>) resource.get().getClass();
+    @NonNull
+    @Override
+    public Resource<Z> onResourceDecoded(@NonNull Resource<Z> decoded) {
+      return DecodeJob.this.onResourceDecoded(dataSource, decoded);
     }
   }
 
@@ -526,6 +604,9 @@ public DecodeCallback(DataSource dataSource) {
     private boolean isEncodeComplete;
     private boolean isFailed;
 
+    @Synthetic
+    ReleaseManager() { }
+
     synchronized boolean release(boolean isRemovedFromQueue) {
       isReleased = true;
       return isComplete(isRemovedFromQueue);
@@ -553,15 +634,18 @@ private boolean isComplete(boolean isRemovedFromQueue) {
   }
 
   /**
-   * Allows transformed resources to be encoded after the transcoded result is already delivered
-   * to requestors.
+   * Allows transformed resources to be encoded after the transcoded result is already delivered to
+   * requestors.
    */
   private static class DeferredEncodeManager<Z> {
     private Key key;
     private ResourceEncoder<Z> encoder;
     private LockedResource<Z> toEncode;
 
-    // We just need the encoder and resouce type to match, which this will enforce.
+    @Synthetic
+    DeferredEncodeManager() { }
+
+    // We just need the encoder and resource type to match, which this will enforce.
     @SuppressWarnings("unchecked")
     <X> void init(Key key, ResourceEncoder<X> encoder, LockedResource<X> toEncode) {
       this.key = key;
@@ -570,11 +654,13 @@ private boolean isComplete(boolean isRemovedFromQueue) {
     }
 
     void encode(DiskCacheProvider diskCacheProvider, Options options) {
+      TraceCompat.beginSection("DecodeJob.encode");
       try {
         diskCacheProvider.getDiskCache().put(key,
             new DataCacheWriter<>(encoder, toEncode, options));
       } finally {
         toEncode.unlock();
+        TraceCompat.endSection();
       }
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
index 929515277..919dc7584 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
@@ -1,13 +1,13 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools.Pool;
 import android.util.Log;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-
+import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -25,13 +25,13 @@
   private final Class<DataType> dataClass;
   private final List<? extends ResourceDecoder<DataType, ResourceType>> decoders;
   private final ResourceTranscoder<ResourceType, Transcode> transcoder;
-  private final Pool<List<Exception>> listPool;
+  private final Pool<List<Throwable>> listPool;
   private final String failureMessage;
 
   public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
       List<? extends ResourceDecoder<DataType, ResourceType>> decoders,
-      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Exception>> listPool) {
+      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.decoders = decoders;
     this.transcoder = transcoder;
@@ -41,15 +41,16 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
   }
 
   public Resource<Transcode> decode(DataRewinder<DataType> rewinder, int width, int height,
-      Options options, DecodeCallback<ResourceType> callback) throws GlideException {
+      @NonNull Options options, DecodeCallback<ResourceType> callback) throws GlideException {
     Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);
     Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);
-    return transcoder.transcode(transformed);
+    return transcoder.transcode(transformed, options);
   }
 
+  @NonNull
   private Resource<ResourceType> decodeResource(DataRewinder<DataType> rewinder, int width,
-      int height, Options options) throws GlideException {
-    List<Exception> exceptions = listPool.acquire();
+      int height, @NonNull Options options) throws GlideException {
+    List<Throwable> exceptions = Preconditions.checkNotNull(listPool.acquire());
     try {
       return decodeResourceWithList(rewinder, width, height, options, exceptions);
     } finally {
@@ -57,9 +58,11 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
     }
   }
 
+  @NonNull
   private Resource<ResourceType> decodeResourceWithList(DataRewinder<DataType> rewinder, int width,
-      int height, Options options, List<Exception> exceptions) throws GlideException {
+      int height, @NonNull Options options, List<Throwable> exceptions) throws GlideException {
     Resource<ResourceType> result = null;
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0, size = decoders.size(); i < size; i++) {
       ResourceDecoder<DataType, ResourceType> decoder = decoders.get(i);
       try {
@@ -68,7 +71,9 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
           data = rewinder.rewindAndGet();
           result = decoder.decode(data, width, height, options);
         }
-      } catch (IOException e) {
+        // Some decoders throw unexpectedly. If they do, we shouldn't fail the entire load path, but
+        // instead log and continue. See #2406 for an example.
+      } catch (IOException | RuntimeException | OutOfMemoryError e) {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
           Log.v(TAG, "Failed to decode data for " + decoder, e);
         }
@@ -93,6 +98,7 @@ public String toString() {
   }
 
   interface DecodeCallback<ResourceType> {
-    Resource<ResourceType> onResourceDecoded(Resource<ResourceType> resource);
+    @NonNull
+    Resource<ResourceType> onResourceDecoded(@NonNull Resource<ResourceType> resource);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
index 0633c1c16..b110e3121 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
@@ -93,7 +93,7 @@ public boolean decodeCachedData() {
   public static final DiskCacheStrategy RESOURCE = new DiskCacheStrategy() {
     @Override
     public boolean isDataCacheable(DataSource dataSource) {
-      return true;
+      return false;
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 3d1e3133e..dcb320c2d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.engine;
 
-import android.os.Looper;
-import android.os.MessageQueue;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
 import android.util.Log;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -17,13 +17,13 @@
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
-
-import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Responsible for starting loads and managing active and cached resources.
@@ -33,54 +33,61 @@
     EngineResource.ResourceListener {
   private static final String TAG = "Engine";
   private static final int JOB_POOL_SIZE = 150;
-  private final Map<Key, EngineJob> jobs;
+  private final Jobs jobs;
   private final EngineKeyFactory keyFactory;
   private final MemoryCache cache;
   private final EngineJobFactory engineJobFactory;
-  private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
   private final ResourceRecycler resourceRecycler;
   private final LazyDiskCacheProvider diskCacheProvider;
   private final DecodeJobFactory decodeJobFactory;
-
-  // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See
-  // #295.
-  private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
-
-  /**
-   * Allows a request to indicate it no longer is interested in a given load.
-   */
-  public static class LoadStatus {
-    private final EngineJob engineJob;
-    private final ResourceCallback cb;
-
-    public LoadStatus(ResourceCallback cb, EngineJob engineJob) {
-      this.cb = cb;
-      this.engineJob = engineJob;
-    }
-
-    public void cancel() {
-      engineJob.removeCallback(cb);
-    }
+  private final ActiveResources activeResources;
+
+  public Engine(
+      MemoryCache memoryCache,
+      DiskCache.Factory diskCacheFactory,
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
+      GlideExecutor animationExecutor,
+      boolean isActiveResourceRetentionAllowed) {
+    this(
+        memoryCache,
+        diskCacheFactory,
+        diskCacheExecutor,
+        sourceExecutor,
+        sourceUnlimitedExecutor,
+        animationExecutor,
+        /*jobs=*/ null,
+        /*keyFactory=*/ null,
+        /*activeResources=*/ null,
+        /*engineJobFactory=*/ null,
+        /*decodeJobFactory=*/ null,
+        /*resourceRecycler=*/ null,
+        isActiveResourceRetentionAllowed);
   }
 
-  public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
-      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor) {
-    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, null, null, null, null,
-        null, null);
-  }
-
-  // Visible for testing.
-  Engine(MemoryCache cache, DiskCache.Factory diskCacheFactory, GlideExecutor diskCacheExecutor,
-      GlideExecutor sourceExecutor, Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,
-      Map<Key, WeakReference<EngineResource<?>>> activeResources, EngineJobFactory engineJobFactory,
-      DecodeJobFactory decodeJobFactory, ResourceRecycler resourceRecycler) {
+  @VisibleForTesting
+  Engine(MemoryCache cache,
+      DiskCache.Factory diskCacheFactory,
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
+      GlideExecutor animationExecutor,
+      Jobs jobs,
+      EngineKeyFactory keyFactory,
+      ActiveResources activeResources,
+      EngineJobFactory engineJobFactory,
+      DecodeJobFactory decodeJobFactory,
+      ResourceRecycler resourceRecycler,
+      boolean isActiveResourceRetentionAllowed) {
     this.cache = cache;
     this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
     if (activeResources == null) {
-      activeResources = new HashMap<>();
+      activeResources = new ActiveResources(isActiveResourceRetentionAllowed);
     }
     this.activeResources = activeResources;
+    activeResources.setListener(this);
 
     if (keyFactory == null) {
       keyFactory = new EngineKeyFactory();
@@ -88,12 +95,14 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
     this.keyFactory = keyFactory;
 
     if (jobs == null) {
-      jobs = new HashMap<>();
+      jobs = new Jobs();
     }
     this.jobs = jobs;
 
     if (engineJobFactory == null) {
-      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor, this);
+      engineJobFactory =
+          new EngineJobFactory(
+              diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -111,19 +120,26 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
   }
 
   /**
-   * Starts a load for the given arguments. Must be called on the main thread.
+   * Starts a load for the given arguments.
+   *
+   * <p>Must be called on the main thread.
    *
-   * <p> The flow for any request is as follows: <ul> <li>Check the memory cache and provide the
-   * cached resource if present</li> <li>Check the current put of actively used resources and return
-   * the active resource if present</li> <li>Check the current put of in progress loads and add the
-   * cb to the in progress load if present</li> <li>Start a new load</li> </ul> </p>
+   * <p>The flow for any request is as follows:
+   * <ul>
+   *   <li>Check the current set of actively used resources, return the active resource if
+   *   present, and move any newly inactive resources into the memory cache.</li>
+   *   <li>Check the memory cache and provide the cached resource if present.</li>
+   *   <li>Check the current set of in progress loads and add the cb to the in progress load if
+   *   one is present.</li>
+   *   <li>Start a new load.</li>
+   * </ul>
    *
-   * <p> Active resources are those that have been provided to at least one request and have not yet
+   * <p>Active resources are those that have been provided to at least one request and have not yet
    * been released. Once all consumers of a resource have released that resource, the resource then
    * goes to cache. If the resource is ever returned to a new consumer from cache, it is re-added to
    * the active resources. If the resource is evicted from the cache, its resources are recycled and
    * re-used if possible and the resource is discarded. There is no strict requirement that
-   * consumers release their resources so active resources are held weakly. </p>
+   * consumers release their resources so active resources are held weakly.
    *
    * @param width  The target width in pixels of the desired resource.
    * @param height The target height in pixels of the desired resource.
@@ -141,8 +157,12 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean isScaleOnlyOrNoTransform,
       Options options,
       boolean isMemoryCacheable,
+      boolean useUnlimitedSourceExecutorPool,
+      boolean useAnimationPool,
+      boolean onlyRetrieveFromCache,
       ResourceCallback cb) {
     Util.assertMainThread();
     long startTime = LogTime.getLogTime();
@@ -150,25 +170,25 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
     EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
         resourceClass, transcodeClass, options);
 
-    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
-    if (cached != null) {
-      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
+    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
+    if (active != null) {
+      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from cache", startTime, key);
+        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
       }
       return null;
     }
 
-    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
-    if (active != null) {
-      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
+    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
+    if (cached != null) {
+      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
+        logWithTimeAndKey("Loaded resource from cache", startTime, key);
       }
       return null;
     }
 
-    EngineJob current = jobs.get(key);
+    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
     if (current != null) {
       current.addCallback(cb);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -177,23 +197,35 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       return new LoadStatus(cb, current);
     }
 
-    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable);
-    DecodeJob<R> decodeJob = decodeJobFactory.build(
-        glideContext,
-        model,
-        key,
-        signature,
-        width,
-        height,
-        resourceClass,
-        transcodeClass,
-        priority,
-        diskCacheStrategy,
-        transformations,
-        isTransformationRequired,
-        options,
-        engineJob);
+    EngineJob<R> engineJob =
+        engineJobFactory.build(
+            key,
+            isMemoryCacheable,
+            useUnlimitedSourceExecutorPool,
+            useAnimationPool,
+            onlyRetrieveFromCache);
+
+    DecodeJob<R> decodeJob =
+        decodeJobFactory.build(
+            glideContext,
+            model,
+            key,
+            signature,
+            width,
+            height,
+            resourceClass,
+            transcodeClass,
+            priority,
+            diskCacheStrategy,
+            transformations,
+            isTransformationRequired,
+            isScaleOnlyOrNoTransform,
+            onlyRetrieveFromCache,
+            options,
+            engineJob);
+
     jobs.put(key, engineJob);
+
     engineJob.addCallback(cb);
     engineJob.start(decodeJob);
 
@@ -207,20 +239,14 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
   }
 
+  @Nullable
   private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
     if (!isMemoryCacheable) {
       return null;
     }
-
-    EngineResource<?> active = null;
-    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);
-    if (activeRef != null) {
-      active = activeRef.get();
-      if (active != null) {
-        active.acquire();
-      } else {
-        activeResources.remove(key);
-      }
+    EngineResource<?> active = activeResources.get(key);
+    if (active != null) {
+      active.acquire();
     }
 
     return active;
@@ -234,31 +260,30 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     EngineResource<?> cached = getEngineResourceFromCache(key);
     if (cached != null) {
       cached.acquire();
-      activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));
+      activeResources.activate(key, cached);
     }
     return cached;
   }
 
-  @SuppressWarnings("unchecked")
   private EngineResource<?> getEngineResourceFromCache(Key key) {
     Resource<?> cached = cache.remove(key);
 
-    final EngineResource result;
+    final EngineResource<?> result;
     if (cached == null) {
       result = null;
     } else if (cached instanceof EngineResource) {
       // Save an object allocation if we've cached an EngineResource (the typical case).
-      result = (EngineResource) cached;
+      result = (EngineResource<?>) cached;
     } else {
-      result = new EngineResource(cached, true /*isMemoryCacheable*/);
+      result = new EngineResource<>(cached, true /*isMemoryCacheable*/, true /*isRecyclable*/);
     }
     return result;
   }
 
-  public void release(Resource resource) {
+  public void release(Resource<?> resource) {
     Util.assertMainThread();
     if (resource instanceof EngineResource) {
-      ((EngineResource) resource).release();
+      ((EngineResource<?>) resource).release();
     } else {
       throw new IllegalArgumentException("Cannot release anything but an EngineResource");
     }
@@ -266,39 +291,37 @@ public void release(Resource resource) {
 
   @SuppressWarnings("unchecked")
   @Override
-  public void onEngineJobComplete(Key key, EngineResource<?> resource) {
+  public void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
     Util.assertMainThread();
     // A null resource indicates that the load failed, usually due to an exception.
     if (resource != null) {
       resource.setResourceListener(key, this);
 
       if (resource.isCacheable()) {
-        activeResources.put(key, new ResourceWeakReference(key, resource, getReferenceQueue()));
+        activeResources.activate(key, resource);
       }
     }
-    // TODO: should this check that the engine job is still current?
-    jobs.remove(key);
+
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
-  public void onEngineJobCancelled(EngineJob engineJob, Key key) {
+  public void onEngineJobCancelled(EngineJob<?> engineJob, Key key) {
     Util.assertMainThread();
-    EngineJob current = jobs.get(key);
-    if (engineJob.equals(current)) {
-      jobs.remove(key);
-    }
+
+    jobs.removeIfCurrent(key, engineJob);
   }
 
   @Override
-  public void onResourceRemoved(final Resource<?> resource) {
+  public void onResourceRemoved(@NonNull final Resource<?> resource) {
     Util.assertMainThread();
     resourceRecycler.recycle(resource);
   }
 
   @Override
-  public void onResourceReleased(Key cacheKey, EngineResource resource) {
+  public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
     Util.assertMainThread();
-    activeResources.remove(cacheKey);
+    activeResources.deactivate(cacheKey);
     if (resource.isCacheable()) {
       cache.put(cacheKey, resource);
     } else {
@@ -310,13 +333,28 @@ public void clearDiskCache() {
     diskCacheProvider.getDiskCache().clear();
   }
 
-  private ReferenceQueue<EngineResource<?>> getReferenceQueue() {
-    if (resourceReferenceQueue == null) {
-      resourceReferenceQueue = new ReferenceQueue<>();
-      MessageQueue queue = Looper.myQueue();
-      queue.addIdleHandler(new RefQueueIdleHandler(activeResources, resourceReferenceQueue));
+  @VisibleForTesting
+  public void shutdown() {
+    engineJobFactory.shutdown();
+    diskCacheProvider.clearDiskCacheIfCreated();
+    activeResources.shutdown();
+  }
+
+  /**
+   * Allows a request to indicate it no longer is interested in a given load.
+   */
+  public static class LoadStatus {
+    private final EngineJob<?> engineJob;
+    private final ResourceCallback cb;
+
+    LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
+      this.cb = cb;
+      this.engineJob = engineJob;
+    }
+
+    public void cancel() {
+      engineJob.removeCallback(cb);
     }
-    return resourceReferenceQueue;
   }
 
   private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {
@@ -324,10 +362,18 @@ public void clearDiskCache() {
     private final DiskCache.Factory factory;
     private volatile DiskCache diskCache;
 
-    public LazyDiskCacheProvider(DiskCache.Factory factory) {
+    LazyDiskCacheProvider(DiskCache.Factory factory) {
       this.factory = factory;
     }
 
+    @VisibleForTesting
+    synchronized void clearDiskCacheIfCreated() {
+      if (diskCache == null) {
+        return;
+      }
+      diskCache.clear();
+    }
+
     @Override
     public DiskCache getDiskCache() {
       if (diskCache == null) {
@@ -344,47 +390,15 @@ public DiskCache getDiskCache() {
     }
   }
 
-  private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
-    private final Key key;
-
-    public ResourceWeakReference(Key key, EngineResource<?> r,
-        ReferenceQueue<? super EngineResource<?>> q) {
-      super(r, q);
-      this.key = key;
-    }
-  }
-
-  // Responsible for cleaning up the active resource map by remove weak references that have been
-  // cleared.
-  private static class RefQueueIdleHandler implements MessageQueue.IdleHandler {
-    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
-    private final ReferenceQueue<EngineResource<?>> queue;
-
-    public RefQueueIdleHandler(Map<Key, WeakReference<EngineResource<?>>> activeResources,
-        ReferenceQueue<EngineResource<?>> queue) {
-      this.activeResources = activeResources;
-      this.queue = queue;
-    }
-
-    @Override
-    public boolean queueIdle() {
-      ResourceWeakReference ref = (ResourceWeakReference) queue.poll();
-      if (ref != null) {
-        activeResources.remove(ref.key);
-      }
-
-      return true;
-    }
-  }
-
-  // Visible for testing.
+  @VisibleForTesting
   static class DecodeJobFactory {
-    private final DecodeJob.DiskCacheProvider diskCacheProvider;
-    private final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<DecodeJob<?>>() {
+    @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
+    @Synthetic final Pools.Pool<DecodeJob<?>> pool =
+        FactoryPools.simple(JOB_POOL_SIZE,
+            new FactoryPools.Factory<DecodeJob<?>>() {
           @Override
           public DecodeJob<?> create() {
-            return new DecodeJob<Object>(diskCacheProvider, pool);
+            return new DecodeJob<>(diskCacheProvider, pool);
           }
         });
     private int creationOrder;
@@ -406,9 +420,11 @@ public boolean queueIdle() {
         DiskCacheStrategy diskCacheStrategy,
         Map<Class<?>, Transformation<?>> transformations,
         boolean isTransformationRequired,
+        boolean isScaleOnlyOrNoTransform,
+        boolean onlyRetrieveFromCache,
         Options options,
         DecodeJob.Callback<R> callback) {
-      DecodeJob<R> result = (DecodeJob<R>) pool.acquire();
+      DecodeJob<R> result = Preconditions.checkNotNull((DecodeJob<R>) pool.acquire());
       return result.init(
           glideContext,
           model,
@@ -422,36 +438,87 @@ public boolean queueIdle() {
           diskCacheStrategy,
           transformations,
           isTransformationRequired,
+          isScaleOnlyOrNoTransform,
+          onlyRetrieveFromCache,
           options,
           callback,
           creationOrder++);
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class EngineJobFactory {
-    private final GlideExecutor diskCacheExecutor;
-    private final GlideExecutor sourceExecutor;
-    private final EngineJobListener listener;
-    private final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<EngineJob<?>>() {
-          @Override
-          public EngineJob<?> create() {
-            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, listener, pool);
-          }
-        });
-
-    EngineJobFactory(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+    @Synthetic final GlideExecutor diskCacheExecutor;
+    @Synthetic final GlideExecutor sourceExecutor;
+    @Synthetic final GlideExecutor sourceUnlimitedExecutor;
+    @Synthetic final GlideExecutor animationExecutor;
+    @Synthetic final EngineJobListener listener;
+    @Synthetic final Pools.Pool<EngineJob<?>> pool =
+        FactoryPools.simple(
+            JOB_POOL_SIZE,
+            new FactoryPools.Factory<EngineJob<?>>() {
+              @Override
+              public EngineJob<?> create() {
+                return new EngineJob<>(
+                    diskCacheExecutor,
+                    sourceExecutor,
+                    sourceUnlimitedExecutor,
+                    animationExecutor,
+                    listener,
+                    pool);
+              }
+            });
+
+    EngineJobFactory(
+        GlideExecutor diskCacheExecutor,
+        GlideExecutor sourceExecutor,
+        GlideExecutor sourceUnlimitedExecutor,
+        GlideExecutor animationExecutor,
         EngineJobListener listener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
+      this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
+      this.animationExecutor = animationExecutor;
       this.listener = listener;
     }
 
+    @VisibleForTesting
+    void shutdown() {
+      shutdownAndAwaitTermination(diskCacheExecutor);
+      shutdownAndAwaitTermination(sourceExecutor);
+      shutdownAndAwaitTermination(sourceUnlimitedExecutor);
+      shutdownAndAwaitTermination(animationExecutor);
+    }
+
     @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable) {
-      EngineJob<R> result = (EngineJob<R>) pool.acquire();
-      return result.init(key, isMemoryCacheable);
+    <R> EngineJob<R> build(
+        Key key,
+        boolean isMemoryCacheable,
+        boolean useUnlimitedSourceGeneratorPool,
+        boolean useAnimationPool,
+        boolean onlyRetrieveFromCache) {
+      EngineJob<R> result = Preconditions.checkNotNull((EngineJob<R>) pool.acquire());
+      return result.init(
+          key,
+          isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
+    }
+
+    private static void shutdownAndAwaitTermination(ExecutorService pool) {
+      long shutdownSeconds = 5;
+      pool.shutdown();
+      try {
+        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+          pool.shutdownNow();
+          if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+            throw new RuntimeException("Failed to shutdown");
+          }
+        }
+      } catch (InterruptedException ie) {
+        throw new RuntimeException(ie);
+      }
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index c58965ca1..344a15036 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -3,16 +3,17 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -39,9 +40,14 @@
   private final EngineJobListener listener;
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
+  private final GlideExecutor sourceUnlimitedExecutor;
+  private final GlideExecutor animationExecutor;
 
   private Key key;
   private boolean isCacheable;
+  private boolean useUnlimitedSourceGeneratorPool;
+  private boolean useAnimationPool;
+  private boolean onlyRetrieveFromCache;
   private Resource<?> resource;
   private DataSource dataSource;
   private boolean hasResource;
@@ -56,36 +62,65 @@
   // Checked primarily on the main thread, but also on other threads in reschedule.
   private volatile boolean isCancelled;
 
-  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
-      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool) {
-    this(diskCacheExecutor, sourceExecutor, listener, pool, DEFAULT_FACTORY);
+  EngineJob(
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
+      GlideExecutor animationExecutor,
+      EngineJobListener listener,
+      Pools.Pool<EngineJob<?>> pool) {
+    this(
+        diskCacheExecutor,
+        sourceExecutor,
+        sourceUnlimitedExecutor,
+        animationExecutor,
+        listener,
+        pool,
+        DEFAULT_FACTORY);
   }
 
-  // Visible for testing.
-  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
-      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool,
+  @VisibleForTesting
+  EngineJob(
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
+      GlideExecutor animationExecutor,
+      EngineJobListener listener,
+      Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
+    this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
+    this.animationExecutor = animationExecutor;
     this.listener = listener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
 
-  // Visible for testing.
-  EngineJob<R> init(Key key, boolean isCacheable) {
+  @VisibleForTesting
+  EngineJob<R> init(
+      Key key,
+      boolean isCacheable,
+      boolean useUnlimitedSourceGeneratorPool,
+      boolean useAnimationPool,
+      boolean onlyRetrieveFromCache) {
     this.key = key;
     this.isCacheable = isCacheable;
+    this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
+    this.useAnimationPool = useAnimationPool;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     return this;
   }
 
   public void start(DecodeJob<R> decodeJob) {
     this.decodeJob = decodeJob;
-    GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : sourceExecutor;
+    GlideExecutor executor = decodeJob.willDecodeFromCache()
+        ? diskCacheExecutor
+        : getActiveSourceExecutor();
     executor.execute(decodeJob);
   }
 
-  public void addCallback(ResourceCallback cb) {
+  void addCallback(ResourceCallback cb) {
     Util.assertMainThread();
     stateVerifier.throwIfRecycled();
     if (hasResource) {
@@ -97,7 +132,7 @@ public void addCallback(ResourceCallback cb) {
     }
   }
 
-  public void removeCallback(ResourceCallback cb) {
+  void removeCallback(ResourceCallback cb) {
     Util.assertMainThread();
     stateVerifier.throwIfRecycled();
     if (hasResource || hasLoadFailed) {
@@ -110,6 +145,15 @@ public void removeCallback(ResourceCallback cb) {
     }
   }
 
+  boolean onlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
+
+  private GlideExecutor getActiveSourceExecutor() {
+    return useUnlimitedSourceGeneratorPool
+        ? sourceUnlimitedExecutor : (useAnimationPool ? animationExecutor : sourceExecutor);
+  }
+
   // We cannot remove callbacks while notifying our list of callbacks directly because doing so
   // would cause a ConcurrentModificationException. However, we need to obey the cancellation
   // request such that if notifying a callback early in the callbacks list cancels a callback later
@@ -136,13 +180,9 @@ void cancel() {
 
     isCancelled = true;
     decodeJob.cancel();
-    boolean isPendingJobRemoved =
-        diskCacheExecutor.remove(decodeJob) || sourceExecutor.remove(decodeJob);
+    // TODO: Consider trying to remove jobs that have never been run before from executor queues.
+    // Removing jobs that have run before can break things. See #1996.
     listener.onEngineJobCancelled(this, key);
-
-    if (isPendingJobRemoved) {
-      release(true /*isRemovedFromQueue*/);
-    }
   }
 
   // Exposed for testing.
@@ -150,7 +190,8 @@ boolean isCancelled() {
     return isCancelled;
   }
 
-  private void handleResultOnMainThread() {
+  @Synthetic
+  void handleResultOnMainThread() {
     stateVerifier.throwIfRecycled();
     if (isCancelled) {
       resource.recycle();
@@ -167,9 +208,11 @@ private void handleResultOnMainThread() {
     // Hold on to resource for duration of request so we don't recycle it in the middle of
     // notifying if it synchronously released by one of the callbacks.
     engineResource.acquire();
-    listener.onEngineJobComplete(key, engineResource);
+    listener.onEngineJobComplete(this, key, engineResource);
 
-    for (ResourceCallback cb : cbs) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = cbs.size(); i < size; i++) {
+      ResourceCallback cb = cbs.get(i);
       if (!isInIgnoredCallbacks(cb)) {
         engineResource.acquire();
         cb.onResourceReady(engineResource, dataSource);
@@ -181,7 +224,8 @@ private void handleResultOnMainThread() {
     release(false /*isRemovedFromQueue*/);
   }
 
-  private void handleCancelledOnMainThread() {
+  @Synthetic
+  void handleCancelledOnMainThread() {
     stateVerifier.throwIfRecycled();
     if (!isCancelled) {
       throw new IllegalStateException("Not cancelled");
@@ -224,14 +268,13 @@ public void onLoadFailed(GlideException e) {
 
   @Override
   public void reschedule(DecodeJob<?> job) {
-    if (isCancelled) {
-      MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();
-    } else {
-      sourceExecutor.execute(job);
-    }
+    // Even if the job is cancelled here, it still needs to be scheduled so that it can clean itself
+    // up.
+    getActiveSourceExecutor().execute(job);
   }
 
-  private void handleExceptionOnMainThread() {
+  @Synthetic
+  void handleExceptionOnMainThread() {
     stateVerifier.throwIfRecycled();
     if (isCancelled) {
       release(false /*isRemovedFromQueue*/);
@@ -243,7 +286,7 @@ private void handleExceptionOnMainThread() {
     }
     hasLoadFailed = true;
 
-    listener.onEngineJobComplete(key, null);
+    listener.onEngineJobComplete(this, key, null);
 
     for (ResourceCallback cb : cbs) {
       if (!isInIgnoredCallbacks(cb)) {
@@ -254,23 +297,28 @@ private void handleExceptionOnMainThread() {
     release(false /*isRemovedFromQueue*/);
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class EngineResourceFactory {
     public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
-      return new EngineResource<>(resource, isMemoryCacheable);
+      return new EngineResource<>(resource, isMemoryCacheable, /*isRecyclable=*/ true);
     }
   }
 
   private static class MainThreadCallback implements Handler.Callback {
 
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    MainThreadCallback() { }
+
     @Override
     public boolean handleMessage(Message message) {
-      EngineJob job = (EngineJob) message.obj;
+      EngineJob<?> job = (EngineJob<?>) message.obj;
       switch (message.what) {
         case MSG_COMPLETE:
           job.handleResultOnMainThread();
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
index 0d3c2e410..4b068286f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java
@@ -4,7 +4,7 @@
 
 interface EngineJobListener {
 
-  void onEngineJobComplete(Key key, EngineResource<?> resource);
+  void onEngineJobComplete(EngineJob<?> engineJob, Key key, EngineResource<?> resource);
 
-  void onEngineJobCancelled(EngineJob engineJob, Key key);
+  void onEngineJobCancelled(EngineJob<?> engineJob, Key key);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index 855f48b04..9f16b6115 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 import java.util.Map;
 
@@ -22,9 +22,15 @@
   private final Options options;
   private int hashCode;
 
-  public EngineKey(Object model, Key signature, int width, int height,
-      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
-      Class<?> transcodeClass, Options options) {
+  EngineKey(
+      Object model,
+      Key signature,
+      int width,
+      int height,
+      Map<Class<?>, Transformation<?>> transformations,
+      Class<?> resourceClass,
+      Class<?> transcodeClass,
+      Options options) {
     this.model = Preconditions.checkNotNull(model);
     this.signature = Preconditions.checkNotNull(signature, "Signature must not be null");
     this.width = width;
@@ -84,7 +90,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     throw new UnsupportedOperationException();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
index b458d3132..05e7a55a0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
@@ -3,13 +3,12 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
-
 import java.util.Map;
 
 class EngineKeyFactory {
 
   @SuppressWarnings("rawtypes")
-  public EngineKey buildKey(Object model, Key signature, int width, int height,
+  EngineKey buildKey(Object model, Key signature, int width, int height,
       Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
       Class<?> transcodeClass, Options options) {
     return new EngineKey(model, signature, width, height, transformations, resourceClass,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index 0ba087590..75bb1b841 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Looper;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 
@@ -13,6 +13,7 @@
  */
 class EngineResource<Z> implements Resource<Z> {
   private final boolean isCacheable;
+  private final boolean isRecyclable;
   private ResourceListener listener;
   private Key key;
   private int acquired;
@@ -23,9 +24,10 @@
     void onResourceReleased(Key key, EngineResource<?> resource);
   }
 
-  EngineResource(Resource<Z> toWrap, boolean isCacheable) {
+  EngineResource(Resource<Z> toWrap, boolean isCacheable, boolean isRecyclable) {
     resource = Preconditions.checkNotNull(toWrap);
     this.isCacheable = isCacheable;
+    this.isRecyclable = isRecyclable;
   }
 
   void setResourceListener(Key key, ResourceListener listener) {
@@ -33,15 +35,21 @@ void setResourceListener(Key key, ResourceListener listener) {
     this.listener = listener;
   }
 
+  Resource<Z> getResource() {
+    return resource;
+  }
+
   boolean isCacheable() {
     return isCacheable;
   }
 
+  @NonNull
   @Override
   public Class<Z> getResourceClass() {
     return resource.getResourceClass();
   }
 
+  @NonNull
   @Override
   public Z get() {
     return resource.get();
@@ -61,7 +69,9 @@ public void recycle() {
       throw new IllegalStateException("Cannot recycle a resource that has already been recycled");
     }
     isRecycled = true;
-    resource.recycle();
+    if (isRecyclable) {
+      resource.recycle();
+    }
   }
 
   /**
@@ -87,9 +97,9 @@ void acquire() {
    * Decrements the number of consumers using the wrapped resource. Must be called on the main
    * thread.
    *
-   * <p> This must only be called when a consumer that called the {@link #acquire()} method is now
-   * done with the resource. Generally external users should never callthis method, the framework
-   * will take care of this for you. </p>
+   * <p>This must only be called when a consumer that called the {@link #acquire()} method is now
+   * done with the resource. Generally external users should never call this method, the framework
+   * will take care of this for you.
    */
   void release() {
     if (acquired <= 0) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index 070017e78..79d05eff5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
-
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.PrintWriter;
@@ -15,24 +15,29 @@
 /**
  * An exception with zero or more causes indicating why a load in Glide failed.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class GlideException extends Exception {
+  private static final long serialVersionUID = 1L;
+
   private static final StackTraceElement[] EMPTY_ELEMENTS = new StackTraceElement[0];
 
-  private final List<Exception> causes;
+  private final List<Throwable> causes;
   private Key key;
   private DataSource dataSource;
   private Class<?> dataClass;
+  private String detailMessage;
 
   public GlideException(String message) {
-    this(message, Collections.<Exception>emptyList());
+    this(message, Collections.<Throwable>emptyList());
   }
 
-  public GlideException(String detailMessage, Exception cause) {
+  public GlideException(String detailMessage, Throwable cause) {
     this(detailMessage, Collections.singletonList(cause));
   }
 
-  public GlideException(String detailMessage, List<Exception> causes) {
-    super(detailMessage);
+  public GlideException(String detailMessage, List<Throwable> causes) {
+    this.detailMessage = detailMessage;
     setStackTrace(EMPTY_ELEMENTS);
     this.causes = causes;
   }
@@ -47,6 +52,10 @@ void setLoggingDetails(Key key, DataSource dataSource, Class<?> dataClass) {
     this.dataClass = dataClass;
   }
 
+
+
+  // No need to synchronize when doing nothing whatsoever.
+  @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
   public Throwable fillInStackTrace() {
     // Avoid an expensive allocation by doing nothing here. Causes should contain all relevant
@@ -57,12 +66,12 @@ public Throwable fillInStackTrace() {
   /**
    * Returns a list of causes that are immediate children of this exception.
    *
-   * @see #getRootCauses().
-   *
    * <p>Causes may or may not be {@link GlideException GlideExceptions}. Causes may also not be root
-   * causes, and in turn my have been caused by other failures.
+   * causes, and in turn my have been caused by other failures.</p>
+   *
+   * @see #getRootCauses()
    */
-  public List<Exception> getCauses() {
+  public List<Throwable> getCauses() {
     return causes;
   }
 
@@ -74,8 +83,8 @@ public Throwable fillInStackTrace() {
    * a given model using multiple different pathways, there may be multiple related or unrelated
    * reasons for a load to fail.
    */
-  public List<Exception> getRootCauses() {
-    List<Exception> rootCauses = new ArrayList<>();
+  public List<Throwable> getRootCauses() {
+    List<Throwable> rootCauses = new ArrayList<>();
     addRootCauses(this, rootCauses);
     return rootCauses;
   }
@@ -88,21 +97,20 @@ public Throwable fillInStackTrace() {
    * complete stack traces.
    */
   public void logRootCauses(String tag) {
-    Log.e(tag, getClass() + ": " + getMessage());
-    List<Exception> causes = getRootCauses();
+    List<Throwable> causes = getRootCauses();
     for (int i = 0, size = causes.size(); i < size; i++) {
       Log.i(tag, "Root cause (" + (i + 1) + " of " + size + ")", causes.get(i));
     }
   }
 
-  private void addRootCauses(Exception exception, List<Exception> rootCauses) {
-    if (exception instanceof GlideException) {
-      GlideException glideException = (GlideException) exception;
-      for (Exception e : glideException.getCauses()) {
-        addRootCauses(e, rootCauses);
+  private void addRootCauses(Throwable throwable, List<Throwable> rootCauses) {
+    if (throwable instanceof GlideException) {
+      GlideException glideException = (GlideException) throwable;
+      for (Throwable t : glideException.getCauses()) {
+        addRootCauses(t, rootCauses);
       }
     } else {
-      rootCauses.add(exception);
+      rootCauses.add(throwable);
     }
   }
 
@@ -126,29 +134,47 @@ private void printStackTrace(Appendable appendable) {
     appendCauses(getCauses(), new IndentedAppendable(appendable));
   }
 
+  // PMD doesn't seem to notice that we're allocating the builder with the suggested size.
+  @SuppressWarnings("PMD.InsufficientStringBufferDeclaration")
   @Override
   public String getMessage() {
-    return super.getMessage()
-        + (dataClass != null ? ", " + dataClass : "")
-        + (dataSource != null ? ", " + dataSource : "")
-        + (key != null ? ", " + key : "");
+    StringBuilder result = new StringBuilder(71)
+        .append(detailMessage)
+        .append(dataClass != null ? ", " + dataClass : "")
+        .append(dataSource != null ? ", " + dataSource : "")
+        .append(key != null ? ", " + key : "");
+
+    List<Throwable> rootCauses = getRootCauses();
+    if (rootCauses.isEmpty()) {
+      return result.toString();
+    } else if (rootCauses.size() == 1) {
+      result.append("\nThere was 1 cause:");
+    } else {
+      result.append("\nThere were ").append(rootCauses.size()).append(" causes:");
+    }
+    for (Throwable cause : rootCauses) {
+      result.append('\n')
+          .append(cause.getClass().getName()).append('(').append(cause.getMessage()).append(')');
+    }
+    result.append("\n call GlideException#logRootCauses(String) for more detail");
+    return result.toString();
   }
 
   // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
   // never happen.
   @SuppressWarnings("PMD.PreserveStackTrace")
-  private static void appendExceptionMessage(Exception e, Appendable appendable) {
+  private static void appendExceptionMessage(Throwable t, Appendable appendable) {
     try {
-      appendable.append(e.getClass().toString()).append(": ").append(e.getMessage()).append('\n');
+      appendable.append(t.getClass().toString()).append(": ").append(t.getMessage()).append('\n');
     } catch (IOException e1) {
-      throw new RuntimeException(e);
+      throw new RuntimeException(t);
     }
   }
 
   // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
   // never happen.
   @SuppressWarnings("PMD.PreserveStackTrace")
-  private static void appendCauses(List<Exception> causes, Appendable appendable) {
+  private static void appendCauses(List<Throwable> causes, Appendable appendable) {
     try {
       appendCausesWrapped(causes, appendable);
     } catch (IOException e) {
@@ -157,7 +183,7 @@ private static void appendCauses(List<Exception> causes, Appendable appendable)
   }
 
   @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
-  private static void appendCausesWrapped(List<Exception> causes, Appendable appendable)
+  private static void appendCausesWrapped(List<Throwable> causes, Appendable appendable)
       throws IOException {
     int size = causes.size();
     for (int i = 0; i < size; i++) {
@@ -167,7 +193,7 @@ private static void appendCausesWrapped(List<Exception> causes, Appendable appen
           .append(String.valueOf(size))
           .append("): ");
 
-      Exception cause = causes.get(i);
+      Throwable cause = causes.get(i);
       if (cause instanceof GlideException) {
         GlideException glideCause = (GlideException) cause;
         glideCause.printStackTrace(appendable);
@@ -178,6 +204,7 @@ private static void appendCausesWrapped(List<Exception> causes, Appendable appen
   }
 
   private static final class IndentedAppendable implements Appendable {
+    private static final String EMPTY_SEQUENCE = "";
     private static final String INDENT = "  ";
     private final Appendable appendable;
     private boolean printedNewLine = true;
@@ -198,19 +225,31 @@ public Appendable append(char c) throws IOException {
     }
 
     @Override
-    public Appendable append(CharSequence charSequence) throws IOException {
+    public Appendable append(@Nullable CharSequence charSequence) throws IOException {
+      charSequence = safeSequence(charSequence);
       return append(charSequence, 0, charSequence.length());
     }
 
     @Override
-    public Appendable append(CharSequence csq, int start, int end) throws IOException {
+    public Appendable append(@Nullable CharSequence charSequence, int start, int end)
+        throws IOException {
+      charSequence = safeSequence(charSequence);
       if (printedNewLine) {
         printedNewLine = false;
         appendable.append(INDENT);
       }
-      printedNewLine = csq.length() > 0 && csq.charAt(end - 1) == '\n';
-      appendable.append(csq, start, end);
+      printedNewLine = charSequence.length() > 0 && charSequence.charAt(end - 1) == '\n';
+      appendable.append(charSequence, start, end);
       return this;
     }
+
+    @NonNull
+    private CharSequence safeSequence(@Nullable CharSequence sequence) {
+      if (sequence == null) {
+        return EMPTY_SEQUENCE;
+      } else {
+        return sequence;
+      }
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
new file mode 100644
index 000000000..9b34820b1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.load.engine;
+
+/**
+ * A callback allowing a resource to do some optimization on a background thread before being
+ * returned to the ui.
+ */
+public interface Initializable {
+
+  /**
+   * Called on a background thread so the {@link Resource} can do some eager initialization.
+   */
+  void initialize();
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
new file mode 100644
index 000000000..93b3106f7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Jobs.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Key;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+final class Jobs {
+  private final Map<Key, EngineJob<?>> jobs = new HashMap<>();
+  private final Map<Key, EngineJob<?>> onlyCacheJobs = new HashMap<>();
+
+  @VisibleForTesting
+  Map<Key, EngineJob<?>> getAll() {
+    return Collections.unmodifiableMap(jobs);
+  }
+
+  EngineJob<?> get(Key key, boolean onlyRetrieveFromCache) {
+    return getJobMap(onlyRetrieveFromCache).get(key);
+  }
+
+  void put(Key key, EngineJob<?> job) {
+    getJobMap(job.onlyRetrieveFromCache()).put(key, job);
+  }
+
+  void removeIfCurrent(Key key, EngineJob<?> expected) {
+    Map<Key, EngineJob<?>> jobMap = getJobMap(expected.onlyRetrieveFromCache());
+    if (expected.equals(jobMap.get(key))) {
+      jobMap.remove(key);
+    }
+  }
+
+  private Map<Key, EngineJob<?>> getJobMap(boolean onlyRetrieveFromCache) {
+    return onlyRetrieveFromCache ? onlyCacheJobs : jobs;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
index 4df0cc8ed..dca8f8952 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
@@ -1,11 +1,10 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -23,13 +22,13 @@
  */
 public class LoadPath<Data, ResourceType, Transcode> {
   private final Class<Data> dataClass;
-  private final Pool<List<Exception>> listPool;
+  private final Pool<List<Throwable>> listPool;
   private final List<? extends DecodePath<Data, ResourceType, Transcode>> decodePaths;
   private final String failureMessage;
 
   public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
       Class<Transcode> transcodeClass,
-      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Exception>> listPool) {
+      List<DecodePath<Data, ResourceType, Transcode>> decodePaths, Pool<List<Throwable>> listPool) {
     this.dataClass = dataClass;
     this.listPool = listPool;
     this.decodePaths = Preconditions.checkNotEmpty(decodePaths);
@@ -37,22 +36,23 @@ public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
         + resourceClass.getSimpleName() + "->" + transcodeClass.getSimpleName() + "}";
   }
 
-  public Resource<Transcode> load(DataRewinder<Data> rewinder, Options options, int width,
+  public Resource<Transcode> load(DataRewinder<Data> rewinder, @NonNull Options options, int width,
       int height, DecodePath.DecodeCallback<ResourceType> decodeCallback) throws GlideException {
-    List<Exception> exceptions = listPool.acquire();
+    List<Throwable> throwables = Preconditions.checkNotNull(listPool.acquire());
     try {
-      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, exceptions);
+      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);
     } finally {
-      listPool.release(exceptions);
+      listPool.release(throwables);
     }
   }
 
-  private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder, Options options,
+  private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder,
+      @NonNull Options options,
       int width, int height, DecodePath.DecodeCallback<ResourceType> decodeCallback,
-      List<Exception> exceptions) throws GlideException {
-    int size = decodePaths.size();
+      List<Throwable> exceptions) throws GlideException {
     Resource<Transcode> result = null;
-    for (int i = 0; i < size; i++) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = decodePaths.size(); i < size; i++) {
       DecodePath<Data, ResourceType, Transcode> path = decodePaths.get(i);
       try {
         result = path.decode(rewinder, width, height, options, decodeCallback);
@@ -77,7 +77,6 @@ public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
 
   @Override
   public String toString() {
-    return "LoadPath{" + "decodePaths="
-        + Arrays.toString(decodePaths.toArray(new DecodePath[decodePaths.size()])) + '}';
+    return "LoadPath{" + "decodePaths=" + Arrays.toString(decodePaths.toArray()) + '}';
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
index 3e21cc186..594b26441 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools;
-
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
 
@@ -27,13 +29,16 @@
   private boolean isRecycled;
 
   @SuppressWarnings("unchecked")
+  @NonNull
   static <Z> LockedResource<Z> obtain(Resource<Z> resource) {
-    LockedResource<Z> result = (LockedResource<Z>) POOL.acquire();
+    LockedResource<Z> result = Preconditions.checkNotNull((LockedResource<Z>) POOL.acquire());
     result.init(resource);
     return result;
   }
 
-  private LockedResource() { }
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  LockedResource() { }
 
   private void init(Resource<Z> toWrap) {
     isRecycled = false;
@@ -46,7 +51,7 @@ private void release() {
     POOL.release(this);
   }
 
-  public synchronized void unlock() {
+  synchronized void unlock() {
     stateVerifier.throwIfRecycled();
 
     if (!isLocked) {
@@ -58,11 +63,13 @@ public synchronized void unlock() {
     }
   }
 
+  @NonNull
   @Override
   public Class<Z> getResourceClass() {
     return toWrap.getResourceClass();
   }
 
+  @NonNull
   @Override
   public Z get() {
     return toWrap.get();
@@ -84,6 +91,7 @@ public synchronized void recycle() {
     }
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
index 3717a889d..6667381ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 
 /**
  * A resource interface that wraps a particular type so that it can be pooled and reused.
@@ -11,6 +12,7 @@
   /**
    * Returns the {@link Class} of the wrapped resource.
    */
+  @NonNull
   Class<Z> getResourceClass();
 
   /**
@@ -23,6 +25,7 @@
    * {@link android.graphics.drawable.Drawable Drawable}s should always return a new
    * {@link android.graphics.drawable.Drawable Drawable}. </p>
    */
+  @NonNull
   Z get();
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index 65c0decd0..4e427b920 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
-
 import java.io.File;
 import java.util.List;
 
@@ -20,7 +20,7 @@
   private final FetcherReadyCallback cb;
   private final DecodeHelper<?> helper;
 
-  private int sourceIdIndex = 0;
+  private int sourceIdIndex;
   private int resourceClassIndex = -1;
   private Key sourceKey;
   private List<ModelLoader<File, ?>> modelLoaders;
@@ -32,7 +32,7 @@
   private File cacheFile;
   private ResourceCacheKey currentKey;
 
-  public ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+  ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
     this.helper = helper;
     this.cb = cb;
   }
@@ -40,7 +40,18 @@ public ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
   @Override
   public boolean startNext() {
     List<Key> sourceIds = helper.getCacheKeys();
+    if (sourceIds.isEmpty()) {
+      return false;
+    }
     List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
+    if (resourceClasses.isEmpty()) {
+      if (File.class.equals(helper.getTranscodeClass())) {
+        return false;
+      }
+      throw new IllegalStateException(
+          "Failed to find any load path from " + helper.getModelClass() + " to "
+              + helper.getTranscodeClass());
+    }
     while (modelLoaders == null || !hasNextModelLoader()) {
       resourceClassIndex++;
       if (resourceClassIndex >= resourceClasses.size()) {
@@ -54,12 +65,22 @@ public boolean startNext() {
       Key sourceId = sourceIds.get(sourceIdIndex);
       Class<?> resourceClass = resourceClasses.get(resourceClassIndex);
       Transformation<?> transformation = helper.getTransformation(resourceClass);
-
-      currentKey = new ResourceCacheKey(sourceId, helper.getSignature(), helper.getWidth(),
-          helper.getHeight(), transformation, resourceClass, helper.getOptions());
+      // PMD.AvoidInstantiatingObjectsInLoops Each iteration is comparatively expensive anyway,
+      // we only run until the first one succeeds, the loop runs for only a limited
+      // number of iterations on the order of 10-20 in the worst case.
+      currentKey =
+          new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops
+              helper.getArrayPool(),
+              sourceId,
+              helper.getSignature(),
+              helper.getWidth(),
+              helper.getHeight(),
+              transformation,
+              resourceClass,
+              helper.getOptions());
       cacheFile = helper.getDiskCache().get(currentKey);
       if (cacheFile != null) {
-        this.sourceKey = sourceId;
+        sourceKey = sourceId;
         modelLoaders = helper.getModelLoaders(cacheFile);
         modelLoaderIndex = 0;
       }
@@ -69,9 +90,8 @@ public boolean startNext() {
     boolean started = false;
     while (!started && hasNextModelLoader()) {
       ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
-      loadData =
-          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),
-              helper.getOptions());
+      loadData = modelLoader.buildLoadData(cacheFile,
+          helper.getWidth(), helper.getHeight(), helper.getOptions());
       if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
@@ -100,7 +120,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(currentKey, e, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
index ea3f11714..afd18a739 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -1,10 +1,12 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.LruCache;
-
+import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -13,6 +15,7 @@
  */
 final class ResourceCacheKey implements Key {
   private static final LruCache<Class<?>, byte[]> RESOURCE_CLASS_BYTES = new LruCache<>(50);
+  private final ArrayPool arrayPool;
   private final Key sourceKey;
   private final Key signature;
   private final int width;
@@ -21,8 +24,16 @@
   private final Options options;
   private final Transformation<?> transformation;
 
-  public ResourceCacheKey(Key sourceKey, Key signature, int width, int height,
-      Transformation<?> appliedTransformation, Class<?> decodedResourceClass, Options options) {
+  ResourceCacheKey(
+      ArrayPool arrayPool,
+      Key sourceKey,
+      Key signature,
+      int width,
+      int height,
+      Transformation<?> appliedTransformation,
+      Class<?> decodedResourceClass,
+      Options options) {
+    this.arrayPool = arrayPool;
     this.sourceKey = sourceKey;
     this.signature = signature;
     this.width = width;
@@ -37,10 +48,10 @@ public boolean equals(Object o) {
     if (o instanceof ResourceCacheKey) {
       ResourceCacheKey other = (ResourceCacheKey) o;
       return height == other.height && width == other.width
-          && (transformation == null
-              ? other.transformation == null : transformation.equals(other.transformation))
+          && Util.bothNullOrEqual(transformation, other.transformation)
           && decodedResourceClass.equals(other.decodedResourceClass)
-          && sourceKey.equals(other.sourceKey) && signature.equals(other.signature)
+          && sourceKey.equals(other.sourceKey)
+          && signature.equals(other.signature)
           && options.equals(other.options);
     }
     return false;
@@ -62,8 +73,9 @@ public int hashCode() {
 
   // TODO: Include relevant options?
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    byte[] dimensions = ByteBuffer.allocate(8).putInt(width).putInt(height).array();
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    byte[] dimensions = arrayPool.getExact(8, byte[].class);
+    ByteBuffer.wrap(dimensions).putInt(width).putInt(height).array();
     signature.updateDiskCacheKey(messageDigest);
     sourceKey.updateDiskCacheKey(messageDigest);
     messageDigest.update(dimensions);
@@ -72,6 +84,7 @@ public void updateDiskCacheKey(MessageDigest messageDigest) {
     }
     options.updateDiskCacheKey(messageDigest);
     messageDigest.update(getResourceClassBytes());
+    arrayPool.put(dimensions);
   }
 
   private byte[] getResourceClassBytes() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
index ddd5d55cb..4ad3cf905 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -3,7 +3,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 
 /**
@@ -14,7 +14,7 @@
   private final Handler handler =
       new Handler(Looper.getMainLooper(), new ResourceRecyclerCallback());
 
-  public void recycle(Resource<?> resource) {
+  void recycle(Resource<?> resource) {
     Util.assertMainThread();
 
     if (isRecycling) {
@@ -30,13 +30,16 @@ public void recycle(Resource<?> resource) {
     }
   }
 
-  private static class ResourceRecyclerCallback implements Handler.Callback {
-    public static final int RECYCLE_RESOURCE = 1;
+  private static final class ResourceRecyclerCallback implements Handler.Callback {
+    static final int RECYCLE_RESOURCE = 1;
+
+    @Synthetic
+    ResourceRecyclerCallback() { }
 
     @Override
     public boolean handleMessage(Message message) {
       if (message.what == RECYCLE_RESOURCE) {
-        Resource resource = (Resource) message.obj;
+        Resource<?> resource = (Resource<?>) message.obj;
         resource.recycle();
         return true;
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
index 275ea1b06..5a57b971b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
@@ -9,7 +9,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
 import com.bumptech.glide.util.LogTime;
-
 import java.util.Collections;
 
 /**
@@ -34,7 +33,7 @@
   private volatile ModelLoader.LoadData<?> loadData;
   private DataCacheKey originalKey;
 
-  public SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
+  SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
     this.helper = helper;
     this.cb = cb;
   }
@@ -116,7 +115,7 @@ public void onDataReady(Object data) {
   }
 
   @Override
-  public void onLoadFailed(Exception e) {
+  public void onLoadFailed(@NonNull Exception e) {
     cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
new file mode 100644
index 000000000..e53c49de4
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+/**
+ * Interface for handling operations on a primitive array type.
+ * @param <T> Array type (e.g. byte[], int[])
+ */
+interface ArrayAdapterInterface<T> {
+
+  /**
+   * TAG for logging.
+   */
+  String getTag();
+
+  /**
+   * Return the length of the given array.
+   */
+  int getArrayLength(T array);
+
+  /**
+   * Allocate and return an array of the specified size.
+   */
+  T newArray(int length);
+
+  /**
+   * Return the size of an element in the array in bytes (e.g. for int return 4).
+   */
+  int getElementSizeInBytes();
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
new file mode 100644
index 000000000..7cb169dbb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -0,0 +1,66 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+/**
+ * Interface for an array pool that pools arrays of different types.
+ */
+public interface ArrayPool {
+  /**
+   * A standard size to use to increase hit rates when the required size isn't defined.
+   * Currently 64KB.
+   */
+  int STANDARD_BUFFER_SIZE_BYTES = 64 * 1024;
+
+  /**
+   * Optionally adds the given array of the given type to the pool.
+   *
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
+   * pool.
+   *
+   * @deprecated Use {@link #put(Object)}
+   */
+  @Deprecated
+  <T> void put(T array, Class<T> arrayClass);
+
+  /**
+   * Optionally adds the given array of the given type to the pool.
+   *
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
+   * pool.
+   */
+  <T> void put(T array);
+
+  /**
+   * Returns a non-null array of the given type with a length >= to the given size.
+   *
+   * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   *
+   * <p>This class makes no guarantees about the contents of the returned array.
+   *
+   * @see #getExact(int, Class)
+   */
+  <T> T get(int size, Class<T> arrayClass);
+
+  /**
+   * Returns a non-null array of the given type with a length exactly equal to the given size.
+   *
+   * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   *
+   * <p>This class makes no guarantees about the contents of the returned array.
+   *
+   * @see #get(int, Class)
+   */
+  <T> T getExact(int size, Class<T> arrayClass);
+
+  /**
+   * Clears all arrays from the pool.
+   */
+  void clearMemory();
+
+  /**
+   * Trims the size to the appropriate level.
+   *
+   * @param level A trim specified in {@link android.content.ComponentCallbacks2}.
+   */
+  void trimMemory(int level);
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
index 1a24f4c9c..58ee33826 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
-
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 
 /**
@@ -12,6 +13,7 @@
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
 
+  @Override
   public void put(Bitmap bitmap) {
     final Key key = keyPool.get(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
 
@@ -54,13 +56,15 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
   }
 
-  private static String getBitmapString(int width, int height, Bitmap.Config config) {
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  static String getBitmapString(int width, int height, Bitmap.Config config) {
     return "[" + width + "x" + height + "], " + config;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
-    public Key get(int width, int height, Bitmap.Config config) {
+    Key get(int width, int height, Bitmap.Config config) {
       Key result = get();
       result.init(width, height, config);
       return result;
@@ -72,7 +76,7 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Key implements Poolable {
     private final KeyPool pool;
     private int width;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
index 32702852b..ccb085511 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
@@ -1,14 +1,13 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import com.bumptech.glide.util.Util;
-
 import java.util.Queue;
 
 abstract class BaseKeyPool<T extends Poolable> {
   private static final int MAX_SIZE = 20;
   private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);
 
-  protected T get() {
+  T get() {
     T result = keyPool.poll();
     if (result == null) {
       result = create();
@@ -22,5 +21,5 @@ public void offer(T key) {
     }
   }
 
-  protected abstract T create();
+  abstract T create();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
index 3fecc0360..7b234184a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java
@@ -11,7 +11,7 @@
   /**
    * Returns the current maximum size of the pool in bytes.
    */
-  int getMaxSize();
+  long getMaxSize();
 
   /**
    * Multiplies the initial size of the pool by the given multiplier to dynamically and
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
index af72c1b82..60652581e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java
@@ -10,7 +10,7 @@
  */
 public class BitmapPoolAdapter implements BitmapPool {
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return 0;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
new file mode 100644
index 000000000..95f5ff708
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -0,0 +1,29 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+/**
+ * Adapter for handling primitive byte arrays.
+ */
+@SuppressWarnings("PMD.UseVarargs")
+public final class ByteArrayAdapter implements ArrayAdapterInterface<byte[]> {
+  private static final String TAG = "ByteArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(byte[] array) {
+    return array.length;
+  }
+
+  @Override
+  public byte[] newArray(int length) {
+    return new byte[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 1;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
deleted file mode 100644
index 0213653b8..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-/**
- * Pool containing byte[] arrays of various sizes.
- */
-public interface ByteArrayPool {
-  /**
-   * A standard size to use to increase hit rates when the required size isn't defined.
-   * Currently 64KB.
-   */
-  int STANDARD_BUFFER_SIZE_BYTES = 64 * 1024;
-
-  /**
-   * Optionally adds the given byte array to the pool.
-   *
-   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
-   * pool.
-   */
-  void put(byte[] bytes);
-
-  /**
-   * Returns a non-null byte array with a length >= to the given size.
-   *
-   * <p>If an array of the given size isn't in the pool, a new one will be allocated.
-   */
-  byte[] get(int size);
-
-  /**
-   * Clears all byte arrays from the pool.
-   */
-  void clearMemory();
-
-  /**
-   * Trims the size to the appropriate level.
-   *
-   * @param level A trim specified in {@link android.content.ComponentCallbacks2}.
-   */
-  void trimMemory(int level);
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index ea29e42ad..9060fd825 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.support.annotation.Nullable;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -120,18 +120,18 @@ private void makeTail(LinkedEntry<K, V> entry) {
   }
 
   private static class LinkedEntry<K, V> {
-    private final K key;
+    @Synthetic final K key;
     private List<V> values;
     LinkedEntry<K, V> next;
     LinkedEntry<K, V> prev;
 
     // Used only for the first item in the list which we will treat specially and which will not
     // contain a value.
-    public LinkedEntry() {
+    LinkedEntry() {
       this(null);
     }
 
-    public LinkedEntry(K key) {
+    LinkedEntry(K key) {
       next = prev = this;
       this.key = key;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
new file mode 100644
index 000000000..4fb179c38
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -0,0 +1,29 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+/**
+ * Adapter for handling primitive int arrays.
+ */
+@SuppressWarnings("PMD.UseVarargs")
+public final class IntegerArrayAdapter implements ArrayAdapterInterface<int[]> {
+  private static final String TAG = "IntegerArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(int[] array) {
+    return array.length;
+  }
+
+  @Override
+  public int[] newArray(int length) {
+    return new int[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 4;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
new file mode 100644
index 000000000..f6838dd26
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -0,0 +1,279 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+
+/**
+ * A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under
+ * the maximum byte size.
+ */
+public final class LruArrayPool implements ArrayPool {
+  // 4MB.
+  private static final int DEFAULT_SIZE = 4 * 1024 * 1024;
+
+  /**
+   * The maximum number of times larger an int array may be to be than a requested size to eligible
+   * to be returned from the pool.
+   */
+  @VisibleForTesting
+  static final int MAX_OVER_SIZE_MULTIPLE = 8;
+  /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
+  private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
+
+  private final GroupedLinkedMap<Key, Object> groupedMap = new GroupedLinkedMap<>();
+  private final KeyPool keyPool = new KeyPool();
+  private final Map<Class<?>, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();
+  private final Map<Class<?>, ArrayAdapterInterface<?>> adapters = new HashMap<>();
+  private final int maxSize;
+  private int currentSize;
+
+  @VisibleForTesting
+  public LruArrayPool() {
+    maxSize = DEFAULT_SIZE;
+  }
+
+  /**
+   * Constructor for a new pool.
+   *
+   * @param maxSize The maximum size in integers of the pool.
+   */
+  public LruArrayPool(int maxSize) {
+    this.maxSize = maxSize;
+  }
+
+  @Deprecated
+  @Override
+  public <T> void put(T array, Class<T> arrayClass) {
+    put(array);
+  }
+
+  @Override
+  public synchronized <T> void put(T array) {
+    @SuppressWarnings("unchecked")
+    Class<T> arrayClass = (Class<T>) array.getClass();
+
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    int size = arrayAdapter.getArrayLength(array);
+    int arrayBytes = size * arrayAdapter.getElementSizeInBytes();
+    if (!isSmallEnoughForReuse(arrayBytes)) {
+      return;
+    }
+    Key key = keyPool.get(size, arrayClass);
+
+    groupedMap.put(key, array);
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(key.size);
+    sizes.put(key.size, current == null ? 1 : current + 1);
+    currentSize += arrayBytes;
+    evict();
+  }
+
+  @Override
+  public synchronized <T> T getExact(int size, Class<T> arrayClass) {
+    Key key = keyPool.get(size, arrayClass);
+    return getForKey(key, arrayClass);
+  }
+
+  @Override
+  public synchronized <T> T get(int size, Class<T> arrayClass) {
+    Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
+    final Key key;
+    if (mayFillRequest(size, possibleSize)) {
+      key = keyPool.get(possibleSize, arrayClass);
+    } else {
+      key = keyPool.get(size, arrayClass);
+    }
+    return getForKey(key, arrayClass);
+  }
+
+  private <T> T getForKey(Key key, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    T result = getArrayForKey(key);
+    if (result != null) {
+      currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
+      decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
+    }
+
+    if (result == null) {
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "Allocated " + key.size + " bytes");
+      }
+      result = arrayAdapter.newArray(key.size);
+    }
+    return result;
+  }
+
+
+  // Our cast is safe because the Key is based on the type.
+  @SuppressWarnings({"unchecked", "TypeParameterUnusedInFormals"})
+  @Nullable
+  private <T> T getArrayForKey(Key key) {
+    return (T) groupedMap.get(key);
+  }
+
+  private boolean isSmallEnoughForReuse(int byteSize) {
+    return byteSize <= maxSize / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
+  }
+
+  private boolean mayFillRequest(int requestedSize, Integer actualSize) {
+    return actualSize != null
+        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));
+  }
+
+  private boolean isNoMoreThanHalfFull() {
+    return currentSize == 0 || (maxSize / currentSize >= 2);
+  }
+
+  @Override
+  public synchronized void clearMemory() {
+    evictToSize(0);
+  }
+
+  @Override
+  public synchronized void trimMemory(int level) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+      clearMemory();
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+      evictToSize(maxSize / 2);
+    }
+  }
+
+  private void evict() {
+    evictToSize(maxSize);
+  }
+
+  private void evictToSize(int size) {
+    while (currentSize > size) {
+      Object evicted = groupedMap.removeLast();
+      Preconditions.checkNotNull(evicted);
+      ArrayAdapterInterface<Object> arrayAdapter = getAdapterFromObject(evicted);
+      currentSize -= arrayAdapter.getArrayLength(evicted) * arrayAdapter.getElementSizeInBytes();
+      decrementArrayOfSize(arrayAdapter.getArrayLength(evicted), evicted.getClass());
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "evicted: " + arrayAdapter.getArrayLength(evicted));
+      }
+    }
+  }
+
+  private void decrementArrayOfSize(int size, Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(size);
+    if (current == null) {
+      throw new NullPointerException(
+          "Tried to decrement empty size" + ", size: " + size + ", this: " + this);
+    }
+    if (current == 1) {
+      sizes.remove(size);
+    } else {
+      sizes.put(size, current - 1);
+    }
+  }
+
+  private NavigableMap<Integer, Integer> getSizesForAdapter(Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = sortedSizes.get(arrayClass);
+    if (sizes == null) {
+      sizes = new TreeMap<>();
+      sortedSizes.put(arrayClass, sizes);
+    }
+    return sizes;
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromObject(T object) {
+    return (ArrayAdapterInterface<T>) getAdapterFromType(object.getClass());
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromType(Class<T> arrayPoolClass) {
+    ArrayAdapterInterface<?> adapter = adapters.get(arrayPoolClass);
+    if (adapter == null) {
+      if (arrayPoolClass.equals(int[].class)) {
+        adapter = new IntegerArrayAdapter();
+      } else if (arrayPoolClass.equals(byte[].class)) {
+        adapter = new ByteArrayAdapter();
+      } else {
+          throw new IllegalArgumentException("No array pool found for: "
+              + arrayPoolClass.getSimpleName());
+      }
+      adapters.put(arrayPoolClass, adapter);
+    }
+    return (ArrayAdapterInterface<T>) adapter;
+  }
+
+  // VisibleForTesting
+  int getCurrentSize() {
+    int currentSize = 0;
+    for (Class<?> type : sortedSizes.keySet()) {
+      for (Integer size : sortedSizes.get(type).keySet()) {
+        ArrayAdapterInterface<?> adapter = getAdapterFromType(type);
+        currentSize += size * sortedSizes.get(type).get(size) * adapter.getElementSizeInBytes();
+      }
+    }
+    return currentSize;
+  }
+
+  private static final class KeyPool extends BaseKeyPool<Key> {
+
+    @Synthetic
+    KeyPool() { }
+
+    Key get(int size, Class<?> arrayClass) {
+      Key result = get();
+      result.init(size, arrayClass);
+      return result;
+    }
+
+    @Override
+    protected Key create() {
+      return new Key(this);
+    }
+  }
+
+  private static final class Key implements Poolable {
+    private final KeyPool pool;
+    @Synthetic int size;
+    private Class<?> arrayClass;
+
+    Key(KeyPool pool) {
+      this.pool = pool;
+    }
+
+    void init(int length, Class<?> arrayClass) {
+      this.size = length;
+      this.arrayClass = arrayClass;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return size == other.size && arrayClass == other.arrayClass;
+      }
+      return false;
+    }
+
+    @Override
+    public String toString() {
+      return "Key{" + "size=" + size + "array=" + arrayClass + '}';
+    }
+
+    @Override
+    public void offer() {
+      pool.offer(this);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = size;
+      result = 31 * result + (arrayClass != null ? arrayClass.hashCode() : 0);
+      return result;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 754544bea..0540e469e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -8,7 +8,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
@@ -26,18 +26,18 @@
 
   private final LruPoolStrategy strategy;
   private final Set<Bitmap.Config> allowedConfigs;
-  private final int initialMaxSize;
+  private final long initialMaxSize;
   private final BitmapTracker tracker;
 
-  private int maxSize;
-  private int currentSize;
+  private long maxSize;
+  private long currentSize;
   private int hits;
   private int misses;
   private int puts;
   private int evictions;
 
   // Exposed for testing only.
-  LruBitmapPool(int maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
+  LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {
     this.initialMaxSize = maxSize;
     this.maxSize = maxSize;
     this.strategy = strategy;
@@ -50,7 +50,7 @@
    *
    * @param maxSize The initial maximum size of the pool in bytes.
    */
-  public LruBitmapPool(int maxSize) {
+  public LruBitmapPool(long maxSize) {
     this(maxSize, getDefaultStrategy(), getDefaultAllowedConfigs());
   }
 
@@ -62,12 +62,14 @@ public LruBitmapPool(int maxSize) {
    *                       allowed to be put into the pool. Configs not in the allowed put will be
    *                       rejected.
    */
-  public LruBitmapPool(int maxSize, Set<Bitmap.Config> allowedConfigs) {
+  // Public API.
+  @SuppressWarnings("unused")
+  public LruBitmapPool(long maxSize, Set<Bitmap.Config> allowedConfigs) {
     this(maxSize, getDefaultStrategy(), allowedConfigs);
   }
 
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return maxSize;
   }
 
@@ -126,7 +128,7 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
       // contents individually, so we do so here. See issue #131.
       result.eraseColor(Color.TRANSPARENT);
     } else {
-      result = Bitmap.createBitmap(width, height, config);
+      result = createBitmap(width, height, config);
     }
 
     return result;
@@ -137,13 +139,34 @@ public Bitmap get(int width, int height, Bitmap.Config config) {
   public Bitmap getDirty(int width, int height, Bitmap.Config config) {
     Bitmap result = getDirtyOrNull(width, height, config);
     if (result == null) {
-      result = Bitmap.createBitmap(width, height, config);
+      result = createBitmap(width, height, config);
     }
     return result;
   }
 
+  @NonNull
+  private static Bitmap createBitmap(int width, int height, @Nullable Bitmap.Config config) {
+    return Bitmap.createBitmap(width, height, config != null ? config : DEFAULT_CONFIG);
+  }
+
+  @TargetApi(Build.VERSION_CODES.O)
+  private static void assertNotHardwareConfig(Bitmap.Config config) {
+    // Avoid short circuiting on sdk int since it breaks on some versions of Android.
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+      return;
+    }
+
+    if (config == Bitmap.Config.HARDWARE) {
+      throw new IllegalArgumentException("Cannot create a mutable Bitmap with config: " + config
+          + ". Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your RequestOptions"
+          + " and/or in GlideBuilder.setDefaultRequestOptions");
+    }
+  }
+
   @Nullable
-  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {
+  private synchronized Bitmap getDirtyOrNull(
+      int width, int height, @Nullable Bitmap.Config config) {
+    assertNotHardwareConfig(config);
     // Config will be null for non public config types, which can lead to transformations naively
     // passing in null as the requested config here. See issue #194.
     final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG);
@@ -169,17 +192,10 @@ private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config
   // Setting these two values provides Bitmaps that are essentially equivalent to those returned
   // from Bitmap.createBitmap.
   private static void normalize(Bitmap bitmap) {
-    maybeSetAlpha(bitmap);
+    bitmap.setHasAlpha(true);
     maybeSetPreMultiplied(bitmap);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-  private static void maybeSetAlpha(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
-      bitmap.setHasAlpha(true);
-    }
-  }
-
   @TargetApi(Build.VERSION_CODES.KITKAT)
   private static void maybeSetPreMultiplied(Bitmap bitmap) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
@@ -201,14 +217,14 @@ public void trimMemory(int level) {
     if (Log.isLoggable(TAG, Log.DEBUG)) {
       Log.d(TAG, "trimMemory, level=" + level);
     }
-    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
       trimToSize(maxSize / 2);
     }
   }
 
-  private synchronized void trimToSize(int size) {
+  private synchronized void trimToSize(long size) {
     while (currentSize > size) {
       final Bitmap removed = strategy.removeLast();
       // TODO: This shouldn't ever happen, see #331.
@@ -252,12 +268,18 @@ private static LruPoolStrategy getDefaultStrategy() {
     return strategy;
   }
 
+  @TargetApi(Build.VERSION_CODES.O)
   private static Set<Bitmap.Config> getDefaultAllowedConfigs() {
-    Set<Bitmap.Config> configs = new HashSet<>();
-    configs.addAll(Arrays.asList(Bitmap.Config.values()));
-    if (Build.VERSION.SDK_INT >= 19) {
+    Set<Bitmap.Config> configs = new HashSet<>(Arrays.asList(Bitmap.Config.values()));
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java
+      // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured
+      // and are suitable for re-use.
       configs.add(null);
     }
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      configs.remove(Bitmap.Config.HARDWARE);
+    }
     return Collections.unmodifiableSet(configs);
   }
 
@@ -291,7 +313,11 @@ public void remove(Bitmap bitmap) {
     }
   }
 
-  private static class NullBitmapTracker implements BitmapTracker {
+  private static final class NullBitmapTracker implements BitmapTracker {
+
+    @Synthetic
+    NullBitmapTracker() { }
+
     @Override
     public void add(Bitmap bitmap) {
       // Do nothing.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
deleted file mode 100644
index dd6d5dc68..000000000
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
+++ /dev/null
@@ -1,195 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import android.util.Log;
-
-import java.util.Arrays;
-import java.util.TreeMap;
-
-/**
- * A fixed size LruByteArrayPool that evicts arrays using an LRU strategy to keep the pool under
- * the maximum byte size.
- */
-public final class LruByteArrayPool implements ByteArrayPool {
-  private static final String TAG = "LruBytesPool";
-  // 4MB.
-  private static final int DEFAULT_SIZE = 4 * 1024 * 1024;
-  /**
-   * The maximum number of times larger a byte array may be to be than a requested size to eligble
-   * to be returned from the pool.
-   */
-  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
-  /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
-  private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
-  private final GroupedLinkedMap<Key, byte[]> groupedMap = new GroupedLinkedMap<>();
-  private final KeyPool keyPool = new KeyPool();
-  private final TreeMap<Integer, Integer> sortedSizes = new TreeMap<>();
-  private final int maxSizeBytes;
-
-  private int currentSizeBytes;
-
-  /**
-   * Constructor for a new pool with a standard size.
-   */
-  public LruByteArrayPool() {
-    this(DEFAULT_SIZE);
-  }
-
-  /**
-   * Constructor for a new pool.
-   *
-   * @param maxSizeBytes The maximum size in bytes of the pool.
-   */
-  public LruByteArrayPool(int maxSizeBytes) {
-    this.maxSizeBytes = maxSizeBytes;
-  }
-
-  @Override
-  public synchronized void put(byte[] bytes) {
-    int size = bytes.length;
-    if (!isSmallEnoughForReuse(size)) {
-      return;
-    }
-    Key key = keyPool.get(size);
-
-    groupedMap.put(key, bytes);
-    Integer current = sortedSizes.get(size);
-    sortedSizes.put(size, current == null ? 1 : current + 1);
-    currentSizeBytes += size;
-    evict();
-  }
-
-  @Override
-  public byte[] get(int size) {
-    byte[] result;
-    synchronized (this) {
-      Integer possibleSize = sortedSizes.ceilingKey(size);
-      final Key key;
-      if (mayFillRequest(size, possibleSize)) {
-        key = keyPool.get(possibleSize);
-      } else {
-        key = keyPool.get(size);
-      }
-
-      result = groupedMap.get(key);
-      if (result != null) {
-        currentSizeBytes -= result.length;
-        decrementByteArrayOfSize(result.length);
-      }
-    }
-
-    if (result != null) {
-      Arrays.fill(result, (byte) 0);
-    } else {
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Allocated " + size + " bytes");
-      }
-      result = new byte[size];
-    }
-
-    return result;
-  }
-
-  private boolean isSmallEnoughForReuse(int byteSize) {
-    return byteSize <= maxSizeBytes / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
-  }
-
-  private boolean mayFillRequest(int requestedSize, Integer actualSize) {
-    return actualSize != null
-        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));
-  }
-
-  private boolean isNoMoreThanHalfFull() {
-    return currentSizeBytes == 0 || (maxSizeBytes / currentSizeBytes >= 2);
-  }
-
-  @Override
-  public synchronized void clearMemory() {
-    evictToSize(0);
-  }
-
-  @Override
-  public synchronized void trimMemory(int level) {
-     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
-      clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
-      evictToSize(maxSizeBytes / 2);
-    }
-  }
-
-  private void evict() {
-    evictToSize(maxSizeBytes);
-  }
-
-  private void evictToSize(int size) {
-    while (currentSizeBytes > size) {
-      byte[] evicted = groupedMap.removeLast();
-      currentSizeBytes -= evicted.length;
-      decrementByteArrayOfSize(evicted.length);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "evicted: " + evicted.length);
-      }
-    }
-  }
-
-  private void decrementByteArrayOfSize(int size) {
-    Integer current = sortedSizes.get(size);
-    if (current == 1) {
-      sortedSizes.remove(current);
-    } else {
-      sortedSizes.put(size, current - 1);
-    }
-  }
-
-  private static final class KeyPool extends BaseKeyPool<Key> {
-
-    Key get(int size) {
-      Key result = get();
-      result.init(size);
-      return result;
-    }
-
-    @Override
-    protected Key create() {
-      return new Key(this);
-    }
-  }
-
-  private static final class Key implements Poolable {
-    private final KeyPool pool;
-    private int size;
-
-    Key(KeyPool pool) {
-      this.pool = pool;
-    }
-
-    void init(int length) {
-      this.size = length;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof Key) {
-        Key other = (Key) o;
-        return size == other.size;
-      }
-      return false;
-    }
-
-    @Override
-    public int hashCode() {
-      return size;
-    }
-
-    @Override
-    public String toString() {
-      return "Key{"
-          + "size=" + size
-          + '}';
-    }
-
-    @Override
-    public void offer() {
-      pool.offer(this);
-    }
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
index 5d4176f3c..220d3beff 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/PrettyPrintTreeMap.java
@@ -2,6 +2,8 @@
 
 import java.util.TreeMap;
 
+// Never serialized.
+@SuppressWarnings("serial")
 class PrettyPrintTreeMap<K, V> extends TreeMap<K, V> {
   @Override
   public String toString() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index 0a011dbc3..e496fde4e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -1,12 +1,14 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.os.Build;
 import android.support.annotation.Nullable;
-
+import android.support.annotation.RequiresApi;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.NavigableMap;
@@ -23,15 +25,26 @@
  * the performance of applications. This class works around #301 by only allowing re-use of
  * {@link android.graphics.Bitmap Bitmaps} with a matching number of bytes per pixel. </p>
  */
-@TargetApi(Build.VERSION_CODES.KITKAT)
+@RequiresApi(Build.VERSION_CODES.KITKAT)
 public class SizeConfigStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
-  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS =
-      new Bitmap.Config[] {
-          Bitmap.Config.ARGB_8888,
-          // The value returned by Bitmaps with the hidden Bitmap config.
-          null,
-      };
+
+  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS;
+  static {
+    Bitmap.Config[] result =
+        new Bitmap.Config[] {
+            Bitmap.Config.ARGB_8888,
+            // The value returned by Bitmaps with the hidden Bitmap config.
+            null,
+        };
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      result = Arrays.copyOf(result, result.length + 1);
+      result[result.length - 1] = Config.RGBA_F16;
+    }
+    ARGB_8888_IN_CONFIGS = result;
+  }
+  private static final Bitmap.Config[] RGBA_F16_IN_CONFIGS = ARGB_8888_IN_CONFIGS;
+
   // We probably could allow ARGB_4444 and RGB_565 to decode into each other, but ARGB_4444 is
   // deprecated and we'd rather be safe.
   private static final Bitmap.Config[] RGB_565_IN_CONFIGS =
@@ -161,7 +174,7 @@ public String toString() {
     return sb.append(")}").toString();
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
     public Key get(int size, Bitmap.Config config) {
@@ -176,18 +189,18 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class Key implements Poolable {
     private final KeyPool pool;
 
-    private int size;
+    @Synthetic int size;
     private Bitmap.Config config;
 
     public Key(KeyPool pool) {
       this.pool = pool;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Key(KeyPool pool, int size, Bitmap.Config config) {
       this(pool);
       init(size, config);
@@ -213,7 +226,7 @@ public boolean equals(Object o) {
       if (o instanceof Key) {
         Key other = (Key) o;
         return size == other.size
-            && (config == null ? other.config == null : config.equals(other.config));
+            && Util.bothNullOrEqual(config, other.config);
       }
       return false;
     }
@@ -226,11 +239,18 @@ public int hashCode() {
     }
   }
 
-  private static String getBitmapString(int size, Bitmap.Config config) {
+  @Synthetic
+  static String getBitmapString(int size, Bitmap.Config config) {
     return "[" + size + "](" + config + ")";
   }
 
   private static Bitmap.Config[] getInConfigs(Bitmap.Config requested) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      if (Bitmap.Config.RGBA_F16.equals(requested)) { // NOPMD - Avoid short circuiting sdk checks.
+        return RGBA_F16_IN_CONFIGS;
+      }
+    }
+
     switch (requested) {
       case ARGB_8888:
         return ARGB_8888_IN_CONFIGS;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index 007ae8151..5536b75db 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -1,13 +1,13 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.support.annotation.Nullable;
-
+import android.support.annotation.RequiresApi;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
-import java.util.TreeMap;
+import java.util.NavigableMap;
 
 /**
  * A strategy for reusing bitmaps that relies on
@@ -15,12 +15,12 @@
  *
  * <p> Requires {@link Build.VERSION_CODES#KITKAT KitKat} or higher. </p>
  */
-@TargetApi(Build.VERSION_CODES.KITKAT)
-class SizeStrategy implements LruPoolStrategy {
+@RequiresApi(Build.VERSION_CODES.KITKAT)
+final class SizeStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
-  private final TreeMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
+  private final NavigableMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
 
   @Override
   public void put(Bitmap bitmap) {
@@ -102,15 +102,16 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(size);
   }
 
-  private static String getBitmapString(int size) {
+  @Synthetic static String getBitmapString(int size) {
     return "[" + size + "]";
   }
 
-  // Visible for testing.
+  // Non-final for mocking.
+  @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
     public Key get(int size) {
-      Key result = get();
+      Key result = super.get();
       result.init(size);
       return result;
     }
@@ -121,10 +122,10 @@ protected Key create() {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class Key implements Poolable {
     private final KeyPool pool;
-    private int size;
+    @Synthetic int size;
 
     Key(KeyPool pool) {
       this.pool = pool;
@@ -148,6 +149,8 @@ public int hashCode() {
       return size;
     }
 
+    // PMD.AccessorMethodGeneration: https://github.com/pmd/pmd/issues/807
+    @SuppressWarnings("PMD.AccessorMethodGeneration")
     @Override
     public String toString() {
       return getBitmapString(size);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
index 01736759f..7bcfd02e4 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Key;
-
 import java.io.File;
 
 /**
@@ -15,16 +14,13 @@
    * An interface for lazily creating a disk cache.
    */
   interface Factory {
+    /** 250 MB of cache. */
+    int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
+    String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
 
-      /** 250 MB of cache. */
-      int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
-      String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
-
-      /**
-       * Returns a new disk cache, or {@code null} if no disk cache could be created.
-       */
-      @Nullable
-      DiskCache build();
+    /** Returns a new disk cache, or {@code null} if no disk cache could be created. */
+    @Nullable
+    DiskCache build();
   }
 
   /**
@@ -37,7 +33,7 @@
      *
      * @param file The File the Writer should write to.
      */
-    boolean write(File file);
+    boolean write(@NonNull File file);
   }
 
   /**
@@ -66,6 +62,8 @@
    *
    * @param key The key to remove.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   void delete(Key key);
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
index 73bbe74c7..d551af16a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import com.bumptech.glide.load.Key;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
index 35586d8ae..d11f0f02a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
@@ -1,8 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
-import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayDeque;
 import java.util.HashMap;
 import java.util.Map;
@@ -19,16 +18,16 @@
  *  0, the lock can safely be removed from the map. </p>
  */
 final class DiskCacheWriteLocker {
-  private final Map<Key, WriteLock> locks = new HashMap<>();
+  private final Map<String, WriteLock> locks = new HashMap<>();
   private final WriteLockPool writeLockPool = new WriteLockPool();
 
-  void acquire(Key key) {
+  void acquire(String safeKey) {
     WriteLock writeLock;
     synchronized (this) {
-      writeLock = locks.get(key);
+      writeLock = locks.get(safeKey);
       if (writeLock == null) {
         writeLock = writeLockPool.obtain();
-        locks.put(key, writeLock);
+        locks.put(safeKey, writeLock);
       }
       writeLock.interestedThreads++;
     }
@@ -36,24 +35,24 @@ void acquire(Key key) {
     writeLock.lock.lock();
   }
 
-  void release(Key key) {
+  void release(String safeKey) {
     WriteLock writeLock;
     synchronized (this) {
-      writeLock = Preconditions.checkNotNull(locks.get(key));
+      writeLock = Preconditions.checkNotNull(locks.get(safeKey));
       if (writeLock.interestedThreads < 1) {
         throw new IllegalStateException("Cannot release a lock that is not held"
-            + ", key: " + key
+            + ", safeKey: " + safeKey
             + ", interestedThreads: " + writeLock.interestedThreads);
       }
 
       writeLock.interestedThreads--;
       if (writeLock.interestedThreads == 0) {
-        WriteLock removed = locks.remove(key);
+        WriteLock removed = locks.remove(safeKey);
         if (!removed.equals(writeLock)) {
           throw new IllegalStateException("Removed the wrong lock"
               + ", expected to remove: " + writeLock
               + ", but actually removed: " + removed
-              + ", key: " + key);
+              + ", safeKey: " + safeKey);
         }
         writeLockPool.offer(removed);
       }
@@ -65,12 +64,18 @@ void release(Key key) {
   private static class WriteLock  {
     final Lock lock = new ReentrantLock();
     int interestedThreads;
+
+    @Synthetic
+    WriteLock() { }
   }
 
   private static class WriteLockPool {
     private static final int MAX_POOL_SIZE = 10;
     private final Queue<WriteLock> pool = new ArrayDeque<>();
 
+    @Synthetic
+    WriteLockPool() { }
+
     WriteLock obtain() {
       WriteLock result;
       synchronized (pool) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
index f24fa6dd2..9518b4c85 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java
@@ -7,10 +7,12 @@
  * disk cache directory.
  *
  * <p>If you need to make I/O access before returning the cache directory use the {@link
- * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, int)} constructor variant.
+ * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, long)} constructor variant.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class DiskLruCacheFactory implements DiskCache.Factory {
-  private final int diskCacheSize;
+  private final long diskCacheSize;
   private final CacheDirectoryGetter cacheDirectoryGetter;
 
   /**
@@ -20,7 +22,7 @@
     File getCacheDirectory();
   }
 
-  public DiskLruCacheFactory(final String diskCacheFolder, int diskCacheSize) {
+  public DiskLruCacheFactory(final String diskCacheFolder, long diskCacheSize) {
     this(new CacheDirectoryGetter() {
       @Override
       public File getCacheDirectory() {
@@ -30,7 +32,7 @@ public File getCacheDirectory() {
   }
 
   public DiskLruCacheFactory(final String diskCacheFolder, final String diskCacheName,
-      int diskCacheSize) {
+                             long diskCacheSize) {
     this(new CacheDirectoryGetter() {
       @Override
       public File getCacheDirectory() {
@@ -46,7 +48,9 @@ public File getCacheDirectory() {
    * @param cacheDirectoryGetter Interface called out of UI thread to get the cache folder.
    * @param diskCacheSize        Desired max bytes size for the LRU disk cache.
    */
-  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, int diskCacheSize) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, long diskCacheSize) {
     this.diskCacheSize = diskCacheSize;
     this.cacheDirectoryGetter = cacheDirectoryGetter;
   }
@@ -63,6 +67,6 @@ public DiskCache build() {
       return null;
     }
 
-    return DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
+    return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index 4aeb30c6d..2cedfe0b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -5,11 +5,9 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.util.Log;
-
 import com.bumptech.glide.disklrucache.DiskLruCache;
 import com.bumptech.glide.disklrucache.DiskLruCache.Value;
 import com.bumptech.glide.load.Key;
-
 import java.io.File;
 import java.io.IOException;
 
@@ -17,18 +15,18 @@
  * The default DiskCache implementation. There must be no more than one active instance for a given
  * directory at a time.
  *
- * @see #get(java.io.File, int)
+ * @see #get(java.io.File, long)
  */
 public class DiskLruCacheWrapper implements DiskCache {
   private static final String TAG = "DiskLruCacheWrapper";
 
   private static final int APP_VERSION = 1;
   private static final int VALUE_COUNT = 1;
-  private static DiskLruCacheWrapper wrapper = null;
+  private static DiskLruCacheWrapper wrapper;
 
   private final SafeKeyGenerator safeKeyGenerator;
   private final File directory;
-  private final int maxSize;
+  private final long maxSize;
   private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
   private DiskLruCache diskLruCache;
 
@@ -40,8 +38,12 @@
    * @param directory The directory for the disk cache
    * @param maxSize   The max size for the disk cache
    * @return The new disk cache with the given arguments, or the current cache if one already exists
+   *
+   * @deprecated Use {@link #create(File, long)} to create a new cache with the specified arguments.
    */
-  public static synchronized DiskCache get(File directory, int maxSize) {
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public static synchronized DiskCache get(File directory, long maxSize) {
     // TODO calling twice with different arguments makes it return the cache for the same
     // directory, it's public!
     if (wrapper == null) {
@@ -50,7 +52,25 @@ public static synchronized DiskCache get(File directory, int maxSize) {
     return wrapper;
   }
 
-  protected DiskLruCacheWrapper(File directory, int maxSize) {
+  /**
+   * Create a new DiskCache in the given directory with a specified max size.
+   *
+   * @param directory The directory for the disk cache
+   * @param maxSize   The max size for the disk cache
+   * @return The new disk cache with the given arguments
+   */
+  @SuppressWarnings("deprecation")
+  public static DiskCache create(File directory, long maxSize) {
+    return new DiskLruCacheWrapper(directory, maxSize);
+  }
+
+  /**
+   * @deprecated Do not extend this class.
+   */
+  @Deprecated
+  // Deprecated public API.
+  @SuppressWarnings({"WeakerAccess", "DeprecatedIsStillUsed"})
+  protected DiskLruCacheWrapper(File directory, long maxSize) {
     this.directory = directory;
     this.maxSize = maxSize;
     this.safeKeyGenerator = new SafeKeyGenerator();
@@ -90,9 +110,9 @@ public File get(Key key) {
   public void put(Key key, Writer writer) {
     // We want to make sure that puts block so that data is available when put completes. We may
     // actually not write any data if we find that data is written by the time we acquire the lock.
-    writeLocker.acquire(key);
+    String safeKey = safeKeyGenerator.getSafeKey(key);
+    writeLocker.acquire(safeKey);
     try {
-      String safeKey = safeKeyGenerator.getSafeKey(key);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "Put: Obtained: " + safeKey + " for for Key: " + key);
       }
@@ -123,7 +143,7 @@ public void put(Key key, Writer writer) {
         }
       }
     } finally {
-      writeLocker.release(key);
+      writeLocker.release(safeKey);
     }
   }
 
@@ -143,11 +163,15 @@ public void delete(Key key) {
   public synchronized void clear() {
     try {
       getDiskCache().delete();
-      resetDiskCache();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Unable to clear disk cache", e);
+        Log.w(TAG, "Unable to clear disk cache or disk cache cleared externally", e);
       }
+    } finally {
+      // Delete can close the cache but still throw. If we don't null out the disk cache here, every
+      // subsequent request will try to act on a closed disk cache and fail. By nulling out the disk
+      // cache we at least allow for attempts to open the cache in the future. See #2465.
+      resetDiskCache();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
index 885a8e97e..08b8d4dde 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.content.Context;
-
 import java.io.File;
 
 /**
@@ -9,7 +8,12 @@
  * disk cache directory.
  *
  * <p><b>Images can be read by everyone when using external disk cache.</b>
+ *
+ * @deprecated use {@link ExternalPreferredCacheDiskCacheFactory} instead.
  */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+@Deprecated
 public final class ExternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public ExternalCacheDiskCacheFactory(Context context) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
new file mode 100644
index 000000000..4f2743b1e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
@@ -0,0 +1,65 @@
+package com.bumptech.glide.load.engine.cache;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+import java.io.File;
+
+/**
+ * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the external
+ * disk cache directory, which falls back to the internal disk cache if no external storage is
+ * available. If ever fell back to the internal disk cache, will use that one from that moment on.
+ *
+ * <p><b>Images can be read by everyone when using external disk cache.</b>
+ */
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+public final class ExternalPreferredCacheDiskCacheFactory extends DiskLruCacheFactory {
+
+  public ExternalPreferredCacheDiskCacheFactory(Context context) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,
+        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
+  }
+
+  public ExternalPreferredCacheDiskCacheFactory(Context context, long diskCacheSize) {
+    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
+  }
+
+  public ExternalPreferredCacheDiskCacheFactory(final Context context, final String diskCacheName,
+                                                final long diskCacheSize) {
+    super(new CacheDirectoryGetter() {
+      @Nullable
+      private File getInternalCacheDirectory() {
+        File cacheDirectory = context.getCacheDir();
+        if (cacheDirectory == null) {
+          return null;
+        }
+        if (diskCacheName != null) {
+          return new File(cacheDirectory, diskCacheName);
+        }
+        return cacheDirectory;
+      }
+
+      @Override
+      public File getCacheDirectory() {
+        File internalCacheDirectory = getInternalCacheDirectory();
+
+        // Already used internal cache, so keep using that one,
+        // thus avoiding using both external and internal with transient errors.
+        if ((null != internalCacheDirectory) && internalCacheDirectory.exists()) {
+          return internalCacheDirectory;
+        }
+
+        File cacheDirectory = context.getExternalCacheDir();
+
+        // Shared storage is not available.
+        if ((cacheDirectory == null) || (!cacheDirectory.canWrite())) {
+          return internalCacheDirectory;
+        }
+        if (diskCacheName != null) {
+          return new File(cacheDirectory, diskCacheName);
+        }
+        return cacheDirectory;
+      }
+    }, diskCacheSize);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
index a69112738..18afb52f0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
@@ -1,13 +1,14 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.content.Context;
-
 import java.io.File;
 
 /**
  * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the internal
  * disk cache directory.
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory {
 
   public InternalCacheDiskCacheFactory(Context context) {
@@ -15,12 +16,12 @@ public InternalCacheDiskCacheFactory(Context context) {
         DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
   }
 
-  public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
+  public InternalCacheDiskCacheFactory(Context context, long diskCacheSize) {
     this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
   }
 
   public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName,
-      int diskCacheSize) {
+                                       long diskCacheSize) {
     super(new CacheDirectoryGetter() {
       @Override
       public File getCacheDirectory() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 82391d42a..9c26b83df 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.annotation.SuppressLint;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
@@ -17,38 +18,42 @@
    *
    * @param size The maximum size in bytes the in memory cache can use.
    */
-  public LruResourceCache(int size) {
+  public LruResourceCache(long size) {
     super(size);
   }
 
   @Override
-  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
     this.listener = listener;
   }
 
   @Override
-  protected void onItemEvicted(Key key, Resource<?> item) {
-    if (listener != null) {
+  protected void onItemEvicted(@NonNull Key key, @Nullable Resource<?> item) {
+    if (listener != null && item != null) {
       listener.onResourceRemoved(item);
     }
   }
 
   @Override
-  protected int getSize(Resource<?> item) {
-    return item.getSize();
+  protected int getSize(@Nullable Resource<?> item) {
+    if (item == null) {
+      return super.getSize(null);
+    } else {
+      return item.getSize();
+    }
   }
 
   @SuppressLint("InlinedApi")
   @Override
   public void trimMemory(int level) {
-    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       // Nearing middle of list of cached background apps
       // Evict our entire bitmap cache
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
       // Entering list of cached background apps
       // Evict oldest half of our bitmap cache
-      trimToSize(getCurrentSize() / 2);
+      trimToSize(getMaxSize() / 2);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
index b432c2825..3210e6821 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -13,18 +13,18 @@
    * An interface that will be called whenever a bitmap is removed from the cache.
    */
   interface ResourceRemovedListener {
-    void onResourceRemoved(Resource<?> removed);
+    void onResourceRemoved(@NonNull Resource<?> removed);
   }
 
   /**
    * Returns the sum of the sizes of all the contents of the cache in bytes.
    */
-  int getCurrentSize();
+  long getCurrentSize();
 
   /**
    * Returns the current maximum size in bytes of the cache.
    */
-  int getMaxSize();
+  long getMaxSize();
 
   /**
    * Adjust the maximum size of the cache by multiplying the original size of the cache by the given
@@ -43,7 +43,7 @@
    * @param key The key.
    */
   @Nullable
-  Resource<?> remove(Key key);
+  Resource<?> remove(@NonNull Key key);
 
   /**
    * Add bitmap to the cache with the given key.
@@ -53,14 +53,14 @@
    * @return The old value of key (null if key is not in map).
    */
   @Nullable
-  Resource<?> put(Key key, Resource<?> resource);
+  Resource<?> put(@NonNull Key key, @Nullable Resource<?> resource);
 
   /**
    * Set the listener to be called when a bitmap is removed from the cache.
    *
    * @param listener The listener.
    */
-  void setResourceRemovedListener(ResourceRemovedListener listener);
+  void setResourceRemovedListener(@NonNull ResourceRemovedListener listener);
 
   /**
    * Evict all items from the memory cache.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
index e2f92de07..70deb5ce6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCacheAdapter.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
@@ -11,12 +13,12 @@
   private ResourceRemovedListener listener;
 
   @Override
-  public int getCurrentSize() {
+  public long getCurrentSize() {
     return 0;
   }
 
   @Override
-  public int getMaxSize() {
+  public long getMaxSize() {
     return 0;
   }
 
@@ -25,19 +27,23 @@ public void setSizeMultiplier(float multiplier) {
     // Do nothing.
   }
 
+  @Nullable
   @Override
-  public Resource<?> remove(Key key) {
+  public Resource<?> remove(@NonNull Key key) {
     return null;
   }
 
+  @Nullable
   @Override
-  public Resource<?> put(Key key, Resource<?> resource) {
-    listener.onResourceRemoved(resource);
+  public Resource<?> put(@NonNull Key key, @Nullable Resource<?> resource) {
+    if (resource != null) {
+      listener.onResourceRemoved(resource);
+    }
     return null;
   }
 
   @Override
-  public void setResourceRemovedListener(ResourceRemovedListener listener) {
+  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
     this.listener = listener;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 6156e8802..1418c466b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -4,11 +4,12 @@
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
+import android.support.annotation.VisibleForTesting;
 import android.text.format.Formatter;
 import android.util.DisplayMetrics;
 import android.util.Log;
-
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A calculator that tries to intelligently determine cache sizes for a given device based on some
@@ -16,53 +17,68 @@
  */
 public final class MemorySizeCalculator {
   private static final String TAG = "MemorySizeCalculator";
-  // Visible for testing.
+  @VisibleForTesting
   static final int BYTES_PER_ARGB_8888_PIXEL = 4;
-  static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
+  private static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
 
   private final int bitmapPoolSize;
   private final int memoryCacheSize;
   private final Context context;
-  private final int byteArrayPoolSize;
+  private final int arrayPoolSize;
 
   interface ScreenDimensions {
     int getWidthPixels();
     int getHeightPixels();
   }
 
-  MemorySizeCalculator(Context context, ActivityManager activityManager,
-      ScreenDimensions screenDimensions, float memoryCacheScreens, float bitmapPoolScreens,
-      int targetByteArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
-    this.context = context;
-    byteArrayPoolSize = isLowMemoryDevice(activityManager)
-        ? targetByteArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR : targetByteArrayPoolSize;
-    final int maxSize = getMaxSize(activityManager, maxSizeMultiplier, lowMemoryMaxSizeMultiplier);
+  // Package private to avoid PMD warning.
+  MemorySizeCalculator(MemorySizeCalculator.Builder builder) {
+    this.context = builder.context;
+
+    arrayPoolSize =
+        isLowMemoryDevice(builder.activityManager)
+            ? builder.arrayPoolSizeBytes / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
+            : builder.arrayPoolSizeBytes;
+    int maxSize =
+        getMaxSize(
+            builder.activityManager, builder.maxSizeMultiplier, builder.lowMemoryMaxSizeMultiplier);
+
+    int widthPixels = builder.screenDimensions.getWidthPixels();
+    int heightPixels = builder.screenDimensions.getHeightPixels();
+    int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;
 
-    final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()
-        * BYTES_PER_ARGB_8888_PIXEL;
+    int targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);
 
-    int targetPoolSize = Math.round(screenSize * bitmapPoolScreens);
-    int targetMemoryCacheSize = Math.round(screenSize * memoryCacheScreens);
-    int availableSize = maxSize - byteArrayPoolSize;
+    int targetMemoryCacheSize = Math.round(screenSize * builder.memoryCacheScreens);
+    int availableSize = maxSize - arrayPoolSize;
 
-    if (targetMemoryCacheSize + targetPoolSize <= availableSize) {
+    if (targetMemoryCacheSize + targetBitmapPoolSize <= availableSize) {
       memoryCacheSize = targetMemoryCacheSize;
-      bitmapPoolSize = targetPoolSize;
+      bitmapPoolSize = targetBitmapPoolSize;
     } else {
-      float part = availableSize / (bitmapPoolScreens + memoryCacheScreens);
-      memoryCacheSize = Math.round(part * memoryCacheScreens);
-      bitmapPoolSize = Math.round(part * bitmapPoolScreens);
+      float part = availableSize / (builder.bitmapPoolScreens + builder.memoryCacheScreens);
+      memoryCacheSize = Math.round(part * builder.memoryCacheScreens);
+      bitmapPoolSize = Math.round(part * builder.bitmapPoolScreens);
     }
 
     if (Log.isLoggable(TAG, Log.DEBUG)) {
-      Log.d(TAG, "Calculation complete"
-          + ", Calculated memory cache size: " + toMb(memoryCacheSize)
-          + ", pool size: " + toMb(bitmapPoolSize)
-          + ", byte array size: " + toMb(byteArrayPoolSize)
-          + ", memory class limited? " + (targetMemoryCacheSize + targetPoolSize > maxSize)
-          + ", max size: " + toMb(maxSize)
-          + ", memoryClass: " + activityManager.getMemoryClass()
-          + ", isLowMemoryDevice: " + isLowMemoryDevice(activityManager));
+      Log.d(
+          TAG,
+          "Calculation complete"
+              + ", Calculated memory cache size: "
+              + toMb(memoryCacheSize)
+              + ", pool size: "
+              + toMb(bitmapPoolSize)
+              + ", byte array size: "
+              + toMb(arrayPoolSize)
+              + ", memory class limited? "
+              + (targetMemoryCacheSize + targetBitmapPoolSize > maxSize)
+              + ", max size: "
+              + toMb(maxSize)
+              + ", memoryClass: "
+              + builder.activityManager.getMemoryClass()
+              + ", isLowMemoryDevice: "
+              + isLowMemoryDevice(builder.activityManager));
     }
   }
 
@@ -81,10 +97,10 @@ public int getBitmapPoolSize() {
   }
 
   /**
-   * Returns the recommended byte array pool size for the device it is run on in bytes.
+   * Returns the recommended array pool size for the device it is run on in bytes.
    */
-  public int getByteArrayPoolSize() {
-    return byteArrayPoolSize;
+  public int getArrayPoolSizeInBytes() {
+    return arrayPoolSize;
   }
 
   private static int getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,
@@ -100,36 +116,51 @@ private String toMb(int bytes) {
   }
 
   @TargetApi(Build.VERSION_CODES.KITKAT)
-  private static boolean isLowMemoryDevice(ActivityManager activityManager) {
-    final int sdkInt = Build.VERSION.SDK_INT;
-    return sdkInt < Build.VERSION_CODES.HONEYCOMB
-        || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());
+  @Synthetic static boolean isLowMemoryDevice(ActivityManager activityManager) {
+    // Explicitly check with an if statement, on some devices both parts of boolean expressions
+    // can be evaluated even if we'd normally expect a short circuit.
+    //noinspection SimplifiableIfStatement
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      return activityManager.isLowRamDevice();
+    } else {
+      return true;
+    }
   }
 
   /**
    * Constructs an {@link MemorySizeCalculator} with reasonable defaults that can be optionally
    * overridden.
    */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "unused"})
   public static final class Builder {
-    // Visible for testing.
+    @VisibleForTesting
     static final int MEMORY_CACHE_TARGET_SCREENS = 2;
-    static final int BITMAP_POOL_TARGET_SCREENS = 4;
+
+    /**
+     * On Android O+, we use {@link android.graphics.Bitmap.Config#HARDWARE} for all reasonably
+     * sized images unless we're creating thumbnails for the first time. As a result, the Bitmap
+     * pool is much less important on O than it was on previous versions.
+     */
+    static final int BITMAP_POOL_TARGET_SCREENS =
+        Build.VERSION.SDK_INT < Build.VERSION_CODES.O ? 4 : 1;
+
     static final float MAX_SIZE_MULTIPLIER = 0.4f;
     static final float LOW_MEMORY_MAX_SIZE_MULTIPLIER = 0.33f;
     // 4MB.
-    static final int BYTE_ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
+    static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
-    private final Context context;
+    @Synthetic final Context context;
 
-    // Modifiable for testing.
-    private ActivityManager activityManager;
-    private ScreenDimensions screenDimensions;
+    // Modifiable (non-final) for testing.
+    @Synthetic ActivityManager activityManager;
+    @Synthetic ScreenDimensions screenDimensions;
 
-    private float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
-    private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
-    private float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
-    private float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
-    private int byteArrayPoolSizeBytes = BYTE_ARRAY_POOL_SIZE_BYTES;
+    @Synthetic float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
+    @Synthetic float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
+    @Synthetic float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
+    @Synthetic float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
+    @Synthetic int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
 
     public Builder(Context context) {
       this.context = context;
@@ -137,6 +168,14 @@ public Builder(Context context) {
           (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
       screenDimensions =
           new DisplayMetricsScreenDimensions(context.getResources().getDisplayMetrics());
+
+      // On Android O+ Bitmaps are allocated natively, ART is much more efficient at managing
+      // garbage and we rely heavily on HARDWARE Bitmaps, making Bitmap re-use much less important.
+      // We prefer to preserve RAM on these devices and take the small performance hit of not
+      // re-using Bitmaps and textures when loading very small images or generating thumbnails.
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && isLowMemoryDevice(activityManager)) {
+        bitmapPoolScreens = 0;
+      }
     }
 
     /**
@@ -145,7 +184,7 @@ public Builder(Context context) {
      * returns this Builder.
      */
     public Builder setMemoryCacheScreens(float memoryCacheScreens) {
-      Preconditions.checkArgument(bitmapPoolScreens >= 0,
+      Preconditions.checkArgument(memoryCacheScreens >= 0,
           "Memory cache screens must be greater than or equal to 0");
       this.memoryCacheScreens = memoryCacheScreens;
       return this;
@@ -194,40 +233,38 @@ public Builder setLowMemoryMaxSizeMultiplier(float lowMemoryMaxSizeMultiplier) {
 
     /**
      * Sets the size in bytes of the {@link
-     * com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool} to use to store temporary
+     * com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool} to use to store temporary
      * arrays while decoding data and returns this builder.
      *
      * <p>This number will be halved on low memory devices that return {@code true} from
      * {@link ActivityManager#isLowRamDevice()}.
      */
-    public Builder setByteArrayPoolSize(int byteArrayPoolSizeBytes) {
-      this.byteArrayPoolSizeBytes = byteArrayPoolSizeBytes;
+    public Builder setArrayPoolSize(int arrayPoolSizeBytes) {
+      this.arrayPoolSizeBytes = arrayPoolSizeBytes;
       return this;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Builder setActivityManager(ActivityManager activityManager) {
       this.activityManager = activityManager;
       return this;
     }
 
-    // Visible for testing.
+    @VisibleForTesting
     Builder setScreenDimensions(ScreenDimensions screenDimensions) {
       this.screenDimensions = screenDimensions;
       return this;
     }
 
     public MemorySizeCalculator build() {
-      return new MemorySizeCalculator(context, activityManager, screenDimensions,
-          memoryCacheScreens, bitmapPoolScreens, byteArrayPoolSizeBytes, maxSizeMultiplier,
-          lowMemoryMaxSizeMultiplier);
+      return new MemorySizeCalculator(this);
     }
   }
 
   private static final class DisplayMetricsScreenDimensions implements ScreenDimensions {
     private final DisplayMetrics displayMetrics;
 
-    public DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
+    DisplayMetricsScreenDimensions(DisplayMetrics displayMetrics) {
       this.displayMetrics = displayMetrics;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index 06cc14ffa..f726ef10e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -1,9 +1,14 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.annotation.NonNull;
+import android.support.v4.util.Pools;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.LruCache;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
+import com.bumptech.glide.util.pool.FactoryPools;
+import com.bumptech.glide.util.pool.StateVerifier;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
@@ -11,18 +16,21 @@
  * A class that generates and caches safe and unique string file names from {@link
  * com.bumptech.glide.load.Key}s.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class SafeKeyGenerator {
   private final LruCache<Key, String> loadIdToSafeHash = new LruCache<>(1000);
-
-  private static String calculateHexStringDigest(Key key) {
-     try {
-        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
-        key.updateDiskCacheKey(messageDigest);
-        return Util.sha256BytesToHex(messageDigest.digest());
-      } catch (NoSuchAlgorithmException e) {
-       throw new RuntimeException(e);
-      }
-  }
+  private final Pools.Pool<PoolableDigestContainer> digestPool = FactoryPools.threadSafe(10,
+      new FactoryPools.Factory<PoolableDigestContainer>() {
+        @Override
+        public PoolableDigestContainer create() {
+          try {
+            return new PoolableDigestContainer(MessageDigest.getInstance("SHA-256"));
+          } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+          }
+        }
+      });
 
   public String getSafeKey(Key key) {
     String safeKey;
@@ -37,4 +45,31 @@ public String getSafeKey(Key key) {
     }
     return safeKey;
   }
+
+  private String calculateHexStringDigest(Key key) {
+    PoolableDigestContainer container = Preconditions.checkNotNull(digestPool.acquire());
+    try {
+      key.updateDiskCacheKey(container.messageDigest);
+      // calling digest() will automatically reset()
+      return Util.sha256BytesToHex(container.messageDigest.digest());
+    } finally {
+      digestPool.release(container);
+    }
+  }
+
+  private static final class PoolableDigestContainer implements FactoryPools.Poolable {
+
+    @Synthetic final MessageDigest messageDigest;
+    private final StateVerifier stateVerifier = StateVerifier.newInstance();
+
+    PoolableDigestContainer(MessageDigest messageDigest) {
+      this.messageDigest = messageDigest;
+    }
+
+    @NonNull
+    @Override
+    public StateVerifier getVerifier() {
+      return stateVerifier;
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index aca64853a..7f8845534 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -1,138 +1,447 @@
 package com.bumptech.glide.load.engine.executor;
 
+import android.os.StrictMode;
+import android.os.StrictMode.ThreadPolicy;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
-
+import com.bumptech.glide.util.Synthetic;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
 /**
  * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
  */
-public class GlideExecutor extends ThreadPoolExecutor {
+public final class GlideExecutor implements ExecutorService {
+  /**
+   * The default thread name prefix for executors used to load/decode/transform data not found in
+   * cache.
+   */
+  private static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+
+  /**
+   * The default thread name prefix for executors used to load/decode/transform data found in
+   * Glide's cache.
+   */
+  private static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+
+  /**
+   * The default thread count for executors used to load/decode/transform data found in Glide's
+   * cache.
+   */
+  private static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
+
   private static final String TAG = "GlideExecutor";
-  private static final String DEFAULT_NAME = "fifo-pool";
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * The default thread name prefix for executors from unlimited thread pool used to
+   * load/decode/transform data not found in cache.
+   */
+  private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
+
+  private static final String ANIMATION_EXECUTOR_NAME = "animation";
+
+  /**
+   * The default keep alive time for threads in our cached thread pools in milliseconds.
+   */
+  private static final long KEEP_ALIVE_TIME_MS = TimeUnit.SECONDS.toMillis(10);
+
+  // Don't use more than four threads when automatically determining thread count..
+  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
+
+  // May be accessed on other threads, but this is an optimization only so it's ok if we set its
+  // value more than once.
+  private static volatile int bestThreadCount;
+
+  private final ExecutorService delegate;
+
+  /**
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
+   * prefix, and the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy.
    *
-   * @param poolSize The number of threads.
+   * <p>Disk cache executors do not allow network operations on their threads.
    */
-  public GlideExecutor(int poolSize) {
-    this(poolSize, new DefaultThreadFactory());
+  public static GlideExecutor newDiskCacheExecutor() {
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
+   * prefix, and a custom
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
+   * uncaught throwable strategy.
    *
-   * @param poolSize The number of threads.
-   * @param uncaughtThrowableStrategy Dictates how the pool should handle uncaught and unexpected
-   *                                  throwables thrown by Futures run by the pool.
+   * <p>Disk cache executors do not allow network operations on their threads.
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
    */
-  public GlideExecutor(int poolSize,
-      UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    this(poolSize, new DefaultThreadFactory(uncaughtThrowableStrategy));
+  // Public API.
+  @SuppressWarnings("unused")
+  public static GlideExecutor newDiskCacheExecutor(
+          UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return newDiskCacheExecutor(
+        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
+        uncaughtThrowableStrategy);
+  }
+
+  /**
+   * Returns a new fixed thread pool with the given thread count, thread name prefix,
+   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   *
+   * <p>Disk cache executors do not allow network operations on their threads.
+   *
+   * @param threadCount The number of threads.
+   * @param name The prefix for each thread name.
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newDiskCacheExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, true)));
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
+   * prefix, and the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy.
    *
-   * @param name The prefix for threads created by this pool.
-   * @param poolSize The number of threads.
+   * <p>Source executors allow network operations on their threads.
    */
-  public GlideExecutor(String name, int poolSize) {
-    this(poolSize, new DefaultThreadFactory(name));
+  public static GlideExecutor newSourceExecutor() {
+    return newSourceExecutor(
+        calculateBestThreadCount(),
+        DEFAULT_SOURCE_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
+   * prefix, and a custom
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
+   * uncaught throwable strategy.
+   *
+   * <p>Source executors allow network operations on their threads.
    *
-   * @param name The prefix for each thread name.
-   * @param poolSize The number of threads.
    * @param uncaughtThrowableStrategy The {@link
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public GlideExecutor(String name, int poolSize,
+  // Public API.
+  @SuppressWarnings("unused")
+  public static GlideExecutor newSourceExecutor(
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    this(poolSize, new DefaultThreadFactory(name, uncaughtThrowableStrategy));
+    return newSourceExecutor(
+        calculateBestThreadCount(),
+        DEFAULT_SOURCE_EXECUTOR_NAME,
+        uncaughtThrowableStrategy);
   }
 
-  private GlideExecutor(int corePoolSize, ThreadFactory threadFactory) {
-    super(corePoolSize, corePoolSize, 0, TimeUnit.MILLISECONDS,
-        new PriorityBlockingQueue<Runnable>(), threadFactory);
+  /**
+   * Returns a new fixed thread pool with the given thread count, thread name prefix,
+   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   *
+   * <p>Source executors allow network operations on their threads.
+   *
+   * @param threadCount The number of threads.
+   * @param name The prefix for each thread name.
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newSourceExecutor(
+      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return new GlideExecutor(
+        new ThreadPoolExecutor(
+            threadCount /* corePoolSize */,
+            threadCount /* maximumPoolSize */,
+            0 /* keepAliveTime */,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(name, uncaughtThrowableStrategy, false)));
+  }
+
+  /**
+   * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
+   * created by default, {@link #KEEP_ALIVE_TIME_MS} keep alive
+   * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
+   * blocking queue, for example, {@link PriorityBlockingQueue} effectively won't create more than
+   * {@code corePoolSize} threads.
+   * See <a href=
+   * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">
+   * ThreadPoolExecutor documentation</a>.
+   *
+   * <p>Source executors allow network operations on their threads.
+   */
+  public static GlideExecutor newUnlimitedSourceExecutor() {
+    return new GlideExecutor(new ThreadPoolExecutor(
+        0,
+        Integer.MAX_VALUE,
+        KEEP_ALIVE_TIME_MS,
+        TimeUnit.MILLISECONDS,
+        new SynchronousQueue<Runnable>(),
+        new DefaultThreadFactory(
+            SOURCE_UNLIMITED_EXECUTOR_NAME,
+            UncaughtThrowableStrategy.DEFAULT,
+            false)));
+  }
+
+  /**
+   * Returns a new cached thread pool that defaults to either one or two threads depending on the
+   * number of available cores to use when loading frames of animations.
+   */
+  public static GlideExecutor newAnimationExecutor() {
+    int bestThreadCount = calculateBestThreadCount();
+    // We don't want to add a ton of threads running animations in parallel with our source and
+    // disk cache executors. Doing so adds unnecessary CPU load and can also dramatically increase
+    // our maximum memory usage. Typically one thread is sufficient here, but for higher end devices
+    // with more cores, two threads can provide better performance if lots of GIFs are showing at
+    // once.
+    int maximumPoolSize = bestThreadCount >= 4 ? 2 : 1;
+
+    return newAnimationExecutor(maximumPoolSize, UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * A strategy for handling unexpected and uncaught throwables thrown by futures run on the pool.
+   * Returns a new cached thread pool with the given thread count and
+   * {@link UncaughtThrowableStrategy} to use when loading frames of animations.
    */
-  public enum UncaughtThrowableStrategy {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newAnimationExecutor(
+      int threadCount, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+     return new GlideExecutor(
+        new ThreadPoolExecutor(
+            0 /* corePoolSize */,
+            threadCount,
+            KEEP_ALIVE_TIME_MS,
+            TimeUnit.MILLISECONDS,
+            new PriorityBlockingQueue<Runnable>(),
+            new DefaultThreadFactory(
+                ANIMATION_EXECUTOR_NAME,
+                uncaughtThrowableStrategy,
+                true)));
+  }
+
+  @VisibleForTesting
+  GlideExecutor(ExecutorService delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public void execute(@NonNull Runnable command) {
+    delegate.execute(command);
+  }
+
+  @NonNull
+  @Override
+  public Future<?> submit(@NonNull Runnable task) {
+    return delegate.submit(task);
+  }
+
+  @NonNull
+  @Override
+  public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks);
+  }
+
+  @NonNull
+  @Override
+  public <T> List<Future<T>> invokeAll(
+      @NonNull Collection<? extends Callable<T>> tasks,
+      long timeout,
+      @NonNull TimeUnit unit) throws InterruptedException {
+    return delegate.invokeAll(tasks, timeout, unit);
+  }
+
+  @NonNull
+  @Override
+  public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks)
+      throws InterruptedException, ExecutionException {
+    return delegate.invokeAny(tasks);
+  }
+
+  @Override
+  public <T> T invokeAny(
+      @NonNull Collection<? extends Callable<T>> tasks,
+      long timeout,
+      @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+    return delegate.invokeAny(tasks, timeout, unit);
+  }
+
+  @NonNull
+  @Override
+  public <T> Future<T> submit(@NonNull Runnable task, T result) {
+    return delegate.submit(task, result);
+  }
+
+  @Override
+  public <T> Future<T> submit(@NonNull Callable<T> task) {
+    return delegate.submit(task);
+  }
+
+  @Override
+  public void shutdown() {
+    delegate.shutdown();
+  }
+
+  @NonNull
+  @Override
+  public List<Runnable> shutdownNow() {
+    return delegate.shutdownNow();
+  }
+
+  @Override
+  public boolean isShutdown() {
+    return delegate.isShutdown();
+  }
+
+  @Override
+  public boolean isTerminated() {
+    return delegate.isTerminated();
+  }
+
+  @Override
+  public boolean awaitTermination(long timeout, @NonNull TimeUnit unit)
+      throws InterruptedException {
+    return delegate.awaitTermination(timeout, unit);
+  }
+
+  @Override
+  public String toString() {
+    return delegate.toString();
+  }
+
+  /**
+   * Determines the number of cores available on the device.
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static int calculateBestThreadCount() {
+    if (bestThreadCount == 0) {
+      bestThreadCount =
+          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());
+    }
+    return bestThreadCount;
+  }
+
+  /**
+   * A strategy for handling unexpected and uncaught {@link Throwable}s thrown by futures run on the
+   * pool.
+   */
+  public interface UncaughtThrowableStrategy {
     /**
-     * Silently catches and ignores the uncaught throwables.
+     * Silently catches and ignores the uncaught {@link Throwable}s.
      */
-    IGNORE,
+    // Public API.
+    @SuppressWarnings("unused")
+    UncaughtThrowableStrategy IGNORE = new UncaughtThrowableStrategy() {
+      @Override
+      public void handle(Throwable t) {
+        //ignore
+      }
+    };
     /**
-     * Logs the uncaught throwables using {@link #TAG} and {@link Log}.
+     * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}.
      */
-    LOG {
+    UncaughtThrowableStrategy LOG = new UncaughtThrowableStrategy() {
       @Override
-      protected void handle(Throwable t) {
+      public void handle(Throwable t) {
         if (t != null && Log.isLoggable(TAG, Log.ERROR)) {
           Log.e(TAG, "Request threw uncaught throwable", t);
         }
       }
-    },
+    };
     /**
-     * Rethrows the uncaught throwables to crash the app.
+     * Rethrows the uncaught {@link Throwable}s to crash the app.
      */
-    THROW {
+    // Public API.
+    @SuppressWarnings("unused")
+    UncaughtThrowableStrategy THROW = new UncaughtThrowableStrategy() {
       @Override
-      protected void handle(Throwable t) {
-        super.handle(t);
+      public void handle(Throwable t) {
         if (t != null) {
           throw new RuntimeException("Request threw uncaught throwable", t);
         }
       }
     };
 
-    protected void handle(Throwable t) {
-      // Ignore.
-    }
+    /** The default strategy, currently {@link #LOG}. */
+    UncaughtThrowableStrategy DEFAULT = LOG;
+
+    void handle(Throwable t);
   }
 
   /**
-   * A {@link java.util.concurrent.ThreadFactory} that builds threads with priority {@link
+   * A {@link java.util.concurrent.ThreadFactory} that builds threads slightly above priority {@link
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
-    private final String name;
-    private final UncaughtThrowableStrategy uncaughtThrowableStrategy;
-    private int threadNum = 0;
+    private static final int DEFAULT_PRIORITY = android.os.Process.THREAD_PRIORITY_BACKGROUND
+        + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE;
 
-    DefaultThreadFactory() {
-      this(DEFAULT_NAME);
-    }
-
-    DefaultThreadFactory(String name) {
-      this(name, UncaughtThrowableStrategy.LOG);
-    }
-
-    DefaultThreadFactory(UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-      this(DEFAULT_NAME, uncaughtThrowableStrategy);
-    }
+    private final String name;
+    @Synthetic final UncaughtThrowableStrategy uncaughtThrowableStrategy;
+    @Synthetic final boolean preventNetworkOperations;
+    private int threadNum;
 
-    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy,
+        boolean preventNetworkOperations) {
       this.name = name;
       this.uncaughtThrowableStrategy = uncaughtThrowableStrategy;
+      this.preventNetworkOperations = preventNetworkOperations;
     }
 
     @Override
-    public Thread newThread(Runnable runnable) {
-      final Thread result = new Thread(runnable, name + "-thread-" + threadNum) {
+    public synchronized Thread newThread(@NonNull Runnable runnable) {
+      final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
         @Override
         public void run() {
-          android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+          // why PMD suppression is needed: https://github.com/pmd/pmd/issues/808
+          android.os.Process.setThreadPriority(DEFAULT_PRIORITY); //NOPMD AccessorMethodGeneration
+          if (preventNetworkOperations) {
+            StrictMode.setThreadPolicy(
+                new ThreadPolicy.Builder()
+                    .detectNetwork()
+                    .penaltyDeath()
+                    .build());
+          }
           try {
             super.run();
           } catch (Throwable t) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
new file mode 100644
index 000000000..8dc69bdeb
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.Build;
+import android.os.StrictMode;
+import android.os.StrictMode.ThreadPolicy;
+import android.util.Log;
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.regex.Pattern;
+
+/**
+ * Compatibility methods for {@link java.lang.Runtime}.
+ */
+final class RuntimeCompat {
+  private static final String TAG = "GlideRuntimeCompat";
+  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
+  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
+
+  private RuntimeCompat() {
+    // Utility class.
+  }
+
+  /**
+   * Determines the number of cores available on the device.
+   */
+  static int availableProcessors() {
+    int cpus = Runtime.getRuntime().availableProcessors();
+    if (Build.VERSION.SDK_INT < 17) {
+      cpus = Math.max(getCoreCountPre17(), cpus);
+    }
+    return cpus;
+  }
+
+  /**
+   * Determines the number of cores available on the device (pre-v17).
+   *
+   * <p>Before Jellybean, {@link Runtime#availableProcessors()} returned the number of awake cores,
+   * which may not be the number of available cores depending on the device's current state. See
+   * https://stackoverflow.com/a/30150409.
+   *
+   * @return the maximum number of processors available to the VM; never smaller than one
+   */
+  @SuppressWarnings("PMD")
+  private static int getCoreCountPre17() {
+    // We override the current ThreadPolicy to allow disk reads.
+    // This shouldn't actually do disk-IO and accesses a device file.
+    // See: https://github.com/bumptech/glide/issues/1170
+    File[] cpus = null;
+    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
+    try {
+      File cpuInfo = new File(CPU_LOCATION);
+      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+      cpus = cpuInfo.listFiles(new FilenameFilter() {
+        @Override
+        public boolean accept(File file, String s) {
+          return cpuNamePattern.matcher(s).matches();
+        }
+      });
+    } catch (Throwable t) {
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Failed to calculate accurate cpu count", t);
+      }
+    } finally {
+      StrictMode.setThreadPolicy(originalPolicy);
+    }
+    return Math.max(1, cpus != null ? cpus.length : 0);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index 04243f947..a8c5d641c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -4,14 +4,15 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.security.MessageDigest;
 import java.util.HashSet;
 import java.util.Set;
@@ -29,7 +30,8 @@
  * limit, we assume a GC has occurred, stop the current allocations, and try again after a delay.
  */
 final class BitmapPreFillRunner implements Runnable {
-  private static final String TAG = "PreFillRunner";
+  @VisibleForTesting
+  static final String TAG = "PreFillRunner";
   private static final Clock DEFAULT_CLOCK = new Clock();
 
   /**
@@ -63,15 +65,25 @@
   private long currentDelay = INITIAL_BACKOFF_MS;
   private boolean isCancelled;
 
-  public BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache,
-      PreFillQueue allocationOrder) {
-    this(bitmapPool, memoryCache, allocationOrder, DEFAULT_CLOCK,
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapPreFillRunner(
+      BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder) {
+    this(
+        bitmapPool,
+        memoryCache,
+        allocationOrder,
+        DEFAULT_CLOCK,
         new Handler(Looper.getMainLooper()));
   }
 
-  // Visible for testing.
-  BitmapPreFillRunner(BitmapPool bitmapPool, MemoryCache memoryCache, PreFillQueue allocationOrder,
-      Clock clock, Handler handler) {
+  @VisibleForTesting
+  BitmapPreFillRunner(
+      BitmapPool bitmapPool,
+      MemoryCache memoryCache,
+      PreFillQueue allocationOrder,
+      Clock clock,
+      Handler handler) {
     this.bitmapPool = bitmapPool;
     this.memoryCache = memoryCache;
     this.toPrefill = allocationOrder;
@@ -87,33 +99,44 @@ public void cancel() {
    * Attempts to allocate {@link android.graphics.Bitmap}s and returns {@code true} if there are
    * more {@link android.graphics.Bitmap}s to allocate and {@code false} otherwise.
    */
-  private boolean allocate() {
+  @VisibleForTesting
+  boolean allocate() {
     long start = clock.now();
     while (!toPrefill.isEmpty() && !isGcDetected(start)) {
       PreFillType toAllocate = toPrefill.remove();
       final Bitmap bitmap;
       if (!seenTypes.contains(toAllocate)) {
         seenTypes.add(toAllocate);
-        bitmap = bitmapPool.getDirty(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            bitmapPool.getDirty(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       } else {
-        bitmap = Bitmap.createBitmap(toAllocate.getWidth(), toAllocate.getHeight(),
-            toAllocate.getConfig());
+        bitmap =
+            Bitmap.createBitmap(
+                toAllocate.getWidth(), toAllocate.getHeight(), toAllocate.getConfig());
       }
 
+      // Order matters here! If the Bitmap is too large or the BitmapPool is too full, it may be
+      // recycled after the call to bitmapPool#put below.
+      int bitmapSize = Util.getBitmapByteSize(bitmap);
+
       // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's
-      // not empty so
-      // we use all available space.
-      if (getFreeMemoryCacheBytes() >= Util.getBitmapByteSize(bitmap)) {
-        memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
+      // not empty so that we use all available space.
+      if (getFreeMemoryCacheBytes() >= bitmapSize) {
+        // We could probably make UniqueKey just always return false from equals,
+        // but the allocation of the Key is not nearly as expensive as the allocation of the Bitmap,
+        // so it's probably not worth it.
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        Key uniqueKey = new UniqueKey();
+        memoryCache.put(uniqueKey, BitmapResource.obtain(bitmap, bitmapPool));
       } else {
         bitmapPool.put(bitmap);
       }
 
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG,
-            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] " + toAllocate
-                .getConfig() + " size: " + Util.getBitmapByteSize(bitmap));
+            "allocated [" + toAllocate.getWidth() + "x" + toAllocate.getHeight() + "] "
+                + toAllocate.getConfig() + " size: " + bitmapSize);
       }
     }
 
@@ -124,7 +147,7 @@ private boolean isGcDetected(long startTimeMs) {
     return clock.now() - startTimeMs >= MAX_DURATION_MS;
   }
 
-  private int getFreeMemoryCacheBytes() {
+  private long getFreeMemoryCacheBytes() {
     return memoryCache.getMaxSize() - memoryCache.getCurrentSize();
   }
 
@@ -141,17 +164,21 @@ private long getNextDelay() {
     return result;
   }
 
-  private static class UniqueKey implements Key {
+  private static final class UniqueKey implements Key {
+
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    UniqueKey() { }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
       throw new UnsupportedOperationException();
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class Clock {
-    public long now() {
+    long now() {
       return SystemClock.currentThreadTimeMillis();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index b91c4f73a..9ddc221ed 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -3,12 +3,11 @@
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
-
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.util.Util;
-
 import java.util.HashMap;
 import java.util.Map;
 
@@ -32,6 +31,7 @@ public BitmapPreFiller(MemoryCache memoryCache, BitmapPool bitmapPool,
     this.defaultFormat = defaultFormat;
   }
 
+  @SuppressWarnings("deprecation")
   public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     if (current != null) {
       current.cancel();
@@ -41,7 +41,9 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     for (int i = 0; i < bitmapAttributeBuilders.length; i++) {
       PreFillType.Builder builder = bitmapAttributeBuilders[i];
       if (builder.getConfig() == null) {
-        builder.setConfig(defaultFormat == DecodeFormat.PREFER_ARGB_8888
+        builder.setConfig(
+            defaultFormat == DecodeFormat.PREFER_ARGB_8888
+                || defaultFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
             ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
       }
       bitmapAttributes[i] = builder.build();
@@ -52,9 +54,9 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     handler.post(current);
   }
 
-  // Visible for testing.
-  PreFillQueue generateAllocationOrder(PreFillType[] preFillSizes) {
-    final int maxSize =
+  @VisibleForTesting
+  PreFillQueue generateAllocationOrder(PreFillType... preFillSizes) {
+    final long maxSize =
         memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
 
     int totalWeight = 0;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
index b423df158..31a8b529a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
@@ -2,7 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.support.annotation.Nullable;
-
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Preconditions;
 
 /**
@@ -11,7 +11,7 @@
  * single size and configuration.
  */
 public final class PreFillType {
-  // Visible for testing.
+  @VisibleForTesting
   static final Bitmap.Config DEFAULT_CONFIG = Bitmap.Config.RGB_565;
   private final int width;
   private final int height;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
index baa57e8c9..9eea06323 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -1,17 +1,15 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorAssetPathFetcher;
 import com.bumptech.glide.load.data.StreamAssetPathFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 
 /**
@@ -28,20 +26,22 @@
   private final AssetManager assetManager;
   private final AssetFetcherFactory<Data> factory;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public AssetUriLoader(AssetManager assetManager, AssetFetcherFactory<Data> factory) {
     this.assetManager = assetManager;
     this.factory = factory;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     String assetPath = model.toString().substring(ASSET_PREFIX_LENGTH);
     return new LoadData<>(new ObjectKey(model), factory.buildFetcher(assetManager, assetPath));
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return ContentResolver.SCHEME_FILE.equals(model.getScheme()) && !model.getPathSegments()
         .isEmpty() && ASSET_PATH_SEGMENT.equals(model.getPathSegments().get(0));
   }
@@ -61,10 +61,16 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       AssetFetcherFactory<InputStream> {
 
+    private final AssetManager assetManager;
+
+    public StreamFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
+    @NonNull
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
@@ -85,10 +91,16 @@ public void teardown() {
       ParcelFileDescriptor>,
       AssetFetcherFactory<ParcelFileDescriptor> {
 
+    private final AssetManager assetManager;
+
+    public FileDescriptorFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
+    @NonNull
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 52683e37d..bb8213fc1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.signature.EmptySignature;
-
+import com.bumptech.glide.signature.ObjectKey;
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -22,28 +20,30 @@
 public class ByteArrayLoader<Data> implements ModelLoader<byte[], Data> {
   private final Converter<Data> converter;
 
+  @SuppressWarnings("WeakerAccess") // Public API
   public ByteArrayLoader(Converter<Data> converter) {
     this.converter = converter;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(byte[] model, int width, int height,
-      Options options) {
-    // TODO: compare the actual bytes?
-    return new LoadData<>(EmptySignature.obtain(), new Fetcher<>(model, converter));
+  public LoadData<Data> buildLoadData(
+      @NonNull byte[] model, int width, int height, @NonNull Options options) {
+    return new LoadData<>(new ObjectKey(model), new Fetcher<>(model, converter));
   }
 
   @Override
-  public boolean handles(byte[] model) {
+  public boolean handles(@NonNull byte[] model) {
     return true;
   }
 
   /**
    * Converts between a byte array a desired model class.
+   *
    * @param <Data> The type of data to convert to.
    */
   public interface Converter<Data> {
     Data convert(byte[] model);
+
     Class<Data> getDataClass();
   }
 
@@ -51,13 +51,19 @@ public boolean handles(byte[] model) {
     private final byte[] model;
     private final Converter<Data> converter;
 
-    public Fetcher(byte[] model, Converter<Data> converter) {
+    /**
+     * @param model We really ought to copy the model, but doing so can be hugely expensive and/or
+     *              lead to OOMs. In practice it's unlikely that users would pass an array into
+     *              Glide and then mutate it.
+     */
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
+    Fetcher(byte[] model, Converter<Data> converter) {
       this.model = model;
       this.converter = converter;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       Data result = converter.convert(model);
       callback.onDataReady(result);
     }
@@ -72,11 +78,13 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public Class<Data> getDataClass() {
       return converter.getDataClass();
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
@@ -89,9 +97,9 @@ public DataSource getDataSource() {
    */
   public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
 
+    @NonNull
     @Override
-    public ModelLoader<byte[], ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
         @Override
         public ByteBuffer convert(byte[] model) {
@@ -116,9 +124,9 @@ public void teardown() {
    */
   public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<byte[], InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<InputStream>() {
         @Override
         public InputStream convert(byte[] model) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
index 4fbd048eb..9c8b6a121 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
@@ -1,11 +1,10 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -17,7 +16,7 @@
   private static final String TAG = "ByteBufferEncoder";
 
   @Override
-  public boolean encode(ByteBuffer data, File file, Options options) {
+  public boolean encode(@NonNull ByteBuffer data, @NonNull File file, @NonNull Options options) {
     boolean success = false;
     try {
       ByteBufferUtil.toFile(data, file);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index febd8bc1b..c56d04b08 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import com.bumptech.glide.util.Synthetic;
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -21,13 +20,13 @@
   private static final String TAG = "ByteBufferFileLoader";
 
   @Override
-  public LoadData<ByteBuffer> buildLoadData(File file, int width, int height,
-      Options options) {
+  public LoadData<ByteBuffer> buildLoadData(@NonNull File file, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(file), new ByteBufferFetcher(file));
   }
 
   @Override
-  public boolean handles(File file) {
+  public boolean handles(@NonNull File file) {
     return true;
   }
 
@@ -36,9 +35,9 @@ public boolean handles(File file) {
    */
   public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
 
+    @NonNull
     @Override
-    public ModelLoader<File, ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<File, ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteBufferFileLoader();
     }
 
@@ -48,17 +47,20 @@ public void teardown() {
     }
   }
 
-  private static class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
+  private static final class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
 
     private final File file;
 
-    public ByteBufferFetcher(File file) {
+    @Synthetic
+    @SuppressWarnings("WeakerAccess")
+    ByteBufferFetcher(File file) {
       this.file = file;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super ByteBuffer> callback) {
-      ByteBuffer result = null;
+    public void loadData(@NonNull Priority priority,
+        @NonNull DataCallback<? super ByteBuffer> callback) {
+      ByteBuffer result;
       try {
         result = ByteBufferUtil.fromFile(file);
       } catch (IOException e) {
@@ -82,11 +84,13 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public Class<ByteBuffer> getDataClass() {
       return ByteBuffer.class;
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
new file mode 100644
index 000000000..646c43907
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -0,0 +1,171 @@
+package com.bumptech.glide.load.model;
+
+import android.support.annotation.NonNull;
+import android.util.Base64;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.signature.ObjectKey;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A simple model loader for loading data from a Data URL String.
+ *
+ * Data URIs use the "data" scheme.
+ *
+ * <p>See http://www.ietf.org/rfc/rfc2397.txt  for a complete description of the 'data' URL scheme.
+ *
+ * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],some_data</pre>
+ *
+ * @param <Model> The type of Model that we can retrieve data for, e.g. {@link String}.
+ * @param <Data> The type of data that can be opened, e.g. {@link InputStream}.
+ */
+public final class DataUrlLoader<Model, Data> implements ModelLoader<Model, Data> {
+
+  private static final String DATA_SCHEME_IMAGE = "data:image";
+  private static final String BASE64_TAG = ";base64";
+  private final DataDecoder<Data> dataDecoder;
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public DataUrlLoader(DataDecoder<Data> dataDecoder) {
+    this.dataDecoder = dataDecoder;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
+    return new LoadData<>(
+        new ObjectKey(model), new DataUriFetcher<>(model.toString(), dataDecoder));
+  }
+
+  @Override
+  public boolean handles(@NonNull Model model) {
+    // We expect Model to be a Uri or a String, both of which implement toString() efficiently. We
+    // should reconsider this implementation before adding any new Model types.
+    return model.toString().startsWith(DATA_SCHEME_IMAGE);
+  }
+
+  /**
+   * Allows decoding a specific type of data from a Data URL String.
+   *
+   * @param <Data> The type of data that can be opened.
+   */
+  public interface DataDecoder<Data> {
+
+    Data decode(String uri) throws IllegalArgumentException;
+
+    void close(Data data) throws IOException;
+
+    Class<Data> getDataClass();
+  }
+
+  private static final class DataUriFetcher<Data> implements DataFetcher<Data> {
+
+    private final String dataUri;
+    private final DataDecoder<Data> reader;
+    private Data data;
+
+    DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
+      this.dataUri = dataUri;
+      this.reader = reader;
+    }
+
+    @Override
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
+      try {
+        data = reader.decode(dataUri);
+        callback.onDataReady(data);
+      } catch (IllegalArgumentException e) {
+        callback.onLoadFailed(e);
+      }
+    }
+
+    @Override
+    public void cleanup() {
+      try {
+        reader.close(data);
+      } catch (IOException e) {
+        // Ignored.
+      }
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @NonNull
+    @Override
+    public Class<Data> getDataClass() {
+      return reader.getDataClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.LOCAL;
+    }
+  }
+
+  /**
+   * Factory for loading {@link InputStream}s from data uris.
+   *
+   * @param <Model> The type of Model we can obtain data for, e.g. String.
+   */
+  public static final class StreamFactory<Model> implements ModelLoaderFactory<Model, InputStream> {
+
+    private final DataDecoder<InputStream> opener;
+
+    public StreamFactory() {
+      opener = new DataDecoder<InputStream>() {
+        @Override
+        public InputStream decode(String url) {
+          if (!url.startsWith(DATA_SCHEME_IMAGE)) {
+            throw new IllegalArgumentException("Not a valid image data URL.");
+          }
+
+          int commaIndex = url.indexOf(',');
+          if (commaIndex == -1) {
+            throw new IllegalArgumentException("Missing comma in data URL.");
+          }
+
+          String beforeComma = url.substring(0, commaIndex);
+          if (!beforeComma.endsWith(BASE64_TAG)) {
+            throw new IllegalArgumentException("Not a base64 image data URL.");
+          }
+
+          String afterComma = url.substring(commaIndex + 1);
+          byte[] bytes = Base64.decode(afterComma, Base64.DEFAULT);
+
+          return new ByteArrayInputStream(bytes);
+        }
+
+        @Override
+        public void close(InputStream inputStream) throws IOException {
+          inputStream.close();
+        }
+
+        @Override
+        public Class<InputStream> getDataClass() {
+          return InputStream.class;
+        }
+      };
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<Model, InputStream> build(
+        @NonNull MultiModelLoaderFactory multiFactory) {
+      return new DataUrlLoader<>(opener);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index e917a8f8b..e4f0d9178 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -1,15 +1,13 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -27,18 +25,20 @@
 
   private final FileOpener<Data> fileOpener;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public FileLoader(FileOpener<Data> fileOpener) {
     this.fileOpener = fileOpener;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(File model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull File model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new FileFetcher<>(model, fileOpener));
   }
 
   @Override
-  public boolean handles(File model) {
+  public boolean handles(@NonNull File model) {
     return true;
   }
 
@@ -52,18 +52,18 @@ public boolean handles(File model) {
     Class<Data> getDataClass();
   }
 
-  private static class FileFetcher<Data> implements DataFetcher<Data> {
+  private static final class FileFetcher<Data> implements DataFetcher<Data> {
     private final File file;
     private final FileOpener<Data> opener;
     private Data data;
 
-    public FileFetcher(File file, FileOpener<Data> opener) {
+    FileFetcher(File file, FileOpener<Data> opener) {
       this.file = file;
       this.opener = opener;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       try {
         data = opener.open(file);
       } catch (FileNotFoundException e) {
@@ -92,11 +92,13 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public Class<Data> getDataClass() {
       return opener.getDataClass();
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
@@ -114,9 +116,9 @@ public Factory(FileOpener<Data> opener) {
       this.opener = opener;
     }
 
+    @NonNull
     @Override
-    public final ModelLoader<File, Data> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<File, Data> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new FileLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index 91cd2ebb1..4661d3b0d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.load.model;
 
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
-
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.security.MessageDigest;
@@ -28,7 +27,7 @@
  * convenience. </p>
  */
 public class GlideUrl implements Key {
-  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";
+  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%;$";
   private final Headers headers;
   @Nullable private final URL url;
   @Nullable private final String stringUrl;
@@ -37,6 +36,8 @@
   @Nullable private URL safeUrl;
   @Nullable private volatile byte[] cacheKeyBytes;
 
+  private int hashCode;
+
   public GlideUrl(URL url) {
     this(url, Headers.DEFAULT);
   }
@@ -86,7 +87,7 @@ private String getSafeStringUrl() {
     if (TextUtils.isEmpty(safeStringUrl)) {
       String unsafeStringUrl = stringUrl;
       if (TextUtils.isEmpty(unsafeStringUrl)) {
-        unsafeStringUrl = url.toString();
+        unsafeStringUrl = Preconditions.checkNotNull(url).toString();
       }
       safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
     }
@@ -103,13 +104,15 @@ private String getSafeStringUrl() {
   /**
    * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
    *
-   * <p> This method does not include headers. </p>
+   * <p>This method does not include headers.
    *
-   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
-   * input. </p>
+   * <p>Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
+   * input.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public String getCacheKey() {
-    return stringUrl != null ? stringUrl : url.toString();
+    return stringUrl != null ? stringUrl : Preconditions.checkNotNull(url).toString();
   }
 
   @Override
@@ -118,7 +121,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(getCacheKeyBytes());
   }
 
@@ -141,8 +144,10 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    int hashCode = getCacheKey().hashCode();
-    hashCode = 31 * hashCode + headers.hashCode();
+    if (hashCode == 0) {
+      hashCode = getCacheKey().hashCode();
+      hashCode = 31 * hashCode + headers.hashCode();
+    }
     return hashCode;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
index 78f292430..c00cc434f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.Nullable;
+
 /**
  * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
  * example) to be generated in the background during the first fetch.
@@ -7,7 +9,14 @@
  * <p> Implementations should implement equals() and hashcode() </p> .
  */
 public interface LazyHeaderFactory {
-
-    String buildHeader();
-
+  /**
+   * Returns an http header, or {@code null} if no header could be built.
+   *
+   * <p>Returning {@code null} or an empty String from this method will result in this particular
+   * key/value being excluded from the headers provided in the request. If there are multiple
+   * factories or values for a particular key, any non-null values will still be included for that
+   * key.
+   */
+  @Nullable
+  String buildHeader();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 915185fbd..e7f446ca5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -42,20 +43,30 @@
     Map<String, String> combinedHeaders = new HashMap<>();
 
     for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-      StringBuilder sb = new StringBuilder();
-      List<LazyHeaderFactory> factories = entry.getValue();
-      int size = factories.size();
-      for (int i = 0; i < size; i++) {
-        LazyHeaderFactory factory = factories.get(i);
-        sb.append(factory.buildHeader());
+      String values = buildHeaderValue(entry.getValue());
+      if (!TextUtils.isEmpty(values)) {
+        combinedHeaders.put(entry.getKey(), values);
+      }
+    }
+
+    return combinedHeaders;
+  }
+
+  @NonNull
+  private String buildHeaderValue(@NonNull List<LazyHeaderFactory> factories) {
+    StringBuilder sb = new StringBuilder();
+    int size = factories.size();
+    for (int i = 0; i < size; i++) {
+      LazyHeaderFactory factory = factories.get(i);
+      String header = factory.buildHeader();
+      if (!TextUtils.isEmpty(header)) {
+        sb.append(header);
         if (i != factories.size() - 1) {
           sb.append(',');
         }
       }
-      combinedHeaders.put(entry.getKey(), sb.toString());
     }
-
-    return combinedHeaders;
+    return sb.toString();
   }
 
   @Override
@@ -90,13 +101,9 @@ public int hashCode() {
    * {@link #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)}
    * would usually append an additional value. </p>
    */
-   // PMD doesn't like the necessary static block to initialize DEFAULT_HEADERS.
-  @SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
   public static final class Builder {
     private static final String USER_AGENT_HEADER = "User-Agent";
-    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
-    private static final String ENCODING_HEADER = "Accept-Encoding";
-    private static final String DEFAULT_ENCODING = "identity";
+    private static final String DEFAULT_USER_AGENT = getSanitizedUserAgent();
     private static final Map<String, List<LazyHeaderFactory>> DEFAULT_HEADERS;
 
     // Set Accept-Encoding header to do our best to avoid gzip since it's both inefficient for
@@ -110,25 +117,20 @@ public int hashCode() {
             Collections.<LazyHeaderFactory>singletonList(
                 new StringHeaderFactory(DEFAULT_USER_AGENT)));
       }
-      temp.put(ENCODING_HEADER,
-          Collections.<LazyHeaderFactory>singletonList(
-              new StringHeaderFactory(DEFAULT_ENCODING)));
       DEFAULT_HEADERS = Collections.unmodifiableMap(temp);
     }
 
     private boolean copyOnModify = true;
-    private boolean isEncodingDefault = true;
     private Map<String, List<LazyHeaderFactory>> headers = DEFAULT_HEADERS;
-    private boolean isUserAgentDefault = headers.containsKey(DEFAULT_USER_AGENT);
+    private boolean isUserAgentDefault = true;
 
     /**
      * Adds a value for the given header and returns this builder.
      *
      * <p> Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
-     * (ie an oauth token). </p>
+     * (i.e. an OAuth token). </p>
      *
      * @see #addHeader(String, LazyHeaderFactory)
-
      */
     public Builder addHeader(String key, String value) {
       return addHeader(key, new StringHeaderFactory(value));
@@ -145,8 +147,7 @@ public Builder addHeader(String key, String value) {
      * times </p>
      */
     public Builder addHeader(String key, LazyHeaderFactory factory) {
-      if ((isEncodingDefault && ENCODING_HEADER.equalsIgnoreCase(key))
-          || (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key))) {
+      if (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key)) {
         return setHeader(key, factory);
       }
 
@@ -162,8 +163,9 @@ public Builder addHeader(String key, LazyHeaderFactory factory) {
      * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
      *
      * <p> Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
-     * (ie an oauth token). </p>
+     * (i.e. an OAuth token). </p>
      */
+    @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"}) // Public API
     public Builder setHeader(String key, String value) {
       return setHeader(key, value == null ? null : new StringHeaderFactory(value));
     }
@@ -184,9 +186,6 @@ public Builder setHeader(String key, LazyHeaderFactory factory) {
         factories.add(factory);
       }
 
-      if (isEncodingDefault && ENCODING_HEADER.equalsIgnoreCase(key)) {
-        isEncodingDefault = false;
-      }
       if (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key)) {
         isUserAgentDefault = false;
       }
@@ -219,13 +218,39 @@ public LazyHeaders build() {
     }
 
     private Map<String, List<LazyHeaderFactory>> copyHeaders() {
-      Map<String, List<LazyHeaderFactory>> result =
-          new HashMap<>(headers.size());
+      Map<String, List<LazyHeaderFactory>> result = new HashMap<>(headers.size());
       for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-        result.put(entry.getKey(), new ArrayList<>(entry.getValue()));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        List<LazyHeaderFactory> valueCopy = new ArrayList<>(entry.getValue());
+        result.put(entry.getKey(), valueCopy);
       }
       return result;
     }
+
+    /**
+     * Ensures that the default header will pass OkHttp3's checks for header values.
+     *
+     * @see <a href="https://github.com/bumptech/glide/issues/2331">#2331</a>
+     */
+    @VisibleForTesting
+    static String getSanitizedUserAgent() {
+      String defaultUserAgent = System.getProperty("http.agent");
+      if (TextUtils.isEmpty(defaultUserAgent)) {
+        return defaultUserAgent;
+      }
+
+      int length = defaultUserAgent.length();
+      StringBuilder sb = new StringBuilder(defaultUserAgent.length());
+      for (int i = 0; i < length; i++) {
+        char c = defaultUserAgent.charAt(i);
+        if ((c > '\u001f' || c == '\t') && c < '\u007f') {
+          sb.append(c);
+        } else {
+          sb.append('?');
+        }
+      }
+      return sb.toString();
+    }
   }
 
   static final class StringHeaderFactory implements LazyHeaderFactory {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index ac81aa270..6b36fb0ec 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -4,36 +4,38 @@
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.MediaStore;
+import android.support.annotation.NonNull;
 import android.text.TextUtils;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.File;
 import java.io.FileNotFoundException;
 
 /**
  * Loads the file path for {@link MediaStore} owned {@link Uri uris}.
  */
-public final class MediaStoreFileLoader implements ModelLoader<Uri, File>  {
+public final class MediaStoreFileLoader implements ModelLoader<Uri, File> {
 
   private final Context context;
 
-  MediaStoreFileLoader(Context context) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public MediaStoreFileLoader(Context context) {
     this.context = context;
   }
 
   @Override
-  public LoadData<File> buildLoadData(Uri uri, int width, int height, Options options) {
+  public LoadData<File> buildLoadData(@NonNull Uri uri, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(uri), new FilePathFetcher(context, uri));
   }
 
   @Override
-  public boolean handles(Uri uri) {
+  public boolean handles(@NonNull Uri uri) {
     return MediaStoreUtil.isMediaStoreUri(uri);
   }
 
@@ -51,7 +53,7 @@ public boolean handles(Uri uri) {
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super File> callback) {
+    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super File> callback) {
       Cursor cursor = context.getContentResolver().query(uri, PROJECTION, null /*selection*/,
           null /*selectionArgs*/, null /*sortOrder*/);
 
@@ -83,11 +85,13 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public Class<File> getDataClass() {
       return File.class;
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
@@ -99,8 +103,15 @@ public DataSource getDataSource() {
    */
   public static final class Factory implements ModelLoaderFactory<Uri, File> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
+    @NonNull
     @Override
-    public ModelLoader<Uri, File> build(Context context, MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, File> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreFileLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Model.java b/library/src/main/java/com/bumptech/glide/load/model/Model.java
new file mode 100644
index 000000000..b82f75f55
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/Model.java
@@ -0,0 +1,30 @@
+package com.bumptech.glide.load.model;
+
+import android.support.annotation.Nullable;
+
+/**
+ * An optional interface that models can implement to enhance control over Glide behaviors.
+ */
+public interface Model {
+
+  /**
+   * Returns {@code true} if this model produces the same image using the same mechanism
+   * (server, authentication, source etc) as the given model.
+   * <p>
+   * Models must also override {@link Object#equals(Object other)} and {@link Object#hashCode()}
+   * to ensure that caching functions correctly.
+   * If this object returns {@code true} from this method for a given Model,
+   * it must also be equal to and have the same hash code as the given model.
+   * <p>
+   * However, this model may be equal to and have the same hash code as a given model
+   * but still return {@code false} from this method.
+   * This method optionally allows you to differentiate between Models that load the same image
+   * via multiple different means.
+   * For example one Model might load the image from server A and another model might load
+   * the same image from server B.
+   * The models must be equal to each other with the same hash code because they load
+   * the same image. However two requests made with the different models are not exactly the
+   * same because the way the image is loaded will differ.
+   */
+  boolean isEquivalentTo(@Nullable Object other);
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index 0a4ce4c06..c654de2fc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
-
 import java.util.Queue;
 
 /**
@@ -21,14 +21,16 @@
 
   private final LruCache<ModelKey<A>, B> cache;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ModelCache() {
     this(DEFAULT_SIZE);
   }
 
-  public ModelCache(int size) {
+  public ModelCache(long size) {
     cache = new LruCache<ModelKey<A>, B>(size) {
       @Override
-      protected void onItemEvicted(ModelKey<A> key, B item) {
+      protected void onItemEvicted(@NonNull ModelKey<A> key, @Nullable B item) {
         key.release();
       }
     };
@@ -70,7 +72,7 @@ public void clear() {
     cache.clearMemory();
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static final class ModelKey<A> {
     private static final Queue<ModelKey<?>> KEY_QUEUE = Util.createQueue(0);
 
@@ -110,7 +112,7 @@ public void release() {
     @Override
     public boolean equals(Object o) {
       if (o instanceof ModelKey) {
-        ModelKey other = (ModelKey) o;
+        @SuppressWarnings("unchecked") ModelKey<A> other = (ModelKey<A>) o;
         return width == other.width && height == other.height && model.equals(other.model);
       }
       return false;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
index c64c6d2bd..2ef8de0dc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.Collections;
 import java.util.List;
 
@@ -23,7 +22,7 @@
  *
  * This not only avoids having to duplicate dimensions in xml and in your code in order to determine
  * the size of a view on devices with different densities, but also allows you to use layout weights
- * or otherwise programatically put the dimensions of the view without forcing you to fetch a
+ * or otherwise programmatically put the dimensions of the view without forcing you to fetch a
  * generic resource size.
  *
  * The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower
@@ -48,11 +47,12 @@
     public final List<Key> alternateKeys;
     public final DataFetcher<Data> fetcher;
 
-    public LoadData(Key sourceKey, DataFetcher<Data> fetcher) {
+    public LoadData(@NonNull Key sourceKey, @NonNull DataFetcher<Data> fetcher) {
       this(sourceKey, Collections.<Key>emptyList(), fetcher);
     }
 
-    public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetcher) {
+    public LoadData(@NonNull Key sourceKey, @NonNull List<Key> alternateKeys,
+        @NonNull DataFetcher<Data> fetcher) {
       this.sourceKey = Preconditions.checkNotNull(sourceKey);
       this.alternateKeys = Preconditions.checkNotNull(alternateKeys);
       this.fetcher = Preconditions.checkNotNull(fetcher);
@@ -79,7 +79,8 @@ public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetche
    *               the resource should be loaded at its original height.
    */
   @Nullable
-  LoadData<Data> buildLoadData(Model model, int width, int height, Options options);
+  LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options);
 
   /**
    * Returns true if the given model is a of a recognized type that this loader can probably load.
@@ -91,5 +92,5 @@ public LoadData(Key sourceKey, List<Key> alternateKeys, DataFetcher<Data> fetche
    * results are acceptable. {@link ModelLoader ModelLoaders} that return true from this method may
    * return {@code null} from {@link #buildLoadData(Object, int, int, Options)} </p>
    */
-  boolean handles(Model model);
+  boolean handles(@NonNull Model model);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index c3813f9ad..321077144 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 /**
  * An interface for creating a {@link ModelLoader} for a given model type. Will be retained
@@ -18,13 +19,12 @@
   /**
    * Build a concrete ModelLoader for this model type.
    *
-   * @param context      A context that cannot be retained by the factory but can be retained by the
-   *                     {@link ModelLoader}
    * @param multiFactory A map of classes to factories that can be used to construct additional
    *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
    * @return A new {@link ModelLoader}
    */
-  ModelLoader<T, Y> build(Context context, MultiModelLoaderFactory multiFactory);
+  @NonNull
+  ModelLoader<T, Y> build(@NonNull MultiModelLoaderFactory multiFactory);
 
   /**
    * A lifecycle method that will be called when this factory is about to replaced.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index bf3ffbab4..ef11d7a21 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -13,53 +14,64 @@
  * Maintains an ordered put of {@link ModelLoader}s and the model and data types they handle in
  * order from highest priority to lowest.
  */
+// Hides Model throughout.
+@SuppressWarnings("TypeParameterHidesVisibleType")
 public class ModelLoaderRegistry {
 
   private final MultiModelLoaderFactory multiModelLoaderFactory;
   private final ModelLoaderCache cache = new ModelLoaderCache();
 
-  public ModelLoaderRegistry(Context context, Pool<List<Exception>> exceptionListPool) {
-    this(new MultiModelLoaderFactory(context, exceptionListPool));
+  public ModelLoaderRegistry(@NonNull Pool<List<Throwable>> throwableListPool) {
+    this(new MultiModelLoaderFactory(throwableListPool));
   }
 
-  // Visible for testing.
-  ModelLoaderRegistry(MultiModelLoaderFactory multiModelLoaderFactory) {
+  private ModelLoaderRegistry(@NonNull MultiModelLoaderFactory multiModelLoaderFactory) {
     this.multiModelLoaderFactory = multiModelLoaderFactory;
   }
 
-  public synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void append(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     multiModelLoaderFactory.append(modelClass, dataClass, factory);
     cache.clear();
   }
 
-  public synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void prepend(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     multiModelLoaderFactory.prepend(modelClass, dataClass, factory);
     cache.clear();
   }
 
-  public synchronized <Model, Data> void remove(Class<Model> modelClass, Class<Data> dataClass) {
+  public synchronized <Model, Data> void remove(@NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
     tearDown(multiModelLoaderFactory.remove(modelClass, dataClass));
     cache.clear();
   }
 
-  public synchronized <Model, Data> void replace(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
+  public synchronized <Model, Data> void replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
     tearDown(multiModelLoaderFactory.replace(modelClass, dataClass, factory));
     cache.clear();
   }
 
-  private <Model, Data> void tearDown(List<ModelLoaderFactory<Model, Data>> factories) {
-    for (ModelLoaderFactory<?, ?> factory : factories) {
+  private <Model, Data> void tearDown(
+      @NonNull List<ModelLoaderFactory<? extends Model, ? extends Data>> factories) {
+    for (ModelLoaderFactory<? extends Model, ? extends Data> factory : factories) {
       factory.teardown();
     }
   }
 
-  public synchronized <A> List<ModelLoader<A, ?>> getModelLoaders(A model) {
+  @NonNull
+  public synchronized <A> List<ModelLoader<A, ?>> getModelLoaders(@NonNull A model) {
     List<ModelLoader<A, ?>> modelLoaders = getModelLoadersForClass(getClass(model));
     int size = modelLoaders.size();
     List<ModelLoader<A, ?>> filteredLoaders = new ArrayList<>(size);
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0; i < size; i++) {
       ModelLoader<A, ?> loader = modelLoaders.get(i);
       if (loader.handles(model)) {
@@ -69,16 +81,18 @@ public ModelLoaderRegistry(Context context, Pool<List<Exception>> exceptionListP
     return filteredLoaders;
   }
 
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
-      Class<Data> dataClass) {
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(@NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
     return multiModelLoaderFactory.build(modelClass, dataClass);
   }
 
-  public synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+  @NonNull
+  public synchronized List<Class<?>> getDataClasses(@NonNull Class<?> modelClass) {
     return multiModelLoaderFactory.getDataClasses(modelClass);
   }
 
-  private <A> List<ModelLoader<A, ?>> getModelLoadersForClass(Class<A> modelClass) {
+  @NonNull
+  private <A> List<ModelLoader<A, ?>> getModelLoadersForClass(@NonNull Class<A> modelClass) {
     List<ModelLoader<A, ?>> loaders = cache.get(modelClass);
     if (loaders == null) {
       loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));
@@ -87,14 +101,18 @@ public ModelLoaderRegistry(Context context, Pool<List<Exception>> exceptionListP
     return loaders;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private static <A> Class<A> getClass(A model) {
+  private static <A> Class<A> getClass(@NonNull A model) {
     return (Class<A>) model.getClass();
   }
 
   private static class ModelLoaderCache {
     private final Map<Class<?>, Entry<?>> cachedModelLoaders = new HashMap<>();
 
+    @Synthetic
+    ModelLoaderCache() { }
+
     public void clear() {
       cachedModelLoaders.clear();
     }
@@ -106,6 +124,7 @@ public void clear() {
       }
     }
 
+    @Nullable
     @SuppressWarnings("unchecked")
     public <Model> List<ModelLoader<Model, ?>> get(Class<Model> modelClass) {
       Entry<Model> entry = (Entry<Model>) cachedModelLoaders.get(modelClass);
@@ -113,7 +132,7 @@ public void clear() {
     }
 
     private static class Entry<Model> {
-      private final List<ModelLoader<Model, ?>> loaders;
+      @Synthetic final List<ModelLoader<Model, ?>> loaders;
 
       public Entry(List<ModelLoader<Model, ?>> loaders) {
         this.loaders = loaders;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index 4466666b7..fb9d7206a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
@@ -10,7 +11,6 @@
 import com.bumptech.glide.load.data.DataFetcher.DataCallback;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -27,20 +27,21 @@
 class MultiModelLoader<Model, Data> implements ModelLoader<Model, Data> {
 
   private final List<ModelLoader<Model, Data>> modelLoaders;
-  private final Pool<List<Exception>> exceptionListPool;
+  private final Pool<List<Throwable>> exceptionListPool;
 
-  MultiModelLoader(List<ModelLoader<Model, Data>> modelLoaders,
-      Pool<List<Exception>> exceptionListPool) {
+  MultiModelLoader(@NonNull List<ModelLoader<Model, Data>> modelLoaders,
+      @NonNull Pool<List<Throwable>> exceptionListPool) {
     this.modelLoaders = modelLoaders;
     this.exceptionListPool = exceptionListPool;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Model model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
     Key sourceKey = null;
     int size = modelLoaders.size();
     List<DataFetcher<Data>> fetchers = new ArrayList<>(size);
+    //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0; i < size; i++) {
       ModelLoader<Model, Data> modelLoader = modelLoaders.get(i);
       if (modelLoader.handles(model)) {
@@ -51,12 +52,12 @@
         }
       }
     }
-    return !fetchers.isEmpty()
+    return !fetchers.isEmpty() && sourceKey != null
         ? new LoadData<>(sourceKey, new MultiFetcher<>(fetchers, exceptionListPool)) : null;
   }
 
   @Override
-  public boolean handles(Model model) {
+  public boolean handles(@NonNull Model model) {
     for (ModelLoader<Model, Data> modelLoader : modelLoaders) {
       if (modelLoader.handles(model)) {
         return true;
@@ -67,37 +68,43 @@ public boolean handles(Model model) {
 
   @Override
   public String toString() {
-    return "MultiModelLoader{" + "modelLoaders=" + Arrays
-        .toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + '}';
+    return "MultiModelLoader{" + "modelLoaders=" + Arrays.toString(modelLoaders.toArray()) + '}';
   }
 
   static class MultiFetcher<Data> implements DataFetcher<Data>, DataCallback<Data> {
 
     private final List<DataFetcher<Data>> fetchers;
-    private final Pool<List<Exception>> exceptionListPool;
+    private final Pool<List<Throwable>> throwableListPool;
     private int currentIndex;
     private Priority priority;
     private DataCallback<? super Data> callback;
-    private List<Exception> exceptions;
-
-    MultiFetcher(List<DataFetcher<Data>> fetchers, Pool<List<Exception>> exceptionListPool) {
-      this.exceptionListPool = exceptionListPool;
+    @Nullable
+    private List<Throwable> exceptions;
+    private boolean isCancelled;
+
+    MultiFetcher(
+        @NonNull List<DataFetcher<Data>> fetchers,
+        @NonNull Pool<List<Throwable>> throwableListPool) {
+      this.throwableListPool = throwableListPool;
       Preconditions.checkNotEmpty(fetchers);
       this.fetchers = fetchers;
       currentIndex = 0;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+    public synchronized void loadData(
+        @NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {
       this.priority = priority;
       this.callback = callback;
-      exceptions = exceptionListPool.acquire();
+      exceptions = throwableListPool.acquire();
       fetchers.get(currentIndex).loadData(priority, this);
     }
 
     @Override
-    public void cleanup() {
-      exceptionListPool.release(exceptions);
+    public synchronized void cleanup() {
+      if (exceptions != null) {
+        throwableListPool.release(exceptions);
+      }
       exceptions = null;
       for (DataFetcher<Data> fetcher : fetchers) {
         fetcher.cleanup();
@@ -105,24 +112,31 @@ public void cleanup() {
     }
 
     @Override
-    public void cancel() {
+    public synchronized void cancel() {
+      isCancelled = true;
       for (DataFetcher<Data> fetcher : fetchers) {
         fetcher.cancel();
       }
     }
 
+    @NonNull
     @Override
     public Class<Data> getDataClass() {
       return fetchers.get(0).getDataClass();
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return fetchers.get(0).getDataSource();
     }
 
     @Override
-    public void onDataReady(Data data) {
+    public synchronized void onDataReady(@Nullable Data data) {
+      if (isCancelled) {
+        return;
+      }
+
       if (data != null) {
         callback.onDataReady(data);
       } else {
@@ -131,16 +145,25 @@ public void onDataReady(Data data) {
     }
 
     @Override
-    public void onLoadFailed(Exception e) {
-      exceptions.add(e);
+    public synchronized void onLoadFailed(@NonNull Exception e) {
+      if (isCancelled) {
+        return;
+      }
+
+      Preconditions.checkNotNull(exceptions).add(e);
       startNextOrFail();
     }
 
     private void startNextOrFail() {
+      if (isCancelled) {
+        return;
+      }
+
       if (currentIndex < fetchers.size() - 1) {
         currentIndex++;
         loadData(priority, callback);
       } else {
+        Preconditions.checkNotNull(exceptions);
         callback.onLoadFailed(new GlideException("Fetch failed", new ArrayList<>(exceptions)));
       }
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index e6c82d9c2..a286bc09d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -1,12 +1,13 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -17,53 +18,66 @@
  * Capable of building an {@link ModelLoader} that wraps one or more other {@link ModelLoader}s for
  * a given model and data class.
  */
+// Hides Model throughout.
+@SuppressWarnings("TypeParameterHidesVisibleType")
 public class MultiModelLoaderFactory {
   private static final Factory DEFAULT_FACTORY = new Factory();
   private static final ModelLoader<Object, Object> EMPTY_MODEL_LOADER = new EmptyModelLoader();
   private final List<Entry<?, ?>> entries = new ArrayList<>();
-  private final Context context;
   private final Factory factory;
   private final Set<Entry<?, ?>> alreadyUsedEntries = new HashSet<>();
-  private final Pool<List<Exception>> exceptionListPool;
+  private final Pool<List<Throwable>> throwableListPool;
 
-  public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool) {
-    this(context, exceptionListPool, DEFAULT_FACTORY);
+  public MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool) {
+    this(throwableListPool, DEFAULT_FACTORY);
   }
 
-  // Visible for testing.
-  MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool,
-      Factory factory) {
-    this.exceptionListPool = exceptionListPool;
-    this.context = context.getApplicationContext();
+  @VisibleForTesting
+  MultiModelLoaderFactory(@NonNull Pool<List<Throwable>> throwableListPool,
+      @NonNull Factory factory) {
+    this.throwableListPool = throwableListPool;
     this.factory = factory;
   }
 
-  synchronized <Model, Data> void append(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
-    add(modelClass, dataClass, factory, true /*append*/);
+  synchronized <Model, Data> void append(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    add(modelClass, dataClass, factory, /*append=*/ true);
   }
 
-  synchronized <Model, Data> void prepend(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory) {
-    add(modelClass, dataClass, factory, false /*append*/);
+  synchronized <Model, Data> void prepend(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    add(modelClass, dataClass, factory, /*append=*/ false);
   }
 
-  private <Model, Data> void add(Class<Model> modelClass, Class<Data> dataClass,
-      ModelLoaderFactory<Model, Data> factory, boolean append) {
+  private <Model, Data> void add(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory,
+      boolean append) {
     Entry<Model, Data> entry = new Entry<>(modelClass, dataClass, factory);
     entries.add(append ? entries.size() : 0, entry);
   }
 
-  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> replace(Class<Model> modelClass,
-      Class<Data> dataClass, ModelLoaderFactory<Model, Data> factory) {
-    List<ModelLoaderFactory<Model, Data>> removed = remove(modelClass, dataClass);
+  @NonNull
+  synchronized <Model, Data> List<ModelLoaderFactory<? extends Model, ? extends Data>> replace(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass,
+      @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
+    List<ModelLoaderFactory<? extends Model, ? extends Data>> removed =
+        remove(modelClass, dataClass);
     append(modelClass, dataClass, factory);
     return removed;
   }
 
-  synchronized <Model, Data> List<ModelLoaderFactory<Model, Data>> remove(Class<Model> modelClass,
-      Class<Data> dataClass) {
-    List<ModelLoaderFactory<Model, Data>> factories = new ArrayList<>();
+  @NonNull
+  synchronized <Model, Data> List<ModelLoaderFactory<? extends Model, ? extends Data>> remove(
+      @NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
+    List<ModelLoaderFactory<? extends Model, ? extends Data>> factories = new ArrayList<>();
     for (Iterator<Entry<?, ?>> iterator = entries.iterator(); iterator.hasNext(); ) {
       Entry<?, ?> entry = iterator.next();
       if (entry.handles(modelClass, dataClass)) {
@@ -74,7 +88,8 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
     return factories;
   }
 
-  synchronized <Model> List<ModelLoader<Model, ?>> build(Class<Model> modelClass) {
+  @NonNull
+  synchronized <Model> List<ModelLoader<Model, ?>> build(@NonNull Class<Model> modelClass) {
     try {
       List<ModelLoader<Model, ?>> loaders = new ArrayList<>();
       for (Entry<?, ?> entry : entries) {
@@ -99,7 +114,8 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
     }
   }
 
-  synchronized List<Class<?>> getDataClasses(Class<?> modelClass) {
+  @NonNull
+  synchronized List<Class<?>> getDataClasses(@NonNull Class<?> modelClass) {
     List<Class<?>> result = new ArrayList<>();
     for (Entry<?, ?> entry : entries) {
       if (!result.contains(entry.dataClass) && entry.handles(modelClass)) {
@@ -109,8 +125,9 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
     return result;
   }
 
-  public synchronized <Model, Data> ModelLoader<Model, Data> build(Class<Model> modelClass,
-      Class<Data> dataClass) {
+  @NonNull
+  public synchronized <Model, Data> ModelLoader<Model, Data> build(@NonNull Class<Model> modelClass,
+      @NonNull Class<Data> dataClass) {
     try {
       List<ModelLoader<Model, Data>> loaders = new ArrayList<>();
       boolean ignoredAnyEntries = false;
@@ -131,7 +148,7 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
         }
       }
       if (loaders.size() > 1) {
-        return factory.build(loaders, exceptionListPool);
+        return factory.build(loaders, throwableListPool);
       } else if (loaders.size() == 1) {
         return loaders.get(0);
       } else {
@@ -150,17 +167,19 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
     }
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private <Model, Data> ModelLoaderFactory<Model, Data> getFactory(Entry<?, ?> entry) {
+  private <Model, Data> ModelLoaderFactory<Model, Data> getFactory(@NonNull Entry<?, ?> entry) {
     return (ModelLoaderFactory<Model, Data>) entry.factory;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  private <Model, Data> ModelLoader<Model, Data> build(Entry<?, ?> entry) {
-    return (ModelLoader<Model, Data>) Preconditions
-        .checkNotNull(entry.factory.build(context, this));
+  private <Model, Data> ModelLoader<Model, Data> build(@NonNull Entry<?, ?> entry) {
+    return (ModelLoader<Model, Data>) Preconditions.checkNotNull(entry.factory.build(this));
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <Model, Data> ModelLoader<Model, Data> emptyModelLoader() {
     return (ModelLoader<Model, Data>) EMPTY_MODEL_LOADER;
@@ -168,41 +187,49 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
 
   private static class Entry<Model, Data> {
     private final Class<Model> modelClass;
-    private final Class<Data> dataClass;
-    private final ModelLoaderFactory<Model, Data> factory;
+    @Synthetic final Class<Data> dataClass;
+    @Synthetic final ModelLoaderFactory<? extends Model, ? extends Data> factory;
 
-    public Entry(Class<Model> modelClass, Class<Data> dataClass,
-        ModelLoaderFactory<Model, Data> factory) {
+    public Entry(
+        @NonNull Class<Model> modelClass,
+        @NonNull Class<Data> dataClass,
+        @NonNull ModelLoaderFactory<? extends Model, ? extends Data> factory) {
       this.modelClass = modelClass;
       this.dataClass = dataClass;
       this.factory = factory;
     }
 
-    public boolean handles(Class<?> modelClass, Class<?> dataClass) {
+    public boolean handles(@NonNull Class<?> modelClass, @NonNull Class<?> dataClass) {
       return handles(modelClass) && this.dataClass.isAssignableFrom(dataClass);
     }
 
-    public boolean handles(Class<?> modelClass) {
+    public boolean handles(@NonNull Class<?> modelClass) {
       return this.modelClass.isAssignableFrom(modelClass);
     }
   }
 
   static class Factory {
+    @NonNull
     public <Model, Data> MultiModelLoader<Model, Data> build(
-        List<ModelLoader<Model, Data>> modelLoaders, Pool<List<Exception>> exceptionListPool) {
-      return new MultiModelLoader<>(modelLoaders, exceptionListPool);
+        @NonNull List<ModelLoader<Model, Data>> modelLoaders,
+        @NonNull Pool<List<Throwable>> throwableListPool) {
+      return new MultiModelLoader<>(modelLoaders, throwableListPool);
     }
   }
 
   private static class EmptyModelLoader implements ModelLoader<Object, Object> {
+    @Synthetic
+    EmptyModelLoader() { }
 
+    @Nullable
     @Override
-    public LoadData<Object> buildLoadData(Object o, int width, int height, Options options) {
-      throw new UnsupportedOperationException("EmptyModelLoader does not handle data");
+    public LoadData<Object> buildLoadData(@NonNull Object o, int width, int height,
+        @NonNull Options options) {
+      return null;
     }
 
     @Override
-    public boolean handles(Object o) {
+    public boolean handles(@NonNull Object o) {
       return false;
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 8c420ae9f..1abc1fab4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
-
 import com.bumptech.glide.load.Options;
-
 import java.io.InputStream;
 
 /**
@@ -23,18 +22,16 @@
   private final ModelLoader<Uri, Data> uriLoader;
   private final Resources resources;
 
-  public ResourceLoader(Context context, ModelLoader<Uri, Data> uriLoader) {
-    this(context.getResources(), uriLoader);
-  }
-
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
     this.resources = resources;
     this.uriLoader = uriLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Integer model, int width, int height, Options options) {
-
+  public LoadData<Data> buildLoadData(@NonNull Integer model, int width, int height,
+      @NonNull Options options) {
     Uri uri = getResourceUri(model);
     return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
   }
@@ -55,7 +52,7 @@ private Uri getResourceUri(Integer model) {
   }
 
   @Override
-  public boolean handles(Integer model) {
+  public boolean handles(@NonNull Integer model) {
     // TODO: check that this is in fact a resource id.
     return true;
   }
@@ -65,10 +62,16 @@ public boolean handles(Integer model) {
    */
   public static class StreamFactory implements ModelLoaderFactory<Integer, InputStream> {
 
+    private final Resources resources;
+
+    public StreamFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @NonNull
     @Override
-    public ModelLoader<Integer, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context, multiFactory.build(Uri.class, InputStream.class));
+    public ModelLoader<Integer, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(resources, multiFactory.build(Uri.class, InputStream.class));
     }
 
     @Override
@@ -83,11 +86,64 @@ public void teardown() {
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<Integer, ParcelFileDescriptor> {
 
+    private final Resources resources;
+
+    public FileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<Integer, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, ParcelFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from resource ids.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Integer, AssetFileDescriptor> {
+
+    private final Resources resources;
+
+    public AssetFileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @Override
+    public ModelLoader<Integer, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Factory for loading resource {@link Uri}s from Android resource ids.
+   */
+  public static class UriFactory implements ModelLoaderFactory<Integer, Uri> {
+
+    private final Resources resources;
+
+    public UriFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @NonNull
     @Override
-    public ModelLoader<Integer, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context,
-          multiFactory.build(Uri.class, ParcelFileDescriptor.class));
+    public ModelLoader<Integer, Uri> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(resources, UnitModelLoader.<Uri>getInstance());
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index 45b168512..9fa8a0ec7 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -1,11 +1,10 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -18,15 +17,15 @@
  */
 public class StreamEncoder implements Encoder<InputStream> {
   private static final String TAG = "StreamEncoder";
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public StreamEncoder(ByteArrayPool byteArrayPool) {
+  public StreamEncoder(ArrayPool byteArrayPool) {
     this.byteArrayPool = byteArrayPool;
   }
 
   @Override
-  public boolean encode(InputStream data, File file, Options options) {
-    byte[] buffer = byteArrayPool.get(ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+  public boolean encode(@NonNull InputStream data, @NonNull File file, @NonNull Options options) {
+    byte[] buffer = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     boolean success = false;
     OutputStream os = null;
     try {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index 5f878b1c5..16bb6cfde 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,13 +1,12 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Options;
-
 import java.io.File;
 import java.io.InputStream;
 
@@ -20,19 +19,21 @@
 public class StringLoader<Data> implements ModelLoader<String, Data> {
   private final ModelLoader<Uri, Data> uriLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public StringLoader(ModelLoader<Uri, Data> uriLoader) {
     this.uriLoader = uriLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(String model, int width, int height,
-      Options options) {
+  public LoadData<Data> buildLoadData(@NonNull String model, int width, int height,
+      @NonNull Options options) {
     Uri uri = parseUri(model);
     return uri == null ? null : uriLoader.buildLoadData(uri, width, height, options);
   }
 
   @Override
-  public boolean handles(String model) {
+  public boolean handles(@NonNull String model) {
     return true;
   }
 
@@ -41,7 +42,8 @@ private static Uri parseUri(String model) {
     Uri uri;
     if (TextUtils.isEmpty(model)) {
       return null;
-    } else if (model.startsWith("/")) {
+    // See https://pmd.github.io/pmd-6.0.0/pmd_rules_java_performance.html#simplifystartswith
+    } else if (model.charAt(0) == '/') {
       uri = toFileUri(model);
     } else {
       uri = Uri.parse(model);
@@ -62,9 +64,9 @@ private static Uri toFileUri(String path) {
    */
   public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<String, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
     }
 
@@ -80,9 +82,9 @@ public void teardown() {
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<String, ParcelFileDescriptor> {
 
+    @NonNull
     @Override
-    public ModelLoader<String, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
@@ -91,4 +93,21 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from Strings.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<String, AssetFileDescriptor> {
+
+    @Override
+    public ModelLoader<String, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new StringLoader<>(multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index b3807a2db..670e86986 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -15,15 +14,32 @@
  * @param <Model> The type of model that will also be returned as decodable data.
  */
 public class UnitModelLoader<Model> implements ModelLoader<Model, Model> {
+  @SuppressWarnings("deprecation")
+  private static final UnitModelLoader<?> INSTANCE = new UnitModelLoader<>();
+
+  @SuppressWarnings("unchecked")
+  public static <T> UnitModelLoader<T> getInstance() {
+    return (UnitModelLoader<T>) INSTANCE;
+  }
+
+  /**
+   * @deprecated Use {@link #getInstance()} instead.
+   */
+  // Need constructor to document deprecation, will be removed, when constructor is privatized.
+  @SuppressWarnings({"PMD.UnnecessaryConstructor", "DeprecatedIsStillUsed"})
+  @Deprecated
+  public UnitModelLoader() {
+    // Intentionally empty.
+  }
 
   @Override
-  public LoadData<Model> buildLoadData(Model model, int width, int height,
-      Options options) {
+  public LoadData<Model> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
     return new LoadData<>(new ObjectKey(model), new UnitFetcher<>(model));
   }
 
   @Override
-  public boolean handles(Model model) {
+  public boolean handles(@NonNull Model model) {
     return true;
   }
 
@@ -31,12 +47,13 @@ public boolean handles(Model model) {
 
     private final Model resource;
 
-    public UnitFetcher(Model resource) {
+    UnitFetcher(Model resource) {
       this.resource = resource;
     }
 
     @Override
-    public void loadData(Priority priority, DataCallback<? super Model> callback) {
+    public void loadData(@NonNull Priority priority,
+        @NonNull DataCallback<? super Model> callback) {
       callback.onDataReady(resource);
     }
 
@@ -50,12 +67,14 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @SuppressWarnings("unchecked")
     @Override
     public Class<Model> getDataClass() {
       return (Class<Model>) resource.getClass();
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
@@ -64,14 +83,32 @@ public DataSource getDataSource() {
 
   /**
    * Factory for producing {@link com.bumptech.glide.load.model.UnitModelLoader}s.
+   *
+   * @param <Model> The type of model that will also be returned as decodable data.
    */
-  public static class Factory<ResourceType> implements ModelLoaderFactory<ResourceType,
-      ResourceType> {
+  // PMD.SingleMethodSingleton false positive: https://github.com/pmd/pmd/issues/816
+  @SuppressWarnings("PMD.SingleMethodSingleton")
+  public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
+    @SuppressWarnings("deprecation")
+    private static final Factory<?> FACTORY = new Factory<>();
+
+    @SuppressWarnings("unchecked")
+    public static <T> Factory<T> getInstance() {
+      return (Factory<T>) FACTORY;
+    }
+
+    /** @deprecated Use {@link #getInstance()} instead. */
+    // Need constructor to document deprecation, will be removed, when constructor is privatized.
+    @SuppressWarnings("PMD.UnnecessaryConstructor")
+    @Deprecated
+    public Factory() {
+      // Intentionally empty.
+    }
 
+    @NonNull
     @Override
-    public ModelLoader<ResourceType, ResourceType> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UnitModelLoader<>();
+    public ModelLoader<Model, Model> build(MultiModelLoaderFactory multiFactory) {
+      return UnitModelLoader.getInstance();
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index d6a66a163..77a316dd4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -1,16 +1,16 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.AssetFileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
@@ -36,22 +36,22 @@
       )
   );
 
-  private final Context context;
   private final LocalUriFetcherFactory<Data> factory;
 
-  public UriLoader(Context context, LocalUriFetcherFactory<Data> factory) {
-    this.context = context;
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public UriLoader(LocalUriFetcherFactory<Data> factory) {
     this.factory = factory;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri model, int width, int height,
-      Options options) {
-    return new LoadData<>(new ObjectKey(model), factory.build(context, model));
+  public LoadData<Data> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
+    return new LoadData<>(new ObjectKey(model), factory.build(model));
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return SCHEMES.contains(model.getScheme());
   }
 
@@ -61,7 +61,7 @@ public boolean handles(Uri model) {
    * @param <Data> The type of data the returned {@link DataFetcher} will obtain.
    */
   public interface LocalUriFetcherFactory<Data> {
-    DataFetcher<Data> build(Context context, Uri uri);
+    DataFetcher<Data> build(Uri uri);
   }
 
   /**
@@ -70,15 +70,21 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       LocalUriFetcherFactory<InputStream> {
 
+    private final ContentResolver contentResolver;
+
+    public StreamFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     @Override
-    public DataFetcher<InputStream> build(Context context, Uri uri) {
-      return new StreamLocalUriFetcher(context, uri);
+    public DataFetcher<InputStream> build(Uri uri) {
+      return new StreamLocalUriFetcher(contentResolver, uri);
     }
 
+    @NonNull
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
@@ -90,24 +96,59 @@ public void teardown() {
   /**
    * Loads {@link ParcelFileDescriptor}s from {@link Uri}s.
    */
-  public static class FileDescriptorFactory implements ModelLoaderFactory<Uri,
-      ParcelFileDescriptor>,
+  public static class FileDescriptorFactory
+      implements ModelLoaderFactory<Uri, ParcelFileDescriptor>,
       LocalUriFetcherFactory<ParcelFileDescriptor> {
 
+    private final ContentResolver contentResolver;
+
+    public FileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
+    @Override
+    public DataFetcher<ParcelFileDescriptor> build(Uri uri) {
+      return new FileDescriptorLocalUriFetcher(contentResolver, uri);
+    }
+
+    @NonNull
+    @Override
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
+    }
+
     @Override
-    public DataFetcher<ParcelFileDescriptor> build(Context context, Uri uri) {
-      return new FileDescriptorLocalUriFetcher(context, uri);
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from {@link Uri}s.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Uri, AssetFileDescriptor>,
+      LocalUriFetcherFactory<AssetFileDescriptor> {
+
+    private final ContentResolver contentResolver;
+
+    public AssetFileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
     }
 
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
     public void teardown() {
       // Do nothing.
     }
+
+    @Override
+    public DataFetcher<AssetFileDescriptor> build(Uri uri) {
+      return new AssetFileDescriptorLocalUriFetcher(contentResolver, uri);
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
index f71d7e789..f51b8698f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -1,10 +1,8 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.net.Uri;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
@@ -28,18 +26,21 @@
   );
   private final ModelLoader<GlideUrl, Data> urlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UrlUriLoader(ModelLoader<GlideUrl, Data> urlLoader) {
     this.urlLoader = urlLoader;
   }
 
   @Override
-  public LoadData<Data> buildLoadData(Uri uri, int width, int height, Options options) {
+  public LoadData<Data> buildLoadData(@NonNull Uri uri, int width, int height,
+      @NonNull Options options) {
     GlideUrl glideUrl = new GlideUrl(uri.toString());
     return urlLoader.buildLoadData(glideUrl, width, height, options);
   }
 
   @Override
-  public boolean handles(Uri uri) {
+  public boolean handles(@NonNull Uri uri) {
     return SCHEMES.contains(uri.getScheme());
   }
 
@@ -49,9 +50,9 @@ public boolean handles(Uri uri) {
    */
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlUriLoader<>(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index d10f4fac6..20c765776 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -1,17 +1,17 @@
 package com.bumptech.glide.load.model.stream;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
-
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -37,7 +37,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(Model model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Model model, int width, int height,
+      @NonNull Options options) {
     GlideUrl result = null;
     if (modelCache != null) {
       result = modelCache.get(model, width, height);
@@ -61,7 +62,7 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
     List<String> alternateUrls = getAlternateUrls(model, width, height, options);
     LoadData<InputStream> concreteLoaderData = concreteLoader.buildLoadData(result, width, height,
         options);
-    if (alternateUrls.isEmpty()) {
+    if (concreteLoaderData == null || alternateUrls.isEmpty()) {
       return concreteLoaderData;
     } else {
       return new LoadData<>(concreteLoaderData.sourceKey, getAlternateKeys(alternateUrls),
@@ -69,7 +70,9 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
     }
   }
 
-  private static List<Key> getAlternateKeys(List<String> alternateUrls) {
+  // Creating a limited number of objects as the sole purpose of the loop.
+  @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+  private static List<Key> getAlternateKeys(Collection<String> alternateUrls) {
     List<Key> result = new ArrayList<>(alternateUrls.size());
     for (String alternate : alternateUrls) {
       result.add(new GlideUrl(alternate));
@@ -110,6 +113,8 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
    * @param width The width in pixels of the view/target the image will be loaded into.
    * @param height The height in pixels of the view/target the image will be loaded into.
    */
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   @Nullable
   protected Headers getHeaders(Model model, int width, int height, Options options) {
     return Headers.DEFAULT;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
index a42d2ca14..e149e1916 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
+import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -10,27 +10,37 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 
 /**
  * An {@link com.bumptech.glide.load.model.ModelLoader} for translating {@link
  * com.bumptech.glide.load.model.GlideUrl} (http/https URLS) into {@link java.io.InputStream} data.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class HttpGlideUrlLoader implements ModelLoader<GlideUrl, InputStream> {
+  /**
+   * An integer option that is used to determine the maximum connect and read timeout durations (in
+   * milliseconds) for network connections.
+   *
+   * <p>Defaults to 2500ms.
+   */
+  public static final Option<Integer> TIMEOUT = Option.memory(
+      "com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout", 2500);
+
   @Nullable private final ModelCache<GlideUrl, GlideUrl> modelCache;
 
   public HttpGlideUrlLoader() {
     this(null);
   }
 
-  public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
+  public HttpGlideUrlLoader(@Nullable ModelCache<GlideUrl, GlideUrl> modelCache) {
     this.modelCache = modelCache;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
-      Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,
+      @NonNull Options options) {
     // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time
     // spent parsing urls.
     GlideUrl url = model;
@@ -41,11 +51,12 @@ public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
         url = model;
       }
     }
-    return new LoadData<>(url, new HttpUrlFetcher(url));
+    int timeout = options.get(TIMEOUT);
+    return new LoadData<>(url, new HttpUrlFetcher(url, timeout));
   }
 
   @Override
-  public boolean handles(GlideUrl model) {
+  public boolean handles(@NonNull GlideUrl model) {
     return true;
   }
 
@@ -55,9 +66,9 @@ public boolean handles(GlideUrl model) {
   public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
     private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
 
+    @NonNull
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpGlideUrlLoader(modelCache);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
index e3f11a6f4..7ff6639b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -1,14 +1,12 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
 import android.net.Uri;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
@@ -24,17 +22,20 @@
 
   private final ModelLoader<GlideUrl, InputStream> urlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public HttpUriLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
     this.urlLoader = urlLoader;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     return urlLoader.buildLoadData(new GlideUrl(model.toString()), width, height, options);
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return SCHEMES.contains(model.getScheme());
   }
 
@@ -43,9 +44,9 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
index 635d8c131..aba0fe3cf 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 import android.net.Uri;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
@@ -10,7 +10,6 @@
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 
 /**
@@ -18,14 +17,17 @@
  * thumbnails for those {@link Uri}s in the media store.
  */
 public class MediaStoreImageThumbLoader implements ModelLoader<Uri, InputStream> {
-  public final Context context;
+  private final Context context;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public MediaStoreImageThumbLoader(Context context) {
     this.context = context.getApplicationContext();
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height)) {
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildImageFetcher(context, model));
     } else {
@@ -34,7 +36,7 @@ public MediaStoreImageThumbLoader(Context context) {
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return MediaStoreUtil.isMediaStoreImageUri(model);
   }
 
@@ -43,9 +45,15 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
+    @NonNull
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreImageThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index 1ab758391..0685decb1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -2,38 +2,40 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 
 /**
  * Loads {@link InputStream}s from media store video {@link Uri}s that point to pre-generated
  * thumbnails for those {@link Uri}s in the media store.
  *
- * <p>If {@link VideoBitmapDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
- * {@link VideoBitmapDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
+ * <p>If {@link VideoDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
+ * {@link VideoDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
  * store does not use a defined frame to generate the thumbnail, so we cannot accurately fulfill
  * requests for specific frames.
  */
 public class MediaStoreVideoThumbLoader implements ModelLoader<Uri, InputStream> {
   private final Context context;
 
-  MediaStoreVideoThumbLoader(Context context) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public MediaStoreVideoThumbLoader(Context context) {
     this.context = context.getApplicationContext();
   }
 
   @Override
   @Nullable
-  public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull Uri model, int width, int height,
+      @NonNull Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
     } else {
@@ -42,12 +44,12 @@
   }
 
   private boolean isRequestingDefaultFrame(Options options) {
-    Long specifiedFrame = options.get(VideoBitmapDecoder.TARGET_FRAME);
-    return specifiedFrame != null && specifiedFrame == VideoBitmapDecoder.DEFAULT_FRAME;
+    Long specifiedFrame = options.get(VideoDecoder.TARGET_FRAME);
+    return specifiedFrame != null && specifiedFrame == VideoDecoder.DEFAULT_FRAME;
   }
 
   @Override
-  public boolean handles(Uri model) {
+  public boolean handles(@NonNull Uri model) {
     return MediaStoreUtil.isMediaStoreVideoUri(model);
   }
 
@@ -57,9 +59,15 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
+    @NonNull
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreVideoThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
index 5cbda7216..c3995affa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 import java.net.URL;
 
@@ -20,17 +18,20 @@
 public class UrlLoader implements ModelLoader<URL, InputStream> {
   private final ModelLoader<GlideUrl, InputStream> glideUrlLoader;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public UrlLoader(ModelLoader<GlideUrl, InputStream> glideUrlLoader) {
     this.glideUrlLoader = glideUrlLoader;
   }
 
   @Override
-  public LoadData<InputStream> buildLoadData(URL model, int width, int height, Options options) {
+  public LoadData<InputStream> buildLoadData(@NonNull URL model, int width, int height,
+      @NonNull Options options) {
     return glideUrlLoader.buildLoadData(new GlideUrl(model), width, height, options);
   }
 
   @Override
-  public boolean handles(URL model) {
+  public boolean handles(@NonNull URL model) {
     return true;
   }
 
@@ -39,9 +40,9 @@ public boolean handles(URL model) {
    */
   public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
 
+    @NonNull
     @Override
-    public ModelLoader<URL, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<URL, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
index 5291061e0..9b6c8e465 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.Preconditions;
 
@@ -14,16 +15,18 @@
 public class SimpleResource<T> implements Resource<T> {
   protected final T data;
 
-  public SimpleResource(T data) {
+  public SimpleResource(@NonNull T data) {
     this.data = Preconditions.checkNotNull(data);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   @Override
   public Class<T> getResourceClass() {
     return (Class<T>) data.getClass();
   }
 
+  @NonNull
   @Override
   public final T get() {
     return data;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
index 702ed39f0..9602c2564 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
@@ -1,17 +1,18 @@
 package com.bumptech.glide.load.resource;
 
+import android.content.Context;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.security.MessageDigest;
 
 /**
- * A noop Transformation that simply returns the given resource.
+ * A no-op Transformation that simply returns the given resource.
  *
  * @param <T> The type of the resource that will always be returned unmodified.
  */
 public final class UnitTransformation<T> implements Transformation<T> {
-  private static final Transformation<?> TRANSFORMATION = new UnitTransformation<Object>();
+  private static final Transformation<?> TRANSFORMATION = new UnitTransformation<>();
 
   /**
    * Returns a UnitTransformation for the given type.
@@ -19,6 +20,7 @@
    * @param <T> The type of the resource to be transformed.
    */
   @SuppressWarnings("unchecked")
+  @NonNull
   public static <T> UnitTransformation<T> get() {
     return (UnitTransformation<T>) TRANSFORMATION;
   }
@@ -27,13 +29,15 @@ private UnitTransformation() {
     // Only accessible as a singleton.
   }
 
+  @NonNull
   @Override
-  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,
+      int outWidth, int outHeight) {
     return resource;
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     // Do nothing.
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
index 6b9d9afae..40a2d4c92 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
@@ -4,14 +4,12 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
-import com.bumptech.glide.Glide;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.io.IOException;
 
 /**
@@ -23,32 +21,41 @@
 
   private final ResourceDecoder<DataType, Bitmap> decoder;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
+  // Public API.
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public BitmapDrawableDecoder(Context context, ResourceDecoder<DataType, Bitmap> decoder) {
-    this(context.getResources(), Glide.get(context).getBitmapPool(), decoder);
+    this(context.getResources(), decoder);
   }
 
-  public BitmapDrawableDecoder(Resources resources, BitmapPool bitmapPool,
+  /**
+   * @deprecated Use {@link #BitmapDrawableDecoder(Context, ResourceDecoder)}, {@code bitmapPool}
+   * is ignored.
+   */
+  @Deprecated
+  public BitmapDrawableDecoder(
+      Resources resources,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
       ResourceDecoder<DataType, Bitmap> decoder) {
+    this(resources, decoder);
+  }
+
+  public BitmapDrawableDecoder(
+      @NonNull Resources resources, @NonNull ResourceDecoder<DataType, Bitmap> decoder) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.decoder = Preconditions.checkNotNull(decoder);
   }
 
   @Override
-  public boolean handles(DataType source, Options options) throws IOException {
+  public boolean handles(@NonNull DataType source, @NonNull Options options) throws IOException {
     return decoder.handles(source, options);
   }
 
   @Override
-  public Resource<BitmapDrawable> decode(DataType source, int width, int height, Options options)
+  public Resource<BitmapDrawable> decode(@NonNull DataType source, int width, int height,
+      @NonNull Options options)
       throws IOException {
     Resource<Bitmap> bitmapResource = decoder.decode(source, width, height, options);
-    if (bitmapResource == null) {
-      return null;
-    }
-
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, bitmapResource.get());
+    return LazyBitmapDrawableResource.obtain(resources, bitmapResource);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
index 162783822..a955d9d05 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
@@ -2,13 +2,12 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.io.File;
 
 /**
@@ -25,12 +24,14 @@ public BitmapDrawableEncoder(BitmapPool bitmapPool, ResourceEncoder<Bitmap> enco
   }
 
   @Override
-  public boolean encode(Resource<BitmapDrawable> data, File file, Options options) {
+  public boolean encode(@NonNull Resource<BitmapDrawable> data, @NonNull File file,
+      @NonNull Options options) {
     return encoder.encode(new BitmapResource(data.get().getBitmap(), bitmapPool), file, options);
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return encoder.getEncodeStrategy(options);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index fc80aa1fa..736c02ea6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.drawable.BitmapDrawable;
-
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 import com.bumptech.glide.util.Util;
@@ -16,14 +17,18 @@
  * given {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is
  * recycled. </p>
  */
-public class BitmapDrawableResource extends DrawableResource<BitmapDrawable> {
+public class BitmapDrawableResource extends DrawableResource<BitmapDrawable>
+    implements Initializable {
   private final BitmapPool bitmapPool;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
     super(drawable);
     this.bitmapPool = bitmapPool;
   }
 
+  @NonNull
   @Override
   public Class<BitmapDrawable> getResourceClass() {
     return BitmapDrawable.class;
@@ -38,4 +43,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(drawable.getBitmap());
   }
+
+  @Override
+  public void initialize() {
+    drawable.getBitmap().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
index 6527b931e..a783e616c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -3,53 +3,79 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
-import com.bumptech.glide.Glide;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
  * Transforms {@link android.graphics.drawable.BitmapDrawable}s.
+ *
+ * @deprecated Use {@link DrawableTransformation} instead.
  */
+@Deprecated
 public class BitmapDrawableTransformation implements Transformation<BitmapDrawable> {
 
-  private final Context context;
-  private final BitmapPool bitmapPool;
-  private final Transformation<Bitmap> wrapped;
+  private final Transformation<Drawable> wrapped;
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
+    this.wrapped =
+        Preconditions.checkNotNull(new DrawableTransformation(wrapped, /*isRequired=*/ false));
+  }
 
-  public BitmapDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
-    this(context, Glide.get(context).getBitmapPool(), wrapped);
+  /**
+   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
+   */
+  @Deprecated
+  public BitmapDrawableTransformation(
+      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
+    this(wrapped);
   }
 
-  // Visible for testing.
-  BitmapDrawableTransformation(Context context, BitmapPool bitmapPool,
+  /**
+   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
+   */
+  @Deprecated
+  public BitmapDrawableTransformation(
+      @SuppressWarnings("unused") Context context,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
       Transformation<Bitmap> wrapped) {
-    this.context = context.getApplicationContext();
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
-    this.wrapped = Preconditions.checkNotNull(wrapped);
+    this(wrapped);
   }
 
+  @NonNull
   @Override
-  public Resource<BitmapDrawable> transform(Resource<BitmapDrawable> drawableResourceToTransform,
+  public Resource<BitmapDrawable> transform(
+      @NonNull Context context, @NonNull Resource<BitmapDrawable> drawableResourceToTransform,
       int outWidth, int outHeight) {
-    BitmapDrawable drawableToTransform = drawableResourceToTransform.get();
-    Bitmap bitmapToTransform = drawableToTransform.getBitmap();
-
-    BitmapResource bitmapResourceToTransform = BitmapResource.obtain(bitmapToTransform, bitmapPool);
-    Resource<Bitmap> transformedBitmapResource =
-        wrapped.transform(bitmapResourceToTransform, outWidth, outHeight);
+    Resource<Drawable> toTransform = convertToDrawableResource(drawableResourceToTransform);
+    Resource<Drawable> transformed = wrapped.transform(context, toTransform, outWidth, outHeight);
+    return convertToBitmapDrawableResource(transformed);
+  }
 
-    if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
-      return drawableResourceToTransform;
-    } else {
-      return LazyBitmapDrawableResource.obtain(context, transformedBitmapResource.get());
+  @SuppressWarnings("unchecked")
+  private static Resource<BitmapDrawable> convertToBitmapDrawableResource(
+      Resource<Drawable> resource) {
+    if (!(resource.get() instanceof BitmapDrawable)) {
+      throw new IllegalArgumentException(
+          "Wrapped transformation unexpectedly returned a non BitmapDrawable resource: "
+              + resource.get());
     }
+    return (Resource<BitmapDrawable>) (Resource<?>) resource;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Resource<Drawable> convertToDrawableResource(
+      Resource<BitmapDrawable> toConvert) {
+    return (Resource<Drawable>) (Resource<? extends Drawable>) toConvert;
   }
 
+  @SuppressWarnings("deprecation")
   @Override
   public boolean equals(Object o) {
     if (o instanceof BitmapDrawableTransformation) {
@@ -65,7 +91,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     wrapped.updateDiskCacheKey(messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index d769ae12a..5c949e6e3 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -1,16 +1,19 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.os.TraceCompat;
 import android.util.Log;
-
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.data.BufferedOutputStream;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -49,41 +52,66 @@
       "com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionFormat");
 
   private static final String TAG = "BitmapEncoder";
+  @Nullable
+  private final ArrayPool arrayPool;
+
+  public BitmapEncoder(@NonNull ArrayPool arrayPool) {
+    this.arrayPool = arrayPool;
+  }
+
+  /**
+   * @deprecated Use {@link #BitmapEncoder(ArrayPool)} instead.
+   */
+  @Deprecated
+  public BitmapEncoder() {
+    arrayPool = null;
+  }
 
   @Override
-  public boolean encode(Resource<Bitmap> resource, File file, Options options) {
+  public boolean encode(@NonNull Resource<Bitmap> resource, @NonNull File file,
+      @NonNull Options options) {
     final Bitmap bitmap = resource.get();
-
-    long start = LogTime.getLogTime();
     Bitmap.CompressFormat format = getFormat(bitmap, options);
-    int quality = options.get(COMPRESSION_QUALITY);
-
-    boolean success = false;
-    OutputStream os = null;
+    TraceCompat.beginSection(
+        "encode: [" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + format);
     try {
-      os = new FileOutputStream(file);
-      bitmap.compress(format, quality, os);
-      os.close();
-      success = true;
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Failed to encode Bitmap", e);
-      }
-    } finally {
-      if (os != null) {
-        try {
-          os.close();
-        } catch (IOException e) {
-          // Do nothing.
+      long start = LogTime.getLogTime();
+      int quality = options.get(COMPRESSION_QUALITY);
+
+      boolean success = false;
+      OutputStream os = null;
+      try {
+        os = new FileOutputStream(file);
+        if (arrayPool != null) {
+          os = new BufferedOutputStream(os, arrayPool);
+        }
+        bitmap.compress(format, quality, os);
+        os.close();
+        success = true;
+      } catch (IOException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Failed to encode Bitmap", e);
+        }
+      } finally {
+        if (os != null) {
+          try {
+            os.close();
+          } catch (IOException e) {
+            // Do nothing.
+          }
         }
       }
-    }
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Compressed with type: " + format + " of size " + Util.getBitmapByteSize(bitmap)
-          + " in " + LogTime.getElapsedMillis(start));
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Compressed with type: " + format + " of size " + Util.getBitmapByteSize(bitmap)
+            + " in " + LogTime.getElapsedMillis(start)
+            + ", options format: " + options.get(COMPRESSION_FORMAT)
+            + ", hasAlpha: " + bitmap.hasAlpha());
+      }
+      return success;
+    } finally {
+      TraceCompat.endSection();
     }
-    return success;
   }
 
   private Bitmap.CompressFormat getFormat(Bitmap bitmap, Options options) {
@@ -97,8 +125,9 @@ public boolean encode(Resource<Bitmap> resource, File file, Options options) {
     }
   }
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return EncodeStrategy.TRANSFORMED;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 4753d2476..49e57a956 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
@@ -11,7 +12,8 @@
 /**
  * A resource wrapping a {@link android.graphics.Bitmap} object.
  */
-public class BitmapResource implements Resource<Bitmap> {
+public class BitmapResource implements Resource<Bitmap>,
+    Initializable {
   private final Bitmap bitmap;
   private final BitmapPool bitmapPool;
 
@@ -23,7 +25,7 @@
    * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}.
    */
   @Nullable
-  public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPool) {
+  public static BitmapResource obtain(@Nullable Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
     if (bitmap == null) {
       return null;
     } else {
@@ -31,16 +33,18 @@ public static BitmapResource obtain(@Nullable Bitmap bitmap, BitmapPool bitmapPo
     }
   }
 
-  public BitmapResource(Bitmap bitmap, BitmapPool bitmapPool) {
+  public BitmapResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {
     this.bitmap = Preconditions.checkNotNull(bitmap, "Bitmap must not be null");
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool, "BitmapPool must not be null");
   }
 
+  @NonNull
   @Override
   public Class<Bitmap> getResourceClass() {
     return Bitmap.class;
   }
 
+  @NonNull
   @Override
   public Bitmap get() {
     return bitmap;
@@ -55,4 +59,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(bitmap);
   }
+
+  @Override
+  public void initialize() {
+    bitmap.prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index cdd367c82..8dd0827ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -3,13 +3,14 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
 
 /**
  * A simple {@link com.bumptech.glide.load.Transformation} for transforming
@@ -19,7 +20,7 @@
  * Use cases will look something like this:
  * <pre>
  * <code>
- * public class FillSpace extends BaseBitmapTransformation {
+ * public class FillSpace extends BitmapTransformation {
  *     private static final String ID = "com.bumptech.glide.transformations.FillSpace";
  *     private static final String ID_BYTES = ID.getBytes(STRING_CHARSET_NAME);
  *
@@ -50,26 +51,46 @@
  * }
  * </code>
  * </pre>
+ *
+ * <p>Using the fully qualified class name as a static final {@link String} (not
+ * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement
+ * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are
+ * required they can be passed in to the constructor of the {@code Transformation} and then used to
+ * update the {@link java.security.MessageDigest} passed in to
+ * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically
+ * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized
+ * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}.
+ *
+ * <p>As with all {@link Transformation}s, all subclasses <em>must</em> implement
+ * {@link #equals(Object)} and {@link #hashCode()} for memory caching to work correctly.
  */
 public abstract class BitmapTransformation implements Transformation<Bitmap> {
 
-  private final BitmapPool bitmapPool;
-
-  public BitmapTransformation(Context context) {
-    this(Glide.get(context).getBitmapPool());
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapTransformation() {
+    // Intentionally empty.
   }
 
-  public BitmapTransformation(BitmapPool bitmapPool) {
-    this.bitmapPool = bitmapPool;
+  /**
+   * @deprecated Use {@link #BitmapTransformation()}.
+   * @param context Ignored.
+   */
+  @Deprecated
+  public BitmapTransformation(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
+  @NonNull
   @Override
-  public final Resource<Bitmap> transform(Resource<Bitmap> resource, int outWidth, int outHeight) {
+  public final Resource<Bitmap> transform(
+      @NonNull Context context, @NonNull Resource<Bitmap> resource, int outWidth, int outHeight) {
     if (!Util.isValidDimensions(outWidth, outHeight)) {
       throw new IllegalArgumentException(
           "Cannot apply transformation on width: " + outWidth + " or height: " + outHeight
               + " less than or equal to zero and not Target.SIZE_ORIGINAL");
     }
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Bitmap toTransform = resource.get();
     int targetWidth = outWidth == Target.SIZE_ORIGINAL ? toTransform.getWidth() : outWidth;
     int targetHeight = outHeight == Target.SIZE_ORIGINAL ? toTransform.getHeight() : outHeight;
@@ -109,9 +130,9 @@ public BitmapTransformation(BitmapPool bitmapPool) {
    * @param toTransform The {@link android.graphics.Bitmap} to transform.
    * @param outWidth    The ideal width of the transformed bitmap (the transformed width does not
    *                    need to match exactly).
-   * @param outHeight   The ideal height of the transformed bitmap (the transformed heightdoes not
+   * @param outHeight   The ideal height of the transformed bitmap (the transformed height does not
    *                    need to match exactly).
    */
-  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
-      int outWidth, int outHeight);
+  protected abstract Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
index 6a89df27a..e5e335bc4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -1,14 +1,134 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.request.transition.BitmapTransitionFactory;
+import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
+import com.bumptech.glide.request.transition.TransitionFactory;
 
 /**
- * Provides {@link Bitmap} specific animation options.
- *
- * TODO: we should probably just use GenericAnimationOptions instead.
+ * Contains {@link Bitmap} specific animation options.
  */
-public final class BitmapTransitionOptions extends TransitionOptions<BitmapTransitionOptions,
-    Bitmap> {
+// Public API.
+@SuppressWarnings({"unused", "WeakerAccess"})
+public final class BitmapTransitionOptions extends
+    TransitionOptions<BitmapTransitionOptions, Bitmap> {
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade()
+   */
+  @NonNull
+  public static BitmapTransitionOptions withCrossFade() {
+    return new BitmapTransitionOptions().crossFade();
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int)
+   */
+  @NonNull
+  public static BitmapTransitionOptions withCrossFade(int duration) {
+    return new BitmapTransitionOptions().crossFade(duration);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory)
+   */
+  @NonNull
+  public static BitmapTransitionOptions withCrossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return new BitmapTransitionOptions().crossFade(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory.Builder)
+   */
+  @NonNull
+  public static BitmapTransitionOptions withCrossFade(
+      @NonNull DrawableCrossFadeFactory.Builder builder) {
+    return new BitmapTransitionOptions().crossFade(builder);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a any animation
+   * that is possible on drawables.
+   *
+   * @see #transitionUsing(TransitionFactory)
+   */
+  @NonNull
+  public static BitmapTransitionOptions withWrapped(
+      @NonNull TransitionFactory<Drawable> drawableCrossFadeFactory) {
+    return new BitmapTransitionOptions().transitionUsing(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that uses the given transition factory.
+   *
+   * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
+   */
+  @NonNull
+  public static BitmapTransitionOptions with(
+      @NonNull TransitionFactory<Bitmap> transitionFactory) {
+    return new BitmapTransitionOptions().transition(transitionFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  @NonNull
+  public BitmapTransitionOptions crossFade() {
+    return crossFade(new DrawableCrossFadeFactory.Builder());
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param duration The duration of the animation, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}.
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
+  @NonNull
+  public BitmapTransitionOptions crossFade(int duration) {
+    return crossFade(new DrawableCrossFadeFactory.Builder(duration));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  @NonNull
+  public BitmapTransitionOptions crossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return transitionUsing(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Enables a any Drawable based animation to run on Bitmaps as well.
+   */
+  @NonNull
+  public BitmapTransitionOptions transitionUsing(
+      @NonNull TransitionFactory<Drawable> drawableCrossFadeFactory) {
+    return transition(new BitmapTransitionFactory(drawableCrossFadeFactory));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  @NonNull
+  public BitmapTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Builder builder) {
+    return transitionUsing(builder.build());
+  }
 }
+
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
index b8cb4624a..97084a025 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -22,12 +21,13 @@ public ByteBufferBitmapDecoder(Downsampler downsampler) {
   }
 
   @Override
-  public boolean handles(ByteBuffer source, Options options) throws IOException {
+  public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) {
     return downsampler.handles(source);
   }
 
   @Override
-  public Resource<Bitmap> decode(ByteBuffer source, int width, int height, Options options)
+  public Resource<Bitmap> decode(@NonNull ByteBuffer source, int width, int height,
+      @NonNull Options options)
       throws IOException {
     InputStream is = ByteBufferUtil.toStream(source);
     return downsampler.decode(is, width, height, options);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index c81d59b9b..da0d1a1ec 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -1,11 +1,8 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -19,19 +16,9 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterCrop";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterCrop(Context context) {
-    super(context);
-  }
-
-  public CenterCrop(BitmapPool bitmapPool) {
-    super(bitmapPool);
-  }
-
-  // Bitmap doesn't implement equals, so == and .equals are equivalent here.
-  @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);
   }
 
@@ -46,7 +33,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
new file mode 100644
index 000000000..b707b0fc8
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import java.security.MessageDigest;
+
+/**
+ * Returns the image with its original size if its dimensions match or are smaller
+ * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}
+ * in order to center it in Target. If not, then it is scaled so that one of the dimensions of
+ * the image will be equal to the given dimension and the other will be less than the given
+ * dimension (maintaining the image's aspect ratio).
+ */
+public class CenterInside extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  @Override
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return o instanceof CenterInside;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+  }
+}
+
+
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
index 39b602969..7d5d5968b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
@@ -1,11 +1,8 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -21,19 +18,11 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CircleCrop." + VERSION;
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CircleCrop(Context context) {
-    super(context);
-  }
-
-  public CircleCrop(BitmapPool bitmapPool) {
-    super(bitmapPool);
-  }
-
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);
   }
 
@@ -48,7 +37,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
similarity index 59%
rename from library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
rename to library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index 2411ddab0..a6e7c10cb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -1,16 +1,16 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.GIF;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.JPEG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG_A;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.UNKNOWN;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.GIF;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.JPEG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG_A;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.UNKNOWN;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -20,88 +20,79 @@
 /**
  * A class for parsing the exif orientation and other data from an image header.
  */
-public class ImageHeaderParser {
-  private static final String TAG = "ImageHeaderParser";
-  /**
-   * A constant indicating we were unable to parse the orientation from the image either because
-   * no exif segment containing orientation data existed, or because of an I/O error attempting to
-   * read the exif segment.
-   */
-  public static final int UNKNOWN_ORIENTATION = -1;
-
-  /**
-   * The format of the image data including whether or not the image may include transparent
-   * pixels.
-   */
-  public enum ImageType {
-    GIF(true),
-    JPEG(false),
-    /** PNG type with alpha. */
-    PNG_A(true),
-    /** PNG type without alpha. */
-    PNG(false),
-    /**
-     * Unrecognized type.
-     */
-    UNKNOWN(false);
-    private final boolean hasAlpha;
-
-    ImageType(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
-  }
+public final class DefaultImageHeaderParser implements ImageHeaderParser {
+  // Due to https://code.google.com/p/android/issues/detail?id=97751.
+  // TAG needs to be under 23 chars, so "Default" > "Dflt".
+  private static final String TAG = "DfltImageHeaderParser";
 
   private static final int GIF_HEADER = 0x474946;
   private static final int PNG_HEADER = 0x89504E47;
-  private static final int EXIF_MAGIC_NUMBER = 0xFFD8;
+  static final int EXIF_MAGIC_NUMBER = 0xFFD8;
   // "MM".
   private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
   // "II".
   private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
   private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
-  private static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
+  static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
       JPEG_EXIF_SEGMENT_PREAMBLE.getBytes(Charset.forName("UTF-8"));
   private static final int SEGMENT_SOS = 0xDA;
   private static final int MARKER_EOI = 0xD9;
-  private static final int SEGMENT_START_ID = 0xFF;
-  private static final int EXIF_SEGMENT_TYPE = 0xE1;
+  static final int SEGMENT_START_ID = 0xFF;
+  static final int EXIF_SEGMENT_TYPE = 0xE1;
   private static final int ORIENTATION_TAG_TYPE = 0x0112;
   private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
+  // WebP-related
+  // "RIFF"
+  private static final int RIFF_HEADER = 0x52494646;
+  // "WEBP"
+  private static final int WEBP_HEADER = 0x57454250;
+  // "VP8" null.
+  private static final int VP8_HEADER = 0x56503800;
+  private static final int VP8_HEADER_MASK = 0xFFFFFF00;
+  private static final int VP8_HEADER_TYPE_MASK = 0x000000FF;
+  // 'X'
+  private static final int VP8_HEADER_TYPE_EXTENDED = 0x00000058;
+  // 'L'
+  private static final int VP8_HEADER_TYPE_LOSSLESS = 0x0000004C;
+  private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
+  private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
+
+  @NonNull
+  @Override
+  public ImageType getType(@NonNull InputStream is) throws IOException {
+    return getType(new StreamReader(Preconditions.checkNotNull(is)));
+  }
 
-  private final ByteArrayPool byteArrayPool;
-  private final Reader reader;
-
-  public ImageHeaderParser(InputStream is, ByteArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(is);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new StreamReader(is);
+  @NonNull
+  @Override
+  public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {
+    return getType(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)));
   }
 
-  public ImageHeaderParser(ByteBuffer byteBuffer, ByteArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(byteBuffer);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new ByteBufferReader(byteBuffer);
+  @Override
+  public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
+    return getOrientation(new StreamReader(Preconditions.checkNotNull(is)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  // 0xD0A3C68 -> <htm
-  // 0xCAFEBABE -> <!DOCTYPE...
-  public boolean hasAlpha() throws IOException {
-    return getType().hasAlpha();
+  @Override
+  public int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool)
+      throws IOException {
+    return getOrientation(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  public ImageType getType() throws IOException {
-    int firstTwoBytes = reader.getUInt16();
+  @NonNull
+  private ImageType getType(Reader reader) throws IOException {
+    final int firstTwoBytes = reader.getUInt16();
 
     // JPEG.
     if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
       return JPEG;
     }
 
-    final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    final int firstFourBytes = (firstTwoBytes << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
     // PNG.
     if (firstFourBytes == PNG_HEADER) {
       // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha
@@ -117,7 +108,35 @@ public ImageType getType() throws IOException {
       return GIF;
     }
 
-    return UNKNOWN;
+    // WebP (reads up to 21 bytes). See https://developers.google.com/speed/webp/docs/riff_container
+    // for details.
+    if (firstFourBytes != RIFF_HEADER) {
+      return UNKNOWN;
+    }
+    // Bytes 4 - 7 contain length information. Skip these.
+    reader.skip(4);
+    final int thirdFourBytes =
+        (reader.getUInt16() << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
+    if (thirdFourBytes != WEBP_HEADER) {
+      return UNKNOWN;
+    }
+    final int fourthFourBytes =
+        (reader.getUInt16() << 16 & 0xFFFF0000) | (reader.getUInt16() & 0xFFFF);
+    if ((fourthFourBytes & VP8_HEADER_MASK) != VP8_HEADER) {
+      return UNKNOWN;
+    }
+    if ((fourthFourBytes & VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_EXTENDED) {
+      // Skip some more length bytes and check for transparency/alpha flag.
+      reader.skip(4);
+      return (reader.getByte() & WEBP_EXTENDED_ALPHA_FLAG) != 0 ? ImageType.WEBP_A : ImageType.WEBP;
+    }
+    if ((fourthFourBytes & VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_LOSSLESS) {
+      // See chromium.googlesource.com/webm/libwebp/+/master/doc/webp-lossless-bitstream-spec.txt
+      // for more info.
+      reader.skip(4);
+      return (reader.getByte() & WEBP_LOSSLESS_ALPHA_FLAG) != 0 ? ImageType.WEBP_A : ImageType.WEBP;
+    }
+    return ImageType.WEBP;
   }
 
   /**
@@ -126,9 +145,8 @@ public ImageType getType() throws IOException {
    *
    * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
    * contain an orientation
-   * @throws IOException
    */
-  public int getOrientation() throws IOException {
+  private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOException {
     final int magicNumber = reader.getUInt16();
 
     if (!handles(magicNumber)) {
@@ -137,7 +155,7 @@ public int getOrientation() throws IOException {
       }
       return UNKNOWN_ORIENTATION;
     } else {
-      int exifSegmentLength = moveToExifSegmentAndGetLength();
+      int exifSegmentLength = moveToExifSegmentAndGetLength(reader);
       if (exifSegmentLength == -1) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Failed to parse exif segment length, or exif segment not found");
@@ -145,16 +163,17 @@ public int getOrientation() throws IOException {
         return UNKNOWN_ORIENTATION;
       }
 
-      byte[] exifData = byteArrayPool.get(exifSegmentLength);
+      byte[] exifData = byteArrayPool.get(exifSegmentLength, byte[].class);
       try {
-        return parseExifSegment(exifData, exifSegmentLength);
+        return parseExifSegment(reader, exifData, exifSegmentLength);
       } finally {
         byteArrayPool.put(exifData);
       }
     }
   }
 
-  private int parseExifSegment(byte[] tempArray, int exifSegmentLength) throws IOException {
+  private int parseExifSegment(Reader reader, byte[] tempArray, int exifSegmentLength)
+      throws IOException {
     int read = reader.read(tempArray, exifSegmentLength);
     if (read != exifSegmentLength) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -194,11 +213,9 @@ private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
    * Moves reader to the start of the exif segment and returns the length of the exif segment or
    * {@code -1} if no exif segment is found.
    */
-  private int moveToExifSegmentAndGetLength() throws IOException {
-    short segmentId, segmentType;
-    int segmentLength;
+  private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
     while (true) {
-      segmentId = reader.getUInt8();
+      short segmentId = reader.getUInt8();
       if (segmentId != SEGMENT_START_ID) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Unknown segmentId=" + segmentId);
@@ -206,8 +223,7 @@ private int moveToExifSegmentAndGetLength() throws IOException {
         return -1;
       }
 
-      segmentType = reader.getUInt8();
-
+      short segmentType = reader.getUInt8();
       if (segmentType == SEGMENT_SOS) {
         return -1;
       } else if (segmentType == MARKER_EOI) {
@@ -218,18 +234,17 @@ private int moveToExifSegmentAndGetLength() throws IOException {
       }
 
       // Segment length includes bytes for segment length.
-      segmentLength = reader.getUInt16() - 2;
-
+      int segmentLength = reader.getUInt16() - 2;
       if (segmentType != EXIF_SEGMENT_TYPE) {
         long skipped = reader.skip(segmentLength);
         if (skipped != segmentLength) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Unable to skip enough data"
-                    + ", type: " + segmentType
-                    + ", wanted to skip: " + segmentLength
-                    + ", but actually skipped: " + skipped);
-            }
-            return -1;
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Unable to skip enough data"
+                + ", type: " + segmentType
+                + ", wanted to skip: " + segmentLength
+                + ", but actually skipped: " + skipped);
+          }
+          return -1;
         }
       } else {
         return segmentLength;
@@ -242,34 +257,35 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
 
     short byteOrderIdentifier = segmentData.getInt16(headerOffsetSize);
     final ByteOrder byteOrder;
-    if (byteOrderIdentifier == MOTOROLA_TIFF_MAGIC_NUMBER) {
-      byteOrder = ByteOrder.BIG_ENDIAN;
-    } else if (byteOrderIdentifier == INTEL_TIFF_MAGIC_NUMBER) {
-      byteOrder = ByteOrder.LITTLE_ENDIAN;
-    } else {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
-      }
-      byteOrder = ByteOrder.BIG_ENDIAN;
+    switch (byteOrderIdentifier) {
+      case MOTOROLA_TIFF_MAGIC_NUMBER:
+        byteOrder = ByteOrder.BIG_ENDIAN;
+        break;
+      case INTEL_TIFF_MAGIC_NUMBER:
+        byteOrder = ByteOrder.LITTLE_ENDIAN;
+        break;
+      default:
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Unknown endianness = " + byteOrderIdentifier);
+        }
+        byteOrder = ByteOrder.BIG_ENDIAN;
+        break;
     }
 
     segmentData.order(byteOrder);
 
     int firstIfdOffset = segmentData.getInt32(headerOffsetSize + 4) + headerOffsetSize;
     int tagCount = segmentData.getInt16(firstIfdOffset);
-
-    int tagOffset, tagType, formatCode, componentCount;
     for (int i = 0; i < tagCount; i++) {
-      tagOffset = calcTagOffset(firstIfdOffset, i);
-      tagType = segmentData.getInt16(tagOffset);
+      final int tagOffset = calcTagOffset(firstIfdOffset, i);
 
+      final int tagType = segmentData.getInt16(tagOffset);
       // We only want orientation.
       if (tagType != ORIENTATION_TAG_TYPE) {
         continue;
       }
 
-      formatCode = segmentData.getInt16(tagOffset + 2);
-
+      final int formatCode = segmentData.getInt16(tagOffset + 2);
       // 12 is max format code.
       if (formatCode < 1 || formatCode > 12) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -278,8 +294,7 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
         continue;
       }
 
-      componentCount = segmentData.getInt32(tagOffset + 4);
-
+      final int componentCount = segmentData.getInt32(tagOffset + 4);
       if (componentCount < 0) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Negative tiff component count");
@@ -293,7 +308,6 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       final int byteCount = componentCount + BYTES_PER_FORMAT[formatCode];
-
       if (byteCount > 4) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Got byte count > 4, not orientation, continuing, formatCode=" + formatCode);
@@ -302,7 +316,6 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       final int tagValueOffset = tagOffset + 8;
-
       if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
@@ -334,29 +347,33 @@ private static boolean handles(int imageMagicNumber) {
         || imageMagicNumber == INTEL_TIFF_MAGIC_NUMBER;
   }
 
-  private static class RandomAccessReader {
+  private static final class RandomAccessReader {
     private final ByteBuffer data;
 
-    public RandomAccessReader(byte[] data, int length) {
+    RandomAccessReader(byte[] data, int length) {
       this.data = (ByteBuffer) ByteBuffer.wrap(data)
           .order(ByteOrder.BIG_ENDIAN)
           .limit(length);
     }
 
-    public void order(ByteOrder byteOrder) {
+    void order(ByteOrder byteOrder) {
       this.data.order(byteOrder);
     }
 
-    public int length() {
+    int length() {
       return data.remaining();
     }
 
-    public int getInt32(int offset) {
-      return data.getInt(offset);
+    int getInt32(int offset) {
+      return isAvailable(offset, 4) ? data.getInt(offset) : -1;
+    }
+
+    short getInt16(int offset) {
+      return isAvailable(offset, 2) ? data.getShort(offset) : -1;
     }
 
-    public short getInt16(int offset) {
-      return data.getShort(offset);
+    private boolean isAvailable(int offset, int byteSize) {
+      return data.remaining() - offset >= byteSize;
     }
   }
 
@@ -368,41 +385,44 @@ public short getInt16(int offset) {
     int getByte() throws IOException;
   }
 
-  private static class ByteBufferReader implements Reader {
+  private static final class ByteBufferReader implements Reader {
 
     private final ByteBuffer byteBuffer;
 
-    public ByteBufferReader(ByteBuffer byteBuffer) {
+    ByteBufferReader(ByteBuffer byteBuffer) {
       this.byteBuffer = byteBuffer;
       byteBuffer.order(ByteOrder.BIG_ENDIAN);
     }
 
     @Override
-    public int getUInt16() throws IOException {
+    public int getUInt16() {
       return (getByte() << 8 & 0xFF00) | (getByte() & 0xFF);
     }
 
     @Override
-    public short getUInt8() throws IOException {
+    public short getUInt8() {
       return (short) (getByte() & 0xFF);
     }
 
     @Override
-    public long skip(long total) throws IOException {
+    public long skip(long total) {
       int toSkip = (int) Math.min(byteBuffer.remaining(), total);
       byteBuffer.position(byteBuffer.position() + toSkip);
       return toSkip;
     }
 
     @Override
-    public int read(byte[] buffer, int byteCount) throws IOException {
+    public int read(byte[] buffer, int byteCount) {
       int toRead = Math.min(byteCount, byteBuffer.remaining());
-      byteBuffer.get(buffer, 0 /*dstOffset*/, byteCount);
+      if (toRead == 0) {
+        return -1;
+      }
+      byteBuffer.get(buffer, 0 /*dstOffset*/, toRead);
       return toRead;
     }
 
     @Override
-    public int getByte() throws IOException {
+    public int getByte() {
       if (byteBuffer.remaining() < 1) {
         return -1;
       }
@@ -410,10 +430,11 @@ public int getByte() throws IOException {
     }
   }
 
-  private static class StreamReader implements Reader {
+  private static final class StreamReader implements Reader {
     private final InputStream is;
+
     // Motorola / big endian byte order.
-    public StreamReader(InputStream is) {
+    StreamReader(InputStream is) {
       this.is = is;
     }
 
@@ -470,4 +491,3 @@ public int getByte() throws IOException {
     }
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index 0ab010b53..c60666adf 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -1,8 +1,12 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import com.bumptech.glide.util.Synthetic;
+
 /**
  * Indicates the algorithm to use when downsampling images.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class DownsampleStrategy {
 
   /**
@@ -11,12 +15,13 @@
    * requested size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or
+   * {@link #CENTER_INSIDE}.
    *
    * <p>On pre-KitKat devices, this is equivalent to {@link #AT_MOST} because only power of
    * two downsampling can be used.
    */
-  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
+  public static final DownsampleStrategy FIT_CENTER = new FitCenter();
 
   /**
    * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
@@ -24,7 +29,8 @@
    * the requested size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},
+   * or {@link #CENTER_INSIDE}.
    *
    * <p>On pre-KitKat devices, this is equivalent to {@link #AT_LEAST} because only power of
    * two downsampling can be used.
@@ -43,15 +49,24 @@
    */
   public static final DownsampleStrategy AT_MOST = new AtMost();
 
+  /**
+   * Returns the original image if it is smaller than the target, otherwise it will be downscaled
+   * maintaining its original aspect ratio, so that one of the image's dimensions is exactly equal
+   * to the requested size and the other is less or equal than the requested size.
+   *
+   * <p>This method will not upscale.</p>
+   */
+  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
+
   /**
    * Performs no downsampling or scaling.
    */
   public static final DownsampleStrategy NONE = new None();
 
   /**
-   * Default strategy, currently {@link #AT_LEAST}.
+   * Default strategy, currently {@link #CENTER_OUTSIDE}.
    */
-  public static final DownsampleStrategy DEFAULT = AT_LEAST;
+  public static final DownsampleStrategy DEFAULT = CENTER_OUTSIDE;
 
   /**
    * Returns a float (0, +infinity) indicating a scale factor to apply to the source
@@ -86,7 +101,10 @@ public abstract float getScaleFactor(int sourceWidth, int sourceHeight, int requ
   public abstract SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
       int requestedWidth, int requestedHeight);
 
-  private static class CenterInside extends DownsampleStrategy {
+  private static class FitCenter extends DownsampleStrategy {
+
+    @Synthetic
+    FitCenter() { }
 
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
@@ -104,7 +122,11 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   }
 
   private static class CenterOutside extends DownsampleStrategy {
-     @Override
+
+    @Synthetic
+    CenterOutside() { }
+
+    @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
       float widthPercentage = requestedWidth / (float) sourceWidth;
@@ -121,6 +143,9 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
 
   private static class AtLeast extends DownsampleStrategy {
 
+    @Synthetic
+    AtLeast() { }
+
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
@@ -136,6 +161,10 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   }
 
   private static class AtMost extends DownsampleStrategy {
+
+    @Synthetic
+    AtMost() { }
+
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
@@ -155,7 +184,11 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   }
 
   private static class None extends DownsampleStrategy {
-     @Override
+
+    @Synthetic
+    None() { }
+
+    @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
       return 1f;
@@ -168,6 +201,26 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
     }
   }
 
+  private static class CenterInside extends DownsampleStrategy {
+
+    @Synthetic
+    CenterInside() { }
+
+    @Override
+    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+        int requestedHeight) {
+
+      return Math.min(1.f,
+          FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));
+    }
+
+    @Override
+    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+        int requestedWidth, int requestedHeight) {
+      return SampleSizeRounding.QUALITY;
+    }
+  }
+
   /**
    * Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage
    * or higher quality.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 065e9796a..51e9be79a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -2,27 +2,35 @@
 
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.graphics.BitmapFactory;
 import android.os.Build;
+import android.support.annotation.Nullable;
 import android.util.DisplayMetrics;
 import android.util.Log;
-
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.SampleSizeRounding;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 
@@ -30,7 +38,7 @@
  * Downsamples, decodes, and rotates images according to their exif orientation.
  */
 public final class Downsampler {
-  private static final String TAG = "Downsampler";
+  static final String TAG = "Downsampler";
   /**
    * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction
    * with the image format to determine the {@link android.graphics.Bitmap.Config} to provide to
@@ -45,8 +53,53 @@
    */
   public static final Option<DownsampleStrategy> DOWNSAMPLE_STRATEGY =
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
-          DownsampleStrategy.AT_LEAST);
+          DownsampleStrategy.DEFAULT);
+  /**
+   * Ensure that the size of the bitmap is fixed to the requested width and height of the
+   * resource from the caller.  The final resource dimensions may differ from the requested
+   * width and height, and thus setting this to true may result in the bitmap size differing
+   * from the resource dimensions.
+   *
+   * This can be used as a performance optimization for KitKat and above by fixing the size of the
+   * bitmap for a collection of requested resources so that the bitmap pool will not need to
+   * allocate new bitmaps for images of different sizes.
+   */
+  // Public API
+  @SuppressWarnings("WeakerAccess")
+  public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
+
+  /**
+   * Indicates that it's safe or unsafe to decode {@link Bitmap}s with
+   * {@link Bitmap.Config#HARDWARE}.
+   *
+   * <p>Callers should almost never set this value to {@code true} manually. Glide will already do
+   * so when Glide believes it's safe to do (when no transformations are applied). Instead, callers
+   * can set this value to {@code false} to prevent Glide from decoding hardware bitmaps if Glide
+   * is unable to detect that hardware bitmaps are unsafe. For example, you should set this to
+   * {@code false} if you plan to draw it to a software {@link android.graphics.Canvas} or if you
+   * plan to inspect the {@link Bitmap}s pixels with {@link Bitmap#getPixel(int, int)} or
+   * {@link Bitmap#getPixels(int[], int, int, int, int, int, int)}.
+   *
+   * <p>Callers can disable hardware {@link Bitmap}s for all loads using
+   * {@link com.bumptech.glide.GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+   *
+   * <p>This option is ignored unless we're on Android O+.
+   */
+  public static final Option<Boolean> ALLOW_HARDWARE_CONFIG =
+      Option.memory("com.bumtpech.glide.load.resource.bitmap.Downsampler.AllowHardwareDecode");
 
+  private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
+  private static final String ICO_MIME_TYPE = "image/x-ico";
+  private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
+      Collections.unmodifiableSet(
+          new HashSet<>(
+              Arrays.asList(
+                  WBMP_MIME_TYPE,
+                  ICO_MIME_TYPE
+              )
+          )
+      );
   private static final DecodeCallbacks EMPTY_CALLBACKS = new DecodeCallbacks() {
     @Override
     public void onObtainBounds() {
@@ -54,7 +107,7 @@ public void onObtainBounds() {
     }
 
     @Override
-    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException {
+    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {
       // Do nothing.
     }
   };
@@ -67,27 +120,30 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
           )
       );
   private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);
-  // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer
+  // 10MB. This is the max image header size we can handle, we preallocate a much smaller buffer
   // but will resize up to this amount if necessary.
-  private static final int MARK_POSITION = 5 * 1024 * 1024;
+  private static final int MARK_POSITION = 10 * 1024 * 1024;
 
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
+  private final List<ImageHeaderParser> parsers;
+  private final HardwareConfigState hardwareConfigState = HardwareConfigState.getInstance();
 
-  public Downsampler(DisplayMetrics displayMetrics, BitmapPool bitmapPool,
-      ByteArrayPool byteArrayPool) {
+  public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetrics,
+      BitmapPool bitmapPool, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.displayMetrics = Preconditions.checkNotNull(displayMetrics);
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
   }
 
-  public boolean handles(InputStream is) {
+  public boolean handles(@SuppressWarnings("unused") InputStream is) {
     // We expect Downsampler to handle any available type Android supports.
     return true;
   }
 
-  public boolean handles(ByteBuffer byteBuffer) {
+  public boolean handles(@SuppressWarnings("unused") ByteBuffer byteBuffer) {
     // We expect downsampler to handle any available type Android supports.
     return true;
   }
@@ -128,22 +184,29 @@ public boolean handles(ByteBuffer byteBuffer) {
    * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is
    * not null.
    */
-  @SuppressWarnings("resource")
+  @SuppressWarnings({"resource", "deprecation"})
   public Resource<Bitmap> decode(InputStream is, int requestedWidth, int requestedHeight,
       Options options, DecodeCallbacks callbacks) throws IOException {
     Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports"
         + " mark()");
 
-    byte[] bytesForOptions = byteArrayPool.get(ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+    byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
     BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();
     bitmapFactoryOptions.inTempStorage = bytesForOptions;
 
     DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
     DownsampleStrategy downsampleStrategy = options.get(DOWNSAMPLE_STRATEGY);
+    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
+    boolean isHardwareConfigAllowed =
+      options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);
+    if (decodeFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE) {
+      isHardwareConfigAllowed = false;
+    }
 
     try {
       Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
-          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight, callbacks);
+          downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,
+          requestedHeight, fixBitmapToRequestedDimensions, callbacks);
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
@@ -153,31 +216,93 @@ public boolean handles(ByteBuffer byteBuffer) {
 
   private Bitmap decodeFromWrappedStreams(InputStream is,
       BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
-      DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,
+      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,
+      int requestedHeight, boolean fixBitmapToRequestedDimensions,
       DecodeCallbacks callbacks) throws IOException {
+    long startTime = LogTime.getLogTime();
 
-    int[] sourceDimensions = getDimensions(is, options, callbacks);
+    int[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool);
     int sourceWidth = sourceDimensions[0];
     int sourceHeight = sourceDimensions[1];
     String sourceMimeType = options.outMimeType;
 
-    int orientation = getOrientation(is);
-    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(getOrientation(is));
-
-    options.inPreferredConfig = getConfig(is, decodeFormat);
-    if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
-      options.inDither = true;
+    // If we failed to obtain the image dimensions, we may end up with an incorrectly sized Bitmap,
+    // so we want to use a mutable Bitmap type. One way this can happen is if the image header is so
+    // large (10mb+) that our attempt to use inJustDecodeBounds fails and we're forced to decode the
+    // full size image.
+    if (sourceWidth == -1 || sourceHeight == -1) {
+      isHardwareConfigAllowed = false;
     }
-    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, requestedWidth,
-        requestedHeight, options);
 
-    Bitmap downsampled = downsampleWithSize(is, options, bitmapPool, sourceWidth,
-        sourceHeight, callbacks);
+    int orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
+    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
+    boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);
+
+    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
+    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
+
+    ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
+
+    calculateScaling(
+        imageType,
+        is,
+        callbacks,
+        bitmapPool,
+        downsampleStrategy,
+        degreesToRotate,
+        sourceWidth,
+        sourceHeight,
+        targetWidth,
+        targetHeight,
+        options);
+    calculateConfig(
+        is,
+        decodeFormat,
+        isHardwareConfigAllowed,
+        isExifOrientationRequired,
+        options,
+        targetWidth,
+        targetHeight);
+
+    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
+    if ((options.inSampleSize == 1 || isKitKatOrGreater) && shouldUsePool(imageType)) {
+      int expectedWidth;
+      int expectedHeight;
+      if (sourceWidth >= 0 && sourceHeight >= 0
+          && fixBitmapToRequestedDimensions && isKitKatOrGreater) {
+        expectedWidth = targetWidth;
+        expectedHeight = targetHeight;
+      } else {
+        float densityMultiplier = isScaling(options)
+            ? (float) options.inTargetDensity / options.inDensity : 1f;
+        int sampleSize = options.inSampleSize;
+        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
+        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
+        expectedWidth = Math.round(downsampledWidth * densityMultiplier);
+        expectedHeight = Math.round(downsampledHeight * densityMultiplier);
+
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
+              + " [" + sourceWidth + "x" + sourceHeight + "]"
+              + ", sampleSize: " + sampleSize
+              + ", targetDensity: " + options.inTargetDensity
+              + ", density: " + options.inDensity
+              + ", density multiplier: " + densityMultiplier);
+        }
+      }
+      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
+      // will be -1 here.
+      if (expectedWidth > 0 && expectedHeight > 0) {
+        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);
+      }
+    }
+    Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);
     callbacks.onDecodeComplete(bitmapPool, downsampled);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logDecode(sourceWidth, sourceHeight, sourceMimeType, options, downsampled,
-          requestedWidth, requestedHeight);
+          requestedWidth, requestedHeight, startTime);
     }
 
     Bitmap rotated = null;
@@ -195,18 +320,27 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     return rotated;
   }
 
-  // Visible for testing.
-  static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesToRotate,
-      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight,
-      BitmapFactory.Options options) {
+  private static void calculateScaling(
+      ImageType imageType,
+      InputStream is,
+      DecodeCallbacks decodeCallbacks,
+      BitmapPool bitmapPool,
+      DownsampleStrategy downsampleStrategy,
+      int degreesToRotate,
+      int sourceWidth,
+      int sourceHeight,
+      int targetWidth,
+      int targetHeight,
+      BitmapFactory.Options options) throws IOException {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to determine dimensions for: " + imageType
+            + " with target [" + targetWidth + "x" + targetHeight + "]");
+      }
       return;
     }
 
-    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
-    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
-
     final float exactScaleFactor;
     if (degreesToRotate == 90 || degreesToRotate == 270) {
       // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
@@ -222,7 +356,9 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
 
     if (exactScaleFactor <= 0f) {
       throw new IllegalArgumentException("Cannot scale with factor: " + exactScaleFactor
-          + " from: " + downsampleStrategy);
+          + " from: " + downsampleStrategy
+          + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
+          + ", target: [" + targetWidth + "x" + targetHeight + "]");
     }
     SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding(sourceWidth,
         sourceHeight, targetWidth, targetHeight);
@@ -230,8 +366,8 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
       throw new IllegalArgumentException("Cannot round with null rounding");
     }
 
-    int outWidth = (int) (exactScaleFactor * sourceWidth + 0.5f);
-    int outHeight = (int) (exactScaleFactor * sourceHeight + 0.5f);
+    int outWidth = round(exactScaleFactor * sourceWidth);
+    int outHeight = round(exactScaleFactor * sourceHeight);
 
     int widthScaleFactor = sourceWidth / outWidth;
     int heightScaleFactor = sourceHeight / outHeight;
@@ -240,19 +376,74 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
         ? Math.max(widthScaleFactor, heightScaleFactor)
         : Math.min(widthScaleFactor, heightScaleFactor);
 
-    int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
-    if (rounding == SampleSizeRounding.MEMORY && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
-      powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+    int powerOfTwoSampleSize;
+    // BitmapFactory does not support downsampling wbmp files on platforms <= M. See b/27305903.
+    if (Build.VERSION.SDK_INT <= 23
+        && NO_DOWNSAMPLE_PRE_N_MIME_TYPES.contains(options.outMimeType)) {
+      powerOfTwoSampleSize = 1;
+    } else {
+      powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
+      if (rounding == SampleSizeRounding.MEMORY
+          && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
+        powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+      }
     }
 
-    float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;
-
+    // Here we mimic framework logic for determining how inSampleSize division is rounded on various
+    // versions of Android. The logic here has been tested on emulators for Android versions 15-26.
+    // PNG - Always uses floor
+    // JPEG - Always uses ceiling
+    // Webp - Prior to N, always uses floor. At and after N, always uses round.
     options.inSampleSize = powerOfTwoSampleSize;
+    int powerOfTwoWidth;
+    int powerOfTwoHeight;
+    if (imageType == ImageType.JPEG) {
+      // libjpegturbo can downsample up to a sample size of 8. libjpegturbo uses ceiling to round.
+      // After libjpegturbo's native rounding, skia does a secondary scale using floor
+      // (integer division). Here we replicate that logic.
+      int nativeScaling = Math.min(powerOfTwoSampleSize, 8);
+      powerOfTwoWidth = (int) Math.ceil(sourceWidth / (float) nativeScaling);
+      powerOfTwoHeight = (int) Math.ceil(sourceHeight / (float) nativeScaling);
+      int secondaryScaling = powerOfTwoSampleSize / 8;
+      if (secondaryScaling > 0) {
+        powerOfTwoWidth = powerOfTwoWidth / secondaryScaling;
+        powerOfTwoHeight = powerOfTwoHeight / secondaryScaling;
+      }
+    } else if (imageType == ImageType.PNG || imageType == ImageType.PNG_A) {
+      powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
+      powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+    } else if (imageType == ImageType.WEBP || imageType == ImageType.WEBP_A) {
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+        powerOfTwoWidth = Math.round(sourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = Math.round(sourceHeight / (float) powerOfTwoSampleSize);
+      } else {
+        powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+      }
+    } else if (
+        sourceWidth % powerOfTwoSampleSize != 0 || sourceHeight % powerOfTwoSampleSize != 0) {
+      // If we're not confident the image is in one of our types, fall back to checking the
+      // dimensions again. inJustDecodeBounds decodes do obey inSampleSize.
+      int[] dimensions = getDimensions(is, options, decodeCallbacks, bitmapPool);
+      // Power of two downsampling in BitmapFactory uses a variety of random factors to determine
+      // rounding that we can't reliably replicate for all image formats. Use ceiling here to make
+      // sure that we at least provide a Bitmap that's large enough to fit the content we're going
+      // to load.
+      powerOfTwoWidth = dimensions[0];
+      powerOfTwoHeight = dimensions[1];
+    } else {
+      powerOfTwoWidth = sourceWidth / powerOfTwoSampleSize;
+      powerOfTwoHeight = sourceHeight / powerOfTwoSampleSize;
+    }
+
+    double adjustedScaleFactor = downsampleStrategy.getScaleFactor(
+        powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);
+
     // Density scaling is only supported if inBitmap is null prior to KitKat. Avoid setting
     // densities here so we calculate the final Bitmap size correctly.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-      options.inTargetDensity = (int) (1000 * adjustedScaleFactor + 0.5f);
-      options.inDensity = 1000;
+      options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor);
+      options.inDensity = getDensityMultiplier(adjustedScaleFactor);
     }
     if (isScaling(options)) {
       options.inScaled = true;
@@ -264,6 +455,7 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
       Log.v(TAG, "Calculate scaling"
           + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
           + ", target: [" + targetWidth + "x" + targetHeight + "]"
+          + ", power of two scaled: [" + powerOfTwoWidth + "x" + powerOfTwoHeight + "]"
           + ", exact scale factor: " + exactScaleFactor
           + ", power of 2 sample size: " + powerOfTwoSampleSize
           + ", adjusted scale factor: " + adjustedScaleFactor
@@ -272,98 +464,86 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
     }
   }
 
-  private int getOrientation(InputStream is) throws IOException {
-    is.mark(MARK_POSITION);
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
-    try {
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine the image orientation from header", e);
-      }
-    } finally {
-      is.reset();
-    }
-    return orientation;
+  /**
+   * BitmapFactory calculates the density scale factor as a float. This introduces some non-trivial
+   * error. This method attempts to account for that error by adjusting the inTargetDensity so that
+   * the final scale factor is as close to our target as possible.
+   */
+  private static int adjustTargetDensityForError(double adjustedScaleFactor) {
+    int densityMultiplier = getDensityMultiplier(adjustedScaleFactor);
+    int targetDensity = round(densityMultiplier * adjustedScaleFactor);
+    float scaleFactorWithError = targetDensity / (float) densityMultiplier;
+    double difference = adjustedScaleFactor / scaleFactorWithError;
+    return round(difference * targetDensity);
   }
 
-  private Bitmap downsampleWithSize(InputStream is, BitmapFactory.Options options,
-      BitmapPool pool, int sourceWidth, int sourceHeight, DecodeCallbacks callbacks)
-      throws IOException {
-    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
-    if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT)
-        && shouldUsePool(is)) {
-
-      float densityMultiplier = isScaling(options)
-          ? (float) options.inTargetDensity / options.inDensity : 1f;
-
-      int sampleSize = options.inSampleSize;
-      int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
-      int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
-      int expectedWidth = Math.round(downsampledWidth * densityMultiplier);
-      int expectedHeight = Math.round(downsampledHeight * densityMultiplier);
-
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
-            + " [" + sourceWidth + "x" + sourceHeight + "]"
-            + ", sampleSize: " + sampleSize
-            + ", targetDensity: " + options.inTargetDensity
-            + ", density: " + options.inDensity
-            + ", density multiplier: " + densityMultiplier);
-      }
-      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
-      // will be -1 here.
-      if (expectedWidth > 0 && expectedHeight > 0) {
-        setInBitmap(options, pool, expectedWidth, expectedHeight, options.inPreferredConfig);
-      }
-    }
-    return decodeStream(is, options, callbacks);
+  private static int getDensityMultiplier(double adjustedScaleFactor) {
+    return (int) Math.round(
+        Integer.MAX_VALUE
+            * (adjustedScaleFactor <= 1D ? adjustedScaleFactor : 1 / adjustedScaleFactor));
   }
 
-  private boolean shouldUsePool(InputStream is) throws IOException {
+  // This is weird, but it matches the logic in a bunch of Android views/framework classes for
+  // rounding.
+  private static int round(double value) {
+    return (int) (value + 0.5d);
+  }
+
+  private boolean shouldUsePool(ImageType imageType) {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       return true;
     }
 
-    is.mark(MARK_POSITION);
-    try {
-      final ImageHeaderParser.ImageType type = new ImageHeaderParser(is, byteArrayPool).getType();
-      // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
-      // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
-      return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(type);
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine the image type from header", e);
-      }
-    } finally {
-      is.reset();
-    }
-    return false;
+    // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
+    // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
+    return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(imageType);
   }
 
-  private Bitmap.Config getConfig(InputStream is, DecodeFormat format) throws IOException {
+  @SuppressWarnings("deprecation")
+  private void calculateConfig(
+      InputStream is,
+      DecodeFormat format,
+      boolean isHardwareConfigAllowed,
+      boolean isExifOrientationRequired,
+      BitmapFactory.Options optionsWithScaling,
+      int targetWidth,
+      int targetHeight) {
+
+    if (hardwareConfigState.setHardwareConfigIfAllowed(
+        targetWidth,
+        targetHeight,
+        optionsWithScaling,
+        format,
+        isHardwareConfigAllowed,
+        isExifOrientationRequired)) {
+      return;
+    }
+
     // Changing configs can cause skewing on 4.1, see issue #128.
     if (format == DecodeFormat.PREFER_ARGB_8888
+        || format == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
         || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
-      return Bitmap.Config.ARGB_8888;
+      optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888;
+      return;
     }
 
     boolean hasAlpha = false;
-    is.mark(MARK_POSITION);
     try {
-      hasAlpha = new ImageHeaderParser(is, byteArrayPool).hasAlpha();
+      hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Cannot determine whether the image has alpha or not from header"
             + ", format " + format, e);
       }
-    } finally {
-      is.reset();
     }
 
-    return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    optionsWithScaling.inPreferredConfig =
+        hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    if (optionsWithScaling.inPreferredConfig == Config.RGB_565) {
+      optionsWithScaling.inDither = true;
+    }
   }
 
   /**
@@ -375,15 +555,15 @@ private boolean shouldUsePool(InputStream is) throws IOException {
    * @return an array containing the dimensions of the image in the form {width, height}.
    */
   private static int[] getDimensions(InputStream is, BitmapFactory.Options options,
-      DecodeCallbacks decodeCallbacks) throws IOException {
+      DecodeCallbacks decodeCallbacks, BitmapPool bitmapPool) throws IOException {
     options.inJustDecodeBounds = true;
-    decodeStream(is, options, decodeCallbacks);
+    decodeStream(is, options, decodeCallbacks, bitmapPool);
     options.inJustDecodeBounds = false;
     return new int[] { options.outWidth, options.outHeight };
   }
 
   private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options,
-      DecodeCallbacks callbacks) throws IOException {
+      DecodeCallbacks callbacks, BitmapPool bitmapPool) throws IOException {
     if (options.inJustDecodeBounds) {
       is.mark(MARK_POSITION);
     } else {
@@ -391,7 +571,7 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
       // size. To avoid unnecessary allocations reading image data, we fix the mark limit so that it
       // is no larger than our current buffer size here. We need to do so immediately before
       // decoding the full image to avoid having our mark limit overridden by other calls to
-      // markand reset. See issue #225.
+      // mark and reset. See issue #225.
       callbacks.onObtainBounds();
     }
     // BitmapFactory.Options out* variables are reset by most calls to decodeStream, successful or
@@ -400,17 +580,35 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
     int sourceHeight = options.outHeight;
     String outMimeType = options.outMimeType;
     final Bitmap result;
+    TransformationUtils.getBitmapDrawableLock().lock();
     try {
       result = BitmapFactory.decodeStream(is, null, options);
     } catch (IllegalArgumentException e) {
-      throw newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
+      IOException bitmapAssertionException =
+          newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to decode with inBitmap, trying again without Bitmap re-use",
+            bitmapAssertionException);
+      }
+      if (options.inBitmap != null) {
+        try {
+          is.reset();
+          bitmapPool.put(options.inBitmap);
+          options.inBitmap = null;
+          return decodeStream(is, options, callbacks, bitmapPool);
+        } catch (IOException resetException) {
+          throw bitmapAssertionException;
+        }
+      }
+      throw bitmapAssertionException;
+    } finally {
+      TransformationUtils.getBitmapDrawableLock().unlock();
     }
 
     if (options.inJustDecodeBounds) {
       is.reset();
 
     }
-
     return result;
   }
 
@@ -420,7 +618,8 @@ private static boolean isScaling(BitmapFactory.Options options) {
   }
 
   private static void logDecode(int sourceWidth, int sourceHeight, String outMimeType,
-      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight) {
+      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight,
+      long startTime) {
     Log.v(TAG, "Decoded " + getBitmapString(result)
         + " from [" + sourceWidth + "x" + sourceHeight + "] " + outMimeType
         + " with inBitmap " + getInBitmapString(options)
@@ -428,34 +627,31 @@ private static void logDecode(int sourceWidth, int sourceHeight, String outMimeT
         + ", sample size: " + options.inSampleSize
         + ", density: " + options.inDensity
         + ", target density: " + options.inTargetDensity
-        + ", thread: " + Thread.currentThread().getName());
+        + ", thread: " + Thread.currentThread().getName()
+        + ", duration: " + LogTime.getElapsedMillis(startTime));
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static String getInBitmapString(BitmapFactory.Options options) {
-    return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB
-        ? getBitmapString(options.inBitmap) : null;
+    return getBitmapString(options.inBitmap);
   }
 
+  @Nullable
   @TargetApi(Build.VERSION_CODES.KITKAT)
   private static String getBitmapString(Bitmap bitmap) {
-    final String result;
     if (bitmap == null) {
-      result = null;
-    } else {
-      String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
-          ? " (" + bitmap.getAllocationByteCount() + ")" : "";
-      result = "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
-          + sizeString;
+      return null;
     }
-    return result;
+
+    String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
+        ? " (" + bitmap.getAllocationByteCount() + ")" : "";
+    return  "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
+        + sizeString;
   }
 
   // BitmapFactory throws an IllegalArgumentException if any error occurs attempting to decode a
   // file when inBitmap is non-null, including those caused by partial or corrupt data. We still log
   // the error because the IllegalArgumentException is supposed to catch errors reusing Bitmaps, so
   // want some useful log output. In most cases this can be safely treated as a normal IOException.
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentException e,
       int outWidth, int outHeight, String outMimeType, BitmapFactory.Options options) {
     return new IOException("Exception decoding bitmap"
@@ -465,16 +661,33 @@ private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentExc
           + ", inBitmap: " + getInBitmapString(options), e);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
-      int height, Bitmap.Config config) {
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-      options.inBitmap = bitmapPool.getDirty(width, height, config);
+  @SuppressWarnings("PMD.CollapsibleIfStatements")
+  @TargetApi(Build.VERSION_CODES.O)
+  private static void setInBitmap(
+      BitmapFactory.Options options, BitmapPool bitmapPool, int width, int height) {
+    @Nullable Bitmap.Config expectedConfig = null;
+    // Avoid short circuiting, it appears to break on some devices.
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      if (options.inPreferredConfig == Config.HARDWARE) {
+        return;
+      }
+      // On API 26 outConfig may be null for some images even if the image is valid, can be decoded
+      // and outWidth/outHeight/outColorSpace are populated (see b/71513049).
+      expectedConfig = options.outConfig;
+    }
+
+    if (expectedConfig == null) {
+      // We're going to guess that BitmapFactory will return us the config we're requesting. This
+      // isn't always the case, even though our guesses tend to be conservative and prefer configs
+      // of larger sizes so that the Bitmap will fit our image anyway. If we're wrong here and the
+      // config we choose is too small, our initial decode will fail, but we will retry with no
+      // inBitmap which will succeed so if we're wrong here, we're less efficient but still correct.
+      expectedConfig = options.inPreferredConfig;
     }
+    // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
+    options.inBitmap = bitmapPool.getDirty(width, height, expectedConfig);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static synchronized BitmapFactory.Options getDefaultOptions() {
     BitmapFactory.Options decodeBitmapOptions;
     synchronized (OPTIONS_QUEUE) {
@@ -495,7 +708,7 @@ private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SuppressWarnings("deprecation")
   private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.inTempStorage = null;
     decodeBitmapOptions.inDither = false;
@@ -508,11 +721,8 @@ private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.outWidth = 0;
     decodeBitmapOptions.outHeight = 0;
     decodeBitmapOptions.outMimeType = null;
-
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      decodeBitmapOptions.inBitmap = null;
-      decodeBitmapOptions.inMutable = true;
-    }
+    decodeBitmapOptions.inBitmap = null;
+    decodeBitmapOptions.inMutable = true;
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
new file mode 100644
index 000000000..2ed84484d
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java
@@ -0,0 +1,79 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.request.target.Target;
+import java.util.concurrent.locks.Lock;
+
+final class DrawableToBitmapConverter {
+  private static final String TAG = "DrawableToBitmap";
+  private static final BitmapPool NO_RECYCLE_BITMAP_POOL = new BitmapPoolAdapter() {
+    @Override
+    public void put(Bitmap bitmap) {
+      // Avoid calling super to avoid recycling the given Bitmap.
+    }
+  };
+  private DrawableToBitmapConverter() {
+    // Utility class.
+  }
+
+  @Nullable
+  static Resource<Bitmap> convert(BitmapPool bitmapPool, Drawable drawable, int width, int height) {
+    // Handle DrawableContainer or StateListDrawables that may contain one or more BitmapDrawables.
+    drawable = drawable.getCurrent();
+    Bitmap result = null;
+    boolean isRecycleable = false;
+    if (drawable instanceof BitmapDrawable) {
+      result = ((BitmapDrawable) drawable).getBitmap();
+    } else if (!(drawable instanceof Animatable)) {
+      result = drawToBitmap(bitmapPool, drawable, width, height);
+      // We created and drew to the Bitmap, so it's safe for us to recycle or re-use.
+      isRecycleable = true;
+    }
+
+    BitmapPool toUse = isRecycleable ? bitmapPool : NO_RECYCLE_BITMAP_POOL;
+    return BitmapResource.obtain(result, toUse);
+  }
+
+  @Nullable
+  private static Bitmap drawToBitmap(
+      BitmapPool bitmapPool, Drawable drawable, int width, int height) {
+    if (width == Target.SIZE_ORIGINAL && drawable.getIntrinsicWidth() <= 0) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to draw " + drawable + " to Bitmap with Target.SIZE_ORIGINAL because the"
+            + " Drawable has no intrinsic width");
+      }
+      return null;
+    }
+    if (height == Target.SIZE_ORIGINAL && drawable.getIntrinsicHeight() <= 0) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Unable to draw " + drawable + " to Bitmap with Target.SIZE_ORIGINAL because the"
+            + " Drawable has no intrinsic height");
+      }
+      return null;
+    }
+    int targetWidth = drawable.getIntrinsicWidth() > 0 ? drawable.getIntrinsicWidth() : width;
+    int targetHeight = drawable.getIntrinsicHeight() > 0 ? drawable.getIntrinsicHeight() : height;
+
+    Lock lock = TransformationUtils.getBitmapDrawableLock();
+    lock.lock();
+    Bitmap result = bitmapPool.get(targetWidth, targetHeight, Bitmap.Config.ARGB_8888);
+    try {
+      Canvas canvas = new Canvas(result);
+      drawable.setBounds(0, 0, targetWidth, targetHeight);
+      drawable.draw(canvas);
+      canvas.setBitmap(null);
+    } finally {
+      lock.unlock();
+    }
+    return result;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
new file mode 100644
index 000000000..dee51f7a2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import java.security.MessageDigest;
+
+/**
+ * Applies a {@link Bitmap} {@link Transformation} to {@link Drawable}s by first attempting to
+ * convert the {@link Drawable} to a {@link Bitmap} and then running the {@link Transformation}
+ * on the converted {@link Bitmap}.
+ *
+ * <p>This class is relatively efficient for {@link BitmapDrawable} where the {@link Bitmap} is
+ * readily accessible. For non-{@link Bitmap} based {@link Drawable}s, this class must first try to
+ * draw the {@link Drawable} to a {@link Bitmap} using {@link android.graphics.Canvas}, which is
+ * less efficient. {@link Drawable}s that implement {@link android.graphics.drawable.Animatable}
+ * will fail with an exception. {@link Drawable}s that return <= 0 for
+ * {@link Drawable#getIntrinsicHeight()} and/or {@link Drawable#getIntrinsicWidth()} will fail
+ * with an exception if the requested size is
+ * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}. {@link Drawable}s without
+ * intrinsic dimensions are drawn using the dimensions provided in
+ * {@link Transformation#transform(Context, Resource, int, int)}. As a result, they may be
+ * transformed incorrectly or in unexpected ways.
+ */
+public class DrawableTransformation implements Transformation<Drawable> {
+
+  private final Transformation<Bitmap> wrapped;
+  private final boolean isRequired;
+
+  public DrawableTransformation(Transformation<Bitmap> wrapped, boolean isRequired) {
+    this.wrapped = wrapped;
+    this.isRequired = isRequired;
+  }
+
+  @SuppressWarnings("unchecked")
+  public Transformation<BitmapDrawable> asBitmapDrawable() {
+    return (Transformation<BitmapDrawable>) (Transformation<?>) this;
+  }
+
+  @NonNull
+  @Override
+  public Resource<Drawable> transform(@NonNull Context context,
+      @NonNull Resource<Drawable> resource, int outWidth, int outHeight) {
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
+    Drawable drawable = resource.get();
+    Resource<Bitmap> bitmapResourceToTransform =
+        DrawableToBitmapConverter.convert(bitmapPool, drawable, outWidth, outHeight);
+    if (bitmapResourceToTransform == null) {
+      if (isRequired) {
+        throw new IllegalArgumentException("Unable to convert " + drawable + " to a Bitmap");
+      } else {
+        return resource;
+      }
+    }
+    Resource<Bitmap> transformedBitmapResource =
+        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
+
+    if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
+      transformedBitmapResource.recycle();
+      return resource;
+    } else {
+      return newDrawableResource(context, transformedBitmapResource);
+    }
+  }
+
+  // It's clearer to cast the result in a separate line from obtaining it.
+  @SuppressWarnings({"unchecked", "PMD.UnnecessaryLocalBeforeReturn"})
+  private Resource<Drawable> newDrawableResource(
+      Context context, Resource<Bitmap> transformed) {
+    Resource<? extends Drawable> result =
+        LazyBitmapDrawableResource.obtain(context.getResources(), transformed);
+    return (Resource<Drawable>) result;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof DrawableTransformation) {
+      DrawableTransformation other = (DrawableTransformation) o;
+      return wrapped.equals(other.wrapped);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return wrapped.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    wrapped.updateDiskCacheKey(messageDigest);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
index 9f728b1b3..9c2ae89c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
@@ -1,11 +1,8 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -17,14 +14,6 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.FitCenter";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public FitCenter(Context context) {
-    super(context);
-  }
-
-  public FitCenter(BitmapPool bitmapPool) {
-    super(bitmapPool);
-  }
-
   @Override
   protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
       int outHeight) {
@@ -42,7 +31,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(ID_BYTES);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
new file mode 100644
index 000000000..fe7c0357d
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
@@ -0,0 +1,119 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import android.util.Log;
+import com.bumptech.glide.load.DecodeFormat;
+import java.io.File;
+
+/**
+ * State and constants for interacting with {@link android.graphics.Bitmap.Config#HARDWARE} on
+ * Android O+.
+ */
+final class HardwareConfigState {
+  /**
+   * The minimum size in pixels a {@link Bitmap} must be in both dimensions to be created with the
+   * {@link Bitmap.Config#HARDWARE} configuration.
+   *
+   * <p>This is a quick check that lets us skip wasting FDs (see {@link #FD_SIZE_LIST}) on small
+   * {@link Bitmap}s with relatively low memory costs.
+   *
+   * @see #FD_SIZE_LIST
+   */
+  private static final int MIN_HARDWARE_DIMENSION = 128;
+
+  /**
+   * Allows us to check to make sure we're not exceeding the FD limit for a process with hardware
+   * {@link Bitmap}s.
+   *
+   * <p>{@link Bitmap.Config#HARDWARE} {@link Bitmap}s require two FDs (depending on the driver).
+   * Processes have an FD limit of 1024 (at least on O). With sufficiently small {@link Bitmap}s
+   * and/or a sufficiently large {@link com.bumptech.glide.load.engine.cache.MemoryCache}, we can
+   * end up with enough {@link Bitmap}s in memory that we blow through the FD limit, which causes
+   * graphics errors, Binder errors, and a variety of crashes.
+   *
+   * <p>Calling list.size() should be relatively efficient (hopefully < 1ms on average) because
+   * /proc is an in-memory FS.
+   */
+  private static final File FD_SIZE_LIST = new File("/proc/self/fd");
+
+  /**
+   * Each FD check takes 1-2ms, so to avoid overhead, only check every N decodes. 50 is more or less
+   * arbitrary.
+   */
+  private static final int MINIMUM_DECODES_BETWEEN_FD_CHECKS = 50;
+
+  /**
+   * 700 with an error of 50 Bitmaps in between at two FDs each lets us use up to 800 FDs for
+   * hardware Bitmaps.
+   */
+  private static final int MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = 700;
+
+  private volatile int decodesSinceLastFdCheck;
+  private volatile boolean isHardwareConfigAllowed = true;
+
+  private static volatile HardwareConfigState instance;
+
+  static HardwareConfigState getInstance() {
+    if (instance == null) {
+      synchronized (HardwareConfigState.class) {
+        if (instance == null) {
+          instance = new HardwareConfigState();
+        }
+      }
+    }
+    return instance;
+  }
+
+  private HardwareConfigState() {
+    // Singleton constructor.
+  }
+
+  @TargetApi(Build.VERSION_CODES.O)
+  @SuppressWarnings("deprecation")
+  boolean setHardwareConfigIfAllowed(
+      int targetWidth,
+      int targetHeight,
+      BitmapFactory.Options optionsWithScaling,
+      DecodeFormat decodeFormat,
+      boolean isHardwareConfigAllowed,
+      boolean isExifOrientationRequired) {
+    if (!isHardwareConfigAllowed
+        || Build.VERSION.SDK_INT < Build.VERSION_CODES.O
+        || decodeFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
+        || isExifOrientationRequired) {
+      return false;
+    }
+
+    boolean result =
+        targetWidth >= MIN_HARDWARE_DIMENSION
+            && targetHeight >= MIN_HARDWARE_DIMENSION
+            // Make sure to call isFdSizeBelowHardwareLimit last because it has side affects.
+            && isFdSizeBelowHardwareLimit();
+
+    if (result) {
+      optionsWithScaling.inPreferredConfig = Bitmap.Config.HARDWARE;
+      optionsWithScaling.inMutable = false;
+    }
+    return result;
+  }
+
+  private synchronized boolean isFdSizeBelowHardwareLimit() {
+    if (++decodesSinceLastFdCheck >= MINIMUM_DECODES_BETWEEN_FD_CHECKS) {
+      decodesSinceLastFdCheck = 0;
+      int currentFds = FD_SIZE_LIST.list().length;
+      isHardwareConfigAllowed = currentFds < MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
+
+      if (!isHardwareConfigAllowed && Log.isLoggable(Downsampler.TAG, Log.WARN)) {
+        Log.w(Downsampler.TAG,
+            "Excluding HARDWARE bitmap config because we're over the file descriptor limit"
+                + ", file descriptors " + currentFds
+                + ", limit " + MAXIMUM_FDS_FOR_HARDWARE_CONFIGS);
+      }
+    }
+
+    return isHardwareConfigAllowed;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index 9a4b7b205..92855b5ba 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -4,55 +4,90 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
 
 /**
  * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
  * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
  */
-public class LazyBitmapDrawableResource implements Resource<BitmapDrawable> {
+public final class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
+    Initializable {
 
-  private final Bitmap bitmap;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
+  private final Resource<Bitmap> bitmapResource;
 
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   * {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
   public static LazyBitmapDrawableResource obtain(Context context, Bitmap bitmap) {
-    return obtain(context.getResources(), Glide.get(context).getBitmapPool(), bitmap);
+    return
+        (LazyBitmapDrawableResource)
+            obtain(
+                context.getResources(),
+                BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));
   }
 
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   * {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
   public static LazyBitmapDrawableResource obtain(Resources resources, BitmapPool bitmapPool,
       Bitmap bitmap) {
-    return new LazyBitmapDrawableResource(resources, bitmapPool, bitmap);
+    return
+        (LazyBitmapDrawableResource) obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));
+  }
+
+  @Nullable
+  public static Resource<BitmapDrawable> obtain(
+      @NonNull Resources resources, @Nullable Resource<Bitmap> bitmapResource) {
+    if (bitmapResource == null) {
+      return null;
+    }
+    return new LazyBitmapDrawableResource(resources, bitmapResource);
+
   }
 
-  LazyBitmapDrawableResource(Resources resources, BitmapPool bitmapPool, Bitmap bitmap) {
+  private LazyBitmapDrawableResource(@NonNull Resources resources,
+      @NonNull Resource<Bitmap> bitmapResource) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
-    this.bitmap = Preconditions.checkNotNull(bitmap);
+    this.bitmapResource = Preconditions.checkNotNull(bitmapResource);
   }
 
+  @NonNull
   @Override
   public Class<BitmapDrawable> getResourceClass() {
     return BitmapDrawable.class;
   }
 
+  @NonNull
   @Override
   public BitmapDrawable get() {
-    return new BitmapDrawable(resources, bitmap);
+    return new BitmapDrawable(resources, bitmapResource.get());
   }
 
   @Override
   public int getSize() {
-    return Util.getBitmapByteSize(bitmap);
+    return bitmapResource.getSize();
   }
 
   @Override
   public void recycle() {
-    bitmapPool.put(bitmap);
+    bitmapResource.recycle();
+  }
+
+  @Override
+  public void initialize() {
+    if (bitmapResource instanceof Initializable) {
+      ((Initializable) bitmapResource).initialize();
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 33a25b6f7..c8139383f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -17,8 +17,9 @@
  *  limitations under the License.
  */
 
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -62,18 +63,18 @@
    * The current position within the byte array {@code buf}.
    */
   private int pos;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public RecyclableBufferedInputStream(InputStream in, ByteArrayPool byteArrayPool) {
-    this(in, byteArrayPool, ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES);
+  public RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool byteArrayPool) {
+    this(in, byteArrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);
   }
 
-  // Visible for testing
-  RecyclableBufferedInputStream(InputStream in, ByteArrayPool byteArrayPool,
+  @VisibleForTesting
+  RecyclableBufferedInputStream(@NonNull InputStream in, @NonNull ArrayPool byteArrayPool,
       int bufferSize) {
     super(in);
     this.byteArrayPool = byteArrayPool;
-    buf = byteArrayPool.get(bufferSize);
+    buf = byteArrayPool.get(bufferSize, byte[].class);
   }
 
   /**
@@ -105,6 +106,8 @@ private static IOException streamClosed() throws IOException {
    * <p>Subsequent calls to {@link #mark(int)} will be obeyed and may cause the buffer size to
    * increase.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public synchronized void fixMarkLimit() {
     marklimit = buf.length;
   }
@@ -161,7 +164,7 @@ private int fillbuf(InputStream localIn, byte[] localBuf) throws IOException {
       if (newLength > marklimit) {
         newLength = marklimit;
       }
-      byte[] newbuf = byteArrayPool.get(newLength);
+      byte[] newbuf = byteArrayPool.get(newLength, byte[].class);
       System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);
       byte[] oldbuf = localBuf;
       // Reassign buf, which will invalidate any local references
@@ -267,7 +270,8 @@ public synchronized int read() throws IOException {
    *                                   occurs.
    */
   @Override
-  public synchronized int read(byte[] buffer, int offset, int byteCount) throws IOException {
+  public synchronized int read(@NonNull byte[] buffer, int offset, int byteCount)
+      throws IOException {
     // Use local ref since buf may be invalidated by an unsynchronized close()
     byte[] localBuf = buf;
     if (localBuf == null) {
@@ -357,31 +361,32 @@ public synchronized void reset() throws IOException {
    * Skips {@code byteCount} bytes in this stream. Subsequent calls to {@link #read} will not return
    * these bytes unless {@link #reset} is used.
    *
-   * @param byteCount the number of bytes to skip. {@link #skip} does nothing and returns 0 if
+   * @param byteCount the number of bytes to skip. This method does nothing and returns 0 if
    *                  {@code byteCount} is less than zero.
    * @return the number of bytes actually skipped.
    * @throws IOException if this stream is closed or another IOException occurs.
    */
   @Override
   public synchronized long skip(long byteCount) throws IOException {
+    if (byteCount < 1) {
+      return 0;
+    }
     // Use local refs since buf and in may be invalidated by an unsynchronized close()
     byte[] localBuf = buf;
-    InputStream localIn = in;
     if (localBuf == null) {
       throw streamClosed();
     }
-    if (byteCount < 1) {
-      return 0;
-    }
+    InputStream localIn = in;
     if (localIn == null) {
       throw streamClosed();
     }
 
     if (count - pos >= byteCount) {
-      pos += byteCount;
+      pos = (int) (pos + byteCount);
       return byteCount;
     }
-    long read = count - pos;
+    // See http://errorprone.info/bugpattern/IntLongMath.
+    long read = (long) count - pos;
     pos = count;
 
     if (markpos != -1 && byteCount <= marklimit) {
@@ -389,7 +394,8 @@ public synchronized long skip(long byteCount) throws IOException {
         return read;
       }
       if (count - pos >= byteCount - read) {
-        pos += byteCount - read;
+        // See http://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+        pos = (int) (pos + byteCount - read);
         return byteCount;
       }
       // Couldn't get all the bytes, skip what we read.
@@ -404,10 +410,10 @@ public synchronized long skip(long byteCount) throws IOException {
    * An exception thrown when a mark can no longer be obeyed because the underlying buffer size is
    * smaller than the amount of data read after the mark position.
    */
-  public static class InvalidMarkException extends IOException {
+  static class InvalidMarkException extends IOException {
     private static final long serialVersionUID = -4338378848813561757L;
 
-    public InvalidMarkException(String detailMessage) {
+    InvalidMarkException(String detailMessage) {
       super(detailMessage);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
new file mode 100644
index 000000000..3ef5b5b3e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.ContentResolver;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * Decodes {@link Bitmap}s from resource ids.
+ *
+ * <p>The framework will decode some resources as {@link Drawable}s that do not wrap
+ * {@link Bitmap}s. This decoder will attempt to return a {@link Bitmap} for those
+ * {@link Drawable}s anyway by drawing the {@link Drawable} to a {@link Canvas}s using
+ * the {@link Drawable}'s intrinsic bounds or the dimensions provided to
+ * {@link #decode(Object, int, int, Options)}.
+ *
+ * <p>For non-{@link Bitmap} {@link Drawable}s that return <= 0 for
+ * {@link Drawable#getIntrinsicWidth()} and/or {@link Drawable#getIntrinsicHeight()}, this
+ * decoder will fail if the width and height provided to {@link #decode(Object, int, int, Options)}
+ * are {@link Target#SIZE_ORIGINAL}.
+ */
+public class ResourceBitmapDecoder implements ResourceDecoder<Uri, Bitmap> {
+
+  private final ResourceDrawableDecoder drawableDecoder;
+  private final BitmapPool bitmapPool;
+
+  public ResourceBitmapDecoder(ResourceDrawableDecoder drawableDecoder, BitmapPool bitmapPool) {
+    this.drawableDecoder = drawableDecoder;
+    this.bitmapPool = bitmapPool;
+  }
+
+  @Override
+  public boolean handles(@NonNull Uri source, @NonNull Options options) {
+    return ContentResolver.SCHEME_ANDROID_RESOURCE.equals(source.getScheme());
+  }
+
+  @Nullable
+  @Override
+  public Resource<Bitmap> decode(@NonNull Uri source, int width, int height,
+      @NonNull Options options) {
+    Resource<Drawable> drawableResource = drawableDecoder.decode(source, width, height, options);
+    if (drawableResource == null) {
+      return null;
+    }
+    Drawable drawable = drawableResource.get();
+    return DrawableToBitmapConverter.convert(bitmapPool, drawable, width, height);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
new file mode 100644
index 000000000..ae5552152
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * A {@link BitmapTransformation} which rounds the corners of a bitmap.
+ */
+public final class RoundedCorners extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.RoundedCorners";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  private final int roundingRadius;
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   */
+  public RoundedCorners(int roundingRadius) {
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+    this.roundingRadius = roundingRadius;
+  }
+
+  @Override
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.roundedCorners(pool, toTransform, roundingRadius);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof RoundedCorners) {
+      RoundedCorners other = (RoundedCorners) o;
+      return roundingRadius == other.roundingRadius;
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return Util.hashCode(ID.hashCode(),
+        Util.hashCode(roundingRadius));
+  }
+
+  @Override
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+
+    byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();
+    messageDigest.update(radiusData);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index bedf360ba..00cc6f3c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.util.ExceptionCatchingInputStream;
 import com.bumptech.glide.util.MarkEnforcingInputStream;
-
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -19,20 +18,21 @@
 public class StreamBitmapDecoder implements ResourceDecoder<InputStream, Bitmap> {
 
   private final Downsampler downsampler;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public StreamBitmapDecoder(Downsampler downsampler, ByteArrayPool byteArrayPool) {
+  public StreamBitmapDecoder(Downsampler downsampler, ArrayPool byteArrayPool) {
     this.downsampler = downsampler;
     this.byteArrayPool = byteArrayPool;
   }
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     return downsampler.handles(source);
   }
 
   @Override
-  public Resource<Bitmap> decode(InputStream source, int width, int height, Options options)
+  public Resource<Bitmap> decode(@NonNull InputStream source, int width, int height,
+      @NonNull Options options)
       throws IOException {
 
     // Use to fix the mark limit to avoid allocating buffers that fit entire images.
@@ -76,7 +76,7 @@ public boolean handles(InputStream source, Options options) throws IOException {
     private final RecyclableBufferedInputStream bufferedStream;
     private final ExceptionCatchingInputStream exceptionStream;
 
-    public UntrustedCallbacks(RecyclableBufferedInputStream bufferedStream,
+    UntrustedCallbacks(RecyclableBufferedInputStream bufferedStream,
         ExceptionCatchingInputStream exceptionStream) {
       this.bufferedStream = bufferedStream;
       this.exceptionStream = exceptionStream;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 0f201106d..1c4d4812c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -1,24 +1,38 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapShader;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffXfermode;
-import android.graphics.Rect;
 import android.graphics.RectF;
+import android.graphics.Shader;
 import android.media.ExifInterface;
 import android.os.Build;
 import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
-
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * A class with methods to efficiently resize Bitmaps.
  */
+// Legacy Public APIs.
+@SuppressWarnings("WeakerAccess")
 public final class TransformationUtils {
   private static final String TAG = "TransformationUtils";
   public static final int PAINT_FLAGS = Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
@@ -26,6 +40,56 @@
   private static final int CIRCLE_CROP_PAINT_FLAGS = PAINT_FLAGS | Paint.ANTI_ALIAS_FLAG;
   private static final Paint CIRCLE_CROP_SHAPE_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
+
+  // See #738.
+  private static final Set<String> MODELS_REQUIRING_BITMAP_LOCK =
+      new HashSet<>(
+          Arrays.asList(
+              // Moto X gen 2
+              "XT1085",
+              "XT1092",
+              "XT1093",
+              "XT1094",
+              "XT1095",
+              "XT1096",
+              "XT1097",
+              "XT1098",
+              // Moto G gen 1
+              "XT1031",
+              "XT1028",
+              "XT937C",
+              "XT1032",
+              "XT1008",
+              "XT1033",
+              "XT1035",
+              "XT1034",
+              "XT939G",
+              "XT1039",
+              "XT1040",
+              "XT1042",
+              "XT1045",
+              // Moto G gen 2
+              "XT1063",
+              "XT1064",
+              "XT1068",
+              "XT1069",
+              "XT1072",
+              "XT1077",
+              "XT1078",
+              "XT1079"
+          )
+      );
+
+  /**
+   * https://github.com/bumptech/glide/issues/738 On some devices, bitmap drawing is not thread
+   * safe.
+   * This lock only locks for these specific devices. For other types of devices the lock is always
+   * available and therefore does not impact performance
+   */
+  private static final Lock BITMAP_DRAWABLE_LOCK =
+      MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL)
+          ? new ReentrantLock() : new NoLock();
+
   static {
     CIRCLE_CROP_BITMAP_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
     CIRCLE_CROP_BITMAP_PAINT.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
@@ -35,43 +99,50 @@ private TransformationUtils() {
     // Utility class.
   }
 
+
+  public static Lock getBitmapDrawableLock() {
+    return BITMAP_DRAWABLE_LOCK;
+  }
+
   /**
    * A potentially expensive operation to crop the given Bitmap so that it fills the given
    * dimensions. This operation is significantly less expensive in terms of memory if a mutable
    * Bitmap with the given dimensions is passed in as well.
    *
    * @param pool     The BitmapPool to obtain a bitmap from.
-   * @param toCrop   The Bitmap to resize.
+   * @param inBitmap   The Bitmap to resize.
    * @param width    The width in pixels of the final Bitmap.
    * @param height   The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int width,
+  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
       int height) {
-    if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
-      return toCrop;
+    if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
+      return inBitmap;
     }
     // From ImageView/Bitmap.createScaledBitmap.
     final float scale;
-    float dx = 0, dy = 0;
+    final float dx;
+    final float dy;
     Matrix m = new Matrix();
-    if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
-      scale = (float) height / (float) toCrop.getHeight();
-      dx = (width - toCrop.getWidth() * scale) * 0.5f;
+    if (inBitmap.getWidth() * height > width * inBitmap.getHeight()) {
+      scale = (float) height / (float) inBitmap.getHeight();
+      dx = (width - inBitmap.getWidth() * scale) * 0.5f;
+      dy = 0;
     } else {
-      scale = (float) width / (float) toCrop.getWidth();
-      dy = (height - toCrop.getHeight() * scale) * 0.5f;
+      scale = (float) width / (float) inBitmap.getWidth();
+      dx = 0;
+      dy = (height - inBitmap.getHeight() * scale) * 0.5f;
     }
 
     m.setScale(scale, scale);
     m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
 
-    Bitmap result = pool.get(width, height, getSafeConfig(toCrop));
+    Bitmap result = pool.get(width, height, getNonNullConfig(inBitmap));
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-    TransformationUtils.setAlpha(toCrop, result);
+    TransformationUtils.setAlpha(inBitmap, result);
 
-    Canvas canvas = new Canvas(result);
-    canvas.drawBitmap(toCrop, m, DEFAULT_PAINT);
+    applyMatrix(inBitmap, result, m);
     return result;
   }
 
@@ -80,76 +151,99 @@ public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop
    * dimensions maintain the original proportions.
    *
    * @param pool   The BitmapPool obtain a bitmap from.
-   * @param toFit  The Bitmap to shrink.
+   * @param inBitmap  The Bitmap to shrink.
    * @param width  The width in pixels the final image will fit within.
    * @param height The height in pixels the final image will fit within.
    * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or
    * height matches the given dimensions and toFit fits within the given dimensions
    */
-  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap toFit, int width,
+  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
       int height) {
-    if (toFit.getWidth() == width && toFit.getHeight() == height) {
+    if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size matches input, returning input");
       }
-      return toFit;
+      return inBitmap;
     }
-    final float widthPercentage = width / (float) toFit.getWidth();
-    final float heightPercentage = height / (float) toFit.getHeight();
+    final float widthPercentage = width / (float) inBitmap.getWidth();
+    final float heightPercentage = height / (float) inBitmap.getHeight();
     final float minPercentage = Math.min(widthPercentage, heightPercentage);
 
-    // take the floor of the target width/height, not round. If the matrix
-    // passed into drawBitmap rounds differently, we want to slightly
-    // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
-    final int targetWidth = (int) (minPercentage * toFit.getWidth());
-    final int targetHeight = (int) (minPercentage * toFit.getHeight());
+    // Round here in case we've decoded exactly the image we want, but take the floor below to
+    // avoid a line of garbage or blank pixels in images.
+    int targetWidth = Math.round(minPercentage * inBitmap.getWidth());
+    int targetHeight = Math.round(minPercentage * inBitmap.getHeight());
 
-    if (toFit.getWidth() == targetWidth && toFit.getHeight() == targetHeight) {
+    if (inBitmap.getWidth() == targetWidth && inBitmap.getHeight() == targetHeight) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "adjusted target size matches input, returning input");
       }
-      return toFit;
+      return inBitmap;
     }
 
-    Bitmap.Config config = getSafeConfig(toFit);
+    // Take the floor of the target width/height, not round. If the matrix
+    // passed into drawBitmap rounds differently, we want to slightly
+    // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
+    targetWidth = (int) (minPercentage * inBitmap.getWidth());
+    targetHeight = (int) (minPercentage * inBitmap.getHeight());
+
+    Bitmap.Config config = getNonNullConfig(inBitmap);
     Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
 
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-    TransformationUtils.setAlpha(toFit, toReuse);
+    TransformationUtils.setAlpha(inBitmap, toReuse);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       Log.v(TAG, "request: " + width + "x" + height);
-      Log.v(TAG, "toFit:   " + toFit.getWidth() + "x" + toFit.getHeight());
+      Log.v(TAG, "toFit:   " + inBitmap.getWidth() + "x" + inBitmap.getHeight());
       Log.v(TAG, "toReuse: " + toReuse.getWidth() + "x" + toReuse.getHeight());
       Log.v(TAG, "minPct:   " + minPercentage);
     }
 
-    Canvas canvas = new Canvas(toReuse);
     Matrix matrix = new Matrix();
     matrix.setScale(minPercentage, minPercentage);
-    canvas.drawBitmap(toFit, matrix, DEFAULT_PAINT);
+    applyMatrix(inBitmap, toReuse, matrix);
 
     return toReuse;
   }
 
+  /**
+   * If the Bitmap is smaller or equal to the Target it returns the original size, if not then
+   * {@link #fitCenter(BitmapPool, Bitmap, int, int)} is called instead.
+   *
+   * @param pool   The BitmapPool obtain a bitmap from.
+   * @param inBitmap  The Bitmap to center.
+   * @param width  The width in pixels of the target.
+   * @param height The height in pixels of the target.
+   * @return returns input Bitmap if smaller or equal to target, or toFit if the Bitmap's width or
+   * height is larger than the given dimensions
+   */
+  public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
+      int height) {
+    if (inBitmap.getWidth() <= width && inBitmap.getHeight() <= height) {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "requested target size larger or equal to input, returning input");
+      }
+      return inBitmap;
+    } else {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "requested target size too big for input, fit centering instead");
+      }
+      return fitCenter(pool, inBitmap, width, height);
+    }
+  }
+
   /**
    * Sets the alpha of the Bitmap we're going to re-use to the alpha of the Bitmap we're going to
    * transform. This keeps {@link android.graphics.Bitmap#hasAlpha()}} consistent before and after
    * the transformation for transformations that don't add or remove transparent pixels.
    *
-   * @param toTransform The {@link android.graphics.Bitmap} that will be transformed.
+   * @param inBitmap The {@link android.graphics.Bitmap} that will be transformed.
    * @param outBitmap   The {@link android.graphics.Bitmap} that will be returned from the
    *                    transformation.
    */
-  public static void setAlpha(Bitmap toTransform, Bitmap outBitmap) {
-    setAlphaIfAvailable(outBitmap, toTransform.hasAlpha());
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-  private static void setAlphaIfAvailable(Bitmap bitmap, boolean hasAlpha) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1 && bitmap != null) {
-      bitmap.setHasAlpha(hasAlpha);
-    }
+  public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
+    outBitmap.setHasAlpha(inBitmap.hasAlpha());
   }
 
   /**
@@ -201,6 +295,7 @@ public static int getExifOrientationDegrees(int exifOrientation) {
         break;
       default:
         degreesToRotate = 0;
+        break;
     }
     return degreesToRotate;
   }
@@ -210,78 +305,230 @@ public static int getExifOrientationDegrees(int exifOrientation) {
    *
    * @param pool            A pool that may or may not contain an image of the necessary
    *                        dimensions.
-   * @param toOrient        The bitmap to rotate/flip.
+   * @param inBitmap        The bitmap to rotate/flip.
    * @param exifOrientation the exif orientation [1-8].
    * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary.
    */
-  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap toOrient,
+  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
       int exifOrientation) {
+    if (!isExifOrientationRequired(exifOrientation)) {
+      return inBitmap;
+    }
+
     final Matrix matrix = new Matrix();
     initializeMatrixForRotation(exifOrientation, matrix);
-    if (matrix.isIdentity()) {
-      return toOrient;
-    }
 
     // From Bitmap.createBitmap.
-    final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
+    final RectF newRect = new RectF(0, 0, inBitmap.getWidth(), inBitmap.getHeight());
     matrix.mapRect(newRect);
 
     final int newWidth = Math.round(newRect.width());
     final int newHeight = Math.round(newRect.height());
 
-    Bitmap.Config config = getSafeConfig(toOrient);
+    Bitmap.Config config = getNonNullConfig(inBitmap);
     Bitmap result = pool.get(newWidth, newHeight, config);
 
     matrix.postTranslate(-newRect.left, -newRect.top);
 
-    final Canvas canvas = new Canvas(result);
-    canvas.drawBitmap(toOrient, matrix, DEFAULT_PAINT);
-
+    applyMatrix(inBitmap, result, matrix);
     return result;
   }
 
+  /**
+   * Returns {@code true} if the given exif orientation indicates that a transformation is necessary
+   * and {@code false} otherwise.
+   */
+  public static boolean isExifOrientationRequired(int exifOrientation) {
+    switch (exifOrientation) {
+      case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
+      case ExifInterface.ORIENTATION_ROTATE_180:
+      case ExifInterface.ORIENTATION_FLIP_VERTICAL:
+      case ExifInterface.ORIENTATION_TRANSPOSE:
+      case ExifInterface.ORIENTATION_ROTATE_90:
+      case ExifInterface.ORIENTATION_TRANSVERSE:
+      case ExifInterface.ORIENTATION_ROTATE_270:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   /**
    * Crop the image to a circle and resize to the specified width/height.  The circle crop will
    * have the same width and height equal to the min-edge of the result image.
    *
    * @param pool   The BitmapPool obtain a bitmap from.
-   * @param toCrop   The Bitmap to resize.
+   * @param inBitmap   The Bitmap to resize.
    * @param destWidth    The width in pixels of the final Bitmap.
    * @param destHeight   The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int destWidth,
-      int destHeight) {
+  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
+      int destWidth, int destHeight) {
     int destMinEdge = Math.min(destWidth, destHeight);
     float radius = destMinEdge / 2f;
-    Rect destRect = new Rect((destWidth - destMinEdge) / 2, (destHeight - destMinEdge) / 2,
-        destMinEdge, destMinEdge);
 
-    int srcWidth = toCrop.getWidth();
-    int srcHeight = toCrop.getHeight();
-    int srcMinEdge = Math.min(srcWidth, srcHeight);
-    Rect srcRect = new Rect((srcWidth - srcMinEdge) / 2, (srcHeight - srcMinEdge) / 2,
-        srcMinEdge, srcMinEdge);
+    int srcWidth = inBitmap.getWidth();
+    int srcHeight = inBitmap.getHeight();
+
+    float scaleX = destMinEdge / (float) srcWidth;
+    float scaleY = destMinEdge / (float) srcHeight;
+    float maxScale = Math.max(scaleX, scaleY);
 
-    Bitmap result = pool.get(destWidth, destHeight, getSafeConfig(toCrop));
-    setAlphaIfAvailable(result, true /*hasAlpha*/);
-    Canvas canvas = new Canvas(result);
+    float scaledWidth = maxScale * srcWidth;
+    float scaledHeight = maxScale * srcHeight;
+    float left = (destMinEdge - scaledWidth) / 2f;
+    float top = (destMinEdge - scaledHeight) / 2f;
 
-    // Draw a circle
-    canvas.drawCircle(destRect.left + radius, destRect.top + radius, radius,
-        CIRCLE_CROP_SHAPE_PAINT);
+    RectF destRect = new RectF(left, top, left + scaledWidth, top + scaledHeight);
 
-    // Draw the bitmap in the circle
-    canvas.drawBitmap(toCrop, srcRect, destRect, CIRCLE_CROP_BITMAP_PAINT);
+    // Alpha is required for this transformation.
+    Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
+
+    Bitmap.Config outConfig = getAlphaSafeConfig(inBitmap);
+    Bitmap result = pool.get(destMinEdge, destMinEdge, outConfig);
+    result.setHasAlpha(true);
+
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(result);
+      // Draw a circle
+      canvas.drawCircle(radius, radius, radius, CIRCLE_CROP_SHAPE_PAINT);
+      // Draw the bitmap in the circle
+      canvas.drawBitmap(toTransform, null, destRect, CIRCLE_CROP_BITMAP_PAINT);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
+
+    if (!toTransform.equals(inBitmap)) {
+      pool.put(toTransform);
+    }
+
+    return result;
+  }
+
+  private static Bitmap getAlphaSafeBitmap(
+      @NonNull BitmapPool pool, @NonNull Bitmap maybeAlphaSafe) {
+    Bitmap.Config safeConfig = getAlphaSafeConfig(maybeAlphaSafe);
+    if (safeConfig.equals(maybeAlphaSafe.getConfig())) {
+      return maybeAlphaSafe;
+    }
+
+    Bitmap argbBitmap =
+        pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(), safeConfig);
+    new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*paint*/);
+
+    // We now own this Bitmap. It's our responsibility to replace it in the pool outside this method
+    // when we're finished with it.
+    return argbBitmap;
+  }
+
+  @NonNull
+  private static Config getAlphaSafeConfig(@NonNull Bitmap inBitmap) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      // Avoid short circuiting the sdk check.
+      if (Bitmap.Config.RGBA_F16.equals(inBitmap.getConfig())) { // NOPMD
+        return Bitmap.Config.RGBA_F16;
+      }
+    }
+
+    return Bitmap.Config.ARGB_8888;
+  }
+
+  /**
+   * Creates a bitmap from a source bitmap and rounds the corners.
+   *
+   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
+   * @param width the width of the generated bitmap.
+   * @param height the height of the generated bitmap.
+   * @param roundingRadius the corner radius to be applied (in device-specific pixels).
+   * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
+   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
+   *
+   * @deprecated Width and height are unused and ignored. Use
+   * {@link #roundedCorners(BitmapPool, Bitmap, int)} instead.
+   */
+  @Deprecated
+  public static Bitmap roundedCorners(
+      @NonNull BitmapPool pool,
+      @NonNull Bitmap inBitmap,
+      @SuppressWarnings("unused") int width,
+      @SuppressWarnings("unused") int height,
+      int roundingRadius) {
+    return roundedCorners(pool, inBitmap, roundingRadius);
+  }
+
+  /**
+   * Creates a bitmap from a source bitmap and rounds the corners.
+   *
+   * <p>This method does <em>NOT</em> resize the given {@link Bitmap}, it only rounds it's corners.
+   * To both resize and round the corners of an image, consider
+   * {@link com.bumptech.glide.request.RequestOptions#transforms(Transformation[])} and/or
+   * {@link com.bumptech.glide.load.MultiTransformation}.
+   *
+   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
+   * @param roundingRadius the corner radius to be applied (in device-specific pixels).
+   * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
+   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
+   */
+  public static Bitmap roundedCorners(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int roundingRadius) {
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+
+    // Alpha is required for this transformation.
+    Bitmap.Config safeConfig = getAlphaSafeConfig(inBitmap);
+    Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
+    Bitmap result = pool.get(toTransform.getWidth(), toTransform.getHeight(), safeConfig);
+
+    result.setHasAlpha(true);
+
+    BitmapShader shader = new BitmapShader(toTransform, Shader.TileMode.CLAMP,
+        Shader.TileMode.CLAMP);
+    Paint paint = new Paint();
+    paint.setAntiAlias(true);
+    paint.setShader(shader);
+    RectF rect = new RectF(0, 0, result.getWidth(), result.getHeight());
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(result);
+      canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
+      canvas.drawRoundRect(rect, roundingRadius, roundingRadius, paint);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
+
+    if (!toTransform.equals(inBitmap)) {
+      pool.put(toTransform);
+    }
 
     return result;
   }
 
-  private static Bitmap.Config getSafeConfig(Bitmap bitmap) {
+  // Avoids warnings in M+.
+  private static void clear(Canvas canvas) {
+    canvas.setBitmap(null);
+  }
+
+  @NonNull
+  private static Bitmap.Config getNonNullConfig(@NonNull Bitmap bitmap) {
     return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
   }
 
-  // Visible for testing.
+  private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap targetBitmap,
+      Matrix matrix) {
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(targetBitmap);
+      canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
+  }
+
+  @VisibleForTesting
   static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
     switch (exifOrientation) {
       case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
@@ -312,4 +559,41 @@ static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
         // Do nothing.
     }
   }
+
+  private static final class NoLock implements Lock {
+
+    @Synthetic
+    NoLock() { }
+
+    @Override
+    public void lock() {
+      // do nothing
+    }
+
+    @Override
+    public void lockInterruptibly() throws InterruptedException {
+      // do nothing
+    }
+
+    @Override
+    public boolean tryLock() {
+      return true;
+    }
+
+    @Override
+    public boolean tryLock(long time, @NonNull TimeUnit unit) throws InterruptedException {
+      return true;
+    }
+
+    @Override
+    public void unlock() {
+      // do nothing
+    }
+
+    @NonNull
+    @Override
+    public Condition newCondition() {
+      throw new UnsupportedOperationException("Should not be called");
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
new file mode 100644
index 000000000..63e804bb1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
@@ -0,0 +1,57 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.Util;
+
+/**
+ * Passes through a (hopefully) non-owned {@link Bitmap} as a {@link Bitmap} based {@link Resource}
+ * so that the given {@link Bitmap} is not recycled.
+ */
+public final class UnitBitmapDecoder implements ResourceDecoder<Bitmap, Bitmap> {
+
+  @Override
+  public boolean handles(@NonNull Bitmap source, @NonNull Options options) {
+    return true;
+  }
+
+  @Override
+  public Resource<Bitmap> decode(@NonNull Bitmap source, int width, int height,
+      @NonNull Options options) {
+    return new NonOwnedBitmapResource(source);
+  }
+
+  private static final class NonOwnedBitmapResource implements Resource<Bitmap> {
+
+    private final Bitmap bitmap;
+
+    NonOwnedBitmapResource(@NonNull Bitmap bitmap) {
+      this.bitmap = bitmap;
+    }
+
+    @NonNull
+    @Override
+    public Class<Bitmap> getResourceClass() {
+      return Bitmap.class;
+    }
+
+    @NonNull
+    @Override
+    public Bitmap get() {
+      return bitmap;
+    }
+
+    @Override
+    public int getSize() {
+      return Util.getBitmapByteSize(bitmap);
+    }
+
+    @Override
+    public void recycle() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index c3cb3f5c6..226765e2d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -1,149 +1,31 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.content.Context;
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.security.MessageDigest;
-
 /**
  * An {@link com.bumptech.glide.load.ResourceDecoder} that can decode a thumbnail frame
  * {@link android.graphics.Bitmap} from a {@link android.os.ParcelFileDescriptor} containing a
  * video.
  *
  * @see android.media.MediaMetadataRetriever
+ *
+ * @deprecated Use {@link VideoDecoder#parcel(BitmapPool)} instead. This class may be removed and
+ * {@link VideoDecoder} may become final in a future version of Glide.
  */
-public class VideoBitmapDecoder implements ResourceDecoder<ParcelFileDescriptor, Bitmap> {
-  /**
-   * A constant indicating we should use whatever frame we consider best, frequently not the first
-   * frame.
-   */
-  public static final long DEFAULT_FRAME = -1;
-
-  /**
-   * A long indicating the time position (in microseconds) of the target frame which will be
-   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
-   * extract the video frame.
-   *
-   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
-   * source has a frame located at the position. When this happens, a frame nearby will be returned.
-   * If the long is negative, time position and option will ignored, and any frame that the
-   * implementation considers as representative may be returned.
-   */
-  public static final Option<Long> TARGET_FRAME = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
-      new Option.CacheKeyUpdater<Long>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
-        @Override
-        public void update(byte[] keyBytes, Long value, MessageDigest messageDigest) {
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putLong(value).array());
-          }
-        }
-      });
-
-  /**
-   * An integer indicating the frame option used to retrieve a target frame.
-   *
-   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
-   * {@link #DEFAULT_FRAME}.
-   *
-   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
-   */
-  public static final Option<Integer> FRAME_OPTION = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
-      null /*defaultValue*/,
-      new Option.CacheKeyUpdater<Integer>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
-        @Override
-        public void update(byte[] keyBytes, Integer value, MessageDigest messageDigest) {
-          if (value == null) {
-            return;
-          }
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putInt(value).array());
-          }
-        }
-      }
-  );
-
-  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
-      new MediaMetadataRetrieverFactory();
-
-  private final BitmapPool bitmapPool;
-  private final MediaMetadataRetrieverFactory factory;
+@Deprecated
+public class VideoBitmapDecoder extends VideoDecoder<ParcelFileDescriptor> {
 
+  @SuppressWarnings("unused")
   public VideoBitmapDecoder(Context context) {
     this(Glide.get(context).getBitmapPool());
   }
 
+  // Public API
+  @SuppressWarnings("WeakerAccess")
   public VideoBitmapDecoder(BitmapPool bitmapPool) {
-    this(bitmapPool, DEFAULT_FACTORY);
-  }
-
-  // Visible for testing.
-  VideoBitmapDecoder(BitmapPool bitmapPool, MediaMetadataRetrieverFactory factory) {
-    this.bitmapPool = bitmapPool;
-    this.factory = factory;
-  }
-
-  @Override
-  public boolean handles(ParcelFileDescriptor data, Options options) {
-    MediaMetadataRetriever retriever = factory.build();
-    try {
-      retriever.setDataSource(data.getFileDescriptor());
-      return true;
-    } catch (RuntimeException e) {
-      // Throws a generic runtime exception when given invalid data.
-      return false;
-    } finally {
-      retriever.release();
-    }
-  }
-
-  @Override
-  public Resource<Bitmap> decode(ParcelFileDescriptor resource, int outWidth, int outHeight,
-      Options options) throws IOException {
-    long frameTimeMicros = options.get(TARGET_FRAME);
-    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
-      throw new IllegalArgumentException(
-          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
-    }
-    Integer frameOption = options.get(FRAME_OPTION);
-
-    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
-    mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
-    final Bitmap result;
-    if (frameTimeMicros == DEFAULT_FRAME) {
-      result = mediaMetadataRetriever.getFrameAtTime();
-    } else if (frameOption == null) {
-      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
-    } else {
-      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
-    }
-    mediaMetadataRetriever.release();
-    resource.close();
-    return BitmapResource.obtain(result, bitmapPool);
-  }
-
-  // Visible for testing.
-  static class MediaMetadataRetrieverFactory {
-    public MediaMetadataRetriever build() {
-      return new MediaMetadataRetriever();
-    }
+    super(bitmapPool, new ParcelFileDescriptorInitializer());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
new file mode 100644
index 000000000..509e83e10
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
@@ -0,0 +1,222 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.annotation.TargetApi;
+import android.content.res.AssetFileDescriptor;
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * Decodes video data to Bitmaps from {@link ParcelFileDescriptor}s and
+ * {@link AssetFileDescriptor}s.
+ *
+ * @param <T> The type of data, currently either {@link ParcelFileDescriptor} or
+ * {@link AssetFileDescriptor}.
+ */
+public class VideoDecoder<T> implements ResourceDecoder<T, Bitmap> {
+
+  /**
+   * A constant indicating we should use whatever frame we consider best, frequently not the first
+   * frame.
+   */
+  public static final long DEFAULT_FRAME = -1;
+
+  /** Matches the behavior of {@link MediaMetadataRetriever#getFrameAtTime(long)}. */
+  @VisibleForTesting
+  static final int DEFAULT_FRAME_OPTION = MediaMetadataRetriever.OPTION_CLOSEST_SYNC;
+
+  /**
+   * A long indicating the time position (in microseconds) of the target frame which will be
+   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
+   * extract the video frame.
+   *
+   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
+   * source has a frame located at the position. When this happens, a frame nearby will be returned.
+   * If the long is negative, time position and option will ignored, and any frame that the
+   * implementation considers as representative may be returned.
+   */
+  public static final Option<Long> TARGET_FRAME = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
+      new Option.CacheKeyUpdater<Long>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
+
+        @Override
+        public void update(@NonNull byte[] keyBytes, @NonNull Long value,
+            @NonNull MessageDigest messageDigest) {
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putLong(value).array());
+          }
+        }
+      });
+
+  /**
+   * An integer indicating the frame option used to retrieve a target frame.
+   *
+   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
+   * {@link #DEFAULT_FRAME}.
+   *
+   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static final Option<Integer> FRAME_OPTION = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
+      /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,
+      new Option.CacheKeyUpdater<Integer>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
+
+        @Override
+        public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
+            @NonNull MessageDigest messageDigest) {
+          //noinspection ConstantConditions public API, people could have been doing it wrong
+          if (value == null) {
+            return;
+          }
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putInt(value).array());
+          }
+        }
+      }
+  );
+
+  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
+      new MediaMetadataRetrieverFactory();
+
+  private final MediaMetadataRetrieverInitializer<T> initializer;
+  private final BitmapPool bitmapPool;
+  private final MediaMetadataRetrieverFactory factory;
+
+  public static ResourceDecoder<AssetFileDescriptor, Bitmap> asset(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new AssetFileDescriptorInitializer());
+  }
+
+  public static ResourceDecoder<ParcelFileDescriptor, Bitmap> parcel(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new ParcelFileDescriptorInitializer());
+  }
+
+  VideoDecoder(
+      BitmapPool bitmapPool, MediaMetadataRetrieverInitializer<T> initializer) {
+    this(bitmapPool, initializer, DEFAULT_FACTORY);
+  }
+
+  @VisibleForTesting
+  VideoDecoder(
+      BitmapPool bitmapPool,
+      MediaMetadataRetrieverInitializer<T> initializer,
+      MediaMetadataRetrieverFactory factory) {
+    this.bitmapPool = bitmapPool;
+    this.initializer = initializer;
+    this.factory = factory;
+  }
+
+  @Override
+  public boolean handles(@NonNull T data, @NonNull Options options) {
+    // Calling setDataSource is expensive so avoid doing so unless we're actually called.
+    // For non-videos this isn't any cheaper, but for videos it safes the redundant call and
+    // 50-100ms.
+    return true;
+  }
+
+  @Override
+  public Resource<Bitmap> decode(
+      @NonNull T resource, int outWidth, int outHeight, @NonNull Options options)
+      throws IOException {
+    long frameTimeMicros = options.get(TARGET_FRAME);
+    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
+      throw new IllegalArgumentException(
+          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
+    }
+    Integer frameOption = options.get(FRAME_OPTION);
+    if (frameOption == null) {
+      frameOption = DEFAULT_FRAME_OPTION;
+    }
+
+    final Bitmap result;
+    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
+    try {
+      initializer.initialize(mediaMetadataRetriever, resource);
+      result =
+          decodeFrame(mediaMetadataRetriever, frameTimeMicros, frameOption, outWidth, outHeight);
+    } catch (RuntimeException e) {
+      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data.
+      throw new IOException(e);
+    } finally {
+      mediaMetadataRetriever.release();
+    }
+
+    return BitmapResource.obtain(result, bitmapPool);
+  }
+
+  @TargetApi(Build.VERSION_CODES.O_MR1)
+  @Nullable
+  private static Bitmap decodeFrame(
+      MediaMetadataRetriever mediaMetadataRetriever,
+      long frameTimeMicros,
+      int frameOption,
+      int outWidth,
+      int outHeight) {
+    // Arguably we should handle the case where just width or just height is set to
+    // Target.SIZE_ORIGINAL. Up to and including OMR1, MediaMetadataRetriever defaults to setting
+    // the dimensions to the display width and height if they aren't specified (ie
+    // getScaledFrameAtTime is not used). Given that this is an optimization only if
+    // Target.SIZE_ORIGINAL is not used and not using getScaledFrameAtTime ever would match the
+    // behavior of Glide in all versions of Android prior to OMR1, it's probably fine for now.
+    if (Build.VERSION.SDK_INT >= VERSION_CODES.O_MR1
+        && outWidth != Target.SIZE_ORIGINAL
+        && outHeight != Target.SIZE_ORIGINAL) {
+      return mediaMetadataRetriever.getScaledFrameAtTime(
+          frameTimeMicros, frameOption, outWidth, outHeight);
+    } else {
+      return mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+    }
+  }
+
+  @VisibleForTesting
+  static class MediaMetadataRetrieverFactory {
+    public MediaMetadataRetriever build() {
+      return new MediaMetadataRetriever();
+    }
+  }
+
+  @VisibleForTesting
+  interface MediaMetadataRetrieverInitializer<T> {
+    void initialize(MediaMetadataRetriever retriever, T data);
+  }
+
+  private static final class AssetFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<AssetFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, AssetFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor(), data.getStartOffset(), data.getLength());
+    }
+  }
+
+  // Visible for VideoBitmapDecoder.
+  static final class ParcelFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<ParcelFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, ParcelFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor());
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
index 815c14b8f..a154faafb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
@@ -1,8 +1,7 @@
 package com.bumptech.glide.load.resource.bytes;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.data.DataRewinder;
-
-import java.io.IOException;
 import java.nio.ByteBuffer;
 
 /**
@@ -11,12 +10,15 @@
 public class ByteBufferRewinder implements DataRewinder<ByteBuffer> {
   private final ByteBuffer buffer;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ByteBufferRewinder(ByteBuffer buffer) {
     this.buffer = buffer;
   }
 
+  @NonNull
   @Override
-  public ByteBuffer rewindAndGet() throws IOException {
+  public ByteBuffer rewindAndGet() {
     buffer.position(0);
     return buffer;
   }
@@ -31,11 +33,13 @@ public void cleanup() {
    */
   public static class Factory implements DataRewinder.Factory<ByteBuffer> {
 
+    @NonNull
     @Override
     public DataRewinder<ByteBuffer> build(ByteBuffer data) {
       return new ByteBufferRewinder(data);
     }
 
+    @NonNull
     @Override
     public Class<ByteBuffer> getDataClass() {
       return ByteBuffer.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
index 6b0d7a2be..88068855d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.bytes;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.Preconditions;
 
@@ -13,12 +14,24 @@ public BytesResource(byte[] bytes) {
     this.bytes = Preconditions.checkNotNull(bytes);
   }
 
+  @NonNull
   @Override
   public Class<byte[]> getResourceClass() {
     return byte[].class;
   }
 
+  /**
+   * In most cases it will only be retrieved once (see linked methods).
+   *
+   * @return the same array every time, do not mutate the contents. Not a copy returned, because
+   * copying the array can be prohibitively expensive and/or lead to OOMs.
+   * @see com.bumptech.glide.load.ResourceEncoder
+   * @see com.bumptech.glide.load.resource.transcode.ResourceTranscoder
+   * @see com.bumptech.glide.request.SingleRequest#onResourceReady
+   */
+  @NonNull
   @Override
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
   public byte[] get() {
     return bytes;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
new file mode 100644
index 000000000..2f90275c7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java
@@ -0,0 +1,62 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.Resources.Theme;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.Nullable;
+import android.support.v4.content.res.ResourcesCompat;
+import android.support.v7.content.res.AppCompatResources;
+
+/**
+ * Handles decoding Drawables with the v7 support library if present and falling back to the v4
+ * support library otherwise.
+ */
+public final class DrawableDecoderCompat {
+  private static volatile boolean shouldCallAppCompatResources = true;
+  private DrawableDecoderCompat() {
+    // Utility class.
+  }
+
+  /**
+   * See {@code getDrawable(Context, int, Theme)}.
+   */
+  public static Drawable getDrawable(Context context, @DrawableRes int id) {
+    return getDrawable(context, id, /*theme=*/ null);
+  }
+
+  /**
+   * Loads a Drawable using {@link AppCompatResources} if available and {@link ResourcesCompat}
+   * otherwise, depending on whether or not the v7 support library is included in the application.
+   *
+   * @param theme Used instead of the {@link Theme} returned from the given {@link Context} if
+   * non-null when loading the {@link Drawable}.
+   */
+  public static Drawable getDrawable(Context context, @DrawableRes int id, @Nullable Theme theme) {
+    try {
+      // Race conditions may cause us to attempt to load using v7 more than once. That's ok since
+      // this check is a modest optimization and the output will be correct anyway.
+      if (shouldCallAppCompatResources) {
+        return loadDrawableV7(context, id);
+      }
+    } catch (NoClassDefFoundError error) {
+      shouldCallAppCompatResources = false;
+    } catch (Resources.NotFoundException e) {
+      // Ignored, this can be thrown when drawable compat attempts to decode a canary resource. If
+      // that decode attempt fails, we still want to try with the v4 ResourcesCompat below.
+    }
+
+    return loadDrawableV4(context, id, theme != null ? theme : context.getTheme());
+  }
+
+  private static Drawable loadDrawableV7(Context context, @DrawableRes int id) {
+    return AppCompatResources.getDrawable(context, id);
+  }
+
+  private static Drawable loadDrawableV4(
+      Context context, @DrawableRes int id, @Nullable Theme theme) {
+    Resources resources = context.getResources();
+    return ResourcesCompat.getDrawable(resources, id, theme);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 4cea85519..17b74f2cc 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -1,35 +1,54 @@
 package com.bumptech.glide.load.resource.drawable;
 
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-
+import android.graphics.drawable.Drawable.ConstantState;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.Preconditions;
 
 /**
- * Simple wrapper for an Android {@link Drawable} which returns a {@link
- * android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable} based on it's {@link
- * android.graphics.drawable.Drawable.ConstantState state}.
+ * Simple wrapper for an Android {@link Drawable} which returns a
+ * {@link android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable}
+ * based on it's {@link android.graphics.drawable.Drawable.ConstantState state}.
  *
  * <b>Suggested usages only include {@code T}s where the new drawable is of the same or descendant
  * class.</b>
  *
  * @param <T> type of the wrapped {@link Drawable}
  */
-public abstract class DrawableResource<T extends Drawable> implements Resource<T> {
+public abstract class DrawableResource<T extends Drawable> implements Resource<T>,
+    Initializable {
   protected final T drawable;
 
   public DrawableResource(T drawable) {
     this.drawable = Preconditions.checkNotNull(drawable);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   @Override
   public final T get() {
-    // Drawables contain temporary state related to how they're being displayed (alpha, color
-    // filter etc), so
-    // return a new copy each time. If we ever return the original drawable, it's temporary state
-    // may be changed
+    @Nullable ConstantState state = drawable.getConstantState();
+    if (state == null) {
+      return drawable;
+    }
+    // Drawables contain temporary state related to how they're being displayed
+    // (alpha, color filter etc), so return a new copy each time.
+    // If we ever return the original drawable, it's temporary state may be changed
     // and subsequent copies may end up with that temporary state. See #276.
-    return (T) drawable.getConstantState().newDrawable();
+    return (T) state.newDrawable();
+  }
+
+  @Override
+  public void initialize() {
+    if (drawable instanceof BitmapDrawable) {
+      ((BitmapDrawable) drawable).getBitmap().prepareToDraw();
+    } else if (drawable instanceof GifDrawable) {
+      ((GifDrawable) drawable).getFirstFrame().prepareToDraw();
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index 9d8c8a2f2..8eec67561 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -1,38 +1,111 @@
 package com.bumptech.glide.load.resource.drawable;
 
 import android.graphics.drawable.Drawable;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
+import com.bumptech.glide.request.transition.TransitionFactory;
 
 /**
  * Contains {@link Drawable} specific animation options.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class DrawableTransitionOptions extends
     TransitionOptions<DrawableTransitionOptions, Drawable> {
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade()
+   */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade() {
     return new DrawableTransitionOptions().crossFade();
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int)
+   */
+  @NonNull
   public static DrawableTransitionOptions withCrossFade(int duration) {
     return new DrawableTransitionOptions().crossFade(duration);
   }
 
-  public static DrawableTransitionOptions withCrossFade(int animationId, int duration) {
-    return new DrawableTransitionOptions().crossFade(animationId, duration);
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory)
+   */
+  @NonNull
+  public static DrawableTransitionOptions withCrossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return new DrawableTransitionOptions().crossFade(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory.Builder)
+   */
+  @NonNull
+  public static DrawableTransitionOptions withCrossFade(
+      @NonNull DrawableCrossFadeFactory.Builder builder) {
+    return new DrawableTransitionOptions().crossFade(builder);
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that uses the given transition factory.
+   *
+   * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
+   */
+  @NonNull
+  public static DrawableTransitionOptions with(
+      @NonNull TransitionFactory<Drawable> transitionFactory) {
+    return new DrawableTransitionOptions().transition(transitionFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  @NonNull
   public DrawableTransitionOptions crossFade() {
-    return transition(new DrawableCrossFadeFactory());
+    return crossFade(new DrawableCrossFadeFactory.Builder());
   }
 
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param duration The duration of the animation, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
+  @NonNull
   public DrawableTransitionOptions crossFade(int duration) {
-    return transition(new DrawableCrossFadeFactory(duration));
+    return crossFade(new DrawableCrossFadeFactory.Builder(duration));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  @NonNull
+  public DrawableTransitionOptions crossFade(
+      @NonNull DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return transition(drawableCrossFadeFactory);
   }
 
-  public DrawableTransitionOptions crossFade(int animationId, int duration) {
-    return transition(new DrawableCrossFadeFactory(animationId, duration));
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  @NonNull
+  public DrawableTransitionOptions crossFade(@NonNull DrawableCrossFadeFactory.Builder builder) {
+    return crossFade(builder.build());
   }
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
new file mode 100644
index 000000000..2cba88462
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.engine.Resource;
+
+/**
+ * Handles generic {@link Drawable} types where we may be uncertain of their size or type and
+ * where we don't know that it's safe for us to recycle or re-use the Drawable.
+ */
+final class NonOwnedDrawableResource extends DrawableResource<Drawable> {
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  static Resource<Drawable> newInstance(@Nullable Drawable drawable) {
+    return drawable != null ? new NonOwnedDrawableResource(drawable) : null;
+  }
+
+  private NonOwnedDrawableResource(Drawable drawable) {
+    super(drawable);
+  }
+
+  @NonNull
+  @SuppressWarnings("unchecked")
+  @Override
+  public Class<Drawable> getResourceClass() {
+    return (Class<Drawable>) drawable.getClass();
+  }
+
+  @Override
+  public int getSize() {
+    // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If
+    // there are no intrinsic bounds, we can fall back just to 1.
+    return Math.max(1, drawable.getIntrinsicWidth() * drawable.getIntrinsicHeight() * 4);
+  }
+
+  @Override
+  public void recycle() {
+    // Do nothing.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
new file mode 100644
index 000000000..1550ef519
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import java.util.List;
+
+/**
+ * Decodes {@link Drawable}s given resource {@link Uri}s.
+ *
+ * <p>This is typically used as a fallback for resource types that either aren't Bitmaps (see #350)
+ * or for resource types that we can't obtain an {@link java.io.InputStream} for using a standard
+ * {@link ContentResolver}, including some types of application icons and resources loaded from
+ * other packages.
+ */
+public class ResourceDrawableDecoder implements ResourceDecoder<Uri, Drawable> {
+  // android.resource://<package_name>/<type>/<name>.
+  private static final int NAME_URI_PATH_SEGMENTS = 2;
+  private static final int TYPE_PATH_SEGMENT_INDEX = 0;
+  private static final int NAME_PATH_SEGMENT_INDEX = 1;
+  // android.resource://<package_name>/<resource_id>
+  private static final int ID_PATH_SEGMENTS = 1;
+  private static final int RESOURCE_ID_SEGMENT_INDEX = 0;
+
+  private final Context context;
+
+  public ResourceDrawableDecoder(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  @Override
+  public boolean handles(@NonNull Uri source, @NonNull Options options) {
+    return source.getScheme().equals(ContentResolver.SCHEME_ANDROID_RESOURCE);
+  }
+
+  @Nullable
+  @Override
+  public Resource<Drawable> decode(@NonNull Uri source, int width, int height,
+      @NonNull Options options) {
+    @DrawableRes int resId = loadResourceIdFromUri(source);
+    String packageName = source.getAuthority();
+    Context toUse = packageName.equals(context.getPackageName())
+        ? context : getContextForPackage(source, packageName);
+    // We can't get a theme from another application.
+    Drawable drawable = DrawableDecoderCompat.getDrawable(toUse, resId);
+    return NonOwnedDrawableResource.newInstance(drawable);
+  }
+
+  @NonNull
+  private Context getContextForPackage(Uri source, String packageName) {
+    try {
+      return context.createPackageContext(packageName, /*flags=*/ 0);
+    } catch (NameNotFoundException e) {
+      throw new IllegalArgumentException(
+          "Failed to obtain context or unrecognized Uri format for: " + source, e);
+    }
+  }
+
+  @DrawableRes
+  private int loadResourceIdFromUri(Uri source) {
+    List<String> segments = source.getPathSegments();
+    @DrawableRes Integer result = null;
+    if (segments.size() == NAME_URI_PATH_SEGMENTS) {
+      String packageName = source.getAuthority();
+      String typeName = segments.get(TYPE_PATH_SEGMENT_INDEX);
+      String resourceName = segments.get(NAME_PATH_SEGMENT_INDEX);
+      result = context.getResources().getIdentifier(resourceName, typeName, packageName);
+    } else if (segments.size() == ID_PATH_SEGMENTS) {
+      try {
+        result = Integer.valueOf(segments.get(RESOURCE_ID_SEGMENT_INDEX));
+      } catch (NumberFormatException e) {
+        // Ignored.
+      }
+    }
+
+    if (result == null) {
+      throw new IllegalArgumentException("Unrecognized Uri format: " + source);
+    } else if (result == 0) {
+      throw new IllegalArgumentException("Failed to obtain resource id for: " + source);
+    }
+    return result;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
new file mode 100644
index 000000000..7ac9450c7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/UnitDrawableDecoder.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.load.resource.drawable;
+
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+
+/**
+ * Passes through a {@link Drawable} as a {@link Drawable} based {@link Resource}.
+ */
+public class UnitDrawableDecoder implements ResourceDecoder<Drawable, Drawable> {
+  @Override
+  public boolean handles(@NonNull Drawable source, @NonNull Options options) {
+    return true;
+  }
+
+  @Nullable
+  @Override
+  public Resource<Drawable> decode(@NonNull Drawable source, int width, int height,
+      @NonNull Options options) {
+    return NonOwnedDrawableResource.newInstance(source);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
index 01c54c297..a5b3e13dd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
@@ -1,9 +1,9 @@
 package com.bumptech.glide.load.resource.file;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.io.File;
 
 /**
@@ -13,12 +13,13 @@
 public class FileDecoder implements ResourceDecoder<File, File> {
 
   @Override
-  public boolean handles(File source, Options options) {
+  public boolean handles(@NonNull File source, @NonNull Options options) {
     return true;
   }
 
   @Override
-  public Resource<File> decode(File source, int width, int height, Options options) {
+  public Resource<File> decode(@NonNull File source, int width, int height,
+      @NonNull Options options) {
     return new FileResource(source);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
index 4cc540b0c..790f33b53 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
@@ -1,12 +1,13 @@
 package com.bumptech.glide.load.resource.file;
 
 import com.bumptech.glide.load.resource.SimpleResource;
-
 import java.io.File;
 
 /**
  * A simple {@link com.bumptech.glide.load.engine.Resource} that wraps a {@link File}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class FileResource extends SimpleResource<File> {
   public FileResource(File file) {
     super(file);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index aa62a9250..dbab1827c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -2,26 +2,30 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
-import com.bumptech.glide.load.Option;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.List;
 import java.util.Queue;
 
 /**
@@ -31,88 +35,93 @@
 public class ByteBufferGifDecoder implements ResourceDecoder<ByteBuffer, GifDrawable> {
   private static final String TAG = "BufferGifDecoder";
   private static final GifDecoderFactory GIF_DECODER_FACTORY = new GifDecoderFactory();
-
-  /**
-   *  If set to {@code true}, disables this decoder
-   *  ({@link #handles(ByteBuffer, Options)} will return {@code false}). Defaults to
-   * {@code false}.
-   */
-  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
-      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
-
   private static final GifHeaderParserPool PARSER_POOL = new GifHeaderParserPool();
 
   private final Context context;
+  private final List<ImageHeaderParser> parsers;
   private final GifHeaderParserPool parserPool;
-  private final BitmapPool bitmapPool;
-  private final ByteArrayPool byteArrayPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ByteBufferGifDecoder(Context context) {
-    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getByteArrayPool());
+    this(context, Glide.get(context).getRegistry().getImageHeaderParsers(),
+        Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
   }
 
-  public ByteBufferGifDecoder(Context context, BitmapPool bitmapPool, ByteArrayPool byteArrayPool) {
-    this(context, bitmapPool, byteArrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
+  public ByteBufferGifDecoder(
+      Context context, List<ImageHeaderParser> parsers, BitmapPool bitmapPool,
+      ArrayPool arrayPool) {
+    this(context, parsers, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
-  // Visible for testing.
-  ByteBufferGifDecoder(Context context, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,
-      GifHeaderParserPool parserPool, GifDecoderFactory gifDecoderFactory) {
-    this.context = context;
-    this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
+  @VisibleForTesting
+  ByteBufferGifDecoder(
+      Context context,
+      List<ImageHeaderParser> parsers,
+      BitmapPool bitmapPool,
+      ArrayPool arrayPool,
+      GifHeaderParserPool parserPool,
+      GifDecoderFactory gifDecoderFactory) {
+    this.context = context.getApplicationContext();
+    this.parsers = parsers;
     this.gifDecoderFactory = gifDecoderFactory;
-    this.provider = new GifBitmapProvider(bitmapPool, byteArrayPool);
+    this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
     this.parserPool = parserPool;
   }
 
   @Override
-  public boolean handles(ByteBuffer source, Options options) throws IOException {
-    return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+  public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) throws IOException {
+    return !options.get(GifOptions.DISABLE_ANIMATION)
+        && ImageHeaderParserUtils.getType(parsers, source) == ImageType.GIF;
   }
 
   @Override
-  public GifDrawableResource decode(ByteBuffer source, int width, int height, Options options) {
+  public GifDrawableResource decode(@NonNull ByteBuffer source, int width, int height,
+      @NonNull Options options) {
     final GifHeaderParser parser = parserPool.obtain(source);
     try {
-      return decode(source, width, height, parser);
+      return decode(source, width, height, parser, options);
     } finally {
       parserPool.release(parser);
     }
   }
 
-  private GifDrawableResource decode(ByteBuffer byteBuffer, int width, int height,
-      GifHeaderParser parser) {
+  @Nullable
+  private GifDrawableResource decode(
+      ByteBuffer byteBuffer, int width, int height, GifHeaderParser parser, Options options) {
     long startTime = LogTime.getLogTime();
-    final GifHeader header = parser.parseHeader();
-    if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
-      // If we couldn't decode the GIF, we will end up with a frame count of 0.
-      return null;
-    }
+    try {
+      final GifHeader header = parser.parseHeader();
+      if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
+        // If we couldn't decode the GIF, we will end up with a frame count of 0.
+        return null;
+      }
 
+      Bitmap.Config config = options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565
+          ? Bitmap.Config.RGB_565 : Bitmap.Config.ARGB_8888;
 
-    int sampleSize = getSampleSize(header, width, height);
-    GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
-    gifDecoder.advance();
-    Bitmap firstFrame = gifDecoder.getNextFrame();
-    if (firstFrame == null) {
-      return null;
-    }
+      int sampleSize = getSampleSize(header, width, height);
+      GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
+      gifDecoder.setDefaultBitmapConfig(config);
+      gifDecoder.advance();
+      Bitmap firstFrame = gifDecoder.getNextFrame();
+      if (firstFrame == null) {
+        return null;
+      }
 
-    Transformation<Bitmap> unitTransformation = UnitTransformation.get();
+      Transformation<Bitmap> unitTransformation = UnitTransformation.get();
 
-    GifDrawable gifDrawable =
-        new GifDrawable(context, gifDecoder, bitmapPool, unitTransformation, width, height,
-            firstFrame);
+      GifDrawable gifDrawable =
+          new GifDrawable(context, gifDecoder, unitTransformation, width, height, firstFrame);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Decoded gif from stream in " + LogTime.getElapsedMillis(startTime));
+      return new GifDrawableResource(gifDrawable);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-
-    return new GifDrawableResource(gifDrawable);
   }
 
   private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targetHeight) {
@@ -122,8 +131,8 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
     // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code
     // than 0.
     int sampleSize = Math.max(1, powerOfTwoSampleSize);
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Downsampling gif"
+    if (Log.isLoggable(TAG, Log.VERBOSE) && sampleSize > 1) {
+      Log.v(TAG, "Downsampling GIF"
           + ", sampleSize: " + sampleSize
           + ", target dimens: [" + targetWidth + "x" + targetHeight + "]"
           + ", actual dimens: [" + gifHeader.getWidth() + "x" + gifHeader.getHeight() + "]");
@@ -131,19 +140,19 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
     return sampleSize;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class GifDecoderFactory {
-    public GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
+    GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
         ByteBuffer data, int sampleSize) {
-      return new GifDecoder(provider, header, data, sampleSize);
+      return new StandardGifDecoder(provider, header, data, sampleSize);
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class GifHeaderParserPool {
     private final Queue<GifHeaderParser> pool = Util.createQueue(0);
 
-    public synchronized GifHeaderParser obtain(ByteBuffer buffer) {
+    synchronized GifHeaderParser obtain(ByteBuffer buffer) {
       GifHeaderParser result = pool.poll();
       if (result == null) {
         result = new GifHeaderParser();
@@ -151,7 +160,7 @@ public synchronized GifHeaderParser obtain(ByteBuffer buffer) {
       return result.setData(buffer);
     }
 
-    public synchronized void release(GifHeaderParser parser) {
+    synchronized void release(GifHeaderParser parser) {
       parser.clear();
       pool.offer(parser);
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index 6b2988df9..400530d79 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -4,10 +4,9 @@
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 
 /**
  * Implements {@link com.bumptech.glide.gifdecoder.GifDecoder.BitmapProvider} by wrapping Glide's
@@ -15,49 +14,70 @@
  */
 public final class GifBitmapProvider implements GifDecoder.BitmapProvider {
   private final BitmapPool bitmapPool;
-  @Nullable private final ByteArrayPool byteArrayPool;
+  @Nullable private final ArrayPool arrayPool;
 
   /**
    * Constructs an instance without a shared byte array pool. Byte arrays will be always constructed
    * when requested.
    */
   public GifBitmapProvider(BitmapPool bitmapPool) {
-    this(bitmapPool, null /*byteArrayPool*/);
+    this(bitmapPool, /*arrayPool=*/ null);
   }
 
   /**
-   * Constructs an instance with a shared byte array pool. Byte arrays will be reused where
+   * Constructs an instance with a shared array pool. Arrays will be reused where
    * possible.
    */
-  public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ByteArrayPool byteArrayPool) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ArrayPool arrayPool) {
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
+    this.arrayPool = arrayPool;
   }
 
   @NonNull
   @Override
-  public Bitmap obtain(int width, int height, Bitmap.Config config) {
+  public Bitmap obtain(int width, int height, @NonNull Bitmap.Config config) {
     return bitmapPool.getDirty(width, height, config);
   }
 
   @Override
-  public void release(Bitmap bitmap) {
+  public void release(@NonNull Bitmap bitmap) {
     bitmapPool.put(bitmap);
   }
 
+  @NonNull
   @Override
   public byte[] obtainByteArray(int size) {
-    if (byteArrayPool == null) {
+    if (arrayPool == null) {
       return new byte[size];
     }
-    return byteArrayPool.get(size);
+    return arrayPool.get(size, byte[].class);
+  }
+
+  @Override
+  public void release(@NonNull byte[] bytes) {
+    if (arrayPool == null) {
+      return;
+    }
+    arrayPool.put(bytes);
+  }
+
+  @NonNull
+  @Override
+  public int[] obtainIntArray(int size) {
+    if (arrayPool == null) {
+      return new int[size];
+    }
+    return arrayPool.get(size, int[].class);
   }
 
+  @SuppressWarnings("PMD.UseVarargs")
   @Override
-  public void release(byte[] bytes) {
-    if (byteArrayPool == null) {
+  public void release(@NonNull int[] array) {
+    if (arrayPool == null) {
       return;
     }
-    byteArrayPool.put(bytes);
+    arrayPool.put(array);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index dfcffbc6f..cd0aa5248 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
-import android.annotation.TargetApi;
+import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;
+
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -11,14 +12,14 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.view.Gravity;
-
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.nio.ByteBuffer;
 
 /**
@@ -29,13 +30,18 @@
   /**
    * A constant indicating that an animated drawable should loop continuously.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final int LOOP_FOREVER = -1;
   /**
    * A constant indicating that an animated drawable should loop for its default number of times.
    * For animated GIFs, this constant indicates the GIF should use the netscape loop count if
    * present.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public static final int LOOP_INTRINSIC = 0;
+  private static final int GRAVITY = Gravity.FILL;
 
   private final GifState state;
   /**
@@ -58,11 +64,11 @@
    */
   private boolean isVisible = true;
   /**
-   * The number of times we've looped over all the frames in the gif.
+   * The number of times we've looped over all the frames in the GIF.
    */
   private int loopCount;
   /**
-   * The number of times to loop through the gif animation.
+   * The number of times to loop through the GIF animation.
    */
   private int maxLoopCount = LOOP_FOREVER;
 
@@ -74,9 +80,7 @@
    * Constructor for GifDrawable.
    *
    * @param context             A context.
-   * @param bitmapPool          A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}
-   *                            that can be used to return the first frame when this drawable is
-   *                            recycled.
+   * @param bitmapPool          Ignored, see deprecation note.
    * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
    *                            applied to each frame.
    * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
@@ -87,25 +91,69 @@
    *                            height of the view or
    *                            {@link com.bumptech.glide.request.target.Target}
    *                            this drawable is being loaded into).
-   * @param gifDecoder          The decoder to use to decode gif data.
-   * @param firstFrame          The decoded and transformed first frame of this gif.
+   * @param gifDecoder          The decoder to use to decode GIF data.
+   * @param firstFrame          The decoded and transformed first frame of this GIF.
    * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
+   *
+   * @deprecated Use {@link #GifDrawable(Context, GifDecoder, Transformation, int, int, Bitmap)}
    */
-  public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool,
-      Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public GifDrawable(
+      Context context,
+      GifDecoder gifDecoder,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
+      Transformation<Bitmap> frameTransformation,
+      int targetFrameWidth,
+      int targetFrameHeight,
       Bitmap firstFrame) {
-    this(new GifState(context, bitmapPool,
-        new GifFrameLoader(context, gifDecoder, targetFrameWidth, targetFrameHeight,
-            frameTransformation, firstFrame)));
+    this(context, gifDecoder, frameTransformation, targetFrameWidth, targetFrameHeight, firstFrame);
+  }
+
+   /**
+   * Constructor for GifDrawable.
+   *
+   * @param context             A context.
+   * @param frameTransformation An {@link com.bumptech.glide.load.Transformation} that can be
+   *                            applied to each frame.
+   * @param targetFrameWidth    The desired width of the frames displayed by this drawable (the
+   *                            width of the view or
+   *                            {@link com.bumptech.glide.request.target.Target}
+   *                            this drawable is being loaded into).
+   * @param targetFrameHeight   The desired height of the frames displayed by this drawable (the
+   *                            height of the view or
+   *                            {@link com.bumptech.glide.request.target.Target}
+   *                            this drawable is being loaded into).
+   * @param gifDecoder          The decoder to use to decode GIF data.
+   * @param firstFrame          The decoded and transformed first frame of this GIF.
+   * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
+   */
+  public GifDrawable(
+      Context context,
+      GifDecoder gifDecoder,
+      Transformation<Bitmap> frameTransformation,
+      int targetFrameWidth,
+      int targetFrameHeight,
+      Bitmap firstFrame) {
+    this(
+        new GifState(
+            new GifFrameLoader(
+                // TODO(b/27524013): Factor out this call to Glide.get()
+                Glide.get(context),
+                gifDecoder,
+                targetFrameWidth,
+                targetFrameHeight,
+                frameTransformation,
+                firstFrame)));
   }
 
   GifDrawable(GifState state) {
     this.state = Preconditions.checkNotNull(state);
   }
 
-  // Visible for testing.
-  GifDrawable(Context context, GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
-    this(new GifState(context, bitmapPool, frameLoader));
+  @VisibleForTesting
+  GifDrawable(GifFrameLoader frameLoader, Paint paint) {
+    this(new GifState(frameLoader));
     this.paint = paint;
   }
 
@@ -117,6 +165,8 @@ public Bitmap getFirstFrame() {
     return state.frameLoader.getFirstFrame();
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public void setFrameTransformation(Transformation<Bitmap> frameTransformation,
       Bitmap firstFrame) {
     state.frameLoader.setFrameTransformation(frameTransformation, firstFrame);
@@ -138,6 +188,8 @@ public int getFrameCount() {
    * Returns the current frame index in the range 0..{@link #getFrameCount()} - 1, or -1 if no frame
    * is displayed.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public int getFrameIndex() {
     return state.frameLoader.getCurrentIndex();
   }
@@ -146,6 +198,17 @@ private void resetLoopCount() {
     loopCount = 0;
   }
 
+  /**
+   * Starts the animation from the first frame. Can only be called while animation is not running.
+   */
+  // Public API.
+  @SuppressWarnings("unused")
+  public void startFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "You cannot restart a currently running animation.");
+    state.frameLoader.setNextStartFromFirstFrame();
+    start();
+  }
+
   @Override
   public void start() {
     isStarted = true;
@@ -162,6 +225,8 @@ public void stop() {
   }
 
   private void startRunning() {
+    Preconditions.checkArgument(!isRecycled, "You cannot start a recycled Drawable. Ensure that"
+        + "you clear any references to the Drawable when clearing the corresponding request.");
     // If we have only a single frame, we don't want to decode it endlessly.
     if (state.frameLoader.getFrameCount() == 1) {
       invalidateSelf();
@@ -179,6 +244,9 @@ private void stopRunning() {
 
   @Override
   public boolean setVisible(boolean visible, boolean restart) {
+    Preconditions.checkArgument(!isRecycled, "Cannot change the visibility of a recycled resource."
+        + " Ensure that you unset the Drawable from your View before changing the View's"
+        + " visibility.");
     isVisible = visible;
     if (!visible) {
       stopRunning();
@@ -215,14 +283,13 @@ protected void onBoundsChange(Rect bounds) {
   }
 
   @Override
-  public void draw(Canvas canvas) {
+  public void draw(@NonNull Canvas canvas) {
     if (isRecycled) {
       return;
     }
 
     if (applyGravity) {
-      Gravity.apply(GifState.GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(),
-          getDestRect());
+      Gravity.apply(GRAVITY, getIntrinsicWidth(), getIntrinsicHeight(), getBounds(), getDestRect());
       applyGravity = false;
     }
 
@@ -260,10 +327,18 @@ public int getOpacity() {
     return PixelFormat.TRANSPARENT;
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  // See #1087.
+  private Callback findCallback() {
+    Callback callback = getCallback();
+    while (callback instanceof Drawable) {
+      callback = ((Drawable) callback).getCallback();
+    }
+    return callback;
+  }
+
   @Override
   public void onFrameReady() {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && getCallback() == null) {
+    if (findCallback() == null) {
       stop();
       invalidateSelf();
       return;
@@ -298,6 +373,8 @@ boolean isRecycled() {
     return isRecycled;
   }
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public void setLoopCount(int loopCount) {
     if (loopCount <= 0 && loopCount != LOOP_FOREVER && loopCount != LOOP_INTRINSIC) {
       throw new IllegalArgumentException("Loop count must be greater than 0, or equal to "
@@ -305,29 +382,29 @@ public void setLoopCount(int loopCount) {
     }
 
     if (loopCount == LOOP_INTRINSIC) {
-      maxLoopCount = state.frameLoader.getLoopCount();
+      int intrinsicCount = state.frameLoader.getLoopCount();
+      maxLoopCount =
+          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;
     } else {
       maxLoopCount = loopCount;
     }
   }
 
-  static class GifState extends ConstantState {
-    static final int GRAVITY = Gravity.FILL;
-    final Context context;
-    final BitmapPool bitmapPool;
+  static final class GifState extends ConstantState {
+    @VisibleForTesting
     final GifFrameLoader frameLoader;
 
-    public GifState(Context context, BitmapPool bitmapPool, GifFrameLoader frameLoader) {
-      this.bitmapPool = bitmapPool;
-      this.context = context.getApplicationContext();
+    GifState(GifFrameLoader frameLoader) {
       this.frameLoader = frameLoader;
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable(Resources res) {
       return newDrawable();
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable() {
       return new GifDrawable(this);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
index 44268ec8e..e73f713dc 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
@@ -1,13 +1,12 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.File;
 import java.io.IOException;
 
@@ -18,13 +17,15 @@
 public class GifDrawableEncoder implements ResourceEncoder<GifDrawable> {
   private static final String TAG = "GifEncoder";
 
+  @NonNull
   @Override
-  public EncodeStrategy getEncodeStrategy(Options options) {
+  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {
     return EncodeStrategy.SOURCE;
   }
 
   @Override
-  public boolean encode(Resource<GifDrawable> data, File file, Options options) {
+  public boolean encode(@NonNull Resource<GifDrawable> data, @NonNull File file,
+      @NonNull Options options) {
     GifDrawable drawable = data.get();
     boolean success = false;
     try {
@@ -32,7 +33,7 @@ public boolean encode(Resource<GifDrawable> data, File file, Options options) {
       success = true;
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Failed to encode gif drawable data", e);
+        Log.w(TAG, "Failed to encode GIF drawable data", e);
       }
     }
     return success;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index 6b8301462..090f279b8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -1,15 +1,21 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 
 /**
  * A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
-public class GifDrawableResource extends DrawableResource<GifDrawable> {
+public class GifDrawableResource extends DrawableResource<GifDrawable>
+    implements Initializable {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public GifDrawableResource(GifDrawable drawable) {
     super(drawable);
   }
 
+  @NonNull
   @Override
   public Class<GifDrawable> getResourceClass() {
     return GifDrawable.class;
@@ -17,7 +23,7 @@ public GifDrawableResource(GifDrawable drawable) {
 
   @Override
   public int getSize() {
-   return drawable.getSize();
+    return drawable.getSize();
   }
 
   @Override
@@ -25,4 +31,9 @@ public void recycle() {
     drawable.stop();
     drawable.recycle();
   }
+
+  @Override
+  public void initialize() {
+    drawable.getFirstFrame().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index 1d78c736e..8c39e60cb 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -2,14 +2,13 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -19,30 +18,45 @@
  */
 public class GifDrawableTransformation implements Transformation<GifDrawable> {
   private final Transformation<Bitmap> wrapped;
-  private final BitmapPool bitmapPool;
 
-  public GifDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
-    this(wrapped, Glide.get(context).getBitmapPool());
+  public GifDrawableTransformation(Transformation<Bitmap> wrapped) {
+    this.wrapped = Preconditions.checkNotNull(wrapped);
+  }
+
+  /**
+   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}.
+   */
+  @Deprecated
+  public GifDrawableTransformation(
+      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
+    this(wrapped);
   }
 
-  public GifDrawableTransformation(Transformation<Bitmap> wrapped, BitmapPool bitmapPool) {
-    this.wrapped = Preconditions.checkNotNull(wrapped);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+  /**
+   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}
+   */
+  @Deprecated
+  public GifDrawableTransformation(
+      Transformation<Bitmap> wrapped, @SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this(wrapped);
   }
 
+  @NonNull
   @Override
-  public Resource<GifDrawable> transform(Resource<GifDrawable> resource, int outWidth,
-      int outHeight) {
+  public Resource<GifDrawable> transform(
+      @NonNull Context context, @NonNull Resource<GifDrawable> resource,
+      int outWidth, int outHeight) {
     GifDrawable drawable = resource.get();
 
     // The drawable needs to be initialized with the correct width and height in order for a view
     // displaying it to end up with the right dimensions. Since our transformations may arbitrarily
-    // modify the dimensions of our gif, here we create a stand in for a frame and pass it to the
+    // modify the dimensions of our GIF, here we create a stand in for a frame and pass it to the
     // transformation to see what the final transformed dimensions will be so that our drawable can
     // report the correct intrinsic width and height.
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Bitmap firstFrame = drawable.getFirstFrame();
     Resource<Bitmap> bitmapResource = new BitmapResource(firstFrame, bitmapPool);
-    Resource<Bitmap> transformed = wrapped.transform(bitmapResource, outWidth, outHeight);
+    Resource<Bitmap> transformed = wrapped.transform(context, bitmapResource, outWidth, outHeight);
     if (!bitmapResource.equals(transformed)) {
       bitmapResource.recycle();
     }
@@ -67,7 +81,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     wrapped.updateDiskCacheKey(messageDigest);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 5431bca24..c46775bd2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -3,13 +3,14 @@
 import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemClock;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
@@ -17,55 +18,73 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.nio.ByteBuffer;
-import java.security.MessageDigest;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.UUID;
 
 class GifFrameLoader {
   private final GifDecoder gifDecoder;
   private final Handler handler;
-  private final Context context;
   private final List<FrameCallback> callbacks = new ArrayList<>();
-  private final RequestManager requestManager;
+  @SuppressWarnings("WeakerAccess") @Synthetic final RequestManager requestManager;
+  private final BitmapPool bitmapPool;
 
-  private boolean isRunning = false;
-  private boolean isLoadPending = false;
+  private boolean isRunning;
+  private boolean isLoadPending;
+  private boolean startFromFirstFrame;
   private RequestBuilder<Bitmap> requestBuilder;
   private DelayTarget current;
   private boolean isCleared;
   private DelayTarget next;
   private Bitmap firstFrame;
   private Transformation<Bitmap> transformation;
+  private DelayTarget pendingTarget;
+  @Nullable
+  private GifFrameLoader.OnEveryFrameListener onEveryFrameListener;
 
   public interface FrameCallback {
     void onFrameReady();
   }
 
-  public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int height,
-      Transformation<Bitmap> transformation, Bitmap firstFrame) {
-    this(context,
-        Glide.with(context),
+  GifFrameLoader(
+      Glide glide,
+      GifDecoder gifDecoder,
+      int width,
+      int height,
+      Transformation<Bitmap> transformation,
+      Bitmap firstFrame) {
+    this(
+        glide.getBitmapPool(),
+        Glide.with(glide.getContext()),
         gifDecoder,
         null /*handler*/,
-        getRequestBuilder(context, width, height), transformation, firstFrame);
+        getRequestBuilder(Glide.with(glide.getContext()), width, height),
+        transformation,
+        firstFrame);
   }
 
-  GifFrameLoader(Context context, RequestManager requestManager, GifDecoder gifDecoder,
-      Handler handler, RequestBuilder<Bitmap> requestBuilder, Transformation<Bitmap> transformation,
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+  GifFrameLoader(
+      BitmapPool bitmapPool,
+      RequestManager requestManager,
+      GifDecoder gifDecoder,
+      Handler handler,
+      RequestBuilder<Bitmap> requestBuilder,
+      Transformation<Bitmap> transformation,
       Bitmap firstFrame) {
     this.requestManager = requestManager;
     if (handler == null) {
       handler = new Handler(Looper.getMainLooper(), new FrameLoaderCallback());
     }
-    this.context = context;
+    this.bitmapPool = bitmapPool;
     this.handler = handler;
     this.requestBuilder = requestBuilder;
 
@@ -77,7 +96,7 @@ public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int hei
   void setFrameTransformation(Transformation<Bitmap> transformation, Bitmap firstFrame) {
     this.transformation = Preconditions.checkNotNull(transformation);
     this.firstFrame = Preconditions.checkNotNull(firstFrame);
-    requestBuilder = requestBuilder.apply(new RequestOptions().transform(context, transformation));
+    requestBuilder = requestBuilder.apply(new RequestOptions().transform(transformation));
   }
 
   Transformation<Bitmap> getFrameTransformation() {
@@ -92,10 +111,10 @@ void subscribe(FrameCallback frameCallback) {
     if (isCleared) {
       throw new IllegalStateException("Cannot subscribe to a cleared frame loader");
     }
-    boolean start = callbacks.isEmpty();
     if (callbacks.contains(frameCallback)) {
       throw new IllegalStateException("Cannot subscribe twice in a row");
     }
+    boolean start = callbacks.isEmpty();
     callbacks.add(frameCallback);
     if (start) {
       start();
@@ -139,7 +158,7 @@ int getFrameCount() {
   }
 
   int getLoopCount() {
-    return gifDecoder.getLoopCount();
+    return gifDecoder.getTotalIterationCount();
   }
 
   private void start() {
@@ -168,6 +187,10 @@ void clear() {
       requestManager.clear(next);
       next = null;
     }
+    if (pendingTarget != null) {
+      requestManager.clear(pendingTarget);
+      pendingTarget = null;
+    }
     gifDecoder.clear();
     isCleared = true;
   }
@@ -180,6 +203,18 @@ private void loadNextFrame() {
     if (!isRunning || isLoadPending) {
       return;
     }
+    if (startFromFirstFrame) {
+      Preconditions.checkArgument(
+          pendingTarget == null, "Pending target must be null when starting from the first frame");
+      gifDecoder.resetFrameIndex();
+      startFromFirstFrame = false;
+    }
+    if (pendingTarget != null) {
+      DelayTarget temp = pendingTarget;
+      pendingTarget = null;
+      onFrameReady(temp);
+      return;
+    }
     isLoadPending = true;
     // Get the delay before incrementing the pointer because the delay indicates the amount of time
     // we want to spend on the current frame.
@@ -188,22 +223,48 @@ private void loadNextFrame() {
 
     gifDecoder.advance();
     next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);
-    requestBuilder.clone().apply(signatureOf(new FrameSignature())).load(gifDecoder).into(next);
+    requestBuilder.apply(signatureOf(getFrameSignature())).load(gifDecoder).into(next);
   }
 
   private void recycleFirstFrame() {
     if (firstFrame != null) {
-      Glide.get(context).getBitmapPool().put(firstFrame);
+      bitmapPool.put(firstFrame);
       firstFrame = null;
     }
   }
 
-  // Visible for testing.
+  void setNextStartFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "Can't restart a running animation");
+    startFromFirstFrame = true;
+    if (pendingTarget != null) {
+      requestManager.clear(pendingTarget);
+      pendingTarget = null;
+    }
+  }
+
+  @VisibleForTesting
+  void setOnEveryFrameReadyListener(@Nullable OnEveryFrameListener onEveryFrameListener) {
+    this.onEveryFrameListener = onEveryFrameListener;
+  }
+
+  @VisibleForTesting
   void onFrameReady(DelayTarget delayTarget) {
+    if (onEveryFrameListener != null) {
+      onEveryFrameListener.onFrameReady();
+    }
+    isLoadPending = false;
     if (isCleared) {
       handler.obtainMessage(FrameLoaderCallback.MSG_CLEAR, delayTarget).sendToTarget();
       return;
     }
+    // If we're not running, notifying here will recycle the frame that we might currently be
+    // showing, which breaks things (see #2526). We also can't discard this frame because we've
+    // already incremented the frame pointer and can't decode the same frame again. Instead we'll
+    // just hang on to this next frame until start() or clear() are called.
+    if (!isRunning) {
+      pendingTarget = delayTarget;
+      return;
+    }
 
     if (delayTarget.getResource() != null) {
       recycleFirstFrame();
@@ -220,13 +281,15 @@ void onFrameReady(DelayTarget delayTarget) {
       }
     }
 
-    isLoadPending = false;
     loadNextFrame();
   }
 
   private class FrameLoaderCallback implements Handler.Callback {
-    public static final int MSG_DELAY = 1;
-    public static final int MSG_CLEAR = 2;
+    static final int MSG_DELAY = 1;
+    static final int MSG_CLEAR = 2;
+
+    @Synthetic
+    FrameLoaderCallback() { }
 
     @Override
     public boolean handleMessage(Message msg) {
@@ -242,10 +305,10 @@ public boolean handleMessage(Message msg) {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static class DelayTarget extends SimpleTarget<Bitmap> {
     private final Handler handler;
-    private final int index;
+    @Synthetic final int index;
     private final long targetTime;
     private Bitmap resource;
 
@@ -260,48 +323,33 @@ Bitmap getResource() {
     }
 
     @Override
-    public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+    public void onResourceReady(@NonNull Bitmap resource,
+        @Nullable Transition<? super Bitmap> transition) {
       this.resource = resource;
       Message msg = handler.obtainMessage(FrameLoaderCallback.MSG_DELAY, this);
       handler.sendMessageAtTime(msg, targetTime);
     }
   }
 
-  private static RequestBuilder<Bitmap> getRequestBuilder(Context context, int width, int height) {
-    return Glide.with(context).asBitmap().apply(
-        diskCacheStrategyOf(DiskCacheStrategy.NONE).skipMemoryCache(true).override(width, height));
+  private static RequestBuilder<Bitmap> getRequestBuilder(
+      RequestManager requestManager, int width, int height) {
+    return requestManager
+        .asBitmap()
+        .apply(
+            diskCacheStrategyOf(DiskCacheStrategy.NONE)
+                .useAnimationPool(true)
+                .skipMemoryCache(true)
+                .override(width, height));
   }
 
-  // Visible for testing.
-  static class FrameSignature implements Key {
-    private final UUID uuid;
-
-    public FrameSignature() {
-      this(UUID.randomUUID());
-    }
-
-    // VisibleForTesting.
-    FrameSignature(UUID uuid) {
-      this.uuid = uuid;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof FrameSignature) {
-        FrameSignature other = (FrameSignature) o;
-        return other.uuid.equals(uuid);
-      }
-      return false;
-    }
-
-    @Override
-    public int hashCode() {
-      return uuid.hashCode();
-    }
+  private static Key getFrameSignature() {
+    // Some devices seem to have crypto bugs that throw exceptions when you create a new UUID.
+    // See #1510.
+    return new ObjectKey(Math.random());
+  }
 
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      throw new UnsupportedOperationException("Not implemented");
-    }
+  @VisibleForTesting
+  interface OnEveryFrameListener {
+    void onFrameReady();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index a644056aa..0fa7e28d5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -21,13 +21,13 @@ public GifFrameResourceDecoder(BitmapPool bitmapPool) {
   }
 
   @Override
-  public boolean handles(GifDecoder source, Options options) {
+  public boolean handles(@NonNull GifDecoder source, @NonNull Options options) {
     return true;
   }
 
   @Override
-  public Resource<Bitmap> decode(GifDecoder source, int width, int height,
-      Options options) {
+  public Resource<Bitmap> decode(@NonNull GifDecoder source, int width, int height,
+      @NonNull Options options) {
     Bitmap bitmap = source.getNextFrame();
     return BitmapResource.obtain(bitmap, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
new file mode 100644
index 000000000..cb2f71e5e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.load.resource.gif;
+
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+
+/**
+ * Options related to decoding GIFs.
+ */
+public final class GifOptions {
+
+  /**
+   * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction
+   * with the particular GIF to determine the {@link android.graphics.Bitmap.Config} to use when
+   * decoding frames of GIFs.
+   */
+  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(
+      "com.bumptech.glide.load.resource.gif.GifOptions.DecodeFormat", DecodeFormat.DEFAULT);
+
+  /**
+   * If set to {@code true}, disables the GIF {@link com.bumptech.glide.load.ResourceDecoder}s
+   * ({@link ResourceDecoder#handles(Object, Options)} will return {@code false}). Defaults to
+   * {@code false}.
+   */
+  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
+      "com.bumptech.glide.load.resource.gif.GifOptions.DisableAnimation", false);
+
+  private GifOptions() {
+    // Utility class.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index bef067093..2cc3b848b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -1,19 +1,19 @@
 package com.bumptech.glide.load.resource.gif;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
-
-import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.List;
 
 /**
  * A relatively inefficient decoder for {@link com.bumptech.glide.load.resource.gif.GifDrawable}
@@ -22,32 +22,27 @@
  */
 public class StreamGifDecoder implements ResourceDecoder<InputStream, GifDrawable> {
   private static final String TAG = "StreamGifDecoder";
-  /**
-   * If set to {@code true}, disables this decoder
-   * ({@link #handles(InputStream, Options)} will return {@code false}). Defaults to
-   * {@code false}.
-   */
-  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
-      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
 
+  private final List<ImageHeaderParser> parsers;
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
-  private final ByteArrayPool byteArrayPool;
+  private final ArrayPool byteArrayPool;
 
-  public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder,
-      ByteArrayPool byteArrayPool) {
+  public StreamGifDecoder(List<ImageHeaderParser> parsers, ResourceDecoder<ByteBuffer,
+      GifDrawable> byteBufferDecoder, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.byteBufferDecoder = byteBufferDecoder;
     this.byteArrayPool = byteArrayPool;
   }
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
-    return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) throws IOException {
+    return !options.get(GifOptions.DISABLE_ANIMATION)
+        && ImageHeaderParserUtils.getType(parsers, source, byteArrayPool) == ImageType.GIF;
   }
 
   @Override
-  public Resource<GifDrawable> decode(InputStream source, int width, int height,
-      Options options) throws IOException {
+  public Resource<GifDrawable> decode(@NonNull InputStream source, int width, int height,
+      @NonNull Options options) throws IOException {
     byte[] data = inputStreamToBytes(source);
     if (data == null) {
       return null;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index af4a0281b..9274b56ff 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -1,10 +1,11 @@
 package com.bumptech.glide.load.resource.transcode;
 
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
-
 import java.io.ByteArrayOutputStream;
 
 /**
@@ -21,13 +22,17 @@ public BitmapBytesTranscoder() {
     this(Bitmap.CompressFormat.JPEG, 100);
   }
 
-  public BitmapBytesTranscoder(Bitmap.CompressFormat compressFormat, int quality) {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapBytesTranscoder(@NonNull Bitmap.CompressFormat compressFormat, int quality) {
     this.compressFormat = compressFormat;
     this.quality = quality;
   }
 
+  @Nullable
   @Override
-  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode) {
+  public Resource<byte[]> transcode(@NonNull Resource<Bitmap> toTranscode,
+      @NonNull Options options) {
     ByteArrayOutputStream os = new ByteArrayOutputStream();
     toTranscode.get().compress(compressFormat, quality, os);
     toTranscode.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
index b3993cbb2..b9dc68bb5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -4,8 +4,9 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
-import com.bumptech.glide.Glide;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.LazyBitmapDrawableResource;
@@ -17,19 +18,30 @@
  */
 public class BitmapDrawableTranscoder implements ResourceTranscoder<Bitmap, BitmapDrawable> {
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
-  public BitmapDrawableTranscoder(Context context) {
-    this(context.getResources(), Glide.get(context).getBitmapPool());
+  // Public API.
+  @SuppressWarnings("unused")
+  public BitmapDrawableTranscoder(@NonNull Context context) {
+    this(context.getResources());
+  }
+
+  /**
+   * @deprecated Use {@link #BitmapDrawableTranscoder(Resources)}, {@code bitmapPool} is unused.
+   */
+  @Deprecated
+  public BitmapDrawableTranscoder(
+      @NonNull Resources resources, @SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this(resources);
   }
 
-  public BitmapDrawableTranscoder(Resources resources, BitmapPool bitmapPool) {
+  public BitmapDrawableTranscoder(@NonNull Resources resources) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
   }
 
+  @Nullable
   @Override
-  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode) {
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, toTranscode.get());
+  public Resource<BitmapDrawable> transcode(@NonNull Resource<Bitmap> toTranscode,
+      @NonNull Options options) {
+    return LazyBitmapDrawableResource.obtain(resources, toTranscode);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
new file mode 100644
index 000000000..a37e16ff6
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide.load.resource.transcode;
+
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+
+/**
+ * Obtains {@code byte[]} from {@link BitmapDrawable}s by delegating to a
+ * {@link ResourceTranscoder} for {@link Bitmap}s to {@code byte[]}s.
+ */
+public final class DrawableBytesTranscoder implements ResourceTranscoder<Drawable, byte[]> {
+  private final BitmapPool bitmapPool;
+  private final ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder;
+  private final ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder;
+
+  public DrawableBytesTranscoder(
+      @NonNull BitmapPool bitmapPool,
+      @NonNull ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder,
+      @NonNull ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder) {
+    this.bitmapPool = bitmapPool;
+    this.bitmapBytesTranscoder = bitmapBytesTranscoder;
+    this.gifDrawableBytesTranscoder = gifDrawableBytesTranscoder;
+  }
+
+  @Nullable
+  @Override
+  public Resource<byte[]> transcode(@NonNull Resource<Drawable> toTranscode,
+      @NonNull Options options) {
+    Drawable drawable = toTranscode.get();
+    if (drawable instanceof BitmapDrawable) {
+      return bitmapBytesTranscoder.transcode(
+          BitmapResource.obtain(((BitmapDrawable) drawable).getBitmap(), bitmapPool), options);
+    } else if (drawable instanceof GifDrawable) {
+      return gifDrawableBytesTranscoder.transcode(toGifDrawableResource(toTranscode), options);
+    }
+    return null;
+  }
+
+  @SuppressWarnings("unchecked")
+  @NonNull
+  private static Resource<GifDrawable> toGifDrawableResource(@NonNull Resource<Drawable> resource) {
+    return (Resource<GifDrawable>) (Resource<?>) resource;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
index 98e3f9790..69e82202d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
@@ -1,10 +1,12 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.nio.ByteBuffer;
 
 /**
@@ -13,8 +15,10 @@
  * the GIF from the {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
 public class GifDrawableBytesTranscoder implements ResourceTranscoder<GifDrawable, byte[]> {
+  @Nullable
   @Override
-  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode) {
+  public Resource<byte[]> transcode(@NonNull Resource<GifDrawable> toTranscode,
+      @NonNull Options options) {
     GifDrawable gifData = toTranscode.get();
     ByteBuffer byteBuffer = gifData.getBuffer();
     return new BytesResource(ByteBufferUtil.toBytes(byteBuffer));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
index e6c965436..fbd4631bd 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -11,9 +14,10 @@
 public interface ResourceTranscoder<Z, R> {
 
   /**
-   * Transcodes the given resource to the new resource type and returns the wew resource.
+   * Transcodes the given resource to the new resource type and returns the new resource.
    *
    * @param toTranscode The resource to transcode.
    */
-  Resource<R> transcode(Resource<Z> toTranscode);
+  @Nullable
+  Resource<R> transcode(@NonNull Resource<Z> toTranscode, @NonNull Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
index c0a0bdb42..9c907b65f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -20,8 +22,9 @@
    * @param <Z>             The type of the resource that the transcoder transcodes from.
    * @param <R>             The type of the resource that the transcoder transcodes to.
    */
-  public synchronized <Z, R> void register(Class<Z> decodedClass, Class<R> transcodedClass,
-      ResourceTranscoder<Z, R> transcoder) {
+  public synchronized <Z, R> void register(
+      @NonNull Class<Z> decodedClass, @NonNull Class<R> transcodedClass,
+      @NonNull ResourceTranscoder<Z, R> transcoder) {
     transcoders.add(new Entry<>(decodedClass, transcodedClass, transcoder));
   }
 
@@ -34,9 +37,10 @@
    * @param <Z>             The type of the resource that the transcoder transcodes from.
    * @param <R>             The type of the resource that the transcoder transcodes to.
    */
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <Z, R> ResourceTranscoder<Z, R> get(Class<Z> resourceClass,
-      Class<R> transcodedClass) {
+  public synchronized <Z, R> ResourceTranscoder<Z, R> get(
+      @NonNull Class<Z> resourceClass, @NonNull Class<R> transcodedClass) {
     // For example, there may be a transcoder that can convert a GifDrawable to a Drawable, which
     // will be caught above. However, if there is no registered transcoder, we can still just use
     // the UnitTranscoder to return the Drawable because the transcode class (Drawable) is
@@ -54,8 +58,9 @@
         "No transcoder registered to transcode from " + resourceClass + " to " + transcodedClass);
   }
 
-  public synchronized <Z, R> List<Class<R>> getTranscodeClasses(Class<Z> resourceClass,
-      Class<R> transcodeClass) {
+  @NonNull
+  public synchronized <Z, R> List<Class<R>> getTranscodeClasses(
+      @NonNull Class<Z> resourceClass, @NonNull Class<R> transcodeClass) {
     List<Class<R>> transcodeClasses = new ArrayList<>();
     // GifDrawable -> Drawable is just the UnitTranscoder, as is GifDrawable -> GifDrawable.
     if (transcodeClass.isAssignableFrom(resourceClass)) {
@@ -75,9 +80,10 @@
   private static final class Entry<Z, R> {
     private final Class<Z> fromClass;
     private final Class<R> toClass;
-    private final ResourceTranscoder<Z, R> transcoder;
+    @Synthetic final ResourceTranscoder<Z, R> transcoder;
 
-    Entry(Class<Z> fromClass, Class<R> toClass, ResourceTranscoder<Z, R> transcoder) {
+    Entry(@NonNull Class<Z> fromClass, @NonNull Class<R> toClass,
+        @NonNull ResourceTranscoder<Z, R> transcoder) {
       this.fromClass = fromClass;
       this.toClass = toClass;
       this.transcoder = transcoder;
@@ -89,7 +95,7 @@
      * we can fulfill requests for a more generic parent class (like Drawable). As a result, we
      * check fromClass and toClass in different orders.
      */
-    public boolean handles(Class<?> fromClass, Class<?> toClass) {
+    public boolean handles(@NonNull Class<?> fromClass, @NonNull Class<?> toClass) {
       return this.fromClass.isAssignableFrom(fromClass) && toClass.isAssignableFrom(this.toClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
index 966e11ecf..45efdf5a1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -8,15 +11,16 @@
  * @param <Z> The type of the resource that will be transcoded from and to.
  */
 public class UnitTranscoder<Z> implements ResourceTranscoder<Z, Z> {
-  private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<Object>();
+  private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<>();
 
   @SuppressWarnings("unchecked")
   public static <Z> ResourceTranscoder<Z, Z> get() {
     return (ResourceTranscoder<Z, Z>) UNIT_TRANSCODER;
   }
 
+  @Nullable
   @Override
-  public Resource<Z> transcode(Resource<Z> toTranscode) {
+  public Resource<Z> transcode(@NonNull Resource<Z> toTranscode, @NonNull Options options) {
     return toTranscode;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index 177165f4e..8bb528050 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.util.Util;
-
 import java.util.Collections;
 import java.util.Set;
 import java.util.WeakHashMap;
@@ -28,7 +28,7 @@
    * avoid adding listeners multiple times. </p>
    */
   @Override
-  public void addListener(LifecycleListener listener) {
+  public void addListener(@NonNull LifecycleListener listener) {
     lifecycleListeners.add(listener);
 
     if (isDestroyed) {
@@ -41,7 +41,7 @@ public void addListener(LifecycleListener listener) {
   }
 
   @Override
-  public void removeListener(LifecycleListener listener) {
+  public void removeListener(@NonNull LifecycleListener listener) {
     lifecycleListeners.remove(listener);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
index 5911d5234..7bf69da7e 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
+
 /**
  * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying
  * listeners of {@link android.app.Application} lifecycle events.
@@ -9,12 +11,12 @@
  */
 class ApplicationLifecycle implements Lifecycle {
   @Override
-  public void addListener(LifecycleListener listener) {
+  public void addListener(@NonNull LifecycleListener listener) {
     listener.onStart();
   }
 
   @Override
-  public void removeListener(LifecycleListener listener) {
+  public void removeListener(@NonNull LifecycleListener listener) {
     // Do nothing.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
index 3b130fd70..b226cd425 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
@@ -1,23 +1,16 @@
 package com.bumptech.glide.manager;
 
 import android.content.Context;
-import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
 
 /**
- * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
- * if the application has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op
- * non functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have
- * the required permission.
+ * A factory class that produces a functional
+ * {@link com.bumptech.glide.manager.ConnectivityMonitor}.
  */
-public class ConnectivityMonitorFactory {
-  public ConnectivityMonitor build(Context context,
-      ConnectivityMonitor.ConnectivityListener listener) {
-    final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
-    final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
-    if (hasPermission) {
-      return new DefaultConnectivityMonitor(context, listener);
-    } else {
-      return new NullConnectivityMonitor();
-    }
-  }
+public interface ConnectivityMonitorFactory {
+
+  @NonNull
+  ConnectivityMonitor build(
+      @NonNull Context context,
+      @NonNull ConnectivityMonitor.ConnectivityListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index 945df9f96..bea4b3673 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -1,31 +1,44 @@
 package com.bumptech.glide.manager;
 
+import android.annotation.SuppressLint;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 
-class DefaultConnectivityMonitor implements ConnectivityMonitor {
+/**
+ * Uses {@link android.net.ConnectivityManager} to identify connectivity changes.
+ */
+final class DefaultConnectivityMonitor implements ConnectivityMonitor {
+  private static final String TAG = "ConnectivityMonitor";
   private final Context context;
-  private final ConnectivityListener listener;
+  @SuppressWarnings("WeakerAccess") @Synthetic final ConnectivityListener listener;
 
-  private boolean isConnected;
+  @SuppressWarnings("WeakerAccess") @Synthetic boolean isConnected;
   private boolean isRegistered;
 
   private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() {
     @Override
-    public void onReceive(Context context, Intent intent) {
+    public void onReceive(@NonNull Context context, Intent intent) {
       boolean wasConnected = isConnected;
       isConnected = isConnected(context);
       if (wasConnected != isConnected) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "connectivity changed, isConnected: " + isConnected);
+        }
+
         listener.onConnectivityChanged(isConnected);
       }
     }
   };
 
-  public DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {
+  DefaultConnectivityMonitor(@NonNull Context context, @NonNull ConnectivityListener listener) {
     this.context = context.getApplicationContext();
     this.listener = listener;
   }
@@ -35,10 +48,19 @@ private void register() {
       return;
     }
 
+    // Initialize isConnected.
     isConnected = isConnected(context);
-    context.registerReceiver(connectivityReceiver,
-        new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
-    isRegistered = true;
+    try {
+      // See #1405
+      context.registerReceiver(connectivityReceiver,
+          new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
+      isRegistered = true;
+    } catch (SecurityException e) {
+      // See #1417, registering the receiver can throw SecurityException.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to register", e);
+      }
+    }
   }
 
   private void unregister() {
@@ -50,10 +72,27 @@ private void unregister() {
     isRegistered = false;
   }
 
-  private boolean isConnected(Context context) {
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  // Permissions are checked in the factory instead.
+  @SuppressLint("MissingPermission")
+  boolean isConnected(@NonNull Context context) {
     ConnectivityManager connectivityManager =
-        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
+        Preconditions.checkNotNull(
+            (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));
+    NetworkInfo networkInfo;
+    try {
+      networkInfo = connectivityManager.getActiveNetworkInfo();
+    } catch (RuntimeException e) {
+      // #1405 shows that this throws a SecurityException.
+      // b/70869360 shows that this throws NullPointerException on APIs 22, 23, and 24.
+      // b/70869360 also shows that this throws RuntimeException on API 24 and 25.
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to determine connectivity status when connectivity changed", e);
+      }
+      // Default to true;
+      return true;
+    }
     return networkInfo != null && networkInfo.isConnected();
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
new file mode 100644
index 000000000..6858eb370
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.manager;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+import android.support.v4.content.ContextCompat;
+import android.util.Log;
+
+/**
+ * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
+ * if the application has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op
+ * non functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have
+ * the required permission.
+ */
+public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory {
+  private static final String TAG = "ConnectivityMonitor";
+  private static final String NETWORK_PERMISSION = "android.permission.ACCESS_NETWORK_STATE";
+
+  @NonNull
+  @Override
+  public ConnectivityMonitor build(
+      @NonNull Context context,
+      @NonNull ConnectivityMonitor.ConnectivityListener listener) {
+    int permissionResult = ContextCompat.checkSelfPermission(context, NETWORK_PERMISSION);
+    boolean hasPermission = permissionResult == PackageManager.PERMISSION_GRANTED;
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(
+          TAG,
+          hasPermission
+              ? "ACCESS_NETWORK_STATE permission granted, registering connectivity monitor"
+              : "ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor");
+    }
+    return hasPermission
+        ? new DefaultConnectivityMonitor(context, listener) : new NullConnectivityMonitor();
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
index 41505a86e..7297680cd 100644
--- a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.RequestManager;
-
 import java.util.Collections;
 import java.util.Set;
 
@@ -9,6 +9,7 @@
  * A {@link RequestManagerTreeNode} that returns no relatives.
  */
 final class EmptyRequestManagerTreeNode implements RequestManagerTreeNode {
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
         return Collections.emptySet();
diff --git a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
index 5a84cd246..434b5dcab 100644
--- a/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
+
 /**
  * An interface for listening to Activity/Fragment lifecycle events.
  */
@@ -7,14 +9,14 @@
   /**
    * Adds the given listener to the set of listeners managed by this Lifecycle implementation.
    */
-  void addListener(LifecycleListener listener);
+  void addListener(@NonNull LifecycleListener listener);
 
   /**
    * Removes the given listener from the set of listeners managed by this Lifecycle implementation,
-   * returning {@code true} if the listener was removed sucessfully, and {@code false} otherwise.
+   * returning {@code true} if the listener was removed successfully, and {@code false} otherwise.
    *
    * <p>This is an optimization only, there is no guarantee that every added listener will
    * eventually be removed.
    */
-  void removeListener(LifecycleListener listener);
+  void removeListener(@NonNull LifecycleListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 1650bf2f2..259cb7a76 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -5,11 +5,13 @@
 import android.app.Activity;
 import android.app.Fragment;
 import android.os.Build;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
-
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -23,26 +25,29 @@
  * @see com.bumptech.glide.manager.RequestManagerRetriever
  * @see com.bumptech.glide.RequestManager
  */
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
+@SuppressWarnings("DeprecatedIsStillUsed")
+@Deprecated
 public class RequestManagerFragment extends Fragment {
   private static final String TAG = "RMFragment";
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new FragmentRequestManagerTreeNode();
-  private final HashSet<RequestManagerFragment> childRequestManagerFragments =
-      new HashSet<>();
+  @SuppressWarnings("deprecation")
+  private final Set<RequestManagerFragment> childRequestManagerFragments = new HashSet<>();
 
   @Nullable private RequestManager requestManager;
-  @Nullable private RequestManagerFragment rootRequestManagerFragment;
+  @SuppressWarnings("deprecation")
+  @Nullable
+  private RequestManagerFragment rootRequestManagerFragment;
   @Nullable private Fragment parentFragmentHint;
 
   public RequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
   }
 
-  // For testing only.
+  @VisibleForTesting
   @SuppressLint("ValidFragment")
-  RequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+  RequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {
     this.lifecycle = lifecycle;
   }
 
@@ -51,11 +56,12 @@ public RequestManagerFragment() {
    *
    * @param requestManager The request manager to use.
    */
-  public void setRequestManager(RequestManager requestManager) {
+  public void setRequestManager(@Nullable RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
-  ActivityFragmentLifecycle getLifecycle() {
+  @NonNull
+  ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
 
@@ -70,14 +76,17 @@ public RequestManager getRequestManager() {
   /**
    * Returns the {@link RequestManagerTreeNode} for this fragment.
    */
+  @NonNull
   public RequestManagerTreeNode getRequestManagerTreeNode() {
     return requestManagerTreeNode;
   }
 
+  @SuppressWarnings("deprecation")
   private void addChildRequestManagerFragment(RequestManagerFragment child) {
     childRequestManagerFragments.add(child);
   }
 
+  @SuppressWarnings("deprecation")
   private void removeChildRequestManagerFragment(RequestManagerFragment child) {
     childRequestManagerFragments.remove(child);
   }
@@ -86,9 +95,12 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
    * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
    * our parent is the fragment that we are annotating).
    */
+  @SuppressWarnings("deprecation")
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
-    if (rootRequestManagerFragment == this) {
+  @Synthetic
+  @NonNull
+  Set<RequestManagerFragment> getDescendantRequestManagerFragments() {
+    if (equals(rootRequestManagerFragment)) {
       return Collections.unmodifiableSet(childRequestManagerFragments);
     } else if (rootRequestManagerFragment == null
         || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
@@ -96,7 +108,7 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
       // so just return an empty set.
       return Collections.emptySet();
     } else {
-      HashSet<RequestManagerFragment> descendants = new HashSet<>();
+      Set<RequestManagerFragment> descendants = new HashSet<>();
       for (RequestManagerFragment fragment : rootRequestManagerFragment
           .getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragment())) {
@@ -111,13 +123,14 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
    * Sets a hint for which fragment is our parent which allows the fragment to return correct
    * information about its parents before pending fragment transactions have been executed.
    */
-  void setParentFragmentHint(Fragment parentFragmentHint) {
+  void setParentFragmentHint(@Nullable Fragment parentFragmentHint) {
     this.parentFragmentHint = parentFragmentHint;
     if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
       registerFragmentWithRoot(parentFragmentHint.getActivity());
     }
   }
 
+  @Nullable
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   private Fragment getParentFragmentUsingHint() {
     final Fragment fragment;
@@ -133,10 +146,11 @@ private Fragment getParentFragmentUsingHint() {
    * Returns true if the fragment is a descendant of our parent.
    */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private boolean isDescendant(Fragment fragment) {
-    Fragment root = this.getParentFragment();
-    while (fragment.getParentFragment() != null) {
-      if (fragment.getParentFragment() == root) {
+  private boolean isDescendant(@NonNull Fragment fragment) {
+    Fragment root = getParentFragment();
+    Fragment parentFragment;
+    while ((parentFragment = fragment.getParentFragment()) != null) {
+      if (parentFragment.equals(root)) {
         return true;
       }
       fragment = fragment.getParentFragment();
@@ -144,11 +158,12 @@ private boolean isDescendant(Fragment fragment) {
     return false;
   }
 
-  private void registerFragmentWithRoot(Activity activity) {
+  @SuppressWarnings("deprecation")
+  private void registerFragmentWithRoot(@NonNull Activity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = RequestManagerRetriever.get()
+    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getRequestManagerFragment(activity.getFragmentManager(), null);
-    if (rootRequestManagerFragment != this) {
+    if (!equals(rootRequestManagerFragment)) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
   }
@@ -160,12 +175,13 @@ private void unregisterFragmentWithRoot() {
     }
   }
 
+  @SuppressWarnings("deprecation")
   @Override
   public void onAttach(Activity activity) {
     super.onAttach(activity);
     try {
       registerFragmentWithRoot(activity);
-    } catch (IllegalArgumentException e) {
+    } catch (IllegalStateException e) {
       // OnAttach can be called after the activity is destroyed, see #497.
       if (Log.isLoggable(TAG, Log.WARN)) {
         Log.w(TAG, "Unable to register fragment with root", e);
@@ -198,34 +214,22 @@ public void onDestroy() {
     unregisterFragmentWithRoot();
   }
 
-  @Override
-  public void onTrimMemory(int level) {
-    // If an activity is re-created, onTrimMemory may be called before a manager is ever put.
-    // See #329.
-    if (requestManager != null) {
-      requestManager.onTrimMemory(level);
-    }
-  }
-
-  @Override
-  public void onLowMemory() {
-    // If an activity is re-created, onLowMemory may be called before a manager is ever put.
-    // See #329.
-    if (requestManager != null) {
-      requestManager.onLowMemory();
-    }
-  }
-
   @Override
   public String toString() {
     return super.toString() + "{parent=" + getParentFragmentUsingHint() + "}";
   }
 
   private class FragmentRequestManagerTreeNode implements RequestManagerTreeNode {
+
+    @Synthetic
+    FragmentRequestManagerTreeNode() { }
+
+    @SuppressWarnings("deprecation")
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
       Set<RequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
-      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      Set<RequestManager> descendants = new HashSet<>(descendantFragments.size());
       for (RequestManagerFragment fragment : descendantFragments) {
         if (fragment.getRequestManager() != null) {
           descendants.add(fragment.getRequestManager());
@@ -234,6 +238,7 @@ public String toString() {
       return descendants;
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public String toString() {
       return super.toString() + "{fragment=" + RequestManagerFragment.this + "}";
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index e46936da8..c6ddb6839 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -6,17 +6,26 @@
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.os.Build;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
+import android.support.v4.util.ArrayMap;
 import android.util.Log;
-
+import android.view.View;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -25,34 +34,34 @@
  * retrieving existing ones from activities and fragment.
  */
 public class RequestManagerRetriever implements Handler.Callback {
-  // Visible for testing.
+  @VisibleForTesting
   static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
   private static final String TAG = "RMRetriever";
 
-  /**
-   * The singleton instance of RequestManagerRetriever.
-   */
-  private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();
-
   private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
   private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
 
+  // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
+  // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
+  private static final String FRAGMENT_INDEX_KEY = "key";
+
   /**
    * The top application level RequestManager.
    */
   private volatile RequestManager applicationManager;
 
-  // Visible for testing.
   /**
    * Pending adds for RequestManagerFragments.
    */
+  @SuppressWarnings("deprecation")
+  @VisibleForTesting
   final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
       new HashMap<>();
 
-  // Visible for testing.
   /**
    * Pending adds for SupportRequestManagerFragments.
    */
+  @VisibleForTesting
   final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
       new HashMap<>();
 
@@ -60,20 +69,20 @@
    * Main thread handler to handle cleaning up pending fragment maps.
    */
   private final Handler handler;
+  private final RequestManagerFactory factory;
 
-  /**
-   * Retrieves and returns the RequestManagerRetriever singleton.
-   */
-  public static RequestManagerRetriever get() {
-    return INSTANCE;
-  }
+  // Objects used to find Fragments and Activities containing views.
+  private final ArrayMap<View, Fragment> tempViewToSupportFragment = new ArrayMap<>();
+  private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
+  private final Bundle tempBundle = new Bundle();
 
-  // Visible for testing.
-  RequestManagerRetriever() {
+  public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
+    this.factory = factory != null ? factory : DEFAULT_FACTORY;
     handler = new Handler(Looper.getMainLooper(), this /* Callback */);
   }
 
-  private RequestManager getApplicationManager(Context context) {
+  @NonNull
+  private RequestManager getApplicationManager(@NonNull Context context) {
     // Either an application context or we're on a background thread.
     if (applicationManager == null) {
       synchronized (this) {
@@ -82,9 +91,15 @@ private RequestManager getApplicationManager(Context context) {
           // activity. However, in this case since the manager attached to the application will not
           // receive lifecycle events, we must force the manager to start resumed using
           // ApplicationLifecycle.
+
+          // TODO(b/27524013): Factor out this Glide.get() call.
+          Glide glide = Glide.get(context.getApplicationContext());
           applicationManager =
-              new RequestManager(context.getApplicationContext(), new ApplicationLifecycle(),
-                  new EmptyRequestManagerTreeNode());
+              factory.build(
+                  glide,
+                  new ApplicationLifecycle(),
+                  new EmptyRequestManagerTreeNode(),
+                  context.getApplicationContext());
         }
       }
     }
@@ -92,7 +107,8 @@ private RequestManager getApplicationManager(Context context) {
     return applicationManager;
   }
 
-  public RequestManager get(Context context) {
+  @NonNull
+  public RequestManager get(@NonNull Context context) {
     if (context == null) {
       throw new IllegalArgumentException("You cannot start a load on a null Context");
     } else if (Util.isOnMainThread() && !(context instanceof Application)) {
@@ -108,21 +124,21 @@ public RequestManager get(Context context) {
     return getApplicationManager(context);
   }
 
-  public RequestManager get(FragmentActivity activity) {
+  @NonNull
+  public RequestManager get(@NonNull FragmentActivity activity) {
     if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
       assertNotDestroyed(activity);
       FragmentManager fm = activity.getSupportFragmentManager();
-      return supportFragmentGet(activity, fm, null);
+      return supportFragmentGet(activity, fm, null /*parentHint*/);
     }
   }
 
-  public RequestManager get(Fragment fragment) {
-    if (fragment.getActivity() == null) {
-      throw new IllegalArgumentException(
-          "You cannot start a load on a fragment before it is attached");
-    }
+  @NonNull
+  public RequestManager get(@NonNull Fragment fragment) {
+    Preconditions.checkNotNull(fragment.getActivity(),
+          "You cannot start a load on a fragment before it is attached or after it is destroyed");
     if (Util.isOnBackgroundThread()) {
       return get(fragment.getActivity().getApplicationContext());
     } else {
@@ -131,26 +147,186 @@ public RequestManager get(Fragment fragment) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  public RequestManager get(Activity activity) {
-    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+  @SuppressWarnings("deprecation")
+  @NonNull
+  public RequestManager get(@NonNull Activity activity) {
+    if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
       assertNotDestroyed(activity);
       android.app.FragmentManager fm = activity.getFragmentManager();
-      return fragmentGet(activity, fm, null);
+      return fragmentGet(activity, fm, null /*parentHint*/);
+    }
+  }
+
+  @SuppressWarnings("deprecation")
+  @NonNull
+  public RequestManager get(@NonNull View view) {
+    if (Util.isOnBackgroundThread()) {
+      return get(view.getContext().getApplicationContext());
+    }
+
+    Preconditions.checkNotNull(view);
+    Preconditions.checkNotNull(view.getContext(),
+        "Unable to obtain a request manager for a view without a Context");
+    Activity activity = findActivity(view.getContext());
+    // The view might be somewhere else, like a service.
+    if (activity == null) {
+      return get(view.getContext().getApplicationContext());
+    }
+
+    // Support Fragments.
+    // Although the user might have non-support Fragments attached to FragmentActivity, searching
+    // for non-support Fragments is so expensive pre O and that should be rare enough that we
+    // prefer to just fall back to the Activity directly.
+    if (activity instanceof FragmentActivity) {
+      Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
+      return fragment != null ? get(fragment) : get(activity);
+    }
+
+    // Standard Fragments.
+    android.app.Fragment fragment = findFragment(view, activity);
+    if (fragment == null) {
+      return get(activity);
+    }
+    return get(fragment);
+  }
+
+  private static void findAllSupportFragmentsWithViews(
+      @Nullable Collection<Fragment> topLevelFragments,
+      @NonNull Map<View, Fragment> result) {
+    if (topLevelFragments == null) {
+      return;
+    }
+    for (Fragment fragment : topLevelFragments) {
+      // getFragment()s in the support FragmentManager may contain null values, see #1991.
+      if (fragment == null || fragment.getView() == null) {
+        continue;
+      }
+      result.put(fragment.getView(), fragment);
+      findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);
+    }
+  }
+
+  @Nullable
+  private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {
+    tempViewToSupportFragment.clear();
+    findAllSupportFragmentsWithViews(
+        activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
+    Fragment result = null;
+    View activityRoot = activity.findViewById(android.R.id.content);
+    View current = target;
+    while (!current.equals(activityRoot)) {
+      result = tempViewToSupportFragment.get(current);
+      if (result != null) {
+        break;
+      }
+      if (current.getParent() instanceof View) {
+        current = (View) current.getParent();
+      } else {
+        break;
+      }
+    }
+
+    tempViewToSupportFragment.clear();
+    return result;
+  }
+
+  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+  @Deprecated
+  @Nullable
+  private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) {
+    tempViewToFragment.clear();
+    findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
+
+    android.app.Fragment result = null;
+
+    View activityRoot = activity.findViewById(android.R.id.content);
+    View current = target;
+    while (!current.equals(activityRoot)) {
+      result = tempViewToFragment.get(current);
+      if (result != null) {
+        break;
+      }
+      if (current.getParent() instanceof View) {
+        current = (View) current.getParent();
+      } else {
+        break;
+      }
+    }
+    tempViewToFragment.clear();
+    return result;
+  }
+
+  // TODO: Consider using an accessor class in the support library package to more directly retrieve
+  // non-support Fragments.
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @TargetApi(Build.VERSION_CODES.O)
+  private void findAllFragmentsWithViews(
+      @NonNull android.app.FragmentManager fragmentManager,
+      @NonNull ArrayMap<View, android.app.Fragment> result) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      for (android.app.Fragment fragment : fragmentManager.getFragments()) {
+        if (fragment.getView() != null) {
+          result.put(fragment.getView(), fragment);
+          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+        }
+      }
+    } else {
+      findAllFragmentsWithViewsPreO(fragmentManager, result);
+    }
+  }
+
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  private void findAllFragmentsWithViewsPreO(
+      @NonNull android.app.FragmentManager fragmentManager,
+      @NonNull ArrayMap<View, android.app.Fragment> result) {
+    int index = 0;
+    while (true) {
+      tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
+      android.app.Fragment fragment = null;
+      try {
+        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_INDEX_KEY);
+      } catch (Exception e) {
+        // This generates log spam from FragmentManager anyway.
+      }
+      if (fragment == null) {
+        break;
+      }
+      if (fragment.getView() != null) {
+        result.put(fragment.getView(), fragment);
+        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) {
+          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+        }
+      }
+    }
+  }
+
+  @Nullable
+  private Activity findActivity(@NonNull Context context) {
+    if (context instanceof Activity) {
+      return (Activity) context;
+    } else if (context instanceof ContextWrapper) {
+      return findActivity(((ContextWrapper) context).getBaseContext());
+    } else {
+      return null;
     }
   }
 
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private static void assertNotDestroyed(Activity activity) {
+  private static void assertNotDestroyed(@NonNull Activity activity) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
       throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
     }
   }
 
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @NonNull
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public RequestManager get(android.app.Fragment fragment) {
+  public RequestManager get(@NonNull android.app.Fragment fragment) {
     if (fragment.getActivity() == null) {
       throw new IllegalArgumentException(
           "You cannot start a load on a fragment before it is attached");
@@ -163,9 +339,11 @@ public RequestManager get(android.app.Fragment fragment) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  @NonNull
   RequestManagerFragment getRequestManagerFragment(
-      final android.app.FragmentManager fm, android.app.Fragment parentHint) {
+      @NonNull final android.app.FragmentManager fm, @Nullable android.app.Fragment parentHint) {
     RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
     if (current == null) {
       current = pendingRequestManagerFragments.get(fm);
@@ -180,21 +358,28 @@ RequestManagerFragment getRequestManagerFragment(
     return current;
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
-      android.app.Fragment parentHint) {
+  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+  @Deprecated
+  @NonNull
+  private RequestManager fragmentGet(@NonNull Context context,
+      @NonNull android.app.FragmentManager fm,
+      @Nullable android.app.Fragment parentHint) {
     RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(
+              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
       current.setRequestManager(requestManager);
     }
     return requestManager;
   }
 
+  @NonNull
   SupportRequestManagerFragment getSupportRequestManagerFragment(
-      final FragmentManager fm, Fragment parentHint) {
+      @NonNull final FragmentManager fm, @Nullable Fragment parentHint) {
     SupportRequestManagerFragment current =
         (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
     if (current == null) {
@@ -210,12 +395,17 @@ SupportRequestManagerFragment getSupportRequestManagerFragment(
     return current;
   }
 
-  RequestManager supportFragmentGet(Context context, FragmentManager fm, Fragment parentHint) {
+  @NonNull
+  private RequestManager supportFragmentGet(@NonNull Context context, @NonNull FragmentManager fm,
+      @Nullable Fragment parentHint) {
     SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(
+              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -239,10 +429,32 @@ public boolean handleMessage(Message message) {
         break;
       default:
         handled = false;
+        break;
     }
     if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
       Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
     }
     return handled;
   }
+
+  /**
+   * Used internally to create {@link RequestManager}s.
+   */
+  public interface RequestManagerFactory {
+    @NonNull
+    RequestManager build(
+        @NonNull Glide glide,
+        @NonNull Lifecycle lifecycle,
+        @NonNull RequestManagerTreeNode requestManagerTreeNode,
+        @NonNull Context context);
+  }
+
+  private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
+    @NonNull
+    @Override
+    public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+        @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) {
+      return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
+    }
+  };
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
index 87f982947..20666d093 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.RequestManager;
-
 import java.util.Set;
 
 /**
@@ -14,5 +14,6 @@
    * Returns all descendant {@link RequestManager}s relative to the context of the current
    * {@link RequestManager}.
    */
+  @NonNull
   Set<RequestManager> getDescendants();
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 48d5882a7..45fa25c17 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -1,8 +1,10 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Util;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -26,8 +28,7 @@
       Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());
   // A set of requests that have not completed and are queued to be run again. We use this list to
   // maintain hard references to these requests to ensure that they are not garbage collected
-  // before
-  // they start running or while they are paused. See #346.
+  // before they start running or while they are paused. See #346.
   @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
   private final List<Request> pendingRequests = new ArrayList<>();
   private boolean isPaused;
@@ -35,7 +36,7 @@
   /**
    * Starts tracking the given request.
    */
-  public void runRequest(Request request) {
+  public void runRequest(@NonNull Request request) {
     requests.add(request);
     if (!isPaused) {
       request.begin();
@@ -44,21 +45,35 @@ public void runRequest(Request request) {
     }
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   void addRequest(Request request) {
     requests.add(request);
   }
 
   /**
    * Stops tracking the given request, clears, and recycles it, and returns {@code true} if the
-   * request was removed or {@code false} if the request was not found.
+   * request was removed or invalid or {@code false} if the request was not found.
    */
-  public boolean clearRemoveAndRecycle(Request request) {
-    boolean isOwnedByUs =
-        request != null && (requests.remove(request) || pendingRequests.remove(request));
+  public boolean clearRemoveAndRecycle(@Nullable Request request) {
+    // It's safe for us to recycle because this is only called when the user is explicitly clearing
+    // a Target so we know that there are no remaining references to the Request.
+    return clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ true);
+  }
+
+  private boolean clearRemoveAndMaybeRecycle(@Nullable Request request, boolean isSafeToRecycle) {
+     if (request == null) {
+       // If the Request is null, the request is already cleared and we don't need to search further
+       // for its owner.
+      return true;
+    }
+    boolean isOwnedByUs = requests.remove(request);
+    // Avoid short circuiting.
+    isOwnedByUs = pendingRequests.remove(request) || isOwnedByUs;
     if (isOwnedByUs) {
       request.clear();
-      request.recycle();
+      if (isSafeToRecycle) {
+        request.recycle();
+      }
     }
     return isOwnedByUs;
   }
@@ -83,6 +98,17 @@ public void pauseRequests() {
     }
   }
 
+  /** Stops any in progress requests and releases bitmaps associated with completed requests. */
+  public void pauseAllRequests() {
+    isPaused = true;
+    for (Request request : Util.getSnapshot(requests)) {
+      if (request.isRunning() || request.isComplete()) {
+        request.pause();
+        pendingRequests.add(request);
+      }
+    }
+  }
+
   /**
    * Starts any not yet completed or failed requests.
    */
@@ -103,7 +129,9 @@ public void resumeRequests() {
    */
   public void clearRequests() {
     for (Request request : Util.getSnapshot(requests)) {
-      clearRemoveAndRecycle(request);
+      // It's unsafe to recycle the Request here because we don't know who might else have a
+      // reference to it.
+      clearRemoveAndMaybeRecycle(request, /*isSafeToRecycle=*/ false);
     }
     pendingRequests.clear();
   }
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index 6fa4b4c41..b6b2f28dc 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -1,14 +1,16 @@
 package com.bumptech.glide.manager;
 
 import android.annotation.SuppressLint;
-import android.app.Activity;
+import android.content.Context;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
-
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -27,8 +29,7 @@
   private final ActivityFragmentLifecycle lifecycle;
   private final RequestManagerTreeNode requestManagerTreeNode =
       new SupportFragmentRequestManagerTreeNode();
-  private final HashSet<SupportRequestManagerFragment> childRequestManagerFragments =
-      new HashSet<>();
+  private final Set<SupportRequestManagerFragment> childRequestManagerFragments = new HashSet<>();
 
   @Nullable private SupportRequestManagerFragment rootRequestManagerFragment;
   @Nullable private RequestManager requestManager;
@@ -38,9 +39,9 @@ public SupportRequestManagerFragment() {
     this(new ActivityFragmentLifecycle());
   }
 
-  // For testing only.
+  @VisibleForTesting
   @SuppressLint("ValidFragment")
-  public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
+  public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {
     this.lifecycle = lifecycle;
   }
 
@@ -49,11 +50,12 @@ public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
    *
    * @param requestManager The manager to put.
    */
-  public void setRequestManager(RequestManager requestManager) {
+  public void setRequestManager(@Nullable RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
-  ActivityFragmentLifecycle getLifecycle() {
+  @NonNull
+  ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
 
@@ -70,6 +72,7 @@ public RequestManager getRequestManager() {
    * to the
    * associated {@link RequestManager}.
    */
+  @NonNull
   public RequestManagerTreeNode getRequestManagerTreeNode() {
     return requestManagerTreeNode;
   }
@@ -86,13 +89,15 @@ private void removeChildRequestManagerFragment(SupportRequestManagerFragment chi
    * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
    * our parent is the fragment that we are annotating).
    */
-  public Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
+  @Synthetic
+  @NonNull
+  Set<SupportRequestManagerFragment> getDescendantRequestManagerFragments() {
     if (rootRequestManagerFragment == null) {
       return Collections.emptySet();
-    } else if (rootRequestManagerFragment == this) {
+    } else if (equals(rootRequestManagerFragment)) {
       return Collections.unmodifiableSet(childRequestManagerFragments);
     } else {
-      HashSet<SupportRequestManagerFragment> descendants = new HashSet<>();
+      Set<SupportRequestManagerFragment> descendants = new HashSet<>();
       for (SupportRequestManagerFragment fragment : rootRequestManagerFragment
           .getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragmentUsingHint())) {
@@ -107,13 +112,14 @@ private void removeChildRequestManagerFragment(SupportRequestManagerFragment chi
    * Sets a hint for which fragment is our parent which allows the fragment to return correct
    * information about its parents before pending fragment transactions have been executed.
    */
-  void setParentFragmentHint(Fragment parentFragmentHint) {
+  void setParentFragmentHint(@Nullable Fragment parentFragmentHint) {
     this.parentFragmentHint = parentFragmentHint;
     if (parentFragmentHint != null && parentFragmentHint.getActivity() != null) {
       registerFragmentWithRoot(parentFragmentHint.getActivity());
     }
   }
 
+  @Nullable
   private Fragment getParentFragmentUsingHint() {
     Fragment fragment = getParentFragment();
     return fragment != null ? fragment : parentFragmentHint;
@@ -122,10 +128,11 @@ private Fragment getParentFragmentUsingHint() {
   /**
    * Returns true if the fragment is a descendant of our parent.
    */
-  private boolean isDescendant(Fragment fragment) {
-    Fragment root = this.getParentFragmentUsingHint();
-    while (fragment.getParentFragment() != null) {
-      if (fragment.getParentFragment() == root) {
+  private boolean isDescendant(@NonNull Fragment fragment) {
+    Fragment root = getParentFragmentUsingHint();
+    Fragment parentFragment;
+    while ((parentFragment = fragment.getParentFragment()) != null) {
+      if (parentFragment.equals(root)) {
         return true;
       }
       fragment = fragment.getParentFragment();
@@ -133,11 +140,11 @@ private boolean isDescendant(Fragment fragment) {
     return false;
   }
 
-  private void registerFragmentWithRoot(FragmentActivity activity) {
+  private void registerFragmentWithRoot(@NonNull FragmentActivity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = RequestManagerRetriever.get()
+    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getSupportRequestManagerFragment(activity.getSupportFragmentManager(), null);
-    if (rootRequestManagerFragment != this) {
+    if (!equals(rootRequestManagerFragment)) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
     }
   }
@@ -150,11 +157,11 @@ private void unregisterFragmentWithRoot() {
   }
 
   @Override
-  public void onAttach(Activity activity) {
-    super.onAttach(activity);
+  public void onAttach(Context context) {
+    super.onAttach(context);
     try {
       registerFragmentWithRoot(getActivity());
-    } catch (IllegalArgumentException e) {
+    } catch (IllegalStateException e) {
       // OnAttach can be called after the activity is destroyed, see #497.
       if (Log.isLoggable(TAG, Log.WARN)) {
         Log.w(TAG, "Unable to register fragment with root", e);
@@ -188,27 +195,22 @@ public void onDestroy() {
     unregisterFragmentWithRoot();
   }
 
-  @Override
-  public void onLowMemory() {
-    super.onLowMemory();
-    // If an activity is re-created, onLowMemory may be called before a manager is ever put.
-    // See #329.
-    if (requestManager != null) {
-      requestManager.onLowMemory();
-    }
-  }
-
   @Override
   public String toString() {
     return super.toString() + "{parent=" + getParentFragmentUsingHint() + "}";
   }
 
   private class SupportFragmentRequestManagerTreeNode implements RequestManagerTreeNode {
+
+    @Synthetic
+    SupportFragmentRequestManagerTreeNode() { }
+
+    @NonNull
     @Override
     public Set<RequestManager> getDescendants() {
       Set<SupportRequestManagerFragment> descendantFragments =
           getDescendantRequestManagerFragments();
-      HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
+      Set<RequestManager> descendants = new HashSet<>(descendantFragments.size());
       for (SupportRequestManagerFragment fragment : descendantFragments) {
         if (fragment.getRequestManager() != null) {
           descendants.add(fragment.getRequestManager());
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
index 6c83dd896..45ad1252a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.manager;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
-
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
@@ -17,11 +16,11 @@
   private final Set<Target<?>> targets =
       Collections.newSetFromMap(new WeakHashMap<Target<?>, Boolean>());
 
-  public void track(Target<?> target) {
+  public void track(@NonNull Target<?> target) {
     targets.add(target);
   }
 
-  public void untrack(Target<?> target) {
+  public void untrack(@NonNull Target<?> target) {
     targets.remove(target);
   }
 
@@ -46,8 +45,9 @@ public void onDestroy() {
     }
   }
 
+  @NonNull
   public List<Target<?>> getAll() {
-    return new ArrayList<>(targets);
+    return Util.getSnapshot(targets);
   }
 
   public void clear() {
diff --git a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
new file mode 100644
index 000000000..77f124670
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
@@ -0,0 +1,43 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.GlideBuilder;
+
+/**
+ * Defines a set of dependencies and options to use when initializing Glide within an application.
+ *
+ * <p>There can be at most one {@link AppGlideModule} in an application. Only Applications
+ * can include a {@link AppGlideModule}. Libraries must use {@link LibraryGlideModule}.
+ *
+ * <p>Classes that extend {@link AppGlideModule} must be annotated with
+ * {@link com.bumptech.glide.annotation.GlideModule} to be processed correctly.
+ *
+ * <p>Classes that extend {@link AppGlideModule} can optionally be annotated with
+ * {@link com.bumptech.glide.annotation.Excludes} to optionally exclude one or more
+ * {@link LibraryGlideModule} and/or {@link GlideModule} classes.
+ *
+ * <p>Once an application has migrated itself and all libraries it depends on to use Glide's
+ * annotation processor, {@link AppGlideModule} implementations should override
+ * {@link #isManifestParsingEnabled()} and return {@code false}.
+ */
+// Used only in javadoc.
+@SuppressWarnings("deprecation")
+public abstract class AppGlideModule extends LibraryGlideModule implements AppliesOptions {
+  /**
+   * Returns {@code true} if Glide should check the AndroidManifest for {@link GlideModule}s.
+   *
+   * <p>Implementations should return {@code false} after they and their dependencies have migrated
+   * to Glide's annotation processor.
+   *
+   * <p>Returns {@code true} by default.
+   */
+  public boolean isManifestParsingEnabled() {
+    return true;
+  }
+
+  @Override
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    // Default empty impl.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
new file mode 100644
index 000000000..c92e0da64
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.GlideBuilder;
+
+/**
+ * An internal interface, to be removed when {@link GlideModule}s are removed.
+ */
+@Deprecated
+interface AppliesOptions {
+  /**
+   * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
+   * singleton is created.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context An Application {@link android.content.Context}.
+   * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
+   */
+  void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder);
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/GlideModule.java b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
index 061856a6c..b8e2108e6 100644
--- a/library/src/main/java/com/bumptech/glide/module/GlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
@@ -1,8 +1,5 @@
 package com.bumptech.glide.module;
 
-import android.content.Context;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 
 /**
@@ -19,7 +16,7 @@
  *                      public class FlickrGlideModule implements GlideModule {
  *                          {@literal @}Override
  *                          public void applyOptions(Context context, GlideBuilder builder) {
- *                              buidler.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);
+ *                              builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);
  *                          }
  *
  *                          {@literal @}Override
@@ -53,28 +50,9 @@
  * applying conflicting settings in different modules. If an application depends on libraries that
  * have conflicting modules, the application should consider avoiding the library modules and
  * instead providing their required dependencies in a single application module. </p>
+ *
+ * @deprecated Libraries should use {@link LibraryGlideModule} and Applications should use
+ * {@link AppGlideModule}.
  */
-public interface GlideModule {
-
-  /**
-   * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
-   * singleton is created.
-   *
-   * <p> This method will be called once and only once per implementation. </p>
-   *
-   * @param context An Application {@link android.content.Context}.
-   * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
-   */
-  void applyOptions(Context context, GlideBuilder builder);
-
-  /**
-   * Lazily register components immediately after the Glide singleton is created but before any
-   * requests can be started.
-   *
-   * <p> This method will be called once and only once per implementation. </p>
-   *
-   * @param context  An Application {@link android.content.Context}.
-   * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
-   */
-  void registerComponents(Context context, Registry registry);
-}
+@Deprecated
+public interface GlideModule extends RegistersComponents, AppliesOptions { }
diff --git a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
new file mode 100644
index 000000000..612dc8c13
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Registry;
+
+/**
+ * Registers a set of components to use when initializing Glide within an app when
+ * Glide's annotation processor is used.
+ *
+ * <p>Any number of LibraryGlideModules can be contained within any library or application.
+ *
+ * <p>LibraryGlideModules are called in no defined order. If LibraryGlideModules within an
+ * application conflict, {@link AppGlideModule}s can use the
+ * {@link com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of
+ * the conflicting modules.
+ */
+@SuppressWarnings("deprecation")
+public abstract class LibraryGlideModule implements RegistersComponents {
+  @Override
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    // Default empty impl.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index 7d9a755e5..6304f179a 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -3,14 +3,19 @@
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
-
+import android.util.Log;
+import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
  */
+// Used only in javadoc.
+@SuppressWarnings("deprecation")
+@Deprecated
 public final class ManifestParser {
+  private static final String TAG = "ManifestParser";
   private static final String GLIDE_MODULE_VALUE = "GlideModule";
 
   private final Context context;
@@ -19,25 +24,43 @@ public ManifestParser(Context context) {
     this.context = context;
   }
 
+  @SuppressWarnings("deprecation")
   public List<GlideModule> parse() {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Loading Glide modules");
+    }
     List<GlideModule> modules = new ArrayList<>();
     try {
       ApplicationInfo appInfo = context.getPackageManager()
           .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
-      if (appInfo.metaData != null) {
-        for (String key : appInfo.metaData.keySet()) {
-          if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
-            modules.add(parseModule(key));
+      if (appInfo.metaData == null) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Got null app info metadata");
+        }
+        return modules;
+      }
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Got app info metadata: " + appInfo.metaData);
+      }
+      for (String key : appInfo.metaData.keySet()) {
+        if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
+          modules.add(parseModule(key));
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Loaded Glide module: " + key);
           }
         }
       }
     } catch (PackageManager.NameNotFoundException e) {
       throw new RuntimeException("Unable to find metadata to parse GlideModules", e);
     }
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Finished loading Glide modules");
+    }
 
     return modules;
   }
 
+  @SuppressWarnings("deprecation")
   private static GlideModule parseModule(String className) {
     Class<?> clazz;
     try {
@@ -46,12 +69,18 @@ private static GlideModule parseModule(String className) {
       throw new IllegalArgumentException("Unable to find GlideModule implementation", e);
     }
 
-    Object module;
+    Object module = null;
     try {
-      module = clazz.newInstance();
-    } catch (InstantiationException | IllegalAccessException e) {
-      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-          e);
+      module = clazz.getDeclaredConstructor().newInstance();
+    // These can't be combined until API minimum is 19.
+    } catch (InstantiationException e) {
+      throwInstantiateGlideModuleException(clazz, e);
+    } catch (IllegalAccessException e) {
+      throwInstantiateGlideModuleException(clazz, e);
+    } catch (NoSuchMethodException e) {
+      throwInstantiateGlideModuleException(clazz, e);
+    } catch (InvocationTargetException e) {
+      throwInstantiateGlideModuleException(clazz, e);
     }
 
     if (!(module instanceof GlideModule)) {
@@ -59,4 +88,8 @@ private static GlideModule parseModule(String className) {
     }
     return (GlideModule) module;
   }
+
+  private static void throwInstantiateGlideModuleException(Class<?> clazz, Exception e) {
+    throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz, e);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
new file mode 100644
index 000000000..9461ee341
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
@@ -0,0 +1,28 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Registry;
+
+/**
+ * An internal interface, to be removed when {@link GlideModule}s are removed.
+ */
+// Used only in javadocs.
+@SuppressWarnings("deprecation")
+@Deprecated
+interface RegistersComponents {
+
+  /**
+   * Lazily register components immediately after the Glide singleton is created but before any
+   * requests can be started.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context  An Application {@link android.content.Context}.
+   * @param glide The Glide singleton that is in the process of being initialized.
+   * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
+   */
+  void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry);
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
index 915bd0024..ca5148a0f 100644
--- a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -1,14 +1,14 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Encoder;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Contains an unordered list of {@link Encoder}s capable of encoding arbitrary data types.
+ * Contains an ordered list of {@link Encoder}s capable of encoding arbitrary data types.
  */
 public class EncoderRegistry {
   // TODO: This registry should probably contain a put, rather than a list.
@@ -16,7 +16,7 @@
 
   @SuppressWarnings("unchecked")
   @Nullable
-  public synchronized <T> Encoder<T> getEncoder(Class<T> dataClass) {
+  public synchronized <T> Encoder<T> getEncoder(@NonNull Class<T> dataClass) {
     for (Entry<?> entry : encoders) {
       if (entry.handles(dataClass)) {
         return (Encoder<T>) entry.encoder;
@@ -25,20 +25,24 @@
     return null;
   }
 
-  public synchronized <T> void add(Class<T> dataClass, Encoder<T> encoder) {
+  public synchronized <T> void append(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
     encoders.add(new Entry<>(dataClass, encoder));
   }
 
+  public synchronized <T> void prepend(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
+    encoders.add(0, new Entry<>(dataClass, encoder));
+  }
+
   private static final class Entry<T> {
     private final Class<T> dataClass;
-    private final Encoder<T> encoder;
+    @Synthetic @SuppressWarnings("WeakerAccess") final Encoder<T> encoder;
 
-    public Entry(Class<T> dataClass, Encoder<T> encoder) {
+    Entry(@NonNull Class<T> dataClass, @NonNull Encoder<T> encoder) {
       this.dataClass = dataClass;
       this.encoder = encoder;
     }
 
-    public boolean handles(Class<?> dataClass) {
+    boolean handles(@NonNull Class<?> dataClass) {
       return this.dataClass.isAssignableFrom(dataClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
new file mode 100644
index 000000000..902fc1bd4
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.provider;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.ImageHeaderParser;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains an unordered list of {@link ImageHeaderParser}s capable of parsing image headers.
+ */
+public final class ImageHeaderParserRegistry {
+  private final List<ImageHeaderParser> parsers = new ArrayList<>();
+
+  @NonNull
+  public synchronized List<ImageHeaderParser> getParsers() {
+    return parsers;
+  }
+
+  public synchronized void add(@NonNull ImageHeaderParser parser) {
+    parsers.add(parser);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
index f9c68b34a..89d2525af 100644
--- a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
@@ -2,10 +2,12 @@
 
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
-
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.DecodePath;
 import com.bumptech.glide.load.engine.LoadPath;
+import com.bumptech.glide.load.resource.transcode.UnitTranscoder;
 import com.bumptech.glide.util.MultiClassKey;
-
+import java.util.Collections;
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
@@ -13,19 +15,38 @@
  * {@link com.bumptech.glide.load.engine.LoadPath}s capable of decoding with the requested types.
  */
 public class LoadPathCache {
+  private static final LoadPath<?, ?, ?> NO_PATHS_SIGNAL =
+      new LoadPath<>(
+          Object.class,
+          Object.class,
+          Object.class,
+          Collections.singletonList(
+              new DecodePath<>(
+                  Object.class,
+                  Object.class,
+                  Object.class,
+                  Collections.<ResourceDecoder<Object, Object>>emptyList(),
+                  new UnitTranscoder<>(),
+                  /*listPool=*/ null)),
+          /*listPool=*/ null);
+
   private final ArrayMap<MultiClassKey, LoadPath<?, ?, ?>> cache = new ArrayMap<>();
   private final AtomicReference<MultiClassKey> keyRef = new AtomicReference<>();
 
-  public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass) {
-    MultiClassKey key = getKey(dataClass, resourceClass, transcodeClass);
-    boolean result;
-    synchronized (cache) {
-      result = cache.containsKey(key);
-    }
-    keyRef.set(key);
-    return result;
+  /**
+   * Returns {@code} true if the given {@link LoadPath} is the signal object returned from
+   * {@link #get(Class, Class, Class)} that indicates that we've previously found that there are
+   * no available paths to load the requested resources and {@code false} otherwise.
+   */
+  public boolean isEmptyLoadPath(@Nullable LoadPath<?, ?, ?> path) {
+    return NO_PATHS_SIGNAL.equals(path);
   }
 
+  /**
+   * May return {@link #NO_PATHS_SIGNAL} to indicate that we've previously found that there are 0
+   * available load paths for the requested types. Callers must check using
+   * {@link #isEmptyLoadPath(LoadPath)} before using any load path returned by this method.
+   */
   @SuppressWarnings("unchecked")
   @Nullable
   public <Data, TResource, Transcode> LoadPath<Data, TResource, Transcode> get(
@@ -40,10 +61,14 @@ public boolean contains(Class<?> dataClass, Class<?> resourceClass, Class<?> tra
     return (LoadPath<Data, TResource, Transcode>) result;
   }
 
-  public void put(Class<?> dataClass, Class<?> resourceClass, Class<?> transcodeClass,
-      LoadPath<?, ?, ?> loadPath) {
+  public void put(
+      Class<?> dataClass, Class<?> resourceClass,
+      Class<?> transcodeClass,
+      @Nullable LoadPath<?, ?, ?> loadPath) {
     synchronized (cache) {
-      cache.put(new MultiClassKey(dataClass, resourceClass, transcodeClass), loadPath);
+      cache.put(
+          new MultiClassKey(dataClass, resourceClass, transcodeClass),
+          loadPath != null ? loadPath : NO_PATHS_SIGNAL);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
index 01e771d7d..ac417c13f 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
@@ -1,10 +1,9 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
-
 import com.bumptech.glide.util.MultiClassKey;
-
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -18,7 +17,7 @@
       new ArrayMap<>();
 
   @Nullable
-  public List<Class<?>> get(Class<?> modelClass, Class<?> resourceClass) {
+  public List<Class<?>> get(@NonNull Class<?> modelClass, @NonNull Class<?> resourceClass) {
     MultiClassKey key = resourceClassKeyRef.getAndSet(null);
     if (key == null) {
       key = new MultiClassKey(modelClass, resourceClass);
@@ -27,13 +26,14 @@
     }
     final List<Class<?>> result;
     synchronized (registeredResourceClassCache) {
-       result = registeredResourceClassCache.get(key);
+      result = registeredResourceClassCache.get(key);
     }
     resourceClassKeyRef.set(key);
     return result;
   }
 
-  public void put(Class<?> modelClass, Class<?> resourceClass, List<Class<?>> resourceClasses) {
+  public void put(@NonNull Class<?> modelClass, @NonNull Class<?> resourceClass,
+      @NonNull List<Class<?>> resourceClasses) {
     synchronized (registeredResourceClassCache) {
       registeredResourceClassCache
           .put(new MultiClassKey(modelClass, resourceClass), resourceClasses);
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
index b56158351..bc3ce0d93 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
@@ -1,25 +1,49 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.ResourceDecoder;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Contains an ordered list of {@link ResourceDecoder}s capable of decoding arbitrary data types
- * into arbitrary resource types from highest priority decoders to loweset priority decoders.
+ * into arbitrary resource types from highest priority decoders to lowest priority decoders.
  */
 @SuppressWarnings("rawtypes")
 public class ResourceDecoderRegistry {
-  private final List<Entry<?, ?>> decoders = new ArrayList<>();
+  private final List<String> bucketPriorityList = new ArrayList<>();
+  private final Map<String, List<Entry<?, ?>>> decoders = new HashMap<>();
+
+  public synchronized void setBucketPriorityList(@NonNull List<String> buckets) {
+    List<String> previousBuckets = new ArrayList<>(bucketPriorityList);
+    bucketPriorityList.clear();
+    bucketPriorityList.addAll(buckets);
+    for (String previousBucket : previousBuckets) {
+      if (!buckets.contains(previousBucket)) {
+        // Keep any buckets from the previous list that aren't included here, but but them at the
+        // end.
+        bucketPriorityList.add(previousBucket);
+      }
+    }
+  }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(Class<T> dataClass,
-      Class<R> resourceClass) {
+  public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(@NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     List<ResourceDecoder<T, R>> result = new ArrayList<>();
-    for (Entry<?, ?> entry : decoders) {
-      if (entry.handles(dataClass, resourceClass)) {
-        result.add((ResourceDecoder<T, R>) entry.decoder);
+    for (String bucket : bucketPriorityList) {
+      List<Entry<?, ?>> entries = decoders.get(bucket);
+      if (entries == null) {
+        continue;
+      }
+      for (Entry<?, ?> entry : entries) {
+        if (entry.handles(dataClass, resourceClass)) {
+          result.add((ResourceDecoder<T, R>) entry.decoder);
+        }
       }
     }
     // TODO: cache result list.
@@ -27,40 +51,65 @@
     return result;
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
-  public synchronized <T, R> List<Class<R>> getResourceClasses(Class<T> dataClass,
-      Class<R> resourceClass) {
+  public synchronized <T, R> List<Class<R>> getResourceClasses(@NonNull Class<T> dataClass,
+      @NonNull Class<R> resourceClass) {
     List<Class<R>> result = new ArrayList<>();
-    for (Entry<?, ?> entry : decoders) {
-      if (entry.handles(dataClass, resourceClass)) {
-        result.add((Class<R>) entry.resourceClass);
+    for (String bucket : bucketPriorityList) {
+      List<Entry<?, ?>> entries = decoders.get(bucket);
+      if (entries == null) {
+        continue;
+      }
+      for (Entry<?, ?> entry : entries) {
+        if (entry.handles(dataClass, resourceClass)
+            && !result.contains((Class<R>) entry.resourceClass)) {
+          result.add((Class<R>) entry.resourceClass);
+        }
       }
     }
     return result;
   }
 
-  public synchronized <T, R> void append(ResourceDecoder<T, R> decoder, Class<T> dataClass,
-      Class<R> resourceClass) {
-    decoders.add(new Entry<>(dataClass, resourceClass, decoder));
+  public synchronized <T, R> void append(@NonNull String bucket,
+      @NonNull ResourceDecoder<T, R> decoder,
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
+    getOrAddEntryList(bucket).add(new Entry<>(dataClass, resourceClass, decoder));
+  }
+
+  public synchronized <T, R> void prepend(@NonNull String bucket,
+      @NonNull ResourceDecoder<T, R> decoder,
+      @NonNull Class<T> dataClass, @NonNull Class<R> resourceClass) {
+    getOrAddEntryList(bucket).add(0, new Entry<>(dataClass, resourceClass, decoder));
   }
 
-  public synchronized <T, R> void prepend(ResourceDecoder<T, R> decoder, Class<T> dataClass,
-      Class<R> resourceClass) {
-    decoders.add(0, new Entry<>(dataClass, resourceClass, decoder));
+  @NonNull
+  private synchronized List<Entry<?, ?>> getOrAddEntryList(@NonNull String bucket) {
+    if (!bucketPriorityList.contains(bucket)) {
+      // Add this unspecified bucket as a low priority bucket.
+      bucketPriorityList.add(bucket);
+    }
+    List<Entry<?, ?>> entries = decoders.get(bucket);
+    if (entries == null) {
+      entries = new ArrayList<>();
+      decoders.put(bucket, entries);
+    }
+    return entries;
   }
 
   private static class Entry<T, R> {
     private final Class<T> dataClass;
-    private final Class<R> resourceClass;
-    private final ResourceDecoder<T, R> decoder;
+    @Synthetic final Class<R> resourceClass;
+    @Synthetic final ResourceDecoder<T, R> decoder;
 
-    public Entry(Class<T> dataClass, Class<R> resourceClass, ResourceDecoder<T, R> decoder) {
+    public Entry(@NonNull Class<T> dataClass, @NonNull Class<R> resourceClass,
+        ResourceDecoder<T, R> decoder) {
       this.dataClass = dataClass;
       this.resourceClass = resourceClass;
       this.decoder = decoder;
     }
 
-    public boolean handles(Class<?> dataClass, Class<?> resourceClass) {
+    public boolean handles(@NonNull Class<?> dataClass, @NonNull Class<?> resourceClass) {
       return this.dataClass.isAssignableFrom(dataClass) && resourceClass
           .isAssignableFrom(this.resourceClass);
     }
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
index e5f5ef9c7..b1bd2977a 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -1,29 +1,35 @@
 package com.bumptech.glide.provider;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.ResourceEncoder;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Contains an unordered list of {@link ResourceEncoder}s capable of encoding arbitrary resource
+ * Contains an ordered list of {@link ResourceEncoder}s capable of encoding arbitrary resource
  * types.
  */
 public class ResourceEncoderRegistry {
   // TODO: this should probably be a put.
-  final List<Entry<?>> encoders = new ArrayList<>();
+  private final List<Entry<?>> encoders = new ArrayList<>();
 
-  public synchronized <Z> void add(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void append(@NonNull Class<Z> resourceClass,
+      @NonNull ResourceEncoder<Z> encoder) {
     encoders.add(new Entry<>(resourceClass, encoder));
   }
 
+  public synchronized <Z> void prepend(@NonNull Class<Z> resourceClass,
+      @NonNull ResourceEncoder<Z> encoder) {
+    encoders.add(0, new Entry<>(resourceClass, encoder));
+  }
+
   @SuppressWarnings("unchecked")
   @Nullable
-  public synchronized <Z> ResourceEncoder<Z> get(Class<Z> resourceClass) {
-    int size = encoders.size();
-    for (int i = 0; i < size; i++) {
+  public synchronized <Z> ResourceEncoder<Z> get(@NonNull Class<Z> resourceClass) {
+    //noinspection ForLoopReplaceableByForEach to improve perf
+    for (int i = 0, size = encoders.size(); i < size; i++) {
       Entry<?> entry = encoders.get(i);
       if (entry.handles(resourceClass)) {
         return (ResourceEncoder<Z>) entry.encoder;
@@ -35,14 +41,15 @@
 
   private static final class Entry<T> {
     private final Class<T> resourceClass;
-    private final ResourceEncoder<T> encoder;
+    @Synthetic final ResourceEncoder<T> encoder;
 
-    Entry(Class<T> resourceClass, ResourceEncoder<T> encoder) {
+    Entry(@NonNull Class<T> resourceClass, @NonNull ResourceEncoder<T> encoder) {
       this.resourceClass = resourceClass;
       this.encoder = encoder;
     }
 
-    private boolean handles(Class<?> resourceClass) {
+    @Synthetic
+    boolean handles(@NonNull Class<?> resourceClass) {
       return this.resourceClass.isAssignableFrom(resourceClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
deleted file mode 100644
index dbb9b2097..000000000
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ /dev/null
@@ -1,867 +0,0 @@
-package com.bumptech.glide.request;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
-import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.CircleCrop;
-import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
-import com.bumptech.glide.load.resource.bitmap.Downsampler;
-import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
-import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
-import com.bumptech.glide.signature.EmptySignature;
-import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Contains and exposes a variety of non type specific options that can be applied to a load in
- * Glide.
- *
- * <p> If {@link #lock()} has been called, this class will throw if any further mutations are
- * attempted. To unlock, use {@link #clone()}. </p>
- *
- * @param <CHILD> The concrete and <em>final</em> subclass.
- */
-public abstract class BaseRequestOptions<CHILD extends BaseRequestOptions<CHILD>>
-    implements Cloneable {
-  private static final int UNSET = -1;
-  private static final int SIZE_MULTIPLIER = 1 << 1;
-  private static final int DISK_CACHE_STRATEGY = 1 << 2;
-  private static final int PRIORITY = 1 << 3;
-  private static final int ERROR_PLACEHOLDER = 1 << 4;
-  private static final int ERROR_ID = 1 << 5;
-  private static final int PLACEHOLDER = 1 << 6;
-  private static final int PLACEHOLDER_ID = 1 << 7;
-  private static final int IS_CACHEABLE = 1 << 8;
-  private static final int OVERRIDE = 1 << 9;
-  private static final int SIGNATURE = 1 << 10;
-  private static final int TRANSFORMATION = 1 << 11;
-  private static final int RESOURCE_CLASS = 1 << 12;
-  private static final int FALLBACK = 1 << 13;
-  private static final int FALLBACK_ID = 1 << 14;
-  private static final int THEME = 1 << 15;
-
-  private int fields;
-
-  private float sizeMultiplier = 1f;
-  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
-  private Priority priority = Priority.NORMAL;
-  private Drawable errorPlaceholder;
-  private int errorId;
-  private Drawable placeholderDrawable;
-  private int placeholderId;
-  private boolean isCacheable = true;
-  private int overrideHeight = UNSET;
-  private int overrideWidth = UNSET;
-  private Key signature = EmptySignature.obtain();
-  private boolean isTransformationRequired;
-  private Drawable fallbackDrawable;
-  private int fallbackId;
-
-  private Options options = new Options();
-  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-  private Class<?> resourceClass = Object.class;
-  private boolean isLocked;
-  private Resources.Theme theme;
-  private boolean isAutoCloneEnabled;
-
-  /**
-   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
-   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
-   * (particularly {@link android.graphics.Bitmap}s on devices with overly dense screens.
-   *
-   * @param sizeMultiplier The multiplier to apply to the
-   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
-   *                       loading the resource.
-   * @return This request builder.
-   */
-  public final CHILD sizeMultiplier(float sizeMultiplier) {
-    if (isAutoCloneEnabled) {
-      return clone().sizeMultiplier(sizeMultiplier);
-    }
-
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-    }
-    this.sizeMultiplier = sizeMultiplier;
-    fields |= SIZE_MULTIPLIER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load.
-   *
-   * <p> Defaults to {@link com.bumptech.glide.load.engine.DiskCacheStrategy#AUTOMATIC}. </p>
-   *
-   * <p> For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} is
-   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
-   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#DATA} or
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}. </p>
-   *
-   * @param strategy The strategy to use.
-   * @return This request builder.
-   */
-  public final CHILD diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
-    if (isAutoCloneEnabled) {
-      return clone().diskCacheStrategy(strategy);
-    }
-    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
-    fields |= DISK_CACHE_STRATEGY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the priority for this load.
-   *
-   * @param priority A priority.
-   * @return This request builder.
-   */
-  public final CHILD priority(@NonNull Priority priority) {
-    if (isAutoCloneEnabled) {
-      return clone().priority(priority);
-    }
-
-    this.priority = Preconditions.checkNotNull(priority);
-    fields |= PRIORITY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD placeholder(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(drawable);
-    }
-
-    this.placeholderDrawable = drawable;
-    fields |= PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resource to
-   * display while a resource is loading.
-   *
-   * @param resourceId The id of the resource to use as a placeholder
-   * @return This request builder.
-   */
-  public final CHILD placeholder(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(resourceId);
-    }
-
-    this.placeholderId = resourceId;
-    fields |= PLACEHOLDER_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
-   * error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD fallback(Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(drawable);
-    }
-
-    this.fallbackDrawable = drawable;
-    fields |= FALLBACK;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
-   * the error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param resourceId The id of the resource to use as a fallback.
-   * @return This request builder.
-   */
-  public final CHILD fallback(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(resourceId);
-    }
-
-    this.fallbackId = resourceId;
-    fields |= FALLBACK_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a {@link Drawable} to display if a load fails.
-   *
-   * @param drawable The drawable to display.
-   * @return This request builder.
-   */
-  public final CHILD error(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().error(drawable);
-    }
-
-    this.errorPlaceholder = drawable;
-    fields |= ERROR_PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if a load fails.
-   *
-   * @param resourceId The id of the resource to use as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD error(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().error(resourceId);
-    }
-    this.errorId = resourceId;
-    fields |= ERROR_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
-   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
-   * {@link #fallback(Drawable)}.
-   *
-   * @param theme The theme to use when loading Drawables.
-   * @return this request builder.
-   */
-  public final CHILD theme(Resources.Theme theme) {
-    if (isAutoCloneEnabled) {
-      return clone().theme(theme);
-    }
-
-    this.theme = theme;
-    fields |= THEME;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Allows the loaded resource to skip the memory cache.
-   *
-   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
-   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
-   *
-   * @param skip True to allow the resource to skip the memory cache.
-   * @return This request builder.
-   */
-  public final CHILD skipMemoryCache(boolean skip) {
-    if (isAutoCloneEnabled) {
-      return clone().skipMemoryCache(true);
-    }
-
-    this.isCacheable = !skip;
-    fields |= IS_CACHEABLE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given values. This is useful for thumbnails, and should only be used for other cases when you
-   * need a very specific image size.
-   *
-   * @param width  The width in pixels to use to load the resource.
-   * @param height The height in pixels to use to load the resource.
-   * @return This request builder.
-   */
-  public final CHILD override(int width, int height) {
-    if (isAutoCloneEnabled) {
-      return clone().override(width, height);
-    }
-
-    this.overrideWidth = width;
-    this.overrideHeight = height;
-    fields |= OVERRIDE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given size.
-   *
-   * @see #override(int, int)
-   * @param size The width and height to use.
-   * @return This request builder.
-   */
-  public final CHILD override(int size) {
-    return override(size, size);
-  }
-
-  /**
-   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
-   * more control over when cached data is invalidated.
-   *
-   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
-   *
-   * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current
-   *                  state of the model that will be mixed in to the cache key.
-   * @return This request builder.
-   * @see com.bumptech.glide.signature.StringSignature
-   */
-  public final CHILD signature(@NonNull Key signature) {
-    if (isAutoCloneEnabled) {
-      return clone().signature(signature);
-    }
-
-    this.signature = Preconditions.checkNotNull(signature);
-    fields |= SIGNATURE;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   *
-   * <p> Even if this object was locked, the cloned object returned from this method will not be
-   * locked. </p>
-   */
-  @SuppressWarnings("unchecked")
-  @Override
-  public final CHILD clone() {
-    try {
-      BaseRequestOptions<CHILD> result = (BaseRequestOptions<CHILD>) super.clone();
-      result.options = new Options();
-      result.options.putAll(options);
-      result.transformations = new HashMap<>();
-      result.transformations.putAll(transformations);
-      result.isLocked = false;
-      result.isAutoCloneEnabled = false;
-      return (CHILD) result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public final <T> CHILD set(@NonNull Option<T> option, @NonNull T value) {
-    if (isAutoCloneEnabled) {
-      return clone().set(option, value);
-    }
-
-    Preconditions.checkNotNull(option);
-    Preconditions.checkNotNull(value);
-    options.set(option, value);
-    return selfOrThrowIfLocked();
-  }
-
-  public final CHILD decode(@NonNull Class<?> resourceClass) {
-    if (isAutoCloneEnabled) {
-      return clone().decode(resourceClass);
-    }
-
-    this.resourceClass = Preconditions.checkNotNull(resourceClass);
-    fields |= RESOURCE_CLASS;
-    return selfOrThrowIfLocked();
-  }
-
-  public final boolean isTransformationSet() {
-    return isSet(TRANSFORMATION);
-  }
-
-  public final boolean isLocked() {
-    return isLocked;
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
-   */
-  public CHILD encodeFormat(@NonNull Bitmap.CompressFormat format) {
-    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_QUALITY}.
-   */
-  public CHILD encodeQuality(int quality) {
-    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
-  }
-
-  /**
-   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
-   * {@link Downsampler}.
-   *
-   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
-   * decoded using a decoder that cannot control the format
-   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
-   * ignore the requested format if it can't display the image (ie RGB_565 is requested, but the
-   * image has alpha).
-   */
-  public CHILD format(@NonNull DecodeFormat format) {
-    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the time position of the frame to extract from a video.
-   *
-   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
-   *                        Android framework implementation return a representative frame.
-   */
-  public CHILD frame(long frameTimeMicros) {
-    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
-  }
-
-  /**
-   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
-   * {@link Downsampler}.
-   */
-  public CHILD downsample(@NonNull DownsampleStrategy strategy) {
-    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
-   * ignores unknown types.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerCrop(android.content.Context)
-   */
-  public CHILD optionalCenterCrop(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalCenterCrop(android.content.Context)
-   */
-  public CHILD centerCrop(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
-   * ignores unknown types.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #fitCenter(android.content.Context)
-   */
-  public CHILD optionalFitCenter(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalFitCenter(android.content.Context)
-   */
-  public CHILD fitCenter(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
-   *
-   * @param context Any {@link Context}.
-   * @see #optionalTransform(Context, Transformation)
-   * @see #circleCrop(Context)
-   */
-  public CHILD optionalCircleCrop(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
-   * an unknown type.
-   *
-   * @param context Any {@link Context}.
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterCrop(Context)
-   */
-  public CHILD circleCrop(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));
-  }
-
-  final CHILD optionalTransform(Context context, DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(context, downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return optionalTransform(context, transformation);
-  }
-
-  final CHILD transform(Context context, DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(context, downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return transform(context, transformation);
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
-   *
-   * @param context        Any {@link android.content.Context}.
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #optionalTransform(android.content.Context, com.bumptech.glide.load.Transformation)
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public CHILD transform(Context context, @NonNull Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(context, transformation);
-    }
-
-    optionalTransform(context, transformation);
-    isTransformationRequired = true;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
-   *
-   * @param context        Any {@link android.content.Context}.
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #transform(android.content.Context, com.bumptech.glide.load.Transformation)
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public CHILD optionalTransform(Context context, Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(context, transformation);
-    }
-
-    optionalTransform(Bitmap.class, transformation);
-    // TODO: remove BitmapDrawable decoder and this transformation.
-    optionalTransform(BitmapDrawable.class,
-        new BitmapDrawableTransformation(context, transformation));
-    optionalTransform(GifDrawable.class, new GifDrawableTransformation(context, transformation));
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and allows unknown resource types to be ignored.
-   *
-   * <p> Users can apply different transformations for each resource class. Applying a
-   * {@link com.bumptech.glide.load.Transformation} for a resource type that already has a
-   * {@link com.bumptech.glide.load.Transformation} will override the previous call. </p>
-   *
-   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
-   * an unknown resource class will throw an exception. To allow unknown types, users must always
-   * call the optional version of each method. </p>
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   */
-  public final <T> CHILD optionalTransform(Class<T> resourceClass,
-      Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(resourceClass, transformation);
-    }
-
-    Preconditions.checkNotNull(resourceClass);
-    Preconditions.checkNotNull(transformation);
-    fields |= TRANSFORMATION;
-    transformations.put(resourceClass, transformation);
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and throws if asked to transform an unknown resource type.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public final <T> CHILD transform(Class<T> resourceClass, Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(resourceClass, transformation);
-    }
-
-    optionalTransform(resourceClass, transformation);
-    isTransformationRequired = true;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Removes all applied {@link com.bumptech.glide.load.Transformation Transformations} for all
-   * resource classes and allows unknown resource types to be transformed without throwing an
-   * exception.
-   */
-  public final CHILD dontTransform() {
-    if (isAutoCloneEnabled) {
-      return clone().dontTransform();
-    }
-
-    fields &= ~TRANSFORMATION;
-    transformations.clear();
-    isTransformationRequired = false;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Disables resource decoders that return animated resources so any resource returned will be
-   * static.
-   *
-   * <p> To disable transitions (fades etc) use
-   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
-   */
-  public final CHILD dontAnimate() {
-    if (isAutoCloneEnabled) {
-      return clone().dontAnimate();
-    }
-
-    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
-    set(StreamGifDecoder.DISABLE_ANIMATION, true);
-    return selfOrThrowIfLocked();
-  }
-
-  public final CHILD apply(BaseRequestOptions<?> other) {
-    if (isAutoCloneEnabled) {
-      return clone().apply(other);
-    }
-
-    if (isSet(other.fields, SIZE_MULTIPLIER)) {
-      sizeMultiplier = other.sizeMultiplier;
-    }
-    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
-      diskCacheStrategy = other.diskCacheStrategy;
-    }
-    if (isSet(other.fields, PRIORITY)) {
-      priority = other.priority;
-    }
-    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
-      errorPlaceholder = other.errorPlaceholder;
-    }
-    if (isSet(other.fields, ERROR_ID)) {
-      errorId = other.errorId;
-    }
-    if (isSet(other.fields, PLACEHOLDER)) {
-      placeholderDrawable = other.placeholderDrawable;
-    }
-    if (isSet(other.fields, PLACEHOLDER_ID)) {
-      placeholderId = other.placeholderId;
-    }
-    if (isSet(other.fields, IS_CACHEABLE)) {
-      isCacheable = other.isCacheable;
-    }
-    if (isSet(other.fields, OVERRIDE)) {
-      overrideWidth = other.overrideWidth;
-      overrideHeight = other.overrideHeight;
-    }
-    if (isSet(other.fields, SIGNATURE)) {
-      signature = other.signature;
-    }
-    if (isSet(other.fields, RESOURCE_CLASS)) {
-      resourceClass = other.resourceClass;
-    }
-    if (isSet(other.fields, FALLBACK)) {
-      fallbackDrawable = other.fallbackDrawable;
-    }
-    if (isSet(other.fields, FALLBACK_ID)) {
-      fallbackId = other.fallbackId;
-    }
-    if (isSet(other.fields, THEME)) {
-      theme = other.theme;
-    }
-
-    isTransformationRequired |= other.isTransformationRequired;
-    fields |= other.fields;
-    transformations.putAll(other.transformations);
-    options.putAll(other.options);
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Throws if any further mutations are attempted.
-   *
-   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
-   */
-  @SuppressWarnings("unchecked")
-  public final CHILD lock() {
-    isLocked = true;
-    // This is the only place we should not check locked.
-    return (CHILD) this;
-  }
-
-  /**
-   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
-   * before the mutation resulting in all methods returning a new Object and leaving the original
-   * locked object unmodified.
-   *
-   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
-   * are mutable and are not locked.
-   */
-  public final CHILD autoLock() {
-    if (isLocked && !isAutoCloneEnabled) {
-      throw new IllegalStateException("You cannot auto lock an already locked options object"
-          + ", try clone() first");
-    }
-    isAutoCloneEnabled = true;
-    return lock();
-  }
-
-  @SuppressWarnings("unchecked")
-  private CHILD selfOrThrowIfLocked() {
-    if (isLocked) {
-      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
-    }
-    return (CHILD) this;
-  }
-
-  public final Map<Class<?>, Transformation<?>> getTransformations() {
-    return transformations;
-  }
-
-  public final boolean isTransformationRequired() {
-    return isTransformationRequired;
-  }
-
-  public final Options getOptions() {
-    return options;
-  }
-
-  public final Class<?> getResourceClass() {
-    return resourceClass;
-  }
-
-  public final DiskCacheStrategy getDiskCacheStrategy() {
-    return diskCacheStrategy;
-  }
-
-  public final Drawable getErrorPlaceholder() {
-    return errorPlaceholder;
-  }
-
-  public final int getErrorId() {
-    return errorId;
-  }
-
-  public final int getPlaceholderId() {
-    return placeholderId;
-  }
-
-  public final Drawable getPlaceholderDrawable() {
-    return placeholderDrawable;
-  }
-
-  public final int getFallbackId() {
-    return fallbackId;
-  }
-
-  public final Drawable getFallbackDrawable() {
-    return fallbackDrawable;
-  }
-
-  public final Resources.Theme getTheme() {
-    return theme;
-  }
-
-  public final boolean isMemoryCacheable() {
-    return isCacheable;
-  }
-
-  public final Key getSignature() {
-    return signature;
-  }
-
-  public final boolean isPrioritySet() {
-    return isSet(PRIORITY);
-  }
-
-  public final Priority getPriority() {
-    return priority;
-  }
-
-  public final int getOverrideWidth() {
-    return overrideWidth;
-  }
-
-  public final boolean isValidOverride() {
-    return Util.isValidDimensions(overrideWidth, overrideHeight);
-  }
-
-  public final int getOverrideHeight() {
-    return overrideHeight;
-  }
-
-  public final float getSizeMultiplier() {
-    return sizeMultiplier;
-  }
-
-  private boolean isSet(int flag) {
-    return isSet(fields, flag);
-  }
-
-  private static boolean isSet(int fields, int flag) {
-    return (fields & flag) != 0;
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
new file mode 100644
index 000000000..cd6a43151
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
@@ -0,0 +1,158 @@
+package com.bumptech.glide.request;
+
+import android.support.annotation.Nullable;
+
+/**
+ * Runs a single primary {@link Request} until it completes and then a fallback error request only
+ * if the single primary request fails.
+ */
+public final class ErrorRequestCoordinator implements RequestCoordinator,
+    Request {
+
+  @Nullable
+  private final RequestCoordinator parent;
+  private Request primary;
+  private Request error;
+
+  public ErrorRequestCoordinator(@Nullable RequestCoordinator parent) {
+    this.parent = parent;
+  }
+
+  public void setRequests(Request primary, Request error) {
+    this.primary = primary;
+    this.error = error;
+  }
+
+  @Override
+  public void begin() {
+    if (!primary.isRunning()) {
+      primary.begin();
+    }
+  }
+
+  @Override
+  public void pause() {
+    if (!primary.isFailed()) {
+      primary.pause();
+    }
+    if (error.isRunning()) {
+      error.pause();
+    }
+  }
+
+  @Override
+  public void clear() {
+    primary.clear();
+    // Don't check primary.isFailed() here because it will have been reset by the clear call
+    // immediately before this.
+    if (error.isRunning()) {
+      error.clear();
+    }
+  }
+
+  @Override
+  public boolean isPaused() {
+    return primary.isFailed() ? error.isPaused() : primary.isPaused();
+  }
+
+  @Override
+  public boolean isRunning() {
+    return primary.isFailed() ? error.isRunning() : primary.isRunning();
+  }
+
+  @Override
+  public boolean isComplete() {
+    return primary.isFailed() ? error.isComplete() : primary.isComplete();
+  }
+
+  @Override
+  public boolean isResourceSet() {
+    return primary.isFailed() ? error.isResourceSet() : primary.isResourceSet();
+  }
+
+  @Override
+  public boolean isCancelled() {
+    return primary.isFailed() ? error.isCancelled() : primary.isCancelled();
+  }
+
+  @Override
+  public boolean isFailed() {
+    return primary.isFailed() && error.isFailed();
+  }
+
+  @Override
+  public void recycle() {
+    primary.recycle();
+    error.recycle();
+  }
+
+  @Override
+  public boolean isEquivalentTo(Request o) {
+    if (o instanceof ErrorRequestCoordinator) {
+      ErrorRequestCoordinator other = (ErrorRequestCoordinator) o;
+      return primary.isEquivalentTo(other.primary) && error.isEquivalentTo(other.error);
+    }
+    return false;
+  }
+
+  @Override
+  public boolean canSetImage(Request request) {
+    return parentCanSetImage() && isValidRequest(request);
+  }
+
+  private boolean parentCanSetImage() {
+    return parent == null || parent.canSetImage(this);
+  }
+
+  @Override
+  public boolean canNotifyStatusChanged(Request request) {
+    return parentCanNotifyStatusChanged() && isValidRequest(request);
+  }
+
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && isValidRequest(request);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return parent == null || parent.canNotifyCleared(this);
+  }
+
+  private boolean parentCanNotifyStatusChanged() {
+    return parent == null || parent.canNotifyStatusChanged(this);
+  }
+
+  private boolean isValidRequest(Request request) {
+    return request.equals(primary) || (primary.isFailed() && request.equals(error));
+  }
+
+  @Override
+  public boolean isAnyResourceSet() {
+    return parentIsAnyResourceSet() || isResourceSet();
+  }
+
+  private boolean parentIsAnyResourceSet() {
+    return parent != null && parent.isAnyResourceSet();
+  }
+
+  @Override
+  public void onRequestSuccess(Request request) {
+    if (parent != null) {
+      parent.onRequestSuccess(this);
+    }
+  }
+
+  @Override
+  public void onRequestFailed(Request request) {
+    if (!request.equals(error)) {
+      if (!error.isRunning()) {
+        error.begin();
+      }
+      return;
+    }
+
+    if (parent != null) {
+      parent.onRequestFailed(this);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
index aa485d357..063b96dd8 100644
--- a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.request;
 
 import com.bumptech.glide.request.target.Target;
-
 import java.util.concurrent.Future;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/request/Request.java b/library/src/main/java/com/bumptech/glide/request/Request.java
index ffa21d02f..ad89792fb 100644
--- a/library/src/main/java/com/bumptech/glide/request/Request.java
+++ b/library/src/main/java/com/bumptech/glide/request/Request.java
@@ -57,4 +57,18 @@
    * Recycles the request object and releases its resources.
    */
   void recycle();
+
+  /**
+   * Returns {@code true} if this {@link Request} is equivalent to the given {@link Request} (has
+   * all of the same options and sizes).
+   *
+   * <p>This method is identical to {@link Object#equals(Object)} except that it's specific to
+   * {@link Request} subclasses. We do not use {@link Object#equals(Object)} directly because we
+   * track {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate
+   * to have two different {@link Request} objects for two different
+   * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different
+   * method let's us selectively compare {@link Request} objects to each other when it's useful in
+   * specific scenarios.
+   */
+  boolean isEquivalentTo(Request other);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
index 2143366eb..4aa69b394 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
@@ -20,6 +20,12 @@
    */
   boolean canNotifyStatusChanged(Request request);
 
+  /**
+   * Returns {@code true} if the {@link Request} can clear the
+   * {@link com.bumptech.glide.request.target.Target}.
+   */
+  boolean canNotifyCleared(Request request);
+
   /**
    * Returns true if any coordinated {@link Request} has successfully completed.
    *
@@ -28,7 +34,10 @@
   boolean isAnyResourceSet();
 
   /**
-   * Must be called when a request coordinated by this object completes successfully.
+   * Must be called when a {@link Request} coordinated by this object completes successfully.
    */
   void onRequestSuccess(Request request);
+
+  /** Must be called when a {@link Request} coordinated by this object fails. */
+  void onRequestFailed(Request request);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 3c57db530..77dad3e09 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -2,12 +2,15 @@
 
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
-
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -23,18 +26,33 @@
  *
  * <pre>
  *     {@code
- *      RequestFutureTarget target = Glide.load("")...
- *     Object resource = target.get();
- *     // Do something with resource, and when finished:
- *     target.cancel(false);
+ *      FutureTarget<File> target = null;
+ *      RequestManager requestManager = Glide.with(context);
+ *      try {
+ *        target = requestManager
+ *           .downloadOnly()
+ *           .load(model)
+ *           .submit();
+ *        File downloadedFile = target.get();
+ *        // ... do something with the file (usually throws IOException)
+ *      } catch (ExecutionException | InterruptedException | IOException e) {
+ *        // ... bug reporting or recovery
+ *      } finally {
+ *        // make sure to cancel pending operations and free resources
+ *        if (target != null) {
+ *          target.cancel(true); // mayInterruptIfRunning
+ *        }
+ *      }
  *     }
  *     </pre>
- * The {@link #cancel(boolean)} call will make sure any resources used are recycled.
+ * The {@link #cancel(boolean)} call will cancel pending operations and
+ * make sure that any resources used are recycled.
  * </p>
  *
  * @param <R> The type of the resource that will be loaded.
  */
 public class RequestFutureTarget<R> implements FutureTarget<R>,
+    RequestListener<R>,
     Runnable {
   private static final Waiter DEFAULT_WAITER = new Waiter();
 
@@ -50,6 +68,7 @@
   private boolean isCancelled;
   private boolean resultReceived;
   private boolean loadFailed;
+  @Nullable private GlideException exception;
 
   /**
    * Constructor for a RequestFutureTarget. Should not be used directly.
@@ -69,17 +88,15 @@ public RequestFutureTarget(Handler mainHandler, int width, int height) {
 
   @Override
   public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-    if (isCancelled) {
-      return true;
+    if (isDone()) {
+      return false;
     }
-
-    final boolean result = !isDone();
-    if (result) {
-      isCancelled = true;
-      waiter.notifyAll(this);
+    isCancelled = true;
+    waiter.notifyAll(this);
+    if (mayInterruptIfRunning) {
+      clearOnMainThread();
     }
-    clearOnMainThread();
-    return result;
+    return true;
   }
 
   @Override
@@ -89,7 +106,7 @@ public synchronized boolean isCancelled() {
 
   @Override
   public synchronized boolean isDone() {
-    return isCancelled || resultReceived;
+    return isCancelled || resultReceived || loadFailed;
   }
 
   @Override
@@ -102,7 +119,7 @@ public R get() throws InterruptedException, ExecutionException {
   }
 
   @Override
-  public R get(long time, TimeUnit timeUnit)
+  public R get(long time, @NonNull TimeUnit timeUnit)
       throws InterruptedException, ExecutionException, TimeoutException {
     return doGet(timeUnit.toMillis(time));
   }
@@ -111,13 +128,15 @@ public R get(long time, TimeUnit timeUnit)
    * A callback that should never be invoked directly.
    */
   @Override
-  public void getSize(SizeReadyCallback cb) {
+  public void getSize(@NonNull SizeReadyCallback cb) {
     cb.onSizeReady(width, height);
   }
 
-  /**
-   * {@inheritDoc}
-   */
+  @Override
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
+    // Do nothing because we do not retain references to SizeReadyCallbacks.
+  }
+
   @Override
   public void setRequest(@Nullable Request request) {
     this.request = request;
@@ -133,7 +152,7 @@ public Request getRequest() {
    * A callback that should never be invoked directly.
    */
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
@@ -141,7 +160,7 @@ public void onLoadCleared(Drawable placeholder) {
    * A callback that should never be invoked directly.
    */
   @Override
-  public void onLoadStarted(Drawable placeholder) {
+  public void onLoadStarted(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
@@ -149,32 +168,29 @@ public void onLoadStarted(Drawable placeholder) {
    * A callback that should never be invoked directly.
    */
   @Override
-  public synchronized void onLoadFailed(Drawable errorDrawable) {
-    loadFailed = true;
-    waiter.notifyAll(this);
+  public synchronized void onLoadFailed(@Nullable Drawable errorDrawable) {
+    // Ignored, synchronized for backwards compatibility.
   }
 
   /**
    * A callback that should never be invoked directly.
    */
   @Override
-  public synchronized void onResourceReady(R resource, Transition<? super R> transition) {
-    // We might get a null result.
-    resultReceived = true;
-    this.resource = resource;
-    waiter.notifyAll(this);
+  public synchronized void onResourceReady(@NonNull R resource,
+      @Nullable Transition<? super R> transition) {
+    // Ignored, synchronized for backwards compatibility.
   }
 
   private synchronized R doGet(Long timeoutMillis)
       throws ExecutionException, InterruptedException, TimeoutException {
-    if (assertBackgroundThread) {
+    if (assertBackgroundThread && !isDone()) {
       Util.assertBackgroundThread();
     }
 
     if (isCancelled) {
       throw new CancellationException();
     } else if (loadFailed) {
-      throw new ExecutionException(new IllegalStateException("Load failed"));
+      throw new ExecutionException(exception);
     } else if (resultReceived) {
       return resource;
     }
@@ -182,13 +198,18 @@ private synchronized R doGet(Long timeoutMillis)
     if (timeoutMillis == null) {
       waiter.waitForTimeout(this, 0);
     } else if (timeoutMillis > 0) {
-      waiter.waitForTimeout(this, timeoutMillis);
+      long now = System.currentTimeMillis();
+      long deadline = now + timeoutMillis;
+      while (!isDone() && now < deadline) {
+        waiter.waitForTimeout(this, deadline - now);
+        now = System.currentTimeMillis();
+      }
     }
 
     if (Thread.interrupted()) {
       throw new InterruptedException();
     } else if (loadFailed) {
-      throw new ExecutionException(new IllegalStateException("Load failed"));
+      throw new ExecutionException(exception);
     } else if (isCancelled) {
       throw new CancellationException();
     } else if (!resultReceived) {
@@ -228,14 +249,35 @@ public void onDestroy() {
     // Do nothing.
   }
 
-  // Visible for testing.
-  static class Waiter {
+  @Override
+  public synchronized boolean onLoadFailed(
+      @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource) {
+    loadFailed = true;
+    exception = e;
+    waiter.notifyAll(this);
+    return false;
+  }
+
+  @Override
+  public synchronized boolean onResourceReady(
+      R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource) {
+    // We might get a null result.
+    resultReceived = true;
+    this.resource = resource;
+    waiter.notifyAll(this);
+    return false;
+  }
 
-    public void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
+  @VisibleForTesting
+  static class Waiter {
+    // This is a simple wrapper class that is used to enable testing. The call to the wrapping class
+    // is waited on appropriately.
+    @SuppressWarnings("WaitNotInLoop")
+    void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
       toWaitOn.wait(timeoutMillis);
     }
 
-    public void notifyAll(Object toNotify) {
+    void notifyAll(Object toNotify) {
       toNotify.notifyAll();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index cd8ddb751..74b33246c 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.request;
 
+import android.graphics.drawable.Drawable;
 import android.support.annotation.Nullable;
-
+import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.Target;
@@ -14,52 +15,61 @@
 public interface RequestListener<R> {
 
   /**
-   * Called when an exception occurs during a load. Will only be called if we currently want to
-   * display an image for the given model in the given target. It is recommended to create a single
-   * instance per activity/fragment rather than instantiate a new object for each call to {@code
-   * Glide.load()} to avoid object churn.
+   * Called when an exception occurs during a load, immediately before
+   * {@link Target#onLoadFailed(Drawable)}. Will only be called if we currently want to display an
+   * image for the given model in the given target. It is recommended to create a single instance
+   * per activity/fragment rather than instantiate a new object for each call to {@code
+   * Glide.with(fragment/activity).load()} to avoid object churn.
+   *
+   * <p>It is not safe to reload this or a different model in this callback. If you need to do so
+   * use {@link com.bumptech.glide.RequestBuilder#error(RequestBuilder)} instead.
+   *
+   * <p>Although you can't start an entirely new load, it is safe to change what is displayed in the
+   * {@link Target} at this point, as long as you return {@code true} from the method to prevent
+   * {@link Target#onLoadFailed(Drawable)} from being called.
    *
-   * <p> It is safe to reload this or a different model or change what is displayed in the target at
-   * this point. For example:
+   * For example:
    * <pre>
    * {@code
-   * public void onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
+   * public boolean onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {
    *     target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
-   *     Glide.load(model).into(target);
+   *     return true; // Prevent onLoadFailed from being called on the Target.
    * }
    * }
    * </pre>
    * </p>
    *
-   * <p> Note - if you want to reload this or any other model after an exception, you will need to
-   * include all relevant builder calls (like centerCrop, placeholder etc). </p>
-   *
    * @param e               The maybe {@code null} exception containing information about why the
    *                        request failed.
    * @param model           The model we were trying to load when the exception occurred.
    * @param target          The {@link Target} we were trying to load the image into.
-   * @param isFirstResource True if this exception is for the first resource to load.
-   * @return True if the listener has handled updating the target for the given exception, false to
-   * allow Glide's request to update the target.
+   * @param isFirstResource {@code true} if this exception is for the first resource to load.
+   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
+   * {@code target}, typically because the listener wants to update the {@code target} or the object
+   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}
+   * to be called on {@code target}.
    */
-  boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
-      boolean isFirstResource);
+  boolean onLoadFailed(
+      @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource);
 
   /**
-   * Called when a load completes successfully, immediately after {@link
+   * Called when a load completes successfully, immediately before {@link
    * Target#onResourceReady(Object, com.bumptech.glide.request.transition.Transition)}.
    *
    * @param resource          The resource that was loaded for the target.
    * @param model             The specific model that was used to load the image.
    * @param target            The target the model was loaded into.
    * @param dataSource        The {@link DataSource} the resource was loaded from.
-   * @param isFirstResource   True if this is the first resource to in this load to be loaded into
-   *                          the target. For example when loading a thumbnail and a fullsize image,
-   *                          this will be true for the first image to load and false for the
-   *                          second.
-   * @return True if the listener has handled setting the resource on the target (including any
-   * animations), false to allow Glide's request to update the target (again including animations).
+   * @param isFirstResource   {@code true} if this is the first resource to in this load to be
+   *                          loaded into the target. For example when loading a thumbnail and a
+   *                          full-sized image, this will be {@code true} for the first image to
+   *                          load and {@code false} for the second.
+   *
+   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on
+   * {@code target}, typically because the listener wants to update the {@code target} or the object
+   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}
+   * to be called on {@code target}.
    */
-  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,
-      boolean isFirstResource);
+  boolean onResourceReady(
+      R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 6e8aa1e65..4e416b649 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -1,46 +1,139 @@
 package com.bumptech.glide.request;
 
-import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.MultiTransformation;
 import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;
+import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CenterInside;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.DrawableTransformation;
+import com.bumptech.glide.load.resource.bitmap.FitCenter;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
+import com.bumptech.glide.load.resource.gif.GifOptions;
+import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
- * The standard concrete implementation of {@link com.bumptech.glide.request.BaseRequestOptions}.
- *
- * <p> Uses with custom types, transformations, or options can subclass and customize. {@link
- * com.bumptech.glide.request.BaseRequestOptions}. </p>
+ * Provides type independent options to customize loads with Glide.
  */
 @SuppressWarnings({"PMD.UseUtilityClass", "unused"})
-public final class RequestOptions extends BaseRequestOptions<RequestOptions> {
+public class RequestOptions implements Cloneable {
+  private static final int UNSET = -1;
+  private static final int SIZE_MULTIPLIER = 1 << 1;
+  private static final int DISK_CACHE_STRATEGY = 1 << 2;
+  private static final int PRIORITY = 1 << 3;
+  private static final int ERROR_PLACEHOLDER = 1 << 4;
+  private static final int ERROR_ID = 1 << 5;
+  private static final int PLACEHOLDER = 1 << 6;
+  private static final int PLACEHOLDER_ID = 1 << 7;
+  private static final int IS_CACHEABLE = 1 << 8;
+  private static final int OVERRIDE = 1 << 9;
+  private static final int SIGNATURE = 1 << 10;
+  private static final int TRANSFORMATION = 1 << 11;
+  private static final int RESOURCE_CLASS = 1 << 12;
+  private static final int FALLBACK = 1 << 13;
+  private static final int FALLBACK_ID = 1 << 14;
+  private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
+  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
+  private static final int USE_ANIMATION_POOL = 1 << 20;
 
+  @Nullable
   private static RequestOptions skipMemoryCacheTrueOptions;
+  @Nullable
   private static RequestOptions skipMemoryCacheFalseOptions;
+  @Nullable
   private static RequestOptions fitCenterOptions;
+  @Nullable
+  private static RequestOptions centerInsideOptions;
+  @Nullable
   private static RequestOptions centerCropOptions;
+  @Nullable
   private static RequestOptions circleCropOptions;
+  @Nullable
   private static RequestOptions noTransformOptions;
+  @Nullable
   private static RequestOptions noAnimationOptions;
 
+  private int fields;
+  private float sizeMultiplier = 1f;
+  @NonNull
+  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
+  @NonNull
+  private Priority priority = Priority.NORMAL;
+  @Nullable
+  private Drawable errorPlaceholder;
+  private int errorId;
+  @Nullable
+  private Drawable placeholderDrawable;
+  private int placeholderId;
+  private boolean isCacheable = true;
+  private int overrideHeight = RequestOptions.UNSET;
+  private int overrideWidth = RequestOptions.UNSET;
+  @NonNull
+  private Key signature = EmptySignature.obtain();
+  private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
+  @Nullable
+  private Drawable fallbackDrawable;
+  private int fallbackId;
+  @NonNull
+  private Options options = new Options();
+  @NonNull
+  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+  @NonNull
+  private Class<?> resourceClass = Object.class;
+  private boolean isLocked;
+  @Nullable
+  private Resources.Theme theme;
+  private boolean isAutoCloneEnabled;
+  private boolean useUnlimitedSourceGeneratorsPool;
+  private boolean onlyRetrieveFromCache;
+  private boolean isScaleOnlyOrNoTransform = true;
+  private boolean useAnimationPool;
+
   /**
    * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
    */
-  public static RequestOptions sizeMultiplierOf(float sizeMultiplier) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
+  public static RequestOptions sizeMultiplierOf(
+      @FloatRange(from = 0, to = 1) float sizeMultiplier) {
     return new RequestOptions().sizeMultiplier(sizeMultiplier);
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
+   * Returns a {@link RequestOptions} object with {@link #diskCacheStrategy(DiskCacheStrategy)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) {
     return new RequestOptions().diskCacheStrategy(diskCacheStrategy);
   }
@@ -48,6 +141,9 @@ public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy disk
   /**
    * Returns a {@link RequestOptions} object with {@link #priority(Priority)}} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions priorityOf(@NonNull Priority priority) {
     return new RequestOptions().priority(priority);
   }
@@ -55,6 +151,8 @@ public static RequestOptions priorityOf(@NonNull Priority priority) {
   /**
    * Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
     return new RequestOptions().placeholder(placeholder);
   }
@@ -62,13 +160,17 @@ public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
   /**
    * Returns a {@link RequestOptions} object with {@link #placeholder(int)} set.
    */
-  public static RequestOptions placeholderOf(int placeholderId) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions placeholderOf(@DrawableRes int placeholderId) {
     return new RequestOptions().placeholder(placeholderId);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #error(Drawable)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
     return new RequestOptions().error(errorDrawable);
   }
@@ -76,22 +178,26 @@ public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
   /**
    * Returns a {@link RequestOptions} object with {@link #error(int)}} set.
    */
-  public static RequestOptions errorOf(int errorId) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions errorOf(@DrawableRes int errorId) {
     return new RequestOptions().error(errorId);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
     if (skipMemoryCache) {
       if (skipMemoryCacheTrueOptions == null) {
-        skipMemoryCacheTrueOptions = new RequestOptions().skipMemoryCache(true).autoLock();
+        skipMemoryCacheTrueOptions = new RequestOptions().skipMemoryCache(true).autoClone();
       }
       return skipMemoryCacheTrueOptions;
     } else {
       if (skipMemoryCacheFalseOptions == null) {
-        skipMemoryCacheFalseOptions = new RequestOptions().skipMemoryCache(false).autoLock();
+        skipMemoryCacheFalseOptions = new RequestOptions().skipMemoryCache(false).autoClone();
       }
       return skipMemoryCacheFalseOptions;
     }
@@ -100,7 +206,12 @@ public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
   /**
    * Returns a {@link RequestOptions} object with {@link #override(int, int)}} set.
    */
-  public static RequestOptions overrideOf(int width, int height) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
+  public static RequestOptions overrideOf(
+      @IntRange(from = 0) int width,
+      @IntRange(from = 0) int height) {
     return new RequestOptions().override(width, height);
   }
 
@@ -108,69 +219,102 @@ public static RequestOptions overrideOf(int width, int height) {
    * Returns a {@link RequestOptions} with {@link #override(int, int)} set where both the width and
    * height are the given size.
    */
-  public static RequestOptions overrideOf(int size) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
+  public static RequestOptions overrideOf(@IntRange(from = 0) int size) {
     return overrideOf(size, size);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #signature} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions signatureOf(@NonNull Key signature) {
     return new RequestOptions().signature(signature);
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #fitCenter(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link #fitCenter()} set.
    */
-  public static RequestOptions fitCenterTransform(Context context) {
+  @NonNull
+  @CheckResult
+  public static RequestOptions fitCenterTransform() {
     if (fitCenterOptions == null) {
       fitCenterOptions = new RequestOptions()
-          .fitCenter(context.getApplicationContext())
-          .autoLock();
+          .fitCenter()
+          .autoClone();
     }
     return fitCenterOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #circleCrop(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link #centerInside()} set.
+   */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
+  public static RequestOptions centerInsideTransform() {
+    if (centerInsideOptions == null) {
+      centerInsideOptions = new RequestOptions()
+              .centerInside()
+              .autoClone();
+    }
+    return centerInsideOptions;
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
    */
-  public static RequestOptions centerCropTransform(Context context) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
+  public static RequestOptions centerCropTransform() {
     if (centerCropOptions == null) {
       centerCropOptions = new RequestOptions()
-          .centerCrop(context.getApplicationContext())
-          .autoLock();
+          .centerCrop()
+          .autoClone();
     }
     return centerCropOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set.
    */
-  public static RequestOptions circleCropTransform(Context context) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
+  public static RequestOptions circleCropTransform() {
     if (circleCropOptions == null) {
       circleCropOptions = new RequestOptions()
-          .circleCrop(context.getApplicationContext())
-          .autoLock();
+          .circleCrop()
+          .autoClone();
     }
     return circleCropOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #transform(Context, Transformation)} set.
+   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
    */
-  public static RequestOptions bitmapTransform(Context context,
-      @NonNull Transformation<Bitmap> transformation) {
-    return new RequestOptions().transform(context, transformation);
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
+  public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new RequestOptions().transform(transformation);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
    */
-  public static RequestOptions noTransform() {
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
+  @CheckResult
+  public static RequestOptions noTransformation() {
     if (noTransformOptions == null) {
       noTransformOptions = new RequestOptions()
           .dontTransform()
-          .autoLock();
+          .autoClone();
     }
     return noTransformOptions;
   }
@@ -179,6 +323,8 @@ public static RequestOptions noTransform() {
    * Returns a {@link RequestOptions} object with the given {@link Option} set via
    * {@link #set(Option, Object)}.
    */
+  @NonNull
+  @CheckResult
   public static <T> RequestOptions option(@NonNull Option<T> option, @NonNull T value) {
     return new RequestOptions().set(option, value);
   }
@@ -186,6 +332,8 @@ public static RequestOptions noTransform() {
   /**
    * Returns a {@link RequestOptions} object with {@link #decode(Class)} set.
    */
+  @NonNull
+  @CheckResult
   public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
     return new RequestOptions().decode(resourceClass);
   }
@@ -193,6 +341,9 @@ public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
   /**
    * Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions formatOf(@NonNull DecodeFormat format) {
     return new RequestOptions().format(format);
   }
@@ -200,22 +351,40 @@ public static RequestOptions formatOf(@NonNull DecodeFormat format) {
   /**
    * Returns a {@link RequestOptions} object with {@link #frame(long)} set.
    */
-  public static RequestOptions frameOf(long frameTimeMicros) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
+  public static RequestOptions frameOf(@IntRange(from = 0) long frameTimeMicros) {
     return new RequestOptions().frame(frameTimeMicros);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
     return new RequestOptions().downsample(strategy);
   }
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #timeout(int)} set.
+   */
+  @NonNull
+  @CheckResult
+  public static RequestOptions timeoutOf(@IntRange(from = 0) int timeout) {
+    return new RequestOptions().timeout(timeout);
+  }
+
   /**
    * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
    * #encodeQuality(int)} called with the given quality.
    */
-  public static RequestOptions encodeQualityOf(int quality) {
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
+  public static RequestOptions encodeQualityOf(@IntRange(from = 0, to = 100) int quality) {
     return new RequestOptions().encodeQuality(quality);
   }
 
@@ -223,6 +392,9 @@ public static RequestOptions encodeQualityOf(int quality) {
    * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
    * #encodeFormat(android.graphics.Bitmap.CompressFormat)} called with the given format.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
     return new RequestOptions().encodeFormat(format);
   }
@@ -231,12 +403,1284 @@ public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat forma
    * Returns a new {@link com.bumptech.glide.request.RequestOptions} with {@link #dontAnimate()}
    * called.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  @CheckResult
   public static RequestOptions noAnimation() {
     if (noAnimationOptions == null) {
       noAnimationOptions = new RequestOptions()
           .dontAnimate()
-          .autoLock();
+          .autoClone();
     }
     return noAnimationOptions;
   }
+
+  private static boolean isSet(int fields, int flag) {
+    return (fields & flag) != 0;
+  }
+
+  /**
+   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
+   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
+   * (particularly {@link Bitmap}s on devices with overly dense screens.
+   *
+   * @param sizeMultiplier The multiplier to apply to the
+   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
+   *                       loading the resource.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions sizeMultiplier(@FloatRange(from = 0, to = 1) float sizeMultiplier) {
+    if (isAutoCloneEnabled) {
+      return clone().sizeMultiplier(sizeMultiplier);
+    }
+
+    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+    }
+    this.sizeMultiplier = sizeMultiplier;
+    fields |= SIZE_MULTIPLIER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to {@code true}, uses a cached unlimited {@link java.util.concurrent.Executor} to run
+   * the request.
+   *
+   * <p>This method should <em>ONLY</em> be used when a Glide load is started recursively on one
+   * of Glide's threads as part of another request. Using this method in other scenarios can lead
+   * to excessive memory usage and OOMs and/or a significant decrease in performance across an
+   * application.
+   *
+   * <p>If both this method and {@link #useAnimationPool(boolean)} are set, this method will be
+   * preferred and {@link #useAnimationPool(boolean)} will be ignored.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useUnlimitedSourceGeneratorsPool(flag);
+    }
+
+    this.useUnlimitedSourceGeneratorsPool = flag;
+    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to {@code true}, uses a special {@link java.util.concurrent.Executor} that is used
+   * exclusively for decoding frames of animated resources, like GIFs.
+   *
+   * <p>The animation executor disallows network operations and must not be used for loads that
+   * may load remote data. The animation executor has fewer threads available to it than Glide's
+   * normal executors and is only useful as a way of avoiding blocking on longer and more expensive
+   * reads for critical requests like those in an animating GIF.
+   *
+   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and this method are set,
+   * {@link #useUnlimitedSourceGeneratorsPool(boolean)} will be preferred and this method will be
+   * ignored.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions useAnimationPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useAnimationPool(flag);
+    }
+
+    useAnimationPool = flag;
+    fields |= USE_ANIMATION_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   *
+   * If set to true, will only load an item if found in the cache, and will not fetch from source.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions onlyRetrieveFromCache(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().onlyRetrieveFromCache(flag);
+    }
+
+    this.onlyRetrieveFromCache = flag;
+    fields |= ONLY_RETRIEVE_FROM_CACHE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link DiskCacheStrategy} to use for this load.
+   *
+   * <p> Defaults to {@link DiskCacheStrategy#AUTOMATIC}. </p>
+   *
+   * <p> For most applications {@link DiskCacheStrategy#RESOURCE} is
+   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
+   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
+   * using {@link DiskCacheStrategy#DATA} or
+   * {@link DiskCacheStrategy#ALL}. </p>
+   *
+   * @param strategy The strategy to use.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    if (isAutoCloneEnabled) {
+      return clone().diskCacheStrategy(strategy);
+    }
+    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
+    fields |= DISK_CACHE_STRATEGY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the priority for this load.
+   *
+   * @param priority A priority.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions priority(@NonNull Priority priority) {
+    if (isAutoCloneEnabled) {
+      return clone().priority(priority);
+    }
+
+    this.priority = Preconditions.checkNotNull(priority);
+    fields |= PRIORITY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display while a resource is loading.
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions placeholder(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(drawable);
+    }
+
+    this.placeholderDrawable = drawable;
+    fields |= PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an Android resource id for a {@link Drawable} resource to
+   * display while a resource is loading.
+   *
+   * @param resourceId The id of the resource to use as a placeholder
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions placeholder(@DrawableRes int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(resourceId);
+    }
+
+    this.placeholderId = resourceId;
+    fields |= PLACEHOLDER_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions fallback(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(drawable);
+    }
+
+    this.fallbackDrawable = drawable;
+    fields |= FALLBACK;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
+   * the error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param resourceId The id of the resource to use as a fallback.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions fallback(@DrawableRes int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(resourceId);
+    }
+
+    this.fallbackId = resourceId;
+    fields |= FALLBACK_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a {@link Drawable} to display if a load fails.
+   *
+   * @param drawable The drawable to display.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions error(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().error(drawable);
+    }
+
+    this.errorPlaceholder = drawable;
+    fields |= ERROR_PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if a load fails.
+   *
+   * @param resourceId The id of the resource to use as a placeholder.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions error(@DrawableRes int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().error(resourceId);
+    }
+    this.errorId = resourceId;
+    fields |= ERROR_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
+   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
+   * {@link #fallback(Drawable)}.
+   *
+   * <p>The theme is <em>NOT</em> applied in the decoder that will attempt to decode a given
+   * resource id model on Glide's background threads. The theme is used exclusively on the main
+   * thread to obtain placeholder/error/fallback drawables to avoid leaking Activities.
+   *
+   * <p>If the {@link android.content.Context} of the {@link android.app.Fragment} or
+   * {@link android.app.Activity} used to start this load has a different
+   * {@link android.content.res.Resources.Theme}, the {@link android.content.res.Resources.Theme}
+   * provided here will override the {@link android.content.res.Resources.Theme} of the
+   * {@link android.content.Context}.
+   *
+   * @param theme The theme to use when loading Drawables.
+   * @return this request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions theme(@Nullable Resources.Theme theme) {
+    if (isAutoCloneEnabled) {
+      return clone().theme(theme);
+    }
+
+    this.theme = theme;
+    fields |= THEME;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Allows the loaded resource to skip the memory cache.
+   *
+   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
+   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
+   *
+   * @param skip True to allow the resource to skip the memory cache.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions skipMemoryCache(boolean skip) {
+    if (isAutoCloneEnabled) {
+      return clone().skipMemoryCache(true);
+    }
+
+    this.isCacheable = !skip;
+    fields |= IS_CACHEABLE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given values. This is useful for thumbnails, and should only be used for other cases when you
+   * need a very specific image size.
+   *
+   * @param width  The width in pixels to use to load the resource.
+   * @param height The height in pixels to use to load the resource.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions override(int width, int height) {
+    if (isAutoCloneEnabled) {
+      return clone().override(width, height);
+    }
+
+    this.overrideWidth = width;
+    this.overrideHeight = height;
+    fields |= OVERRIDE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given size.
+   *
+   * @see #override(int, int)
+   * @param size The width and height to use.
+   * @return This request builder.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions override(int size) {
+    return override(size, size);
+  }
+
+  /**
+   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
+   * more control over when cached data is invalidated.
+   *
+   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
+   *
+   * @param signature A unique non-null {@link Key} representing the current
+   *                  state of the model that will be mixed in to the cache key.
+   * @return This request builder.
+   * @see com.bumptech.glide.signature.ObjectKey
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions signature(@NonNull Key signature) {
+    if (isAutoCloneEnabled) {
+      return clone().signature(signature);
+    }
+
+    this.signature = Preconditions.checkNotNull(signature);
+    fields |= SIGNATURE;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Returns a copy of this request builder with all of the options put so far on this builder.
+   *
+   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * changes to one builder will not affect the other builder. However, in addition to immutable
+   * arguments, the current model is not copied copied so changes to the model will affect both
+   * builders. </p>
+   *
+   * <p> Even if this object was locked, the cloned object returned from this method will not be
+   * locked. </p>
+   */
+  @SuppressWarnings({
+      "unchecked",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
+  @CheckResult
+  @Override
+  public RequestOptions clone() {
+    try {
+      RequestOptions result = (RequestOptions) super.clone();
+      result.options = new Options();
+      result.options.putAll(options);
+      result.transformations = new HashMap<>();
+      result.transformations.putAll(transformations);
+      result.isLocked = false;
+      result.isAutoCloneEnabled = false;
+      return result;
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @NonNull
+  @CheckResult
+  public <T> RequestOptions set(@NonNull Option<T> option, @NonNull T value) {
+    if (isAutoCloneEnabled) {
+      return clone().set(option, value);
+    }
+
+    Preconditions.checkNotNull(option);
+    Preconditions.checkNotNull(value);
+    options.set(option, value);
+    return selfOrThrowIfLocked();
+  }
+
+  @NonNull
+  @CheckResult
+  public RequestOptions decode(@NonNull Class<?> resourceClass) {
+    if (isAutoCloneEnabled) {
+      return clone().decode(resourceClass);
+    }
+
+    this.resourceClass = Preconditions.checkNotNull(resourceClass);
+    fields |= RESOURCE_CLASS;
+    return selfOrThrowIfLocked();
+  }
+
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
+  public final boolean isTransformationSet() {
+    return isSet(TRANSFORMATION);
+  }
+
+  public final boolean isLocked() {
+    return isLocked;
+  }
+
+  /**
+   * Sets the value for key
+   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the value for key
+   * {@link BitmapEncoder#COMPRESSION_QUALITY}.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions encodeQuality(@IntRange(from = 0, to = 100) int quality) {
+    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
+  }
+
+  /**
+   * Sets the time position of the frame to extract from a video.
+   *
+   * <p>This is a component option specific to {@link VideoDecoder}. If the default video
+   * decoder is replaced or skipped because of your configuration, this option may be ignored.
+   *
+   * @see VideoDecoder#TARGET_FRAME
+   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
+   *                        Android framework implementation return a representative frame.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions frame(@IntRange(from = 0) long frameTimeMicros) {
+    return set(VideoDecoder.TARGET_FRAME, frameTimeMicros);
+  }
+
+  /**
+   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
+   * {@link Downsampler} and Glide's default GIF decoders.
+   *
+   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
+   * decoded using a decoder that cannot control the format
+   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
+   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
+   * image has alpha).
+   *
+   * <p>This is a component option specific to {@link Downsampler} and Glide's GIF decoders. If the
+   * default Bitmap decoders are replaced or skipped because of your configuration, this option may
+   * be ignored.
+   *
+   * <p>To set only the format used when decoding {@link Bitmap}s, use
+   * {@link #option(Option, Object)} and {@link Downsampler#DECODE_FORMAT}. To set only the format
+   * used when decoding GIF frames, use {@link #option(Option, Object)} and
+   * {@link GifOptions#DECODE_FORMAT}.
+   *
+   * @see Downsampler#DECODE_FORMAT
+   * @see GifOptions#DECODE_FORMAT
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions format(@NonNull DecodeFormat format) {
+    Preconditions.checkNotNull(format);
+    return set(Downsampler.DECODE_FORMAT, format)
+        .set(GifOptions.DECODE_FORMAT, format);
+  }
+
+  /**
+   * Disables the use of {@link android.graphics.Bitmap.Config#HARDWARE} in {@link Downsampler} to
+   * avoid errors caused by inspecting Bitmap pixels, drawing with hardware support disabled,
+   * drawing to {@link android.graphics.Canvas}s backed by {@link Bitmap}s etc.
+   *
+   * <p>It's almost never safe to set {@link Downsampler#ALLOW_HARDWARE_CONFIG} to {@code true} so
+   * we only provide a way to disable hardware configs entirely. If no option is set for
+   * {@link Downsampler#ALLOW_HARDWARE_CONFIG}, Glide will set the value per request based on
+   * whether or not a {@link Transformation} is applied and if one is, the type of
+   * {@link Transformation} applied. Built in transformations like {@link FitCenter} and
+   * {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.CenterOutside} can safely use
+   * {@link android.graphics.Bitmap.Config#HARDWARE} because they can be entirely replaced by
+   * scaling within {@link Downsampler}. {@link Transformation}s like {@link #circleCrop()} that
+   * can't be replicated by {@link Downsampler} cannot use {@link Bitmap.Config#HARDWARE} because
+   * {@link android.graphics.Bitmap.Config#HARDWARE} cannot be drawn to
+   * {@link android.graphics.Canvas}s, which is required by most {@link Transformation}s.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions disallowHardwareConfig() {
+    return set(Downsampler.ALLOW_HARDWARE_CONFIG, false);
+  }
+
+  /**
+   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
+   * {@link Downsampler}.
+   *
+   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
+   * is replaced or skipped because of your configuration, this option may be ignored.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
+  }
+
+  /**
+   * Sets the read and write timeout for the http requests used to load the image.
+   *
+   * <p>This is a component option specific to Glide's default networking library and
+   * {@link com.bumptech.glide.load.model.stream.HttpGlideUrlLoader}. If you use any other
+   * networking library including Glide's Volley or OkHttp integration libraries, this option will
+   * be ignored.
+   *
+   * @see com.bumptech.glide.load.model.stream.HttpGlideUrlLoader#TIMEOUT
+   * @param timeoutMs The read and write timeout in milliseconds.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions timeout(@IntRange(from = 0) int timeoutMs) {
+    return set(HttpGlideUrlLoader.TIMEOUT, timeoutMs);
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerCrop()
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions optionalCenterCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()} ()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions centerCrop() {
+    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   *
+   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
+   * image types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #fitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions optionalFitCenter() {
+    return optionalScaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
+   * image types, and throws an exception if asked to transform an unknown
+   * type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalFitCenter()
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions fitCenter() {
+    return scaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types,
+   * {@link DownsampleStrategy#CENTER_INSIDE} to image types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions optionalCenterInside() {
+    return optionalScaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CenterInside} to all default types, {@link DownsampleStrategy#CENTER_INSIDE} to
+   * image types and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterInside()
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions centerInside() {
+    return scaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Transformation)
+   * @see #circleCrop()
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions optionalCircleCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions circleCrop() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
+  }
+
+  // calling optionalTransform() on the result of clone() requires greater access.
+  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"WeakerAccess", "CheckResult"})
+  @NonNull
+  final RequestOptions optionalTransform(@NonNull DownsampleStrategy downsampleStrategy,
+      @NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation, /*isRequired=*/ false);
+  }
+
+  // calling transform() on the result of clone() requires greater access.
+  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"WeakerAccess", "CheckResult"})
+  @NonNull
+  @CheckResult
+  final RequestOptions transform(@NonNull DownsampleStrategy downsampleStrategy,
+      @NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation);
+  }
+
+  @NonNull
+  private RequestOptions scaleOnlyTransform(
+      @NonNull DownsampleStrategy strategy, @NonNull Transformation<Bitmap> transformation) {
+    return scaleOnlyTransform(strategy, transformation, true /*isTransformationRequired*/);
+  }
+
+  @NonNull
+  private RequestOptions optionalScaleOnlyTransform(
+      @NonNull DownsampleStrategy strategy, @NonNull Transformation<Bitmap> transformation) {
+    return scaleOnlyTransform(strategy, transformation, false /*isTransformationRequired*/);
+  }
+
+  @NonNull
+  private RequestOptions scaleOnlyTransform(
+      @NonNull DownsampleStrategy strategy,
+      @NonNull Transformation<Bitmap> transformation,
+      boolean isTransformationRequired) {
+    RequestOptions result = isTransformationRequired
+          ? transform(strategy, transformation) : optionalTransform(strategy, transformation);
+    result.isScaleOnlyOrNoTransform = true;
+    return result;
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public RequestOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    return transform(transformation, /*isRequired=*/ true);
+  }
+
+  /**
+   * Applies the given {@link Transformation}s in the given order for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"unchecked", "varargs", "CheckResult"})
+  @NonNull
+  @CheckResult
+  public RequestOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    return transform(new MultiTransformation<>(transformations), /*isRequired=*/ true);
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
+   * @see #transform(Transformation)
+   * @see #transform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public RequestOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
+    return transform(transformation, /*isRequired=*/ false);
+  }
+
+  @NonNull
+  private RequestOptions transform(
+      @NonNull Transformation<Bitmap> transformation, boolean isRequired) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(transformation, isRequired);
+    }
+
+    DrawableTransformation drawableTransformation =
+        new DrawableTransformation(transformation, isRequired);
+    transform(Bitmap.class, transformation, isRequired);
+    transform(Drawable.class, drawableTransformation, isRequired);
+    // TODO: remove BitmapDrawable decoder and this transformation.
+    // Registering as BitmapDrawable is simply an optimization to avoid some iteration and
+    // isAssignableFrom checks when obtaining the transformation later on. It can be removed without
+    // affecting the functionality.
+    transform(BitmapDrawable.class, drawableTransformation.asBitmapDrawable(), isRequired);
+    transform(GifDrawable.class, new GifDrawableTransformation(transformation), isRequired);
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and allows unknown resource types to be ignored.
+   *
+   * <p> Users can apply different transformations for each resource class. Applying a
+   * {@link Transformation} for a resource type that already has a
+   * {@link Transformation} will override the previous call. </p>
+   *
+   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
+   * an unknown resource class will throw an exception. To allow unknown types, users must always
+   * call the optional version of each method. </p>
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   */
+  @NonNull
+  @CheckResult
+  public <T> RequestOptions optionalTransform(
+      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {
+    return transform(resourceClass, transformation, /*isRequired=*/ false);
+  }
+
+  @NonNull
+  private <T> RequestOptions transform(
+      @NonNull Class<T> resourceClass,
+      @NonNull Transformation<T> transformation,
+      boolean isRequired) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(resourceClass, transformation, isRequired);
+    }
+
+    Preconditions.checkNotNull(resourceClass);
+    Preconditions.checkNotNull(transformation);
+    transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
+    // Always set to false here. Known scale only transformations will call this method and then
+    // set isScaleOnlyOrNoTransform to true immediately after.
+    isScaleOnlyOrNoTransform = false;
+    if (isRequired) {
+      fields |= TRANSFORMATION_REQUIRED;
+      isTransformationRequired = true;
+    }
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and throws if asked to transform an unknown resource type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public <T> RequestOptions transform(
+      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {
+    return transform(resourceClass, transformation, /*isRequired=*/ true);
+  }
+
+  /**
+   * Removes all applied {@link Transformation Transformations} for all
+   * resource classes and allows unknown resource types to be transformed without throwing an
+   * exception.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions dontTransform() {
+    if (isAutoCloneEnabled) {
+      return clone().dontTransform();
+    }
+
+    transformations.clear();
+    fields &= ~TRANSFORMATION;
+    isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
+    isScaleOnlyOrNoTransform = true;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Disables resource decoders that return animated resources so any resource returned will be
+   * static.
+   *
+   * <p> To disable transitions (fades etc) use
+   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @NonNull
+  @CheckResult
+  public RequestOptions dontAnimate() {
+    return set(GifOptions.DISABLE_ANIMATION, true);
+  }
+
+  /**
+   * Updates this options set with any options that are explicitly set in the given
+   * {@code RequestOptions} object and returns this object if {@link #autoClone()} is disabled or
+   * a new {@code RequestOptions} object if {@link #autoClone()} is enabled.
+   *
+   * <p>{@code #apply} only replaces those values that are explicitly set in the given
+   * {@code RequestOptions}. If you need to completely reset all previously set options, create a
+   * new {@code RequestOptions} object instead of using this method.
+   *
+   * <p>The options that will be set to values in the returned {@code RequestOptions} object is the
+   * intersection of the set of options in this {@code RequestOptions} object and the given
+   * {@code RequestOptions} object that were explicitly set. If the values of any of the options
+   * conflict, the values in the returned {@code RequestOptions} object will be set to those in the
+   * given {@code RequestOptions} object.
+   */
+  @NonNull
+  @CheckResult
+  public RequestOptions apply(@NonNull RequestOptions other) {
+    if (isAutoCloneEnabled) {
+      return clone().apply(other);
+    }
+
+    if (isSet(other.fields, SIZE_MULTIPLIER)) {
+      sizeMultiplier = other.sizeMultiplier;
+    }
+    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
+      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
+    }
+    if (isSet(other.fields, USE_ANIMATION_POOL)) {
+      useAnimationPool = other.useAnimationPool;
+    }
+    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
+      diskCacheStrategy = other.diskCacheStrategy;
+    }
+    if (isSet(other.fields, PRIORITY)) {
+      priority = other.priority;
+    }
+    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
+      errorPlaceholder = other.errorPlaceholder;
+    }
+    if (isSet(other.fields, ERROR_ID)) {
+      errorId = other.errorId;
+    }
+    if (isSet(other.fields, PLACEHOLDER)) {
+      placeholderDrawable = other.placeholderDrawable;
+    }
+    if (isSet(other.fields, PLACEHOLDER_ID)) {
+      placeholderId = other.placeholderId;
+    }
+    if (isSet(other.fields, IS_CACHEABLE)) {
+      isCacheable = other.isCacheable;
+    }
+    if (isSet(other.fields, OVERRIDE)) {
+      overrideWidth = other.overrideWidth;
+      overrideHeight = other.overrideHeight;
+    }
+    if (isSet(other.fields, SIGNATURE)) {
+      signature = other.signature;
+    }
+    if (isSet(other.fields, RESOURCE_CLASS)) {
+      resourceClass = other.resourceClass;
+    }
+    if (isSet(other.fields, FALLBACK)) {
+      fallbackDrawable = other.fallbackDrawable;
+    }
+    if (isSet(other.fields, FALLBACK_ID)) {
+      fallbackId = other.fallbackId;
+    }
+    if (isSet(other.fields, THEME)) {
+      theme = other.theme;
+    }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+      isScaleOnlyOrNoTransform = other.isScaleOnlyOrNoTransform;
+    }
+    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
+      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+      isScaleOnlyOrNoTransform = true;
+    }
+
+    fields |= other.fields;
+    options.putAll(other.options);
+
+    return selfOrThrowIfLocked();
+  }
+
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof RequestOptions) {
+      RequestOptions other = (RequestOptions) o;
+      return Float.compare(other.sizeMultiplier, sizeMultiplier) == 0
+          && errorId == other.errorId
+          && Util.bothNullOrEqual(errorPlaceholder, other.errorPlaceholder)
+          && placeholderId == other.placeholderId
+          && Util.bothNullOrEqual(placeholderDrawable, other.placeholderDrawable)
+          && fallbackId == other.fallbackId
+          && Util.bothNullOrEqual(fallbackDrawable, other.fallbackDrawable)
+          && isCacheable == other.isCacheable
+          && overrideHeight == other.overrideHeight
+          && overrideWidth == other.overrideWidth
+          && isTransformationRequired == other.isTransformationRequired
+          && isTransformationAllowed == other.isTransformationAllowed
+          && useUnlimitedSourceGeneratorsPool == other.useUnlimitedSourceGeneratorsPool
+          && onlyRetrieveFromCache == other.onlyRetrieveFromCache
+          && diskCacheStrategy.equals(other.diskCacheStrategy)
+          && priority == other.priority
+          && options.equals(other.options)
+          && transformations.equals(other.transformations)
+          && resourceClass.equals(other.resourceClass)
+          && Util.bothNullOrEqual(signature, other.signature)
+          && Util.bothNullOrEqual(theme, other.theme);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hashCode = Util.hashCode(sizeMultiplier);
+    hashCode = Util.hashCode(errorId, hashCode);
+    hashCode = Util.hashCode(errorPlaceholder, hashCode);
+    hashCode = Util.hashCode(placeholderId, hashCode);
+    hashCode = Util.hashCode(placeholderDrawable, hashCode);
+    hashCode = Util.hashCode(fallbackId, hashCode);
+    hashCode = Util.hashCode(fallbackDrawable, hashCode);
+    hashCode = Util.hashCode(isCacheable, hashCode);
+    hashCode = Util.hashCode(overrideHeight, hashCode);
+    hashCode = Util.hashCode(overrideWidth, hashCode);
+    hashCode = Util.hashCode(isTransformationRequired, hashCode);
+    hashCode = Util.hashCode(isTransformationAllowed, hashCode);
+    hashCode = Util.hashCode(useUnlimitedSourceGeneratorsPool, hashCode);
+    hashCode = Util.hashCode(onlyRetrieveFromCache, hashCode);
+    hashCode = Util.hashCode(diskCacheStrategy, hashCode);
+    hashCode = Util.hashCode(priority, hashCode);
+    hashCode = Util.hashCode(options, hashCode);
+    hashCode = Util.hashCode(transformations, hashCode);
+    hashCode = Util.hashCode(resourceClass, hashCode);
+    hashCode = Util.hashCode(signature, hashCode);
+    hashCode = Util.hashCode(theme, hashCode);
+    return hashCode;
+  }
+
+  /**
+   * Throws if any further mutations are attempted.
+   *
+   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
+   */
+  @NonNull
+  @SuppressWarnings("unchecked")
+  public RequestOptions lock() {
+    isLocked = true;
+    // This is the only place we should not check locked.
+    return this;
+  }
+
+  /**
+   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
+   * before the mutation resulting in all methods returning a new Object and leaving the original
+   * locked object unmodified.
+   *
+   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
+   * are mutable and are not locked.
+   */
+  @NonNull
+  public RequestOptions autoClone() {
+    if (isLocked && !isAutoCloneEnabled) {
+      throw new IllegalStateException("You cannot auto lock an already locked options object"
+          + ", try clone() first");
+    }
+    isAutoCloneEnabled = true;
+    return lock();
+  }
+
+  @NonNull
+  @SuppressWarnings("unchecked")
+  private RequestOptions selfOrThrowIfLocked() {
+    if (isLocked) {
+      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
+    }
+    return this;
+  }
+
+  protected boolean isAutoCloneEnabled() {
+    return isAutoCloneEnabled;
+  }
+
+  public final boolean isDiskCacheStrategySet() {
+    return isSet(DISK_CACHE_STRATEGY);
+  }
+
+  public final boolean isSkipMemoryCacheSet() {
+    return isSet(IS_CACHEABLE);
+  }
+
+  @NonNull
+  public final Map<Class<?>, Transformation<?>> getTransformations() {
+    return transformations;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final boolean isTransformationRequired() {
+    return isTransformationRequired;
+  }
+
+  @NonNull
+  public final Options getOptions() {
+    return options;
+  }
+
+  @NonNull
+  public final Class<?> getResourceClass() {
+    return resourceClass;
+  }
+
+  @NonNull
+  public final DiskCacheStrategy getDiskCacheStrategy() {
+    return diskCacheStrategy;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getErrorPlaceholder() {
+    return errorPlaceholder;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getErrorId() {
+    return errorId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getPlaceholderId() {
+    return placeholderId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getPlaceholderDrawable() {
+    return placeholderDrawable;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getFallbackId() {
+    return fallbackId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getFallbackDrawable() {
+    return fallbackDrawable;
+  }
+
+  @Nullable
+  public final Resources.Theme getTheme() {
+    return theme;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final boolean isMemoryCacheable() {
+    return isCacheable;
+  }
+
+  @NonNull
+  public final Key getSignature() {
+    return signature;
+  }
+
+  public final boolean isPrioritySet() {
+    return isSet(PRIORITY);
+  }
+
+  @NonNull
+  public final Priority getPriority() {
+    return priority;
+  }
+
+  public final int getOverrideWidth() {
+    return overrideWidth;
+  }
+
+  public final boolean isValidOverride() {
+    return Util.isValidDimensions(overrideWidth, overrideHeight);
+  }
+
+  public final int getOverrideHeight() {
+    return overrideHeight;
+  }
+
+  public final float getSizeMultiplier() {
+    return sizeMultiplier;
+  }
+
+  boolean isScaleOnlyOrNoTransform() {
+    return isScaleOnlyOrNoTransform;
+  }
+
+  private boolean isSet(int flag) {
+    return isSet(fields, flag);
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getUseUnlimitedSourceGeneratorsPool() {
+    return useUnlimitedSourceGeneratorsPool;
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getUseAnimationPool() {
+    return useAnimationPool;
+  }
+
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
+  public final boolean getOnlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index e8262fa69..1cc122df3 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -1,22 +1,26 @@
 package com.bumptech.glide.request;
 
-import android.content.res.Resources;
+import android.content.Context;
+import android.content.res.Resources.Theme;
 import android.graphics.drawable.Drawable;
-import android.support.v4.content.res.ResourcesCompat;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools;
 import android.util.Log;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.drawable.DrawableDecoderCompat;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
@@ -42,6 +46,10 @@
           return new SingleRequest<Object>();
         }
       });
+  private boolean isCallingCallbacks;
+
+  private static final boolean IS_VERBOSE_LOGGABLE =
+      Log.isLoggable(TAG, Log.VERBOSE);
 
   private enum Status {
     /**
@@ -78,14 +86,19 @@
     PAUSED,
   }
 
-  private final String tag = String.valueOf(hashCode());
+  @Nullable
+  private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
 
+  @Nullable
+  private RequestListener<R> targetListener;
   private RequestCoordinator requestCoordinator;
+  private Context context;
   private GlideContext glideContext;
+  @Nullable
   private Object model;
   private Class<R> transcodeClass;
-  private BaseRequestOptions<?> requestOptions;
+  private RequestOptions requestOptions;
   private int overrideWidth;
   private int overrideHeight;
   private Priority priority;
@@ -104,14 +117,16 @@
   private int height;
 
   public static <R> SingleRequest<R> obtain(
+      Context context,
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
       Target<R> target,
+      RequestListener<R> targetListener,
       RequestListener<R> requestListener,
       RequestCoordinator requestCoordinator,
       Engine engine,
@@ -122,6 +137,7 @@
       request = new SingleRequest<>();
     }
     request.init(
+        context,
         glideContext,
         model,
         transcodeClass,
@@ -130,6 +146,7 @@
         overrideHeight,
         priority,
         target,
+        targetListener,
         requestListener,
         requestCoordinator,
         engine,
@@ -137,23 +154,28 @@
     return request;
   }
 
-  private SingleRequest() {
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  SingleRequest() {
     // just create, instances are reused with recycle/init
   }
 
   private void init(
+      Context context,
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
       Target<R> target,
+      RequestListener<R> targetListener,
       RequestListener<R> requestListener,
       RequestCoordinator requestCoordinator,
       Engine engine,
       TransitionFactory<? super R> animationFactory) {
+    this.context = context;
     this.glideContext = glideContext;
     this.model = model;
     this.transcodeClass = transcodeClass;
@@ -162,6 +184,7 @@ private void init(
     this.overrideHeight = overrideHeight;
     this.priority = priority;
     this.target = target;
+    this.targetListener = targetListener;
     this.requestListener = requestListener;
     this.requestCoordinator = requestCoordinator;
     this.engine = engine;
@@ -169,6 +192,7 @@ private void init(
     status = Status.PENDING;
   }
 
+  @NonNull
   @Override
   public StateVerifier getVerifier() {
     return stateVerifier;
@@ -176,6 +200,8 @@ public StateVerifier getVerifier() {
 
   @Override
   public void recycle() {
+    assertNotCallingCallbacks();
+    context = null;
     glideContext = null;
     model = null;
     transcodeClass = null;
@@ -184,6 +210,7 @@ public void recycle() {
     overrideHeight = -1;
     target = null;
     requestListener = null;
+    targetListener = null;
     requestCoordinator = null;
     animationFactory = null;
     loadStatus = null;
@@ -197,13 +224,39 @@ public void recycle() {
 
   @Override
   public void begin() {
+    assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
     if (model == null) {
-      onLoadFailed(new GlideException("Received null model"));
+      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+        width = overrideWidth;
+        height = overrideHeight;
+      }
+      // Only log at more verbose log levels if the user has set a fallback drawable, because
+      // fallback Drawables indicate the user expects null models occasionally.
+      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
+      onLoadFailed(new GlideException("Received null model"), logLevel);
+      return;
+    }
+
+    if (status == Status.RUNNING) {
+      throw new IllegalArgumentException("Cannot restart a running request");
+    }
+
+    // If we're restarted after we're complete (usually via something like a notifyDataSetChanged
+    // that starts an identical request into the same Target or View), we can simply use the
+    // resource and size we retrieved the last time around and skip obtaining a new size, starting a
+    // new load etc. This does mean that users who want to restart a load because they expect that
+    // the view size has changed will need to explicitly clear the View or Target before starting
+    // the new load.
+    if (status == Status.COMPLETE) {
+      onResourceReady(resource, DataSource.MEMORY_CACHE);
       return;
     }
 
+    // Restarts for requests that are neither complete nor running can be treated as new requests
+    // and can run again from the beginning.
+
     status = Status.WAITING_FOR_SIZE;
     if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
       onSizeReady(overrideWidth, overrideHeight);
@@ -215,7 +268,7 @@ public void begin() {
         && canNotifyStatusChanged()) {
       target.onLoadStarted(getPlaceholderDrawable());
     }
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished run method in " + LogTime.getElapsedMillis(startTime));
     }
   }
@@ -229,7 +282,9 @@ public void begin() {
    * @see #clear()
    */
   void cancel() {
+    assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
+    target.removeCallback(this);
     status = Status.CANCELLED;
     if (loadStatus != null) {
       loadStatus.cancel();
@@ -237,6 +292,16 @@ void cancel() {
     }
   }
 
+  // Avoids difficult to understand errors like #2413.
+  private void assertNotCallingCallbacks() {
+    if (isCallingCallbacks) {
+      throw new IllegalStateException("You can't start or clear loads in RequestListener or"
+          + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
+          + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
+          + " clear() calls to the main thread using a Handler instead.");
+    }
+  }
+
   /**
    * Cancels the current load if it is in progress, clears any resources held onto by the request
    * and replaces the loaded resource if the load completed with the placeholder.
@@ -248,6 +313,8 @@ void cancel() {
   @Override
   public void clear() {
     Util.assertMainThread();
+    assertNotCallingCallbacks();
+    stateVerifier.throwIfRecycled();
     if (status == Status.CLEARED) {
       return;
     }
@@ -256,7 +323,7 @@ public void clear() {
     if (resource != null) {
       releaseResource(resource);
     }
-    if (canNotifyStatusChanged()) {
+    if (canNotifyCleared()) {
       target.onLoadCleared(getPlaceholderDrawable());
     }
     // Must be after cancel().
@@ -274,7 +341,7 @@ public void pause() {
     status = Status.PAUSED;
   }
 
-  private void releaseResource(Resource resource) {
+  private void releaseResource(Resource<?> resource) {
     engine.release(resource);
     this.resource = null;
   }
@@ -334,9 +401,10 @@ private Drawable getFallbackDrawable() {
     return fallbackDrawable;
   }
 
-  private Drawable loadDrawable(int resouceId) {
-    Resources resources = glideContext.getResources();
-    return ResourcesCompat.getDrawable(resources, resouceId, requestOptions.getTheme());
+  private Drawable loadDrawable(@DrawableRes int resourceId) {
+    Theme theme = requestOptions.getTheme() != null
+        ? requestOptions.getTheme() : context.getTheme();
+    return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
   }
 
   private void setErrorPlaceholder() {
@@ -344,7 +412,15 @@ private void setErrorPlaceholder() {
       return;
     }
 
-    Drawable error = model == null ? getFallbackDrawable() : getErrorDrawable();
+    Drawable error = null;
+    if (model == null) {
+      error = getFallbackDrawable();
+    }
+    // Either the model isn't null, or there was no fallback drawable set.
+    if (error == null) {
+      error = getErrorDrawable();
+    }
+    // The model isn't null, no fallback drawable was set or no error drawable was set.
     if (error == null) {
       error = getPlaceholderDrawable();
     }
@@ -357,7 +433,7 @@ private void setErrorPlaceholder() {
   @Override
   public void onSizeReady(int width, int height) {
     stateVerifier.throwIfRecycled();
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
     if (status != Status.WAITING_FOR_SIZE) {
@@ -366,10 +442,10 @@ public void onSizeReady(int width, int height) {
     status = Status.RUNNING;
 
     float sizeMultiplier = requestOptions.getSizeMultiplier();
-    this.width = Math.round(sizeMultiplier * width);
-    this.height = Math.round(sizeMultiplier * height);
+    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
+    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
     }
     loadStatus = engine.load(
@@ -384,18 +460,37 @@ public void onSizeReady(int width, int height) {
         requestOptions.getDiskCacheStrategy(),
         requestOptions.getTransformations(),
         requestOptions.isTransformationRequired(),
+        requestOptions.isScaleOnlyOrNoTransform(),
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
+        requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+        requestOptions.getUseAnimationPool(),
+        requestOptions.getOnlyRetrieveFromCache(),
         this);
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+
+    // This is a hack that's only useful for testing right now where loads complete synchronously
+    // even though under any executor running on any thread but the main thread, the load would
+    // have completed asynchronously.
+    if (status != Status.RUNNING) {
+      loadStatus = null;
+    }
+    if (IS_VERBOSE_LOGGABLE) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
   }
 
+  private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
+    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
+  }
+
   private boolean canSetResource() {
     return requestCoordinator == null || requestCoordinator.canSetImage(this);
   }
 
+  private boolean canNotifyCleared() {
+    return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
+  }
+
   private boolean canNotifyStatusChanged() {
     return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
   }
@@ -410,6 +505,12 @@ private void notifyLoadSuccess() {
     }
   }
 
+  private void notifyLoadFailed() {
+    if (requestCoordinator != null) {
+      requestCoordinator.onRequestFailed(this);
+    }
+  }
+
   /**
    * A callback method that should never be invoked directly.
    */
@@ -467,11 +568,18 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
           + LogTime.getElapsedMillis(startTime) + " ms");
     }
 
-    if (requestListener == null
-        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {
-      Transition<? super R> animation =
-          animationFactory.build(dataSource, isFirstResource);
-      target.onResourceReady(result, animation);
+    isCallingCallbacks = true;
+    try {
+      if ((requestListener == null
+          || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))
+          && (targetListener == null
+          || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) {
+        Transition<? super R> animation =
+            animationFactory.build(dataSource, isFirstResource);
+        target.onResourceReady(result, animation);
+      }
+    } finally {
+      isCallingCallbacks = false;
     }
 
     notifyLoadSuccess();
@@ -482,9 +590,13 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
    */
   @Override
   public void onLoadFailed(GlideException e) {
+    onLoadFailed(e, Log.WARN);
+  }
+
+  private void onLoadFailed(GlideException e, int maxLogLevel) {
     stateVerifier.throwIfRecycled();
     int logLevel = glideContext.getLogLevel();
-    if (logLevel <= Log.WARN) {
+    if (logLevel <= maxLogLevel) {
       Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
       if (logLevel <= Log.INFO) {
         e.logRootCauses(GLIDE_TAG);
@@ -493,11 +605,40 @@ public void onLoadFailed(GlideException e) {
 
     loadStatus = null;
     status = Status.FAILED;
-    //TODO: what if this is a thumbnail request?
-    if (requestListener == null || !requestListener.onLoadFailed(e, model, target,
-        isFirstReadyResource())) {
-      setErrorPlaceholder();
+
+    isCallingCallbacks = true;
+    try {
+      //TODO: what if this is a thumbnail request?
+      if ((requestListener == null
+          || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource()))
+          && (targetListener == null
+          || !targetListener.onLoadFailed(e, model, target, isFirstReadyResource()))) {
+        setErrorPlaceholder();
+      }
+    } finally {
+      isCallingCallbacks = false;
+    }
+
+    notifyLoadFailed();
+  }
+
+  @Override
+  public boolean isEquivalentTo(Request o) {
+    if (o instanceof SingleRequest) {
+      SingleRequest<?> that = (SingleRequest<?>) o;
+      return overrideWidth == that.overrideWidth
+          && overrideHeight == that.overrideHeight
+          && Util.bothModelsNullEquivalentOrEquals(model, that.model)
+          && transcodeClass.equals(that.transcodeClass)
+          && requestOptions.equals(that.requestOptions)
+          && priority == that.priority
+          // We do not want to require that RequestListeners implement equals/hashcode, so we don't
+          // compare them using equals(). We can however, at least assert that the request listener
+          // is either present or not present in both requests.
+          && (requestListener != null
+          ? that.requestListener != null : that.requestListener == null);
     }
+    return false;
   }
 
   private void logV(String message) {
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 195c24d69..ec172f848 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request;
 
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 
 /**
  * A coordinator that coordinates two individual {@link Request}s that load a small thumbnail
@@ -8,17 +9,19 @@
  */
 public class ThumbnailRequestCoordinator implements RequestCoordinator,
     Request {
+  @Nullable private final RequestCoordinator parent;
+
   private Request full;
   private Request thumb;
-  @Nullable private RequestCoordinator coordinator;
   private boolean isRunning;
 
-  public ThumbnailRequestCoordinator() {
-    this(null);
+  @VisibleForTesting
+  ThumbnailRequestCoordinator() {
+    this(/*parent=*/ null);
   }
 
-  public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
-    this.coordinator = coordinator;
+  public ThumbnailRequestCoordinator(@Nullable RequestCoordinator parent) {
+    this.parent = parent;
   }
 
   public void setRequests(Request full, Request thumb) {
@@ -27,7 +30,7 @@ public void setRequests(Request full, Request thumb) {
   }
 
   /**
-   * Returns true if the request is either the request loading the fullsize image or if the request
+   * Returns true if the request is either the request loading the full size image or if the request
    * loading the full size image has not yet completed.
    *
    * @param request {@inheritDoc}
@@ -38,12 +41,12 @@ public boolean canSetImage(Request request) {
   }
 
   private boolean parentCanSetImage() {
-    return coordinator == null || coordinator.canSetImage(this);
+    return parent == null || parent.canSetImage(this);
   }
 
   /**
-   * Returns true if the request is the request loading the fullsize image and if neither the full
-   * nor the thumbnail image have completed sucessfully.
+   * Returns true if the request is the request loading the full size image and if neither the full
+   * nor the thumbnail image have completed successfully.
    *
    * @param request {@inheritDoc}.
    */
@@ -52,8 +55,17 @@ public boolean canNotifyStatusChanged(Request request) {
     return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
   }
 
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && request.equals(full);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return parent == null || parent.canNotifyCleared(this);
+  }
+
   private boolean parentCanNotifyStatusChanged() {
-    return coordinator == null || coordinator.canNotifyStatusChanged(this);
+    return parent == null || parent.canNotifyStatusChanged(this);
   }
 
   @Override
@@ -66,8 +78,8 @@ public void onRequestSuccess(Request request) {
     if (request.equals(thumb)) {
       return;
     }
-    if (coordinator != null) {
-      coordinator.onRequestSuccess(this);
+    if (parent != null) {
+      parent.onRequestSuccess(this);
     }
     // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
     // as a layer in a cross fade for example. The only way we know the thumb is not being
@@ -77,8 +89,19 @@ public void onRequestSuccess(Request request) {
     }
   }
 
+  @Override
+  public void onRequestFailed(Request request) {
+    if (!request.equals(full)) {
+      return;
+    }
+
+    if (parent != null) {
+      parent.onRequestFailed(this);
+    }
+  }
+
   private boolean parentIsAnyResourceSet() {
-    return coordinator != null && coordinator.isAnyResourceSet();
+    return parent != null && parent.isAnyResourceSet();
   }
 
   /**
@@ -87,7 +110,9 @@ private boolean parentIsAnyResourceSet() {
   @Override
   public void begin() {
     isRunning = true;
-    if (!thumb.isRunning()) {
+    // If the request has completed previously, there's no need to restart both the full and the
+    // thumb, we can just restart the full.
+    if (!full.isComplete() && !thumb.isRunning()) {
       thumb.begin();
     }
     if (isRunning && !full.isRunning()) {
@@ -102,9 +127,6 @@ public void pause() {
     thumb.pause();
   }
 
-  /**
-   * {@inheritDoc}
-   */
   @Override
   public void clear() {
     isRunning = false;
@@ -151,12 +173,19 @@ public boolean isFailed() {
     return full.isFailed();
   }
 
-  /**
-   * {@inheritDoc}.
-   */
   @Override
   public void recycle() {
     full.recycle();
     thumb.recycle();
   }
+
+  @Override
+  public boolean isEquivalentTo(Request o) {
+    if (o instanceof ThumbnailRequestCoordinator) {
+      ThumbnailRequestCoordinator that = (ThumbnailRequestCoordinator) o;
+      return (full == null ? that.full == null : full.isEquivalentTo(that.full))
+          && (thumb == null ? that.thumb == null : thumb.isEquivalentTo(that.thumb));
+    }
+    return false;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index 6928462ae..85ebda0de 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -4,8 +4,9 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.widget.RemoteViews;
-
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
 
@@ -16,8 +17,9 @@
  * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
  * for every subsequent load. </p>
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class AppWidgetTarget extends SimpleTarget<Bitmap> {
-
   private final int[] widgetIds;
   private final ComponentName componentName;
   private final RemoteViews remoteViews;
@@ -29,16 +31,16 @@
    * it.
    *
    * @param context     Context to use in the AppWidgetManager initialization.
-   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-   * @param viewId      The id of the ImageView view that will load the image.
    * @param width       Desired width in pixels of the bitmap that will be loaded. (Needs to be
    *                    manually put because of RemoteViews limitations.)
    * @param height      Desired height in pixels of the bitmap that will be loaded. (Needs to be
    *                    manually put because of RemoteViews limitations.)
+   * @param viewId      The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param widgetIds   The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, int... widgetIds) {
+  public AppWidgetTarget(Context context, int width, int height,
+      int viewId, RemoteViews remoteViews, int... widgetIds) {
     super(width, height);
     if (widgetIds.length == 0) {
       throw new IllegalArgumentException("WidgetIds must have length > 0");
@@ -56,29 +58,30 @@ public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int
    * that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
    * @param context     Context to use in the AppWidgetManager initialization.
-   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param viewId      The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param widgetIds   The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int... widgetIds) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, widgetIds);
+  public AppWidgetTarget(Context context,
+      int viewId, RemoteViews remoteViews, int... widgetIds) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);
   }
 
   /**
    * Constructor using a ComponentName to get a handle on the Widget in order to update it.
    *
    * @param context       Context to use in the AppWidgetManager initialization.
-   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
-   *                      bitmap.
-   * @param viewId        The id of the ImageView view that will load the image.
    * @param width         Desired width in pixels of the bitmap that will be loaded. (Needs to be
    *                      manually put because of RemoteViews limitations.)
    * @param height        Desired height in pixels of the bitmap that will be loaded. (Needs to be
    *                      manually put because of RemoteViews limitations.)
+   * @param viewId        The id of the ImageView view that will load the image.
+   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
+   *                      bitmap.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, ComponentName componentName) {
+  public AppWidgetTarget(Context context, int width, int height,
+      int viewId, RemoteViews remoteViews, ComponentName componentName) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context can not be null!");
     this.remoteViews =
@@ -94,14 +97,14 @@ public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int
    * order to update it that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
    * @param context       Context to use in the AppWidgetManager initialization.
+   * @param viewId        The id of the ImageView view that will load the image.
    * @param remoteViews   RemoteViews object which contains the ImageView that will load the
    *                      bitmap.
-   * @param viewId        The id of the ImageView view that will load the image.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId,
-      ComponentName componentName) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, componentName);
+  public AppWidgetTarget(Context context,
+      int viewId, RemoteViews remoteViews, ComponentName componentName) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);
   }
 
   /**
@@ -117,7 +120,8 @@ private void update() {
   }
 
   @Override
-  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+  public void onResourceReady(@NonNull Bitmap resource,
+      @Nullable Transition<? super Bitmap> transition) {
     this.remoteViews.setImageViewBitmap(this.viewId, resource);
     this.update();
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
index 1c3e2407a..792de64a3 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
-
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.Request;
 
 /**
@@ -23,27 +23,28 @@
   private Request request;
 
   @Override
-  public void setRequest(Request request) {
+  public void setRequest(@Nullable Request request) {
     this.request = request;
   }
 
   @Override
+  @Nullable
   public Request getRequest() {
     return request;
   }
 
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
   @Override
-  public void onLoadStarted(Drawable placeholder) {
+  public void onLoadStarted(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
   @Override
-  public void onLoadFailed(Drawable errorDrawable) {
+  public void onLoadFailed(@Nullable Drawable errorDrawable) {
     // Do nothing.
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
index e71d23779..386a6a1cf 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java
@@ -8,10 +8,22 @@
  * android.graphics.Bitmap} in an {@link android.widget.ImageView}.
  */
 public class BitmapImageViewTarget extends ImageViewTarget<Bitmap> {
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public BitmapImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  // Public API.
+  @SuppressWarnings({"unused", "deprecation"})
+  @Deprecated
+  public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   /**
    * Sets the {@link android.graphics.Bitmap} on the view using {@link
    * android.widget.ImageView#setImageBitmap(android.graphics.Bitmap)}.
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
index c4b247964..90b03a62f 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java
@@ -8,11 +8,22 @@
 /**
  * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {
   public BitmapThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @SuppressWarnings("deprecation")
+  @Deprecated
+  public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   @Override
   protected Drawable getDrawable(Bitmap resource) {
     return new BitmapDrawable(view.getResources(), resource);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
index e9ab75e01..ca9c6528d 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java
@@ -13,6 +13,16 @@ public DrawableImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  // Public API.
+  @SuppressWarnings({"unused", "deprecation"})
+  @Deprecated
+  public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   @Override
   protected void setResource(@Nullable Drawable resource) {
     view.setImageDrawable(resource);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
index 416633f7c..40ff2dad4 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java
@@ -6,11 +6,22 @@
 /**
  * Efficiently displays multiple Drawables loaded serially into a single {@link android.view.View}.
  */
+// Public API.
+@SuppressWarnings("unused")
 public class DrawableThumbnailImageViewTarget extends ThumbnailImageViewTarget<Drawable> {
   public DrawableThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @Deprecated
+  @SuppressWarnings("deprecation")
+  public DrawableThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   @Override
   protected Drawable getDrawable(Drawable resource) {
     return resource;
diff --git a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
index f58eceda3..154bdc3eb 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.request.target;
 
-import android.annotation.TargetApi;
 import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
@@ -10,8 +9,10 @@
 import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A wrapper drawable to square the wrapped drawable so that it expands to fill a square with
@@ -27,6 +28,8 @@
   private State state;
   private boolean mutated;
 
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public FixedSizeDrawable(Drawable wrapped, int width, int height) {
     this(new State(wrapped.getConstantState(), width, height), wrapped);
   }
@@ -51,7 +54,7 @@ public void setBounds(int left, int top, int right, int bottom) {
   }
 
   @Override
-  public void setBounds(Rect bounds) {
+  public void setBounds(@NonNull Rect bounds) {
     super.setBounds(bounds);
     this.bounds.set(bounds);
     updateMatrix();
@@ -71,6 +74,7 @@ public int getChangingConfigurations() {
     return wrapped.getChangingConfigurations();
   }
 
+  @Deprecated
   @Override
   public void setDither(boolean dither) {
     wrapped.setDither(dither);
@@ -81,20 +85,19 @@ public void setFilterBitmap(boolean filter) {
     wrapped.setFilterBitmap(filter);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @Override
   public Callback getCallback() {
     return wrapped.getCallback();
   }
 
-  @TargetApi(Build.VERSION_CODES.KITKAT)
+  @RequiresApi(Build.VERSION_CODES.KITKAT)
   @Override
   public int getAlpha() {
     return wrapped.getAlpha();
   }
 
   @Override
-  public void setColorFilter(int color, PorterDuff.Mode mode) {
+  public void setColorFilter(int color, @NonNull PorterDuff.Mode mode) {
     wrapped.setColorFilter(color, mode);
   }
 
@@ -103,6 +106,7 @@ public void clearColorFilter() {
     wrapped.clearColorFilter();
   }
 
+  @NonNull
   @Override
   public Drawable getCurrent() {
     return wrapped.getCurrent();
@@ -134,7 +138,7 @@ public int getMinimumHeight() {
   }
 
   @Override
-  public boolean getPadding(Rect padding) {
+  public boolean getPadding(@NonNull Rect padding) {
     return wrapped.getPadding(padding);
   }
 
@@ -145,19 +149,19 @@ public void invalidateSelf() {
   }
 
   @Override
-  public void unscheduleSelf(Runnable what) {
+  public void unscheduleSelf(@NonNull Runnable what) {
     super.unscheduleSelf(what);
     wrapped.unscheduleSelf(what);
   }
 
   @Override
-  public void scheduleSelf(Runnable what, long when) {
+  public void scheduleSelf(@NonNull Runnable what, long when) {
     super.scheduleSelf(what, when);
     wrapped.scheduleSelf(what, when);
   }
 
   @Override
-  public void draw(Canvas canvas) {
+  public void draw(@NonNull Canvas canvas) {
     canvas.save();
     canvas.concat(matrix);
     wrapped.draw(canvas);
@@ -179,6 +183,7 @@ public int getOpacity() {
     return wrapped.getOpacity();
   }
 
+  @NonNull
   @Override
   public Drawable mutate() {
     if (!mutated && super.mutate() == this) {
@@ -194,10 +199,10 @@ public ConstantState getConstantState() {
     return state;
   }
 
-  static class State extends ConstantState {
+  static final class State extends ConstantState {
     private final ConstantState wrapped;
-    private final int width;
-    private final int height;
+    @Synthetic final int width;
+    @Synthetic final int height;
 
     State(State other) {
       this(other.wrapped, other.width, other.height);
@@ -209,11 +214,13 @@ public ConstantState getConstantState() {
       this.height = height;
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable() {
       return new FixedSizeDrawable(this, wrapped.newDrawable());
     }
 
+    @NonNull
     @Override
     public Drawable newDrawable(Resources res) {
       return new FixedSizeDrawable(this, wrapped.newDrawable(res));
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index 85ed326a4..6f270b9a6 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -2,9 +2,9 @@
 
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.widget.ImageView;
-
 import com.bumptech.glide.request.transition.Transition;
 
 /**
@@ -14,6 +14,8 @@
  * @param <Z> The type of resource that this target will display in the wrapped {@link
  *            android.widget.ImageView}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z>
     implements Transition.ViewAdapter {
 
@@ -24,6 +26,15 @@ public ImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @SuppressWarnings({"deprecation"})
+  @Deprecated
+  public ImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   /**
    * Returns the current {@link android.graphics.drawable.Drawable} being displayed in the view
    * using {@link android.widget.ImageView#getDrawable()}.
@@ -54,7 +65,7 @@ public void setDrawable(Drawable drawable) {
   @Override
   public void onLoadStarted(@Nullable Drawable placeholder) {
     super.onLoadStarted(placeholder);
-    setResource(null);
+    setResourceInternal(null);
     setDrawable(placeholder);
   }
 
@@ -67,7 +78,7 @@ public void onLoadStarted(@Nullable Drawable placeholder) {
   @Override
   public void onLoadFailed(@Nullable Drawable errorDrawable) {
     super.onLoadFailed(errorDrawable);
-    setResource(null);
+    setResourceInternal(null);
     setDrawable(errorDrawable);
   }
 
@@ -80,19 +91,19 @@ public void onLoadFailed(@Nullable Drawable errorDrawable) {
   @Override
   public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
-    setResource(null);
+    if (animatable != null) {
+      animatable.stop();
+    }
+    setResourceInternal(null);
     setDrawable(placeholder);
   }
 
   @Override
-  public void onResourceReady(Z resource, @Nullable Transition<? super Z> transition) {
+  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
     if (transition == null || !transition.transition(resource, this)) {
-      setResource(resource);
-    }
-
-    if (resource instanceof Animatable) {
-      animatable = (Animatable) resource;
-      animatable.start();
+      setResourceInternal(resource);
+    } else {
+      maybeUpdateAnimatable(resource);
     }
   }
 
@@ -110,6 +121,22 @@ public void onStop() {
     }
   }
 
+  private void setResourceInternal(@Nullable Z resource) {
+    // Order matters here. Set the resource first to make sure that the Drawable has a valid and
+    // non-null Callback before starting it.
+    setResource(resource);
+    maybeUpdateAnimatable(resource);
+  }
+
+  private void maybeUpdateAnimatable(@Nullable Z resource) {
+    if (resource instanceof Animatable) {
+      animatable = (Animatable) resource;
+      animatable.start();
+    } else {
+      animatable = null;
+    }
+  }
+
   protected abstract void setResource(@Nullable Z resource);
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
index 33454b46a..2e91ac594 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.widget.ImageView;
 
 /**
@@ -9,13 +10,14 @@
  * {@link com.bumptech.glide.request.target.Target} for a given {@link android.view.View} subclass.
  */
 public class ImageViewTargetFactory {
-
+  @NonNull
   @SuppressWarnings("unchecked")
-  public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {
+  public <Z> ViewTarget<ImageView, Z> buildTarget(@NonNull ImageView view,
+      @NonNull Class<Z> clazz) {
     if (Bitmap.class.equals(clazz)) {
-      return (Target<Z>) new BitmapImageViewTarget(view);
+      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
     } else if (Drawable.class.isAssignableFrom(clazz)) {
-      return (Target<Z>) new DrawableImageViewTarget(view);
+      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
     } else {
       throw new IllegalArgumentException(
           "Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)");
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index ec889d0ad..393b40cf1 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -5,8 +5,9 @@
 import android.app.NotificationManager;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.widget.RemoteViews;
-
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
 
@@ -17,11 +18,13 @@
  * <p> Note - For cancellation to work correctly, you must pass in the same instance of this class
  * for every subsequent load. </p>
  */
+// Public API.
+@SuppressWarnings({"WeakerAccess", "unused"})
 public class NotificationTarget extends SimpleTarget<Bitmap> {
-
   private final RemoteViews remoteViews;
   private final Context context;
   private final int notificationId;
+  private final String notificationTag;
   private final Notification notification;
   private final int viewId;
 
@@ -31,34 +34,57 @@
    * height.
    *
    * @param context        Context to use in the AppWidgetManager initialization.
+   * @param viewId         The id of the ImageView view that will load the image.
    * @param remoteViews    RemoteViews object which contains the ImageView that will load the
    *                       bitmap.
-   * @param viewId         The id of the ImageView view that will load the image.
    * @param notification   The Notification object that we want to update.
    * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
    */
-  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
-      Notification notification, int notificationId) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, notification, notificationId);
+  public NotificationTarget(Context context,
+      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {
+    this(context, viewId, remoteViews, notification, notificationId, null);
   }
 
   /**
-   * Constructor using a Notification object and a notificationId to get a handle on the
-   * Notification in order to update it.
+   * Constructor using a Notification object, a notificationId, and a notificationTag to get a
+   * handle on the Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the
+   * target width and height.
    *
-   * @param context        Context to use in the AppWidgetManager initialization.
-   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
-   *                       bitmap.
-   * @param viewId         The id of the ImageView view that will load the image.
-   * @param width          Desired width of the bitmap that will be loaded.(Need to be manually put
-   *                       because of RemoteViews limitations.)
-   * @param height         Desired height of the bitmap that will be loaded. (Need to be manually
-   *                       put because of RemoteViews limitations.)
-   * @param notification   The Notification object that we want to update.
-   * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
+   * @param context         Context to use in the AppWidgetManager initialization.
+   * @param viewId          The id of the ImageView view that will load the image.
+   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
+   *                        bitmap.
+   * @param notification    The Notification object that we want to update.
+   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param notificationTag The notificationTag of the Notification that we want to load the Bitmap.
+   *                        May be {@code null}.
+   */
+  public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,
+      Notification notification, int notificationId, String notificationTag) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId,
+        notificationTag);
+  }
+
+  /**
+   * Constructor using a Notification object, a notificationId, and a notificationTag to get a
+   * handle on the Notification in order to update it.
+   *
+   * @param context         Context to use in the AppWidgetManager initialization.
+   * @param width           Desired width of the bitmap that will be loaded.(Need to be manually put
+   *                        because of RemoteViews limitations.)
+   * @param height          Desired height of the bitmap that will be loaded. (Need to be manually
+   *                        put because of RemoteViews limitations.)
+   * @param viewId          The id of the ImageView view that will load the image.
+   * @param remoteViews     RemoteViews object which contains the ImageView that will load the
+   *                        bitmap.
+   * @param notification    The Notification object that we want to update.
+   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap.
+   * @param notificationTag The notificationTag of the Notification that we want to load the
+   *                        Bitmap. May be {@code null}.
    */
-  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, Notification notification, int notificationId) {
+  public NotificationTarget(Context context, int width, int height, int viewId,
+      RemoteViews remoteViews, Notification notification, int notificationId,
+      String notificationTag) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context must not be null!");
     this.notification =
@@ -67,6 +93,7 @@ public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
         Preconditions.checkNotNull(remoteViews, "RemoteViews object can not be null!");
     this.viewId = viewId;
     this.notificationId = notificationId;
+    this.notificationTag = notificationTag;
   }
 
   /**
@@ -75,11 +102,13 @@ public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
   private void update() {
     NotificationManager manager =
         (NotificationManager) this.context.getSystemService(Context.NOTIFICATION_SERVICE);
-    manager.notify(this.notificationId, this.notification);
+    Preconditions.checkNotNull(manager)
+        .notify(this.notificationTag, this.notificationId, this.notification);
   }
 
   @Override
-  public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+  public void onResourceReady(@NonNull Bitmap resource,
+      @Nullable Transition<? super Bitmap> transition) {
     this.remoteViews.setImageViewBitmap(this.viewId, resource);
     this.update();
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
index 7b9f884a9..903522fc0 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
@@ -1,7 +1,14 @@
 package com.bumptech.glide.request.target;
 
+import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A one time use {@link com.bumptech.glide.request.target.Target} class that loads a resource into
@@ -10,6 +17,17 @@
  * @param <Z> The type of resource that will be loaded into memory.
  */
 public final class PreloadTarget<Z> extends SimpleTarget<Z> {
+  private static final int MESSAGE_CLEAR = 1;
+  private static final Handler HANDLER = new Handler(Looper.getMainLooper(), new Callback() {
+    @Override
+    public boolean handleMessage(Message message) {
+      if (message.what == MESSAGE_CLEAR) {
+        ((PreloadTarget<?>) message.obj).clear();
+        return true;
+      }
+      return false;
+    }
+  });
 
   private final RequestManager requestManager;
 
@@ -30,7 +48,12 @@ private PreloadTarget(RequestManager requestManager, int width, int height) {
   }
 
   @Override
-  public void onResourceReady(Z resource, Transition<? super Z> transition) {
+  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
+    HANDLER.obtainMessage(MESSAGE_CLEAR, this).sendToTarget();
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void clear() {
     requestManager.clear(this);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index 1199c6870..4c2143ab1 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -1,28 +1,64 @@
 package com.bumptech.glide.request.target;
 
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.view.View;
 import com.bumptech.glide.util.Util;
 
 /**
- * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually noop)
+ * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually no-op)
  * implementations of non essential methods that allows the caller to specify an exact width/height.
- * Typicaly use cases look something like this:
+ * Typically use cases look something like this:
  * <pre>
  * <code>
- * Glide.load("http://somefakeurl.com/fakeImage.jpeg")
- *      .asBitmap()
- *      .withFitCenter()
- *      .into(new SimpleTarget<Bitmap>(250, 250) {
+ * Target<Bitmap> target =
+ *     Glide.with(fragment)
+ *       .asBitmap()
+ *       .load("http://somefakeurl.com/fakeImage.jpeg")
+ *       .apply(fitCenterTransform())
+ *       .into(new SimpleTarget<Bitmap>(250, 250) {
  *
- *          {@literal @Override}
- *          public void onResourceReady(Bitmap resource, GlideAnimation<Bitmap> glideAnimation) {
- *              // Do something with bitmap here.
- *          }
+ *         {@literal @Override}
+ *         public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {
+ *           // Do something with bitmap here.
+ *         }
  *
- *      });
+ *       });
  * }
+ * // At some later point, clear the Target to release the resources, prevent load queues from
+ * // blowing out proportion, and to improve load times for future requests:
+ * Glide.with(fragment).clear(target);
  * </code>
  * </pre>
  *
+ * <p><em>Warning!</em> this class is extremely prone to mis-use. Use SimpleTarget only as a last
+ * resort. {@link ViewTarget} or a subclass of {@link ViewTarget} is almost always a better choice.
+ *
+ * <p><em>Don't forget to clear instances of this class!</em>. If you must use this class, keep in
+ * mind that unlike {@link ViewTarget} it is not safe to load into new instances of this class
+ * repeatedly if every instance updates the same underlying {@link View} or caller. If you need to
+ * load into the same {@link View} or caller repeatedly using this class, always retain a reference
+ * to the previous instance and either call {@link com.bumptech.glide.RequestManager#clear(Target)}
+ * on the old instance before starting a new load or you must re-use the old instance for the new
+ * load. Glide's {@link com.bumptech.glide.RequestBuilder#into(Target)} method returns the
+ * {@link Target} instance you provided to make retaining a reference to the {@link Target} as easy
+ * as possible. That said, you must wait until you're completely finished with the resource before
+ * calling {@link com.bumptech.glide.RequestManager#clear(Target)} and you should always null out
+ * references to any loaded resources in {@link Target#onLoadCleared(Drawable)}.
+ *
+ * <p>Always try to provide a size when using this class. Use
+ * {@link SimpleTarget#SimpleTarget(int, int)} whenever possible with values that are <em>not</em>
+ * {@link Target#SIZE_ORIGINAL}. Using {@link Target#SIZE_ORIGINAL} is unsafe if you're loading
+ * large images or are running your application on older or memory constrained devices because it
+ * can cause Glide to load very large images into memory. In some cases those images may throw
+ * {@link OutOfMemoryError} and in others they may exceed the texture limit for the device, which
+ * will prevent them from being rendered. Providing a valid size allows Glide to downsample large
+ * images, which can avoid issues with texture size or memory limitations. You don't have to worry
+ * about providing a size in most cases if you use {@link ViewTarget} so prefer {@link ViewTarget}
+ * over this class whenver possible.
+ *
+ * @see <a href="http://bumptech.github.io/glide/doc/targets.html">Glide's Target docs page</a>
+ *
  * @param <Z> The type of resource that this target will receive.
  */
 public abstract class SimpleTarget<Z> extends BaseTarget<Z> {
@@ -33,6 +69,8 @@
    * Constructor for the target that uses {@link Target#SIZE_ORIGINAL} as the target width and
    * height.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public SimpleTarget() {
     this(SIZE_ORIGINAL, SIZE_ORIGINAL);
   }
@@ -44,6 +82,8 @@ public SimpleTarget() {
    * @param width  The width in pixels of the desired resource.
    * @param height The height in pixels of the desired resource.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public SimpleTarget(int width, int height) {
     this.width = width;
     this.height = height;
@@ -55,7 +95,7 @@ public SimpleTarget(int width, int height) {
    * @param cb {@inheritDoc}
    */
   @Override
-  public final void getSize(SizeReadyCallback cb) {
+  public final void getSize(@NonNull SizeReadyCallback cb) {
     if (!Util.isValidDimensions(width, height)) {
       throw new IllegalArgumentException(
           "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given" + " width: "
@@ -64,4 +104,9 @@ public final void getSize(SizeReadyCallback cb) {
     }
     cb.onSizeReady(width, height);
   }
+
+  @Override
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
+    // Do nothing, we never retain a reference to the callback.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index 2245adace..3aa385ce5 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.manager.LifecycleListener;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
@@ -31,11 +31,15 @@
    * A lifecycle callback that is called when a load is started.
    *
    * <p> Note - This may not be called for every load, it is possible for example for loads to fail
-   * before the load starts (when the model object is null). </p>
+   * before the load starts (when the model object is null).
    *
    * <p> Note - This method may be called multiple times before any other lifecycle method is
    * called. Loads can be paused and restarted due to lifecycle or connectivity events and each
-   * restart may cause a call here. </p>
+   * restart may cause a call here.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
@@ -45,7 +49,11 @@
    * A lifecycle callback that is called when a load fails.
    *
    * <p> Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)
-   * } if the model object is null. </p>
+   * } if the model object is null.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param errorDrawable The error drawable to optionally show, or null.
    */
@@ -56,11 +64,15 @@
    *
    * @param resource the loaded resource.
    */
-  void onResourceReady(R resource, Transition<? super R> transition);
+  void onResourceReady(@NonNull R resource, @Nullable Transition<? super R> transition);
 
   /**
    * A lifecycle callback that is called when a load is cancelled and its resources are freed.
    *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
+   *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
   void onLoadCleared(@Nullable Drawable placeholder);
@@ -70,7 +82,14 @@
    *
    * @param cb The callback that must be called when the size of the target has been determined
    */
-  void getSize(SizeReadyCallback cb);
+  void getSize(@NonNull SizeReadyCallback cb);
+
+  /**
+   * Removes the given callback from the pending set if it's still retained.
+   *
+   * @param cb The callback to remove.
+   */
+  void removeCallback(@NonNull SizeReadyCallback cb);
 
   /**
    * Sets the current request for this target to retain, should not be called outside of Glide.
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
index 84306618b..043d31daf 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ThumbnailImageViewTarget.java
@@ -14,18 +14,29 @@
  * com.bumptech.glide.RequestBuilder#thumbnail(com.bumptech.glide.RequestBuilder)} API into views in
  * a scrolling list like ListView, GridView, or RecyclerView.
  *
- * <p>{@link FixedSizeDrawable} may cause skewing or other undesireable behavior depending on
+ * <p>{@link FixedSizeDrawable} may cause skewing or other undesirable behavior depending on
  * your images, views, and scaling. If this occurs, consider {@link DrawableImageViewTarget} or
  * {@link BitmapImageViewTarget} as alternatives.
  *
  * @param <T> The type of resource that will be displayed in the ImageView.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public abstract class ThumbnailImageViewTarget<T> extends ImageViewTarget<T> {
 
   public ThumbnailImageViewTarget(ImageView view) {
     super(view);
   }
 
+  /**
+   * @deprecated Use {@link #waitForLayout()} insetad.
+   */
+  @Deprecated
+  @SuppressWarnings({"deprecation"})
+  public ThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {
+    super(view, waitForLayout);
+  }
+
   @Override
   protected void setResource(@Nullable T resource) {
     ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 336d4b069..635b6b5d0 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -1,21 +1,22 @@
 package com.bumptech.glide.request.target;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
+import android.support.annotation.CallSuper;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
 import android.view.Display;
 import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
 import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
-
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.List;
@@ -42,20 +43,159 @@
  */
 public abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {
   private static final String TAG = "ViewTarget";
-  private static boolean isTagUsedAtLeastOnce = false;
-  @Nullable private static Integer tagId = null;
+  private static boolean isTagUsedAtLeastOnce;
+  @Nullable private static Integer tagId;
 
   protected final T view;
   private final SizeDeterminer sizeDeterminer;
+  @Nullable
+  private OnAttachStateChangeListener attachStateListener;
+  private boolean isClearedByUs;
+  private boolean isAttachStateListenerAdded;
 
-  public ViewTarget(T view) {
+
+  /**
+   * Constructor that defaults {@code waitForLayout} to {@code false}.
+   */
+  public ViewTarget(@NonNull T view) {
     this.view = Preconditions.checkNotNull(view);
     sizeDeterminer = new SizeDeterminer(view);
   }
 
+  /**
+   * @param waitForLayout If set to {@code true}, Glide will always wait for any pending layout pass
+   * before checking for the size a View. If set to {@code false} Glide will only wait for a pending
+   * layout pass if it's unable to resolve the size from layout parameters or an existing View size.
+   * Because setting this parameter to {@code true} forces Glide to wait for the layout pass to
+   * occur before starting the load, setting this parameter to {@code true} can cause flashing in
+   * some cases and should be used sparingly. If layout parameters are set to fixed sizes, they will
+   * still be used instead of the View's dimensions even if this parameter is set to {@code true}.
+   * This parameter is a fallback only.
+   *
+   * @deprecated Use {@link #waitForLayout()} instead.
+   */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @Deprecated
+  public ViewTarget(@NonNull T view, boolean waitForLayout) {
+    this(view);
+    if (waitForLayout) {
+      waitForLayout();
+    }
+  }
+
+  /**
+   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its
+   * {@link android.view.Window} and restarts the {@link Request} when the {@link View} is
+   * re-attached from its {@link android.view.Window}.
+   *
+   * <p>This is an experimental API that may be removed in a future version.
+   *
+   * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when
+   * transitioning screens or swapping adapters in scrolling views. However it also substantially
+   * increases the odds that images will not be in memory if users subsequently return to a screen
+   * where images were previously loaded. Whether or not this happens will depend on the number
+   * of images loaded in the new screen and the size of the memory cache. Increasing the size of
+   * the memory cache can improve this behavior but it largely negates the memory benefits of using
+   * this method.
+   *
+   * <p>Use this method with caution and measure your memory usage to ensure that it's actually
+   * improving your memory usage in the cases you care about.
+   */
+  // Public API.
+  @NonNull
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  public final ViewTarget<T, Z> clearOnDetach() {
+    if (attachStateListener != null) {
+      return this;
+    }
+    attachStateListener = new OnAttachStateChangeListener() {
+      @Override
+      public void onViewAttachedToWindow(View v) {
+        resumeMyRequest();
+      }
+
+      @Override
+      public void onViewDetachedFromWindow(View v) {
+        pauseMyRequest();
+      }
+    };
+    maybeAddAttachStateListener();
+    return this;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void resumeMyRequest() {
+    Request request = getRequest();
+    if (request != null && request.isPaused()) {
+      request.begin();
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic void pauseMyRequest() {
+    Request request = getRequest();
+    if (request != null && !request.isCancelled() && !request.isPaused()) {
+      isClearedByUs = true;
+      request.pause();
+      isClearedByUs = false;
+    }
+  }
+
+  /**
+   * Indicates that Glide should always wait for any pending layout pass before checking
+   * for the size an {@link View}.
+   *
+   * <p>By default, Glide will only wait for a pending layout pass if it's unable to resolve the
+   * size from the {@link LayoutParams} or valid non-zero values for {@link View#getWidth()} and
+   * {@link View#getHeight()}.
+   *
+   * <p>Because calling this method forces Glide to wait for the layout pass to occur before
+   * starting loads, setting this parameter to {@code true} can cause Glide to asynchronous load
+   * an image even if it's in the memory cache. The load will happen asynchronously because Glide
+   * has to wait for a layout pass to occur, which won't necessarily happen in the same frame as
+   * when the image is requested. As a result, using this method can resulting in flashing in some
+   * cases and should be used sparingly.
+   *
+   * <p>If the {@link LayoutParams} of the wrapped {@link View} are set to fixed sizes, they will
+   * still be used instead of the {@link View}'s dimensions even if this method is called. This
+   * parameter is a fallback only.
+   */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public final ViewTarget<T, Z> waitForLayout() {
+    sizeDeterminer.waitForLayout = true;
+    return this;
+  }
+
+  @CallSuper
+  @Override
+  public void onLoadStarted(@Nullable Drawable placeholder) {
+    super.onLoadStarted(placeholder);
+    maybeAddAttachStateListener();
+  }
+
+  private void maybeAddAttachStateListener() {
+    if (attachStateListener == null || isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.addOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = true;
+  }
+
+  private void maybeRemoveAttachStateListener() {
+    if (attachStateListener == null || !isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.removeOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = false;
+  }
+
   /**
    * Returns the wrapped {@link android.view.View}.
    */
+  @NonNull
   public T getView() {
     return view;
   }
@@ -69,15 +209,27 @@ public T getView() {
    *
    * @param cb {@inheritDoc}
    */
+  @CallSuper
   @Override
-  public void getSize(SizeReadyCallback cb) {
+  public void getSize(@NonNull SizeReadyCallback cb) {
     sizeDeterminer.getSize(cb);
   }
 
+  @CallSuper
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void removeCallback(@NonNull SizeReadyCallback cb) {
+    sizeDeterminer.removeCallback(cb);
+  }
+
+  @CallSuper
+  @Override
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
     sizeDeterminer.clearCallbacksAndListener();
+
+    if (!isClearedByUs) {
+      maybeRemoveAttachStateListener();
+    }
   }
 
   /**
@@ -158,41 +310,65 @@ private Object getTag() {
    *
    * @param tagId The android resource to use.
    */
+  // Public API.
+  @SuppressWarnings("unused")
   public static void setTagId(int tagId) {
-      if (ViewTarget.tagId != null || isTagUsedAtLeastOnce) {
-          throw new IllegalArgumentException("You cannot set the tag id more than once or change"
-              + " the tag id after the first request has been made");
-      }
-      ViewTarget.tagId = tagId;
+    if (ViewTarget.tagId != null || isTagUsedAtLeastOnce) {
+      throw new IllegalArgumentException("You cannot set the tag id more than once or change"
+          + " the tag id after the first request has been made");
+    }
+    ViewTarget.tagId = tagId;
   }
 
-  private static class SizeDeterminer {
-    // Some negative sizes (WRAP_CONTENT) are valid, 0 is never valid.
+  @VisibleForTesting
+  static final class SizeDeterminer {
+    // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
     private static final int PENDING_SIZE = 0;
+    @VisibleForTesting
+    @Nullable
+    static Integer maxDisplayLength;
     private final View view;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
+    @Synthetic boolean waitForLayout;
 
     @Nullable private SizeDeterminerLayoutListener layoutListener;
-    @Nullable private Point displayDimens;
 
-    public SizeDeterminer(View view) {
+    SizeDeterminer(@NonNull View view) {
       this.view = view;
     }
 
+    // Use the maximum to avoid depending on the device's current orientation.
+    private static int getMaxDisplayLength(@NonNull Context context) {
+      if (maxDisplayLength == null) {
+        WindowManager windowManager =
+            (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
+        Point displayDimensions = new Point();
+        display.getSize(displayDimensions);
+        maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);
+      }
+      return maxDisplayLength;
+    }
+
     private void notifyCbs(int width, int height) {
-      for (SizeReadyCallback cb : cbs) {
+      // One or more callbacks may trigger the removal of one or more additional callbacks, so we
+      // need a copy of the list to avoid a concurrent modification exception. One place this
+      // happens is when a full request completes from the in memory cache while its thumbnail is
+      // still being loaded asynchronously. See #2237.
+      for (SizeReadyCallback cb : new ArrayList<>(cbs)) {
         cb.onSizeReady(width, height);
       }
     }
 
-    private void checkCurrentDimens() {
+    @Synthetic
+    void checkCurrentDimens() {
       if (cbs.isEmpty()) {
         return;
       }
 
-      int currentWidth = getViewWidthOrParam();
-      int currentHeight = getViewHeightOrParam();
-      if (!isSizeValid(currentWidth) || !isSizeValid(currentHeight)) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (!isViewStateAndSizeValid(currentWidth, currentHeight)) {
         return;
       }
 
@@ -200,32 +376,42 @@ private void checkCurrentDimens() {
       clearCallbacksAndListener();
     }
 
-    void getSize(SizeReadyCallback cb) {
-      int currentWidth = getViewWidthOrParam();
-      int currentHeight = getViewHeightOrParam();
-      if (isSizeValid(currentWidth) && isSizeValid(currentHeight)) {
+    void getSize(@NonNull SizeReadyCallback cb) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
         cb.onSizeReady(currentWidth, currentHeight);
-      } else {
-        // We want to notify callbacks in the order they were added and we only expect one or two
-        // callbacks to
-        // be added a time, so a List is a reasonable choice.
-        if (!cbs.contains(cb)) {
-          cbs.add(cb);
-        }
-        if (layoutListener == null) {
-          final ViewTreeObserver observer = view.getViewTreeObserver();
-          layoutListener = new SizeDeterminerLayoutListener(this);
-          observer.addOnPreDrawListener(layoutListener);
-        }
+        return;
+      }
+
+      // We want to notify callbacks in the order they were added and we only expect one or two
+      // callbacks to be added a time, so a List is a reasonable choice.
+      if (!cbs.contains(cb)) {
+        cbs.add(cb);
+      }
+      if (layoutListener == null) {
+        ViewTreeObserver observer = view.getViewTreeObserver();
+        layoutListener = new SizeDeterminerLayoutListener(this);
+        observer.addOnPreDrawListener(layoutListener);
       }
     }
 
+    /**
+     * The callback may be called anyway if it is removed by another {@link SizeReadyCallback} or
+     * otherwise removed while we're notifying the list of callbacks.
+     *
+     * <p>See #2237.
+     */
+    void removeCallback(@NonNull SizeReadyCallback cb) {
+      cbs.remove(cb);
+    }
+
     void clearCallbacksAndListener() {
-      // Keep a reference to the layout listener and remove it here
+      // Keep a reference to the layout attachStateListener and remove it here
       // rather than having the observer remove itself because the observer
-      // we add the listener to will be almost immediately merged into
+      // we add the attachStateListener to will be almost immediately merged into
       // another observer and will therefore never be alive. If we instead
-      // keep a reference to the listener and remove it here, we get the
+      // keep a reference to the attachStateListener and remove it here, we get the
       // current view tree observer and should succeed.
       ViewTreeObserver observer = view.getViewTreeObserver();
       if (observer.isAlive()) {
@@ -235,71 +421,97 @@ void clearCallbacksAndListener() {
       cbs.clear();
     }
 
-    private int getViewHeightOrParam() {
-      final LayoutParams layoutParams = view.getLayoutParams();
-      if (isSizeValid(view.getHeight())) {
-        return view.getHeight();
-      } else if (layoutParams != null) {
-        return getSizeForParam(layoutParams.height, true /*isHeight*/);
-      } else {
-        return PENDING_SIZE;
-      }
+    private boolean isViewStateAndSizeValid(int width, int height) {
+      return isDimensionValid(width) && isDimensionValid(height);
     }
 
-    private int getViewWidthOrParam() {
-      final LayoutParams layoutParams = view.getLayoutParams();
-      if (isSizeValid(view.getWidth())) {
-        return view.getWidth();
-      } else if (layoutParams != null) {
-        return getSizeForParam(layoutParams.width, false /*isHeight*/);
-      } else {
-        return PENDING_SIZE;
-      }
+    private int getTargetHeight() {
+      int verticalPadding = view.getPaddingTop() + view.getPaddingBottom();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.height : PENDING_SIZE;
+      return getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);
     }
 
-    private int getSizeForParam(int param, boolean isHeight) {
-      if (param == LayoutParams.WRAP_CONTENT) {
-        Point displayDimens = getDisplayDimens();
-        return isHeight ? displayDimens.y : displayDimens.x;
-      } else {
-        return param;
-      }
+    private int getTargetWidth() {
+      int horizontalPadding = view.getPaddingLeft() + view.getPaddingRight();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.width : PENDING_SIZE;
+      return getTargetDimen(view.getWidth(), layoutParamSize, horizontalPadding);
     }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
-    @SuppressWarnings("deprecation")
-    private Point getDisplayDimens() {
-      if (displayDimens != null) {
-        return displayDimens;
+    private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
+      // We consider the View state as valid if the View has non-null layout params and a non-zero
+      // layout params width and height. This is imperfect. We're making an assumption that View
+      // parents will obey their child's layout parameters, which isn't always the case.
+      int adjustedParamSize = paramSize - paddingSize;
+      if (adjustedParamSize > 0) {
+        return adjustedParamSize;
       }
-      WindowManager windowManager =
-          (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
-      Display display = windowManager.getDefaultDisplay();
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
-        displayDimens = new Point();
-        display.getSize(displayDimens);
-      } else {
-        displayDimens = new Point(display.getWidth(), display.getHeight());
+
+      // Since we always prefer layout parameters with fixed sizes, even if waitForLayout is true,
+      // we might as well ignore it and just return the layout parameters above if we have them.
+      // Otherwise we should wait for a layout pass before checking the View's dimensions.
+      if (waitForLayout && view.isLayoutRequested()) {
+        return PENDING_SIZE;
+      }
+
+      // We also consider the View state valid if the View has a non-zero width and height. This
+      // means that the View has gone through at least one layout pass. It does not mean the Views
+      // width and height are from the current layout pass. For example, if a View is re-used in
+      // RecyclerView or ListView, this width/height may be from an old position. In some cases
+      // the dimensions of the View at the old position may be different than the dimensions of the
+      // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to
+      // change them. Nevertheless, in most cases this should be a reasonable choice.
+      int adjustedViewSize = viewSize - paddingSize;
+      if (adjustedViewSize > 0) {
+        return adjustedViewSize;
       }
-      return displayDimens;
+
+      // Finally we consider the view valid if the layout parameter size is set to wrap_content.
+      // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a
+      // coherent choice, it's extremely dangerous because original images may be much too large to
+      // fit in memory or so large that only a couple can fit in memory, causing OOMs. If users want
+      // the original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content
+      // may never resolve to a real size unless we load something, we aim for a square whose length
+      // is the largest screen size. That way we're loading something and that something has some
+      // hope of being downsampled to a size that the device can support. We also log a warning that
+      // tries to explain what Glide is doing and why some alternatives are preferable.
+      // Since WRAP_CONTENT is sometimes used as a default layout parameter, we always wait for
+      // layout to complete before using this fallback parameter (ConstraintLayout among others).
+      if (!view.isLayoutRequested() && paramSize == LayoutParams.WRAP_CONTENT) {
+        if (Log.isLoggable(TAG, Log.INFO)) {
+          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
+              + " this device's screen dimensions. If you want to load the original image and are"
+              + " ok with the corresponding memory cost and OOMs (depending on the input size), use"
+              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set"
+              + " layout_width and layout_height to fixed dimension, or use .override() with fixed"
+              + " dimensions.");
+        }
+        return getMaxDisplayLength(view.getContext());
+      }
+
+      // If the layout parameters are < padding, the view size is < padding, or the layout
+      // parameters are set to match_parent or wrap_content and no layout has occurred, we should
+      // wait for layout and repeat.
+      return PENDING_SIZE;
     }
 
-    private boolean isSizeValid(int size) {
-      return size > 0 || size == LayoutParams.WRAP_CONTENT;
+    private boolean isDimensionValid(int size) {
+      return size > 0 || size == SIZE_ORIGINAL;
     }
 
-    private static class SizeDeterminerLayoutListener implements ViewTreeObserver
-        .OnPreDrawListener {
+    private static final class SizeDeterminerLayoutListener
+        implements ViewTreeObserver.OnPreDrawListener {
       private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
-      public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
+      SizeDeterminerLayoutListener(@NonNull SizeDeterminer sizeDeterminer) {
         sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
       }
 
       @Override
       public boolean onPreDraw() {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
-          Log.v(TAG, "OnGlobalLayoutListener called listener=" + this);
+          Log.v(TAG, "OnGlobalLayoutListener called attachStateListener=" + this);
         }
         SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
         if (sizeDeterminer != null) {
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
new file mode 100644
index 000000000..8bec74e45
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.request.transition;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.load.DataSource;
+
+/**
+ * A {@link TransitionFactory} for complex types that have a {@link android.graphics.Bitmap} inside.
+ * The transitioning bitmap is wrapped in a {@link android.graphics.drawable.BitmapDrawable}.
+ * Most commonly used with {@link DrawableCrossFadeFactory}.
+ *
+ * @param <R> The type of the composite object that contains the {@link android.graphics.Bitmap} to
+ *            be transitioned.
+ */
+public abstract class BitmapContainerTransitionFactory<R> implements TransitionFactory<R> {
+  private final TransitionFactory<Drawable> realFactory;
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory) {
+    this.realFactory = realFactory;
+  }
+
+  @Override
+  public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
+    Transition<Drawable> transition = realFactory.build(dataSource, isFirstResource);
+    return new BitmapGlideAnimation(transition);
+  }
+
+  /**
+   * Retrieve the Bitmap from a composite object.
+   * <p><b>Warning:</b> Do not convert any arbitrary object to Bitmap
+   * via expensive drawing here, this method is called on the UI thread.</p>
+   *
+   * @param current composite object containing a Bitmap and some other information
+   * @return the Bitmap contained within {@code current}
+   */
+  protected abstract Bitmap getBitmap(R current);
+
+  private final class BitmapGlideAnimation implements Transition<R> {
+    private final Transition<Drawable> transition;
+
+    BitmapGlideAnimation(Transition<Drawable> transition) {
+      this.transition = transition;
+    }
+
+    @Override
+    public boolean transition(R current, ViewAdapter adapter) {
+      Resources resources = adapter.getView().getResources();
+      Drawable currentBitmap = new BitmapDrawable(resources, getBitmap(current));
+      return transition.transition(currentBitmap, adapter);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
new file mode 100644
index 000000000..a6982b5d5
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
@@ -0,0 +1,23 @@
+package com.bumptech.glide.request.transition;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+
+/**
+ * A {@link TransitionFactory} for {@link android.graphics.Bitmap}s that uses a Drawable transition
+ * factory to transition from an existing drawable already visible on the target to the new bitmap.
+ *
+ * @see BitmapContainerTransitionFactory
+ */
+public class BitmapTransitionFactory extends BitmapContainerTransitionFactory<Bitmap> {
+  public BitmapTransitionFactory(@NonNull TransitionFactory<Drawable> realFactory) {
+    super(realFactory);
+  }
+
+  @Override
+  @NonNull
+  protected Bitmap getBitmap(@NonNull Bitmap current) {
+    return current;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index e4e3a0d93..0a8da3056 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -1,10 +1,6 @@
 package com.bumptech.glide.request.transition;
 
-import android.content.Context;
 import android.graphics.drawable.Drawable;
-import android.view.animation.AlphaAnimation;
-import android.view.animation.Animation;
-
 import com.bumptech.glide.load.DataSource;
 
 /**
@@ -15,80 +11,72 @@
  * <p> Resources are usually loaded from the memory cache just before the user can see the view, for
  * example when the user changes screens or scrolls back and forth in a list. In those cases the
  * user typically does not expect to see a transition. As a result, when the resource is loaded from
- * the memory cache this factory produces an {@link NoTransition}. </p>
+ * the memory cache this factory produces an {@link NoTransition}.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
-  private static final int DEFAULT_DURATION_MS = 300;
-  private final ViewAnimationFactory<Drawable> viewAnimationFactory;
   private final int duration;
-  private DrawableCrossFadeTransition firstResourceTransition;
-  private DrawableCrossFadeTransition secondResourceTransition;
-
-  public DrawableCrossFadeFactory() {
-    this(DEFAULT_DURATION_MS);
-  }
-
-  public DrawableCrossFadeFactory(int duration) {
-    this(new ViewAnimationFactory<Drawable>(
-        new DefaultViewTransitionAnimationFactory(duration)), duration);
-  }
-
-  public DrawableCrossFadeFactory(int defaultAnimationId, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimationId), duration);
-  }
+  private final boolean isCrossFadeEnabled;
+  private DrawableCrossFadeTransition resourceTransition;
 
-  public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimation), duration);
-  }
-
-  DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory, int duration) {
-    this.viewAnimationFactory = viewAnimationFactory;
+  protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   @Override
   public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {
-    if (dataSource == DataSource.MEMORY_CACHE) {
-      return NoTransition.get();
-    } else if (isFirstResource) {
-      return getFirstResourceTransition(dataSource);
-    } else {
-      return getSecondResourceTransition(dataSource);
-    }
+    return dataSource == DataSource.MEMORY_CACHE
+        ? NoTransition.<Drawable>get() : getResourceTransition();
   }
 
-  private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {
-      if (firstResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(dataSource, true /*isFirstResource*/);
-          firstResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+  private Transition<Drawable> getResourceTransition() {
+      if (resourceTransition == null) {
+        resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);
       }
-      return firstResourceTransition;
+      return resourceTransition;
   }
 
-  private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {
-      if (secondResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(dataSource, false /*isFirstResource*/);
-          secondResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
-      }
-      return secondResourceTransition;
-  }
+  /**
+   * A Builder for {@link DrawableCrossFadeFactory}.
+   */
+  @SuppressWarnings("unused")
+  public static class Builder {
+    private static final int DEFAULT_DURATION_MS = 300;
+    private final int durationMillis;
+    private boolean isCrossFadeEnabled;
 
-  private static class DefaultViewTransitionAnimationFactory implements ViewTransition
-      .ViewTransitionAnimationFactory {
+    public Builder() {
+      this(DEFAULT_DURATION_MS);
+    }
 
-    private final int duration;
+    /**
+     * @param durationMillis The duration of the cross fade animation in milliseconds.
+     */
+    public Builder(int durationMillis) {
+      this.durationMillis = durationMillis;
+    }
 
-    DefaultViewTransitionAnimationFactory(int duration) {
-      this.duration = duration;
+    /**
+     * Enables or disables animating the alpha of the {@link Drawable} the cross fade will animate
+     * from.
+     *
+     * <p>Defaults to {@code false}.
+     *
+     * @param isCrossFadeEnabled If {@code true} the previous {@link Drawable}'s alpha will be
+     *     animated from 100 to 0 while the new {@link Drawable}'s alpha is
+     *     animated from 0 to 100. Otherwise the previous {@link Drawable}'s
+     *     alpha will remain at 100 throughout the animation. See
+     *     {@link android.graphics.drawable.TransitionDrawable#setCrossFadeEnabled(boolean)}
+     */
+    public Builder setCrossFadeEnabled(boolean isCrossFadeEnabled) {
+      this.isCrossFadeEnabled = isCrossFadeEnabled;
+      return this;
     }
 
-    @Override
-    public Animation build(Context context) {
-      AlphaAnimation animation = new AlphaAnimation(0f, 1f);
-      animation.setDuration(duration);
-      return animation;
+    public DrawableCrossFadeFactory build() {
+      return new DrawableCrossFadeFactory(durationMillis, isCrossFadeEnabled);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index 2cbca19c7..730d84f30 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.request.transition;
 
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
 
@@ -11,19 +13,24 @@
  * android.graphics.drawable.TransitionDrawable}.
  */
 public class DrawableCrossFadeTransition implements Transition<Drawable> {
-  private final Transition<Drawable> defaultAnimation;
   private final int duration;
+  private final boolean isCrossFadeEnabled;
 
   /**
-   * Constructor that takes a default animation and a duration in milliseconds that the cross fade
-   * animation should last.
-   *
    * @param duration The duration that the cross fade animation should run if there is something to
    *                 cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
+   * @param isCrossFadeEnabled If {@code true}, animates the previous resource's alpha to 0 while
+   *                         animating the new resource's alpha to 100. Otherwise, only animates
+   *                         the new resource's alpha to 100 while leaving the previous resource's
+   *                         alpha at 100. See
+   *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
-  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration) {
-    this.defaultAnimation = defaultAnimation;
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public DrawableCrossFadeTransition(int duration,
+      boolean isCrossFadeEnabled) {
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   /**
@@ -40,16 +47,14 @@ public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int du
   @Override
   public boolean transition(Drawable current, ViewAdapter adapter) {
     Drawable previous = adapter.getCurrentDrawable();
-    if (previous != null) {
-      TransitionDrawable transitionDrawable =
-          new TransitionDrawable(new Drawable[] { previous, current });
-      transitionDrawable.setCrossFadeEnabled(true);
-      transitionDrawable.startTransition(duration);
-      adapter.setDrawable(transitionDrawable);
-      return true;
-    } else {
-      defaultAnimation.transition(current, adapter);
-      return false;
+    if (previous == null) {
+      previous = new ColorDrawable(Color.TRANSPARENT);
     }
+    TransitionDrawable transitionDrawable =
+        new TransitionDrawable(new Drawable[] { previous, current });
+    transitionDrawable.setCrossFadeEnabled(isCrossFadeEnabled);
+    transitionDrawable.startTransition(duration);
+    adapter.setDrawable(transitionDrawable);
+    return true;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
index 5192b150b..1ef48eb2b 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request.transition;
 
 import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A simple {@link Transition} that performs no actions.
@@ -9,12 +10,15 @@
  * {@link com.bumptech.glide.request.target.Target}.
  */
 public class NoTransition<R> implements Transition<R> {
-  private static final NoTransition<?> NO_ANIMATION = new NoTransition<Object>();
+  @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<>();
   @SuppressWarnings("rawtypes")
   private static final TransitionFactory<?> NO_ANIMATION_FACTORY = new NoAnimationFactory();
 
   /**
    * A factory that always returns the same {@link NoTransition}.
+   *
+   * @param <R> the resource type that will be transitioned into a
+   * {@link com.bumptech.glide.request.target.Target}.
    */
   public static class NoAnimationFactory<R> implements TransitionFactory<R> {
     @SuppressWarnings("unchecked")
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
index 0aad3abef..e5a2cec05 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
@@ -3,7 +3,6 @@
 import android.content.Context;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
-
 import com.bumptech.glide.load.DataSource;
 
 /**
@@ -15,6 +14,8 @@
   private final ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
   private Transition<R> transition;
 
+  // Public API.
+  @SuppressWarnings("unused")
   public ViewAnimationFactory(Animation animation) {
     this(new ConcreteViewTransitionAnimationFactory(animation));
   }
@@ -53,7 +54,7 @@ public ViewAnimationFactory(int animationId) {
       .ViewTransitionAnimationFactory {
     private final Animation animation;
 
-    public ConcreteViewTransitionAnimationFactory(Animation animation) {
+    ConcreteViewTransitionAnimationFactory(Animation animation) {
       this.animation = animation;
     }
 
@@ -67,7 +68,7 @@ public Animation build(Context context) {
       .ViewTransitionAnimationFactory {
     private final int animationId;
 
-    public ResourceViewTransitionAnimationFactory(int animationId) {
+    ResourceViewTransitionAnimationFactory(int animationId) {
       this.animationId = animationId;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
index e863a83be..45e75f760 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewPropertyTransition.java
@@ -19,6 +19,8 @@
    *
    * @param animator The animator to use.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
   public ViewPropertyTransition(Animator animator) {
     this.animator = animator;
   }
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 0764fe285..21d86931d 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -3,25 +3,29 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
 import com.bumptech.glide.load.Key;
-
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * A utility class for obtaining a {@link com.bumptech.glide.load.Key} signature containing the
  * application version name using {@link android.content.pm.PackageInfo#versionCode}.
  */
 public final class ApplicationVersionSignature {
-  private static final ConcurrentHashMap<String, Key> PACKAGE_NAME_TO_KEY =
-      new ConcurrentHashMap<>();
+  private static final String TAG = "AppVersionSignature";
+  private static final ConcurrentMap<String, Key> PACKAGE_NAME_TO_KEY = new ConcurrentHashMap<>();
 
   /**
    * Returns the signature {@link com.bumptech.glide.load.Key} for version code of the Application
    * of the given Context.
    */
-  public static Key obtain(Context context) {
+  @NonNull
+  public static Key obtain(@NonNull Context context) {
     String packageName = context.getPackageName();
     Key result = PACKAGE_NAME_TO_KEY.get(packageName);
     if (result == null) {
@@ -36,26 +40,37 @@ public static Key obtain(Context context) {
     return result;
   }
 
-  // Visible for testing.
+  @VisibleForTesting
   static void reset() {
     PACKAGE_NAME_TO_KEY.clear();
   }
 
-  private static Key obtainVersionSignature(Context context) {
-    PackageInfo pInfo = null;
-    try {
-      pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
-    } catch (PackageManager.NameNotFoundException e) {
-      // Should never happen.
-      e.printStackTrace();
-    }
-    final String versionCode;
-    if (pInfo != null) {
-      versionCode = String.valueOf(pInfo.versionCode);
+  @NonNull
+  private static Key obtainVersionSignature(@NonNull Context context) {
+    PackageInfo packageInfo = getPackageInfo(context);
+    String versionCode = getVersionCode(packageInfo);
+    return new ObjectKey(versionCode);
+  }
+
+  @NonNull
+  private static String getVersionCode(@Nullable PackageInfo packageInfo) {
+    String versionCode;
+    if (packageInfo != null) {
+      versionCode = String.valueOf(packageInfo.versionCode);
     } else {
       versionCode = UUID.randomUUID().toString();
     }
-    return new StringSignature(versionCode);
+    return versionCode;
+  }
+
+  @Nullable
+  private static PackageInfo getPackageInfo(@NonNull Context context) {
+    try {
+      return context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+    } catch (PackageManager.NameNotFoundException e) {
+      Log.e(TAG, "Cannot resolve info for" + context.getPackageName(), e);
+      return null;
+    }
   }
 
   private ApplicationVersionSignature() {
diff --git a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
index 56d4c474d..2763433aa 100644
--- a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.signature;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
-
 import java.security.MessageDigest;
 
 /**
@@ -10,6 +10,7 @@
 public final class EmptySignature implements Key {
   private static final EmptySignature EMPTY_KEY = new EmptySignature();
 
+  @NonNull
   public static EmptySignature obtain() {
     return EMPTY_KEY;
   }
@@ -24,7 +25,7 @@ public String toString() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     // Do nothing.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index 37f15a62f..bb0e06b6e 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.signature;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Key;
-
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -10,7 +11,7 @@
  * media store files like edits, rotations, and temporary file replacement.
  */
 public class MediaStoreSignature implements Key {
-  private final String mimeType;
+  @NonNull private final String mimeType;
   private final long dateModified;
   private final int orientation;
 
@@ -26,12 +27,13 @@
    * @param orientation  The orientation of the media store media. Ok to default to 0. See {@link
    *                     android.provider.MediaStore.Images.ImageColumns#ORIENTATION}.
    */
-  public MediaStoreSignature(String mimeType, long dateModified, int orientation) {
-    this.mimeType = mimeType;
+  public MediaStoreSignature(@Nullable String mimeType, long dateModified, int orientation) {
+    this.mimeType = mimeType == null ? "" : mimeType;
     this.dateModified = dateModified;
     this.orientation = orientation;
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -49,23 +51,22 @@ public boolean equals(Object o) {
     if (orientation != that.orientation) {
       return false;
     }
-    if (mimeType != null ? !mimeType.equals(that.mimeType) : that.mimeType != null) {
+    if (!mimeType.equals(that.mimeType)) {
       return false;
     }
-
     return true;
   }
 
   @Override
   public int hashCode() {
-    int result = mimeType != null ? mimeType.hashCode() : 0;
+    int result = mimeType.hashCode();
     result = 31 * result + (int) (dateModified ^ (dateModified >>> 32));
     result = 31 * result + orientation;
     return result;
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     byte[] data = ByteBuffer.allocate(12).putLong(dateModified).putInt(orientation).array();
     messageDigest.update(data);
     messageDigest.update(mimeType.getBytes(CHARSET));
diff --git a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
index 0637bcada..ed3ea19e8 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.signature;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -11,13 +11,13 @@
  * method to the {@link java.security.MessageDigest} in
  * {@link #updateDiskCacheKey(java.security.MessageDigest)}.
  *
- * <p> The Object's {@link #toString()} method must be unique and suitable for use as a disk cache
- * key. </p>
+ * <p>The Object's {@link #toString()} method must be unique and suitable for use as a disk cache
+ * key.</p>
  */
 public final class ObjectKey implements Key {
   private final Object object;
 
-  public ObjectKey(Object object) {
+  public ObjectKey(@NonNull Object object) {
     this.object = Preconditions.checkNotNull(object);
   }
 
@@ -43,7 +43,7 @@ public int hashCode() {
   }
 
   @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
+  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
     messageDigest.update(object.toString().getBytes(CHARSET));
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/signature/StringSignature.java b/library/src/main/java/com/bumptech/glide/signature/StringSignature.java
deleted file mode 100644
index 5492f2216..000000000
--- a/library/src/main/java/com/bumptech/glide/signature/StringSignature.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.util.Preconditions;
-
-import java.security.MessageDigest;
-
-/**
- * A unique Signature that wraps a String.
- *
- * TODO: remove this and replace with ObjectKey.
- */
-public class StringSignature implements Key {
-  private final String signature;
-
-  public StringSignature(String signature) {
-    this.signature = Preconditions.checkNotNull(signature);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) {
-      return true;
-    }
-    if (o == null || getClass() != o.getClass()) {
-      return false;
-    }
-
-    StringSignature that = (StringSignature) o;
-
-    return signature.equals(that.signature);
-  }
-
-  @Override
-  public int hashCode() {
-    return signature.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "StringSignature{"
-        + "signature='" + signature + '\''
-        + '}';
-  }
-
-  @Override
-  public void updateDiskCacheKey(MessageDigest messageDigest) {
-    messageDigest.update(signature.getBytes(CHARSET));
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index 72204c4b4..8f0bee837 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -12,6 +15,7 @@
 /**
  * Utilities for interacting with {@link java.nio.ByteBuffer}s.
  */
+@SuppressWarnings({"unused", "WeakerAccess"}) // Public API
 public final class ByteBufferUtil {
   // 16 Kb
   private static final int BUFFER_SIZE = 16384;
@@ -21,13 +25,24 @@ private ByteBufferUtil() {
     // Utility class.
   }
 
-  public static ByteBuffer fromFile(File file) throws IOException {
+  @NonNull
+  public static ByteBuffer fromFile(@NonNull File file) throws IOException {
     RandomAccessFile raf = null;
     FileChannel channel = null;
     try {
+      long fileLength = file.length();
+      // See #2240.
+      if (fileLength > Integer.MAX_VALUE) {
+        throw new IOException("File too large to map into memory");
+      }
+      // See b/67710449.
+      if (fileLength == 0) {
+        throw new IOException("File unsuitable for memory mapping");
+      }
+
       raf = new RandomAccessFile(file, "r");
       channel = raf.getChannel();
-      return channel.map(FileChannel.MapMode.READ_ONLY, 0, file.length()).load();
+      return channel.map(FileChannel.MapMode.READ_ONLY, 0, fileLength).load();
     } finally {
       if (channel != null) {
         try {
@@ -46,7 +61,8 @@ public static ByteBuffer fromFile(File file) throws IOException {
     }
   }
 
-  public static void toFile(ByteBuffer buffer, File file) throws IOException {
+  public static void toFile(@NonNull ByteBuffer buffer, @NonNull File file) throws IOException {
+    buffer.position(0);
     RandomAccessFile raf = null;
     FileChannel channel = null;
     try {
@@ -74,7 +90,8 @@ public static void toFile(ByteBuffer buffer, File file) throws IOException {
     }
   }
 
-  public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOException {
+  public static void toStream(@NonNull ByteBuffer byteBuffer,
+      @NonNull OutputStream os) throws IOException {
     SafeArray safeArray = getSafeArray(byteBuffer);
     if (safeArray != null) {
       os.write(safeArray.data, safeArray.offset, safeArray.offset + safeArray.limit);
@@ -94,7 +111,8 @@ public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOExc
     }
   }
 
-  public static byte[] toBytes(ByteBuffer byteBuffer) {
+  @NonNull
+  public static byte[] toBytes(@NonNull ByteBuffer byteBuffer) {
     final byte[] result;
     SafeArray safeArray = getSafeArray(byteBuffer);
     if (safeArray != null && safeArray.offset == 0 && safeArray.limit == safeArray.data.length) {
@@ -108,11 +126,35 @@ public static void toStream(ByteBuffer byteBuffer, OutputStream os) throws IOExc
     return result;
   }
 
-  public static InputStream toStream(ByteBuffer buffer) {
+  @NonNull
+  public static InputStream toStream(@NonNull ByteBuffer buffer) {
     return new ByteBufferStream(buffer);
   }
 
-  private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
+  @NonNull
+  public static ByteBuffer fromStream(@NonNull InputStream stream) throws IOException {
+    ByteArrayOutputStream outStream = new ByteArrayOutputStream(BUFFER_SIZE);
+
+    byte[] buffer = BUFFER_REF.getAndSet(null);
+    if (buffer == null) {
+      buffer = new byte[BUFFER_SIZE];
+    }
+
+    int n;
+    while ((n = stream.read(buffer)) >= 0) {
+      outStream.write(buffer, 0, n);
+    }
+
+    BUFFER_REF.set(buffer);
+
+    byte[] bytes = outStream.toByteArray();
+
+    // Some resource decoders require a direct byte buffer. Prefer allocateDirect() over wrap()
+    return (ByteBuffer) ByteBuffer.allocateDirect(bytes.length).put(bytes).position(0);
+  }
+
+  @Nullable
+  private static SafeArray getSafeArray(@NonNull ByteBuffer byteBuffer) {
     if (!byteBuffer.isReadOnly() && byteBuffer.hasArray()) {
       return new SafeArray(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit());
     }
@@ -120,11 +162,13 @@ private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
   }
 
   static final class SafeArray {
-    private final int offset;
-    private final int limit;
-    private final byte[] data;
+    @Synthetic final int offset;
+    @Synthetic final int limit;
+    @Synthetic final byte[] data;
 
-    public SafeArray(byte[] data, int offset, int limit) {
+    // PMD.ArrayIsStoredDirectly Copying would be prohibitively expensive and/or lead to OOMs.
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
+    SafeArray(@NonNull byte[] data, int offset, int limit) {
       this.data = data;
       this.offset = offset;
       this.limit = limit;
@@ -133,20 +177,20 @@ public SafeArray(byte[] data, int offset, int limit) {
 
   private static class ByteBufferStream extends InputStream {
     private static final int UNSET = -1;
-    private final ByteBuffer byteBuffer;
+    @NonNull private final ByteBuffer byteBuffer;
     private int markPos = UNSET;
 
-    public ByteBufferStream(ByteBuffer byteBuffer) {
+    ByteBufferStream(@NonNull ByteBuffer byteBuffer) {
       this.byteBuffer = byteBuffer;
     }
 
     @Override
-    public int available() throws IOException {
+    public int available() {
       return byteBuffer.remaining();
     }
 
     @Override
-    public int read() throws IOException {
+    public int read() {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
@@ -154,7 +198,7 @@ public int read() throws IOException {
     }
 
     @Override
-    public synchronized void mark(int readlimit) {
+    public synchronized void mark(int readLimit) {
       markPos = byteBuffer.position();
     }
 
@@ -164,7 +208,7 @@ public boolean markSupported() {
     }
 
     @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
index eac7dfec4..2b0283e03 100644
--- a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
-
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -18,15 +19,18 @@
   private final long contentLength;
   private int readSoFar;
 
-  public static InputStream obtain(InputStream other, String contentLengthHeader) {
+  @NonNull
+  public static InputStream obtain(@NonNull InputStream other,
+      @Nullable String contentLengthHeader) {
     return obtain(other, parseContentLength(contentLengthHeader));
   }
 
-  public static InputStream obtain(InputStream other, long contentLength) {
+  @NonNull
+  public static InputStream obtain(@NonNull InputStream other, long contentLength) {
     return new ContentLengthInputStream(other, contentLength);
   }
 
-  private static int parseContentLength(String contentLengthHeader) {
+  private static int parseContentLength(@Nullable String contentLengthHeader) {
     int result = UNKNOWN;
     if (!TextUtils.isEmpty(contentLengthHeader)) {
       try {
@@ -40,7 +44,7 @@ private static int parseContentLength(String contentLengthHeader) {
     return result;
   }
 
-  ContentLengthInputStream(InputStream in, long contentLength) {
+  private ContentLengthInputStream(@NonNull InputStream in, long contentLength) {
     super(in);
     this.contentLength = contentLength;
   }
@@ -52,7 +56,9 @@ public synchronized int available() throws IOException {
 
   @Override
   public synchronized int read() throws IOException {
-    return checkReadSoFarOrThrow(super.read());
+    int value = super.read();
+    checkReadSoFarOrThrow(value >= 0 ? 1 : -1);
+    return value;
   }
 
   @Override
@@ -61,7 +67,8 @@ public int read(byte[] buffer) throws IOException {
   }
 
   @Override
-  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public synchronized int read(byte[] buffer, int byteOffset, int byteCount)
+      throws IOException {
     return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
index c64b8572b..3f5b05fb0 100644
--- a/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ExceptionCatchingInputStream.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Queue;
@@ -19,7 +21,8 @@
   private InputStream wrapped;
   private IOException exception;
 
-  public static ExceptionCatchingInputStream obtain(InputStream toWrap) {
+  @NonNull
+  public static ExceptionCatchingInputStream obtain(@NonNull InputStream toWrap) {
     ExceptionCatchingInputStream result;
     synchronized (QUEUE) {
       result = QUEUE.poll();
@@ -42,7 +45,7 @@ static void clearQueue() {
     // Do nothing.
   }
 
-  void setInputStream(InputStream toWrap) {
+  void setInputStream(@NonNull InputStream toWrap) {
     wrapped = toWrap;
   }
 
@@ -57,8 +60,8 @@ public void close() throws IOException {
   }
 
   @Override
-  public void mark(int readlimit) {
-    wrapped.mark(readlimit);
+  public void mark(int readLimit) {
+    wrapped.mark(readLimit);
   }
 
   @Override
@@ -67,7 +70,7 @@ public boolean markSupported() {
   }
 
   @Override
-  public int read(byte[] buffer) throws IOException {
+  public int read(byte[] buffer) {
     int read;
     try {
       read = wrapped.read(buffer);
@@ -79,7 +82,7 @@ public int read(byte[] buffer) throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(byte[] buffer, int byteOffset, int byteCount) {
     int read;
     try {
       read = wrapped.read(buffer, byteOffset, byteCount);
@@ -96,7 +99,7 @@ public synchronized void reset() throws IOException {
   }
 
   @Override
-  public long skip(long byteCount) throws IOException {
+  public long skip(long byteCount) {
     long skipped;
     try {
       skipped = wrapped.skip(byteCount);
@@ -108,7 +111,7 @@ public long skip(long byteCount) throws IOException {
   }
 
   @Override
-  public int read() throws IOException {
+  public int read() {
     int result;
     try {
       result = wrapped.read();
@@ -119,6 +122,7 @@ public int read() throws IOException {
     return result;
   }
 
+  @Nullable
   public IOException getException() {
     return exception;
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
index c0b9a8940..08b7ed3ba 100644
--- a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -1,9 +1,9 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.ListPreloader;
 
-import java.util.Arrays;
-
 /**
  * A {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} with a fixed width and height.
  *
@@ -23,8 +23,12 @@ public FixedPreloadSizeProvider(int width, int height) {
     this.size = new int[] { width, height };
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
-    return Arrays.copyOf(this.size, this.size.length);
+  // It's better to take on the risk that callers may mutate the array when there isn't any reason
+  // for them to do so than it the performance overhead of copying the array with every call.
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
+  public int[] getPreloadSize(@NonNull T item, int adapterPosition, int itemPosition) {
+    return size;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/LogTime.java b/library/src/main/java/com/bumptech/glide/util/LogTime.java
index 834fc161d..58ddd6269 100644
--- a/library/src/main/java/com/bumptech/glide/util/LogTime.java
+++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java
@@ -9,7 +9,7 @@
  */
 public final class LogTime {
   private static final double MILLIS_MULTIPLIER =
-      Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT ? 1d / Math.pow(10, 6) : 1d;
+      Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 ? 1d / Math.pow(10, 6) : 1d;
 
   private LogTime() {
     // Utility class.
@@ -21,10 +21,10 @@ private LogTime() {
    */
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public static long getLogTime() {
-    if (Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
       return SystemClock.elapsedRealtimeNanos();
     } else {
-      return System.currentTimeMillis();
+      return SystemClock.uptimeMillis();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index 1377e3a15..a2cd7d822 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -14,10 +15,10 @@
  * @param <Y> The type of the values.
  */
 public class LruCache<T, Y> {
-  private final LinkedHashMap<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
-  private final int initialMaxSize;
-  private int maxSize;
-  private int currentSize = 0;
+  private final Map<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
+  private final long initialMaxSize;
+  private long maxSize;
+  private long currentSize;
 
   /**
    * Constructor for LruCache.
@@ -25,7 +26,7 @@
    * @param size The maximum size of the cache, the units must match the units used in {@link
    *             #getSize(Object)}.
    */
-  public LruCache(int size) {
+  public LruCache(long size) {
     this.initialMaxSize = size;
     this.maxSize = size;
   }
@@ -52,31 +53,38 @@ public synchronized void setSizeMultiplier(float multiplier) {
    *
    * @param item The item to get the size of.
    */
-  protected int getSize(Y item) {
+  protected int getSize(@Nullable Y item) {
     return 1;
   }
 
+  /**
+   * Returns the number of entries stored in cache.
+   */
+  protected synchronized int getCount() {
+    return cache.size();
+  }
+
   /**
    * A callback called whenever an item is evicted from the cache. Subclasses can override.
    *
    * @param key  The key of the evicted item.
    * @param item The evicted item.
    */
-  protected void onItemEvicted(T key, Y item) {
+  protected void onItemEvicted(@NonNull T key, @Nullable Y item) {
     // optional override
   }
 
   /**
    * Returns the current maximum size of the cache in bytes.
    */
-  public synchronized int getMaxSize() {
+  public synchronized long getMaxSize() {
     return maxSize;
   }
 
   /**
    * Returns the sum of the sizes of all items in the cache.
    */
-  public synchronized int getCurrentSize() {
+  public synchronized long getCurrentSize() {
     return currentSize;
   }
 
@@ -86,7 +94,7 @@ public synchronized int getCurrentSize() {
    * @param key The key to check.
    */
 
-  public synchronized boolean contains(T key) {
+  public synchronized boolean contains(@NonNull T key) {
     return cache.containsKey(key);
   }
 
@@ -96,7 +104,7 @@ public synchronized boolean contains(T key) {
    * @param key The key to check.
    */
   @Nullable
-  public synchronized Y get(T key) {
+  public synchronized Y get(@NonNull T key) {
     return cache.get(key);
   }
 
@@ -104,31 +112,35 @@ public synchronized Y get(T key) {
    * Adds the given item to the cache with the given key and returns any previous entry for the
    * given key that may have already been in the cache.
    *
-   * <p> If the size of the item is larger than the total cache size, the item will not be added to
+   * <p>If the size of the item is larger than the total cache size, the item will not be added to
    * the cache and instead {@link #onItemEvicted(Object, Object)} will be called synchronously with
-   * the given key and item. </p>
+   * the given key and item.
    *
    * @param key  The key to add the item at.
    * @param item The item to add.
    */
-  public synchronized Y put(T key, Y item) {
+  @Nullable
+  public synchronized Y put(@NonNull T key, @Nullable Y item) {
     final int itemSize = getSize(item);
     if (itemSize >= maxSize) {
       onItemEvicted(key, item);
       return null;
     }
 
-    final Y result = cache.put(key, item);
     if (item != null) {
-      currentSize += getSize(item);
+      currentSize += itemSize;
     }
-    if (result != null) {
-      // TODO: should we call onItemEvicted here?
-      currentSize -= getSize(result);
+    @Nullable final Y old = cache.put(key, item);
+    if (old != null) {
+      currentSize -= getSize(old);
+
+      if (!old.equals(item)) {
+        onItemEvicted(key, old);
+      }
     }
     evict();
 
-    return result;
+    return old;
   }
 
   /**
@@ -137,7 +149,7 @@ public synchronized Y put(T key, Y item) {
    * @param key The key to remove the item at.
    */
   @Nullable
-  public synchronized Y remove(T key) {
+  public synchronized Y remove(@NonNull T key) {
     final Y value = cache.remove(key);
     if (value != null) {
       currentSize -= getSize(value);
@@ -158,14 +170,16 @@ public void clearMemory() {
    *
    * @param size The size the cache should be less than.
    */
-  protected synchronized void trimToSize(int size) {
+  protected synchronized void trimToSize(long size) {
     Map.Entry<T, Y> last;
+    Iterator<Map.Entry<T, Y>> cacheIterator;
     while (currentSize > size) {
-      last = cache.entrySet().iterator().next();
+      cacheIterator  = cache.entrySet().iterator();
+      last = cacheIterator.next();
       final Y toRemove = last.getValue();
       currentSize -= getSize(toRemove);
       final T key = last.getKey();
-      cache.remove(key);
+      cacheIterator.remove();
       onItemEvicted(key, toRemove);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
index bec16fa67..bf8cee9a1 100644
--- a/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -14,14 +15,14 @@
 
   private int availableBytes = UNSET;
 
-  public MarkEnforcingInputStream(InputStream in) {
+  public MarkEnforcingInputStream(@NonNull InputStream in) {
     super(in);
   }
 
   @Override
-  public void mark(int readlimit) {
-    super.mark(readlimit);
-    availableBytes = readlimit;
+  public synchronized void mark(int readLimit) {
+    super.mark(readLimit);
+    availableBytes = readLimit;
   }
 
   @Override
@@ -36,7 +37,7 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+  public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
     int toRead = (int) getBytesToRead(byteCount);
     if (toRead == END_OF_STREAM) {
       return END_OF_STREAM;
@@ -48,7 +49,7 @@ public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException
   }
 
   @Override
-  public void reset() throws IOException {
+  public synchronized void reset() throws IOException {
     super.reset();
     availableBytes = UNSET;
   }
@@ -57,7 +58,7 @@ public void reset() throws IOException {
   public long skip(long byteCount) throws IOException {
     long toSkip = getBytesToRead(byteCount);
     if (toSkip == END_OF_STREAM) {
-      return END_OF_STREAM;
+      return 0;
     }
 
     long read = super.skip(toSkip);
@@ -83,7 +84,8 @@ private long getBytesToRead(long targetByteCount) {
 
   private void updateAvailableBytesAfterRead(long bytesRead) {
     if (availableBytes != UNSET && bytesRead != END_OF_STREAM) {
-      availableBytes -= bytesRead;
+      // See http://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      availableBytes = (int) (availableBytes - bytesRead);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
index de27683b6..54fac7310 100644
--- a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
+++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
@@ -1,8 +1,12 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 /**
  * A key of two {@link Class}es to be used in hashed collections.
  */
+@SuppressWarnings({"PMD.ConstructorCallsOverridableMethod"})
 public class MultiClassKey {
   private Class<?> first;
   private Class<?> second;
@@ -12,19 +16,20 @@ public MultiClassKey() {
     // leave them null
   }
 
-  public MultiClassKey(Class<?> first, Class<?> second) {
+  public MultiClassKey(@NonNull Class<?> first, @NonNull Class<?> second) {
     set(first, second);
   }
 
-  public MultiClassKey(Class<?> first, Class<?> second, Class<?> third) {
+  public MultiClassKey(@NonNull Class<?> first, @NonNull Class<?> second,
+      @Nullable Class<?> third) {
     set(first, second, third);
   }
 
-  public void set(Class<?> first, Class<?> second) {
+  public void set(@NonNull Class<?> first, @NonNull Class<?> second) {
     set(first, second, null);
   }
 
-  public void set(Class<?> first, Class<?> second, Class<?> third) {
+  public void set(@NonNull Class<?> first, @NonNull Class<?> second, @Nullable Class<?> third) {
     this.first = first;
     this.second = second;
     this.third = third;
@@ -35,6 +40,7 @@ public String toString() {
     return "MultiClassKey{" + "first=" + first + ", second=" + second + '}';
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -52,10 +58,7 @@ public boolean equals(Object o) {
     if (!second.equals(that.second)) {
       return false;
     }
-    if (third == null && that.third != null) {
-      return false;
-    }
-    if (third != null && !third.equals(that.third)) {
+    if (!Util.bothNullOrEqual(third, that.third)) {
       return false;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/Preconditions.java b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
index 8356ab943..4ca650fc7 100644
--- a/library/src/main/java/com/bumptech/glide/util/Preconditions.java
+++ b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
@@ -1,7 +1,8 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import java.util.Collection;
 
 /**
@@ -13,31 +14,35 @@ private Preconditions() {
     // Utility class.
   }
 
-  public static void checkArgument(boolean expression, String message) {
+  public static void checkArgument(boolean expression, @NonNull String message) {
     if (!expression) {
       throw new IllegalArgumentException(message);
     }
   }
 
-  public static <T> T checkNotNull(T arg) {
+  @NonNull
+  public static <T> T checkNotNull(@Nullable T arg) {
     return checkNotNull(arg, "Argument must not be null");
   }
 
-  public static <T> T checkNotNull(T arg, String message) {
+  @NonNull
+  public static <T> T checkNotNull(@Nullable T arg, @NonNull String message) {
     if (arg == null) {
       throw new NullPointerException(message);
     }
     return arg;
   }
 
-  public static String checkNotEmpty(String string) {
+  @NonNull
+  public static String checkNotEmpty(@Nullable String string) {
     if (TextUtils.isEmpty(string)) {
       throw new IllegalArgumentException("Must not be null or empty");
     }
     return string;
   }
 
-  public static <T extends Collection<Y>, Y> T checkNotEmpty(T collection) {
+  @NonNull
+  public static <T extends Collection<Y>, Y> T checkNotEmpty(@NonNull T collection) {
     if (collection.isEmpty()) {
       throw new IllegalArgumentException("Must not be empty.");
     }
diff --git a/library/src/main/java/com/bumptech/glide/util/Synthetic.java b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
new file mode 100644
index 000000000..0d1140b04
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.util;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that target's visibility can be relaxed to avoid synthetic methods.
+ */
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.TYPE})
+public @interface Synthetic {
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 762d49765..de4b3784b 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -4,9 +4,10 @@
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Looper;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.model.Model;
 import com.bumptech.glide.request.target.Target;
-
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -17,6 +18,8 @@
  * A collection of assorted utility classes.
  */
 public final class Util {
+  private static final int HASH_MULTIPLIER = 31;
+  private static final int HASH_ACCUMULATOR = 17;
   private static final char[] HEX_CHAR_ARRAY = "0123456789abcdef".toCharArray();
   // 32 bytes from sha-256 -> 64 hex chars.
   private static final char[] SHA_256_CHARS = new char[64];
@@ -28,7 +31,8 @@ private Util() {
   /**
    * Returns the hex string of the given byte array representing a SHA256 hash.
    */
-  public static String sha256BytesToHex(byte[] bytes) {
+  @NonNull
+  public static String sha256BytesToHex(@NonNull byte[] bytes) {
     synchronized (SHA_256_CHARS) {
       return bytesToHex(bytes, SHA_256_CHARS);
     }
@@ -37,7 +41,9 @@ public static String sha256BytesToHex(byte[] bytes) {
   // Taken from:
   // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
   // /9655275#9655275
-  private static String bytesToHex(byte[] bytes, char[] hexChars) {
+  @SuppressWarnings("PMD.UseVarargs")
+  @NonNull
+  private static String bytesToHex(@NonNull byte[] bytes, @NonNull char[] hexChars) {
     int v;
     for (int j = 0; j < bytes.length; j++) {
       v = bytes[j] & 0xFF;
@@ -55,7 +61,7 @@ private static String bytesToHex(byte[] bytes, char[] hexChars) {
    * removed in Glide 4.0.
    */
   @Deprecated
-  public static int getSize(Bitmap bitmap) {
+  public static int getSize(@NonNull Bitmap bitmap) {
     return getBitmapByteSize(bitmap);
   }
 
@@ -63,7 +69,7 @@ public static int getSize(Bitmap bitmap) {
    * Returns the in memory size of the given {@link Bitmap} in bytes.
    */
   @TargetApi(Build.VERSION_CODES.KITKAT)
-  public static int getBitmapByteSize(Bitmap bitmap) {
+  public static int getBitmapByteSize(@NonNull Bitmap bitmap) {
     // The return value of getAllocationByteCount silently changes for recycled bitmaps from the
     // internal buffer size to row bytes * height. To avoid random inconsistencies in caches, we
     // instead assert here.
@@ -75,7 +81,7 @@ public static int getBitmapByteSize(Bitmap bitmap) {
       // Workaround for KitKat initial release NPE in Bitmap, fixed in MR1. See issue #148.
       try {
         return bitmap.getAllocationByteCount();
-      } catch (NullPointerException e) {
+      } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
         // Do nothing.
       }
     }
@@ -86,12 +92,12 @@ public static int getBitmapByteSize(Bitmap bitmap) {
    * Returns the in memory size of {@link android.graphics.Bitmap} with the given width, height, and
    * {@link android.graphics.Bitmap.Config}.
    */
-  public static int getBitmapByteSize(int width, int height, Bitmap.Config config) {
+  public static int getBitmapByteSize(int width, int height, @Nullable Bitmap.Config config) {
     return width * height * getBytesPerPixel(config);
   }
 
-  private static int getBytesPerPixel(Bitmap.Config config) {
-    // A bitmap by decoding a gif has null "config" in certain environments.
+  private static int getBytesPerPixel(@Nullable Bitmap.Config config) {
+    // A bitmap by decoding a GIF has null "config" in certain environments.
     if (config == null) {
       config = Bitmap.Config.ARGB_8888;
     }
@@ -105,9 +111,13 @@ private static int getBytesPerPixel(Bitmap.Config config) {
       case ARGB_4444:
         bytesPerPixel = 2;
         break;
+      case RGBA_F16:
+        bytesPerPixel = 8;
+        break;
       case ARGB_8888:
       default:
         bytesPerPixel = 4;
+        break;
     }
     return bytesPerPixel;
   }
@@ -150,7 +160,7 @@ public static boolean isOnMainThread() {
   }
 
   /**
-   * Returns {@code true} if called on the main thread, {@code false} otherwise.
+   * Returns {@code true} if called on a background thread, {@code false} otherwise.
    */
   public static boolean isOnBackgroundThread() {
     return !isOnMainThread();
@@ -159,6 +169,7 @@ public static boolean isOnBackgroundThread() {
   /**
    * Creates a {@link java.util.Queue} of the given size using Glide's preferred implementation.
    */
+  @NonNull
   public static <T> Queue<T> createQueue(int size) {
     return new ArrayDeque<>(size);
   }
@@ -167,15 +178,68 @@ public static boolean isOnBackgroundThread() {
    * Returns a copy of the given list that is safe to iterate over and perform actions that may
    * modify the original list.
    *
-   * <p> See #303 and #375. </p>
+   * <p>See #303, #375, #322, #2262.
    */
-  public static <T> List<T> getSnapshot(Collection<T> other) {
-      // toArray creates a new ArrayList internally and this way we can guarantee entries will not
-      // be null. See #322.
-      List<T> result = new ArrayList<T>(other.size());
-      for (T item : other) {
-          result.add(item);
+  @NonNull
+  @SuppressWarnings("UseBulkOperation")
+  public static <T> List<T> getSnapshot(@NonNull Collection<T> other) {
+    // toArray creates a new ArrayList internally and does not guarantee that the values it contains
+    // are non-null. Collections.addAll in ArrayList uses toArray internally and therefore also
+    // doesn't guarantee that entries are non-null. WeakHashMap's iterator does avoid returning null
+    // and is therefore safe to use. See #322, #2262.
+    List<T> result = new ArrayList<>(other.size());
+    for (T item : other) {
+      if (item != null) {
+        result.add(item);
       }
-      return result;
+    }
+    return result;
+  }
+
+  /**
+   * Null-safe equivalent of {@code a.equals(b)}.
+   *
+   * @see java.util.Objects#equals
+   */
+  public static boolean bothNullOrEqual(@Nullable Object a, @Nullable Object b) {
+    return a == null ? b == null : a.equals(b);
+  }
+
+  public static boolean bothModelsNullEquivalentOrEquals(@Nullable Object a, @Nullable Object b) {
+    if (a == null) {
+      return b == null;
+    }
+    if (a instanceof Model) {
+      return ((Model) a).isEquivalentTo(b);
+    }
+    return a.equals(b);
+  }
+
+  public static int hashCode(int value) {
+    return hashCode(value, HASH_ACCUMULATOR);
+  }
+
+  public static int hashCode(int value, int accumulator) {
+    return accumulator * HASH_MULTIPLIER + value;
+  }
+
+  public static int hashCode(float value) {
+    return hashCode(value, HASH_ACCUMULATOR);
+  }
+
+  public static int hashCode(float value, int accumulator) {
+    return hashCode(Float.floatToIntBits(value), accumulator);
+  }
+
+  public static int hashCode(@Nullable Object object, int accumulator) {
+    return hashCode(object == null ? 0 : object.hashCode(), accumulator);
+  }
+
+  public static int hashCode(boolean value, int accumulator) {
+    return hashCode(value ? 1 : 0, accumulator);
+  }
+
+  public static int hashCode(boolean value) {
+    return hashCode(value, HASH_ACCUMULATOR);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index 5677b391d..90580d544 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.util;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
-
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.request.transition.Transition;
-
 import java.util.Arrays;
 
 /**
@@ -39,22 +39,25 @@ public ViewPreloadSizeProvider() {
    * @param view A not null View the size will be extracted from async using an {@link
    *             android.view.ViewTreeObserver .OnPreDrawListener}
    */
-  public ViewPreloadSizeProvider(View view) {
-    setView(view);
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public ViewPreloadSizeProvider(@NonNull View view) {
+    viewTarget = new SizeViewTarget(view, this);
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(T item, int adapterPosition, int itemPosition) {
+  public int[] getPreloadSize(@NonNull T item, int adapterPosition, int itemPosition) {
     if (size == null) {
       return null;
     } else {
-      return Arrays.copyOf(this.size, this.size.length);
+      return Arrays.copyOf(size, size.length);
     }
   }
 
   @Override
   public void onSizeReady(int width, int height) {
-    this.size = new int[] { width, height };
+    size = new int[]{width, height};
     viewTarget = null;
   }
 
@@ -67,22 +70,22 @@ public void onSizeReady(int width, int height) {
    * @param view A not null View the size will be extracted async with an {@link
    *             android.view.ViewTreeObserver .OnPreDrawListener}
    */
-  public void setView(View view) {
-    if (this.size != null || viewTarget != null) {
+  public void setView(@NonNull View view) {
+    if (size != null || viewTarget != null) {
       return;
     }
-    this.viewTarget = new SizeViewTarget(view, this);
+    viewTarget = new SizeViewTarget(view, this);
   }
 
   private static final class SizeViewTarget extends ViewTarget<View, Object> {
-
-    public SizeViewTarget(View view, SizeReadyCallback callback) {
+    SizeViewTarget(@NonNull View view, @NonNull SizeReadyCallback callback) {
       super(view);
       getSize(callback);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition transition) {
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
       // Do nothing
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
index 87c9d71fc..12e641dc5 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.util.pool;
 
+import android.support.annotation.NonNull;
 import android.support.v4.util.Pools.Pool;
 import android.support.v4.util.Pools.SimplePool;
 import android.support.v4.util.Pools.SynchronizedPool;
 import android.util.Log;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -18,7 +18,7 @@
   private static final int DEFAULT_POOL_SIZE = 20;
   private static final Resetter<Object> EMPTY_RESETTER = new Resetter<Object>() {
     @Override
-    public void reset(Object object) {
+    public void reset(@NonNull Object object) {
       // Do nothing.
     }
   };
@@ -35,7 +35,8 @@ private FactoryPools() { }
    *
    * @param <T> The type of object the pool will contains.
    */
-  public static <T extends Poolable> Pool<T> simple(int size, Factory<T> factory) {
+  @NonNull
+  public static <T extends Poolable> Pool<T> simple(int size, @NonNull Factory<T> factory) {
     return build(new SimplePool<T>(size), factory);
   }
 
@@ -49,7 +50,8 @@ private FactoryPools() { }
    *
    * @param <T> The type of object the pool will contains.
    */
-  public static <T extends Poolable> Pool<T> threadSafe(int size, Factory<T> factory) {
+  @NonNull
+  public static <T extends Poolable> Pool<T> threadSafe(int size, @NonNull Factory<T> factory) {
     return build(new SynchronizedPool<T>(size), factory);
   }
 
@@ -62,6 +64,7 @@ private FactoryPools() { }
    *
    * @param <T> The type of object that the {@link List Lists} will contain.
    */
+  @NonNull
   public static <T> Pool<List<T>> threadSafeList() {
     return threadSafeList(DEFAULT_POOL_SIZE);
   }
@@ -75,29 +78,37 @@ private FactoryPools() { }
    *
    * @param <T> The type of object that the {@link List Lists} will contain.
    */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  @NonNull
   public static <T> Pool<List<T>> threadSafeList(int size) {
     return build(new SynchronizedPool<List<T>>(size), new Factory<List<T>>() {
+      @NonNull
       @Override
       public List<T> create() {
         return new ArrayList<>();
       }
     }, new Resetter<List<T>>() {
       @Override
-      public void reset(List<T> object) {
+      public void reset(@NonNull List<T> object) {
         object.clear();
       }
     });
   }
 
-  private static <T extends Poolable> Pool<T> build(Pool<T> pool, Factory<T> factory) {
+  @NonNull
+  private static <T extends Poolable> Pool<T> build(@NonNull Pool<T> pool,
+      @NonNull Factory<T> factory) {
     return build(pool, factory, FactoryPools.<T>emptyResetter());
   }
 
-  private static <T> Pool<T> build(Pool<T> pool, Factory<T> factory,
-      Resetter<T> resetter) {
+  @NonNull
+  private static <T> Pool<T> build(@NonNull Pool<T> pool, @NonNull Factory<T> factory,
+      @NonNull Resetter<T> resetter) {
     return new FactoryPool<>(pool, factory, resetter);
   }
 
+  @NonNull
   @SuppressWarnings("unchecked")
   private static <T> Resetter<T> emptyResetter() {
     return (Resetter<T>) EMPTY_RESETTER;
@@ -105,6 +116,8 @@ public void reset(List<T> object) {
 
   /**
    * Creates new instances of the given type.
+   *
+   * @param <T> The type of Object that will be created.
    */
   public interface Factory<T> {
     T create();
@@ -112,9 +125,11 @@ public void reset(List<T> object) {
 
   /**
    * Resets state when objects are returned to the pool.
+   *
+   * @param <T> The type of Object that will be reset.
    */
   public interface Resetter<T> {
-    void reset(T object);
+    void reset(@NonNull T object);
   }
 
   /**
@@ -122,6 +137,7 @@ public void reset(List<T> object) {
    * an object pool.
    */
   public interface Poolable {
+    @NonNull
     StateVerifier getVerifier();
   }
 
@@ -130,7 +146,7 @@ public void reset(List<T> object) {
     private final Resetter<T> resetter;
     private final Pool<T> pool;
 
-    FactoryPool(Pool<T> pool, Factory<T> factory, Resetter<T> resetter) {
+    FactoryPool(@NonNull Pool<T> pool, @NonNull Factory<T> factory, @NonNull Resetter<T> resetter) {
       this.pool = pool;
       this.factory = factory;
       this.resetter = resetter;
@@ -152,7 +168,7 @@ public T acquire() {
     }
 
     @Override
-    public boolean release(T instance) {
+    public boolean release(@NonNull T instance) {
       if (instance instanceof Poolable) {
         ((Poolable) instance).getVerifier().setRecycled(true /*isRecycled*/);
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
index b5268c68b..79e0b40aa 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide.util.pool;
 
+import android.support.annotation.NonNull;
+import com.bumptech.glide.util.Synthetic;
+
 /**
  * Verifies that the job is not in the recycled state.
  */
@@ -9,6 +12,7 @@
   /**
    * Creates a new {@link StateVerifier} instance.
    */
+  @NonNull
   public static StateVerifier newInstance() {
     if (DEBUG) {
       return new DebugStateVerifier();
@@ -20,19 +24,22 @@ public static StateVerifier newInstance() {
   private StateVerifier() { }
 
   /**
-   * Throws an exception if we believe our object is recycled and inactive (ie is currently in an
+   * Throws an exception if we believe our object is recycled and inactive (i.e. is currently in an
    * object pool).
    */
   public abstract void throwIfRecycled();
 
   /**
-   * Sets whether or not our objet is recycled.
+   * Sets whether or not our object is recycled.
    */
   abstract void setRecycled(boolean isRecycled);
 
   private static class DefaultStateVerifier extends StateVerifier {
     private volatile boolean isReleased;
 
+    @Synthetic
+    DefaultStateVerifier() { }
+
     @Override
     public void throwIfRecycled() {
       if (isReleased) {
@@ -50,6 +57,9 @@ public void setRecycled(boolean isRecycled) {
     // Keeps track of the stack trace where our state was set to recycled.
     private volatile RuntimeException recycledAtStackTraceException;
 
+    @Synthetic
+    DebugStateVerifier() { }
+
     @Override
     public void throwIfRecycled() {
       if (recycledAtStackTraceException != null) {
@@ -60,9 +70,9 @@ public void throwIfRecycled() {
     @Override
     void setRecycled(boolean isRecycled) {
       if (isRecycled) {
-        this.recycledAtStackTraceException = new RuntimeException("Released");
+        recycledAtStackTraceException = new RuntimeException("Released");
       } else {
-        this.recycledAtStackTraceException = null;
+        recycledAtStackTraceException = null;
       }
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
deleted file mode 100644
index a8a46640a..000000000
--- a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package com.bumptech.glide.load;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class MultiTransformationTest {
-
-  @Mock Transformation<Object> first;
-  @Mock Transformation<Object> second;
-  @Mock Resource<Object> initial;
-  @Mock Resource<Object> firstTransformed;
-  @Mock Resource<Object> secondTransformed;
-
-  @Before
-  public void setUp() {
-    MockitoAnnotations.initMocks(this);
-  }
-
-  @Test
-  public void testAppliesTransformationsInOrder() {
-    final int width = 584;
-    final int height = 768;
-
-    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    when(first.transform(eq(initial), eq(width), eq(height))).thenReturn(firstTransformed);
-
-    when(second.transform(eq(firstTransformed), eq(width), eq(height)))
-        .thenReturn(secondTransformed);
-
-    assertEquals(secondTransformed, transformation.transform(initial, width, height));
-  }
-
-  @Test
-  public void testInitialResourceIsNotRecycled() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
-
-    MultiTransformation<Object> transformation = new MultiTransformation(first);
-
-    transformation.transform(initial, 123, 456);
-
-    verify(initial, never()).recycle();
-  }
-
-  @Test
-  public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformations() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-    when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-
-    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    transformation.transform(initial, 1111, 2222);
-
-    verify(initial, never()).recycle();
-  }
-
-  @Test
-  public void
-  testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-    when(second.transform(any(Resource.class), anyInt(), anyInt()))
-        .thenReturn(mock(Resource.class));
-
-    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    transformation.transform(initial, 1, 2);
-
-    verify(initial, never()).recycle();
-  }
-
-  @Test
-  public void testFinalResourceIsNotRecycled() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
-
-    MultiTransformation<Object> transformation = new MultiTransformation<>(first);
-
-    transformation.transform(mock(Resource.class), 111, 222);
-
-    verify(firstTransformed, never()).recycle();
-  }
-
-  @Test
-  public void testIntermediateResourcesAreRecycled() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
-    when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(secondTransformed);
-
-    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-
-    transformation.transform(mock(Resource.class), 233, 454);
-
-    verify(firstTransformed).recycle();
-  }
-
-  @Test
-  public void testEquals() throws NoSuchAlgorithmException {
-    doAnswer(new Util.WriteDigest("first")).when(first)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(new MultiTransformation<>(first), new MultiTransformation<>(first));
-
-    doAnswer(new Util.WriteDigest("second")).when(second)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(new MultiTransformation<>(first),
-        new MultiTransformation<>(second));
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
deleted file mode 100644
index 7205db1dc..000000000
--- a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.bumptech.glide.load;
-
-import com.google.common.testing.EqualsTester;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class OptionsTest {
-
-  @Test
-  public void testEquals() {
-    Option<Object> firstOption = Option.memory("firstKey");
-    Object firstValue = new Object();
-    Option<Object> secondOption = Option.memory("secondKey");
-    Object secondValue = new Object();
-    new EqualsTester()
-        .addEqualityGroup(new Options(), new Options())
-        .addEqualityGroup(
-            new Options().set(firstOption, firstValue),
-            new Options().set(firstOption, firstValue)
-        )
-        .addEqualityGroup(
-            new Options().set(secondOption, secondValue),
-            new Options().set(secondOption, secondValue)
-        )
-        .addEqualityGroup(
-            new Options().set(firstOption, firstValue).set(secondOption, secondValue),
-            new Options().set(firstOption, firstValue).set(secondOption, secondValue)
-        ).testEquals();
-  }
-
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
deleted file mode 100644
index ee8f8d922..000000000
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.bumptech.glide.load.data.resource;
-
-import static org.mockito.Matchers.isNotNull;
-import static org.mockito.Mockito.verify;
-
-import android.content.Context;
-import android.net.Uri;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.load.data.StreamLocalUriFetcher;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class StreamLocalUriFetcherTest {
-  @Mock DataFetcher.DataCallback<InputStream> callback;
-
-  @Before
-  public void setUp() {
-    MockitoAnnotations.initMocks(this);
-  }
-
-  @Test
-  public void testLoadsInputStream() throws Exception {
-    final Context context = RuntimeEnvironment.application;
-    Uri uri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
-    fetcher.loadData(Priority.NORMAL, callback);
-    verify(callback).onDataReady(isNotNull(InputStream.class));
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
deleted file mode 100644
index e2c13d0e7..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
+++ /dev/null
@@ -1,154 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collections;
-
-/**
- * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object)
- * equals} and SHA-1 disk cache key are different on any difference in ID or existence of a certain
- * workflow part. Also checking whether the equals method is symmetric.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class EngineKeyTest {
-  private Harness harness;
-
-  @Before
-  public void setUp() {
-    harness = new Harness();
-  }
-
-  private static class Harness {
-    String id = "testId";
-    int width = 1;
-    int height = 2;
-    Class resourceClass = Object.class;
-    Class transcodeClass = Integer.class;
-    Key signature = mock(Key.class);
-    Transformation<Object> transformation = mock(Transformation.class);
-    Options options = new Options();
-
-    public Harness() {
-      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
-          .updateDiskCacheKey(any(MessageDigest.class));
-    }
-
-    public EngineKey build() {
-      return new EngineKey(id, signature, width, height,
-          Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),
-          resourceClass, transcodeClass, options);
-    }
-  }
-
-  @Test
-  public void testIsIdenticalWithSameArguments() {
-    assertEquals(harness.build(), harness.build());
-  }
-
-  @Test
-  public void testDiffersIfIdDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.id = harness.id + "2";
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfHeightDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.height += 1;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfWidthDiffers() throws Exception {
-    EngineKey first = harness.build();
-    harness.width += 1;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    Key signature = mock(Key.class);
-    doAnswer(new Answer() {
-      @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        MessageDigest digest = (MessageDigest) invocationOnMock.getArguments()[0];
-        digest.update("signature".getBytes("UTF-8"));
-        return null;
-      }
-    }).when(signature).updateDiskCacheKey(any(MessageDigest.class));
-    harness.signature = signature;
-    EngineKey second = harness.build();
-
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfResourceClassDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.resourceClass = Long.class;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfTranscodeClassDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.transcodeClass = Long.class;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-
-    Transformation<Object> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    harness.transformation = other;
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-
-  @Test
-  public void testDiffersIfOptionsDiffer() throws NoSuchAlgorithmException {
-    EngineKey first = harness.build();
-    harness.options = new Options();
-    harness.options.set(Option.memory("fakeKey"), "someValue");
-    EngineKey second = harness.build();
-    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
deleted file mode 100644
index 8cbe62361..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ /dev/null
@@ -1,502 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static com.bumptech.glide.tests.Util.anyResource;
-import static com.bumptech.glide.tests.Util.isADataSource;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import com.bumptech.glide.GlideContext;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.DataSource;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.cache.DiskCache;
-import com.bumptech.glide.load.engine.cache.MemoryCache;
-import com.bumptech.glide.load.engine.executor.GlideExecutor;
-import com.bumptech.glide.request.ResourceCallback;
-import com.bumptech.glide.tests.BackgroundUtil;
-import com.bumptech.glide.tests.GlideShadowLooper;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.Map;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { GlideShadowLooper.class })
-public class EngineTest {
-  private EngineTestHarness harness;
-
-  @Before
-  public void setUp() {
-    harness = new EngineTestHarness();
-  }
-
-  @Test
-  public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
-    harness.doLoad();
-
-    verify(harness.job).start(any(DecodeJob.class));
-  }
-
-  @Test
-  public void testCallbackIsAddedToNewEngineJobWithNoExistingLoad() {
-    harness.doLoad();
-
-    verify(harness.job).addCallback(eq(harness.cb));
-  }
-
-  @Test
-  public void testLoadStatusIsReturnedForNewLoad() {
-    assertNotNull(harness.doLoad());
-  }
-
-  @Test
-  public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
-    Engine.LoadStatus loadStatus = harness.doLoad();
-    loadStatus.cancel();
-
-    verify(harness.job).removeCallback(eq(harness.cb));
-  }
-
-  @Test
-  public void testNewRunnerIsAddedToRunnersMap() {
-    harness.doLoad();
-
-    assertThat(harness.jobs).containsKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
-    harness.doLoad();
-    harness.doLoad();
-
-    verify(harness.job, times(1)).start(any(DecodeJob.class));
-  }
-
-  @Test
-  @SuppressWarnings("unchecked")
-  public void testCallbackIsAddedToExistingRunnerWithExistingLoad() {
-    harness.doLoad();
-
-    ResourceCallback newCallback = mock(ResourceCallback.class);
-    harness.cb = newCallback;
-    harness.doLoad();
-
-    verify(harness.job).addCallback(eq(newCallback));
-  }
-
-  @Test
-  public void testLoadStatusIsReturnedForExistingJob() {
-    harness.doLoad();
-    Engine.LoadStatus loadStatus = harness.doLoad();
-
-    assertNotNull(loadStatus);
-  }
-
-  @Test
-  public void testResourceIsReturnedFromActiveResourcesIfPresent() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-  }
-
-  @Test
-  public void testResourceIsNotReturnedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    verify(harness.cb, never()).onResourceReady(isNull(Resource.class), isADataSource());
-  }
-
-  @Test
-  public void testKeyIsRemovedFromActiveResourcesIfRefIsCleared() {
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));
-
-    harness.doLoad();
-
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testResourceIsAcquiredIfReturnedFromActiveResources() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.doLoad();
-
-    verify(harness.resource).acquire();
-  }
-
-  @Test
-  public void testNewLoadIsNotStartedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.doLoad();
-
-    verify(harness.job, never()).start(any(DecodeJob.class));
-  }
-
-  @Test
-  public void testNullLoadStatusIsReturnedIfResourceIsActive() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    assertNull(harness.doLoad());
-  }
-
-  @Test
-  public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-    EngineResource other = mock(EngineResource.class);
-    harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-    verify(harness.cb, never()).onResourceReady(eq(other), isADataSource());
-  }
-
-  @Test
-  public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.isMemoryCacheable = false;
-    harness.doLoad();
-
-    verify(harness.resource, never()).acquire();
-    verify(harness.job).start(any(DecodeJob.class));
-  }
-
-  @Test
-  public void testCacheIsCheckedIfMemoryCacheable() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-  }
-
-  @Test
-  public void testCacheIsNotCheckedIfNotMemoryCacheable() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.isMemoryCacheable = false;
-    harness.doLoad();
-
-    verify(harness.job).start(any(DecodeJob.class));
-  }
-
-  @Test
-  public void testResourceIsReturnedFromCacheIfPresent() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
-  }
-
-  @Test
-  public void testHandlesNonEngineResourcesFromCacheIfPresent() {
-    final Object expected = new Object();
-    Resource fromCache = mock(Resource.class);
-    when(fromCache.get()).thenReturn(expected);
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
-
-    doAnswer(new Answer() {
-      @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Resource resource = (Resource) invocationOnMock.getArguments()[0];
-        assertEquals(expected, resource.get());
-        return null;
-      }
-    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
-
-    harness.doLoad();
-
-    verify(harness.cb).onResourceReady(anyResource(), isADataSource());
-  }
-
-  @Test
-  public void testResourceIsAddedToActiveResourceIfReturnedFromCache() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.doLoad();
-
-    assertEquals(harness.resource, harness.activeResources.get(harness.cacheKey).get());
-  }
-
-  @Test
-  public void testResourceIsAcquiredIfReturnedFromCache() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-
-    harness.doLoad();
-
-    verify(harness.resource).acquire();
-  }
-
-  @Test
-  public void testNewLoadIsNotStartedIfResourceIsCached() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
-
-    harness.doLoad();
-
-    verify(harness.job, never()).start(any(DecodeJob.class));
-  }
-
-  @Test
-  public void testNullLoadStatusIsReturnedForCachedResource() {
-    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(mock(EngineResource.class));
-
-    Engine.LoadStatus loadStatus = harness.doLoad();
-    assertNull(loadStatus);
-  }
-
-  @Test
-  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testEngineIsSetAsResourceListenerOnJobComplete() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-
-    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.engine));
-  }
-
-  @Test
-  public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
-  }
-
-  @Test
-  public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
-    when(harness.resource.isCacheable()).thenReturn(true);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-
-    WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);
-    assertThat(harness.resource).isEqualTo(resourceRef.get());
-  }
-
-  @Test
-  public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
-    harness.engine.onEngineJobComplete(harness.cacheKey, null);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
-    when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);
-
-    assertThat(harness.jobs).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
-    harness.doLoad();
-
-    harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
-
-    assertEquals(harness.job, harness.jobs.get(harness.cacheKey));
-  }
-
-  @Test
-  public void testResourceIsAddedToCacheOnReleased() {
-    final Object expected = new Object();
-    when(harness.resource.isCacheable()).thenReturn(true);
-    when(harness.resource.get()).thenReturn(expected);
-    doAnswer(new Answer() {
-      @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
-        assertEquals(expected, resource.get());
-        return null;
-      }
-    }).when(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
-
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-
-
-    verify(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
-  }
-
-  @Test
-  public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
-    when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-
-    verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
-  }
-
-  @Test
-  public void testResourceIsRecycledIfNotCacheableWhenReleased() {
-    when(harness.resource.isCacheable()).thenReturn(false);
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-    verify(harness.resourceRecycler).recycle(eq(harness.resource));
-  }
-
-  @Test
-  public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
-    harness.activeResources
-        .put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));
-
-    harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
-
-    assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);
-  }
-
-  @Test
-  public void testEngineAddedAsListenerToMemoryCache() {
-    verify(harness.cache).setResourceRemovedListener(eq(harness.engine));
-  }
-
-  @Test
-  public void testResourceIsRecycledWhenRemovedFromCache() {
-    harness.engine.onResourceRemoved(harness.resource);
-    verify(harness.resourceRecycler).recycle(eq(harness.resource));
-  }
-
-  @Test
-  public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
-    harness.doLoad();
-
-    assertThat(harness.jobs).containsEntry(harness.cacheKey, harness.job);
-  }
-
-  @Test
-  public void testKeyFactoryIsGivenNecessaryArguments() {
-    harness.doLoad();
-
-    verify(harness.keyFactory)
-        .buildKey(eq(harness.model), eq(harness.signature), eq(harness.width), eq(harness.height),
-            eq(harness.transformations), eq(Object.class), eq(Object.class), eq(harness.options));
-  }
-
-  @Test
-  public void testFactoryIsGivenNecessaryArguments() {
-    harness.doLoad();
-
-    verify(harness.engineJobFactory).build(eq(harness.cacheKey), eq(true) /*isMemoryCacheable*/);
-  }
-
-  @Test
-  public void testReleaseReleasesEngineResource() {
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    harness.engine.release(engineResource);
-    verify(engineResource).release();
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testThrowsIfAskedToReleaseNonEngineResource() {
-    harness.engine.release(mock(Resource.class));
-  }
-
-  @Test(expected = RuntimeException.class)
-  public void testThrowsIfLoadCalledOnBackgroundThread() throws InterruptedException {
-    BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
-      @Override
-      public void runTest() throws Exception {
-        harness.doLoad();
-      }
-    });
-  }
-
-  @SuppressWarnings("unchecked")
-  private static class EngineTestHarness {
-    EngineKey cacheKey = mock(EngineKey.class);
-    EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
-    ResourceCallback cb = mock(ResourceCallback.class);
-    EngineResource resource = mock(EngineResource.class);
-    Map<Key, EngineJob> jobs = new HashMap<>();
-    Map<Key, WeakReference<EngineResource<?>>> activeResources = new HashMap<>();
-
-    int width = 100;
-    int height = 100;
-
-    Object model = new Object();
-    MemoryCache cache = mock(MemoryCache.class);
-    EngineJob job;
-    Engine engine;
-    Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
-    Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
-    ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
-    Key signature = mock(Key.class);
-    Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-    Options options = new Options();
-    GlideContext glideContext = mock(GlideContext.class);
-    boolean isMemoryCacheable = true;
-
-    public EngineTestHarness() {
-      when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
-          eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);
-
-      job = mock(EngineJob.class);
-
-      engine = new Engine(cache, mock(DiskCache.Factory.class), mock(GlideExecutor.class),
-          mock(GlideExecutor.class), jobs, keyFactory, activeResources, engineJobFactory,
-          decodeJobFactory, resourceRecycler);
-    }
-
-    public Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean())).thenReturn(job);
-      return engine.load(glideContext,
-          model,
-          signature,
-          width,
-          height,
-          Object.class,
-          Object.class,
-          Priority.HIGH,
-          DiskCacheStrategy.ALL,
-          transformations,
-          false /*isTransformationRequired*/,
-          options,
-          isMemoryCacheable,
-          cb);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
deleted file mode 100644
index fe8c252b1..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
+++ /dev/null
@@ -1,137 +0,0 @@
-package com.bumptech.glide.load.engine;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.signature.StringSignature;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class ResourceCacheKeyTest {
-
-  private Factory factory;
-
-  @Before
-  public void setUp() {
-    factory = new Factory();
-  }
-
-  @Test
-  public void testIdenticalWithSameArguments()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    KeyAssertions.assertSame(factory.build(), factory.build());
-  }
-
-  @Test
-  public void testDifferIfSourceKeyDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.sourceKey = new StringSignature("secondKey");
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.signature = new StringSignature("secondSignature");
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfWidthDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.width = factory.width * 2;
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfHeightDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.height = factory.height * 2;
-      }
-    });
-  }
-
-  @Test
-  public void tesDiffersIfTransformationDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.transformation = mock(Transformation.class);
-        doAnswer(new Util.WriteDigest("otherTransformation")).when(factory.transformation)
-            .updateDiskCacheKey(any(MessageDigest.class));
-      }
-    });
-  }
-
-  @Test
-  public void testDiffersIfResourceDiffers() {
-    mutateAndAssertDifferent(new FactoryMutation() {
-      @Override
-      public void mutate(Factory factory) {
-        factory.resourceClass = Integer.class;
-      }
-    });
-  }
-
-  interface FactoryMutation {
-    void mutate(Factory factory);
-  }
-
-  private void mutateAndAssertDifferent(FactoryMutation mutation) {
-    ResourceCacheKey original = factory.build();
-    mutation.mutate(factory);
-    ResourceCacheKey mutated = factory.build();
-
-    try {
-      KeyAssertions.assertDifferent(original, mutated);
-    } catch (NoSuchAlgorithmException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  static class Factory {
-    Key sourceKey = new StringSignature("sourceKey");
-    Key signature = new StringSignature("signature");
-    int width = 100;
-    int height = 100;
-    Transformation<?> transformation = mock(Transformation.class);
-    Class<?> resourceClass = Object.class;
-    Options options = new Options();
-
-    Factory() {
-      doAnswer(new Util.WriteDigest("transformation")).when(transformation)
-          .updateDiskCacheKey(any(MessageDigest.class));
-    }
-
-    ResourceCacheKey build() {
-      return new ResourceCacheKey(sourceKey, signature, width, height, transformation,
-          resourceClass, options);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
deleted file mode 100644
index ab9604ddc..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class GroupedLinkedMapTest {
-
-    private GroupedLinkedMap<Key, Object> map;
-
-    @Before
-    public void setUp() {
-        map = new GroupedLinkedMap<Key, Object>();
-    }
-
-    @Test
-    public void testReturnsNullForGetWithNoBitmap() {
-        assertNull(map.get(mock(Key.class)));
-    }
-
-    @Test
-    public void testCanAddAndRemoveABitmap() {
-        Key key = new Key("key", 1, 1);
-        Object expected = new Object();
-
-        map.put(key, expected);
-
-        assertThat(map.get(key)).isEqualTo(expected);
-    }
-
-    @Test
-    public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
-        Key key = new Key("key", 1, 1);
-        Integer value = 20;
-
-        int numToAdd = 10;
-
-        for (int i = 0; i < numToAdd; i++) {
-            map.put(key, new Integer(value));
-        }
-
-        for (int i = 0; i < numToAdd; i++) {
-            assertThat(map.get(key)).isEqualTo(value);
-        }
-    }
-
-    @Test
-    public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
-        Key firstKey = new Key("key", 1, 1);
-        Integer firstValue = 10;
-        map.put(firstKey, firstValue);
-        map.put(firstKey, new Integer(firstValue));
-
-        Key secondKey = new Key("key", 2, 2);
-        Integer secondValue = 20;
-        map.put(secondKey, secondValue);
-
-        map.get(firstKey);
-
-        assertThat(map.removeLast()).isEqualTo(secondValue);
-    }
-
-    @Test
-    public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
-        Key firstKey = new Key("key", 1, 1);
-        Integer firstValue = 10;
-
-        map.put(firstKey, firstValue);
-        map.put(firstKey, new Integer(firstValue));
-
-        map.get(firstKey);
-
-        Integer secondValue = 20;
-        map.put(new Key("key", 2, 2), secondValue);
-
-        assertThat(map.removeLast()).isEqualTo(secondValue);
-    }
-
-    private static class Key implements Poolable {
-
-        private final String key;
-        private final int width;
-        private final int height;
-
-        public Key(String key, int width, int height) {
-            this.key = key;
-            this.width = width;
-            this.height = height;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Key) {
-                Key other = (Key) o;
-                return key.equals(other.key) && width == other.width && height == other.height;
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = key != null ? key.hashCode() : 0;
-            result = 31 * result + width;
-            result = 31 * result + height;
-            return result;
-        }
-
-        @Override
-        public void offer() {
-            // Do nothing.
-        }
-    }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
deleted file mode 100644
index c56ff320e..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package com.bumptech.glide.load.engine.bitmap_recycle;
-
-import com.google.common.testing.EqualsTester;
-
-import android.graphics.Bitmap;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class SizeConfigStrategyTest {
-
-    @Mock SizeConfigStrategy.KeyPool pool;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-    }
-
-    @Test
-    public void testKeyEquals() {
-        new EqualsTester()
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565)
-                )
-                .addEqualityGroup(
-                        new SizeConfigStrategy.Key(pool, 100, null /*config*/)
-                )
-                .testEquals();
-
-    }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
deleted file mode 100644
index 61918f223..000000000
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package com.bumptech.glide.load.engine.cache;
-
-import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.ComponentCallbacks2;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.engine.Resource;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.security.MessageDigest;
-
-@RunWith(JUnit4.class)
-public class LruResourceCacheTest {
-  private static class TrimClearMemoryCacheHarness {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource first = mock(Resource.class);
-    Resource second = mock(Resource.class);
-
-    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-    public TrimClearMemoryCacheHarness() {
-      when(first.getSize()).thenReturn(50);
-      when(second.getSize()).thenReturn(50);
-      resourceCache.put(new MockKey(), first);
-      resourceCache.put(new MockKey(), second);
-      resourceCache.setResourceRemovedListener(listener);
-    }
-  }
-
-  @Test
-  public void testTrimMemoryModerate() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
-
-    verify(harness.listener).onResourceRemoved(eq(harness.first));
-    verify(harness.listener).onResourceRemoved(eq(harness.second));
-  }
-
-  @Test
-  public void testTrimMemoryComplete() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
-
-    verify(harness.listener).onResourceRemoved(harness.first);
-    verify(harness.listener).onResourceRemoved(harness.second);
-  }
-
-  @Test
-  public void testTrimMemoryBackground() {
-    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
-
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
-
-    verify(harness.listener).onResourceRemoved(harness.first);
-    verify(harness.listener, never()).onResourceRemoved(harness.second);
-  }
-
-  @Test
-  public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource resource = mock(Resource.class);
-    when(resource.getSize()).thenReturn(200);
-
-    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
-
-    resourceCache.setResourceRemovedListener(listener);
-    resourceCache.put(new MockKey(), resource);
-
-    verify(listener).onResourceRemoved(eq(resource));
-  }
-
-  @Test
-  public void testSizeIsBasedOnResource() {
-    LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource first = getResource(50);
-    MockKey firstKey = new MockKey();
-    resourceCache.put(firstKey, first);
-    Resource second = getResource(50);
-    MockKey secondKey = new MockKey();
-    resourceCache.put(secondKey, second);
-
-    assertTrue(resourceCache.contains(firstKey));
-    assertTrue(resourceCache.contains(secondKey));
-
-    Resource third = getResource(50);
-    MockKey thirdKey = new MockKey();
-    resourceCache.put(thirdKey, third);
-
-    assertFalse(resourceCache.contains(firstKey));
-    assertTrue(resourceCache.contains(secondKey));
-    assertTrue(resourceCache.contains(thirdKey));
-  }
-
-  private Resource getResource(int size) {
-    Resource resource = mock(Resource.class);
-    when(resource.getSize()).thenReturn(size);
-    return resource;
-  }
-
-  private static class MockKey implements Key {
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      messageDigest.update(toString().getBytes(CHARSET));
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
deleted file mode 100644
index ce38270a9..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.bumptech.glide.load.resource;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.tests.KeyAssertions;
-import com.bumptech.glide.tests.Util;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class UnitTransformationTest {
-
-  @Test
-  public void testReturnsGivenResource() {
-    Resource resource = mock(Resource.class);
-    UnitTransformation transformation = UnitTransformation.get();
-    assertEquals(resource, transformation.transform(resource, 10, 10));
-  }
-
-  @Test
-  public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(UnitTransformation.get(), UnitTransformation.get());
-
-    Transformation<Object> other = mock(Transformation.class);
-    doAnswer(new Util.WriteDigest("other")).when(other)
-        .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(UnitTransformation.get(), other);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
deleted file mode 100644
index c88e3081a..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ /dev/null
@@ -1,194 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.collect.Range.closed;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.util.DisplayMetrics;
-
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.DownsamplerTest.AllocationSizeBitmap;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 19, shadows = AllocationSizeBitmap.class)
-public class DownsamplerTest {
-  @Mock private BitmapPool bitmapPool;
-  @Mock private ByteArrayPool byteArrayPool;
-  private Downsampler downsampler;
-  private Options options;
-
-  @Before
-  public void setUp() throws Exception {
-    MockitoAnnotations.initMocks(this);
-    options = new Options();
-    DisplayMetrics displayMetrics =
-        RuntimeEnvironment.application.getResources().getDisplayMetrics();
-    when(byteArrayPool.get(anyInt()))
-        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
-    downsampler = new Downsampler(displayMetrics, bitmapPool, byteArrayPool);
-  }
-
-  @Test
-  public void testAlwaysArgb8888() throws IOException {
-    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-
-    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_ARGB_8888);
-    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
-    assertEquals(Bitmap.Config.ARGB_8888, result.get().getConfig());
-  }
-
-  @Test
-  public void testPreferRgb565() throws IOException {
-    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-
-    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_RGB_565);
-    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
-    assertEquals(Bitmap.Config.RGB_565, result.get().getConfig());
-  }
-
-  @Test
-  public void testCalculateScaling_withInvalidSourceSizes_doesNotCrash() {
-    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_MOST, 0, 0);
-    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.AT_MOST, -1, -1);
-    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_LEAST, 0, 0);
-    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.CENTER_OUTSIDE, -1, -1);
-  }
-
-  @Test
-  public void testCalculateScaling_withAtMost() {
-    DownsampleStrategy strategy = DownsampleStrategy.AT_MOST;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 75, 75);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(801, 100, 100, 100, strategy, 50, 6);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  @Test
-  public void testCalculateScaling_withAtLeast() {
-    DownsampleStrategy strategy = DownsampleStrategy.AT_LEAST;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 150, 150);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  @Test
-  public void testCalculateScaling_withCenterInside() {
-    DownsampleStrategy strategy = DownsampleStrategy.CENTER_INSIDE;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(801, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
-    runScaleTest(87, 78, 100, 100, strategy, 100, 90);
-  }
-
-  @Test
-  public void testCalculateScaling_withCenterOutside() {
-    DownsampleStrategy strategy = DownsampleStrategy.CENTER_OUTSIDE;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 112, 100);
-  }
-
-  @Test
-  public void testCalculateScaling_withNone() {
-    DownsampleStrategy strategy = DownsampleStrategy.NONE;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 200, 200);
-    runScaleTest(400, 400, 100, 100, strategy, 400, 400);
-    runScaleTest(300, 300, 100, 100, strategy, 300, 300);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
-      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight) {
-    BitmapFactory.Options options = new BitmapFactory.Options();
-    Downsampler.calculateScaling(strategy, 0, sourceWidth, sourceHeight, targetWidth, targetHeight,
-        options);
-    assertSize(sourceWidth, sourceHeight, expectedWidth, expectedHeight, options);
-  }
-
-  private static void assertSize(int sourceWidth, int sourceHeight, int expectedWidth,
-      int expectedHeight, BitmapFactory.Options options) {
-    float sampleSize = Math.max(1, options.inSampleSize);
-    int downsampledWidth = (int) ((sourceWidth / sampleSize) + 0.5f);
-    int downsampledHeight = (int) ((sourceHeight / sampleSize) + 0.5f);
-
-    float scaleFactor = options.inScaled && options.inTargetDensity > 0 && options.inDensity > 0
-        ? options.inTargetDensity / (float) options.inDensity : 1f;
-    int scaledWidth = (int) Math.ceil(downsampledWidth * scaleFactor);
-    int scaledHeight = (int) Math.ceil(downsampledHeight * scaleFactor);
-
-    assertThat(scaledWidth).isIn(closed(expectedWidth, expectedWidth + 1));
-    assertThat(scaledHeight).isIn(closed(expectedHeight, expectedHeight + 1));
-  }
-
-  private InputStream compressBitmap(Bitmap bitmap, Bitmap.CompressFormat compressFormat)
-      throws FileNotFoundException {
-    ByteArrayOutputStream os = new ByteArrayOutputStream();
-    bitmap.compress(compressFormat, 100, os);
-    return new ByteArrayInputStream(os.toByteArray());
-  }
-
-  // Robolectric doesn't implement getAllocationByteCount correctly.
-  @Implements(Bitmap.class)
-  public static class AllocationSizeBitmap extends ShadowBitmap {
-
-    @Implementation
-    public int getAllocationByteCount() {
-      return getWidth() * getHeight() * (getConfig() == Bitmap.Config.ARGB_8888 ? 4 : 2);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
deleted file mode 100644
index 705246076..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ /dev/null
@@ -1,229 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-import com.bumptech.glide.testutil.TestResourceUtil;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.util.Util;
-
-import java.io.ByteArrayInputStream;
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ImageHeaderParserTest {
-
-  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
-      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
-          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
-
-  private LruByteArrayPool byteArrayPool;
-
-  @Before
-  public void setUp() {
-    byteArrayPool = new LruByteArrayPool();
-  }
-
-  @Test
-  public void testCanParsePngType() throws IOException {
-    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
-    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.PNG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParsePngWithAlpha() throws IOException {
-    for (int i = 3; i <= 6; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG_A, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParsePngWithoutAlpha() throws IOException {
-    for (int i = 0; i < 3; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParseJpegType() throws IOException {
-    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.JPEG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseGifType() throws IOException {
-    byte[] data = new byte[] { 'G', 'I', 'F' };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.GIF, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
-    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #286.
-  @Test
-  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
-    byte[] data =
-        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(-1, parser.getOrientation());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownForEmptyData() throws IOException {
-    runTest(new byte[0], new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialReads() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialSkips() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  @Test
-  public void testHandlesSometimesZeroSkips() throws IOException {
-    InputStream is = new ByteArrayInputStream(
-        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
-    ImageHeaderParser parser =
-        new ImageHeaderParser(new SometimesZeroSkipInputStream(is), byteArrayPool);
-    assertEquals(ImageType.PNG, parser.getType());
-  }
-
-  private interface ParserTestCase {
-    void run(ImageHeaderParser parser) throws IOException;
-  }
-
-  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
-    InputStream is = new ByteArrayInputStream(data);
-    ImageHeaderParser parser = new ImageHeaderParser(is, new LruByteArrayPool());
-    test.run(parser);
-
-    ByteBuffer buffer = ByteBuffer.wrap(data);
-    parser = new ImageHeaderParser(buffer, new LruByteArrayPool());
-    test.run(parser);
-  }
-
-  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
-    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
-    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
-    result[result.length - 1] = (byte) bitDepth;
-    return result;
-  }
-
-  private static class SometimesZeroSkipInputStream extends FilterInputStream {
-    boolean returnZeroFlag = true;
-
-    protected SometimesZeroSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-      final long result;
-      if (returnZeroFlag) {
-        result = 0;
-      } else {
-        result = super.skip(byteCount);
-      }
-      returnZeroFlag = !returnZeroFlag;
-      return result;
-    }
-  }
-
-  private static class PartialSkipInputStream extends FilterInputStream {
-
-    protected PartialSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-        long toActuallySkip = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallySkip = 1;
-        }
-        return super.skip(toActuallySkip);
-    }
-  }
-
-  private static class PartialReadInputStream extends FilterInputStream {
-
-    protected PartialReadInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
-        int toActuallyRead = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallyRead = 1;
-        }
-        return super.read(buffer, byteOffset, toActuallyRead);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
deleted file mode 100644
index b1716d3ac..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
+++ /dev/null
@@ -1,100 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
-import android.os.ParcelFileDescriptor;
-
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.io.FileDescriptor;
-import java.io.IOException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class VideoBitmapDecoderTest {
-  @Mock private ParcelFileDescriptor resource;
-  @Mock private VideoBitmapDecoder.MediaMetadataRetrieverFactory factory;
-  @Mock private MediaMetadataRetriever retriever;
-  @Mock private BitmapPool bitmapPool;
-  private VideoBitmapDecoder decoder;
-  private Options options;
-
-  @Before
-  public void setup() {
-    MockitoAnnotations.initMocks(this);
-    when(factory.build()).thenReturn(retriever);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-    options = new Options();
-  }
-
-  @Test
-  public void testReturnsRetrievedFrameForResource() throws IOException {
-    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(retriever.getFrameAtTime()).thenReturn(expected);
-
-    FileDescriptor toSet = FileDescriptor.in;
-    when(resource.getFileDescriptor()).thenReturn(toSet);
-    Resource<Bitmap> result = decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).setDataSource(eq(toSet));
-    assertEquals(expected, result.get());
-  }
-
-  @Test
-  public void testReleasesMediaMetadataRetriever() throws IOException {
-    decoder.decode(resource, 1, 2, options);
-
-    verify(retriever).release();
-  }
-
-  @Test
-  public void testClosesResource() throws IOException {
-    decoder.decode(resource, 1, 2, options);
-
-    verify(resource).close();
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
-    options.set(VideoBitmapDecoder.TARGET_FRAME, -5L);
-    new VideoBitmapDecoder(bitmapPool, factory).decode(resource, 100, 100, options);
-  }
-
-  @Test
-  public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
-    long frame = 5;
-    options.set(VideoBitmapDecoder.TARGET_FRAME, frame);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-
-    decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).getFrameAtTime(frame);
-    verify(retriever, never()).getFrameAtTime();
-  }
-
-  @Test
-  public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
-    decoder.decode(resource, 100, 100, options);
-
-    verify(retriever).getFrameAtTime();
-    verify(retriever, never()).getFrameAtTime(anyLong());
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
deleted file mode 100644
index 16b4f1d4a..000000000
--- a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.bumptech.glide.request;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
-
-import com.bumptech.glide.load.Transformation;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
-public class BaseRequestOptionsTest {
-
-  private TestOptions options;
-
-  @Before
-  public void setUp() {
-    options = new TestOptions();
-  }
-
-  @Test
-  public void testTransformationIsSetAfterApplyingOtherOptionsWithTransformation() {
-    TestOptions other = new TestOptions();
-    other.transform(Object.class, mock(Transformation.class));
-    options.apply(other);
-    assertThat(options.isTransformationSet()).isTrue();
-  }
-
-  private static class TestOptions extends BaseRequestOptions<TestOptions> {
-    // Empty.
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
deleted file mode 100644
index 43af5105f..000000000
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ /dev/null
@@ -1,817 +0,0 @@
-package com.bumptech.glide.request;
-
-import static com.bumptech.glide.tests.Util.isADataSource;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-
-import com.bumptech.glide.GlideContext;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.DataSource;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.engine.Engine;
-import com.bumptech.glide.load.engine.GlideException;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.request.target.SizeReadyCallback;
-import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.request.transition.Transition;
-import com.bumptech.glide.request.transition.TransitionFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class SingleRequestTest {
-  private RequestHarness harness;
-
-  /**
-   * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
-   * Both are in the middle of the hierarchy having multiple descendants and ancestors.
-   */
-  @SuppressWarnings("unchecked")
-  private static class RequestHarness {
-    Engine engine = mock(Engine.class);
-    Number model = 123456;
-    Target<List> target = mock(Target.class);
-    Resource<List> resource = mock(Resource.class);
-    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-    Drawable placeholderDrawable = null;
-    Drawable errorDrawable = null;
-    Drawable fallbackDrawable = null;
-    RequestListener<List> requestListener = mock(RequestListener.class);
-    TransitionFactory<List> factory = mock(TransitionFactory.class);
-    int overrideWidth = -1;
-    int overrideHeight = -1;
-    List result = new ArrayList();
-    GlideContext glideContext = mock(GlideContext.class);
-    Key signature = mock(Key.class);
-    Priority priority = Priority.HIGH;
-
-    Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();
-
-    public RequestHarness() {
-      when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
-      when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
-      when(resource.get()).thenReturn(result);
-    }
-
-    public SingleRequest<List> getRequest() {
-       RequestOptions requestOptions = new RequestOptions()
-        .error(errorDrawable)
-        .placeholder(placeholderDrawable)
-        .fallback(fallbackDrawable)
-        .override(overrideWidth, overrideHeight)
-        .priority(priority)
-        .signature(signature);
-      return SingleRequest
-          .obtain(glideContext, model, List.class, requestOptions, overrideWidth, overrideHeight,
-              priority, target, requestListener, requestCoordinator, engine, factory);
-    }
-  }
-
-  @Before
-  public void setUp() {
-    harness = new RequestHarness();
-  }
-
-  @Test
-  public void testIsNotCompleteBeforeReceivingResource() {
-    SingleRequest<List> request = harness.getRequest();
-
-    assertFalse(request.isComplete());
-  }
-
-  @Test
-  public void testCanHandleNullResources() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(null, DataSource.LOCAL);
-
-    assertTrue(request.isFailed());
-    verify(harness.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),
-        eq(harness.target), anyBoolean());
-  }
-
-  @Test
-  public void testCanHandleEmptyResources() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.resource.get()).thenReturn(null);
-
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-
-    assertTrue(request.isFailed());
-    verify(harness.engine).release(eq(harness.resource));
-    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean());
-  }
-
-  @Test
-  public void testCanHandleNonConformingResources() {
-    SingleRequest<List> request = harness.getRequest();
-    when(((Resource) (harness.resource)).get())
-        .thenReturn("Invalid mocked String, this should be a List");
-
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    assertTrue(request.isFailed());
-    verify(harness.engine).release(eq(harness.resource));
-    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean());
-  }
-
-  @Test
-  public void testIsNotFailedAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
-    request.clear();
-
-    assertFalse(request.isFailed());
-  }
-
-  @Test
-  public void testIsPausedAfterPause() {
-    SingleRequest<List> request = harness.getRequest();
-    request.pause();
-
-    assertTrue(request.isPaused());
-  }
-
-  @Test
-  public void testIsNotCancelledAfterPause() {
-    SingleRequest<List> request = harness.getRequest();
-    request.pause();
-
-    assertFalse(request.isCancelled());
-  }
-
-  @Test
-  public void testIsNotPausedAfterBeginningWhilePaused() {
-    SingleRequest<List> request = harness.getRequest();
-    request.pause();
-    request.begin();
-
-    assertFalse(request.isPaused());
-    assertTrue(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotFailedAfterBegin() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
-    request.begin();
-
-    assertFalse(request.isFailed());
-  }
-
-  @Test
-  public void testIsCompleteAfterReceivingResource() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    assertTrue(request.isComplete());
-  }
-
-  @Test
-  public void testIsNotCompleteAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-    request.clear();
-
-    assertFalse(request.isComplete());
-  }
-
-  @Test
-  public void testIsCancelledAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-    request.clear();
-
-    assertTrue(request.isCancelled());
-  }
-
-  @Test
-  public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
-    SingleRequest<List> request = harness.getRequest();
-    request.clear();
-    request.clear();
-
-    verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
-  }
-
-  @Test
-  public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
-    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
-    doAnswer(new Answer() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        Request request = (Request) invocation.getArguments()[0];
-        assertFalse(request.isComplete());
-        return true;
-      }
-    }).when(requestCoordinator).canSetImage(any(Request.class));
-
-    harness.requestCoordinator = requestCoordinator;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(requestCoordinator).canSetImage(eq(request));
-  }
-
-  @Test
-  public void testIsNotFailedWithoutException() {
-    SingleRequest<List> request = harness.getRequest();
-
-    assertFalse(request.isFailed());
-  }
-
-  @Test
-  public void testIsFailedAfterException() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onLoadFailed(new GlideException("test"));
-    assertTrue(request.isFailed());
-  }
-
-  @Test
-  public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.onSizeReady(100, 100);
-    request.onSizeReady(100, 100);
-
-    verify(harness.engine, times(1))
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
-            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testIsFailedAfterNoResultAndNullException() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onLoadFailed(new GlideException("test"));
-    assertTrue(request.isFailed());
-  }
-
-  @Test
-  public void testEngineLoadCancelledOnCancel() {
-    Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
-
-    when(harness.engine
-       .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
-          eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-          eq(harness.transformations), anyBoolean(), any(Options.class),
-          anyBoolean(), any(ResourceCallback.class)))
-        .thenReturn(loadStatus);
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    request.onSizeReady(100, 100);
-    request.cancel();
-
-    verify(loadStatus).cancel();
-  }
-
-  @Test
-  public void testResourceIsRecycledOnClear() {
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-    request.clear();
-
-    verify(harness.engine).release(eq(harness.resource));
-  }
-
-  @Test
-  public void testPlaceholderDrawableIsSet() {
-    Drawable expected = new ColorDrawable(Color.RED);
-
-    MockTarget target = new MockTarget();
-
-    harness.placeholderDrawable = expected;
-    harness.target = target;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    assertEquals(expected, target.currentPlaceholder);
-  }
-
-  @Test
-  public void testErrorDrawableIsSetOnLoadFailed() {
-    Drawable expected = new ColorDrawable(Color.RED);
-
-    MockTarget target = new MockTarget();
-
-    harness.errorDrawable = expected;
-    harness.target = target;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.onLoadFailed(new GlideException("test"));
-
-    assertEquals(expected, target.currentPlaceholder);
-  }
-
-  @Test
-  public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
-    Drawable placeholder = new ColorDrawable(Color.RED);
-
-    MockTarget target = new MockTarget();
-
-    harness.placeholderDrawable = placeholder;
-    harness.target = target;
-    harness.model = null;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.begin();
-
-    assertEquals(placeholder, target.currentPlaceholder);
-  }
-
-  @Test
-  public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
-    Drawable placeholder = new ColorDrawable(Color.RED);
-    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
-
-    MockTarget target = new MockTarget();
-
-    harness.placeholderDrawable = placeholder;
-    harness.errorDrawable = errorPlaceholder;
-    harness.target = target;
-    harness.model = null;
-    SingleRequest<List> request = harness.getRequest();
-
-    request.begin();
-
-    assertEquals(errorPlaceholder, target.currentPlaceholder);
-  }
-
-
-  @Test
-  public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
-    Drawable placeholder = new ColorDrawable(Color.RED);
-    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
-    Drawable fallback = new ColorDrawable(Color.BLUE);
-
-    MockTarget target = new MockTarget();
-    harness.placeholderDrawable = placeholder;
-    harness.errorDrawable = errorPlaceholder;
-    harness.fallbackDrawable = fallback;
-    harness.target = target;
-    harness.model = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    assertEquals(fallback, target.currentPlaceholder);
-  }
-
-
-  @Test
-  public void testIsNotRunningBeforeRunCalled() {
-    assertFalse(harness.getRequest().isRunning());
-  }
-
-  @Test
-  public void testIsRunningAfterRunCalled() {
-    Request request = harness.getRequest();
-    request.begin();
-    assertTrue(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotRunningAfterComplete() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-
-    assertFalse(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotRunningAfterFailing() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.onLoadFailed(new GlideException("test"));
-
-    assertFalse(request.isRunning());
-  }
-
-  @Test
-  public void testIsNotRunningAfterClear() {
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-    request.clear();
-
-    assertFalse(request.isRunning());
-  }
-
-  @Test
-  public void testCallsTargetOnResourceReadyIfNoRequestListener() {
-    harness.requestListener = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
-  }
-
-  @Test
-  public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
-            anyBoolean())).thenReturn(false);
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());
-  }
-
-  @Test
-  public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
-            anyBoolean())).thenReturn(true);
-    request.onResourceReady(harness.resource, DataSource.REMOTE);
-
-    verify(harness.target, never()).onResourceReady(any(List.class), anyTransition());
-  }
-
-  @Test
-  public void testCallsTargetOnExceptionIfNoRequestListener() {
-    harness.requestListener = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target).onLoadFailed(eq(harness.errorDrawable));
-  }
-
-  @Test
-  public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean()))
-        .thenReturn(false);
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target).onLoadFailed(eq(harness.errorDrawable));
-  }
-
-  @Test
-  public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
-        eq(harness.target), anyBoolean()))
-        .thenReturn(true);
-
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target, never()).onLoadFailed(any(Drawable.class));
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithResourceResult() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
-            anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithModel() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(any(List.class), eq(harness.model), isAListTarget(), isADataSource(),
-            anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithTarget() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),
-            anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
-    final SingleRequest<List> request = harness.getRequest();
-
-    when(harness.engine
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class)))
-        .thenAnswer(new Answer<Object>() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            request.onResourceReady(harness.resource, DataSource.MEMORY_CACHE);
-            return null;
-          }
-        });
-
-    request.begin();
-    request.onSizeReady(100, 100);
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
-            eq(DataSource.MEMORY_CACHE), anyBoolean());
-  }
-
-  @Test
-  public void
-  testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onSizeReady(100, 100);
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
-            eq(DataSource.LOCAL), anyBoolean());
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
-    harness.requestCoordinator = null;
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
-  }
-
-  @Test
-  public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),
-            eq(true));
-  }
-
-  @Test
-  public void
-  testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.requestListener)
-        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),
-            isADataSource(), eq(false));
-  }
-
-  @Test
-  public void testTargetIsCalledWithAnimationFromFactory() {
-    SingleRequest<List> request = harness.getRequest();
-    Transition<List> transition = mockTransition();
-    when(harness.factory.build(any(DataSource.class), anyBoolean())).thenReturn(transition);
-    request.onResourceReady(harness.resource, DataSource.DATA_DISK_CACHE);
-
-    verify(harness.target).onResourceReady(eq(harness.result), eq(transition));
-  }
-
-  @Test
-  public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
-    harness.overrideWidth = -1;
-    harness.overrideHeight = 100;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.target).getSize(any(SizeReadyCallback.class));
-  }
-
-  @Test
-  public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
-    harness.overrideHeight = -1;
-    harness.overrideWidth = 100;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.target).getSize(any(SizeReadyCallback.class));
-  }
-
-  @Test
-  public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
-    harness.overrideWidth = 100;
-    harness.overrideHeight = 100;
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.target, never()).getSize(any(SizeReadyCallback.class));
-  }
-
-  @Test
-  public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
-    harness.overrideWidth = 1;
-    harness.overrideHeight = 2;
-
-    SingleRequest<List> request = harness.getRequest();
-    request.begin();
-
-    verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
-  }
-
-  @Test
-  public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
-    harness.errorDrawable = new ColorDrawable(Color.RED);
-    SingleRequest<List> request = harness.getRequest();
-    when(harness.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
-    request.onLoadFailed(new GlideException("test"));
-
-    verify(harness.target, never()).onLoadFailed(any(Drawable.class));
-  }
-
-  @Test
-  public void testCanReRunCancelledRequests() {
-    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
-        .getSize(any(SizeReadyCallback.class));
-
-    when(harness.engine
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
-            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class)))
-        .thenAnswer(new CallResourceCallback(harness.resource));
-    SingleRequest<List> request = harness.getRequest();
-
-    request.begin();
-    request.cancel();
-    request.begin();
-
-    verify(harness.target, times(2)).onResourceReady(eq(harness.result), anyTransition());
-  }
-
-  @Test
-  public void testResourceOnlyReceivesOneGetOnResourceReady() {
-    SingleRequest<List> request = harness.getRequest();
-    request.onResourceReady(harness.resource, DataSource.LOCAL);
-
-    verify(harness.resource, times(1)).get();
-  }
-
-  @Test
-  public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
-    SingleRequest<List> request = harness.getRequest();
-    request.cancel();
-    request.onSizeReady(100, 100);
-
-    verify(harness.engine, never())
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
-  }
-
-  @SuppressWarnings("unchecked")
-  private static <T> Transition<T> mockTransition() {
-    return mock(Transition.class);
-  }
-
-  @SuppressWarnings("unchecked")
-  private static Target<List> isAListTarget() {
-    return isA(Target.class);
-  }
-
-  private static GlideException isAGlideException() {
-    return isA(GlideException.class);
-  }
-
-  @SuppressWarnings("unchecked")
-  private static <T> Transition<T> anyTransition() {
-    return any(Transition.class);
-  }
-
-  private static class CallResourceCallback implements Answer {
-
-    private Resource resource;
-
-    public CallResourceCallback(Resource resource) {
-      this.resource = resource;
-    }
-
-    @Override
-    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-      ResourceCallback cb =
-          (ResourceCallback) invocationOnMock.getArguments()[invocationOnMock.getArguments().length
-              - 1];
-      cb.onResourceReady(resource, DataSource.REMOTE);
-      return null;
-    }
-  }
-
-  private static class CallSizeReady implements Answer {
-
-    private int width;
-    private int height;
-
-    public CallSizeReady(int width, int height) {
-      this.width = width;
-      this.height = height;
-    }
-
-    @Override
-    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-      SizeReadyCallback cb = (SizeReadyCallback) invocationOnMock.getArguments()[0];
-      cb.onSizeReady(width, height);
-      return null;
-    }
-  }
-
-  private static class MockTarget implements Target<List> {
-    private Drawable currentPlaceholder;
-
-    @Override
-    public void onLoadCleared(Drawable placeholder) {
-      currentPlaceholder = placeholder;
-    }
-
-    @Override
-    public void onLoadStarted(Drawable placeholder) {
-      currentPlaceholder = placeholder;
-
-    }
-
-    @Override
-    public void onLoadFailed(Drawable errorDrawable) {
-      currentPlaceholder = errorDrawable;
-
-    }
-
-    @Override
-    public void onResourceReady(List resource, Transition<? super List> transition) {
-      currentPlaceholder = null;
-    }
-
-
-    @Override
-    public void getSize(SizeReadyCallback cb) {
-    }
-
-    @Override
-    public void setRequest(Request request) {
-    }
-
-    @Override
-    public Request getRequest() {
-      return null;
-    }
-
-    @Override
-    public void onStart() {
-    }
-
-    @Override
-    public void onStop() {
-
-    }
-
-    @Override
-    public void onDestroy() {
-
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
deleted file mode 100644
index 3debccfcd..000000000
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ /dev/null
@@ -1,491 +0,0 @@
-package com.bumptech.glide.request.target;
-
-import static android.view.ViewGroup.LayoutParams;
-import static android.view.ViewTreeObserver.OnPreDrawListener;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.content.Context;
-import android.graphics.drawable.Drawable;
-import android.view.View;
-import android.view.ViewTreeObserver;
-import android.view.WindowManager;
-
-import com.bumptech.glide.request.Request;
-import com.bumptech.glide.request.transition.Transition;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
-import org.robolectric.shadows.ShadowDisplay;
-import org.robolectric.shadows.ShadowView;
-import org.robolectric.shadows.ShadowViewTreeObserver;
-
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { ViewTargetTest.SizedShadowView.class,
-    ViewTargetTest.PreDrawShadowViewTreeObserver.class })
-public class ViewTargetTest {
-  private View view;
-  private ViewTarget target;
-  private SizedShadowView shadowView;
-  private PreDrawShadowViewTreeObserver shadowObserver;
-
-  @Before
-  public void setUp() {
-    view = new View(RuntimeEnvironment.application);
-    target = new TestViewTarget(view);
-
-    shadowView = (SizedShadowView) ShadowExtractor.extract(view);
-    shadowObserver =
-        (PreDrawShadowViewTreeObserver) ShadowExtractor.extract(view.getViewTreeObserver());
-  }
-
-  @Test
-  public void testReturnsWrappedView() {
-    assertEquals(view, target.getView());
-  }
-
-  @Test
-  public void testReturnsNullFromGetRequestIfNoRequestSet() {
-    assertNull(target.getRequest());
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testThrowsIfViewTagIsNotRequestObject() {
-    view.setTag(new Object());
-    target.getRequest();
-  }
-
-  @Test
-  public void testCanSetAndRetrieveRequest() {
-    Request request = mock(Request.class);
-
-    target.setRequest(request);
-
-    assertEquals(request, target.getRequest());
-  }
-
-  @Test
-  public void testRetrievesRequestFromPreviousTargetForView() {
-    Request request = mock(Request.class);
-
-    target.setRequest(request);
-
-    ViewTarget<View, Object> second = new TestViewTarget(view);
-
-    assertEquals(request, second.getRequest());
-  }
-
-  @Test
-  public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
-    int dimens = 333;
-    shadowView.setWidth(dimens);
-    shadowView.setHeight(dimens);
-
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    verify(cb).onSizeReady(eq(dimens), eq(dimens));
-  }
-
-  @Test
-  public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet() {
-    int dimens = 444;
-    LayoutParams layoutParams = new LayoutParams(dimens, dimens);
-    view.setLayoutParams(layoutParams);
-
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    verify(cb).onSizeReady(eq(dimens), eq(dimens));
-  }
-
-  private void setDisplayDimens(Integer width, Integer height) {
-    WindowManager windowManager =
-        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
-    ShadowDisplay shadowDisplay = Shadows.shadowOf(windowManager.getDefaultDisplay());
-    if (width != null) {
-      shadowDisplay.setWidth(width);
-    }
-
-    if (height != null) {
-      shadowDisplay.setHeight(height);
-    }
-  }
-
-  private void setDisplayWidth(int width) {
-    setDisplayDimens(width, null);
-  }
-
-  private void setDisplayHeight(int height) {
-    setDisplayDimens(null, height);
-  }
-
-  @Test
-  public void testBothParamsWrapContent() {
-    LayoutParams layoutParams =
-        new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
-    view.setLayoutParams(layoutParams);
-
-    int width = 123;
-    int height = 456;
-    setDisplayDimens(width, height);
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    verify(cb).onSizeReady(eq(width), eq(height));
-  }
-
-  @Test
-  public void testWrapContentWidthWithValidHeight() {
-    int displayWidth = 500;
-    setDisplayWidth(displayWidth);
-
-    int height = 100;
-    LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
-    view.setLayoutParams(params);
-
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    verify(cb).onSizeReady(eq(displayWidth), eq(height));
-  }
-
-  @Test
-  public void testWrapContentHeightWithValidWidth() {
-    int displayHeight = 700;
-    setDisplayHeight(displayHeight);
-    int width = 100;
-    LayoutParams params = new LayoutParams(width, LayoutParams.WRAP_CONTENT);
-    view.setLayoutParams(params);
-
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    verify(cb).onSizeReady(eq(width), eq(displayHeight));
-  }
-
-  @Test
-  public void testWrapContentWidthWithMatchParentHeight() {
-    int displayWidth = 1234;
-    setDisplayWidth(displayWidth);
-
-    LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
-    view.setLayoutParams(params);
-
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    verify(cb, never()).onSizeReady(anyInt(), anyInt());
-
-    int height = 32;
-    shadowView.setHeight(height);
-
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb).onSizeReady(eq(displayWidth), eq(height));
-  }
-
-  @Test
-  public void testWrapContentHeightWithMatchParentWidth() {
-    int displayHeight = 5812;
-    setDisplayHeight(displayHeight);
-
-    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
-    view.setLayoutParams(params);
-
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    verify(cb, never()).onSizeReady(anyInt(), anyInt());
-
-    int width = 32;
-    shadowView.setWidth(width);
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb).onSizeReady(eq(width), eq(displayHeight));
-  }
-
-  @Test
-  public void testMatchParentWidthAndHeight() {
-    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-    view.setLayoutParams(params);
-
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    verify(cb, never()).onSizeReady(anyInt(), anyInt());
-
-    int width = 32;
-    int height = 45;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb).onSizeReady(eq(width), eq(height));
-  }
-
-  @Test
-  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    int width = 12;
-    int height = 32;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb).onSizeReady(eq(width), eq(height));
-  }
-
-  @Test
-  public void testSizeCallbacksAreCalledInOrderPreDraw() {
-    SizeReadyCallback[] cbs = new SizeReadyCallback[25];
-    for (int i = 0; i < cbs.length; i++) {
-      cbs[i] = mock(SizeReadyCallback.class);
-      target.getSize(cbs[i]);
-    }
-
-    int width = 100, height = 111;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
-    shadowObserver.fireOnPreDrawListeners();
-
-    InOrder order = inOrder((Object[]) cbs);
-    for (SizeReadyCallback cb : cbs) {
-      order.verify(cb).onSizeReady(eq(width), eq(height));
-    }
-  }
-
-  @Test
-  public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-    target.getSize(cb);
-
-    view.setLayoutParams(new LayoutParams(100, 100));
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
-  }
-
-  @Test
-  public void testDoesNotAddMultipleListenersIfMultipleCallbacksAreAdded() {
-    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
-    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
-    target.getSize(cb1);
-    target.getSize(cb2);
-    assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
-  }
-
-  @Test
-  public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest() {
-    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
-    target.getSize(cb1);
-
-    view.setLayoutParams(new LayoutParams(100, 100));
-    shadowObserver.fireOnPreDrawListeners();
-
-    assertThat(shadowObserver.getPreDrawListeners()).hasSize(0);
-
-    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
-    view.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-    target.getSize(cb2);
-
-    view.setLayoutParams(new LayoutParams(100, 100));
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb2).onSizeReady(anyInt(), anyInt());
-  }
-
-  @Test
-  public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb, never()).onSizeReady(anyInt(), anyInt());
-    assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
-  }
-
-  @Test
-  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    int width = 689;
-    int height = 354;
-    LayoutParams layoutParams = new LayoutParams(width, height);
-    view.setLayoutParams(layoutParams);
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb).onSizeReady(eq(width), eq(height));
-  }
-
-  @Test
-  public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    LayoutParams layoutParams = new LayoutParams(1234, 4123);
-    view.setLayoutParams(layoutParams);
-    shadowObserver.fireOnPreDrawListeners();
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
-  }
-
-  @Test
-  public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
-    SizeReadyCallback firstCb = mock(SizeReadyCallback.class);
-    SizeReadyCallback secondCb = mock(SizeReadyCallback.class);
-    target.getSize(firstCb);
-    target.getSize(secondCb);
-
-    int width = 68;
-    int height = 875;
-    LayoutParams layoutParams = new LayoutParams(width, height);
-    view.setLayoutParams(layoutParams);
-    shadowObserver.fireOnPreDrawListeners();
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(firstCb, times(1)).onSizeReady(eq(width), eq(height));
-    verify(secondCb, times(1)).onSizeReady(eq(width), eq(height));
-  }
-
-  @Test
-  public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
-    target.getSize(cb);
-
-    int width = 1;
-    int height = 2;
-    LayoutParams layoutParams = new LayoutParams(width, height);
-    view.setLayoutParams(layoutParams);
-    shadowObserver.setIsAlive(false);
-    shadowObserver.fireOnPreDrawListeners();
-
-    verify(cb).onSizeReady(eq(width), eq(height));
-  }
-
-  @Test(expected = NullPointerException.class)
-  public void testThrowsIfGivenNullView() {
-    new TestViewTarget(null);
-  }
-
-  @Implements(ViewTreeObserver.class)
-  public static class PreDrawShadowViewTreeObserver extends ShadowViewTreeObserver {
-    private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
-    private boolean isAlive = true;
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public void addOnPreDrawListener(OnPreDrawListener listener) {
-      checkIsAlive();
-      preDrawListeners.add(listener);
-    }
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public void removeOnPreDrawListener(OnPreDrawListener listener) {
-      checkIsAlive();
-      preDrawListeners.remove(listener);
-    }
-
-    @Implementation
-    public boolean isAlive() {
-      return isAlive;
-    }
-
-    private void checkIsAlive() {
-      if (!isAlive()) {
-        throw new IllegalStateException("ViewTreeObserver is not alive!");
-      }
-    }
-
-    public void setIsAlive(boolean isAlive) {
-      this.isAlive = isAlive;
-    }
-
-    public void fireOnPreDrawListeners() {
-      for (OnPreDrawListener listener : preDrawListeners) {
-        listener.onPreDraw();
-      }
-    }
-
-    public List<OnPreDrawListener> getPreDrawListeners() {
-      return preDrawListeners;
-    }
-  }
-
-  @Implements(View.class)
-  public static class SizedShadowView extends ShadowView {
-    private int width;
-    private int height;
-
-    public void setWidth(int width) {
-      this.width = width;
-    }
-
-    public void setHeight(int height) {
-      this.height = height;
-    }
-
-    @Implementation
-    public int getWidth() {
-      return width;
-    }
-
-    @Implementation
-    public int getHeight() {
-      return height;
-    }
-  }
-
-  private static class TestViewTarget extends ViewTarget<View, Object> {
-
-    public TestViewTarget(View view) {
-      super(view);
-    }
-
-    @Override
-    public void onLoadStarted(Drawable placeholder) {
-
-    }
-
-    @Override
-    public void onLoadFailed(Drawable errorDrawable) {
-
-    }
-
-    @Override
-    public void onResourceReady(Object resource, Transition transition) {
-
-    }
-
-    @Override
-    public void onLoadCleared(Drawable placeholder) {
-
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
deleted file mode 100644
index 3d444fd17..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.bumptech.glide.signature;
-
-import static org.junit.Assert.assertNotNull;
-
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.After;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ApplicationVersionSignatureTest {
-
-  @After
-  public void tearDown() {
-    ApplicationVersionSignature.reset();
-  }
-
-  @Test
-  public void testCanGetKeyForSignature() {
-    Key key = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    assertNotNull(key);
-  }
-
-  @Test
-  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
-      throws NoSuchAlgorithmException, UnsupportedEncodingException {
-    Key first = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    Key second = ApplicationVersionSignature.obtain(RuntimeEnvironment.application);
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
deleted file mode 100644
index 46b41c9ba..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class MediaStoreSignatureTest {
-
-  @Test
-  public void testSignaturesDifferIfMimeTypeDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("first", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("second", 100, 1);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesDifferIfDateModifiedDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 999, 1);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesDifferIfOrientationDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 9);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSignaturesAreTheSameIfAllArgsAreTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    MediaStoreSignature first = new MediaStoreSignature("mimeType", 100, 1);
-    MediaStoreSignature second = new MediaStoreSignature("mimeType", 100, 1);
-
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
deleted file mode 100644
index 2012092af..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class ObjectKeyTest {
-
-  @Test
-  public void testEquals() throws NoSuchAlgorithmException {
-    Object object = new Object();
-    KeyAssertions.assertSame(new ObjectKey(object), new ObjectKey(object));
-    KeyAssertions.assertDifferent(new ObjectKey(object), new ObjectKey(new Object()));
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java
deleted file mode 100644
index 463d17cca..000000000
--- a/library/src/test/java/com/bumptech/glide/signature/StringSignatureTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.bumptech.glide.signature;
-
-import com.bumptech.glide.tests.KeyAssertions;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
-@RunWith(JUnit4.class)
-public class StringSignatureTest {
-
-  @Test
-  public void testStringSignatureIsNotEqualIfStringDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    StringSignature first = new StringSignature("first");
-    StringSignature second = new StringSignature("second");
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testStringSignatureIsEqualIfStringIsTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    StringSignature first = new StringSignature("signature");
-    StringSignature second = new StringSignature("signature");
-
-    KeyAssertions.assertSame(first, second);
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
deleted file mode 100644
index 80d7dc3a9..000000000
--- a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.bumptech.glide.tests;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.testing.EqualsTester;
-
-import com.bumptech.glide.load.Key;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-public class KeyAssertions {
-
-  public static void assertSame(Key first, Key second) throws NoSuchAlgorithmException {
-    assertSameOrdered(first, second);
-    assertSameOrdered(second, first);
-  }
-
-  private static void assertSameOrdered(Key first, Key second) throws NoSuchAlgorithmException {
-    new EqualsTester()
-        .addEqualityGroup(first, second)
-        .testEquals();
-
-    assertThat(getDigest(first)).isEqualTo(getDigest(second));
-  }
-
-  public static void assertDifferent(Key first, Key second) throws NoSuchAlgorithmException {
-    assertDifferent(first, second, true);
-    assertDifferent(second, first, true);
-  }
-
-  public static void assertDifferent(Key first, Key second, boolean checkDiskCacheKey)
-      throws NoSuchAlgorithmException {
-    new EqualsTester()
-        .addEqualityGroup(first)
-        .addEqualityGroup(second)
-        .testEquals();
-
-    if (checkDiskCacheKey) {
-      MessageDigest firstDigest = MessageDigest.getInstance("SHA-1");
-      first.updateDiskCacheKey(firstDigest);
-      MessageDigest secondDigest = MessageDigest.getInstance("SHA-1");
-      second.updateDiskCacheKey(secondDigest);
-
-      assertThat(getDigest(first)).isNotEqualTo(getDigest(second));
-    }
-  }
-
-  private static byte[] getDigest(Key key) throws NoSuchAlgorithmException {
-    MessageDigest md = MessageDigest.getInstance("SHA-1");
-    key.updateDiskCacheKey(md);
-    return md.digest();
-  }
-}
diff --git a/library/src/test/resources/exif-orientation-examples b/library/src/test/resources/exif-orientation-examples
deleted file mode 160000
index 85c6e142e..000000000
--- a/library/src/test/resources/exif-orientation-examples
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 85c6e142ee57d1c5c7a29b2efcd5980a584758e2
diff --git a/library/test/build.gradle b/library/test/build.gradle
new file mode 100644
index 000000000..67c391819
--- /dev/null
+++ b/library/test/build.gradle
@@ -0,0 +1,51 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    testImplementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    testImplementation project(':library')
+    testImplementation project(':testutil')
+    testImplementation 'com.google.guava:guava-testlib:18.0'
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+}
+
+tasks.withType(JavaCompile) {
+    options.fork = true
+}
+
+afterEvaluate {
+    lint.enabled = false
+    compileDebugJavaWithJavac.enabled = false
+}
+
+android.testOptions.unitTests.all { Test testTask ->
+    // configure max heap size of the test JVM
+    testTask.maxHeapSize = TEST_JVM_MEMORY_SIZE as String
+    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {
+        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0
+        testTask.jvmArgs "-XX:MaxPermSize=${TEST_JVM_MEMORY_SIZE}"
+    }
+
+    // Initializing Robolectric is expensive, two threads seem to be around the only level where any
+    // improvement is seen.
+    testTask.maxParallelForks = 2
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
diff --git a/library/test/src/main/AndroidManifest.xml b/library/test/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..600ac91f9
--- /dev/null
+++ b/library/test/src/main/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.bumptech.glide.test">
+    <application/>
+</manifest>
diff --git a/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
new file mode 100644
index 000000000..2281d5706
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/GlideContextTest.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.util.Log;
+import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.ImageViewTargetFactory;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public final class GlideContextTest {
+  private Map<Class<?>, TransitionOptions<?, ?>> transitionOptions;
+  private GlideContext context;
+
+  @Before
+  public void setUp() {
+    Application app = RuntimeEnvironment.application;
+
+    transitionOptions = new HashMap<>();
+    context = new GlideContext(
+        app,
+        new LruArrayPool(),
+        new Registry(),
+        new ImageViewTargetFactory(),
+        new RequestOptions(),
+        transitionOptions,
+        mock(Engine.class),
+        Log.DEBUG);
+  }
+
+  @Test
+  public void getDefaultTransitionOptions_withNoOptionsRegistered_returnsDefaultOptions() {
+    assertThat(context.getDefaultTransitionOptions(Object.class))
+        .isEqualTo(GlideContext.DEFAULT_TRANSITION_OPTIONS);
+  }
+
+  @Test
+  public void getDefaultTransitionOptions_withNonMatchingOptionRegistered_returnsDefaultOptions() {
+    transitionOptions.put(Bitmap.class, new GenericTransitionOptions<>());
+    assertThat(context.getDefaultTransitionOptions(Drawable.class))
+        .isEqualTo(GlideContext.DEFAULT_TRANSITION_OPTIONS);
+  }
+
+  @Test
+  public void getDefaultTransitionOptions_withMatchingOptionsRegistered_returnsMatchingOptions() {
+    GenericTransitionOptions<Object> expected = new GenericTransitionOptions<>();
+    transitionOptions.put(Bitmap.class, expected);
+    assertThat(context.getDefaultTransitionOptions(Bitmap.class))
+        .isEqualTo(expected);
+  }
+
+  @Test
+  public void getDefaultTransitionOptions_withSuperClassRegistered_returnsSuperClassOptions() {
+    DrawableTransitionOptions expected = new DrawableTransitionOptions();
+    transitionOptions.put(Drawable.class, expected);
+    assertThat(context.getDefaultTransitionOptions(BitmapDrawable.class))
+        .isEqualTo(expected);
+    assertThat(context.getDefaultTransitionOptions(GifDrawable.class))
+        .isEqualTo(expected);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
similarity index 62%
rename from library/src/test/java/com/bumptech/glide/GlideTest.java
rename to library/test/src/test/java/com/bumptech/glide/GlideTest.java
index 01bdd28b8..68ee3870f 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
@@ -1,8 +1,12 @@
 package com.bumptech.glide;
 
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
+import static com.bumptech.glide.request.RequestOptions.errorOf;
 import static com.bumptech.glide.request.RequestOptions.placeholderOf;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
@@ -15,7 +19,6 @@
 
 import android.content.ContentResolver;
 import android.content.Context;
-import android.content.pm.ApplicationInfo;
 import android.content.res.AssetFileDescriptor;
 import android.graphics.Bitmap;
 import android.graphics.Color;
@@ -24,12 +27,12 @@
 import android.graphics.drawable.Drawable;
 import android.media.MediaMetadataRetriever;
 import android.net.Uri;
-import android.os.Bundle;
 import android.os.Handler;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
@@ -39,6 +42,7 @@
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
@@ -46,20 +50,33 @@
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.RequestManagerTreeNode;
-import com.bumptech.glide.module.GlideModule;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.testutil.TestResourceUtil;
-
-import org.junit.After;
+import com.bumptech.glide.util.Preconditions;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Map;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
@@ -69,20 +86,9 @@
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
-import org.robolectric.internal.ShadowExtractor;
-import org.robolectric.res.builder.RobolectricPackageManager;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.nio.ByteBuffer;
-import java.util.HashMap;
-import java.util.Map;
-
 /**
  * Tests for the {@link Glide} interface and singleton.
  */
@@ -91,72 +97,135 @@
     GlideTest.ShadowFileDescriptorContentResolver.class,
     GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
     GlideTest.MutableShadowBitmap.class })
+@SuppressWarnings("unchecked")
 public class GlideTest {
-  private Target target = null;
+  // Fixes method overload confusion.
+  private static final Object NULL = null;
+
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @SuppressWarnings("rawtypes")
+  @Mock private Target target;
+  @Mock private DiskCache.Factory diskCacheFactory;
+  @Mock private DiskCache diskCache;
+  @Mock private MemoryCache memoryCache;
+  @Mock private Handler bgHandler;
+  @Mock private Lifecycle lifecycle;
+  @Mock private RequestManagerTreeNode treeNode;
+  @Mock private BitmapPool bitmapPool;
+
   private ImageView imageView;
   private RequestManager requestManager;
+  private Context context;
 
   @Before
-  public void setUp() throws Exception {
-    Glide.tearDown();
-
-    RobolectricPackageManager pm =
-        (RobolectricPackageManager) RuntimeEnvironment.application.getPackageManager();
-    ApplicationInfo info =
-        pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
-    info.metaData = new Bundle();
-    info.metaData.putString(SetupModule.class.getName(), "GlideModule");
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+
+    // Run all tasks on the main thread so they complete synchronously.
+    GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
+    when(diskCacheFactory.build()).thenReturn(diskCache);
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setMemoryCache(memoryCache)
+            .setDiskCache(diskCacheFactory)
+            .setSourceExecutor(executor)
+            .setDiskCacheExecutor(executor));
+    Registry registry = Glide.get(context).getRegistry();
+    registerMockModelLoader(
+        GlideUrl.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, InputStream.class, new ByteArrayInputStream(new byte[0]), registry);
+    registerMockModelLoader(
+        File.class, ParcelFileDescriptor.class, mock(ParcelFileDescriptor.class), registry);
+    registerMockModelLoader(File.class, ByteBuffer.class, ByteBuffer.allocate(10), registry);
 
     // Ensure that target's size ready callback will be called synchronously.
-    target = mock(Target.class);
-    imageView = new ImageView(RuntimeEnvironment.application);
+    imageView = new ImageView(context);
     imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
+    imageView.layout(0, 0, 100, 100);
     doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
 
-    Handler bgHandler = mock(Handler.class);
     when(bgHandler.post(isA(Runnable.class))).thenAnswer(new Answer<Boolean>() {
       @Override
-      public Boolean answer(InvocationOnMock invocation) throws Throwable {
+      public Boolean answer(InvocationOnMock invocation) {
         Runnable runnable = (Runnable) invocation.getArguments()[0];
         runnable.run();
         return true;
       }
     });
 
-    Lifecycle lifecycle = mock(Lifecycle.class);
-    RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-    requestManager = new RequestManager(getContext(), lifecycle, treeNode);
+    requestManager = new RequestManager(Glide.get(context), lifecycle, treeNode, context);
     requestManager.resumeRequests();
   }
 
-  @After
-  public void tearDown() {
-    Glide.tearDown();
+  @Test
+  public void testCanSetMemoryCategory() {
+    MemoryCategory memoryCategory = MemoryCategory.NORMAL;
+    Glide glide =
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
+    glide.setMemoryCategory(memoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
   }
 
   @Test
-  public void testCanSetMemoryCategory() {
-    MemoryCache memoryCache = mock(MemoryCache.class);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
+  public void testCanIncreaseMemoryCategory() {
+    MemoryCategory memoryCategory = MemoryCategory.NORMAL;
+    Glide glide =
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
+    glide.setMemoryCategory(memoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+
+    MemoryCategory newMemoryCategory = MemoryCategory.HIGH;
+    MemoryCategory oldMemoryCategory = glide.setMemoryCategory(newMemoryCategory);
+
+    assertEquals(memoryCategory, oldMemoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
+  }
 
+  @Test
+  public void testCanDecreaseMemoryCategory() {
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder(getContext()).setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
-            .createGlide();
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
     verify(bitmapPool).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
+
+    MemoryCategory newMemoryCategory = MemoryCategory.LOW;
+    MemoryCategory oldMemoryCategory = glide.setMemoryCategory(newMemoryCategory);
+
+    assertEquals(memoryCategory, oldMemoryCategory);
+
+    verify(memoryCache).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
+    verify(bitmapPool).setSizeMultiplier(eq(newMemoryCategory.getMultiplier()));
   }
 
   @Test
   public void testClearMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .createGlide();
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
 
     glide.clearMemory();
 
@@ -166,12 +235,11 @@ public void testClearMemory() {
 
   @Test
   public void testTrimMemory() {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    MemoryCache memoryCache = mock(MemoryCache.class);
-
     Glide glide =
-        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .createGlide();
+        new GlideBuilder()
+            .setBitmapPool(bitmapPool)
+            .setMemoryCache(memoryCache)
+            .build(context);
 
     final int level = 123;
 
@@ -182,13 +250,13 @@ public void testTrimMemory() {
   }
 
   @Test
-  public void testFileDefaultLoaderWithInputStream() throws Exception {
+  public void testFileDefaultLoaderWithInputStream() {
     registerFailFactory(File.class, ParcelFileDescriptor.class);
     runTestFileDefaultLoader();
   }
 
   @Test
-  public void testFileDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testFileDefaultLoaderWithFileDescriptor() {
     registerFailFactory(File.class, InputStream.class);
     runTestFileDefaultLoader();
   }
@@ -211,6 +279,7 @@ private void runTestFileDefaultLoader() {
     assertNotNull(imageView.getDrawable());
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   public void testUrlDefaultLoader() throws MalformedURLException {
     URL url = new URL("http://www.google.com");
@@ -245,13 +314,53 @@ public void testToBytesOption() {
   }
 
   @Test
-  public void testUriDefaultLoaderWithInputStream() throws Exception {
+  public void testLoadColorDrawable_withUnitBitmapTransformation_returnsColorDrawable() {
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .override(100, 100)
+            .centerCrop())
+        .into(target);
+
+    ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(argumentCaptor.capture(), isA(Transition.class));
+
+    Object result = argumentCaptor.getValue();
+
+    assertThat(result).isInstanceOf(ColorDrawable.class);
+    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);
+  }
+
+  @Test
+  public void testLoadColorDrawable_withNonUnitBitmapTransformation_returnsBitmapDrawable() {
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(colorDrawable)
+        .apply(new RequestOptions()
+            .override(100, 100)
+            .circleCrop())
+        .into(target);
+
+    ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(argumentCaptor.capture(), isA(Transition.class));
+
+    Object result = argumentCaptor.getValue();
+
+    assertThat(result).isInstanceOf(BitmapDrawable.class);
+    Bitmap bitmap = ((BitmapDrawable) result).getBitmap();
+    assertThat(bitmap.getWidth()).isEqualTo(100);
+    assertThat(bitmap.getHeight()).isEqualTo(100);
+  }
+
+  @Test
+  public void testUriDefaultLoaderWithInputStream() {
     registerFailFactory(Uri.class, ParcelFileDescriptor.class);
     runTestUriDefaultLoader();
   }
 
   @Test
-  public void testUriDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testUriDefaultLoaderWithFileDescriptor() {
     registerFailFactory(Uri.class, InputStream.class);
     runTestUriDefaultLoader();
   }
@@ -280,13 +389,13 @@ public void testStringDefaultLoaderWithUrl() {
   }
 
   @Test
-  public void testFileStringDefaultLoaderWithInputStream() throws Exception {
+  public void testFileStringDefaultLoaderWithInputStream() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestFileStringDefaultLoader();
   }
 
   @Test
-  public void testFileStringDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testFileStringDefaultLoaderWithFileDescriptor() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestFileStringDefaultLoader();
   }
@@ -303,13 +412,13 @@ private void runTestFileStringDefaultLoader() {
   }
 
   @Test
-  public void testUriStringDefaultLoaderWithInputStream() throws Exception {
+  public void testUriStringDefaultLoaderWithInputStream() {
     registerFailFactory(String.class, ParcelFileDescriptor.class);
     runTestUriStringDefaultLoader();
   }
 
   @Test
-  public void testUriStringDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testUriStringDefaultLoaderWithFileDescriptor() {
     registerFailFactory(String.class, InputStream.class);
     runTestUriStringDefaultLoader();
   }
@@ -328,13 +437,13 @@ private void runTestUriStringDefaultLoader() {
   private void runTestStringDefaultLoader(String string) {
     requestManager.load(string).listener(new RequestListener<Drawable>() {
       @Override
-      public boolean onLoadFailed(GlideException e, Object model, Target target,
+      public boolean onLoadFailed(GlideException e, Object model, Target<Drawable> target,
           boolean isFirstResource) {
         throw new RuntimeException("Load failed");
       }
 
       @Override
-      public boolean onResourceReady(Drawable resource, Object model, Target target,
+      public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target,
           DataSource dataSource, boolean isFirstResource) {
         return false;
       }
@@ -348,13 +457,13 @@ public boolean onResourceReady(Drawable resource, Object model, Target target,
   }
 
   @Test
-  public void testIntegerDefaultLoaderWithInputStream() throws Exception {
+  public void testIntegerDefaultLoaderWithInputStream() {
     registerFailFactory(Integer.class, ParcelFileDescriptor.class);
     runTestIntegerDefaultLoader();
   }
 
   @Test
-  public void testIntegerDefaultLoaderWithFileDescriptor() throws Exception {
+  public void testIntegerDefaultLoaderWithFileDescriptor() {
     registerFailFactory(Integer.class, InputStream.class);
     runTestIntegerDefaultLoader();
   }
@@ -405,9 +514,9 @@ public void testNonDefaultModelWithRegisteredFactoryDoesNotThrow() {
   }
 
   @Test
-  public void testReceivesGif() throws IOException {
+  public void testReceivesGif() {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
     requestManager.asGif().load(fakeUri).into(target);
@@ -416,9 +525,9 @@ public void testReceivesGif() throws IOException {
   }
 
   @Test
-  public void testReceivesGifBytes() throws IOException {
+  public void testReceivesGifBytes() {
     String fakeUri = "content://fake";
-    InputStream testGifData = openResource("test.gif");
+    InputStream testGifData = openGif();
     mockUri(Uri.parse(fakeUri), testGifData);
 
     requestManager.as(byte[].class).apply(decodeTypeOf(GifDrawable.class)).load(fakeUri)
@@ -468,25 +577,25 @@ public void testReceivesRecursiveThumbnailWithPercentage() {
 
   @Test
   public void testNullModelInGenericImageLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericVideoLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelDoesNotThrow() {
     Drawable drawable = new ColorDrawable(Color.RED);
     requestManager
-        .load(null)
-        .apply(placeholderOf(drawable))
+        .load(NULL)
+        .apply(errorOf(drawable))
         .into(target);
 
     verify(target).onLoadFailed(eq(drawable));
@@ -498,7 +607,7 @@ public void testNullModelPrefersErrorDrawable() {
     Drawable error = new ColorDrawable(Color.RED);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder)
             .error(error))
         .into(target);
@@ -507,13 +616,47 @@ public void testNullModelPrefersErrorDrawable() {
   }
 
   @Test
-  public void testNullModelPrefersFallbackDrwaable() {
+  public void testLoadBitmap_asBitmap() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager
+        .asBitmap()
+        .load(bitmap)
+        .into(target);
+
+    verify(target).onResourceReady(eq(bitmap), any(Transition.class));
+  }
+
+  @Test
+  public void testLoadBitmap_asDrawable() {
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    requestManager
+        .load(bitmap)
+        .into(target);
+
+    ArgumentCaptor<Object> captor = ArgumentCaptor.forClass(Object.class);
+    verify(target).onResourceReady(captor.capture(), any(Transition.class));
+    BitmapDrawable drawable = (BitmapDrawable) captor.getValue();
+    assertThat(drawable.getBitmap()).isEqualTo(bitmap);
+  }
+
+  @Test
+  public void testLoadDrawable() {
+    Drawable drawable = new ColorDrawable(Color.RED);
+    requestManager
+        .load(drawable)
+        .into(target);
+
+    verify(target).onResourceReady(eq(drawable), any(Transition.class));
+  }
+
+  @Test
+  public void testNullModelPrefersFallbackDrawable() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
     Drawable error = new ColorDrawable(Color.RED);
     Drawable fallback = new ColorDrawable(Color.BLUE);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder)
             .error(error)
             .fallback(fallback))
@@ -522,6 +665,18 @@ public void testNullModelPrefersFallbackDrwaable() {
     verify(target).onLoadFailed(eq(fallback));
   }
 
+  @Test
+  public void testNullModelResolvesToUsePlaceholder() {
+    Drawable placeholder = new ColorDrawable(Color.GREEN);
+
+    requestManager
+        .load(NULL)
+        .apply(placeholderOf(placeholder))
+        .into(target);
+
+    verify(target).onLoadFailed(eq(placeholder));
+  }
+
   @Test
   public void testByteData() {
     byte[] data = new byte[] { 1, 2, 3, 4, 5, 6 };
@@ -529,12 +684,30 @@ public void testByteData() {
   }
 
   @Test
-  public void testClone() throws IOException {
-    Target firstTarget = mock(Target.class);
+  public void removeFromManagers_afterRequestManagerRemoved_clearsRequest() {
+    target = requestManager.load(mockUri("content://uri")).into(new SimpleTarget<Drawable>() {
+      @Override
+      public void onResourceReady(@NonNull Drawable resource,
+          @Nullable Transition<? super Drawable> transition) {
+        // Do nothing.
+      }
+    });
+    Request request = Preconditions.checkNotNull(target.getRequest());
+
+    requestManager.onDestroy();
+    requestManager.clear(target);
+
+    assertThat(target.getRequest()).isNull();
+    assertThat(request.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void testClone() {
+    Target<Drawable> firstTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(isA(SizeReadyCallback.class));
-    Target secondTarget = mock(Target.class);
+    Target<Drawable> secondTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(isA(SizeReadyCallback.class));
-    RequestBuilder<Drawable> firstRequest = Glide.with(getContext())
+    RequestBuilder<Drawable> firstRequest = requestManager
         .load(mockUri("content://first"));
 
     firstRequest.into(firstTarget);
@@ -543,15 +716,14 @@ public void testClone() throws IOException {
         .apply(placeholderOf(new ColorDrawable(Color.RED)))
         .into(secondTarget);
 
-    verify(firstTarget).onResourceReady(isA(BitmapDrawable.class), isA(Transition.class));
-    verify(secondTarget).onResourceReady(notNull(), isA(Transition.class));
+    verify(firstTarget).onResourceReady(isA(Drawable.class), isA(Transition.class));
+    verify(secondTarget).onResourceReady(notNull(Drawable.class), isA(Transition.class));
   }
 
   @SuppressWarnings("unchecked")
-  private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource)
-      throws Exception {
+  private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource) {
     DataFetcher<Z> failFetcher = mock(DataFetcher.class);
-    doAnswer(new Util.CallDataReady(null))
+    doAnswer(new Util.CallDataReady<>(null))
         .when(failFetcher)
         .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
     when(failFetcher.getDataClass()).thenReturn(failResource);
@@ -560,27 +732,25 @@ public void testClone() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), failFetcher));
     when(failLoader.handles(isA(failModel))).thenReturn(true);
     ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
-    when(failFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(failLoader);
+    when(failFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(failLoader);
 
-    Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
+    Glide.get(context).getRegistry().prepend(failModel, failResource, failFactory);
   }
 
   private String mockUri(String uriString) {
     return mockUri(Uri.parse(uriString), null);
   }
 
-  private String mockUri(Uri uri) {
-    return mockUri(uri, null);
+  private void mockUri(Uri uri) {
+    mockUri(uri, null);
   }
 
   private String mockUri(Uri uri, InputStream is) {
     if (is == null) {
       is = new ByteArrayInputStream(new byte[0]);
     }
-    ContentResolver contentResolver = RuntimeEnvironment.application.getContentResolver();
-    ShadowFileDescriptorContentResolver shadowContentResolver =
-        (ShadowFileDescriptorContentResolver) ShadowExtractor.extract(contentResolver);
+    ContentResolver contentResolver = context.getContentResolver();
+    ShadowFileDescriptorContentResolver shadowContentResolver = Shadow.extract(contentResolver);
     shadowContentResolver.registerInputStream(uri, is);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
@@ -591,18 +761,13 @@ private String mockUri(Uri uri, InputStream is) {
     return uri.toString();
   }
 
-  private Context getContext() {
-    return RuntimeEnvironment.application;
-  }
-
   @SuppressWarnings("unchecked")
   private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
     ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
-    when(modelLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(modelLoader);
+    when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
-    Glide.get(RuntimeEnvironment.application).getRegistry()
+    Glide.get(context).getRegistry()
         .prepend(modelClass, InputStream.class, modelLoaderFactory);
   }
 
@@ -611,7 +776,7 @@ private Context getContext() {
     ModelLoader<T, InputStream> modelLoader = mock(ModelLoader.class);
     DataFetcher<InputStream> fetcher = mock(DataFetcher.class);
     try {
-      doAnswer(new Util.CallDataReady(new ByteArrayInputStream(new byte[0]))).when(fetcher)
+      doAnswer(new Util.CallDataReady<>(new ByteArrayInputStream(new byte[0]))).when(fetcher)
           .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
     } catch (Exception e) {
       // Do nothing.
@@ -624,19 +789,19 @@ private Context getContext() {
     return modelLoader;
   }
 
-  private InputStream openResource(String imageName) throws IOException {
-    return TestResourceUtil.openResource(getClass(), imageName);
+  private InputStream openGif() {
+    return TestResourceUtil.openResource(getClass(), "test.gif");
   }
 
   private static class CallSizeReady implements Answer<Void> {
-    private int width;
-    private int height;
+    private final int width;
+    private final int height;
 
-    public CallSizeReady() {
+    CallSizeReady() {
       this(100, 100);
     }
 
-    public CallSizeReady(int width, int height) {
+    CallSizeReady(int width, int height) {
       this.width = width;
       this.height = height;
     }
@@ -649,61 +814,26 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  public static class SetupModule implements GlideModule {
-
-    @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
-      // Run all tasks on the main thread so they complete synchronously.
-      GlideExecutor executor = mock(GlideExecutor.class);
-      doAnswer(new Answer<Void>() {
-        @Override
-        public Void answer(InvocationOnMock invocation) throws Throwable {
-          Runnable runnable = (Runnable) invocation.getArguments()[0];
-          runnable.run();
-          return null;
-        }
-      }).when(executor).execute(isA(Runnable.class));
-
-      DiskCache.Factory diskCacheFactory = mock(DiskCache.Factory.class);
-      when(diskCacheFactory.build()).thenReturn(mock(DiskCache.class));
-
-      builder.setMemoryCache(mock(MemoryCache.class)).setDiskCache(diskCacheFactory)
-          .setResizeExecutor(executor).setDiskCacheExecutor(executor);
-    }
-
-    @Override
-    public void registerComponents(Context context, Registry registry) {
-      registerMockModelLoader(GlideUrl.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, InputStream.class,
-          new ByteArrayInputStream(new byte[0]), registry);
-      registerMockModelLoader(File.class, ParcelFileDescriptor.class,
-          mock(ParcelFileDescriptor.class), registry);
-      registerMockModelLoader(File.class, ByteBuffer.class,
-          ByteBuffer.allocate(10), registry);
+  private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
+      Y loadedData, Registry registry) {
+    DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
+    when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
+    try {
+      doAnswer(new Util.CallDataReady<>(loadedData))
+          .when(mockStreamFetcher)
+          .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
     }
+    ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
+    when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
+        .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
+    when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
+    ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
+    when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
+        .thenReturn(mockUrlLoader);
 
-    private static <X, Y> void registerMockModelLoader(Class<X> modelClass, Class<Y> dataClass,
-          Y loadedData, Registry registry) {
-      DataFetcher<Y> mockStreamFetcher = mock(DataFetcher.class);
-      when(mockStreamFetcher.getDataClass()).thenReturn(dataClass);
-      try {
-        doAnswer(new Util.CallDataReady<>(loadedData))
-            .when(mockStreamFetcher)
-            .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-      ModelLoader<X, Y> mockUrlLoader = mock(ModelLoader.class);
-      when(mockUrlLoader.buildLoadData(isA(modelClass), anyInt(), anyInt(), isA(Options.class)))
-          .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
-      when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
-      ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-      when(mockUrlLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-          .thenReturn(mockUrlLoader);
-
-      registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
-    }
+    registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
   }
 
   // TODO: Extending ShadowContentResolver results in exceptions because of some state issues
@@ -711,6 +841,7 @@ public void registerComponents(Context context, Registry registry) {
   // a different part of the test. Each one ends up with different registered uris, which causes
   // tests to fail. We shouldn't need to do this, but using static maps seems to fix the issue.
   @Implements(value = ContentResolver.class)
+  @SuppressWarnings("unused")
   public static class ShadowFileDescriptorContentResolver {
     private static final Map<Uri, AssetFileDescriptor> URI_TO_FILE_DESCRIPTOR = new HashMap<>();
     private static final Map<Uri, InputStream> URI_TO_INPUT_STREAMS = new HashMap<>();
@@ -721,11 +852,11 @@ public static void reset() {
       URI_TO_FILE_DESCRIPTOR.clear();
     }
 
-    public void registerInputStream(Uri uri, InputStream inputStream) {
+    void registerInputStream(Uri uri, InputStream inputStream) {
       URI_TO_INPUT_STREAMS.put(uri, inputStream);
     }
 
-    public void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
+    void registerAssetFileDescriptor(Uri uri, AssetFileDescriptor assetFileDescriptor) {
       URI_TO_FILE_DESCRIPTOR.put(uri, assetFileDescriptor);
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
index 34d04e635..e6c957d27 100644
--- a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.tests.Util.cast;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -7,11 +8,17 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
-
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,23 +29,15 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ListPreloaderTest {
 
-  @Mock private RequestBuilder<Bitmap> request;
+  @Mock private RequestBuilder<Object> request;
   @Mock private RequestManager requestManager;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
   }
 
@@ -48,6 +47,7 @@ public void testGetItemsIsCalledIncreasing() {
     final AtomicInteger calledCount = new AtomicInteger();
 
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         called.set(true);
@@ -71,21 +71,23 @@ public void testGetItemsIsCalledInOrderIncreasing() {
     }
 
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-
-      public int expectedPosition;
+      private int expectedPosition;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects.subList(position - 11, position + 1 - 11);
       }
 
+      @Nullable
       @Override
-      public RequestBuilder<Bitmap> getPreloadRequestBuilder(Object item) {
+      @SuppressWarnings("unchecked")
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition++;
         return mock(RequestBuilder.class);
@@ -101,6 +103,7 @@ public void testGetItemsIsCalledDecreasing() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         // Ignore the preload caused from us starting at the end
@@ -129,23 +132,26 @@ public void testGetItemsIsCalledInOrderDecreasing() {
     }
 
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      int expectedPosition = toPreload - 1;
+      private int expectedPosition = toPreload - 1;
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
         return new int[] { 10, 10 };
       }
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position == 40) {
-          return null;
+          return Collections.emptyList();
         }
         return objects.subList(position, position + 1);
       }
 
+      @Nullable
       @Override
-      public RequestBuilder<Bitmap> getPreloadRequestBuilder(Object item) {
+      @SuppressWarnings("unchecked")
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition--;
         return mock(RequestBuilder.class);
@@ -162,6 +168,7 @@ public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         called.set(true);
@@ -181,6 +188,7 @@ public void testGetItemsIsNeverCalledWithStartLessThanZero() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position >= 17) {
@@ -204,6 +212,7 @@ public void testGetItemsIsNeverCalledWithStartLessThanZero() {
   public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
     final AtomicInteger called = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         final int current = called.getAndIncrement();
@@ -224,6 +233,7 @@ public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
   public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
     final AtomicInteger called = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position >= 20) {
@@ -244,28 +254,30 @@ public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
   }
 
   @Test
-  public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException {
+  public void testMultipleItemsForPositionIncreasing() {
     final List<Object> objects = new ArrayList<>();
     objects.add(new Object());
     objects.add(new Object());
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      public int expectedPosition = (1 + 10) * 2;
+      private int expectedPosition = (1 + 10) * 2;
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects;
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPostion);
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+        assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition++;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
+      @Nullable
       @Override
-      public RequestBuilder getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         return request;
       }
     };
@@ -275,33 +287,35 @@ public RequestBuilder getPreloadRequestBuilder(Object item) {
 
     preloader.onScroll(null, 1, 10, 1 + 10 + 2);
 
-    List<Integer> allValues = getTagetsSizes(request, times(4));
+    List<Integer> allValues = getTargetsSizes(request, times(4));
     assertEquals(expected, allValues);
   }
 
   @Test
-  public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException {
+  public void testMultipleItemsForPositionDecreasing() {
     final List<Object> objects = new ArrayList<>();
     objects.add(new Object());
     objects.add(new Object());
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      int expectedPosition = objects.size() * 2 - 1;
+      private int expectedPosition = objects.size() * 2 - 1;
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects;
       }
 
       @Override
-      public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
-        assertEquals(expectedPosition / 2, adapterPostion);
+      public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
+        assertEquals(expectedPosition / 2, adapterPosition);
         assertEquals(expectedPosition % 2, itemPosition);
         expectedPosition--;
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
+      @Nullable
       @Override
-      public RequestBuilder getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         return request;
       }
     };
@@ -312,22 +326,26 @@ public RequestBuilder getPreloadRequestBuilder(Object item) {
     preloader.onScroll(null, 3, 2, 3 + 2);
     preloader.onScroll(null, 2, 2, 3 + 2);
 
-    List<Integer> allValues = getTagetsSizes(request, times(4));
+    List<Integer> allValues = getTargetsSizes(request, times(4));
     assertEquals(expected, allValues);
   }
 
-  private List<Integer> getTagetsSizes(RequestBuilder<?> requestBuilder, VerificationMode mode) {
+  private <Resource> List<Integer> getTargetsSizes(
+      RequestBuilder<Resource> requestBuilder, VerificationMode mode) {
     ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
-    ArgumentCaptor<Target> targetArgumentCaptor = ArgumentCaptor.forClass(Target.class);
+    ArgumentCaptor<Target<Resource>> targetArgumentCaptor =
+        cast(ArgumentCaptor.forClass(Target.class));
     SizeReadyCallback cb = mock(SizeReadyCallback.class);
     verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
-    for (Target target : targetArgumentCaptor.getAllValues()) {
+    for (Target<Resource> target : targetArgumentCaptor.getAllValues()) {
       target.getSize(cb);
     }
     verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
     return integerArgumentCaptor.getAllValues();
   }
 
+  // It's safe to ignore the return value of containsAllIn.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testItemsArePreloadedWithGlide() {
     final List<Object> objects = new ArrayList<>();
@@ -335,13 +353,15 @@ public void testItemsArePreloadedWithGlide() {
     objects.add(new Object());
     final HashSet<Object> loadedObjects = new HashSet<>();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects.subList(position - 11, position - 10);
       }
 
+      @Nullable
       @Override
-      public RequestBuilder getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
         loadedObjects.add(item);
         return super.getPreloadRequestBuilder(item);
       }
@@ -359,6 +379,7 @@ public RequestBuilder getPreloadRequestBuilder(Object item) {
     public ListPreloaderAdapter() {
     }
 
+    @NonNull
     @Override
     public List<Object> getPreloadItems(int position) {
       ArrayList<Object> result = new ArrayList<>(1);
@@ -366,13 +387,16 @@ public ListPreloaderAdapter() {
       return result;
     }
 
+    @Nullable
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Object item) {
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<Object> getPreloadRequestBuilder(@NonNull Object item) {
       return mock(RequestBuilder.class);
     }
 
+    @Nullable
     @Override
-    public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {
+    public int[] getPreloadSize(@NonNull Object item, int adapterPosition, int itemPosition) {
       return new int[] { 100, 100 };
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
similarity index 59%
rename from library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
rename to library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index f08fae2af..10a6bc568 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -1,21 +1,23 @@
 package com.bumptech.glide;
 
 import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.widget.ImageView;
-
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
-import com.bumptech.glide.tests.BackgroundUtil;
-
+import com.bumptech.glide.request.target.ViewTarget;
+import com.bumptech.glide.tests.BackgroundUtil.BackgroundTester;
+import com.bumptech.glide.tests.TearDownGlide;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -28,21 +30,28 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RequestBuilderTest {
-  @Mock GlideContext glideContext;
-  @Mock RequestManager requestManager;
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @Mock private GlideContext glideContext;
+  @Mock private RequestManager requestManager;
+  private Glide glide;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    glide = Glide.get(RuntimeEnvironment.application);
+    context = RuntimeEnvironment.application;
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new RequestBuilder(null /*context*/, requestManager, Object.class);
+    new RequestBuilder<>(null /*context*/, requestManager, Object.class, context);
   }
 
   @Test(expected = NullPointerException.class)
-  public void testThrowsWhenGlideAnimationFactoryIsNull() {
+  public void testThrowsWhenTransitionsOptionsIsNull() {
+    //noinspection ConstantConditions testing if @NonNull is enforced
     getNullModelRequest().transition(null);
   }
 
@@ -53,7 +62,7 @@ public void testDoesNotThrowWithNullModelWhenRequestIsBuilt() {
 
   @Test
   public void testAddsNewRequestToRequestTracker() {
-    Target target = mock(Target.class);
+    Target<Object> target = mock(Target.class);
     getNullModelRequest().into(target);
 
     verify(requestManager).track(eq(target), isA(Request.class));
@@ -62,7 +71,7 @@ public void testAddsNewRequestToRequestTracker() {
   @Test
   public void testRemovesPreviousRequestFromRequestTracker() {
     Request previous = mock(Request.class);
-    Target target = mock(Target.class);
+    Target<Object> target = mock(Target.class);
     when(target.getRequest()).thenReturn(previous);
 
     getNullModelRequest().into(target);
@@ -70,12 +79,13 @@ public void testRemovesPreviousRequestFromRequestTracker() {
     verify(requestManager).clear(eq(target));
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfGivenNullTarget() {
-    getNullModelRequest().into((Target) null);
+    //noinspection ConstantConditions testing if @NonNull is enforced
+    getNullModelRequest().into((Target<Object>) null);
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfGivenNullView() {
     getNullModelRequest().into((ImageView) null);
   }
@@ -83,33 +93,34 @@ public void testThrowsIfGivenNullView() {
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoViewCalledOnBackgroundThread() throws InterruptedException {
     final ImageView imageView = new ImageView(RuntimeEnvironment.application);
-    testInBackground(new BackgroundUtil.BackgroundTester() {
+    testInBackground(new BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
-        getNullModelRequest().into(imageView);
-
+      public void runTest() {
+       getNullModelRequest().into(imageView);
       }
     });
   }
 
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
-    final Target target = mock(Target.class);
-    testInBackground(new BackgroundUtil.BackgroundTester() {
+    final Target<Object> target = mock(Target.class);
+    testInBackground(new BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
-        getNullModelRequest().into(target);
+      public void runTest() {
+         getNullModelRequest().into(target);
       }
     });
   }
 
-  private RequestBuilder getNullModelRequest() {
+  private RequestBuilder<Object> getNullModelRequest() {
     when(glideContext.buildImageViewTarget(isA(ImageView.class), isA(Class.class)))
-        .thenReturn(mock(Target.class));
+        .thenReturn(mock(ViewTarget.class));
     when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
     when(requestManager.getDefaultRequestOptions())
-        .thenReturn((BaseRequestOptions) new RequestOptions());
-    return new RequestBuilder(glideContext, requestManager, Object.class)
+        .thenReturn(new RequestOptions());
+    when(requestManager.getDefaultTransitionOptions(any(Class.class)))
+        .thenReturn(new GenericTransitionOptions<>());
+    return new RequestBuilder<>(glide, requestManager, Object.class, context)
         .load((Object) null);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
similarity index 51%
rename from library/src/test/java/com/bumptech/glide/RequestManagerTest.java
rename to library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
index 0e171262f..a7a73ccae 100644
--- a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -10,18 +10,29 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.content.Context;
-
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
+import com.bumptech.glide.request.target.BaseTarget;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
-
+import com.bumptech.glide.tests.TearDownGlide;
+import java.io.File;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -35,30 +46,60 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerTest {
-  @Mock Lifecycle lifecycle = mock(Lifecycle.class);
-  @Mock RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
+  @Mock private Lifecycle lifecycle = mock(Lifecycle.class);
+  @Mock private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
 
   private RequestManager manager;
   private ConnectivityMonitor connectivityMonitor;
   private RequestTracker requestTracker;
   private ConnectivityListener connectivityListener;
+  private Application context;
+  private BaseTarget<Drawable> target;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
     connectivityMonitor = mock(ConnectivityMonitor.class);
     ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
     when(factory.build(isA(Context.class), isA(ConnectivityMonitor.ConnectivityListener.class)))
         .thenAnswer(new Answer<ConnectivityMonitor>() {
           @Override
-          public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
+          public ConnectivityMonitor answer(InvocationOnMock invocation) {
             connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
             return connectivityMonitor;
           }
         });
+
+    target = new BaseTarget<Drawable>() {
+      @Override
+      public void onResourceReady(@NonNull Drawable resource,
+          @Nullable Transition<? super Drawable> transition) {
+        // Empty.
+      }
+
+      @Override
+      public void getSize(@NonNull SizeReadyCallback cb) {
+        // Empty.
+      }
+
+      @Override
+      public void removeCallback(@NonNull SizeReadyCallback cb) {
+        // Empty.
+      }
+    };
+
     requestTracker = mock(RequestTracker.class);
-    manager = new RequestManager(RuntimeEnvironment.application, lifecycle, treeNode,
-        requestTracker, factory);
+    manager =
+        new RequestManager(
+            Glide.get(RuntimeEnvironment.application),
+            lifecycle,
+            treeNode,
+            requestTracker,
+            factory,
+            context);
   }
 
   @Test
@@ -125,7 +166,7 @@ public void testDoesNotRestartRequestsOnDisconnected() {
   public void testThrowsIfResumeCalledOnBackgroundThread() throws InterruptedException {
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         manager.resumeRequests();
       }
     });
@@ -135,7 +176,7 @@ public void runTest() throws Exception {
   public void testThrowsIfPauseCalledOnBackgroundThread() throws InterruptedException {
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         manager.pauseRequests();
       }
     });
@@ -148,4 +189,85 @@ public void testDelegatesIsPausedToRequestTracker() {
     when(requestTracker.isPaused()).thenReturn(false);
     assertFalse(manager.isPaused());
   }
+
+  @Test
+  public void clear_withRequestStartedInSiblingManager_doesNotThrow() {
+    final RequestManager child1 = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    final RequestManager child2 = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return new HashSet<>(java.util.Arrays.asList(child1, child2));
+          }
+        }, context);
+
+    File file = new File("fake");
+    child1.load(file).into(target);
+    child2.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInChildManager_doesNotThrow() {
+    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.singleton(child);
+          }
+        }, context);
+
+    File file = new File("fake");
+    child.load(file).into(target);
+    parent.clear(target);
+  }
+
+  @Test
+  public void clear_withRequestStartedInParentManager_doesNotThrow() {
+    final RequestManager child = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.emptySet();
+          }
+        }, context);
+    RequestManager parent = new RequestManager(Glide.get(context), lifecycle,
+        new RequestManagerTreeNode() {
+          @NonNull
+          @Override
+          public Set<RequestManager> getDescendants() {
+            return Collections.singleton(child);
+          }
+        }, context);
+
+    File file = new File("fake");
+
+    parent.load(file).into(target);
+    child.clear(target);
+  }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
new file mode 100644
index 000000000..6f2fc9d50
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -0,0 +1,149 @@
+package com.bumptech.glide.load;
+
+import static com.bumptech.glide.tests.Util.anyContext;
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RuntimeEnvironment;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
+public class MultiTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Mock private Transformation<Object> first;
+  @Mock private Transformation<Object> second;
+  @Mock private Resource<Object> initial;
+  @Mock private Resource<Object> firstTransformed;
+  @Mock private Resource<Object> secondTransformed;
+  private Application context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    context = RuntimeEnvironment.application;
+
+    doAnswer(new Util.WriteDigest("first")).when(first)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("second")).when(second)
+        .updateDiskCacheKey(any(MessageDigest.class));
+  }
+
+  @Test
+  public void testAppliesTransformationsInOrder() {
+    final int width = 584;
+    final int height = 768;
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
+    when(first.transform(anyContext(), eq(initial), eq(width), eq(height)))
+        .thenReturn(firstTransformed);
+
+    when(second.transform(anyContext(), eq(firstTransformed), eq(width), eq(height)))
+        .thenReturn(secondTransformed);
+
+    assertEquals(secondTransformed, transformation.transform(context, initial, width, height));
+  }
+
+  @Test
+  public void testInitialResourceIsNotRecycled() {
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first);
+
+    transformation.transform(context, initial, 123, 456);
+
+    verify(initial, never()).recycle();
+  }
+
+  @Test
+  public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformations() {
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
+    transformation.transform(context, initial, 1111, 2222);
+
+    verify(initial, never()).recycle();
+  }
+
+  @Test
+  public void
+  testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(mockResource());
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
+    transformation.transform(context, initial, 1, 2);
+
+    verify(initial, never()).recycle();
+  }
+
+  @Test
+  public void testFinalResourceIsNotRecycled() {
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first);
+
+    transformation.transform(context, mockResource(), 111, 222);
+
+    verify(firstTransformed, never()).recycle();
+  }
+
+  @Test
+  public void testIntermediateResourcesAreRecycled() {
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(secondTransformed);
+
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
+
+    transformation.transform(context, mockResource(), 233, 454);
+
+    verify(firstTransformed).recycle();
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    keyTester
+        .addEquivalenceGroup(
+            new MultiTransformation<>(first),
+            new MultiTransformation<>(first))
+        .addEquivalenceGroup(new MultiTransformation<>(second))
+        .addEquivalenceGroup(new MultiTransformation<>(first, second))
+        .addEquivalenceGroup(new MultiTransformation<>(second, first))
+        .addRegressionTest(
+            new MultiTransformation<>(first),
+            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e")
+        .addRegressionTest(
+            new MultiTransformation<>(first, second),
+            "da83f63e1a473003712c18f5afc5a79044221943d1083c7c5a7ac7236d85e8d2")
+        .test();
+
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
new file mode 100644
index 000000000..67ee5b193
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/OptionsTest.java
@@ -0,0 +1,78 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.tests.KeyTester;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class OptionsTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEquals() {
+    Option<Object> firstMemoryOption = Option.memory("firstKey");
+    Object firstValue = new Object();
+    Option<Object> secondMemoryOption = Option.memory("secondKey");
+    Object secondValue = new Object();
+
+    CacheKeyUpdater<Integer> updater = new CacheKeyUpdater<Integer>() {
+      @Override
+      public void update(@NonNull byte[] keyBytes, @NonNull Integer value,
+          @NonNull MessageDigest messageDigest) {
+        messageDigest.update(keyBytes);
+        messageDigest.update(ByteBuffer.allocate(4).putInt(value).array());
+
+      }
+    };
+    Option<Integer> firstDiskOption = Option.disk("firstDisk", updater);
+    Option<Integer> secondDiskOption = Option.disk("secondDisk", updater);
+
+    keyTester
+        .addEquivalenceGroup(new Options(), new Options())
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, firstValue),
+            new Options().set(firstMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(secondMemoryOption, secondValue),
+            new Options().set(secondMemoryOption, secondValue))
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue),
+            new Options().set(secondMemoryOption, secondValue).set(firstMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(firstMemoryOption, secondValue))
+        .addEquivalenceGroup(
+            new Options().set(secondMemoryOption, firstValue))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 1),
+            new Options().set(firstDiskOption, 1))
+        .addEquivalenceGroup(
+            new Options().set(secondDiskOption, 1),
+            new Options().set(secondDiskOption, 1))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 2))
+        .addEquivalenceGroup(
+            new Options().set(secondDiskOption, 2))
+        .addEquivalenceGroup(
+            new Options().set(firstDiskOption, 1).set(secondDiskOption, 2),
+            new Options().set(secondDiskOption, 2).set(firstDiskOption, 1))
+        .addEmptyDigestRegressionTest(new Options().set(firstMemoryOption, firstValue))
+        .addEmptyDigestRegressionTest(
+            new Options().set(firstMemoryOption, firstValue).set(secondMemoryOption, secondValue))
+        .addRegressionTest(
+            new Options().set(firstDiskOption, 123),
+            "3c87124d1a765dc3d566f947d536ef140a4aca645c0947f702356714855b4a8e")
+        .addRegressionTest(
+            new Options().set(firstDiskOption, 123).set(secondDiskOption, 123),
+            "6697f654686c9a925905db3840e9c99944642c2b91d6200360d77639c1754d51")
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
new file mode 100644
index 000000000..21e6120a1
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamFuzzTest.java
@@ -0,0 +1,172 @@
+package com.bumptech.glide.load.data;
+
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Runs some tests based on a random seed that asserts the output of writing to our buffered stream
+ * matches the output of writing to {@link java.io.ByteArrayOutputStream}.
+ */
+@RunWith(JUnit4.class)
+public class BufferedOutputStreamFuzzTest {
+  private static final int TESTS = 500;
+  private static final int BUFFER_SIZE = 10;
+  private static final int WRITES_PER_TEST = 50;
+  private static final int MAX_BYTES_PER_WRITE = BUFFER_SIZE * 6;
+  private static final Random RANDOM = new Random(-3207167907493985134L);
+
+  @Mock private ArrayPool arrayPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(arrayPool.get(anyInt(), eq(byte[].class)))
+        .thenAnswer(new Answer<byte[]>() {
+          @Override
+          public byte[] answer(InvocationOnMock invocation) throws Throwable {
+            int size = (Integer) invocation.getArguments()[0];
+            return new byte[size];
+          }
+        });
+  }
+
+  @Test
+  public void runFuzzTest() throws IOException {
+    for (int i = 0; i < TESTS; i++) {
+      runTest(RANDOM);
+    }
+  }
+
+  private void runTest(Random random) throws IOException {
+    List<Write> writes = new ArrayList<>(WRITES_PER_TEST);
+    for (int i = 0; i < WRITES_PER_TEST; i++) {
+      WriteType writeType = getType(random);
+      writes.add(getWrite(random, writeType));
+    }
+
+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+
+    ByteArrayOutputStream wrapped = new ByteArrayOutputStream();
+    BufferedOutputStream bufferedOutputStream =
+        new BufferedOutputStream(wrapped, arrayPool, BUFFER_SIZE);
+
+    for (Write write : writes) {
+      switch (write.writeType) {
+        case BYTE:
+          byteArrayOutputStream.write(write.data[0]);
+          bufferedOutputStream.write(write.data[0]);
+          break;
+        case BUFFER:
+          byteArrayOutputStream.write(write.data);
+          bufferedOutputStream.write(write.data);
+          break;
+        case OFFSET_BUFFER:
+          byteArrayOutputStream.write(write.data, write.offset, write.length);
+          bufferedOutputStream.write(write.data, write.offset, write.length);
+          break;
+        default:
+            throw new IllegalArgumentException();
+      }
+    }
+
+    byte[] fromByteArrayStream = byteArrayOutputStream.toByteArray();
+    bufferedOutputStream.close();
+    byte[] fromWrappedStream = wrapped.toByteArray();
+    if (!Arrays.equals(fromWrappedStream, fromByteArrayStream)) {
+      StringBuilder writesBuilder = new StringBuilder();
+      for (Write write : writes) {
+        writesBuilder.append(write).append("\n");
+      }
+      fail("Expected: " + Arrays.toString(fromByteArrayStream) + "\n"
+          + "but got: " + Arrays.toString(fromWrappedStream) + "\n"
+          + writesBuilder.toString());
+    }
+  }
+
+  private Write getWrite(Random random, WriteType type) {
+    switch (type) {
+      case BYTE:
+        return getByteWrite(random);
+      case BUFFER:
+        return getBufferWrite(random);
+      case OFFSET_BUFFER:
+        return getOffsetBufferWrite(random);
+      default:
+        throw new IllegalArgumentException("Unrecognized type: " + type);
+    }
+  }
+
+  private Write getOffsetBufferWrite(Random random) {
+    int dataSize = random.nextInt(MAX_BYTES_PER_WRITE * 2);
+    byte[] data = new byte[dataSize];
+    int length = dataSize == 0 ? 0 : random.nextInt(dataSize);
+    int offset = dataSize - length <= 0 ? 0 : random.nextInt(dataSize - length);
+    random.nextBytes(data);
+    return new Write(data, length, offset, WriteType.OFFSET_BUFFER);
+  }
+
+  private Write getBufferWrite(Random random) {
+    byte[] data = new byte[random.nextInt(MAX_BYTES_PER_WRITE)];
+    random.nextBytes(data);
+    return new Write(data, /*length=*/ data.length, /*offset=*/ 0, WriteType.BUFFER);
+  }
+
+  private Write getByteWrite(Random random) {
+    byte[] data = new byte[1];
+    random.nextBytes(data);
+    return new Write(data, /*length=*/ 1, /*offset=*/ 0, WriteType.BYTE);
+  }
+
+  private WriteType getType(Random random) {
+    return WriteType.values()[random.nextInt(WriteType.values().length)];
+  }
+
+  private static final class Write {
+    private final byte[] data;
+    private final int length;
+    private final int offset;
+    private final WriteType writeType;
+
+    @Override
+    public String toString() {
+      return "Write{"
+          + "data=" + Arrays.toString(data)
+          + ", length=" + length
+          + ", offset=" + offset
+          + ", writeType=" + writeType
+          + '}';
+    }
+
+    Write(byte[] data, int length, int offset, WriteType writeType) {
+      this.data = data;
+      this.length = length;
+      this.offset = offset;
+      this.writeType = writeType;
+    }
+  }
+
+  private enum WriteType {
+    BYTE,
+    BUFFER,
+    OFFSET_BUFFER
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
new file mode 100644
index 000000000..ab32ce4a5
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/BufferedOutputStreamTest.java
@@ -0,0 +1,940 @@
+package com.bumptech.glide.load.data;
+
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class BufferedOutputStreamTest {
+  @Mock private ArrayPool arrayPool;
+  @Mock private OutputStream mockOutputStream;
+
+  private final int bufferSize = 10;
+  private final ByteArrayOutputStream inner = new ByteArrayOutputStream();
+  private int currentValue = 0;
+  private BufferedOutputStream os;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    when(arrayPool.get(bufferSize, byte[].class)).thenReturn(new byte[bufferSize]);
+    os = new BufferedOutputStream(inner, arrayPool, bufferSize);
+  }
+
+  @Test
+  public void constructor_obtainsBufferFromArrayPool() {
+    verify(arrayPool).get(bufferSize, byte[].class);
+  }
+
+  @Test
+  public void close_returnsBufferObtainedFromConstructor() throws IOException {
+    byte[] data = new byte[bufferSize];
+    when(arrayPool.get(bufferSize, byte[].class)).thenReturn(data);
+    os = new BufferedOutputStream(inner, arrayPool, bufferSize);
+
+    os.close();
+    verify(arrayPool).put(data);
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andSingleByte_doesNotWriteToStream() throws IOException {
+    os.write(next());
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataSmallerThanBuffer_doesNotWriteToStream()
+      throws IOException {
+    os.write(next(bufferSize - 1));
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetSizeSmallerThanBuffer_doesNotWriteToStream()
+    throws IOException {
+    int offset = 1;
+    int length = bufferSize - offset;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingSizeSmallerThanBuffer_doesNotWriteToStream()
+    throws IOException {
+    int padding = 1;
+    int length = bufferSize - padding;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataEqualToBufferSize_writesDataToStream()
+      throws IOException {
+    os.write(next(bufferSize));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataGreaterThanBufferSize_writesDataToStream()
+      throws IOException {
+    os.write(next(bufferSize + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetAndLengthEqualToBufferSize_writesDataToStream()
+      throws IOException {
+    int offset = 5;
+    int length = bufferSize;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingAndLengthEqualToBufferSize_writesData()
+      throws IOException {
+    int padding = 5;
+    int length = bufferSize;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithOffsetAndLengthGreaterThanBuffer_writesDataToStream()
+      throws IOException {
+    int offset = 5;
+    int length = bufferSize + 1;
+    byte[] data = nextWithOffset(offset, length);
+    os.write(data, offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withEmptyBuffer_andDataWithPaddingAndLengthGreaterThanBuffer_writesData()
+      throws IOException {
+    int padding = 5;
+    int length = bufferSize + 1;
+    byte[] data = nextWithPadding(length, padding);
+    os.write(data, 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void writeSingleByte_whenBufferAlmostFull_writesBufferToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_withSingleByteInBuffer_writesBufferToStream() throws IOException {
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritingByteAfterBufferFull_writesByteToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flushAfterPreviousFlush_withSingleByte_writesOnlySingleByte() throws IOException {
+    os.write(next());
+    os.flush();
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_withSingleByteInBuffer_writesBufferToStream() throws IOException {
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritingByteAfterBufferFull_writesByteToStream() throws IOException {
+    for (int i = 0; i < bufferSize; i++) {
+      os.write(next());
+    }
+
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void closeAfterPreviousFlush_withSingleByte_writesOnlySingleByte() throws IOException {
+    os.write(next());
+    os.flush();
+    os.write(next());
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withDataInBuffer_bufferLessThanRemaining_doesNotWriteToStream()
+      throws IOException {
+    os.write(next());
+    os.write(next(remaining() - 1));
+
+    assertThat(inner.toByteArray()).isEmpty();
+  }
+
+  @Test
+  public void flush_afterWriteWithDataInBuffer_bufferLessThanRemaining_writesToStream()
+      throws IOException {
+    os.write(next());
+    byte[] data = next(remaining() - 1);
+
+    os.write(data);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteWithDataInBuffer_bufferLessThanRemaining_writesToStream()
+      throws IOException {
+    os.write(next());
+    byte[] data = next(remaining());
+
+    os.write(data);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferEqualToRemaining_lessThanLength_writesToStream() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteBufferEqualToRemaining_doesNothing() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferEqualToRemaining_doesNothing() throws IOException {
+    os.write(next());
+    os.write(next(remaining()));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int offset = 5;
+    int length = remaining();
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferEqualToRemaining_lessThanLength_writesToStream()
+      throws IOException {
+    os.write(next());
+    int padding = 5;
+    int length = remaining();
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_lessThanLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize - 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_lessThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_lessThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_lessThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 5;
+    int length = bufferSize - 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = 6;
+    int length = bufferSize;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_equalToLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_equalToLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = 6;
+    int length = bufferSize;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferGreaterThanRemaining_greaterThanLength_writesUpToBufferToStream()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteBufferGreaterThanRemaining_greaterThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferGreaterThanRemaining_greaterThanLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize + 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferGreaterThanRemaining_greaterThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int offset = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferGreaterThanRemaining_greaterThanLength_writesUpToBuffer()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(upTo(bufferSize));
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferGreaterThanRemaining_greaterThanLength_writesAllToStream()
+      throws IOException {
+    os.write(next(2));
+    int padding = 2;
+    int length = bufferSize + 1;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    os.write(next(bufferSize * 2 + 1));
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWriteOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWriteOffsetBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int offset = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithOffset(offset, length), offset, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_withPaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_afterWritePaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void close_afterWritePaddedBufferMoreThanRemains_greaterThanTwiceLength_writesAll()
+      throws IOException {
+    os.write(next(2));
+    int padding = bufferSize + 1;
+    int length = bufferSize * 2 + 2;
+    os.write(nextWithPadding(length, padding), 0, length);
+    os.close();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void flush_flushesUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.flush();
+
+    verify(mockOutputStream).flush();
+  }
+
+  @Test
+  public void overflowBuffer_doesNotFlushUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.write(1);
+    os.write(next(remaining() + 1));
+
+    verify(mockOutputStream, never()).flush();
+  }
+
+  @Test
+  public void close_closesUnderlyingStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.close();
+
+    verify(mockOutputStream).close();
+  }
+
+  @Test
+  public void close_whenUnderlyingStreamThrows_closesStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    doThrow(new IOException()).when(mockOutputStream).write(any(byte[].class), anyInt(), anyInt());
+
+    os.write(1);
+    try {
+      os.close();
+      fail("Failed to receive expected exception");
+    } catch (IOException e) {
+      // Expected.
+    }
+
+    verify(mockOutputStream).close();
+  }
+
+  @Test
+  public void flush_withZeroBytesWritten_doesNotWriteToStream() throws IOException {
+    os = new BufferedOutputStream(mockOutputStream, arrayPool, bufferSize);
+    os.flush();
+
+    verify(mockOutputStream, never()).write(anyInt());
+    verify(mockOutputStream, never()).write(any(byte[].class));
+    verify(mockOutputStream, never()).write(any(byte[].class), anyInt(), anyInt());
+  }
+
+  @Test
+  public void write_throwsIfOffsetIsLessThanZero() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ -1, /*length=*/ 0);
+      }
+    });
+  }
+
+  @Test
+  public void write_throwsIfLengthIsLessThanZero() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ -1);
+      }
+    });
+  }
+
+  @Test
+  public void write_throwsIfOffsetIsGreaterThanLength() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ 1, /*length=*/ 0);
+      }
+    });
+  }
+
+  @Test
+  public void write_throwsIfLengthsIsGreaterThanLength() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[0], /*initialOffset=*/ 0, /*length=*/ 1);
+      }
+    });
+  }
+
+
+  @Test
+  public void write_throwsIfLengthAndOffsetsIsGreaterThanLength() {
+    assertThrows(IndexOutOfBoundsException.class, new ThrowingRunnable() {
+      @Override
+      public void run() throws Throwable {
+        os.write(new byte[1], /*initialOffset=*/ 1, /*length=*/ 1);
+      }
+    });
+  }
+
+  @Test
+  public void write_withZeroLengthBuffer_doesNothing() throws IOException {
+    os.write(new byte[0]);
+
+    assertThat(inner.toByteArray()).hasLength(0);
+  }
+
+  @Test
+  public void write_withZeroLengthBufferAndZeroOffsetAndLength_doesNothing() throws IOException {
+    os.write(new byte[0], 0, 0);
+
+    assertThat(inner.toByteArray()).hasLength(0);
+  }
+
+
+  @Test
+  public void write_afterWriteWithZeroLengthBuffer_writesExpected() throws IOException {
+    os.write(new byte[0]);
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  @Test
+  public void write_afterWriteZeroLengthBufferAndZeroOffsetAndLength_writesExpected()
+      throws IOException {
+    os.write(new byte[0], 0, 0);
+    os.write(next());
+    os.flush();
+
+    assertThat(inner.toByteArray()).isEqualTo(all());
+  }
+
+  private int soFar() {
+    return currentValue;
+  }
+
+  private int remaining() {
+    return bufferSize - soFar();
+  }
+
+  private int next() {
+    return nextWithOffset(0, 1)[0];
+  }
+
+  private byte[] next(int count) {
+    return nextWithOffset(0, count);
+  }
+
+  private byte[] nextWithPadding(int count, int padding) {
+    byte[] result = new byte[count + padding];
+    for (int i = 0; i < count; i++) {
+      result[i] = (byte) ++currentValue;
+    }
+    for (int i = count; i < count + padding; i++) {
+      result[i] = (byte) (i + currentValue);
+    }
+    return result;
+  }
+
+  private byte[] nextWithOffset(int offset, int count) {
+    byte[] result = new byte[offset + count];
+    for (int i = offset - 1; i >= 0; i--) {
+      result[i] = (byte) -offset;
+    }
+    for (int i = offset; i < offset + count; i++) {
+      result[i] = (byte) ++currentValue;
+    }
+    return result;
+  }
+
+  private byte[] upTo(int size) {
+    assertThat(size).isLessThan(currentValue);
+    byte[] result = new byte[size];
+    for (int i = 0; i < size; i++) {
+      result[i] = (byte) (i + 1);
+    }
+    return result;
+  }
+
+  private byte[] all() {
+    byte[] result = new byte[currentValue];
+    for (int i = 0; i < currentValue; i++) {
+      result[i] = (byte) (i + 1);
+    }
+    return result;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
similarity index 71%
rename from library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
index a682ff139..77c6a93f5 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -2,23 +2,22 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
-
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ExifOrientationStreamTest {
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
   private InputStream openOrientationExample(boolean isLandscape, int item) {
     String filePrefix = isLandscape ? "Landscape" : "Portrait";
@@ -28,7 +27,7 @@ private InputStream openOrientationExample(boolean isLandscape, int item) {
 
   @Before
   public void setUp() {
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
   }
 
   @Test
@@ -37,13 +36,12 @@ public void testIncludesGivenExifOrientation() throws IOException {
       for (int j = 0; j < 8; j++) {
         InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
         InputStream wrapped = new ExifOrientationStream(toWrap, i);
-        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
 
         toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
         wrapped = new ExifOrientationStream(toWrap, i);
-        parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
       }
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
index 4e2b4636f..ef1bad28b 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
@@ -9,9 +9,8 @@
 import android.content.res.AssetFileDescriptor;
 import android.content.res.AssetManager;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.Priority;
-
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,24 +19,21 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class FileDescriptorAssetPathFetcherTest {
 
-  @Mock AssetManager assetManager;
-  @Mock AssetFileDescriptor assetFileDescriptor;
-  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+  @Mock private AssetManager assetManager;
+  @Mock private AssetFileDescriptor assetFileDescriptor;
+  @Mock private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
 
   private FileDescriptorAssetPathFetcher fetcher;
   private ParcelFileDescriptor expected;
-  private String assetPath;
 
   @Before
   public void setUp() throws IOException {
     MockitoAnnotations.initMocks(this);
-    assetPath = "/some/asset/path";
+    String assetPath = "/some/asset/path";
     fetcher = new FileDescriptorAssetPathFetcher(assetManager, assetPath);
     expected = mock(ParcelFileDescriptor.class);
     when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(expected);
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 678b9460a..044bf30e8 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -10,10 +10,16 @@
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.testutil.TestUtil;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -24,14 +30,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-
 /**
  * Tests {@link com.bumptech.glide.load.data.HttpUrlFetcher} against server responses. Tests for
  * behavior (connection/disconnection/options) should go in
@@ -43,7 +41,7 @@
   private static final String DEFAULT_PATH = "/fakepath";
   private static final int TIMEOUT_TIME_MS = 300;
 
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private MockWebServer mockWebServer;
   private boolean defaultFollowRedirects;
@@ -55,7 +53,7 @@ public void setUp() throws IOException {
     defaultFollowRedirects = HttpURLConnection.getFollowRedirects();
     HttpURLConnection.setFollowRedirects(false);
     mockWebServer = new MockWebServer();
-    mockWebServer.play();
+    mockWebServer.start();
 
     streamCaptor = ArgumentCaptor.forClass(InputStream.class);
   }
@@ -74,28 +72,33 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
     fetcher.loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
+    assertThat(mockWebServer.takeRequest().getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -108,9 +111,11 @@ public void testHandlesRelativeRedirects() throws Exception {
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    mockWebServer.takeRequest();
+    RecordedRequest first = mockWebServer.takeRequest();
+    assertThat(first.getMethod()).isEqualTo("GET");
     RecordedRequest second = mockWebServer.takeRequest();
     assertThat(second.getPath()).endsWith("/redirect");
+    assertThat(second.getMethod()).isEqualTo("GET");
   }
 
   @Test
@@ -120,7 +125,7 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -128,18 +133,22 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     verify(callback).onDataReady(streamCaptor.capture());
     TestUtil.assertStreamOf(expected, streamCaptor.getValue());
 
-    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
+    RecordedRequest request = mockWebServer.takeRequest();
+    assertThat(request.getPath()).contains(DEFAULT_PATH);
+    assertThat(request.getMethod()).isEqualTo("GET");
     for (int i = 0; i < numRedirects; i++) {
-      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
+      RecordedRequest current = mockWebServer.takeRequest();
+      assertThat(current.getPath()).contains(redirectBase + i);
+      assertThat(current.getMethod()).isEqualTo("GET");
     }
   }
 
   @Test
   public void testFailsOnRedirectLoops() throws Exception {
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
 
     getFetcher().loadData(Priority.IMMEDIATE, callback);
 
@@ -176,7 +185,7 @@ public void testFailsIfStatusCodeIsNegativeOne() throws Exception {
   public void testFailsAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 10; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
 
@@ -204,7 +213,7 @@ public void testSetsReadTimeout() throws Exception {
     MockWebServer tempWebServer = new MockWebServer();
     tempWebServer.enqueue(
         new MockResponse().setBody("test").throttleBody(1, TIMEOUT_TIME_MS, TimeUnit.MILLISECONDS));
-    tempWebServer.play();
+    tempWebServer.start();
 
     try {
       getFetcher().loadData(Priority.HIGH, callback);
@@ -233,11 +242,11 @@ public void testAppliesHeadersInGlideUrl() throws Exception {
   }
 
   private HttpUrlFetcher getFetcher() {
-    return getFetcher(Headers.NONE);
+    return getFetcher(Headers.DEFAULT);
   }
 
   private HttpUrlFetcher getFetcher(Headers headers) {
-    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    URL url = mockWebServer.url(DEFAULT_PATH).url();
     return new HttpUrlFetcher(new GlideUrl(url, headers), TIMEOUT_TIME_MS,
         HttpUrlFetcher.DEFAULT_CONNECTION_FACTORY);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
index 7f70a4a82..9cd87e418 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -9,7 +9,11 @@
 
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.model.GlideUrl;
-
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,20 +23,14 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class HttpUrlFetcherTest {
-  @Mock HttpURLConnection urlConnection;
-  @Mock HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
-  @Mock GlideUrl glideUrl;
-  @Mock InputStream stream;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private HttpURLConnection urlConnection;
+  @Mock private HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
+  @Mock private GlideUrl glideUrl;
+  @Mock private InputStream stream;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private static final int TIMEOUT_MS = 100;
   private HttpUrlFetcher fetcher;
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index af261f814..9ca7a2924 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -8,9 +8,11 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Priority;
-
+import java.io.Closeable;
+import java.io.FileNotFoundException;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,15 +22,11 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.Closeable;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LocalUriFetcherTest {
   private TestLocalUriFetcher fetcher;
-  @Mock DataFetcher.DataCallback<Closeable> callback;
+  @Mock private DataFetcher.DataCallback<Closeable> callback;
 
   @Before
   public void setUp() {
@@ -63,8 +61,8 @@ public void testHandlesExceptionOnClose() throws Exception {
   private static class TestLocalUriFetcher extends LocalUriFetcher<Closeable> {
     final Closeable closeable = mock(Closeable.class);
 
-    public TestLocalUriFetcher(Context context, Uri uri) {
-      super(context, uri);
+    TestLocalUriFetcher(Context context, Uri uri) {
+      super(context.getContentResolver(), uri);
     }
 
     @Override
@@ -78,6 +76,7 @@ protected void close(Closeable data) throws IOException {
       data.close();
     }
 
+    @NonNull
     @Override
     public Class<Closeable> getDataClass() {
       return Closeable.class;
diff --git a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
similarity index 89%
rename from library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
index 2f57e9cc1..fb7e125ac 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
@@ -6,9 +6,9 @@
 import static org.mockito.Mockito.when;
 
 import android.content.res.AssetManager;
-
 import com.bumptech.glide.Priority;
-
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -17,23 +17,19 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamAssetPathFetcherTest {
-  @Mock AssetManager assetManager;
-  @Mock InputStream expected;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
+  @Mock private AssetManager assetManager;
+  @Mock private InputStream expected;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
 
   private StreamAssetPathFetcher fetcher;
-  private String assetPath;
 
   @Before
   public void setUp() throws IOException {
     MockitoAnnotations.initMocks(this);
-    assetPath = "/some/asset/path";
+    String assetPath = "/some/asset/path";
     fetcher = new StreamAssetPathFetcher(assetManager, assetPath);
     when(assetManager.open(eq(assetPath))).thenReturn(expected);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
similarity index 77%
rename from library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
index 0b0673dc3..0b59d74b1 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
@@ -7,28 +7,24 @@
 
 import android.net.Uri;
 import android.provider.MediaStore;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ThumbFetcherTest {
 
-  @Mock ThumbnailStreamOpener opener;
-  @Mock DataFetcher.DataCallback<InputStream> callback;
-  @Mock InputStream expected;
+  @Mock private ThumbnailStreamOpener opener;
+  @Mock private DataFetcher.DataCallback<InputStream> callback;
+  @Mock private InputStream expected;
 
   private ThumbFetcher fetcher;
   private Uri uri;
@@ -38,12 +34,12 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
-    fetcher = new ThumbFetcher(RuntimeEnvironment.application, uri, opener);
+    fetcher = new ThumbFetcher(uri, opener);
   }
 
   @Test
   public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.LOW, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
@@ -51,7 +47,7 @@ public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
 
   @Test
   public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.HIGH, callback);
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
similarity index 61%
rename from library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index a6f9070da..7c25a0580 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -8,13 +8,20 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.content.ContentResolver;
 import android.database.MatrixCursor;
 import android.net.Uri;
 import android.provider.MediaStore;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,11 +31,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.fakes.RoboCursor;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ThumbnailStreamOpenerTest {
@@ -41,43 +43,41 @@ public void setUp() {
 
   @Test
   public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri))).thenReturn(null);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(null);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(new MatrixCursor(new String[1]));
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(new MatrixCursor(new String[1]));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
     MatrixCursor cursor = new MatrixCursor(new String[1]);
     cursor.addRow(new Object[] { "" });
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(cursor);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(cursor);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfFileDoesNotExist() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.exists(eq(harness.file))).thenReturn(false);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnNullIfFileLengthIsZero() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.length(eq(harness.file))).thenReturn(0L);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testClosesCursor() throws FileNotFoundException {
-    harness.get().open(RuntimeEnvironment.application, harness.uri);
+    harness.get().open(harness.uri);
     assertTrue(harness.cursor.isClosed());
   }
 
@@ -86,47 +86,56 @@ public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundExcep
     InputStream expected = new ByteArrayInputStream(new byte[0]);
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .registerInputStream(harness.uri, expected);
-    assertEquals(expected, harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertEquals(expected, harness.get().open(harness.uri));
   }
 
   @Test
   public void testVideoQueryReturnsVideoCursor() {
     Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.VideoThumbnailQuery query = new ThumbFetcher.VideoThumbnailQuery();
+    ThumbFetcher.VideoThumbnailQuery query =
+        new ThumbFetcher.VideoThumbnailQuery(getContentResolver());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
   }
 
   @Test
-  public void testImageQueryReturnsImageCurosr() {
+  public void testImageQueryReturnsImageCursor() {
     Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.ImageThumbnailQuery query = new ThumbFetcher.ImageThumbnailQuery();
+    ThumbFetcher.ImageThumbnailQuery query =
+        new ThumbFetcher.ImageThumbnailQuery(getContentResolver());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
+  }
+
+  private static ContentResolver getContentResolver() {
+    return RuntimeEnvironment.application.getContentResolver();
   }
 
   private static class Harness {
-    MatrixCursor cursor = new MatrixCursor(new String[1]);
-    File file = new File("fake/uri");
-    Uri uri = Uri.fromFile(file);
-    ThumbnailQuery query = mock(ThumbnailQuery.class);
-    FileService service = mock(FileService.class);
-    ByteArrayPool byteArrayPool = new LruByteArrayPool();
+    final MatrixCursor cursor = new MatrixCursor(new String[1]);
+    final File file = new File("fake/uri");
+    final Uri uri = Uri.fromFile(file);
+    final ThumbnailQuery query = mock(ThumbnailQuery.class);
+    final FileService service = mock(FileService.class);
+    final ArrayPool byteArrayPool = new LruArrayPool();
 
     public Harness() {
       cursor.addRow(new String[] { file.getAbsolutePath() });
-      when(query.query(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(cursor);
+      when(query.query(eq(uri))).thenReturn(cursor);
       when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
       when(service.exists(eq(file))).thenReturn(true);
       when(service.length(eq(file))).thenReturn(1L);
     }
 
     public ThumbnailStreamOpener get() {
-      return new ThumbnailStreamOpener(service, query, byteArrayPool);
+      List<ImageHeaderParser> parsers = new ArrayList<>();
+      parsers.add(new DefaultImageHeaderParser());
+      return new ThumbnailStreamOpener(
+          parsers, service, query, byteArrayPool, getContentResolver());
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
similarity index 58%
rename from library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index b9790640b..b4f8e7721 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.data.resource;
 
 import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -10,12 +11,11 @@
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.tests.ContentResolverShadow;
-
+import java.io.FileNotFoundException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,13 +24,14 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class FileDescriptorLocalUriFetcherTest {
 
-  @Mock DataFetcher.DataCallback<ParcelFileDescriptor> callback;
+  @Mock
+  private DataFetcher.DataCallback<ParcelFileDescriptor> callback;
 
   @Before
   public void setUp() {
@@ -38,21 +39,36 @@ public void setUp() {
   }
 
   @Test
-  public void testLoadsFileDescriptor() throws Exception {
-    final Context context = RuntimeEnvironment.application;
-    final Uri uri = Uri.parse("file://nothing");
+  public void testLoadResource_returnsFileDescriptor() throws Exception {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
     ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
     when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(parcelFileDescriptor);
     shadow.registerFileDescriptor(uri, assetFileDescriptor);
 
-    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(eq(parcelFileDescriptor));
   }
 
+  @Test
+  public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
+    shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
+
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
+    fetcher.loadData(Priority.NORMAL, callback);
+    verify(callback).onLoadFailed(isA(FileNotFoundException.class));
+  }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
new file mode 100644
index 000000000..a1d83a5f6
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -0,0 +1,67 @@
+package com.bumptech.glide.load.data.resource;
+
+import static org.mockito.Matchers.isA;
+import static org.mockito.Matchers.isNotNull;
+import static org.mockito.Mockito.verify;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.net.Uri;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.data.StreamLocalUriFetcher;
+import com.bumptech.glide.tests.ContentResolverShadow;
+import java.io.ByteArrayInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadow.api.Shadow;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
+public class StreamLocalUriFetcherTest {
+  @Mock
+  private DataFetcher.DataCallback<InputStream> callback;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testLoadResource_returnsInputStream() throws Exception {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
+    shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
+
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
+    fetcher.loadData(Priority.NORMAL, callback);
+    verify(callback).onDataReady(isNotNull(InputStream.class));
+  }
+
+  @Test
+  public void testLoadResource_withNullInputStream_callsLoadFailed() {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = Shadow.extract(contentResolver);
+
+    shadow.registerInputStream(uri, null /*inputStream*/);
+
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
+    fetcher.loadData(Priority.LOW, callback);
+
+    verify(callback).onLoadFailed(isA(FileNotFoundException.class));
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
new file mode 100644
index 000000000..288ac29d5
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
@@ -0,0 +1,395 @@
+package com.bumptech.glide.load.engine;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.ActiveResources.DequeuedResourceCallback;
+import com.bumptech.glide.load.engine.ActiveResources.ResourceWeakReference;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = GlideShadowLooper.class)
+public class ActiveResourcesTest {
+
+  @Mock private ResourceListener listener;
+  @Mock private Key key;
+  @Mock private Resource<Object> resource;
+
+  private ActiveResources resources;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);
+    resources.setListener(listener);
+
+    reset(GlideShadowLooper.queue);
+  }
+
+  @After
+  public void tearDown() {
+    resources.shutdown();
+  }
+
+  @Test
+  public void get_withMissingKey_returnsNull() {
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveKey_returnsResource() {
+    EngineResource<Object> expected =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, expected);
+    assertThat(resources.get(key)).isEqualTo(expected);
+  }
+
+  @Test
+  public void get_withDeactivatedKey_returnsNull() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.deactivate(key);
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void deactivate_withNotActiveKey_doesNotThrow() {
+    resources.deactivate(key);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_returnsNull() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithWrappedResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithNotRecycleable() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    captor.getValue().recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithCacheable() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    assertThat(captor.getValue().isCacheable()).isTrue();
+  }
+
+  @Test
+  public void get_withActiveAndClearedKey_andNotCacheableResource_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_afterResourceRemovedFromActive_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    resources.deactivate(key);
+
+    enqueueAndWaitForRef(weakRef);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_callListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+
+    EngineResource<?> released = captor.getValue();
+    assertThat(released.getResource()).isEqualTo(resource);
+    assertThat(released.isCacheable()).isTrue();
+
+    released.recycle();
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_doesNotCallListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+    enqueueAndWaitForRef(weakRef);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withCacheableResourceInActive_removesResourceFromActive()
+      throws InterruptedException {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void queueIdle_withNotCacheableResourceInActive_removesResourceFromActive() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    enqueueAndWaitForRef(weakRef);
+
+    assertThat(resources.get(key)).isNull();
+  }
+
+  @Test
+  public void get_withQueuedReference_returnsResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    assertThat(resources.get(key)).isEqualTo(engineResource);
+  }
+
+  @Test
+  public void get_withQueuedReference_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGet_notifiesListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+
+    resources.get(key);
+
+    enqueueAndWaitForRef(weakRef);
+
+    ArgumentCaptor<EngineResource<?>> captor = getEngineResourceCaptor();
+    verify(listener).onResourceReleased(eq(key), captor.capture());
+    assertThat(captor.getValue().getResource()).isEqualTo(resource);
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGetAndNotCacheable_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceDeactivated_doesNotNotifyListener() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.deactivate(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void queueIdle_afterReferenceQueuedThenReactivated_doesNotNotifyListener() {
+    EngineResource<Object> first =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, first);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    EngineResource<Object> second =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, second);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void activate_withNonCacheableResource_doesNotSaveResource() {
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    assertThat(resources.activeEngineResources.get(key).resource).isNull();
+  }
+
+  @Test
+  public void get_withActiveClearedKey_cacheableResource_retentionDisabled_doesNotCallListener() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+    resources.activeEngineResources.get(key).clear();
+    resources.get(key);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  @Test
+  public void get_withQueuedReference_retentionDisabled_returnsResource() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    weakRef.enqueue();
+
+    assertThat(resources.get(key)).isEqualTo(engineResource);
+  }
+
+  @Test
+  public void queueIdle_withQueuedReferenceRetrievedFromGet_retentionDisabled_doesNotNotify() {
+    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
+    EngineResource<Object> engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    resources.activate(key, engineResource);
+
+    ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
+    CountDownLatch latch = getLatchForClearedRef();
+    weakRef.enqueue();
+
+    resources.get(key);
+
+    waitForLatch(latch);
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+  }
+
+  private void enqueueAndWaitForRef(ResourceWeakReference ref) {
+    CountDownLatch latch = getLatchForClearedRef();
+    ref.enqueue();
+    waitForLatch(latch);
+  }
+
+  private void waitForLatch(CountDownLatch latch) {
+     try {
+      latch.await(10, TimeUnit.SECONDS);
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+    ShadowLooper.getShadowMainLooper().runToEndOfTasks();
+  }
+
+  private CountDownLatch getLatchForClearedRef() {
+    final CountDownLatch toWait = new CountDownLatch(1);
+    resources.setDequeuedResourceCallback(new DequeuedResourceCallback() {
+      @Override
+      public void onResourceDequeued() {
+        toWait.countDown();
+      }
+    });
+    return toWait;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static ArgumentCaptor<EngineResource<?>> getEngineResourceCaptor() {
+    return (ArgumentCaptor<EngineResource<?>>) (ArgumentCaptor<?>)
+        ArgumentCaptor.forClass(EngineResource.class);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
similarity index 52%
rename from library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
index 33ea85ac1..2bbc3ad67 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
@@ -4,27 +4,27 @@
 import static org.mockito.Mockito.doAnswer;
 
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util.WriteDigest;
-
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(JUnit4.class)
 public class DataCacheKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Key firstKey;
-  @Mock Key firstSignature;
-  @Mock Key secondKey;
-  @Mock Key secondSignature;
+  @Mock private Key firstKey;
+  @Mock private Key firstSignature;
+  @Mock private Key secondKey;
+  @Mock private Key secondSignature;
 
   @Before
   public void setUp() throws UnsupportedEncodingException {
@@ -40,29 +40,17 @@ public void setUp() throws UnsupportedEncodingException {
   }
 
   @Test
-  public void testDiffersIfIdDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(secondKey, firstSignature);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testDiffersIfSignatureDiffers()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(firstKey, secondSignature);
-
-    KeyAssertions.assertDifferent(first, second);
-  }
-
-  @Test
-  public void testSameIfIdAndSignatureAreTheSame()
-      throws UnsupportedEncodingException, NoSuchAlgorithmException {
-    DataCacheKey first = new DataCacheKey(firstKey, firstSignature);
-    DataCacheKey second = new DataCacheKey(firstKey, firstSignature);
-
-    KeyAssertions.assertSame(first, second);
+  public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
+    keyTester
+        .addEquivalenceGroup(
+            new DataCacheKey(firstKey, firstSignature),
+            new DataCacheKey(firstKey, firstSignature))
+        .addEquivalenceGroup(new DataCacheKey(firstKey, secondSignature))
+        .addEquivalenceGroup(new DataCacheKey(secondKey, firstSignature))
+        .addEquivalenceGroup(new DataCacheKey(secondKey, secondSignature))
+        .addRegressionTest(
+            new DataCacheKey(firstKey, firstSignature),
+            "801d7440d65a0e7c9ad0097d417f346dac4d4c4d5630724110fa3f3fe66236d9")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
similarity index 72%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 1987cc797..a3156e2d7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -2,6 +2,7 @@
 
 import static com.bumptech.glide.tests.Util.anyResource;
 import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
@@ -17,12 +18,13 @@
 
 import android.os.Handler;
 import android.support.v4.util.Pools;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
-
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -34,9 +36,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLooper;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class EngineJobTest {
@@ -65,7 +64,8 @@ public void testListenerNotifiedJobCompleteOnOnResourceReady() {
 
     ShadowLooper.runUiThreadTasks();
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), eq(harness.engineResource));
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), eq(harness.engineResource));
   }
 
   @Test
@@ -108,7 +108,8 @@ public void testListenerNotifiedJobCompleteOnException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
     ShadowLooper.runUiThreadTasks();
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
   }
 
   @Test
@@ -179,7 +180,7 @@ public void testRemovingAllCallbacksCancelsRunner() {
   @SuppressWarnings("unchecked")
   @Test
   public void removingSomeCallbacksDoesNotCancelRunner() {
-    EngineJob job = harness.getJob();
+    EngineJob<Object> job = harness.getJob();
     job.addCallback(mock(ResourceCallback.class));
     job.removeCallback(harness.cb);
 
@@ -221,7 +222,8 @@ public void testDoesNotNotifyCancelledIfReceivedException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
+    verify(harness.listener)
+        .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
     verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
   }
 
@@ -255,9 +257,9 @@ public void testNotifiesNewCallbackOfResourceIfCallbackIsAddedDuringOnResourceRe
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.addCallback(newCallback);
         return null;
       }
@@ -273,13 +275,13 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test
   public void testNotifiesNewCallbackOfExceptionIfCallbackIsAddedDuringOnException() {
     harness = new EngineJobHarness();
-    final EngineJob job = harness.getJob();
+    final EngineJob<Object> job = harness.getJob();
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.addCallback(newCallback);
         return null;
       }
@@ -298,9 +300,9 @@ public void testRemovingCallbackDuringOnResourceReadyIsIgnoredIfCallbackHasAlrea
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(cb);
         return null;
       }
@@ -319,9 +321,9 @@ public void testRemovingCallbackDuringOnExceptionIsIgnoredIfCallbackHasAlreadyBe
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(cb);
         return null;
       }
@@ -341,9 +343,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(notYetCalled);
         return null;
       }
@@ -362,9 +364,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(notYetCalled);
         return null;
       }
@@ -386,9 +388,9 @@ public void testRemovingCallbackDuringOnExceptionPreventsCallbackFromBeingCalled
     final ResourceCallback called = mock(ResourceCallback.class);
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(notYetCalled);
         return null;
       }
@@ -414,50 +416,83 @@ public void testCancelsDecodeJobOnCancel() {
   @Test
   public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {
     EngineJob<Object> job = harness.getJob();
+    harness.diskCacheService.shutdownNow();
     job.reschedule(harness.decodeJob);
 
-    verify(harness.sourceService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
   }
 
   @Test
   public void testSubmitsDecodeJobToDiskCacheServiceWhenDecodingFromCacheOnStart() {
     EngineJob<Object> job = harness.getJob();
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(true);
+    harness.sourceService.shutdownNow();
+    job.start(harness.decodeJob);
+
+    verify(harness.decodeJob).run();
+  }
+
+  @Test
+  public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSourceOnlyOnStart() {
+    EngineJob<Object> job = harness.getJob();
+    when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    harness.diskCacheService.shutdownNow();
     job.start(harness.decodeJob);
 
-    verify(harness.diskCacheService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
   }
 
   @Test
-  public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSoureOnlyOnStart() {
+  public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOnlyOnStart() {
+    harness.useUnlimitedSourceGeneratorPool = true;
     EngineJob<Object> job = harness.getJob();
+
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    harness.diskCacheService.shutdownNow();
     job.start(harness.decodeJob);
 
-    verify(harness.sourceService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
   }
 
   @SuppressWarnings("unchecked")
   private static class MultiCbHarness {
-    Key key = mock(Key.class);
-    Resource<Object> resource = mock(Resource.class);
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    EngineJobListener listener = mock(EngineJobListener.class);
-    boolean isCacheable = true;
-    int numCbs = 10;
-    List<ResourceCallback> cbs = new ArrayList<>();
-    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-    EngineJob<Object> job;
-    GlideExecutor diskCacheService = mock(GlideExecutor.class);
-    GlideExecutor sourceService = mock(GlideExecutor.class);
-    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
-    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
-    DataSource dataSource = DataSource.LOCAL;
+    final Key key = mock(Key.class);
+    final Resource<Object> resource = mockResource();
+    final EngineResource<Object> engineResource = mock(EngineResource.class);
+    final EngineJobListener listener = mock(EngineJobListener.class);
+    final boolean isCacheable = true;
+    final boolean useUnlimitedSourceGeneratorPool = false;
+    final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
+    final int numCbs = 10;
+    final List<ResourceCallback> cbs = new ArrayList<>();
+    final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    final EngineJob<Object> job;
+    final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
+    final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    final DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      job = new EngineJob<>(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      job =
+          new EngineJob<>(
+              diskCacheService,
+              sourceService,
+              sourceUnlimitedService,
+              animationService,
+              listener,
+              pool,
+              factory);
+      job.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
@@ -469,24 +504,42 @@ public MultiCbHarness() {
 
   @SuppressWarnings("unchecked")
   private static class EngineJobHarness {
-    EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
-    Key key = mock(Key.class);
-    Handler mainHandler = new Handler();
-    ResourceCallback cb = mock(ResourceCallback.class);
-    Resource<Object> resource = mock(Resource.class);
-    EngineResource<Object> engineResource = mock(EngineResource.class);
-    EngineJobListener listener = mock(EngineJobListener.class);
-    GlideExecutor diskCacheService = mock(GlideExecutor.class);
-    GlideExecutor sourceService = mock(GlideExecutor.class);
+    final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
+    final Key key = mock(Key.class);
+    final Handler mainHandler = new Handler();
+    final ResourceCallback cb = mock(ResourceCallback.class);
+    final Resource<Object> resource = mockResource();
+    final EngineResource<Object> engineResource = mock(EngineResource.class);
+    final EngineJobListener listener = mock(EngineJobListener.class);
+    final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
+    final GlideExecutor animationService = MockGlideExecutor.newMainThreadExecutor();
     boolean isCacheable = true;
-    DecodeJob<Object> decodeJob = mock(DecodeJob.class);
-    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
-    DataSource dataSource = DataSource.DATA_DISK_CACHE;
-
-    public EngineJob<Object> getJob() {
+    boolean useUnlimitedSourceGeneratorPool = false;
+    final boolean useAnimationPool = false;
+    final boolean onlyRetrieveFromCache = false;
+    final DecodeJob<Object> decodeJob = mock(DecodeJob.class);
+    final Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
+    final DataSource dataSource = DataSource.DATA_DISK_CACHE;
+
+    EngineJob<Object> getJob() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      EngineJob result = new EngineJob(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      EngineJob<Object> result =
+          new EngineJob<>(
+              diskCacheService,
+              sourceService,
+              sourceUnlimitedService,
+              animationService,
+              listener,
+              pool,
+              factory);
+      result.init(
+          key,
+          isCacheable,
+          useUnlimitedSourceGeneratorPool,
+          useAnimationPool,
+          onlyRetrieveFromCache);
       result.addCallback(cb);
       return result;
     }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
new file mode 100644
index 000000000..f18a30289
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
@@ -0,0 +1,179 @@
+package com.bumptech.glide.load.engine;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.signature.ObjectKey;
+import com.google.common.testing.EqualsTester;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class EngineKeyTest {
+  @Rule public final ExpectedException expectedException = ExpectedException.none();
+  @Mock private Transformation<Object> transformation;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void updateDiskCacheKey_throwsException() throws NoSuchAlgorithmException {
+    // If this test fails, update testEqualsAndHashcode to use KeyTester including regression tests.
+    EngineKey key = new EngineKey(
+        "id",
+        new ObjectKey("signature"),
+        100,
+        100,
+        Collections.<Class<?>, Transformation<?>>emptyMap(),
+        Object.class,
+        Object.class,
+        new Options());
+    expectedException.expect(UnsupportedOperationException.class);
+    key.updateDiskCacheKey(MessageDigest.getInstance("SHA-1"));
+  }
+
+  @Test
+  public void testEqualsAndHashCode() {
+    Options memoryOptions = new Options();
+    memoryOptions.set(Option.memory("key", new Object()), new Object());
+
+    Options diskOptions = new Options();
+    diskOptions.set(Option.disk("key", new CacheKeyUpdater<String>() {
+      @Override
+      public void update(@NonNull byte[] keyBytes, @NonNull String value,
+          @NonNull MessageDigest messageDigest) {
+        messageDigest.update(keyBytes);
+        messageDigest.update(value.getBytes(Key.CHARSET));
+
+      }
+    }), "value");
+
+    new EqualsTester()
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()),
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "otherId",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("otherSignature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                200,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                200,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),
+                Object.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Integer.class,
+                Object.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Integer.class,
+                new Options()))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                memoryOptions))
+        .addEqualityGroup(
+            new EngineKey(
+                "id",
+                new ObjectKey("signature"),
+                100,
+                100,
+                Collections.<Class<?>, Transformation<?>>emptyMap(),
+                Object.class,
+                Object.class,
+                diskOptions))
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
similarity index 75%
rename from library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index 1f328c03d..3468931eb 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -1,19 +1,22 @@
 package com.bumptech.glide.load.engine;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.load.Key;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
@@ -21,16 +24,15 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class EngineResourceTest {
   private EngineResource<Object> engineResource;
-  private EngineResource.ResourceListener listener;
-  private Key cacheKey = mock(Key.class);
-  private Resource<Object> resource;
+  @Mock private EngineResource.ResourceListener listener;
+  @Mock private Key cacheKey;
+  @Mock private Resource<Object> resource;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
-    resource = mock(Resource.class);
-    engineResource = new EngineResource<>(resource, true /*isMemoryCacheable*/);
-    listener = mock(EngineResource.ResourceListener.class);
+    MockitoAnnotations.initMocks(this);
+    engineResource =
+        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
     engineResource.setResourceListener(cacheKey, listener);
   }
 
@@ -141,14 +143,27 @@ public void testThrowsIfReleasedMoreThanAcquired() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfWrappedResourceIsNull() {
-    new EngineResource<>(null, false);
+    new EngineResource<>(/*toWrap=*/ null, /*isCacheable=*/ false, /*isRecyclable=*/ true);
   }
 
   @Test
   public void testCanSetAndGetIsCacheable() {
-    engineResource = new EngineResource<>(mock(Resource.class), true);
+    engineResource =
+        new EngineResource<>(mockResource(), /*isCacheable=*/ true, /*isRecyclable=*/ true);
     assertTrue(engineResource.isCacheable());
-    engineResource = new EngineResource<>(mock(Resource.class), false);
+    engineResource =
+        new EngineResource<>(mockResource(), /*isCacheable=*/ false, /*isRecyclable=*/ true);
     assertFalse(engineResource.isCacheable());
   }
+
+  @Test
+  public void release_whenNotRecycleable_doesNotRecycleResource() {
+    resource = mockResource();
+    engineResource = new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
+    engineResource.setResourceListener(cacheKey, listener);
+    engineResource.recycle();
+
+    verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
+    verify(resource, never()).recycle();
+  }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
new file mode 100644
index 000000000..4decb9a07
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -0,0 +1,715 @@
+package com.bumptech.glide.load.engine;
+
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.bumptech.glide.GlideContext;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.GlideShadowLooper;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { GlideShadowLooper.class })
+@SuppressWarnings("unchecked")
+public class EngineTest {
+  private EngineTestHarness harness;
+
+  @Before
+  public void setUp() {
+    harness = new EngineTestHarness();
+  }
+
+  @Test
+  public void testNewRunnerIsCreatedAndPostedWithNoExistingLoad() {
+    harness.doLoad();
+
+    verify(harness.job).start((DecodeJob) any());
+  }
+
+  @Test
+  public void testCallbackIsAddedToNewEngineJobWithNoExistingLoad() {
+    harness.doLoad();
+
+    verify(harness.job).addCallback(eq(harness.cb));
+  }
+
+  @Test
+  public void testLoadStatusIsReturnedForNewLoad() {
+    assertNotNull(harness.doLoad());
+  }
+
+  @Test
+  public void testEngineJobReceivesRemoveCallbackFromLoadStatus() {
+    Engine.LoadStatus loadStatus = harness.doLoad();
+    loadStatus.cancel();
+
+    verify(harness.job).removeCallback(eq(harness.cb));
+  }
+
+  @Test
+  public void testNewRunnerIsAddedToRunnersMap() {
+    harness.doLoad();
+
+    assertThat(harness.jobs.getAll()).containsKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
+    harness.doLoad();
+    harness.doLoad();
+
+    verify(harness.job, times(1)).start((DecodeJob) any());
+  }
+
+  @Test
+  public void testCallbackIsAddedToExistingRunnerWithExistingLoad() {
+    harness.doLoad();
+
+    ResourceCallback newCallback = mock(ResourceCallback.class);
+    harness.cb = newCallback;
+    harness.doLoad();
+
+    verify(harness.job).addCallback(eq(newCallback));
+  }
+
+  @Test
+  public void testLoadStatusIsReturnedForExistingJob() {
+    harness.doLoad();
+    Engine.LoadStatus loadStatus = harness.doLoad();
+
+    assertNotNull(loadStatus);
+  }
+
+  @Test
+  public void testResourceIsReturnedFromActiveResourcesIfPresent() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void testResourceIsAcquiredIfReturnedFromActiveResources() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.resource).acquire();
+  }
+
+  @Test
+  public void testNewLoadIsNotStartedIfResourceIsActive() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void testNullLoadStatusIsReturnedIfResourceIsActive() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    assertNull(harness.doLoad());
+  }
+
+  @Test
+  public void load_withResourceInActiveResources_doesNotCheckMemoryCache() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+    verify(harness.cache, never()).remove(any(Key.class));
+  }
+
+  @Test
+  public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.isMemoryCacheable = false;
+    harness.doLoad();
+
+    verify(harness.resource, never()).acquire();
+    verify(harness.job).start((DecodeJob) any());
+  }
+
+  @Test
+  public void testCacheIsCheckedIfMemoryCacheable() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void testCacheIsNotCheckedIfNotMemoryCacheable() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.isMemoryCacheable = false;
+    harness.doLoad();
+
+    verify(harness.job).start((DecodeJob) any());
+  }
+
+  @Test
+  public void testResourceIsReturnedFromCacheIfPresent() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(eq(harness.resource), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void testHandlesNonEngineResourcesFromCacheIfPresent() {
+    final Object expected = new Object();
+    @SuppressWarnings("rawtypes") Resource fromCache = mockResource();
+    when(fromCache.get()).thenReturn(expected);
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
+
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[0];
+        assertEquals(expected, resource.get());
+        return null;
+      }
+    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());
+
+    harness.doLoad();
+
+    verify(harness.cb).onResourceReady(anyResource(), isADataSource());
+  }
+
+  @Test
+  public void testResourceIsAddedToActiveResourceIfReturnedFromCache() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+    EngineResource<?> activeResource = harness.activeResources.get(harness.cacheKey);
+    assertThat(activeResource).isEqualTo(harness.resource);
+  }
+
+  @Test
+  public void testResourceIsAcquiredIfReturnedFromCache() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.resource).acquire();
+  }
+
+  @Test
+  public void testNewLoadIsNotStartedIfResourceIsCached() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void testNullLoadStatusIsReturnedForCachedResource() {
+    when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
+
+    Engine.LoadStatus loadStatus = harness.doLoad();
+    assertNull(loadStatus);
+  }
+
+  @Test
+  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
+    harness.doLoad();
+
+    harness.callOnEngineJobComplete();
+
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testEngineIsSetAsResourceListenerOnJobComplete() {
+    harness.doLoad();
+
+    harness.callOnEngineJobComplete();
+
+    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.getEngine()));
+  }
+
+  @Test
+  public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
+    harness.doLoad();
+
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
+  }
+
+  @Test
+  public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
+    when(harness.resource.isCacheable()).thenReturn(true);
+    harness.callOnEngineJobComplete();
+
+    EngineResource<?> resource = harness.activeResources.get(harness.cacheKey);
+    assertThat(harness.resource).isEqualTo(resource);
+  }
+
+  @Test
+  public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
+    harness.getEngine().onEngineJobComplete(harness.job, harness.cacheKey, /*resource=*/ null);
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
+  }
+
+  @Test
+  public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
+    when(harness.resource.isCacheable()).thenReturn(false);
+    harness.callOnEngineJobComplete();
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
+  }
+
+  @Test
+  public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobCancel() {
+    harness.doLoad();
+
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
+  }
+
+  @Test
+  public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
+    harness.doLoad();
+
+    harness.getEngine().onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    assertEquals(harness.job, harness.jobs.get(harness.cacheKey, harness.onlyRetrieveFromCache));
+  }
+
+  @Test
+  public void testResourceIsAddedToCacheOnReleased() {
+    final Object expected = new Object();
+    when(harness.resource.isCacheable()).thenReturn(true);
+    when(harness.resource.get()).thenReturn(expected);
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
+        assertEquals(expected, resource.get());
+        return null;
+      }
+    }).when(harness.cache).put(eq(harness.cacheKey), anyResource());
+
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+
+    verify(harness.cache).put(eq(harness.cacheKey), anyResource());
+  }
+
+  @Test
+  public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
+    when(harness.resource.isCacheable()).thenReturn(false);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+
+    verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
+  }
+
+  @Test
+  public void testResourceIsRecycledIfNotCacheableWhenReleased() {
+    when(harness.resource.isCacheable()).thenReturn(false);
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+    verify(harness.resourceRecycler).recycle(eq(harness.resource));
+  }
+
+  @Test
+  public void testResourceIsRemovedFromActiveResourcesWhenReleased() {
+    harness.activeResources.activate(harness.cacheKey, harness.resource);
+
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+
+    assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
+  }
+
+  @Test
+  public void testEngineAddedAsListenerToMemoryCache() {
+    harness.getEngine();
+    verify(harness.cache).setResourceRemovedListener(eq(harness.getEngine()));
+  }
+
+  @Test
+  public void testResourceIsRecycledWhenRemovedFromCache() {
+    harness.getEngine().onResourceRemoved(harness.resource);
+    verify(harness.resourceRecycler).recycle(eq(harness.resource));
+  }
+
+  @Test
+  public void testJobIsPutInJobWithCacheKeyWithRelevantIds() {
+    harness.doLoad();
+
+    assertThat(harness.jobs.getAll()).containsEntry(harness.cacheKey, harness.job);
+  }
+
+  @Test
+  public void testKeyFactoryIsGivenNecessaryArguments() {
+    harness.doLoad();
+
+    verify(harness.keyFactory)
+        .buildKey(eq(harness.model), eq(harness.signature), eq(harness.width), eq(harness.height),
+            eq(harness.transformations), eq(Object.class), eq(Object.class), eq(harness.options));
+  }
+
+  @Test
+  public void testFactoryIsGivenNecessaryArguments() {
+    harness.doLoad();
+
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(false) /*useUnlimitedSourceGeneratorPool*/,
+        /*useAnimationPool=*/ eq(false),
+        /*onlyRetrieveFromCache=*/ eq(false));
+  }
+
+  @Test
+  public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    harness.doLoad();
+
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(true) /*useUnlimitedSourceGeneratorPool*/,
+        /*useAnimationPool=*/ eq(false),
+        /*onlyRetrieveFromCache=*/ eq(false));
+  }
+
+  @Test
+  public void testReleaseReleasesEngineResource() {
+    EngineResource<Object> engineResource = mock(EngineResource.class);
+    harness.getEngine().release(engineResource);
+    verify(engineResource).release();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfAskedToReleaseNonEngineResource() {
+    harness.getEngine().release(mockResource());
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testThrowsIfLoadCalledOnBackgroundThread() throws InterruptedException {
+    BackgroundUtil.testInBackground(new BackgroundUtil.BackgroundTester() {
+      @Override
+      public void runTest() {
+        harness.doLoad();
+      }
+    });
+  }
+
+  @Test
+  public void load_afterResourceIsLoadedInActiveResources_returnsFromMemoryCache() {
+    when(harness.resource.isCacheable()).thenReturn(true);
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        harness.callOnEngineJobComplete();
+        return null;
+      }
+    }).when(harness.job).start(any(DecodeJob.class));
+    harness.doLoad();
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_afterResourceIsLoadedAndReleased_returnsFromMemoryCache() {
+    harness.cache = new LruResourceCache(100);
+    when(harness.resource.isCacheable()).thenReturn(true);
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+        harness.callOnEngineJobComplete();
+        return null;
+      }
+    }).when(harness.job).start(any(DecodeJob.class));
+    harness.doLoad();
+    harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
+    harness.doLoad();
+    verify(harness.cb).onResourceReady(any(Resource.class), eq(DataSource.MEMORY_CACHE));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_andPreviousNormalLoad_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    verify(first).start(any(DecodeJob.class));
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withNormalLoad_afterPreviousRetrieveFromCache_startsNewLoad() {
+    EngineJob<?> first = harness.job;
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(first).start(any(DecodeJob.class));
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_afterFinishedOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(any(DecodeJob.class));
+    verify(secondNormal, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_afterCancelledOnlyRetrieveFromCache_withPendingNormal_doesNotStartNewLoad() {
+    EngineJob<?> firstNormal = harness.job;
+    harness.doLoad();
+
+    harness.job = mock(EngineJob.class);
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> secondNormal = mock(EngineJob.class);
+    harness.job = secondNormal;
+    harness.onlyRetrieveFromCache = false;
+    harness.doLoad();
+
+    verify(firstNormal).start(any(DecodeJob.class));
+    verify(secondNormal, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_withOtherRetrieveFromCachePending_doesNotStartNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousFinishedOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.callOnEngineJobComplete();
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void load_withOnlyRetrieveFromCache_afterPreviousCancelledOnlyFromCacheLoad_startsNew() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine().onEngineJobCancelled(harness.job, harness.cacheKey);
+
+    EngineJob<?> second = mock(EngineJob.class);
+    harness.job = second;
+    harness.doLoad();
+
+    verify(second).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobComplete_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOldJobForKey_doesNotRemoveJob() {
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+
+  @Test
+  public void onEngineJobComplete_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobComplete(mock(EngineJob.class), harness.cacheKey, harness.resource);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  @Test
+  public void onEngineJobCancelled_withOnlyRetrieveFromCacheAndOldJobForKey_doesNotRemoveJob() {
+    harness.onlyRetrieveFromCache = true;
+    harness.doLoad();
+    harness.getEngine()
+        .onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);
+
+    harness.job = mock(EngineJob.class);
+    harness.doLoad();
+
+    verify(harness.job, never()).start(any(DecodeJob.class));
+  }
+
+  private static class EngineTestHarness {
+    final EngineKey cacheKey = mock(EngineKey.class);
+    final EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
+    ResourceCallback cb = mock(ResourceCallback.class);
+    @SuppressWarnings("rawtypes")
+    final EngineResource resource = mock(EngineResource.class);
+    final Jobs jobs = new Jobs();
+    final ActiveResources activeResources =
+        new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);
+
+    final int width = 100;
+    final int height = 100;
+
+    final Object model = new Object();
+    MemoryCache cache = mock(MemoryCache.class);
+    EngineJob<?> job;
+    private Engine engine;
+    final Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
+    final Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
+    final ResourceRecycler resourceRecycler = mock(ResourceRecycler.class);
+    final Key signature = mock(Key.class);
+    final Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+    final Options options = new Options();
+    final GlideContext glideContext = mock(GlideContext.class);
+    boolean isMemoryCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
+    boolean onlyRetrieveFromCache = false;
+    final boolean isScaleOnlyOrNoTransform = true;
+
+    EngineTestHarness() {
+      when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
+          eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);
+      when(resource.getResource()).thenReturn(mock(Resource.class));
+
+      job = mock(EngineJob.class);
+    }
+
+    void callOnEngineJobComplete() {
+      getEngine().onEngineJobComplete(job, cacheKey, resource);
+    }
+
+
+    Engine.LoadStatus doLoad() {
+      when(
+          engineJobFactory.build(
+              eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean(), anyBoolean()))
+          .thenReturn((EngineJob<Object>) job);
+      when(job.onlyRetrieveFromCache()).thenReturn(onlyRetrieveFromCache);
+      return getEngine().load(glideContext,
+          model,
+          signature,
+          width,
+          height,
+          Object.class /*resourceClass*/,
+          Object.class /*transcodeClass*/,
+          Priority.HIGH,
+          DiskCacheStrategy.ALL,
+          transformations,
+          false /*isTransformationRequired*/,
+          isScaleOnlyOrNoTransform,
+          options,
+          isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
+          /*useAnimationPool=*/ false,
+          onlyRetrieveFromCache,
+          cb);
+    }
+
+    Engine getEngine() {
+      if (engine == null) {
+        engine =
+            new Engine(
+                cache,
+                mock(DiskCache.Factory.class),
+                GlideExecutor.newDiskCacheExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                MockGlideExecutor.newMainThreadExecutor(),
+                jobs,
+                keyFactory,
+                activeResources,
+                engineJobFactory,
+                decodeJobFactory,
+                resourceRecycler,
+                /*isActiveResourceRetentionAllowed=*/ true);
+      }
+      return engine;
+    }
+  }
+
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
new file mode 100644
index 000000000..bcefcbb1a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
@@ -0,0 +1,193 @@
+package com.bumptech.glide.load.engine;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Option.CacheKeyUpdater;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ResourceCacheKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Mock private Transformation<Object> transformation1;
+  @Mock private Transformation<Object> transformation2;
+  private LruArrayPool arrayPool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    arrayPool = new LruArrayPool();
+    doAnswer(new Util.WriteDigest("transformation1")).when(transformation1)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("transformation1")).when(transformation2)
+        .updateDiskCacheKey(any(MessageDigest.class));
+  }
+
+  @Test
+  public void testEqualsAndHashCode() {
+    Options memoryOptions = new Options();
+    memoryOptions.set(Option.memory("key", new Object()), new Object());
+
+    Options diskOptions = new Options();
+    diskOptions.set(Option.disk("key", new CacheKeyUpdater<String>() {
+      @Override
+      public void update(@NonNull byte[] keyBytes, @NonNull String value,
+          @NonNull MessageDigest messageDigest) {
+        messageDigest.update(keyBytes);
+        messageDigest.update(value.getBytes(Key.CHARSET));
+
+      }
+    }), "value");
+
+    for (int i = 0; i < 20; i++) {
+      byte[] array = new byte[9];
+      Arrays.fill(array, (byte) 2);
+      arrayPool.put(array);
+    }
+
+    keyTester
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()),
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("otherSource"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("otherSignature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                200,
+                100,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                200,
+                transformation1,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation2,
+                Object.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Integer.class,
+                new Options()))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                memoryOptions))
+        .addEquivalenceGroup(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                diskOptions))
+        .addRegressionTest(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                new Options()),
+            "04d632bfe8e588544909fc44edb7328fa28bea6831b96927ade22b44818654e2")
+        .addRegressionTest(
+            new ResourceCacheKey(
+                arrayPool,
+                new ObjectKey("source"),
+                new ObjectKey("signature"),
+                100,
+                100,
+                transformation1,
+                Object.class,
+                diskOptions),
+            "781ff8cd30aaaf248134580004ea6d63a1b87ae20ea0f769caf379d7d84986d0")
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
index 9d4257b6d..80405ffc9 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.load.engine;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 import android.os.Looper;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,7 +28,7 @@ public void setUp() {
 
   @Test
   public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
-    Resource resource = mock(Resource.class);
+    Resource<?> resource = mockResource();
     Shadows.shadowOf(Looper.getMainLooper()).pause();
     recycler.recycle(resource);
     verify(resource).recycle();
@@ -37,11 +36,11 @@ public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
 
   @Test
   public void testDoesNotRecycleChildResourceSynchronously() {
-    Resource parent = mock(Resource.class);
-    final Resource child = mock(Resource.class);
-    doAnswer(new Answer() {
+    Resource<?> parent = mockResource();
+    final Resource<?> child = mockResource();
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         recycler.recycle(child);
         return null;
       }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
index e81521160..5ee47b04b 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
@@ -6,12 +6,9 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.AttributeStrategy.Key;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
index 9fc1f1eb2..234b0f0e3 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
@@ -4,7 +4,6 @@
 import static org.junit.Assert.assertNull;
 
 import android.graphics.Bitmap;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
new file mode 100644
index 000000000..3139df1a8
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMapTest.java
@@ -0,0 +1,121 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertNull;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class GroupedLinkedMapTest {
+
+  private GroupedLinkedMap<Key, Object> map;
+
+  @Before
+  public void setUp() {
+    map = new GroupedLinkedMap<>();
+  }
+
+  @Test
+  public void testReturnsNullForGetWithNoBitmap() {
+    Key key =  new Key("key", /*width=*/ 1, /*height=*/ 1);
+    assertNull(map.get(key));
+  }
+
+  @Test
+  public void testCanAddAndRemoveABitmap() {
+    Key key = new Key("key", 1, 1);
+    Object expected = new Object();
+
+    map.put(key, expected);
+
+    assertThat(map.get(key)).isEqualTo(expected);
+  }
+
+  @Test
+  public void testCanAddAndRemoveMoreThanOneBitmapForAGivenKey() {
+    Key key = new Key("key", 1, 1);
+    Integer value = 20;
+
+    int numToAdd = 10;
+
+    for (int i = 0; i < numToAdd; i++) {
+      map.put(key, value);
+    }
+
+    for (int i = 0; i < numToAdd; i++) {
+      assertThat(map.get(key)).isEqualTo(value);
+    }
+  }
+
+  @Test
+  public void testLeastRecentlyRetrievedKeyIsLeastRecentlyUsed() {
+    Key firstKey = new Key("key", 1, 1);
+    Integer firstValue = 10;
+    map.put(firstKey, firstValue);
+    map.put(firstKey, firstValue);
+
+    Key secondKey = new Key("key", 2, 2);
+    Integer secondValue = 20;
+    map.put(secondKey, secondValue);
+
+    map.get(firstKey);
+
+    assertThat(map.removeLast()).isEqualTo(secondValue);
+  }
+
+  @Test
+  public void testAddingAnEntryDoesNotMakeItMostRecentlyUsed() {
+    Key firstKey = new Key("key", 1, 1);
+    Integer firstValue = 10;
+
+    map.put(firstKey, firstValue);
+    map.put(firstKey, firstValue);
+
+    map.get(firstKey);
+
+    Integer secondValue = 20;
+    map.put(new Key("key", 2, 2), secondValue);
+
+    assertThat(map.removeLast()).isEqualTo(secondValue);
+  }
+
+  private static final class Key implements Poolable {
+
+    private final String key;
+    private final int width;
+    private final int height;
+
+    Key(String key, int width, int height) {
+      this.key = key;
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return key.equals(other.key) && width == other.width && height == other.height;
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = key != null ? key.hashCode() : 0;
+      result = 31 * result + width;
+      result = 31 * result + height;
+      return result;
+    }
+
+    @Override
+    public void offer() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
new file mode 100644
index 000000000..1c037b2f5
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
@@ -0,0 +1,199 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class LruArrayPoolTest {
+  private static final int MAX_SIZE = 10;
+  private static final int MAX_PUT_SIZE = MAX_SIZE / 2;
+  private static final Class<byte[]> ARRAY_CLASS = byte[].class;
+  private static final ArrayAdapterInterface<byte[]> ADAPTER = new ByteArrayAdapter();
+  private LruArrayPool pool;
+
+  @Before
+  public void setUp() {
+    pool = new LruArrayPool(MAX_SIZE);
+  }
+
+  @Test
+  public void testNewPoolIsEmpty() {
+    assertEquals(pool.getCurrentSize(), 0);
+  }
+
+  @Test
+  public void testICanAddAndGetValidArray() {
+    int size = 758;
+    int value = 564;
+    fillPool(pool, size - 1, value);
+    pool.put(createArray(ARRAY_CLASS, size, value));
+    Object array = pool.get(size, ARRAY_CLASS);
+    assertNotNull(array);
+    assertTrue(array.getClass() == ARRAY_CLASS);
+    assertTrue(ADAPTER.getArrayLength((byte[]) array) >= size);
+    assertTrue(((byte[]) array)[0] == (byte) 0);
+  }
+
+  @Test
+  public void testItIsSizeLimited() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 1);
+    assertTrue(pool.getCurrentSize() <= MAX_SIZE);
+  }
+
+  @Test
+  public void testArrayLargerThanPoolIsNotAdded() {
+    pool = new LruArrayPool(MAX_SIZE);
+    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0));
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testClearMemoryRemovesAllArrays() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0);
+    pool.clearMemory();
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {
+    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {
+      testTrimMemory(MAX_SIZE, trimLevel, 0);
+    }
+  }
+
+  @Test
+  public void get_withEmptyPool_returnsExactArray() {
+    assertThat(pool.get(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void get_withPoolContainingLargerArray_returnsLargerArray() {
+    byte[] expected = new byte[MAX_PUT_SIZE];
+    pool.put(expected);
+    assertThat(pool.get(MAX_PUT_SIZE - 1, byte[].class)).isSameAs(expected);
+  }
+
+  @Test
+  public void get_withPoolContainingSmallerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE - 1]);
+    assertThat(pool.get(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void get_withPoolLessThanHalfFull_returnsFromPools() {
+    int size = MAX_SIZE / 2;
+    byte[] expected = new byte[size];
+    pool.put(expected);
+    assertThat(pool.get(1, byte[].class)).isSameAs(expected);
+  }
+
+  @Test
+  public void get_withPoolMoreThanHalfFull_sizeMoreThanHalfArrayInPool_returnsArray() {
+    Set<byte[]> expected = new HashSet<>();
+    for (int i = 0; i < 3; i++) {
+      byte[] toPut = new byte[MAX_SIZE / 3];
+      expected.add(toPut);
+      pool.put(toPut);
+    }
+    byte[] received = pool.get(2, byte[].class);
+    assertThat(expected).contains(received);
+  }
+
+  @Test
+  public void get_withPoolMoreThanHalfFull_sizeLessThanHalfArrayInPool_returnsNewArray() {
+    pool = new LruArrayPool(100);
+    for (int i = 0; i < 3; i++) {
+      byte[] toPut = new byte[100 / 3];
+      pool.put(toPut);
+    }
+    int requestedSize = 100 / 3 / LruArrayPool.MAX_OVER_SIZE_MULTIPLE;
+    byte[] received = pool.get(requestedSize, byte[].class);
+    assertThat(received).hasLength(requestedSize);
+  }
+
+  @Test
+  public void getExact_withEmptyPool_returnsExactArray() {
+    byte[] result = pool.getExact(MAX_PUT_SIZE, byte[].class);
+    assertThat(result).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void getExact_withPoolContainingLargerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE]);
+    int expectedSize = MAX_PUT_SIZE - 1;
+    assertThat(pool.getExact(expectedSize, byte[].class)).hasLength(expectedSize);
+  }
+
+  @Test
+  public void getExact_withPoolContainingSmallerArray_returnsExactArray() {
+    pool.put(new byte[MAX_PUT_SIZE - 1]);
+    assertThat(pool.getExact(MAX_PUT_SIZE, byte[].class)).hasLength(MAX_PUT_SIZE);
+  }
+
+  @Test
+  public void getExact_withPoolContainingExactArray_returnsArray() {
+    byte[] expected = new byte[MAX_PUT_SIZE];
+    pool.put(expected);
+    assertThat(pool.getExact(MAX_PUT_SIZE, byte[].class)).isSameAs(expected);
+  }
+
+  @Test
+  public void put_withArrayMoreThanHalfPoolSize_doesNotRetainArray() {
+    int targetSize = (MAX_SIZE / 2) + 1;
+    byte[] toPut = new byte[targetSize];
+    pool.put(toPut);
+    assertThat(pool.getCurrentSize()).isEqualTo(0);
+    assertThat(pool.get(targetSize, byte[].class)).isNotSameAs(toPut);
+  }
+
+  private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
+    pool = new LruArrayPool(MAX_SIZE);
+    fillPool(pool, fillSize / ADAPTER.getElementSizeInBytes(), 1);
+    pool.trimMemory(trimLevel);
+    assertEquals("Failed level=" + trimLevel, expectedSize, pool.getCurrentSize());
+  }
+
+  private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
+    for (int i = 0; i < arrayCount; i++) {
+      pool.put(createArray(ARRAY_CLASS, arrayLength, 10));
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> T createArray(Class<T> type, int size, int value) {
+    Object array = null;
+    if (type.equals(int[].class)) {
+      array = new int[size];
+      Arrays.fill((int[]) array, value);
+    } else if (type.equals(byte[].class)) {
+      array = new byte[size];
+      Arrays.fill((byte[]) array, (byte) value);
+    }
+    return (T) array;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index 6db6062dd..0b452c214 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -2,7 +2,7 @@
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -13,7 +13,11 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,12 +26,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowBitmap;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LruBitmapPoolTest {
@@ -90,9 +88,7 @@ public void testClearMemoryRemovesAllBitmaps() {
   public void testEvictedBitmapsAreRecycled() {
     fillPool(pool, MAX_SIZE);
     List<Bitmap> bitmaps = new ArrayList<>(MAX_SIZE);
-    for (Bitmap b : strategy.bitmaps) {
-      bitmaps.add(b);
-    }
+    bitmaps.addAll(strategy.bitmaps);
 
     pool.clearMemory();
 
@@ -102,18 +98,18 @@ public void testEvictedBitmapsAreRecycled() {
   }
 
   @Test
-  public void testTrimMemoryBackgroundOrLessRemovesHalfOfBitmaps() {
-    testTrimMemory(MAX_SIZE, TRIM_MEMORY_BACKGROUND, MAX_SIZE / 2);
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfBitmaps() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
   }
 
   @Test
-  public void testTrimMemoryBackgroundOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
-    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_BACKGROUND, 0);
+  public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, 0);
   }
 
   @Test
-  public void testTrimMemoryModerateOrGreaterRemovesAllBitmaps() {
-    for (int trimLevel : new int[] { TRIM_MEMORY_MODERATE, TRIM_MEMORY_COMPLETE }) {
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllBitmaps() {
+    for (int trimLevel : new int[] { TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE }) {
       testTrimMemory(MAX_SIZE, trimLevel, MAX_SIZE);
     }
   }
@@ -142,6 +138,18 @@ public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetD
     assertEquals(expected, result);
   }
 
+  @Test
+  public void get_withNullConfig_andEmptyPool_returnsNewArgb8888Bitmap() {
+    Bitmap result = pool.get(100, 100, /*config=*/ null);
+    assertThat(result.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
+  @Test
+  public void getDirty_withNullConfig_andEmptyPool_returnsNewArgb8888Bitmap() {
+    Bitmap result = pool.getDirty(100, 100, /*config=*/ null);
+    assertThat(result.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);
+  }
+
   private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
     MockStrategy strategy = new MockStrategy();
     LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);
@@ -232,7 +240,7 @@ private Bitmap createMutableBitmap(Bitmap.Config config) {
   }
 
   private static class MockStrategy implements LruPoolStrategy {
-    private LinkedList<Bitmap> bitmaps = new LinkedList<>();
+    private final ArrayDeque<Bitmap> bitmaps = new ArrayDeque<>();
     private int numRemoves;
     private int numPuts;
 
@@ -244,7 +252,7 @@ public void put(Bitmap bitmap) {
 
     @Override
     public Bitmap get(int width, int height, Bitmap.Config config) {
-      return bitmaps.removeLast();
+      return bitmaps.isEmpty() ? null : bitmaps.removeLast();
     }
 
     @Override
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
new file mode 100644
index 000000000..c37b5946a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
@@ -0,0 +1,35 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.graphics.Bitmap;
+import com.google.common.testing.EqualsTester;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class SizeConfigStrategyTest {
+
+  @Mock
+  private SizeConfigStrategy.KeyPool pool;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void testKeyEquals() {
+    new EqualsTester()
+        .addEqualityGroup(
+            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888),
+            new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.ARGB_8888)
+        )
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 101, Bitmap.Config.ARGB_8888))
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, Bitmap.Config.RGB_565))
+        .addEqualityGroup(new SizeConfigStrategy.Key(pool, 100, null /*config*/))
+        .testEquals();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
index 79385ce31..6175eb2bf 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
@@ -6,10 +6,8 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-import com.google.common.testing.EqualsTester;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.SizeStrategy.Key;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
similarity index 53%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index a1ecd5953..24a1098e7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -3,10 +3,16 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+import static org.mockito.Mockito.mock;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.tests.Util;
-
+import java.io.File;
+import java.io.IOException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,30 +20,52 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-import java.security.MessageDigest;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class DiskLruCacheWrapperTest {
-  private DiskLruCacheWrapper cache;
+  private DiskCache cache;
   private byte[] data;
-  private StringKey key;
+  private ObjectKey key;
+  private File dir;
 
   @Before
   public void setUp() {
-    File dir = RuntimeEnvironment.application.getCacheDir();
-    cache = new DiskLruCacheWrapper(dir, 10 * 1024 * 1024);
-    key = new StringKey("test" + Math.random());
+    dir = RuntimeEnvironment.application.getCacheDir();
+    cache = DiskLruCacheWrapper.create(dir, 10 * 1024 * 1024);
+    key = new ObjectKey("test" + Math.random());
     data = new byte[] { 1, 2, 3, 4, 5, 6 };
   }
 
+  @After
+  public void tearDown() {
+    try {
+      cache.clear();
+    } finally {
+      deleteRecursive(dir);
+    }
+  }
+
+  private static void deleteRecursive(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursive(f);
+        }
+      }
+    }
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
+    }
+  }
+
   @Test
   public void testCanInsertAndGet() throws IOException {
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         try {
           Util.writeFile(file, data);
         } catch (IOException e) {
@@ -56,7 +84,7 @@ public boolean write(File file) {
   public void testDoesNotCommitIfWriterReturnsFalse() {
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         return false;
       }
     });
@@ -68,7 +96,7 @@ public boolean write(File file) {
   public void testDoesNotCommitIfWriterWritesButReturnsFalse() {
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         try {
           Util.writeFile(file, data);
         } catch (IOException e) {
@@ -86,7 +114,7 @@ public void testEditIsAbortedIfWriterThrows() throws IOException {
     try {
       cache.put(key, new DiskCache.Writer() {
         @Override
-        public boolean write(File file) {
+        public boolean write(@NonNull File file) {
           throw new RuntimeException("test");
         }
       });
@@ -96,7 +124,7 @@ public boolean write(File file) {
 
     cache.put(key, new DiskCache.Writer() {
       @Override
-      public boolean write(File file) {
+      public boolean write(@NonNull File file) {
         try {
           Util.writeFile(file, data);
         } catch (IOException e) {
@@ -111,16 +139,25 @@ public boolean write(File file) {
     assertArrayEquals(data, received);
   }
 
-  private static class StringKey implements Key {
-    private final String key;
-
-    public StringKey(String key) {
-      this.key = key;
-    }
+  // Tests #2465.
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    assumeTrue("A file handle is likely open, so cannot delete dir", !Util.isWindows());
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+  }
 
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      messageDigest.update(key.getBytes());
-    }
+  // Tests #2465.
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    assumeTrue("A file handle is likely open, so cannot delete dir", !Util.isWindows());
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
index 57ce35ebb..a1c3f2d55 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyObject;
 import static org.mockito.Matchers.eq;
@@ -13,8 +14,9 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.util.LruCache;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,7 +31,7 @@
   private String currentKey;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     currentKey = "";
     listener = mock(CacheListener.class);
     cache = new TestLruCache(SIZE, listener);
@@ -61,14 +63,15 @@ public void testCanPutNullItemWithoutChangingSize() {
   @Test
   public void testReplacingNonNullItemWithNullItemDecreasesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, null);
 
     for (int i = 0; i < SIZE; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener, never()).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
   }
 
   @Test
@@ -87,14 +90,16 @@ public void testReplacingNullItemWIthNullItemIncreasesSize() {
   @Test
   public void testReplacingNonNullItemWithNonNullItemUpdatesSize() {
     String key = getKey();
-    cache.put(key, new Object());
+    Object initialValue = new Object();
+    cache.put(key, initialValue);
     cache.put(key, new Object());
 
-    for (int i = 0; i < SIZE; i++) {
+    for (int i = 0; i < SIZE - 1; i++) {
       cache.put(getKey(), new Object());
     }
 
-    verify(listener).onItemRemoved(anyObject());
+    verify(listener).onItemRemoved(initialValue);
+    verify(listener, never()).onItemRemoved(not(eq(initialValue)));
   }
 
   @Test
@@ -192,6 +197,34 @@ public void testCanPutSameItemMultipleTimes() {
     verify(listener, never()).onItemRemoved(anyObject());
   }
 
+  @Test
+  public void put_withSameValueTwice_doesNotEvictItems() {
+    String key = getKey();
+    Object value = new Object();
+    cache.put(key, value);
+    cache.put(key, value);
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withExistingNullValue_doesNotNotifyListener() {
+    String key = getKey();
+    cache.put(key, /* item= */ null);
+    cache.put(key, new Object());
+
+    verify(listener, never()).onItemRemoved(anyObject());
+  }
+
+  @Test
+  public void put_withNullValue_withSizeGreaterThanMaximum_notifiesListener() {
+    String key = getKey();
+    when(listener.getSize(null)).thenReturn((int) (cache.getMaxSize() * 2));
+    cache.put(key, null);
+
+    verify(listener).onItemRemoved(anyObject());
+  }
+
   @Test
   public void testCanIncreaseSizeDynamically() {
     int sizeMultiplier = 2;
@@ -260,7 +293,7 @@ public void testDecreasesSizeWhenRemovesKey() {
     Object value = new Object();
     cache.put(key, value);
     for (int i = 0; i < SIZE - 1; i++) {
-      cache.put(key, value);
+      cache.put(getKey(), value);
     }
     cache.remove(key);
     cache.put(key, value);
@@ -327,26 +360,26 @@ private String getKey() {
   }
 
   private interface CacheListener {
-    public void onItemRemoved(Object item);
+    void onItemRemoved(Object item);
 
-    public int getSize(Object item);
+    int getSize(Object item);
   }
 
   private static class TestLruCache extends LruCache<String, Object> {
     private final CacheListener listener;
 
-    public TestLruCache(int size, CacheListener listener) {
+    TestLruCache(int size, CacheListener listener) {
       super(size);
       this.listener = listener;
     }
 
     @Override
-    protected void onItemEvicted(String key, Object item) {
+    protected void onItemEvicted(@NonNull String key, @Nullable Object item) {
       listener.onItemRemoved(item);
     }
 
     @Override
-    protected int getSize(Object item) {
+    protected int getSize(@Nullable Object item) {
       return listener.getSize(item);
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
new file mode 100644
index 000000000..8d8e43b1f
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -0,0 +1,217 @@
+package com.bumptech.glide.load.engine.cache;
+
+import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.ComponentCallbacks2;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.util.LruCache;
+import java.security.MessageDigest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class LruResourceCacheTest {
+
+  @Test
+  public void put_withExistingItem_updatesSizeCorrectly() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.getCurrentSize()).isEqualTo(harness.second.getSize());
+  }
+
+  @Test
+  public void put_withExistingItem_evictsExistingItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+  }
+
+  @Test
+  public void get_afterPutWithExistingItem_returnsNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    assertThat(harness.cache.get(harness.key)).isEqualTo(harness.second);
+  }
+
+  @Test
+  public void onItemEvicted_withNullValue_doesNotNotifyListener() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.onItemEvicted(new MockKey(), null);
+    verify(harness.listener, never()).onResourceRemoved(anyResource());
+  }
+
+  @Test
+  public void clearMemory_afterPutWithExistingItem_evictsOnlyNewItem() {
+    PutWithExistingEntryHarness harness = new PutWithExistingEntryHarness();
+    harness.cache.put(harness.key, harness.first);
+    harness.cache.put(harness.key, harness.second);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+
+    harness.cache.clearMemory();
+
+    verify(harness.listener, times(1)).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryBackground() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
+
+    verify(harness.listener).onResourceRemoved(eq(harness.first));
+    verify(harness.listener).onResourceRemoved(eq(harness.second));
+  }
+
+  @Test
+  public void testTrimMemoryModerate() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testTrimMemoryUiHidden() {
+    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
+
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
+
+    verify(harness.listener).onResourceRemoved(harness.first);
+    verify(harness.listener, never()).onResourceRemoved(harness.second);
+  }
+
+  @Test
+  public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource<?> resource = mockResource();
+    when(resource.getSize()).thenReturn(200);
+
+    ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    resourceCache.setResourceRemovedListener(listener);
+    resourceCache.put(new MockKey(), resource);
+
+    verify(listener).onResourceRemoved(eq(resource));
+  }
+
+  @Test
+  public void testSizeIsBasedOnResource() {
+    LruResourceCache resourceCache = new LruResourceCache(100);
+    Resource<?> first = getResource(50);
+    MockKey firstKey = new MockKey();
+    resourceCache.put(firstKey, first);
+    Resource<?> second = getResource(50);
+    MockKey secondKey = new MockKey();
+    resourceCache.put(secondKey, second);
+
+    assertTrue(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+
+    Resource<?> third = getResource(50);
+    MockKey thirdKey = new MockKey();
+    resourceCache.put(thirdKey, third);
+
+    assertFalse(resourceCache.contains(firstKey));
+    assertTrue(resourceCache.contains(secondKey));
+    assertTrue(resourceCache.contains(thirdKey));
+  }
+
+  @Test
+  public void testPreventEviction() {
+    final MemoryCache cache = new LruResourceCache(100);
+    final Resource<?> first = getResource(30);
+    final Key firstKey = new MockKey();
+    cache.put(firstKey, first);
+    Resource<?> second = getResource(30);
+    Key secondKey = new MockKey();
+    cache.put(secondKey, second);
+    Resource<?> third = getResource(30);
+    Key thirdKey = new MockKey();
+    cache.put(thirdKey, third);
+    cache.setResourceRemovedListener(new ResourceRemovedListener() {
+      @Override
+      public void onResourceRemoved(@NonNull Resource<?> removed) {
+        if (removed == first) {
+          cache.put(firstKey, first);
+        }
+      }
+    });
+
+    // trims from 100 to 50, having 30+30+30 items, it should trim to 1 item
+    cache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
+
+    // and that 1 item must be first, because it's forced to return to cache in the listener
+    @SuppressWarnings("unchecked")
+    LruCache<Key, Resource<?>> lruCache = (LruCache<Key, Resource<?>>) cache;
+    assertTrue(lruCache.contains(firstKey));
+    assertFalse(lruCache.contains(secondKey));
+    assertFalse(lruCache.contains(thirdKey));
+  }
+
+  private Resource<?> getResource(int size) {
+    Resource<?> resource = mockResource();
+    when(resource.getSize()).thenReturn(size);
+    return resource;
+  }
+
+  private static class MockKey implements Key {
+    @Override
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
+      messageDigest.update(toString().getBytes(CHARSET));
+    }
+  }
+
+  private static class PutWithExistingEntryHarness {
+    final LruResourceCache cache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+    final Key key = new MockKey();
+
+    PutWithExistingEntryHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      cache.setResourceRemovedListener(listener);
+    }
+  }
+
+  private static class TrimClearMemoryCacheHarness {
+    final LruResourceCache resourceCache = new LruResourceCache(100);
+    final Resource<?> first = mockResource();
+    final Resource<?> second = mockResource();
+    final ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
+
+    TrimClearMemoryCacheHarness() {
+      when(first.getSize()).thenReturn(50);
+      when(second.getSize()).thenReturn(50);
+      resourceCache.put(new MockKey(), first);
+      resourceCache.put(new MockKey(), second);
+      resourceCache.setResourceRemovedListener(listener);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index 3d3bb983c..ae2eb4bd6 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -4,14 +4,12 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import com.google.common.collect.Range;
-
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
-
+import com.bumptech.glide.load.engine.cache.MemorySizeCalculatorTest.LowRamActivityManager;
 import com.bumptech.glide.tests.Util;
-
+import com.google.common.collect.Range;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,10 +18,13 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowActivityManager;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 19, shadows = LowRamActivityManager.class)
 public class MemorySizeCalculatorTest {
   private MemorySizeHarness harness;
   private int initialSdkVersion;
@@ -67,7 +68,7 @@ public void testDefaultMemoryCacheSizeIsLimitedByMemoryClass() {
 
     float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
 
-    assertThat((float) memoryCacheSize)
+    assertThat(memoryCacheSize)
         .isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
   }
 
@@ -136,12 +137,11 @@ public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices()
 
   @Test
   public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
-    ShadowActivityManager activityManager = Shadows.shadowOf(harness.activityManager);
+    LowRamActivityManager activityManager = Shadow.extract(harness.activityManager);
     activityManager.setMemoryClass(getLargeEnoughMemoryClass());
+    activityManager.setIsLowRam();
 
-    Util.setSdkVersionInt(10);
-
-    int byteArrayPoolSize = harness.getCalculator().getByteArrayPoolSize();
+    int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
     assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
   }
 
@@ -156,18 +156,18 @@ private int getLargeEnoughMemoryClass() {
   }
 
   private static class MemorySizeHarness {
-    int pixelSize = 500;
-    int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
+    final int pixelSize = 500;
+    final int bytesPerPixel = MemorySizeCalculator.BYTES_PER_ARGB_8888_PIXEL;
     float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;
     float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;
-    float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
-    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.BYTE_ARRAY_POOL_SIZE_BYTES;
-    ActivityManager activityManager =
+    final float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
+    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.ARRAY_POOL_SIZE_BYTES;
+    final ActivityManager activityManager =
         (ActivityManager) RuntimeEnvironment.application.getSystemService(Context.ACTIVITY_SERVICE);
-    MemorySizeCalculator.ScreenDimensions screenDimensions =
+    final MemorySizeCalculator.ScreenDimensions screenDimensions =
         mock(MemorySizeCalculator.ScreenDimensions.class);
 
-    public MemorySizeCalculator getCalculator() {
+    MemorySizeCalculator getCalculator() {
       when(screenDimensions.getWidthPixels()).thenReturn(pixelSize);
       when(screenDimensions.getHeightPixels()).thenReturn(pixelSize);
       return new MemorySizeCalculator.Builder(RuntimeEnvironment.application)
@@ -176,12 +176,28 @@ public MemorySizeCalculator getCalculator() {
           .setMaxSizeMultiplier(sizeMultiplier)
           .setActivityManager(activityManager)
           .setScreenDimensions(screenDimensions)
-          .setByteArrayPoolSize(byteArrayPoolSizeBytes)
+          .setArrayPoolSize(byteArrayPoolSizeBytes)
           .build();
     }
 
-    public int getScreenSize() {
+    int getScreenSize() {
       return pixelSize * pixelSize * bytesPerPixel;
     }
   }
+
+  @Implements(ActivityManager.class)
+  public static final class LowRamActivityManager extends ShadowActivityManager {
+
+    private boolean isLowRam;
+
+    void setIsLowRam() {
+      this.isLowRam = true;
+    }
+
+    @Implementation
+    @Override
+    public boolean isLowRamDevice() {
+      return isLowRam;
+    }
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
index 738bcd951..f48c56eaa 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
@@ -2,18 +2,17 @@
 
 import static org.junit.Assert.assertTrue;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
-
+import java.security.MessageDigest;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class SafeKeyGeneratorTest {
@@ -21,7 +20,7 @@
   private int nextId;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     nextId = 0;
     keyGenerator = new SafeKeyGenerator();
   }
@@ -44,15 +43,15 @@ private String getNextId() {
     return String.valueOf(nextId++);
   }
 
-  private static class MockKey implements Key {
-    private String id;
+  private static final class MockKey implements Key {
+    private final String id;
 
-    public MockKey(String id) {
+    MockKey(String id) {
       this.id = id;
     }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {
       messageDigest.update(id.getBytes(CHARSET));
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
index 1a6f5d9cd..7a9e74be1 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -2,15 +2,15 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
+import android.support.annotation.NonNull;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -19,7 +19,7 @@
   @Test
   public void testLoadsAreExecutedInOrder() throws InterruptedException {
     final List<Integer> resultPriorities = Collections.synchronizedList(new ArrayList<Integer>());
-    GlideExecutor executor = new GlideExecutor(1);
+    GlideExecutor executor = GlideExecutor.newDiskCacheExecutor();
     for (int i = 5; i > 0; i--) {
       executor.execute(new MockRunnable(i, new MockRunnable.OnRun() {
         @Override
@@ -37,21 +37,21 @@ public void onRun(int priority) {
     assertThat(resultPriorities).containsExactly(5, 1, 2, 3, 4).inOrder();
   }
 
-  private static class MockRunnable implements Runnable,
+  private static final class MockRunnable implements Runnable,
       Comparable<MockRunnable> {
     private final int priority;
     private final OnRun onRun;
 
     @Override
-    public int compareTo(MockRunnable another) {
+    public int compareTo(@NonNull MockRunnable another) {
       return priority - another.priority;
     }
 
-    public interface OnRun {
+    interface OnRun {
       void onRun(int priority);
     }
 
-    public MockRunnable(int priority, OnRun onRun) {
+    MockRunnable(int priority, OnRun onRun) {
       this.priority = priority;
       this.onRun = onRun;
     }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..94ef1782c
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,116 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.StrictMode;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+@VisibleForTesting
+public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return newTestExecutor(new DirectExecutorService());
+  }
+
+  /**
+   * @deprecated Use {@link #newMainThreadExecutor} instead.
+   */
+  @Deprecated
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder()
+            .detectNetwork()
+            .penaltyDeath()
+            .build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(new Runnable() {
+        @Override
+        public void run() {
+          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+          StrictMode.setThreadPolicy(THREAD_POLICY);
+          try {
+            command.run();
+          } finally {
+            StrictMode.setThreadPolicy(oldPolicy);
+          }
+        }
+      });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
index a5f045618..7680c43a7 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine.prefill;
 
+import static com.bumptech.glide.tests.Util.anyResource;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertNotEquals;
 import static org.mockito.Matchers.any;
@@ -15,15 +16,20 @@
 
 import android.graphics.Bitmap;
 import android.os.Handler;
-
+import android.util.Log;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
-
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -34,20 +40,16 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import org.robolectric.shadows.ShadowLog;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapPreFillRunnerTest {
-  @Mock BitmapPreFillRunner.Clock clock;
-  @Mock BitmapPool pool;
-  @Mock MemoryCache cache;
-  @Mock Handler mainHandler;
-  private List<Bitmap> addedBitmaps = new ArrayList<>();
+  @Mock private BitmapPreFillRunner.Clock clock;
+  @Mock private BitmapPool pool;
+  @Mock private MemoryCache cache;
+  @Mock private Handler mainHandler;
+  private final List<Bitmap> addedBitmaps = new ArrayList<>();
 
   @Before
   public void setUp() {
@@ -56,7 +58,7 @@ public void setUp() {
     doAnswer(new AddBitmapPoolAnswer(addedBitmaps)).when(pool).put(any(Bitmap.class));
     when(pool.getDirty(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new CreateBitmap());
-    when(cache.put(any(Key.class), any(Resource.class)))
+    when(cache.put(any(Key.class), anyResource()))
         .thenAnswer(new AddBitmapCacheAnswer(addedBitmaps));
   }
 
@@ -131,7 +133,7 @@ public void testStopsAllocatingBitmapsUntilNextIdleCallIfAllocationsTakeLongerTh
   public void testPreFillHandlerDoesNotPostIfHasNoBitmapsToAllocate() {
     BitmapPreFillRunner handler = getHandler(new HashMap<PreFillType, Integer>());
     handler.run();
-    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyInt());
+    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyLong());
   }
 
   @Test
@@ -197,7 +199,7 @@ public void testPreFillHandlerDoesNotPostIfHasBitmapsButIsCancelled() {
   @Test
   public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));
+    when(cache.getMaxSize()).thenReturn(Long.valueOf(Util.getBitmapByteSize(bitmap)));
 
     PreFillType size =
         new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
@@ -207,7 +209,7 @@ public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
 
     getHandler(allocationOrder).run();
 
-    verify(cache).put(any(Key.class), any(Resource.class));
+    verify(cache).put(any(Key.class), anyResource());
     verify(pool, never()).put(any(Bitmap.class));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // assertThat(addedBitmaps).containsExactly(bitmap);
@@ -216,7 +218,7 @@ public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
   @Test
   public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(0);
+    when(cache.getMaxSize()).thenReturn(0L);
 
     PreFillType size =
         new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
@@ -226,7 +228,7 @@ public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
 
     getHandler(allocationOrder).run();
 
-    verify(cache, never()).put(any(Key.class), any(Resource.class));
+    verify(cache, never()).put(any(Key.class), anyResource());
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // verify(pool).put(eq(bitmap));
     // assertThat(addedBitmaps).containsExactly(bitmap);
@@ -235,7 +237,7 @@ public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
   @Test
   public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);
+    when(cache.getMaxSize()).thenReturn((long) Util.getBitmapByteSize(bitmap) / 2);
 
     PreFillType size =
         new PreFillType.Builder(bitmap.getWidth(), bitmap.getHeight()).setConfig(bitmap.getConfig())
@@ -245,7 +247,7 @@ public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
 
     getHandler(allocationOrder).run();
 
-    verify(cache, never()).put(any(Key.class), any(Resource.class));
+    verify(cache, never()).put(any(Key.class), anyResource());
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     //verify(pool).put(eq(bitmap));
     //assertThat(addedBitmaps).containsExactly(bitmap);
@@ -302,10 +304,28 @@ public void testDoesNotGetMoreThanOncePerSize() {
     // order.verify(pool, times(numBitmaps)).put(eq(bitmap));
   }
 
-  private static class AddBitmapPoolAnswer implements Answer<Void> {
-    private List<Bitmap> bitmaps;
+  @Test
+  public void allocate_whenBitmapPoolIsAtCapacity_doesNotLogWithRecycledBitmap() {
+    ShadowLog.setLoggable(BitmapPreFillRunner.TAG, Log.VERBOSE);
+
+    int dimensions = 10;
+    Bitmap.Config config = Bitmap.Config.ARGB_8888;
+    int bitmapByteSize = Util.getBitmapByteSize(dimensions, dimensions, config);
+    PreFillType preFillType = new PreFillType.Builder(dimensions).setConfig(config).build();
+    Map<PreFillType, Integer> allocationOrder = new HashMap<>();
+    allocationOrder.put(preFillType, 1);
+    PreFillQueue queue = new PreFillQueue(allocationOrder);
+    BitmapPreFillRunner runner =
+        new BitmapPreFillRunner(
+            new LruBitmapPool(bitmapByteSize - 1), new MemoryCacheAdapter(), queue);
+
+    runner.allocate();
+  }
+
+  private static final class AddBitmapPoolAnswer implements Answer<Void> {
+    private final List<Bitmap> bitmaps;
 
-    public AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
+    AddBitmapPoolAnswer(List<Bitmap> bitmaps) {
       this.bitmaps = bitmaps;
     }
 
@@ -317,10 +337,10 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     }
   }
 
-  private static class AddBitmapCacheAnswer implements Answer<Resource<?>> {
-    private List<Bitmap> bitmaps;
+  private static final class AddBitmapCacheAnswer implements Answer<Resource<?>> {
+    private final List<Bitmap> bitmaps;
 
-    public AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
+    AddBitmapCacheAnswer(List<Bitmap> bitmaps) {
       this.bitmaps = bitmaps;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
index a308dae93..87d0395d3 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -11,16 +11,15 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.google.common.collect.Range;
-
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
-
+import com.google.common.collect.Range;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,9 +29,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapPreFillerTest {
@@ -45,12 +41,12 @@
   private final Bitmap.Config defaultBitmapConfig = PreFillType.DEFAULT_CONFIG;
   private final Bitmap defaultBitmap =
       Bitmap.createBitmap(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT, defaultBitmapConfig);
-  private final int defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
-  private final int poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
-  private final int cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
+  private final long defaultBitmapSize = Util.getBitmapByteSize(defaultBitmap);
+  private final long poolSize = BITMAPS_IN_CACHE * defaultBitmapSize;
+  private final long cacheSize = BITMAPS_IN_POOL * defaultBitmapSize;
 
-  @Mock BitmapPool pool;
-  @Mock MemoryCache cache;
+  @Mock private BitmapPool pool;
+  @Mock private MemoryCache cache;
   private BitmapPreFiller bitmapPreFiller;
 
   @Before
@@ -66,9 +62,11 @@ public void setUp() {
 
   @Test
   public void testAllocationOrderContainsEnoughSizesToFillPoolAndMemoryCache() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build() });
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build());
 
     assertEquals(BITMAPS_IN_POOL + BITMAPS_IN_CACHE, allocationOrder.getSize());
   }
@@ -92,11 +90,12 @@ public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
     }
 
     int expectedSize = 0;
-    int maxSize = poolSize + cacheSize;
+    long maxSize = poolSize + cacheSize;
     for (PreFillType current : sizes) {
       int currentSize =
           Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());
-      expectedSize += currentSize * (maxSize / (3 * currentSize));
+      // See http://errorprone.info/bugpattern/NarrowingCompoundAssignment.
+      expectedSize = (int) (expectedSize + (currentSize * (maxSize / (3 * currentSize))));
     }
 
     assertEquals(expectedSize, byteSize);
@@ -104,15 +103,15 @@ public void testAllocationOrderThatDoesNotFitExactlyIntoGivenSizeRoundsDown() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
-            .setConfig(defaultBitmapConfig).build() });
+            .setConfig(defaultBitmapConfig).build());
 
-    int byteSize = 0;
+    long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
       PreFillType current = allocationOrder.remove();
       byteSize +=
@@ -124,15 +123,15 @@ public void testAllocationOrderDoesNotOverFillWithMultipleSizes() {
 
   @Test
   public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).setWeight(4).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH / 2, DEFAULT_BITMAP_HEIGHT)
             .setConfig(defaultBitmapConfig).build(),
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 3)
-            .setConfig(defaultBitmapConfig).setWeight(3).build() });
+            .setConfig(defaultBitmapConfig).setWeight(3).build());
 
-    int byteSize = 0;
+    long byteSize = 0;
     while (!allocationOrder.isEmpty()) {
       PreFillType current = allocationOrder.remove();
       byteSize +=
@@ -144,9 +143,11 @@ public void testAllocationOrderDoesNotOverFillWithMultipleSizesAndWeights() {
 
   @Test
   public void testAllocationOrderContainsSingleSizeIfSingleSizeIsProvided() {
-    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(new PreFillType[] {
-        new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
-            .setConfig(defaultBitmapConfig).build() });
+    PreFillQueue allocationOrder =
+        bitmapPreFiller.generateAllocationOrder(
+            new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
+                .setConfig(defaultBitmapConfig)
+                .build());
 
     while (!allocationOrder.isEmpty()) {
       PreFillType size = allocationOrder.remove();
@@ -165,7 +166,7 @@ public void testAllocationOrderSplitsEvenlyBetweenEqualSizesWithEqualWeights() {
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
             .setConfig(defaultBitmapConfig).build();
     PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+        bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
     int numSmallWidth = 0, numSmallHeight = 0;
     while (!allocationOrder.isEmpty()) {
@@ -189,8 +190,7 @@ public void testAllocationOrderSplitsByteSizeEvenlyBetweenUnEqualSizesWithEqualW
             .setConfig(defaultBitmapConfig).build();
     PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT)
         .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, normal });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, normal);
 
     int numSmallWidth = 0, numNormal = 0;
     while (!allocationOrder.isEmpty()) {
@@ -214,8 +214,7 @@ public void testAllocationOrderSplitsByteSizeUnevenlyBetweenEqualSizesWithUnequa
             .setConfig(defaultBitmapConfig).setWeight(2).build();
     PreFillType normal = new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
         .setConfig(defaultBitmapConfig).build();
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { doubleWeight, normal });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(doubleWeight, normal);
 
     int numDoubleWeight = 0, numNormal = 0;
     while (!allocationOrder.isEmpty()) {
@@ -243,8 +242,7 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
         new PreFillType.Builder(DEFAULT_BITMAP_WIDTH, DEFAULT_BITMAP_HEIGHT / 2)
             .setConfig(defaultBitmapConfig).build();
 
-    PreFillQueue allocationOrder =
-        bitmapPreFiller.generateAllocationOrder(new PreFillType[] { smallWidth, smallHeight, });
+    PreFillQueue allocationOrder = bitmapPreFiller.generateAllocationOrder(smallWidth, smallHeight);
 
     List<PreFillType> attributes = new ArrayList<>();
     while (!allocationOrder.isEmpty()) {
@@ -262,6 +260,7 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
   }
 
   @Test
+  @SuppressWarnings("deprecation")
   public void testSetsConfigOnBuildersToDefaultIfNotSet() {
     PreFillType.Builder builder = mock(PreFillType.Builder.class);
     when(builder.build())
@@ -271,6 +270,7 @@ public void testSetsConfigOnBuildersToDefaultIfNotSet() {
 
     InOrder order = inOrder(builder);
     order.verify(builder).setConfig(DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
+        || DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
         ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
     order.verify(builder).build();
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
index 26f2469a3..bd14089f4 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
@@ -2,10 +2,8 @@
 
 import static org.junit.Assert.assertEquals;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
diff --git a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
index 4df23384d..d1670029e 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
@@ -8,10 +8,9 @@
 
 import android.content.res.AssetManager;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import com.bumptech.glide.util.Preconditions;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -26,8 +25,8 @@
 public class AssetUriLoaderTest {
   private static final int IMAGE_SIDE = 10;
 
-  @Mock AssetUriLoader.AssetFetcherFactory<Object> factory;
-  @Mock DataFetcher<Object> fetcher;
+  @Mock private AssetUriLoader.AssetFetcherFactory<Object> factory;
+  @Mock private DataFetcher<Object> fetcher;
   private AssetUriLoader<Object> loader;
 
   @Before
@@ -41,7 +40,9 @@ public void testHandlesAssetUris() {
     Uri assetUri = Uri.parse("file:///android_asset/assetName");
     when(factory.buildFetcher(any(AssetManager.class), eq("assetName"))).thenReturn(fetcher);
     assertTrue(loader.handles(assetUri));
-    assertEquals(fetcher, loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE,
-        new Options()).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE, new Options())).fetcher);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
similarity index 65%
rename from library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
index 580bc669d..80eb81666 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
@@ -9,7 +9,8 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import com.bumptech.glide.util.Preconditions;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -17,13 +18,11 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import java.io.IOException;
-
 @RunWith(JUnit4.class)
 public class ByteArrayLoaderTest {
 
-  @Mock ByteArrayLoader.Converter<Object> converter;
-  @Mock DataFetcher.DataCallback<Object> callback;
+  @Mock private ByteArrayLoader.Converter<Object> converter;
+  @Mock private DataFetcher.DataCallback<Object> callback;
   private ByteArrayLoader<Object> loader;
   private Options options;
 
@@ -37,24 +36,28 @@ public void setUp() {
   @Test
   public void testCanHandleByteArray() {
     byte[] data = new byte[10];
-    DataFetcher<Object> fetcher = loader.buildLoadData(data, -1, -1, options).fetcher;
+    DataFetcher<Object> fetcher =
+        Preconditions.checkNotNull(loader.buildLoadData(data, -1, -1, options)).fetcher;
     assertNotNull(fetcher);
   }
 
   @Test
   public void testFetcherReturnsObjectReceivedFromConverter() throws IOException {
-    byte[] data = "fake".getBytes();
+    byte[] data = "fake".getBytes("UTF-8");
     Object expected = new Object();
     when(converter.convert(eq(data))).thenReturn(expected);
 
-    loader.buildLoadData(data, 10, 10, options).fetcher.loadData(Priority.HIGH, callback);
+    Preconditions.checkNotNull(loader.buildLoadData(data, 10, 10, options)).fetcher
+        .loadData(Priority.HIGH, callback);
     verify(callback).onDataReady(eq(expected));
   }
 
   @Test
-  public void testFetcherRetrunsDataClassFromConverter() {
+  public void testFetcherReturnsDataClassFromConverter() {
     when(converter.getDataClass()).thenReturn(Object.class);
-    assertEquals(Object.class,
-        loader.buildLoadData(new byte[10], 10, 10, options).fetcher.getDataClass());
+    assertEquals(
+        Object.class,
+        Preconditions.checkNotNull(loader.buildLoadData(new byte[10], 10, 10, options)).fetcher
+            .getDataClass());
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
new file mode 100644
index 000000000..440516b26
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -0,0 +1,135 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Base64;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/**
+ * Tests for the {@link DataUrlLoader} class.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DataUrlLoaderTest {
+
+  // A valid base64-encoded PNG (a small "Google" logo).
+  @SuppressWarnings("SpellCheckingInspection")
+  private static final String VALID_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAALCA"
+      + "YAAAAeEY8BAAADFElEQVR42mNgAAK5ig+CiiUfSmUL3mVL5r7PE8t5M1U06027eMYLMQZKQUMDE8eyxGrOJYmdDKtC"
+      + "mTHkFfO/iCsUfTykUPFeASH6n1Es+3WjSM5rKQYqANbFcTmsC2OXYpWUKXw/R67ofQEhQ+5FecnfDnYxPJNmzAp35n"
+      + "8Gxv/7pTT+75PQBrFh4iq5b/lk8z+aiue+tZDKeaPBMC8qh2leFNgB/xkYGO+Eu+ncCnZRAiuWyHv3VDzngxMui0EW"
+      + "Pgpx6n4U4Wx7J8De86aP2blrrgaq//fwCv8/KNT//5CU0f99okn/dwse+b9fQECx9IObQvGHMrn8D66See9eiWa9s2"
+      + "GYE57DMCdi6Qs3N+6HIc4T70a4mtz2t55909u0jkE85+1Tsdx30ciWSuQ+F+VPe6kskPFc4Z6XRcp9H8t2mNxVF72G"
+      + "q066K//vZe//v4cDru//ds7V/7dx1MoXf9gtW/zRFGLO+x7x7DeVDDOBDpgZvvSut3nWXR/LyptuxgG33Axzr7rr2T"
+      + "KIZb1eIpL1ejco3mGGCWe8cRJMf7FVKO1F/y1Xww4gng6Tu+Ko7X7JTvPo/52Mm//vYMqBO2AbU/H/LUwzpQreT5LO"
+      + "f98PEhPLftslkfvGjGF6aA4QL73halh7y9XgwHVnM2G4b0G+FM549Uw440U7Q+h/eCoVSH0+GYjrrjrr2V530n16w1"
+      + "qdFyR+wUYr6YKNRtH/7QzpQHzsfwMDE9gBmxl6/29hcNdu+M8G9HmCWM7bQ6I5bxPBhk0NzmGYErT0mpOe0TVHnY+X"
+      + "HXRMQMKrQhkg9omkvZYUSHvZJ5T+Yh3IUoHUZ/mCqc87BdOe2UB9HXzZQWvCeTuNqPO2GgmghAROgFsZ8oCWtgBxDN"
+      + "ABASC1olmveEQyX/sB8SKRzJcPgbQxw0S/IoaJvksZJvsqXnLQDLhoq7n7nI3GxHOWWs4M1AQ8ic9FhdNf7ZRKeyYC"
+      + "jsrUly7AqDzOQC8glP7SFWjhCVhUKiTc5xBIebaAbg4AWcyf+qxNMPXZKoGU57UCqU+KQKGCTwsAbxBBmvLaD+cAAA"
+      + "AASUVORK5CYII=";
+
+  private static final String INVALID_URL_WRONG_SCHEME1 = "test";
+  private static final String INVALID_URL_WRONG_SCHEME2 = "http://google.com";
+  private static final String INVALID_URL_WRONG_SCHEME3 = "data:text";
+  private static final String INVALID_URL_MISSING_COMMA = "data:image/png;base64=NOT_BASE64";
+  private static final String INVALID_URL_WRONG_ENCODING = "data:image/png;base32,";
+
+  @Mock
+  private MultiModelLoaderFactory multiFactory;
+  private DataUrlLoader<String, InputStream> dataUrlLoader;
+  private DataFetcher<InputStream> fetcher;
+  private Options options;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    DataUrlLoader.StreamFactory<String> factory = new DataUrlLoader.StreamFactory<>();
+    options = new Options();
+    dataUrlLoader = (DataUrlLoader<String, InputStream>) factory.build(multiFactory);
+    fetcher = dataUrlLoader.buildLoadData(VALID_PNG, -1, -1, options).fetcher;
+  }
+
+  @Test
+  public void testHandleDataUri() {
+    assertTrue(dataUrlLoader.handles(VALID_PNG));
+  }
+
+  @Test
+  public void testHandleFalseDataUri() {
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME1));
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME2));
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME3));
+  }
+
+  @Test
+  public void testDecode() throws IOException {
+    byte[] expected = Base64
+        .decode(VALID_PNG.substring(VALID_PNG.indexOf(',') + 1), Base64.DEFAULT);
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    byte[] result = new byte[((ByteArrayInputStream) callback.data).available()];
+    assertEquals(result.length, ((ByteArrayInputStream) callback.data).read(result));
+    assertTrue(Arrays.equals(result, expected));
+    assertNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeInvalidScheme() {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_SCHEME1, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeMissingComma() {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_MISSING_COMMA, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeWrongEncoding() {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_ENCODING, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  private static final class CallBack implements DataFetcher.DataCallback<Object> {
+
+    public Object data;
+    public Exception exception;
+
+    @Override
+    public void onDataReady(@Nullable Object data) {
+      this.data = data;
+    }
+
+    @Override
+    public void onLoadFailed(@NonNull Exception e) {
+      this.exception = e;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
index 7593eaccb..6bc1ddd29 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
@@ -1,18 +1,17 @@
 package com.bumptech.glide.load.model;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 
 import com.google.common.testing.EqualsTester;
-
+import java.net.MalformedURLException;
+import java.net.URL;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.net.MalformedURLException;
-import java.net.URL;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GlideUrlTest {
@@ -89,6 +88,16 @@ public void testIssue133() throws MalformedURLException {
     assertEquals(escaped, glideUrlFromEscapedUrl.toURL().toString());
   }
 
+  @Test
+  public void issue_2583() throws MalformedURLException {
+    String original =
+        "http://api.met.no/weatherapi/weathericon/1.1/?symbol=9;content_type=image/png";
+
+    GlideUrl glideUrl = new GlideUrl(original);
+    assertThat(glideUrl.toURL().toString()).isEqualTo(original);
+    assertThat(glideUrl.toStringUrl()).isEqualTo(original);
+  }
+
   @Test
   public void testEquals() throws MalformedURLException {
     Headers headers = mock(Headers.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
similarity index 73%
rename from library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
index 8e0269c4e..b0e2d1402 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -4,20 +4,73 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import com.google.common.testing.EqualsTester;
-
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.model.LazyHeaders.Builder;
-
+import com.google.common.testing.EqualsTester;
+import java.util.Map;
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.Map;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LazyHeadersTest {
+  private static final String DEFAULT_USER_AGENT = "default_user_agent";
+  private static final String DEFAULT_USER_AGENT_PROPERTY = "http.agent";
+  private String initialUserAgent;
+
+  @Before
+  public void setUp() {
+    initialUserAgent = System.getProperty(DEFAULT_USER_AGENT_PROPERTY);
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, DEFAULT_USER_AGENT);
+  }
+
+  @After
+  public void tearDown() {
+    if (initialUserAgent != null) {
+      System.setProperty(DEFAULT_USER_AGENT_PROPERTY, initialUserAgent);
+    }
+  }
+
+  // Tests for #2331.
+  @Test
+  public void getSanitizedUserAgent_withInvalidAgent_returnsAgentWithInvalidCharactersRemoved() {
+    String invalidUserAgent =
+        "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G八核版(A8H8) Build/LRX21M)";
+    String validUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G???(A8H8) Build/LRX21M)";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, invalidUserAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(validUserAgent);
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withValidAgent_returnsUnmodifiedAgent() {
+    String validUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G(A8H8) Build/LRX21M)";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, validUserAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(validUserAgent);
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withMissingAgent_returnsNull() {
+    System.clearProperty(DEFAULT_USER_AGENT_PROPERTY);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isNull();
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withEmptyStringAgent_returnsEmptyString() {
+    String userAgent = "";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, userAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(userAgent);
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withWhitespace_returnsWhitespaceString() {
+    String userAgent = "  \t";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, userAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(userAgent);
+  }
 
   @Test
   public void testIncludesEagerHeaders() {
@@ -211,6 +264,55 @@ public void testRemovingAndAddingUserAgentHeaderReplacesDefaultThenAppends() {
     assertThat(headers.getHeaders()).containsEntry("User-Agent", "false,true");
   }
 
+  @Test
+  public void testKeyNotIncludedWithFactoryThatReturnsNullValue() {
+    Builder builder = new Builder();
+    builder.setHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return null;
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("test");
+  }
+
+  @Test
+  public void testKeyNotIncludedWithFactoryThatReturnsEmptyValue() {
+    Builder builder = new Builder();
+    builder.setHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return "";
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("test");
+  }
+
+  @Test
+  public void testKeyIncludedWithOneFactoryThatReturnsNullAndOneFactoryThatDoesNotReturnNull() {
+    Builder builder = new Builder();
+    builder.addHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return null;
+      }
+    });
+    builder.addHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return "value";
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("test", "value");
+  }
+
   @Test
   public void testEquals() {
     LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
index 0d323dfbb..041f67992 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
@@ -3,7 +3,6 @@
 import static org.junit.Assert.assertEquals;
 
 import com.google.common.testing.EqualsTester;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
index 3664fcce2..f80441cfb 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -1,18 +1,17 @@
 package com.bumptech.glide.load.model;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
+import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
-
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -22,36 +21,33 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.List;
-
+// containsExactly produces a spurious warning.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class MultiModelLoaderFactoryTest {
+  @Rule public final ExpectedException exception = ExpectedException.none();
 
-  @Mock ModelLoaderFactory<String, String> firstFactory;
-  @Mock ModelLoader<String, String> firstModelLoader;
-  @Mock MultiModelLoaderFactory.Factory multiModelLoaderFactory;
-  @Mock ModelLoaderFactory<String, String> secondFactory;
-  @Mock ModelLoader<String, String> secondModelLoader;
+  @Mock private ModelLoaderFactory<String, String> firstFactory;
+  @Mock private ModelLoader<String, String> firstModelLoader;
+  @Mock private MultiModelLoaderFactory.Factory multiModelLoaderFactory;
+  @Mock private ModelLoaderFactory<String, String> secondFactory;
+  @Mock private ModelLoader<String, String> secondModelLoader;
 
-  @Rule public ExpectedException exception = ExpectedException.none();
-
-  private Pool<List<Exception>> exceptionListPool;
+  private Pool<List<Throwable>> throwableListPool;
   private MultiModelLoaderFactory multiFactory;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    exceptionListPool = FactoryPools.threadSafeList();
+    throwableListPool = FactoryPools.threadSafeList();
 
-    multiFactory = new MultiModelLoaderFactory(RuntimeEnvironment.application, exceptionListPool,
-            multiModelLoaderFactory);
-    when(firstFactory.build(anyContext(), eq(multiFactory))).thenReturn(firstModelLoader);
-    when(secondFactory.build(anyContext(), eq(multiFactory))).thenReturn(secondModelLoader);
+    multiFactory =
+        new MultiModelLoaderFactory(throwableListPool, multiModelLoaderFactory);
+    when(firstFactory.build(eq(multiFactory))).thenReturn(firstModelLoader);
+    when(secondFactory.build(eq(multiFactory))).thenReturn(secondModelLoader);
   }
 
   @Test
@@ -102,15 +98,14 @@ public void testReplace_addsModelLoaderForModelAndDataClasses() {
     assertThat(modelLoader).isEqualTo(firstModelLoader);
   }
 
-  @SuppressWarnings("unchecked")
   @Test
   public void testReplace_returnsPreviouslyRegisteredFactories_withModelAndDataClasses() {
-    ModelLoaderFactory<String, String> firstOtherFactory = mock(ModelLoaderFactory.class);
-    ModelLoaderFactory<String, String> secondOtherFactory = mock(ModelLoaderFactory.class);
+    ModelLoaderFactory<String, String> firstOtherFactory = mockFactory();
+    ModelLoaderFactory<String, String> secondOtherFactory = mockFactory();
     multiFactory.append(String.class, String.class, firstOtherFactory);
     multiFactory.append(String.class, String.class, secondOtherFactory);
 
-    List<ModelLoaderFactory<String, String>> removed =
+    List<ModelLoaderFactory<? extends String, ? extends String>> removed =
         multiFactory.replace(String.class, String.class, firstFactory);
     assertThat(removed).containsExactly(firstOtherFactory, secondOtherFactory);
   }
@@ -126,14 +121,13 @@ public void testReplace_removesPreviouslyRegisteredFactories_withModelAndDataCla
     assertThat(modelLoaders).containsExactly(firstModelLoader);
   }
 
-  @SuppressWarnings("unchecked")
   @Test
   public void testRemove_returnsPreviouslyRegisteredFactories_withModelAndDataClasses() {
-    ModelLoaderFactory<String, String> other = mock(ModelLoaderFactory.class);
+    ModelLoaderFactory<String, String> other = mockFactory();
     multiFactory.append(String.class, String.class, other);
     multiFactory.append(String.class, String.class, firstFactory);
 
-    List<ModelLoaderFactory<String, String>> removed =
+    List<ModelLoaderFactory<? extends String, ? extends String>> removed =
         multiFactory.remove(String.class, String.class);
     assertThat(removed).containsExactly(firstFactory, other);
   }
@@ -271,18 +265,15 @@ public void testBuild_respectsPrependOrder() {
     assertThat(modelLoaders).containsExactly(third, second, first).inOrder();
   }
 
-  @SuppressWarnings("unchecked")
   private <X, Y> List<ModelLoader<X, Y>> buildModelLoaders(Class<X> modelClass,
       Class<Y> dataClass) {
-    ArgumentCaptor<List> captor = ArgumentCaptor.forClass(List.class);
+    ArgumentCaptor<List<ModelLoader<X, Y>>> captor = Util.cast(ArgumentCaptor.forClass(List.class));
     multiFactory.build(modelClass, dataClass);
-    verify(multiModelLoaderFactory).build(captor.capture(), eq(exceptionListPool));
+    verify(multiModelLoaderFactory).build(captor.capture(), eq(throwableListPool));
 
-    List<ModelLoader> captured = captor.getValue();
+    List<ModelLoader<X, Y>> captured = captor.getValue();
     List<ModelLoader<X, Y>> result = new ArrayList<>(captured.size());
-    for (ModelLoader modelLoader : captured) {
-      result.add(modelLoader);
-    }
+    result.addAll(captured);
     return result;
   }
 
@@ -294,12 +285,11 @@ public void testBuild_respectsPrependOrder() {
     return registerFactoryFor(modelClass, dataClass, false /*append*/);
   }
 
-  @SuppressWarnings("unchecked")
-  private <X, Y> ModelLoader<X, Y> registerFactoryFor(Class<X> modelClass, Class<Y> dataClass,
-      boolean append) {
-    ModelLoaderFactory<X, Y> factory = mock(ModelLoaderFactory.class);
-    ModelLoader<X, Y> loader = mock(ModelLoader.class);
-    when(factory.build(anyContext(), eq(multiFactory))).thenReturn(loader);
+  private <X, Y> ModelLoader<X, Y> registerFactoryFor(
+      Class<X> modelClass, Class<Y> dataClass, boolean append) {
+    ModelLoaderFactory<X, Y> factory = mockFactory();
+    @SuppressWarnings("unchecked") ModelLoader<X, Y> loader = mock(ModelLoader.class);
+    when(factory.build(eq(multiFactory))).thenReturn(loader);
     if (append) {
       multiFactory.append(modelClass, dataClass, factory);
     } else {
@@ -308,8 +298,9 @@ public void testBuild_respectsPrependOrder() {
     return loader;
   }
 
-  private static Context anyContext() {
-    return any(Context.class);
+  @SuppressWarnings("unchecked")
+  private static <X, Y> ModelLoaderFactory<X, Y> mockFactory() {
+    return mock(ModelLoaderFactory.class);
   }
 }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
index 492e029dc..ec2c1831e 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -11,11 +11,10 @@
 import static org.mockito.Mockito.when;
 
 import android.net.Uri;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import com.bumptech.glide.util.Preconditions;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -32,9 +31,9 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class ResourceLoaderTest {
 
-  @Mock ModelLoader<Uri, Object> uriLoader;
-  @Mock DataFetcher<Object> fetcher;
-  @Mock Key key;
+  @Mock private ModelLoader<Uri, Object> uriLoader;
+  @Mock private DataFetcher<Object> fetcher;
+  @Mock private Key key;
   private Options options;
 
   private ResourceLoader<Object> loader;
@@ -44,7 +43,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     options = new Options();
 
-    loader = new ResourceLoader<>(RuntimeEnvironment.application, uriLoader);
+    loader = new ResourceLoader<>(RuntimeEnvironment.application.getResources(), uriLoader);
   }
 
   @Test
@@ -55,7 +54,9 @@ public void testCanHandleId() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(id));
-    assertEquals(fetcher, loader.buildLoadData(id, 100, 100, new Options()).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(loader.buildLoadData(id, 100, 100, new Options())).fetcher);
   }
 
     @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
similarity index 73%
rename from library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
index 184012b38..07dd655dc 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
@@ -3,9 +3,11 @@
 import static org.junit.Assert.assertEquals;
 
 import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -14,10 +16,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamEncoderTest {
@@ -26,23 +24,27 @@
 
   @Before
   public void setUp() {
-    encoder = new StreamEncoder(new LruByteArrayPool());
+    encoder = new StreamEncoder(new LruArrayPool());
     file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
   }
 
   @After
   public void tearDown() {
-    file.delete();
+    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+    System.gc();
+    if (!file.delete()) {
+      throw new IllegalStateException("Failed to delete: " + file);
+    }
   }
 
   @Test
   public void testWritesDataFromInputStreamToOutputStream() throws IOException {
     String fakeData = "SomeRandomFakeData";
-    ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes());
+    ByteArrayInputStream is = new ByteArrayInputStream(fakeData.getBytes("UTF-8"));
     encoder.encode(is, file, new Options());
 
     byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
 
-    assertEquals(fakeData, new String(data));
+    assertEquals(fakeData, new String(data, "UTF-8"));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
similarity index 72%
rename from library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
index d8cd64909..b6554eabf 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
@@ -9,12 +9,12 @@
 import static org.mockito.Mockito.when;
 
 import android.net.Uri;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.tests.Util;
-
+import com.bumptech.glide.util.Preconditions;
+import java.io.File;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,9 +24,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-
 /**
  * Tests for the {@link com.bumptech.glide.load.model.StringLoader} class.
  */
@@ -36,15 +33,15 @@
   // Not a magic number, just an arbitrary non zero value.
   private static final int IMAGE_SIDE = 100;
 
-  @Mock ModelLoader<Uri, Object> uriLoader;
-  @Mock DataFetcher<Object> fetcher;
-  @Mock Key key;
+  @Mock private ModelLoader<Uri, Object> uriLoader;
+  @Mock private DataFetcher<Object> fetcher;
+  @Mock private Key key;
 
   private StringLoader<Object> loader;
   private Options options;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     options = new Options();
@@ -53,9 +50,9 @@ public void setUp() throws Exception {
   }
 
   @Test
-  public void testHandlesPaths() throws IOException {
-    // TODO on windows it will fail with schema being the drive letter (C:\... -> C)
-    assumeTrue(!Util.isWindows());
+  public void testHandlesPaths() {
+    // TODO fix drive letter parsing somehow
+    assumeTrue("it will fail with schema being the drive letter (C:\\... -> C)", !Util.isWindows());
 
     File f = RuntimeEnvironment.application.getCacheDir();
     Uri expected = Uri.fromFile(f);
@@ -63,14 +60,14 @@ public void testHandlesPaths() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(f.getAbsolutePath()));
-    assertEquals(fetcher,
-        loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
   public void testCanHandleComplexFilePaths() {
-    assumeTrue(!Util.isWindows());
-
     String testPath =
         "/storage/emulated/0/DCIM/Camera/IMG_20140520_100001:nopm:.jpg,mimeType=image/jpeg,"
             + "2448x3264,orientation=0,date=Tue";
@@ -79,11 +76,14 @@ public void testCanHandleComplexFilePaths() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(testPath));
-    assertEquals(fetcher, loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(testPath, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
-  public void testHandlesFileUris() throws IOException {
+  public void testHandlesFileUris() {
     File f = RuntimeEnvironment.application.getCacheDir();
 
     Uri expected = Uri.fromFile(f);
@@ -91,20 +91,24 @@ public void testHandlesFileUris() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(f.getAbsolutePath()));
-    assertEquals(fetcher,
-        loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(expected.toString(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
-  public void testHandlesResourceUris() throws IOException {
+  public void testHandlesResourceUris() {
     Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
 
     when(uriLoader.buildLoadData(eq(resourceUri), eq(IMAGE_SIDE), eq(IMAGE_SIDE), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(resourceUri.toString()));
-    assertEquals(fetcher,
-        loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -116,7 +120,10 @@ public void testHandlesHttp() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(url));
-    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -128,7 +135,10 @@ public void testHandlesHttps() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(url));
-    assertEquals(fetcher, loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(url, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
@@ -140,7 +150,10 @@ public void testHandlesContent() {
         .thenReturn(new ModelLoader.LoadData<>(key, fetcher));
 
     assertTrue(loader.handles(content));
-    assertEquals(fetcher, loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(content, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
similarity index 62%
rename from library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
index 47fcd5457..b7a4f3859 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -2,28 +2,23 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import com.bumptech.glide.util.Preconditions;
+import java.io.File;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-
 /**
  * Tests for the {@link UriLoader} class.
  */
@@ -33,8 +28,8 @@
   // Not a magic number, just arbitrary non zero.
   private static final int IMAGE_SIDE = 120;
 
-  @Mock DataFetcher<Object> localUriFetcher;
-  @Mock UriLoader.LocalUriFetcherFactory<Object> factory;
+  @Mock private DataFetcher<Object> localUriFetcher;
+  @Mock private UriLoader.LocalUriFetcherFactory<Object> factory;
   private UriLoader<Object> loader;
   private Options options;
 
@@ -43,40 +38,42 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
 
     options = new Options();
-    loader = new UriLoader<>(RuntimeEnvironment.application, factory);
+    loader = new UriLoader<>(factory);
   }
 
   @Test
   public void testHandlesFileUris() throws IOException {
     Uri fileUri = Uri.fromFile(new File("f"));
-    when(factory.build(anyContext(), eq(fileUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(fileUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(fileUri));
-    assertEquals(localUriFetcher,
-        loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(fileUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
   public void testHandlesResourceUris() throws IOException {
     Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-    when(factory.build(anyContext(), eq(resourceUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(resourceUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(resourceUri));
-    assertEquals(localUriFetcher,
-        loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options).fetcher);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(resourceUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 
   @Test
   public void testHandlesContentUris() {
     Uri contentUri = Uri.parse("content://com.bumptech.glide");
-    when(factory.build(anyContext(), eq(contentUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(contentUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(contentUri));
-    assertEquals(localUriFetcher, loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE,
-        options).fetcher);
-  }
-
-  private static Context anyContext() {
-    return any(Context.class);
+    assertEquals(
+        localUriFetcher,
+        Preconditions.checkNotNull(
+            loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE, options)).fetcher);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
similarity index 78%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
index 16d54a573..e635b01a2 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
@@ -9,13 +9,15 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
-
+import com.bumptech.glide.util.Preconditions;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -26,15 +28,13 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BaseGlideUrlLoaderTest {
 
-  @Mock ModelCache<Object, GlideUrl> modelCache;
-  @Mock ModelLoader<GlideUrl, InputStream> wrapped;
-  @Mock DataFetcher<InputStream> fetcher;
+  @Mock private ModelCache<Object, GlideUrl> modelCache;
+  @Mock private ModelLoader<GlideUrl, InputStream> wrapped;
+  @Mock private DataFetcher<InputStream> fetcher;
   private TestLoader urlLoader;
   private Options options;
 
@@ -70,7 +70,9 @@ public void testReturnsUrlFromCacheIfPresent() {
     when(wrapped.buildLoadData(eq(expectedUrl), eq(width), eq(height), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
 
-    assertEquals(fetcher, urlLoader.buildLoadData(model, width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(urlLoader.buildLoadData(model, width, height, options)).fetcher);
   }
 
   @Test
@@ -82,16 +84,18 @@ public void testBuildsNewUrlIfNotPresentInCache() {
     when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
         .thenAnswer(new Answer<ModelLoader.LoadData<InputStream>>() {
           @Override
-          public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock)
-              throws Throwable {
+          public ModelLoader.LoadData<InputStream> answer(InvocationOnMock invocationOnMock) {
             GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[0];
             assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
             return new ModelLoader.LoadData<>(mock(Key.class), fetcher);
 
           }
         });
-    assertEquals(fetcher,
-        urlLoader.buildLoadData(new GlideUrl(urlLoader.resultUrl), width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            urlLoader.buildLoadData(
+                new GlideUrl(urlLoader.resultUrl), width, height, options)).fetcher);
   }
 
   @Test
@@ -101,9 +105,9 @@ public void testAddsNewUrlToCacheIfNotPresentInCache() {
     int width = 400;
     int height = 500;
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) {
         GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
         assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
         return null;
@@ -126,13 +130,16 @@ public void testDoesNotInteractWithModelCacheIfNull() {
     when(wrapped.buildLoadData(any(GlideUrl.class), eq(width), eq(height), eq(options)))
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), fetcher));
 
-    assertEquals(fetcher, urlLoader.buildLoadData(new Object(), width, height, options).fetcher);
+    assertEquals(
+        fetcher,
+        Preconditions.checkNotNull(
+            urlLoader.buildLoadData(new Object(), width, height, options)).fetcher);
   }
 
-  private class TestLoader extends BaseGlideUrlLoader<Object> {
-    public String resultUrl;
+  private static final class TestLoader extends BaseGlideUrlLoader<Object> {
+    String resultUrl;
 
-    public TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
+    TestLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
         ModelCache<Object, GlideUrl> modelCache) {
       super(concreteLoader, modelCache);
     }
@@ -143,7 +150,7 @@ protected String getUrl(Object model, int width, int height, Options options) {
     }
 
     @Override
-    public boolean handles(Object model) {
+    public boolean handles(@NonNull Object model) {
       return true;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
similarity index 70%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
index 35dc69180..e46c95fcd 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
@@ -7,15 +7,16 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
-
+import com.bumptech.glide.util.Preconditions;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.InputStream;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
-@RunWith(JUnit4.class)
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
 public class HttpGlideUrlLoaderTest {
   private HttpGlideUrlLoader loader;
   private GlideUrl model;
@@ -29,7 +30,8 @@ public void setUp() {
 
   @Test
   public void testReturnsValidFetcher() {
-    DataFetcher<InputStream> result = loader.buildLoadData(model, 100, 100, new Options()).fetcher;
+    DataFetcher<InputStream> result =
+        Preconditions.checkNotNull(loader.buildLoadData(model, 100, 100, new Options())).fetcher;
     assertThat(result).isInstanceOf(HttpUrlFetcher.class);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
similarity index 97%
rename from library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
index 369696786..5abc0b23d 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
@@ -5,11 +5,11 @@
 import static org.mockito.Mockito.verify;
 
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
-
+import java.io.InputStream;
+import java.net.MalformedURLException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -18,16 +18,13 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.InputStream;
-import java.net.MalformedURLException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class HttpUriLoaderTest {
   private static final int IMAGE_SIDE = 100;
   private static final Options OPTIONS = new Options();
 
-  @Mock ModelLoader<GlideUrl, InputStream> urlLoader;
+  @Mock private ModelLoader<GlideUrl, InputStream> urlLoader;
   private HttpUriLoader loader;
 
   @Before
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
index a20a7b2db..78b851f22 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
@@ -10,12 +10,12 @@
 @RunWith(JUnit4.class)
 public class SimpleResourceTest {
   private Anything object;
-  private SimpleResource resource;
+  private SimpleResource<?> resource;
 
   @Before
   public void setUp() {
     object = new Anything();
-    resource = new SimpleResource(object);
+    resource = new SimpleResource<>(object);
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
new file mode 100644
index 000000000..087c606d3
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide.load.resource;
+
+import static com.bumptech.glide.tests.Util.mockResource;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+
+import android.app.Application;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.robolectric.RuntimeEnvironment;
+
+@RunWith(JUnit4.class)
+public class UnitTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  private Application app;
+
+  @Before
+  public void setUp() {
+    app = RuntimeEnvironment.application;
+  }
+
+  @Test
+  public void testReturnsGivenResource() {
+    Resource<Object> resource = mockResource();
+    UnitTransformation<Object> transformation = UnitTransformation.get();
+    assertEquals(resource, transformation.transform(app, resource, 10, 10));
+  }
+
+  @Test
+  public void testEqualsHashCodeDigest() throws NoSuchAlgorithmException {
+    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
+    doAnswer(new Util.WriteDigest("other")).when(other)
+        .updateDiskCacheKey(any(MessageDigest.class));
+
+    keyTester
+        .addEquivalenceGroup(
+            UnitTransformation.get(),
+            UnitTransformation.get())
+        .addEquivalenceGroup(other)
+        .addEmptyDigestRegressionTest(UnitTransformation.get())
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
index 15d6e505b..7fdd33f3c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
@@ -8,9 +8,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -56,10 +54,10 @@ public void testBitmapIsReturnedToPoolOnRecycle() {
   }
 
   private static class BitmapDrawableResourceHarness {
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final BitmapPool bitmapPool = mock(BitmapPool.class);
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
-    public BitmapDrawableResource create() {
+    BitmapDrawableResource create() {
       return new BitmapDrawableResource(
           new BitmapDrawable(RuntimeEnvironment.application.getResources(), bitmap), bitmapPool);
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
similarity index 54%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
index 78ba2efc9..2daa5979b 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.bumptech.glide.tests.Util.anyContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
@@ -9,16 +10,21 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
@@ -30,46 +36,53 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("deprecation")
 public class BitmapDrawableTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock BitmapPool bitmapPool;
-  @Mock Transformation<Bitmap> wrapped;
-  @Mock Resource<BitmapDrawable> drawableResourceToTransform;
-  @Mock BitmapDrawable drawableToTransform;
+  @Mock private BitmapPool bitmapPool;
+  @Mock private Transformation<Bitmap> wrapped;
+  @Mock private Resource<BitmapDrawable> drawableResourceToTransform;
 
   private BitmapDrawableTransformation transformation;
   private Bitmap bitmapToTransform;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawableToTransform = new BitmapDrawable(bitmapToTransform);
 
+    context = RuntimeEnvironment.application;
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
     when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);
-    when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);
-    transformation = new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool,
-        wrapped);
+    transformation = new BitmapDrawableTransformation(wrapped);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsOriginalResourceIfTransformationDoesNotTransform() {
     int outWidth = 123;
     int outHeight = 456;
-    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight)))
-        .thenAnswer(new Answer<Object>() {
+    when(wrapped.transform(
+        anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
+        .thenAnswer(new Answer<Resource<Bitmap>>() {
+          @SuppressWarnings("unchecked")
           @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            return invocation.getArguments()[0];
+          public Resource<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
+            return (Resource<Bitmap>) invocation.getArguments()[1];
           }
         });
 
-    Resource<BitmapDrawable> transformed = transformation.transform(drawableResourceToTransform,
-        outWidth, outHeight);
+    Resource<BitmapDrawable> transformed =
+        transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
 
     assertThat(transformed).isEqualTo(drawableResourceToTransform);
   }
@@ -80,13 +93,13 @@ public void testReturnsNewResourceIfTransformationDoesTransform() {
     int outHeight = 555;
 
     Bitmap transformedBitmap = Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.RGB_565);
-    Resource<Bitmap> transformedBitmapResource = mock(Resource.class);
+    Resource<Bitmap> transformedBitmapResource = Util.mockResource();
     when(transformedBitmapResource.get()).thenReturn(transformedBitmap);
-    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight)))
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
         .thenReturn(transformedBitmapResource);
 
     Resource<BitmapDrawable> transformed =
-        transformation.transform(drawableResourceToTransform, outWidth, outHeight);
+        transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
 
     assertThat(transformed.get().getBitmap()).isEqualTo(transformedBitmap);
   }
@@ -95,16 +108,16 @@ public void testReturnsNewResourceIfTransformationDoesTransform() {
   public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
     int outWidth = 332;
     int outHeight = 111;
-    Resource<Bitmap> transformed = mock(Resource.class);
+    Resource<Bitmap> transformed = Util.mockResource();
     when(transformed.get())
         .thenReturn(Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.ARGB_8888));
-    when(wrapped.transform(any(Resource.class), anyInt(), anyInt()))
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), anyInt(), anyInt()))
         .thenReturn(transformed);
 
-    transformation.transform(drawableResourceToTransform, outWidth, outHeight);
-    ArgumentCaptor<Resource> captor = ArgumentCaptor.forClass(Resource.class);
+    transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
+    ArgumentCaptor<Resource<Bitmap>> captor = Util.cast(ArgumentCaptor.forClass(Resource.class));
 
-    verify(wrapped).transform(captor.capture(), eq(outWidth), eq(outHeight));
+    verify(wrapped).transform(anyContext(), captor.capture(), eq(outWidth), eq(outHeight));
 
     assertThat(captor.getValue().get()).isEqualTo(bitmapToTransform);
   }
@@ -113,13 +126,18 @@ public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("wrapped")).when(wrapped)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(transformation,
-        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, wrapped));
-
-    Transformation<Bitmap> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation,
-        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, other));
+
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new BitmapDrawableTransformation(wrapped))
+        .addEquivalenceGroup(new BitmapDrawableTransformation(other))
+        .addEquivalenceGroup(wrapped)
+        .addRegressionTest(
+            transformation, "adbf45b08ad6468aa147e5b2a23758ef56ab631a2b70ad52501ca358441a34f3")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
similarity index 69%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 60e3e3db7..68d4a56c3 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -1,18 +1,20 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import java.io.File;
+import java.io.IOException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -21,16 +23,9 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-import java.io.File;
-import java.io.IOException;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = {
-    BitmapEncoderTest.AlphaShadowBitmap.class })
+@Config(manifest = Config.NONE, sdk = 18)
 public class BitmapEncoderTest {
   private EncoderHarness harness;
 
@@ -93,13 +88,13 @@ public void testEncoderEncodesPngWithNullFormatAndBitmapWithAlpha() throws IOExc
 
   @Test
   public void testReturnsTrueFromWrite() {
-    BitmapEncoder encoder = new BitmapEncoder();
+    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);
     assertTrue(encoder.encode(harness.resource, harness.file, harness.options));
   }
 
   @Test
   public void testEncodeStrategy_alwaysReturnsTransformed() {
-    BitmapEncoder encoder = new BitmapEncoder();
+    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);
     assertEquals(EncodeStrategy.TRANSFORMED, encoder.getEncodeStrategy(harness.options));
   }
 
@@ -107,51 +102,38 @@ private static void assertContains(String string, String expected) {
     assertThat(string).contains(expected);
   }
 
-  @SuppressWarnings("unchecked")
   private static class EncoderHarness {
-    Resource<Bitmap> resource = mock(Resource.class);
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Options options = new Options();
-    File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    final Resource<Bitmap> resource = mockResource();
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final Options options = new Options();
+    final File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    final ArrayPool arrayPool = new LruArrayPool();
 
-    public EncoderHarness() {
+    EncoderHarness() {
       when(resource.get()).thenReturn(bitmap);
     }
 
-    public void setQuality(int quality) {
+    void setQuality(int quality) {
       options.set(BitmapEncoder.COMPRESSION_QUALITY, quality);
     }
 
-    public void setFormat(Bitmap.CompressFormat format) {
+    void setFormat(Bitmap.CompressFormat format) {
       options.set(BitmapEncoder.COMPRESSION_FORMAT, format);
     }
 
-    public String encode() throws IOException {
-      BitmapEncoder encoder = new BitmapEncoder();
+    String encode() throws IOException {
+      BitmapEncoder encoder = new BitmapEncoder(arrayPool);
       encoder.encode(resource, file, options);
       byte[] data = ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file));
-      return new String(data);
-    }
-
-    public void tearDown() {
-      file.delete();
-    }
-  }
-
-  @Implements(Bitmap.class)
-  public static class AlphaShadowBitmap extends ShadowBitmap {
-    private boolean hasAlpha;
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
+      return new String(data, "UTF-8");
     }
 
-    @SuppressWarnings("unused")
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
+    void tearDown() {
+      // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468)
+      System.gc();
+      if (file.exists() && !file.delete()) {
+        throw new IllegalStateException("Failed to delete: " + file);
+      }
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
similarity index 90%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
index b6d8a8b43..60f360b16 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
@@ -7,10 +7,8 @@
 
 import android.graphics.Bitmap;
 import android.os.Build;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -71,8 +69,8 @@ public void testThrowsIfBitmapAndBitmapPoolAreNull() {
   }
 
   private static class BitmapResourceHarness {
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    BitmapPool bitmapPool = mock(BitmapPool.class);
-    BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final BitmapPool bitmapPool = mock(BitmapPool.class);
+    final BitmapResource resource = new BitmapResource(bitmap, bitmapPool);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
similarity index 72%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
index e53f0180a..cb7bd2e99 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -3,43 +3,54 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.target.Target;
-
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapTransformationTest {
 
   @Mock
   private BitmapPool bitmapPool;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceWhenBitmapNotTransformed() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
@@ -49,15 +60,15 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
     };
 
     Resource<Bitmap> resource = mockResource(100, 100);
-    assertEquals(resource, transformation.transform(resource, 1, 1));
+    assertEquals(resource, transformation.transform(context, resource, 1, 1));
   }
 
   @Test
   public void testReturnsNewResourceWhenBitmapTransformed() {
     final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int outWidth,
@@ -67,7 +78,7 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int
     };
 
     Resource<Bitmap> resource = mockResource(1, 2);
-    assertNotSame(resource, transformation.transform(resource, 100, 100));
+    assertNotSame(resource, transformation.transform(context, resource, 100, 100));
   }
 
   @Test
@@ -75,9 +86,9 @@ public void testPassesGivenArgumentsToTransform() {
     final int expectedWidth = 13;
     final int expectedHeight = 148;
     final Resource<Bitmap> resource = mockResource(223, 4123);
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
@@ -90,15 +101,15 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
       }
     };
 
-    transformation.transform(resource, expectedWidth, expectedHeight);
+    transformation.transform(context, resource, expectedWidth, expectedHeight);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidWidth() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
@@ -106,15 +117,15 @@ protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTra
         return null;
       }
     };
-    transformation.transform(mock(Resource.class), -1, 100);
+    transformation.transform(context, mockResource(1, 1), -1, 100);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidHeight() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) { }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTransform,
@@ -123,15 +134,15 @@ protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTra
       }
 
     };
-    transformation.transform(mock(Resource.class), 100, -1);
+    transformation.transform(context, mockResource(1, 1), 100, -1);
   }
 
   @Test
   public void testReturnsNullIfTransformReturnsNull() {
-    BitmapTransformation transform = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transform = new BitmapTransformation() {
 
       @Override
-      public void updateDiskCacheKey(MessageDigest messageDigest) {  }
+      public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {  }
 
       @Override
       protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
@@ -141,7 +152,7 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
     };
 
     Resource<Bitmap> resource = mockResource(100, 100);
-    assertNull(transform.transform(resource, 100, 100));
+    assertNull(transform.transform(context, resource, 100, 100));
   }
 
   @Test
@@ -150,7 +161,7 @@ public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {
 
     int expectedWidth = 200;
     Resource<Bitmap> resource = mockResource(expectedWidth, 300);
-    transform.transform(resource, Target.SIZE_ORIGINAL, 500);
+    transform.transform(context, resource, Target.SIZE_ORIGINAL, 500);
 
     assertEquals(expectedWidth, transform.givenWidth);
   }
@@ -161,27 +172,22 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
 
     int expectedHeight = 500;
     Resource<Bitmap> resource = mockResource(123, expectedHeight);
-    transform.transform(resource, 444, expectedHeight);
+    transform.transform(context, resource, 444, expectedHeight);
 
     assertEquals(expectedHeight, transform.givenHeight);
   }
 
-  @SuppressWarnings("unchecked")
   private Resource<Bitmap> mockResource(int width, int height) {
     Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-    Resource<Bitmap> resource = mock(Resource.class);
+    Resource<Bitmap> resource = Util.mockResource();
     when(resource.get()).thenReturn(bitmap);
     return resource;
   }
 
-  private class SizeTrackingTransform extends BitmapTransformation {
+  private static final class SizeTrackingTransform extends BitmapTransformation {
     int givenWidth;
     int givenHeight;
 
-    public SizeTrackingTransform() {
-      super(bitmapPool);
-    }
-
     @Override
     protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
         int outHeight) {
@@ -191,6 +197,6 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
     }
 
     @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) { }
+    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) { }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
similarity index 73%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index 53359e2f7..d36b44ebd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -11,37 +11,42 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class CenterCropTest {
-  @Mock Resource<Bitmap> resource;
-  @Mock BitmapPool pool;
-  @Mock Transformation<Bitmap> transformation;
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Resource<Bitmap> resource;
+  @Mock private BitmapPool pool;
+  @Mock private Transformation<Bitmap> transformation;
 
   private CenterCrop centerCrop;
   private int bitmapWidth;
   private int bitmapHeight;
   private Bitmap bitmap;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -53,8 +58,15 @@ public void setUp() {
 
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
+    context = RuntimeEnvironment.application;
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
 
-    centerCrop = new CenterCrop(pool);
+    centerCrop = new CenterCrop();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
@@ -62,7 +74,7 @@ public void testDoesNotPutNullBitmapAcquiredFromPool() {
     reset(pool);
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class))).thenReturn(null);
 
-    centerCrop.transform(resource, 100, 100);
+    centerCrop.transform(context, resource, 100, 100);
 
     verify(pool, never()).put(any(Bitmap.class));
   }
@@ -70,21 +82,21 @@ public void testDoesNotPutNullBitmapAcquiredFromPool() {
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-        centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+        centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+    centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testDoesNotRecycleGivenResource() {
-    centerCrop.transform(resource, 50, 50);
+    centerCrop.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
@@ -93,7 +105,7 @@ public void testDoesNotRecycleGivenResource() {
   public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
     Shadows.shadowOf(bitmap).setConfig(null);
 
-    centerCrop.transform(resource, 10, 10);
+    centerCrop.transform(context, resource, 10, 10);
 
     verify(pool).get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888));
     verify(pool, never()).get(anyInt(), anyInt(), (Bitmap.Config) isNull());
@@ -110,7 +122,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsLargerThanTarge
       when(resource.get()).thenReturn(toTransform);
 
       Resource<Bitmap> result =
-          centerCrop.transform(resource, expectedWidth, expectedHeight);
+          centerCrop.transform(context, resource, expectedWidth, expectedHeight);
       Bitmap transformed = result.get();
       assertEquals(expectedWidth, transformed.getWidth());
       assertEquals(expectedHeight, transformed.getHeight());
@@ -128,7 +140,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
       when(resource.get()).thenReturn(toTransform);
 
       Resource<Bitmap> result =
-          centerCrop.transform(resource, expectedWidth, expectedHeight);
+          centerCrop.transform(context, resource, expectedWidth, expectedHeight);
       Bitmap transformed = result.get();
       assertEquals(expectedWidth, transformed.getWidth());
       assertEquals(expectedHeight, transformed.getHeight());
@@ -137,10 +149,16 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerCrop, new CenterCrop(pool));
-
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(centerCrop, transformation);
+    keyTester
+        .addEquivalenceGroup(
+            new CenterCrop(),
+            new CenterCrop())
+        .addEquivalenceGroup(
+            transformation)
+        .addRegressionTest(
+            new CenterCrop(), "68bd5819c42b37efbe7124bb851443a6388ee3e2e9034213da6eaa15381d3457")
+        .test();
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
new file mode 100644
index 000000000..ba0f059f1
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -0,0 +1,136 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowCanvas;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { CenterInsideTest.DrawNothingCanvas.class })
+public class CenterInsideTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Mock private Resource<Bitmap> resource;
+  @Mock private Transformation<Bitmap> transformation;
+  private CenterInside centerInside;
+  private int bitmapWidth;
+  private int bitmapHeight;
+  private Application context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    bitmapWidth = 100;
+    bitmapHeight = 100;
+    Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
+    when(resource.get()).thenReturn(bitmap);
+
+    context = RuntimeEnvironment.application;
+    BitmapPool pool = new BitmapPoolAdapter();
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
+
+    centerInside = new CenterInside();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfMatchesSizeExactly() {
+    Resource<Bitmap> result =
+            centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfSmallerThanTarget() {
+    Resource<Bitmap> result =
+        centerInside.transform(context, resource, 150, 150);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testReturnsNewResourceIfLargerThanTarget() {
+    Resource<Bitmap> result =
+        centerInside.transform(context, resource, 50, 50);
+
+    assertNotEquals(resource, result);
+  }
+
+
+  @Test
+  public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
+    centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testDoesNotRecycleGivenResource() {
+    centerInside.transform(context, resource, 50, 50);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    doAnswer(new Util.WriteDigest("other")).when(transformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
+
+    keyTester
+        .addEquivalenceGroup(
+            new CenterInside(),
+            new CenterInside(),
+            centerInside)
+        .addEquivalenceGroup(transformation)
+        .addRegressionTest(
+            new CenterInside(), "acf83850a2e8e9e809c8bfb999e2aede9e932cb897a15367fac9856b96f3ba33")
+    .test();
+  }
+
+  @Implements(Canvas.class)
+  public static final class DrawNothingCanvas extends ShadowCanvas {
+
+    @Implementation
+    @Override
+    public void drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
similarity index 76%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
index 63bd65c10..d93bc231c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -3,19 +3,24 @@
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.Rect;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
-
+import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -27,6 +32,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
 public class CircleCropTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
   @Mock private BitmapPool bitmapPool;
 
   private CircleCrop circleCrop;
@@ -36,7 +42,14 @@ public void setup() {
     MockitoAnnotations.initMocks(this);
     when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
-    circleCrop = new CircleCrop(RuntimeEnvironment.application);
+    Context context = RuntimeEnvironment.application;
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+    circleCrop = new CircleCrop();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
@@ -77,6 +90,16 @@ public void testTransform_withNarrowRectangle() {
     assertSamePixels(expected, result);
   }
 
+  @Test
+  public void testEquals() {
+    keyTester
+        .addEquivalenceGroup(circleCrop, new CircleCrop())
+        .addEquivalenceGroup(mock(Transformation.class))
+        .addRegressionTest(
+            new CircleCrop(), "1442365bcc658f89310e39844ef4be58f4b16e52c283254e5a458020f56acb90")
+        .test();
+  }
+
   private void assertSamePixels(Bitmap expected, Bitmap actual) {
     assertEquals(expected.getWidth(), actual.getWidth());
     assertEquals(expected.getHeight(), actual.getHeight());
@@ -88,20 +111,18 @@ private void assertSamePixels(Bitmap expected, Bitmap actual) {
     }
   }
 
-  @TargetApi(12)
   private Bitmap createBitmapWithRedCircle(int width, int height) {
-    Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+    int minEdge = Math.min(width, height);
+    float radius = minEdge / 2f;
+
+    Bitmap result = Bitmap.createBitmap(minEdge, minEdge, Bitmap.Config.ARGB_8888);
     result.setHasAlpha(true);
     Canvas canvas = new Canvas(result);
     Paint paint = new Paint();
+    paint.setAntiAlias(true);
     paint.setColor(Color.RED);
 
-    int minEdge = Math.min(width, height);
-    float radius = minEdge / 2f;
-    int left = (width - minEdge) / 2;
-    int top = (height - minEdge) / 2;
-
-    canvas.drawCircle(left + radius, top + radius, radius, paint);
+    canvas.drawCircle(radius, radius, radius, paint);
     return result;
   }
 
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
new file mode 100644
index 000000000..4b39cf880
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
@@ -0,0 +1,403 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.testutil.TestResourceUtil;
+import java.io.ByteArrayInputStream;
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.Util;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DefaultImageHeaderParserTest {
+
+  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
+      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
+          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
+
+  private ArrayPool byteArrayPool;
+
+  @Before
+  public void setUp() {
+    byteArrayPool = new LruArrayPool();
+  }
+
+  @Test
+  public void testCanParsePngType() throws IOException {
+    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
+    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParsePngWithAlpha() throws IOException {
+    for (int i = 3; i <= 6; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParsePngWithoutAlpha() throws IOException {
+    for (int i = 0; i < 3; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParseJpegType() throws IOException {
+    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseGifType() throws IOException {
+    byte[] data = new byte[] { 'G', 'I', 'F' };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
+        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithoutAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
+        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
+    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #286.
+  @Test
+  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
+    byte[] data =
+        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(-1, parser.getOrientation(is, byteArrayPool));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(-1, parser.getOrientation(byteBuffer, byteArrayPool));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownForEmptyData() throws IOException {
+    runTest(new byte[0], new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialReads() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialReadInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialSkips() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialSkipInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  @Test
+  public void testHandlesSometimesZeroSkips() throws IOException {
+    InputStream is = new ByteArrayInputStream(
+        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
+    DefaultImageHeaderParser parser =
+        new DefaultImageHeaderParser();
+    assertEquals(ImageType.PNG, parser.getType(new SometimesZeroSkipInputStream(is)));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        (byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withNonExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE)
+        (byte) 0xE5,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleButLessThanLength_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity());
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleBetweenLengthAndExpected_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity() + 2 + 1);
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  private static ByteBuffer getExifMagicNumber() {
+    ByteBuffer jpegHeaderBytes = ByteBuffer.allocate(2);
+    jpegHeaderBytes.putShort((short) DefaultImageHeaderParser.EXIF_MAGIC_NUMBER);
+    jpegHeaderBytes.position(0);
+    return jpegHeaderBytes;
+  }
+
+  private interface ParserTestCase {
+    void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+        throws IOException;
+    void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+        throws IOException;
+  }
+
+  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
+    InputStream is = new ByteArrayInputStream(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    test.run(parser, is, new LruArrayPool());
+
+    ByteBuffer buffer = ByteBuffer.wrap(data);
+    parser = new DefaultImageHeaderParser();
+    test.run(parser, buffer, new LruArrayPool());
+  }
+
+  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
+    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
+    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
+    result[result.length - 1] = (byte) bitDepth;
+    return result;
+  }
+
+  private static class SometimesZeroSkipInputStream extends FilterInputStream {
+    boolean returnZeroFlag = true;
+
+    SometimesZeroSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+      final long result;
+      if (returnZeroFlag) {
+        result = 0;
+      } else {
+        result = super.skip(byteCount);
+      }
+      returnZeroFlag = !returnZeroFlag;
+      return result;
+    }
+  }
+
+  private static class PartialSkipInputStream extends FilterInputStream {
+
+    PartialSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+        long toActuallySkip = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallySkip = 1;
+        }
+        return super.skip(toActuallySkip);
+    }
+  }
+
+  private static class PartialReadInputStream extends FilterInputStream {
+
+    PartialReadInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
+        int toActuallyRead = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallyRead = 1;
+        }
+        return super.read(buffer, byteOffset, toActuallyRead);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
index f68d1e556..c6a624025 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
@@ -91,11 +91,11 @@ public void testAtLeast_withSourceGreaterInOneDimension_returnsScaleFactorOfSmal
 
   @Test
   public void testCenterInside_scalesImageToFitWithinRequestedBounds() {
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 200, 300, 300))
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 200, 300, 300))
         .isEqualTo(300 / 200f);
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(270, 480, 724, 440))
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(270, 480, 724, 440))
         .isEqualTo(440 / 480f);
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
new file mode 100644
index 000000000..b95fee2ba
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformationTest.java
@@ -0,0 +1,183 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.resource.SimpleResource;
+import com.bumptech.glide.tests.KeyTester;
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DrawableTransformationTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Transformation<Bitmap> bitmapTransformation;
+  private BitmapPool bitmapPool;
+  private DrawableTransformation transformation;
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    transformation = new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true);
+    context = RuntimeEnvironment.application;
+    bitmapPool = new BitmapPoolAdapter();
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @Test
+  public void transform_withBitmapDrawable_andUnitBitmapTransformation_doesNotRecycle() {
+    when(
+        bitmapTransformation
+            .transform(
+                any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new ReturnGivenResource());
+
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    @SuppressWarnings("unchecked")
+    Resource<Drawable> input =
+        (Resource<Drawable>) (Resource<?>) new BitmapDrawableResource(drawable, bitmapPool);
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withBitmapDrawable_andFunctionalBitmapTransformation_doesNotRecycle() {
+    when(bitmapTransformation.transform(
+        any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new Answer<Resource<Bitmap>>() {
+          @Override
+          public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
+            return BitmapResource.obtain(
+                Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888), bitmapPool);
+          }
+        });
+    Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    @SuppressWarnings("unchecked")
+    Resource<Drawable> input =
+        (Resource<Drawable>) (Resource<?>) new BitmapDrawableResource(drawable, bitmapPool);
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withColorDrawable_andUnitBitmapTransformation_recycles() {
+    bitmapPool = mock(BitmapPool.class);
+    Glide.tearDown();
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+    when(
+        bitmapTransformation
+            .transform(
+                any(Context.class), anyBitmapResource(), anyInt(), anyInt()))
+        .thenAnswer(new ReturnGivenResource());
+
+    ColorDrawable colorDrawable = new ColorDrawable(Color.RED);
+    final Resource<Drawable> input = new SimpleResource<Drawable>(colorDrawable);
+
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Bitmap bitmap = (Bitmap) invocationOnMock.getArguments()[0];
+        assertThat(bitmap.getWidth()).isEqualTo(100);
+        assertThat(bitmap.getHeight()).isEqualTo(200);
+        return null;
+      }
+    }).when(bitmapPool).put(any(Bitmap.class));
+    when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
+        .thenAnswer(new Answer<Bitmap>() {
+          @Override
+          public Bitmap answer(InvocationOnMock invocationOnMock) throws Throwable {
+            int width = (Integer) invocationOnMock.getArguments()[0];
+            int height = (Integer) invocationOnMock.getArguments()[1];
+            Bitmap.Config config = (Bitmap.Config) invocationOnMock.getArguments()[2];
+            return Bitmap.createBitmap(width, height, config);
+          }
+        });
+
+    transformation.transform(context, input, /*outWidth=*/ 100, /*outHeight=*/ 200);
+
+    verify(bitmapPool).put(isA(Bitmap.class));
+  }
+
+  @Test
+  public void testEquals() {
+    BitmapTransformation otherBitmapTransformation = mock(BitmapTransformation.class);
+    doAnswer(new Util.WriteDigest("bitmapTransformation"))
+        .when(bitmapTransformation).updateDiskCacheKey(any(MessageDigest.class));
+    doAnswer(new Util.WriteDigest("otherBitmapTransformation"))
+        .when(otherBitmapTransformation).updateDiskCacheKey(any(MessageDigest.class));
+
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true),
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ false))
+        .addEquivalenceGroup(bitmapTransformation)
+        .addEquivalenceGroup(otherBitmapTransformation)
+        .addEquivalenceGroup(
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ true),
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ false))
+        .addRegressionTest(
+            new DrawableTransformation(bitmapTransformation, /*isRequired=*/ true),
+            "eddf60c557a6315a489b8a3a19b12439a90381256289fbe9a503afa726230bd9")
+        .addRegressionTest(
+            new DrawableTransformation(otherBitmapTransformation, /*isRequired=*/ false),
+            "40931536ed0ec97c39d4be10c44f5b69a86030ec575317f5a0f17e15a0ea9be8")
+        .test();
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Resource<Bitmap> anyBitmapResource() {
+    return any(Resource.class);
+  }
+
+  private static final class ReturnGivenResource implements Answer<Resource<Bitmap>> {
+
+    @Override
+    public Resource<Bitmap> answer(InvocationOnMock invocationOnMock) throws Throwable {
+      @SuppressWarnings("unchecked")
+      Resource<Bitmap> input = (Resource<Bitmap>) invocationOnMock.getArguments()[1];
+      return input;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
similarity index 68%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
index a140022d8..39a7bce42 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -7,42 +7,46 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Paint;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowCanvas;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { FitCenterTest.DrawNothingCanvas.class })
 public class FitCenterTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
 
-  @Mock Resource<Bitmap> resource;
-  @Mock Transformation<Bitmap> transformation;
-  private BitmapPool pool;
+  @Mock private Resource<Bitmap> resource;
+  @Mock private Transformation<Bitmap> transformation;
   private FitCenter fitCenter;
   private int bitmapWidth;
   private int bitmapHeight;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -52,40 +56,51 @@ public void setUp() {
     Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
     when(resource.get()).thenReturn(bitmap);
 
-    pool = new BitmapPoolAdapter();
+    BitmapPool pool = new BitmapPoolAdapter();
+    context = RuntimeEnvironment.application;
+    Glide.init(context, new GlideBuilder().setBitmapPool(pool));
+
 
-    fitCenter = new FitCenter(pool);
+    fitCenter = new FitCenter();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-        fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+        fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+    fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testDoesNotRecycleGivenResource() {
-    fitCenter.transform(resource, 50, 50);
+    fitCenter.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(fitCenter, new FitCenter(pool));
-
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(fitCenter, transformation);
+    keyTester
+        .addEquivalenceGroup(fitCenter, new FitCenter(), new FitCenter())
+        .addEquivalenceGroup(transformation)
+        .addRegressionTest(
+            new FitCenter(), "eda03bc6969032145110add4bfe399915897406f4ca3a1a7512d07750e60f90d")
+        .test();
   }
 
   @Implements(Canvas.class)
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
new file mode 100644
index 000000000..1ad62cac2
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.load.engine.Initializable;
+import com.bumptech.glide.load.engine.Resource;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class LazyBitmapDrawableResourceTest {
+  @Mock private Resource<Bitmap> bitmapResource;
+  private LazyBitmapDrawableResource resource;
+  private Resources resources;
+  private Bitmap bitmap;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(bitmapResource.get()).thenReturn(bitmap);
+
+    resources = RuntimeEnvironment.application.getResources();
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+  }
+
+  @Test
+  public void obtain_withNullBitmapResource_returnsNull() {
+    assertThat(LazyBitmapDrawableResource.obtain(resources, null)).isNull();
+  }
+
+  @Test
+  public void getSize_returnsSizeOfWrappedResource() {
+    when(bitmapResource.getSize()).thenReturn(100);
+    assertThat(resource.getSize()).isEqualTo(100);
+  }
+
+  @Test
+  public void recycle_callsRecycleOnWrappedResource() {
+    resource.recycle();
+    verify(bitmapResource).recycle();
+  }
+
+  @Test
+  public void recycle_doesNotRecycleWrappedBitmap() {
+    resource.recycle();
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void get_returnsDrawableContainingWrappedBitmap() {
+    BitmapDrawable drawable = resource.get();
+    assertThat(drawable.getBitmap()).isSameAs(bitmap);
+  }
+
+  @Test
+  public void initialize_withNonInitializableResource_doesNothing() {
+    resource.initialize();
+  }
+
+  @Test
+  public void initialize_withWrappedInitializableResource_callsInitializeOnWrapped() {
+    InitializableBitmapResource bitmapResource = mock(InitializableBitmapResource.class);
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+    resource.initialize();
+
+    verify(bitmapResource).initialize();
+  }
+
+  private interface InitializableBitmapResource extends Initializable,
+      Resource<Bitmap> {
+    // Intentionally empty.
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
similarity index 96%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
index c8edbaeac..f3dfea93a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
@@ -7,19 +7,20 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
-
+// Not required in tests.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RecyclableBufferedInputStreamTest {
@@ -29,7 +30,7 @@
 
   private RecyclableBufferedInputStream stream;
   private byte[] data;
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
   @Before
   public void setUp() {
@@ -38,7 +39,7 @@ public void setUp() {
       data[i] = (byte) i;
     }
 
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
     InputStream wrapped = new ByteArrayInputStream(data);
     stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool, BUFFER_SIZE);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
similarity index 97%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index 24bd56cad..effaae7bf 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -12,18 +12,13 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.google.common.collect.Range;
-
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.Matrix;
 import android.media.ExifInterface;
-import android.os.Build;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.util.Preconditions;
-
+import com.google.common.collect.Range;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -36,13 +31,12 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowBitmap;
 
-@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = {
     TransformationUtilsTest.AlphaShadowBitmap.class })
 public class TransformationUtilsTest {
 
-  @Mock BitmapPool bitmapPool;
+  @Mock private BitmapPool bitmapPool;
 
   @Before
   public void setUp() {
@@ -356,7 +350,7 @@ public void testRotateImage() {
     assertTrue(toRotate == zero);
 
     Bitmap ninety = TransformationUtils.rotateImage(toRotate, 90);
-    assertTrue(Shadows.shadowOf(ninety).getDescription().contains("rotate=90.0"));
+    assertThat(Shadows.shadowOf(ninety).getDescription()).contains("rotate=90.0");
     assertEquals(toRotate.getWidth(), toRotate.getHeight());
   }
 
@@ -445,8 +439,6 @@ public void testInitializeMatrixSetsRotateOnRotation() {
   @Implements(Bitmap.class)
   public static class AlphaShadowBitmap extends ShadowBitmap {
 
-    private boolean hasAlpha;
-
     @Implementation
     public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       // Robolectric doesn't match the framework behavior with null configs, so we have to do so
@@ -454,15 +446,5 @@ public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       Preconditions.checkNotNull("Config must not be null");
       return ShadowBitmap.createBitmap(width, height, config);
     }
-
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
new file mode 100644
index 000000000..ab3ebc56a
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
@@ -0,0 +1,151 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.os.ParcelFileDescriptor;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
+import java.io.IOException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 27)
+public class VideoDecoderTest {
+  @Mock private ParcelFileDescriptor resource;
+  @Mock private VideoDecoder.MediaMetadataRetrieverFactory factory;
+  @Mock private VideoDecoder.MediaMetadataRetrieverInitializer<ParcelFileDescriptor> initializer;
+  @Mock private MediaMetadataRetriever retriever;
+  @Mock private BitmapPool bitmapPool;
+  private VideoDecoder<ParcelFileDescriptor> decoder;
+  private Options options;
+  private int initialSdkVersion;
+
+  @Before
+  public void setup() {
+    MockitoAnnotations.initMocks(this);
+    when(factory.build()).thenReturn(retriever);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+    options = new Options();
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
+  }
+
+  @Test
+  public void testReturnsRetrievedFrameForResource() throws IOException {
+    Util.setSdkVersionInt(19);
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION))
+        .thenReturn(expected);
+
+    Resource<Bitmap> result =
+        Preconditions.checkNotNull(decoder.decode(resource, 100, 100, options));
+
+    verify(initializer).initialize(retriever, resource);
+    assertEquals(expected, result.get());
+  }
+
+  @Test
+  public void testReleasesMediaMetadataRetriever() throws IOException {
+    Util.setSdkVersionInt(19);
+    decoder.decode(resource, 1, 2, options);
+
+    verify(retriever).release();
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
+    Util.setSdkVersionInt(19);
+    options.set(VideoDecoder.TARGET_FRAME, -5L);
+    new VideoDecoder<>(bitmapPool, initializer, factory).decode(resource, 100, 100, options);
+  }
+
+  @Test
+  public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
+    Util.setSdkVersionInt(19);
+    long frame = 5;
+    options.set(VideoDecoder.TARGET_FRAME, frame);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime(frame, VideoDecoder.DEFAULT_FRAME_OPTION);
+  }
+
+  @Test
+  public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
+    Util.setSdkVersionInt(19);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
+    decoder.decode(resource, 100, 100, options);
+
+    verify(retriever).getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION);
+  }
+
+  @Test
+  public void getScaledFrameAtTime() throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getScaledFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC, 100, 100))
+        .thenReturn(expected);
+
+    assertThat(decoder.decode(resource, 100, 100, options).get()).isSameAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginal_onApi27_doesNotThrow() throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL, options).get())
+        .isSameAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginalWidthOnly_onApi27_doesNotThrow()
+      throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, Target.SIZE_ORIGINAL, 100, options).get())
+        .isSameAs(expected);
+  }
+
+  @Test
+  public void decodeFrame_withTargetSizeOriginalHeightOnly_onApi27_doesNotThrow()
+      throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC))
+        .thenReturn(expected);
+
+    verify(retriever, never()).getScaledFrameAtTime(anyLong(), anyInt(), anyInt(), anyInt());
+    assertThat(decoder.decode(resource, 100, Target.SIZE_ORIGINAL, options).get())
+        .isSameAs(expected);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/bytes/BytesResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
index f95f8bd10..50af60a7a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.resource.drawable;
 
-import static org.junit.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertNotEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -9,9 +9,8 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.drawable.Drawable;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,6 +27,7 @@
   public void setUp() {
     drawable = mock(TestDrawable.class);
     resource = new DrawableResource<TestDrawable>(drawable) {
+      @NonNull
       @Override
       public Class<TestDrawable> getResourceClass() {
         return TestDrawable.class;
@@ -57,15 +57,23 @@ public void testReturnsNewDrawableOnGet() {
     when(constantState.newDrawable()).thenReturn(expected);
     when(drawable.getConstantState()).thenReturn(constantState);
 
-    assertEquals(expected, resource.get());
+    assertThat(resource.get()).isEqualTo(expected);
 
     verify(drawable).getConstantState();
     verify(constantState).newDrawable();
   }
 
+  @Test
+  public void get_withNullState_returnsOriginalDrawable() {
+    when(drawable.getConstantState()).thenReturn(null);
+
+    assertThat(resource.get()).isEqualTo(drawable);
+  }
+
   @Test(expected = NullPointerException.class)
   public void testThrowsIfDrawableIsNull() {
     new DrawableResource<TestDrawable>(null) {
+      @NonNull
       @Override
       public Class<TestDrawable> getResourceClass() {
         return TestDrawable.class;
@@ -88,7 +96,7 @@ public void recycle() {
    */
   private static class TestDrawable extends Drawable {
     @Override
-    public void draw(Canvas canvas) {
+    public void draw(@NonNull Canvas canvas) {
 
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
similarity index 83%
rename from library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
index 508316e05..5e2c76048 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
@@ -4,15 +4,14 @@
 
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-
+import com.bumptech.glide.util.Preconditions;
+import java.io.File;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-import java.io.IOException;
-
 @RunWith(JUnit4.class)
 public class FileDecoderTest {
 
@@ -28,7 +27,7 @@ public void setUp() {
   @Test
   public void testReturnsGivenFileAsResource() throws IOException {
     File expected = new File("testFile");
-    Resource<File> decoded = decoder.decode(expected, 1, 1, options);
+    Resource<File> decoded = Preconditions.checkNotNull(decoder.decode(expected, 1, 1, options));
 
     assertEquals(expected, decoded.get());
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
index 1cfb5408b..6cc0c5775 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
@@ -2,13 +2,12 @@
 
 import static org.junit.Assert.assertEquals;
 
+import java.io.File;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-
 @RunWith(JUnit4.class)
 public class FileResourceTest {
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index f403e3080..d440630cd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -12,11 +12,16 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.tests.GlideShadowLooper;
-
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,23 +32,21 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class ByteBufferGifDecoderTest {
   private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
+  private static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
   private ByteBufferGifDecoder decoder;
   private GifHeader gifHeader;
   private Options options;
 
-  @Mock BitmapPool bitmapPool;
-  @Mock GifHeaderParser parser;
-  @Mock GifDecoder gifDecoder;
-  @Mock ByteBufferGifDecoder.GifHeaderParserPool parserPool;
-  @Mock ByteBufferGifDecoder.GifDecoderFactory decoderFactory;
+  @Mock private BitmapPool bitmapPool;
+  @Mock private GifHeaderParser parser;
+  @Mock private GifDecoder gifDecoder;
+  @Mock private ByteBufferGifDecoder.GifHeaderParserPool parserPool;
+  @Mock private ByteBufferGifDecoder.GifDecoderFactory decoderFactory;
 
   @Before
   public void setUp() {
@@ -57,9 +60,18 @@ public void setUp() {
         eq(gifHeader), isA(ByteBuffer.class), anyInt()))
         .thenReturn(gifDecoder);
 
+    List<ImageHeaderParser> parsers = new ArrayList<>();
+    parsers.add(new DefaultImageHeaderParser());
+
     options = new Options();
-    decoder = new ByteBufferGifDecoder(RuntimeEnvironment.application, bitmapPool,
-        new LruByteArrayPool(), parserPool, decoderFactory);
+    decoder =
+        new ByteBufferGifDecoder(
+            RuntimeEnvironment.application,
+            parsers,
+            bitmapPool,
+            new LruArrayPool(ARRAY_POOL_SIZE_BYTES),
+            parserPool,
+            decoderFactory);
   }
 
   @Test
@@ -74,13 +86,13 @@ public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOE
 
   @Test
   public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {
-    options.set(ByteBufferGifDecoder.DISABLE_ANIMATION, false);
+    options.set(GifOptions.DISABLE_ANIMATION, false);
     assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isTrue();
   }
 
   @Test
   public void testDoesNotHandleStreamIfDisabled() throws IOException {
-    options.set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
+    options.set(GifOptions.DISABLE_ANIMATION, true);
     assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isFalse();
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
similarity index 100%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
similarity index 79%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index d838b7efa..1a2187ed6 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -14,24 +14,32 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
+import android.graphics.PorterDuff.Mode;
+import android.graphics.PorterDuffColorFilter;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
 import android.os.Build;
-
+import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.gif.GifDrawableTest.BitmapTrackingShadowCanvas;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
-
+import com.bumptech.glide.util.Preconditions;
+import java.util.HashSet;
+import java.util.Set;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -41,16 +49,15 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowCanvas;
 
-import java.util.HashSet;
-import java.util.Set;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18,
     shadows = { GlideShadowLooper.class, BitmapTrackingShadowCanvas.class })
 public class GifDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+
   private GifDrawable drawable;
   private int frameHeight;
   private int frameWidth;
@@ -58,10 +65,10 @@
   private int initialSdkVersion;
 
   @Mock private Drawable.Callback cb;
-  @Mock private BitmapPool bitmapPool;
   @Mock private GifFrameLoader frameLoader;
   @Mock private Paint paint;
   @Mock private Transformation<Bitmap> transformation;
+  private Application context;
 
   private static Paint isAPaint() {
     return isA(Paint.class);
@@ -74,10 +81,11 @@ private static Rect isARect() {
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
     frameWidth = 120;
     frameHeight = 450;
     firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
-    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);
+    drawable = new GifDrawable(frameLoader, paint);
     when(frameLoader.getWidth()).thenReturn(frameWidth);
     when(frameLoader.getHeight()).thenReturn(frameHeight);
     when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);
@@ -91,20 +99,21 @@ public void tearDown() {
     Util.setSdkVersionInt(initialSdkVersion);
   }
 
+  // containsExactly doesn't need its return value checked.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
     Canvas canvas = new Canvas();
     drawable.draw(canvas);
 
-    BitmapTrackingShadowCanvas shadowCanvas =
-        (BitmapTrackingShadowCanvas) ShadowExtractor.extract(canvas);
+    BitmapTrackingShadowCanvas shadowCanvas = Shadow.extract(canvas);
     assertThat(shadowCanvas.getDrawnBitmaps()).containsExactly(firstFrame);
   }
 
   @Test
   public void testDoesDrawCurrentFrameIfOneIsAvailable() {
     Canvas canvas = mock(Canvas.class);
-    Bitmap currentFrame = Bitmap.createBitmap(100123, 123141, Bitmap.Config.ARGB_4444);
+    Bitmap currentFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     when(frameLoader.getCurrentFrame()).thenReturn(currentFrame);
 
     drawable.draw(canvas);
@@ -201,7 +210,7 @@ public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfHasNoCallback()
   }
 
   @Test
-  public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+  public void testStopsWhenCurrentFrameFinishesIfHasNoCallback() {
     drawable.setIsRunning(true);
     drawable.setCallback(null);
     drawable.onFrameReady();
@@ -210,18 +219,7 @@ public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneyc
   }
 
   @Test
-  public void testDoesNotStopWhenCurrentFrameFinishesIfHasNoCallbackAndIsPreHoneycomb() {
-    Util.setSdkVersionInt(10);
-
-    drawable.setIsRunning(true);
-    drawable.setCallback(null);
-    drawable.onFrameReady();
-
-    assertTrue(drawable.isRunning());
-  }
-
-  @Test
-  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallback() {
     drawable.setIsRunning(true);
     drawable.setCallback(null);
     drawable.onFrameReady();
@@ -346,10 +344,15 @@ public void testReturnsSizeFromFrameLoader() {
   public void testReturnsNewDrawableFromConstantState() {
     Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     drawable =
-        new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
-            transformation, 100, 100, firstFrame);
-
-    assertNotNull(drawable.getConstantState().newDrawable());
+        new GifDrawable(
+            RuntimeEnvironment.application,
+            mock(GifDecoder.class),
+            transformation,
+            100,
+            100,
+            firstFrame);
+
+    assertNotNull(Preconditions.checkNotNull(drawable.getConstantState()).newDrawable());
     assertNotNull(
         drawable.getConstantState().newDrawable(RuntimeEnvironment.application.getResources()));
   }
@@ -372,7 +375,7 @@ public void testLoopsASingleTimeIfLoopCountIsSetToOne() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -388,6 +391,7 @@ public void testLoopsForeverIfLoopCountIsSetToLoopForever() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
   }
 
   @Test
@@ -403,7 +407,7 @@ public void testLoopsOnceIfLoopCountIsSetToOneWithThreeFrames() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -419,7 +423,7 @@ public void testLoopsThreeTimesIfLoopCountIsSetToThree() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -432,6 +436,7 @@ public void testCallingStartResetsLoopCounter() {
     drawable.onFrameReady();
     when(frameLoader.getCurrentIndex()).thenReturn(1);
     drawable.onFrameReady();
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     drawable.start();
 
@@ -442,7 +447,7 @@ public void testCallingStartResetsLoopCounter() {
 
     // 4 onFrameReady(), 2 start()
     verify(cb, times(4 + 2)).invalidateDrawable(eq(drawable));
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -456,6 +461,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     drawable.start();
 
     runLoops(initialLoopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     final int newLoopCount = 2;
 
@@ -467,6 +473,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     int numStarts = 2;
     int expectedFrames = (initialLoopCount + newLoopCount) * frameCount + numStarts;
     verify(cb, times(expectedFrames)).invalidateDrawable(eq(drawable));
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test(expected = IllegalArgumentException.class)
@@ -475,7 +482,7 @@ public void testThrowsIfGivenLoopCountLessThanZeroAndNotInfinite() {
   }
 
   @Test
-  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
+  public void testUsesDecoderTotalLoopCountIfLoopCountIsLoopIntrinsic() {
     final int frameCount = 3;
     final int loopCount = 2;
     when(frameLoader.getLoopCount()).thenReturn(loopCount);
@@ -487,8 +494,26 @@ public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
+  }
+
+  @Test
+  public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsForever() {
+    final int frameCount = 3;
+    final int loopCount = 40;
+    when(frameLoader.getLoopCount()).thenReturn(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER);
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
   }
 
+
   @Test
   public void testDoesNotDrawFrameAfterRecycle() {
     Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
@@ -512,8 +537,8 @@ public void testSetsFrameTransformationOnFrameManager() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfConstructedWithNullFirstFrame() {
-    new GifDrawable(RuntimeEnvironment.application, mock(GifDecoder.class), bitmapPool,
-        transformation, 100, 100, null);
+    new GifDrawable(
+        RuntimeEnvironment.application, mock(GifDecoder.class), transformation, 100, 100, null);
   }
 
   @Test
@@ -536,13 +561,14 @@ public void testSetAlphaSetsAlphaOnPaint() {
 
   @Test
   public void testSetColorFilterSetsColorFilterOnPaint() {
-    ColorFilter colorFilter = new ColorFilter();
+    ColorFilter colorFilter = new PorterDuffColorFilter(Color.RED, Mode.ADD);
     drawable.setColorFilter(colorFilter);
     verify(paint).setColorFilter(eq(colorFilter));
   }
 
   @Test
   public void testReturnsCurrentTransformationInGetFrameTransformation() {
+    @SuppressWarnings("unchecked")
     Transformation<Bitmap> newTransformation = mock(Transformation.class);
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     drawable.setFrameTransformation(newTransformation, bitmap);
@@ -555,6 +581,30 @@ public void testThrowsIfCreatedWithNullState() {
     new GifDrawable(null);
   }
 
+  @Test
+  public void onFrameReady_whenAttachedToDrawableCallbackButNotViewCallback_stops() {
+    TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] { drawable });
+    drawable.setCallback(topLevel);
+    topLevel.setCallback(null);
+
+    drawable.start();
+    drawable.onFrameReady();
+
+    assertThat(drawable.isRunning()).isFalse();
+  }
+
+  @Test
+  public void onFrameReady_whenAttachedtoDrawableCallbackWithViewCallbackParent_doesNotStop() {
+      TransitionDrawable topLevel = new TransitionDrawable(new Drawable[] { drawable });
+    drawable.setCallback(topLevel);
+    topLevel.setCallback(new View(context));
+
+    drawable.start();
+    drawable.onFrameReady();
+
+    assertThat(drawable.isRunning()).isTrue();
+  }
+
   private void verifyRanLoops(int loopCount, int frameCount) {
     // 1 for invalidate in start().
     verify(cb, times(1 + loopCount * frameCount)).invalidateDrawable(eq(drawable));
@@ -564,6 +614,8 @@ private void runLoops(int loopCount, int frameCount) {
     for (int loop = 0; loop < loopCount; loop++) {
       for (int frame = 0; frame < frameCount; frame++) {
         when(frameLoader.getCurrentIndex()).thenReturn(frame);
+        assertTrue("drawable should be started before calling drawable.onFrameReady()",
+            drawable.isRunning());
         drawable.onFrameReady();
       }
     }
@@ -573,15 +625,16 @@ private void runLoops(int loopCount, int frameCount) {
    * Keeps track of the set of Bitmaps drawn to the canvas.
    */
   @Implements(Canvas.class)
-  public static class BitmapTrackingShadowCanvas extends ShadowCanvas {
+  public static final class BitmapTrackingShadowCanvas extends ShadowCanvas {
     private final Set<Bitmap> drawnBitmaps = new HashSet<>();
 
     @Implementation
+    @Override
     public void drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) {
       drawnBitmaps.add(bitmap);
     }
 
-    public Iterable<Bitmap> getDrawnBitmaps() {
+    private Iterable<Bitmap> getDrawnBitmaps() {
       return drawnBitmaps;
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
similarity index 58%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
index 120ad07a1..f31857b81 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static com.bumptech.glide.tests.Util.mockResource;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
@@ -8,44 +10,57 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.content.Context;
 import android.graphics.Bitmap;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.KeyTester;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifDrawableTransformationTest {
-  @Mock Transformation<Bitmap> wrapped;
-  @Mock BitmapPool bitmapPool;
+  @Rule public final KeyTester keyTester = new KeyTester();
+  @Mock private Transformation<Bitmap> wrapped;
+  @Mock private BitmapPool bitmapPool;
 
-  GifDrawableTransformation transformation;
+  private GifDrawableTransformation transformation;
+  private Context context;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    transformation = new GifDrawableTransformation(wrapped, bitmapPool);
+    context = RuntimeEnvironment.application;
+
+    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));
+    transformation = new GifDrawableTransformation(wrapped);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
+  @SuppressWarnings("unchecked")
   public void testSetsTransformationAsFrameTransformation() {
-    Resource<GifDrawable> resource = mock(Resource.class);
+    Resource<GifDrawable> resource = mockResource();
     GifDrawable gifDrawable = mock(GifDrawable.class);
     Transformation<Bitmap> unitTransformation = UnitTransformation.get();
     when(gifDrawable.getFrameTransformation()).thenReturn(unitTransformation);
@@ -59,11 +74,12 @@ public void testSetsTransformationAsFrameTransformation() {
     final int width = 123;
     final int height = 456;
     Bitmap expectedBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-    Resource<Bitmap> expectedResource = mock(Resource.class);
+    Resource<Bitmap> expectedResource = mockResource();
     when(expectedResource.get()).thenReturn(expectedBitmap);
-    when(wrapped.transform(isA(Resource.class), anyInt(), anyInt())).thenReturn(expectedResource);
+    when(wrapped.transform(any(Context.class), Util.<Bitmap>anyResource(), anyInt(), anyInt()))
+        .thenReturn(expectedResource);
 
-    transformation.transform(resource, width, height);
+    transformation.transform(context, resource, width, height);
 
     verify(gifDrawable).setFrameTransformation(isA(Transformation.class), eq(expectedBitmap));
   }
@@ -72,11 +88,19 @@ public void testSetsTransformationAsFrameTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("first")).when(wrapped)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped, bitmapPool));
-
-    Transformation<Bitmap> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other, bitmapPool));
+    keyTester
+        .addEquivalenceGroup(
+            transformation,
+            new GifDrawableTransformation(wrapped),
+            new GifDrawableTransformation(wrapped))
+        .addEquivalenceGroup(wrapped)
+        .addEquivalenceGroup(new GifDrawableTransformation(other))
+        .addRegressionTest(
+            new GifDrawableTransformation(wrapped),
+            "a7937b64b8caa58f03721bb6bacf5c78cb235febe0e70b1b84cd99541461a08e")
+        .test();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
similarity index 58%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 759a88013..c7a77bcfd 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -13,26 +13,26 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Message;
-
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.DelayTarget;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.FrameCallback;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
-
+import java.nio.ByteBuffer;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
@@ -42,18 +42,16 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.nio.ByteBuffer;
-import java.util.UUID;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifFrameLoaderTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
 
-  @Mock GifFrameLoader.FrameCallback callback;
-  @Mock GifDecoder gifDecoder;
-  @Mock Handler handler;
-  @Mock Transformation<Bitmap> transformation;
-  @Mock RequestManager requestManager;
+  @Mock private GifFrameLoader.FrameCallback callback;
+  @Mock private GifDecoder gifDecoder;
+  @Mock private Handler handler;
+  @Mock private Transformation<Bitmap> transformation;
+  @Mock private RequestManager requestManager;
   private GifFrameLoader loader;
   private RequestBuilder<Bitmap> requestBuilder;
   private Bitmap firstFrame;
@@ -71,17 +69,36 @@ public void setUp() {
 
     requestBuilder = mock(RequestBuilder.class, new ReturnsSelfAnswer());
 
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder, handler,
-        requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(handler);
+  }
+
+  @NonNull
+  private GifFrameLoader createGifFrameLoader(Handler handler) {
+    Glide glide = getGlideSingleton();
+    GifFrameLoader result = new GifFrameLoader(
+        glide.getBitmapPool(),
+        requestManager,
+        gifDecoder,
+        handler,
+        requestBuilder,
+        transformation,
+        firstFrame);
+    result.subscribe(callback);
+    return result;
+  }
+
+  private static Glide getGlideSingleton() {
+    return Glide.get(RuntimeEnvironment.application);
   }
 
   @SuppressWarnings("unchecked")
   @Test
   public void testSetFrameTransformationSetsTransformationOnRequestBuilder() {
+    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));
     Transformation<Bitmap> transformation = mock(Transformation.class);
     loader.setFrameTransformation(transformation, firstFrame);
 
-    verify(requestBuilder, times(2)).apply(isA(RequestOptions.class));
+    verify(requestBuilder, times(3)).apply(isA(RequestOptions.class));
   }
 
   @Test(expected = NullPointerException.class)
@@ -98,19 +115,15 @@ public void testReturnsSizeFromGifDecoderAndCurrentFrame() {
 
   @Test
   public void testStartGetsNextFrameIfNotStartedAndWithNoLoadPending() {
-    loader.subscribe(callback);
-
-    verify(requestBuilder).into(isA(Target.class));
+    verify(requestBuilder).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingLoad() {
-    loader.subscribe(callback);
-
     InOrder order = inOrder(gifDecoder, requestBuilder);
     order.verify(gifDecoder).advance();
-    order.verify(requestBuilder).apply(isA(BaseRequestOptions.class));
-    order.verify(requestBuilder).into(isA(Target.class));
+    order.verify(requestBuilder).apply(isA(RequestOptions.class));
+    order.verify(requestBuilder).into(aTarget());
   }
 
   @Test
@@ -130,52 +143,49 @@ public void testGetCurrentFrameReturnsCurrentBitmapAfterLoadHasCompleted() {
 
   @Test
   public void testStartDoesNotStartIfAlreadyRunning() {
-    loader.subscribe(callback);
     loader.subscribe(mock(FrameCallback.class));
 
-    verify(requestBuilder, times(1)).into(isA(Target.class));
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoaderIsNotRunning() {
+    verify(requestBuilder, times(1)).into(aTarget());
+    loader.unsubscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
-    verify(requestBuilder, never()).into(isA(Target.class));
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
-    loader.subscribe(callback);
     loader.unsubscribe(callback);
     loader.subscribe(callback);
 
-    verify(requestBuilder, times(1)).into(isA(Target.class));
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
-    loader.subscribe(callback);
     loader.unsubscribe(callback);
 
     loader.onFrameReady(mock(DelayTarget.class));
     loader.subscribe(callback);
 
-    verify(requestBuilder, times(2)).into(isA(Target.class));
+    verify(requestBuilder, times(2)).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
-    loader.subscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
-    verify(requestBuilder, times(2)).into(isA(Target.class));
+    verify(requestBuilder, times(2)).into(aTarget());
   }
 
   @Test
   public void testOnFrameReadyClearsPreviousFrame() {
     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -192,9 +202,8 @@ public void testOnFrameReadyClearsPreviousFrame() {
 
   @Test
   public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
-     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager,
-        gifDecoder, null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null.
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -229,9 +238,8 @@ public void testDelayTargetSetsResourceOnResourceReady() {
 
   @Test
   public void testClearsCompletedLoadOnFrameReadyIfCleared() {
-    // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null;
+    loader = createGifFrameLoader(null);
     loader.clear();
     DelayTarget delayTarget = mock(DelayTarget.class);
     Request request = mock(Request.class);
@@ -256,10 +264,98 @@ public void testClearsCompletedLoadOnFrameReadyIfCleared() {
   }
 
   @Test
-  public void testFrameSignatureEquality() {
-    UUID first = UUID.randomUUID();
-    new EqualsTester().addEqualityGroup(new GifFrameLoader.FrameSignature(first),
-        new GifFrameLoader.FrameSignature(first))
-        .addEqualityGroup(new GifFrameLoader.FrameSignature()).testEquals();
+  public void onFrameReady_whenNotRunning_doesNotClearPreviouslyLoadedImage() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+    verify(requestManager, never()).clear(loaded);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_clearsPendingFrameOnClear() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+
+    loader.clear();
+    verify(requestManager).clear(loaded);
+    verify(requestManager).clear(nextFrame);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_clearsOldFrameOnStart() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    when(nextFrame.getResource())
+        .thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(nextFrame);
+
+    loader.subscribe(callback);
+    verify(requestManager).clear(loaded);
+  }
+
+  @Test
+  public void onFrameReady_whenNotRunning_callsFrameReadyWithNewFrameOnStart() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
+    when(nextFrame.getResource())
+        .thenReturn(expected);
+    loader.onFrameReady(nextFrame);
+
+    verify(callback, times(1)).onFrameReady();
+    loader.subscribe(callback);
+    verify(callback, times(2)).onFrameReady();
+    assertThat(loader.getCurrentFrame()).isEqualTo(expected);
+  }
+
+  @Test
+  public void startFromFirstFrame_withPendingFrame_clearsPendingFrame() {
+    loader = createGifFrameLoader(/*handler=*/ null);
+    DelayTarget loaded = mock(DelayTarget.class);
+    when(loaded.getResource()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
+    loader.onFrameReady(loaded);
+    loader.unsubscribe(callback);
+
+    DelayTarget nextFrame = mock(DelayTarget.class);
+    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
+    when(nextFrame.getResource())
+        .thenReturn(expected);
+    loader.onFrameReady(nextFrame);
+
+    loader.setNextStartFromFirstFrame();
+    verify(requestManager).clear(nextFrame);
+
+    loader.subscribe(callback);
+    verify(callback, times(1)).onFrameReady();
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Target<Bitmap> aTarget() {
+    return isA(Target.class);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
similarity index 88%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
index 2a4c28460..59d3cfb09 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
@@ -6,19 +6,17 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
+import com.bumptech.glide.util.Preconditions;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifFrameResourceDecoderTest {
@@ -38,7 +36,9 @@ public void testReturnsFrameFromGifDecoder() throws IOException {
     Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     when(gifDecoder.getNextFrame()).thenReturn(expected);
 
-    assertEquals(expected, resourceDecoder.decode(gifDecoder, 100, 100, options).get());
+    assertEquals(
+        expected,
+        Preconditions.checkNotNull(resourceDecoder.decode(gifDecoder, 100, 100, options)).get());
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
similarity index 72%
rename from library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index bd4efeda5..f50eaf075 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -2,10 +2,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,17 +20,12 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamGifDecoderTest {
   private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
 
-  @Mock
-  ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
+  @Mock private ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private StreamGifDecoder decoder;
   private Options options;
 
@@ -32,7 +33,10 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
-    decoder = new StreamGifDecoder(byteBufferDecoder, new LruByteArrayPool());
+    List<ImageHeaderParser> parsers = new ArrayList<>();
+    parsers.add(new DefaultImageHeaderParser());
+
+    decoder = new StreamGifDecoder(parsers, byteBufferDecoder, new LruArrayPool());
     options = new Options();
   }
 
@@ -48,13 +52,13 @@ public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOE
 
   @Test
   public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {
-    options.set(StreamGifDecoder.DISABLE_ANIMATION, false);
+    options.set(GifOptions.DISABLE_ANIMATION, false);
     assertThat(decoder.handles(new ByteArrayInputStream(GIF_HEADER), options)).isTrue();
   }
 
   @Test
   public void testDoesNotHandleStreamIfDisabled() throws IOException {
-    options.set(StreamGifDecoder.DISABLE_ANIMATION, true);
+    options.set(GifOptions.DISABLE_ANIMATION, true);
     assertThat(decoder.handles(new ByteArrayInputStream(GIF_HEADER), options)).isFalse();
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
similarity index 79%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index 41fea2adc..866b3ff70 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -1,14 +1,14 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-
+import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -49,30 +49,30 @@ public void testUsesGivenFormat() {
   }
 
   @Test
-  public void testBitampResourceIsRecycled() {
+  public void testBitmapResourceIsRecycled() {
     harness.getTranscodedDescription();
 
     verify(harness.bitmapResource).recycle();
   }
 
-  @SuppressWarnings("unchecked")
   private static class BitmapBytesTranscoderHarness {
     Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;
     int quality = 100;
     final String description = "TestDescription";
-    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-    Resource<Bitmap> bitmapResource = mock(Resource.class);
+    final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
+    final Resource<Bitmap> bitmapResource = mockResource();
+    final Options options = new Options();
 
-    public BitmapBytesTranscoderHarness() {
+    BitmapBytesTranscoderHarness() {
       when(bitmapResource.get()).thenReturn(bitmap);
       Shadows.shadowOf(bitmap).setDescription(description);
     }
 
-    public String getTranscodedDescription() {
+    String getTranscodedDescription() {
       BitmapBytesTranscoder transcoder = new BitmapBytesTranscoder(compressFormat, quality);
-      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource);
+      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource, options);
 
-      return new String(bytesResource.get());
+      return new String(bytesResource.get(), Charset.defaultCharset());
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
index cb975b03f..b3c195657 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
@@ -1,15 +1,13 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,17 +22,16 @@
 
   @Before
   public void setUp() {
-    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources(),
-        mock(BitmapPool.class));
+    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources());
   }
 
   @Test
   public void testReturnsBitmapDrawableResourceContainingGivenBitmap() {
     Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Resource<Bitmap> resource = mock(Resource.class);
+    Resource<Bitmap> resource = mockResource();
     when(resource.get()).thenReturn(expected);
 
-    Resource<BitmapDrawable> transcoded = transcoder.transcode(resource);
+    Resource<BitmapDrawable> transcoded = transcoder.transcode(resource, new Options());
 
     assertEquals(expected, transcoded.get().getBitmap());
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
index 70e2a185a..fc1c7777c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -1,30 +1,30 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertArrayEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
-
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.nio.ByteBuffer;
-
 @RunWith(JUnit4.class)
 public class GifDrawableBytesTranscoderTest {
   private GifDrawableBytesTranscoder transcoder;
   private GifDrawable gifDrawable;
   private Resource<GifDrawable> resource;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
     gifDrawable = mock(GifDrawable.class);
-    resource = mock(Resource.class);
+    resource = mockResource();
     when(resource.get()).thenReturn(gifDrawable);
     transcoder = new GifDrawableBytesTranscoder();
   }
@@ -32,10 +32,10 @@ public void setUp() {
   @Test
   public void testReturnsBytesOfGivenGifDrawable() {
     for (String fakeData : new String[] { "test", "1235asfklaw3", "@$@#" }) {
-      ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes());
+      ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes(Charset.defaultCharset()));
       when(gifDrawable.getBuffer()).thenReturn(expected);
 
-      Resource<byte[]> transcoded = transcoder.transcode(resource);
+      Resource<byte[]> transcoded = transcoder.transcode(resource, new Options());
 
       assertArrayEquals(expected.array(), transcoded.get());
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
index 2219e7720..28db86bbe 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
@@ -4,13 +4,12 @@
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.Mockito.mock;
 
+import java.io.File;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-
 @RunWith(JUnit4.class)
 public class TranscoderRegistryTest {
   private TranscoderRegistry factories;
@@ -26,8 +25,9 @@ public void testReturnsUnitDecoderIfClassesAreIdentical() {
   }
 
   @Test
-  public void testCanRegisterAndRetreiveResouceTranscoder() {
-    ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
+  public void testCanRegisterAndRetrieveResourceTranscoder() {
+    @SuppressWarnings("unchecked")
+    ResourceTranscoder<File, String> transcoder = mock(ResourceTranscoder.class);
     factories.register(File.class, String.class, transcoder);
 
     assertEquals(transcoder, factories.get(File.class, String.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
similarity index 65%
rename from library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
rename to library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
index 19a33cfb9..0c8713cf2 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -14,9 +14,9 @@
 
   @Test
   public void testReturnsTheGivenResource() {
-    Resource resource = mock(Resource.class);
+    Resource<Object> resource = mockResource();
     ResourceTranscoder<Object, Object> unitTranscoder = UnitTranscoder.get();
 
-    assertEquals(resource, unitTranscoder.transcode(resource));
+    assertEquals(resource, unitTranscoder.transcode(resource, new Options()));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
index d1a14b0a1..e78445533 100644
--- a/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
@@ -13,12 +13,12 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
-public class ConnectivityMonitorFactoryTest {
+public class DefaultConnectivityMonitorFactoryTest {
   private ConnectivityMonitorFactory factory;
 
   @Before
   public void setUp() {
-    factory = new ConnectivityMonitorFactory();
+    factory = new DefaultConnectivityMonitorFactory();
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
similarity index 61%
rename from library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
index 44ac8726f..930a9f34e 100644
--- a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -3,7 +3,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
@@ -12,30 +11,36 @@
 import android.content.Intent;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
-
+import com.bumptech.glide.manager.DefaultConnectivityMonitorTest.PermissionConnectivityManager;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowApplication;
 import org.robolectric.shadows.ShadowConnectivityManager;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 18, shadows = PermissionConnectivityManager.class)
 public class DefaultConnectivityMonitorTest {
-  private ConnectivityMonitor.ConnectivityListener listener;
+  @Mock private ConnectivityMonitor.ConnectivityListener listener;
   private DefaultConnectivityMonitor monitor;
+  private ConnectivityHarness harness;
+
 
   @Before
   public void setUp() {
-    listener = mock(ConnectivityMonitor.ConnectivityListener.class);
+    MockitoAnnotations.initMocks(this);
     monitor = new DefaultConnectivityMonitor(RuntimeEnvironment.application, listener);
+    harness = new ConnectivityHarness();
   }
 
   @Test
@@ -71,7 +76,6 @@ public void testHandlesUnregisteringTwiceInARow() {
 
   @Test
   public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.connect();
 
     monitor.onStart();
@@ -82,7 +86,6 @@ public void testDoesNotNotifyListenerIfConnectedAndBecomesConnected() {
 
   @Test
   public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.connect();
 
     monitor.onStart();
@@ -94,7 +97,6 @@ public void testNotifiesListenerIfConnectedAndBecomesDisconnected() {
 
   @Test
   public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.disconnect();
 
     monitor.onStart();
@@ -106,7 +108,6 @@ public void testNotifiesListenerIfDisconnectedAndBecomesConnected() {
 
   @Test
   public void testDoesNotNotifyListenerWhenNotRegistered() {
-    ConnectivityHarness harness = new ConnectivityHarness();
     harness.disconnect();
 
     monitor.onStart();
@@ -117,33 +118,81 @@ public void testDoesNotNotifyListenerWhenNotRegistered() {
     verify(listener, never()).onConnectivityChanged(anyBoolean());
   }
 
+  @Test
+  public void register_withMissingPermission_doesNotThrow() {
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+
+    monitor.onStart();
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_doesNotThrow() {
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_previouslyDisconnected_notifiesListenersConnected() {
+    harness.disconnect();
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+
+    verify(listener).onConnectivityChanged(true);
+  }
+
+  @Test
+  public void onReceive_withMissingPermission_previouslyConnected_doesNotNotifyListeners() {
+    harness.connect();
+    monitor.onStart();
+    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;
+    harness.broadcast();
+
+    verify(listener, never()).onConnectivityChanged(anyBoolean());
+  }
+
   private List<BroadcastReceiver> getConnectivityReceivers() {
     Intent connectivity = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
     return ShadowApplication.getInstance().getReceiversForIntent(connectivity);
   }
 
   private static class ConnectivityHarness {
-    private final ShadowConnectivityManager shadowConnectivityManager;
+    private final PermissionConnectivityManager shadowConnectivityManager;
 
     public ConnectivityHarness() {
       ConnectivityManager connectivityManager = (ConnectivityManager) RuntimeEnvironment.application
           .getSystemService(Context.CONNECTIVITY_SERVICE);
-      shadowConnectivityManager = Shadows.shadowOf(connectivityManager);
+      shadowConnectivityManager = Shadow.extract(connectivityManager);
     }
 
-    public void disconnect() {
+    void disconnect() {
       shadowConnectivityManager.setActiveNetworkInfo(null);
     }
 
-    public void connect() {
+    void connect() {
       NetworkInfo networkInfo =
           ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.CONNECTED, 0, 0, true, true);
       shadowConnectivityManager.setActiveNetworkInfo(networkInfo);
     }
 
-    public void broadcast() {
+    void broadcast() {
       Intent connected = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
       ShadowApplication.getInstance().sendBroadcast(connected);
     }
   }
+
+  @Implements(ConnectivityManager.class)
+  public static final class PermissionConnectivityManager extends ShadowConnectivityManager {
+    private boolean isNetworkPermissionGranted = true;
+
+    @Implementation
+    @Override
+    public NetworkInfo getActiveNetworkInfo() {
+      if (!isNetworkPermissionGranted) {
+        throw new SecurityException();
+      }
+      return super.getActiveNetworkInfo();
+    }
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
similarity index 77%
rename from library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
rename to library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
index b1feae1f1..60c59027d 100644
--- a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -1,7 +1,12 @@
 package com.bumptech.glide.manager;
 
+import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
+
 import android.content.Context;
+import android.os.Build;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
@@ -11,26 +16,25 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 
 /**
  * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117.
  */
+@RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 class Issue117Activity extends FragmentActivity {
   @Override
   protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     ViewPager viewPager = new ViewPager(this);
     viewPager.setId(View.generateViewId());
-    setContentView(viewPager, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
-        ViewGroup.LayoutParams.MATCH_PARENT));
+    setContentView(viewPager, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
     viewPager.setAdapter(new Issue117Adapter(getSupportFragmentManager()));
   }
 
   private static class Issue117Adapter extends FragmentPagerAdapter {
 
-    public Issue117Adapter(FragmentManager fm) {
+    Issue117Adapter(FragmentManager fm) {
       super(fm);
     }
 
@@ -47,8 +51,8 @@ public int getCount() {
 
   public static class Issue117Fragment extends Fragment {
     @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container,
-        Bundle savedInstanceState) {
+    public View onCreateView(
+        @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
       return new Issue117ImageView(getActivity());
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java b/library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
index bcc1f9bea..df8bce1ae 100644
--- a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
@@ -4,15 +4,14 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LifecycleTest {
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 1d863c384..191f02309 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -2,24 +2,21 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 import android.app.Activity;
 import android.support.v4.app.FragmentActivity;
-
 import com.bumptech.glide.RequestManager;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -101,29 +98,6 @@ public void runTest(Harness harness) {
     });
   }
 
-  @Test
-  public void testCallsRequestManagerOnLowMemory() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        RequestManager requestManager = mock(RequestManager.class);
-        harness.setRequestManager(requestManager);
-        harness.onLowMemory();
-        verify(requestManager).onLowMemory();
-      }
-    });
-  }
-
-  @Test
-  public void testNonSupportFragmentCallsOnTrimMemory() {
-    RequestManagerHarness requestManagerHarness = new RequestManagerHarness();
-    int level = 100;
-    RequestManager requestManager = mock(RequestManager.class);
-    requestManagerHarness.setRequestManager(requestManager);
-    requestManagerHarness.onTrimMemory(level);
-    verify(requestManager).onTrimMemory(eq(level));
-  }
-
   @Test
   public void testOnLowMemoryCallOnNullRequestManagerDoesNotCrash() {
     runTest(new TestCase() {
@@ -155,7 +129,7 @@ private void runTest(TestCase testCase) {
   }
 
   private interface TestCase {
-    public void runTest(Harness harness);
+    void runTest(Harness harness);
   }
 
   private interface Harness {
@@ -167,13 +141,14 @@ private void runTest(TestCase testCase) {
 
     ActivityFragmentLifecycle getFragmentLifecycle();
 
-    ActivityController getController();
+    ActivityController<?> getController();
 
     void onLowMemory();
 
-    void onTrimMemory(int level);
+    void onTrimMemory(@SuppressWarnings("SameParameterValue") int level);
   }
 
+  @SuppressWarnings("deprecation")
   private static class RequestManagerHarness implements Harness {
     private final ActivityController<Activity> controller;
     private final RequestManagerFragment fragment;
@@ -214,11 +189,11 @@ public ActivityFragmentLifecycle getHarnessLifecycle() {
 
     @Override
     public ActivityFragmentLifecycle getFragmentLifecycle() {
-      return fragment.getLifecycle();
+      return fragment.getGlideLifecycle();
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return controller;
     }
 
@@ -272,11 +247,11 @@ public ActivityFragmentLifecycle getHarnessLifecycle() {
 
     @Override
     public ActivityFragmentLifecycle getFragmentLifecycle() {
-      return supportFragment.getLifecycle();
+      return supportFragment.getGlideLifecycle();
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return supportController;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index 0dd3828d3..dd07da813 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -14,16 +14,17 @@
 import android.content.ContextWrapper;
 import android.os.Build;
 import android.os.Looper;
+import android.support.annotation.RequiresApi;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
-
 import com.bumptech.glide.RequestManager;
-import com.bumptech.glide.tests.BackgroundUtil;
+import com.bumptech.glide.tests.BackgroundUtil.BackgroundTester;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
-
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
@@ -31,12 +32,14 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class RequestManagerRetrieverTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+
   private static final String PARENT_TAG = "parent";
   private RetrieverHarness[] harnesses;
   private RequestManagerRetriever retriever;
@@ -44,7 +47,7 @@
 
   @Before
   public void setUp() {
-    retriever = new RequestManagerRetriever();
+    retriever = new RequestManagerRetriever(null /*factory*/);
 
     harnesses =
         new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };
@@ -131,6 +134,7 @@ public void testSupportCanGetRequestManagerFromActivity() {
     assertEquals(manager, retriever.get(fragmentActivity));
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   public void testCanGetRequestManagerFromFragment() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -165,6 +169,7 @@ public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
     helpTestCanGetRequestManagerFromDetachedFragment();
   }
 
+  @SuppressWarnings("deprecation")
   private void helpTestCanGetRequestManagerFromDetachedFragment() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
     android.app.Fragment fragment = new android.app.Fragment();
@@ -199,13 +204,14 @@ private void helpTestSupportCanGetRequestManagerFromDetachedFragment() {
     retriever.get(fragment);
   }
 
+  @SuppressWarnings("deprecation")
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfFragmentNotAttached() {
     android.app.Fragment fragment = new android.app.Fragment();
     retriever.get(fragment);
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfSupportFragmentNotAttached() {
     Fragment fragment = new Fragment();
     retriever.get(fragment);
@@ -213,14 +219,14 @@ public void testThrowsIfSupportFragmentNotAttached() {
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfActivityDestroyed() {
-    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RetrieverHarness harness = new DefaultRetrieverHarness();
     harness.getController().pause().stop().destroy();
     harness.doGet();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfFragmentActivityDestroyed() {
-    SupportRetrieverHarness harness = new SupportRetrieverHarness();
+    RetrieverHarness harness = new SupportRetrieverHarness();
     harness.getController().pause().stop().destroy();
     harness.doGet();
   }
@@ -232,7 +238,7 @@ public void testThrowsIfGivenNullContext() {
 
   @Test
   public void testChecksIfContextIsFragmentActivity() {
-    SupportRetrieverHarness harness = new SupportRetrieverHarness();
+    RetrieverHarness harness = new SupportRetrieverHarness();
     RequestManager requestManager = harness.doGet();
 
     assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
@@ -240,7 +246,7 @@ public void testChecksIfContextIsFragmentActivity() {
 
   @Test
   public void testChecksIfContextIsActivity() {
-    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RetrieverHarness harness = new DefaultRetrieverHarness();
     RequestManager requestManager = harness.doGet();
 
     assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
@@ -248,9 +254,9 @@ public void testChecksIfContextIsActivity() {
 
   @Test
   public void testHandlesContextWrappersForActivities() {
-    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RetrieverHarness harness = new DefaultRetrieverHarness();
     RequestManager requestManager = harness.doGet();
-    ContextWrapper contextWrapper = new ContextWrapper((Context) harness.getController().get());
+    ContextWrapper contextWrapper = new ContextWrapper(harness.getController().get());
 
     assertEquals(requestManager, retriever.get(contextWrapper));
   }
@@ -285,9 +291,9 @@ public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
   @Test
   public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread()
       throws InterruptedException {
-    testInBackground(new BackgroundUtil.BackgroundTester() {
+    testInBackground(new BackgroundTester() {
       @Override
-      public void runTest() throws Exception {
+      public void runTest() {
         retriever.get(RuntimeEnvironment.application);
       }
     });
@@ -306,16 +312,7 @@ public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
   }
 
   @Test
-  public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
-    Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
-    Activity activity = mock(Activity.class);
-    when(activity.getApplicationContext()).thenReturn(RuntimeEnvironment.application);
-    when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());
-
-    assertNotNull(retriever.get(activity));
-  }
-
-  @Test
+  @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -325,20 +322,9 @@ public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     assertNotNull(retriever.get(spyActivity));
   }
 
+  @SuppressWarnings("deprecation")
   @Test
-  public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
-    Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
-    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
-    android.app.Fragment fragment = new android.app.Fragment();
-
-    activity.getFragmentManager().beginTransaction().add(fragment, "test").commit();
-    android.app.Fragment spyFragment = Mockito.spy(fragment);
-    when(spyFragment.isDetached()).thenThrow(new NoSuchMethodError());
-
-    assertNotNull(retriever.get(spyFragment));
-  }
-
-  @Test
+  @RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -352,22 +338,21 @@ public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
   }
 
   private interface RetrieverHarness {
+    ActivityController<?> getController();
 
-    public ActivityController getController();
-
-    public RequestManager doGet();
+    RequestManager doGet();
 
-    public boolean hasFragmentWithTag(String tag);
+    boolean hasFragmentWithTag(String tag);
 
-    public void addFragmentWithTag(String tag, RequestManager manager);
+    void addFragmentWithTag(String tag, RequestManager manager);
   }
 
-  public class DefaultRetrieverHarness implements RetrieverHarness {
+  final class DefaultRetrieverHarness implements RetrieverHarness {
     private final ActivityController<Activity> controller =
         Robolectric.buildActivity(Activity.class);
     private final android.app.Fragment parent;
 
-    public DefaultRetrieverHarness() {
+    DefaultRetrieverHarness() {
       this.parent = new android.app.Fragment();
 
       controller.create();
@@ -378,7 +363,7 @@ public DefaultRetrieverHarness() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return controller;
     }
 
@@ -395,6 +380,7 @@ public boolean hasFragmentWithTag(String tag) {
           .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public void addFragmentWithTag(String tag, RequestManager requestManager) {
       RequestManagerFragment fragment = new RequestManagerFragment();
@@ -421,7 +407,7 @@ public SupportRetrieverHarness() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return controller;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
similarity index 84%
rename from library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
rename to library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
index 2110a1613..afff35212 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -11,11 +11,11 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.request.Request;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -25,27 +25,40 @@
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
     tracker = new RequestTracker();
   }
 
   @Test
-  public void testClearsAddedRequestsOnDestroy() {
+  public void clearRequests_doesNotRecycleRequests() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
 
     tracker.clearRequests();
 
     verify(request).clear();
-    verify(request).recycle();
+    verify(request, never()).recycle();
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsFalse() {
-    assertThat(tracker.clearRemoveAndRecycle(null)).isFalse();
+  public void clearRemoveAndRecycle_withRequestPreviouslyClearedInClearRequests_doesNothing() {
+    Request request = mock(Request.class);
+    tracker.addRequest(request);
+
+    tracker.clearRequests();
+    tracker.clearRemoveAndRecycle(request);
+
+    verify(request).clear();
+    verify(request, never()).recycle();
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
+  public void clearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsTrue() {
+    assertThat(tracker.clearRemoveAndRecycle(null)).isTrue();
+  }
+
+  @Test
+  public void clearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {
     Request request = mock(Request.class);
 
     assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();
@@ -55,7 +68,7 @@ public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturns
   }
 
   @Test
-  public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
+  public void clearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
 
@@ -65,7 +78,7 @@ public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturn
   }
 
   @Test
-  public void testClearRemoveAndRecyle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
+  public void clearRemoveAndRecycle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {
     Request request = mock(Request.class);
     tracker.addRequest(request);
     tracker.clearRemoveAndRecycle(request);
@@ -341,11 +354,31 @@ public void testReturnsFalseFromIsPausedWhenResumed() {
     assertFalse(tracker.isPaused());
   }
 
+  @Test
+  public void testPauseAllRequests_returnsTrueFromIsPaused() {
+    tracker.pauseAllRequests();
+    assertTrue(tracker.isPaused());
+  }
+
+  @Test
+  public void testPauseAllRequests_whenRequestComplete_pausesRequest() {
+    Request request = mock(Request.class);
+    when(request.isFailed()).thenReturn(false);
+    when(request.isComplete()).thenReturn(true);
+    tracker.addRequest(request);
+    tracker.pauseAllRequests();
+    verify(request).pause();
+
+    when(request.isComplete()).thenReturn(false);
+    tracker.resumeRequests();
+    verify(request).begin();
+  }
+
   private class ClearAndRemoveRequest implements Answer<Void> {
 
-    private Request toRemove;
+    private final Request toRemove;
 
-    public ClearAndRemoveRequest(Request toRemove) {
+    ClearAndRemoveRequest(Request toRemove) {
       this.toRemove = toRemove;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
similarity index 87%
rename from library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
rename to library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
index ab71f9d20..698425e22 100644
--- a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -9,10 +9,11 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.os.Bundle;
-
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -21,15 +22,13 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("deprecation")
 public class ManifestParserTest {
   private static final String MODULE_VALUE = "GlideModule";
 
-  @Mock
-  Context context;
+  @Mock private Context context;
   private ManifestParser parser;
   private ApplicationInfo applicationInfo;
 
@@ -112,16 +111,15 @@ private void addToManifest(String key) {
     applicationInfo.metaData.putString(key, MODULE_VALUE);
   }
 
-  public static class InvalidClass {
-  }
+  private static class InvalidClass { }
 
   public static class TestModule1 implements GlideModule {
     @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     }
 
     @Override
-    public void registerComponents(Context context, Registry registry) {
+    public void registerComponents(Context context, Glide glide, Registry registry) {
     }
 
     @Override
@@ -138,11 +136,11 @@ public int hashCode() {
   public static class TestModule2 implements GlideModule {
 
     @Override
-    public void applyOptions(Context context, GlideBuilder builder) {
+    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
     }
 
     @Override
-    public void registerComponents(Context context, Registry registry) {
+    public void registerComponents(Context context, Glide glide, Registry registry) {
     }
 
     @Override
diff --git a/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
new file mode 100644
index 000000000..931579037
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
@@ -0,0 +1,629 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class ErrorRequestCoordinatorTest {
+
+  @Mock private Request primary;
+  @Mock private Request error;
+  @Mock private RequestCoordinator parent;
+  private ErrorRequestCoordinator coordinator;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    coordinator = new ErrorRequestCoordinator(/*parent=*/ null);
+    coordinator.setRequests(primary, error);
+  }
+
+  @Test
+  public void begin_startsPrimary() {
+    coordinator.begin();
+    verify(primary).begin();
+  }
+
+  @Test
+  public void begin_whenPrimaryIsAlreadyRunning_doesNotStartPrimaryAgain() {
+    when(primary.isRunning()).thenReturn(true);
+    coordinator.begin();
+    verify(primary, never()).begin();
+  }
+
+  @Test
+  public void pause_whenPrimaryHasNotFailed_pausesPrimary() {
+    coordinator.pause();
+    verify(primary).pause();
+  }
+
+  @Test
+  public void pause_whenPrimaryHasFailed_doesNotPausePrimary() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.pause();
+    verify(primary, never()).pause();
+  }
+
+  @Test
+  public void pause_whenErrorIsRunning_pausesError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.pause();
+    verify(error).pause();
+  }
+
+  @Test
+  public void pause_whenErrorIsNotRunning_doesNotPauseError() {
+    coordinator.pause();
+    verify(error, never()).pause();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_clearsPrimary() {
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_doesNotClearError() {
+    coordinator.clear();
+    verify(error, never()).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_errorIsRunning_clearsError() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isRunning()).thenReturn(true);
+    coordinator.clear();
+    verify(error).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_clearsPrimary() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void clear_whenErrorIsRunning_clearsError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.clear();
+
+    verify(error).clear();
+  }
+
+  @Test
+  public void isPaused_primaryNotFailed_primaryNotPaused_returnsFalse() {
+    assertThat(coordinator.isPaused()).isFalse();
+  }
+
+  @Test
+  public void isPaused_primaryNotFailed_primaryPaused_returnsTrue() {
+    when(primary.isPaused()).thenReturn(true);
+    assertThat(coordinator.isPaused()).isTrue();
+  }
+
+  @Test
+  public void isPaused_primaryFailed_errorNotPaused_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isPaused()).isFalse();
+  }
+
+  @Test
+  public void isPaused_primaryFailed_errorPaused_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isPaused()).thenReturn(true);
+    assertThat(coordinator.isPaused()).isTrue();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryNotRunning_returnsFalse() {
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryRunning_returnsTrue() {
+    when(primary.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorNotRunning_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorRunning_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryNotComplete_returnsFalse() {
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryComplete_returnsTrue() {
+    when(primary.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorNotComplete_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorComplete_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryNotResourceSet_returnsFalse() {
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryResourceSet_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorNotResourceSet_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorResourceSet_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryNotCancelled_returnsFalse() {
+    assertThat(coordinator.isCancelled()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryCancelled_returnsTrue() {
+    when(primary.isCancelled()).thenReturn(true);
+    assertThat(coordinator.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorNotCancelled_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isCancelled()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorCancelled_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isCancelled()).thenReturn(true);
+    assertThat(coordinator.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorNotFailed_returnsFalse() {
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_errorNotFailed_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorFailed_returnsFalse() {
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_andErrorFailed_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isTrue();
+  }
+
+  @Test
+  public void recycle_recyclesPrimaryAndError() {
+    coordinator.recycle();
+    verify(primary).recycle();
+    verify(error).recycle();
+  }
+
+  @Test
+  public void isEquivalentTo() {
+    assertThat(coordinator.isEquivalentTo(primary)).isFalse();
+
+    ErrorRequestCoordinator other = new ErrorRequestCoordinator(/*parent=*/ null);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(primary, primary);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(error, error);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    when(primary.isEquivalentTo(primary)).thenReturn(true);
+    when(error.isEquivalentTo(error)).thenReturn(true);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_andNullParent_returnsTrue() {
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andNullParent_andNotFailedPrimary_returnsFalse() {
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canSetImage(primary)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCantNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_notFailedPrimary_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCantNotify_false() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_nullParent_returnsFalse() {
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_nullParent_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentResourceNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nullParent_returnsFalse() {
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nullParent_returnsTrue() {
+    when(error.isResourceSet()).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nonNullParentNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void onRequestSuccess_nullParent_doesNotThrow() {
+    coordinator.onRequestSuccess(primary);
+  }
+
+  @Test
+  public void onRequestSuccess_nonNullParent_callsParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.onRequestSuccess(primary);
+    verify(parent).onRequestSuccess(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_beingsError() {
+    coordinator.onRequestFailed(primary);
+    verify(error).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_doesNotBeginError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.onRequestFailed(primary);
+
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_doesNotBeginError() {
+    coordinator.onRequestFailed(error);
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(primary);
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_nonNullParent_notifiesParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(error);
+
+    verify(parent).onRequestFailed(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isRunning()).thenReturn(true);
+
+    coordinator.onRequestFailed(primary);
+
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(false);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
similarity index 71%
rename from library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index fb73a052b..c7b48a83d 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -6,6 +6,7 @@
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -13,9 +14,12 @@
 import static org.mockito.Mockito.verify;
 
 import android.os.Handler;
-
+import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.request.target.SizeReadyCallback;
-
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,11 +28,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RequestFutureTargetTest {
@@ -64,7 +63,12 @@ public void testReturnsFalseForDoneBeforeDone() {
 
   @Test
   public void testReturnsTrueFromIsDoneIfDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     assertTrue(future.isDone());
   }
 
@@ -79,17 +83,17 @@ public void testReturnsTrueFromCancelIfNotYetDone() {
   }
 
   @Test
-  public void testClearsRequestOnMainThreadIfNotYetDoneOnCancel() {
+  public void cancel_withMayInterruptIfRunningTrueAndNotFinishedRequest_clearsFutureOnMainThread() {
     future.cancel(true);
 
     verify(handler).post(eq(future));
   }
 
   @Test
-  public void testClearsOnMainThreadWhenClearCalled() {
+  public void cancel_withInterruptFalseAndNotFinishedRequest_doesNotclearFutureOnMainThread() {
     future.cancel(false);
 
-    verify(handler).post(eq(future));
+    verify(handler, never()).post(eq(future));
   }
 
   @Test
@@ -109,7 +113,12 @@ public void testClearsRequestOnRun() {
 
   @Test
   public void testDoesNotClearRequestIfCancelledAfterDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.cancel(true);
 
     verify(request, never()).clear();
@@ -123,7 +132,12 @@ public void testReturnsTrueFromDoneIfCancelled() {
 
   @Test
   public void testReturnsFalseFromIsCancelledIfCancelledAfterDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     future.cancel(true);
 
     assertFalse(future.isCancelled());
@@ -137,7 +151,12 @@ public void testReturnsTrueFromCancelIfCancelled() {
 
   @Test
   public void testReturnsFalseFromCancelIfDone() {
-    future.onResourceReady(new Object(), null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     assertFalse(future.cancel(true));
   }
 
@@ -145,7 +164,12 @@ public void testReturnsFalseFromCancelIfDone() {
   public void testReturnsResourceOnGetIfAlreadyDone()
       throws ExecutionException, InterruptedException {
     Object expected = new Object();
-    future.onResourceReady(expected, null);
+    future.onResourceReady(
+        /*resource=*/ expected,
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
 
     assertEquals(expected, future.get());
   }
@@ -154,9 +178,14 @@ public void testReturnsResourceOnGetIfAlreadyDone()
   public void testReturnsResourceOnGetWithTimeoutIfAlreadyDone()
       throws InterruptedException, ExecutionException, TimeoutException {
     Object expected = new Object();
-    future.onResourceReady(expected, null);
+    future.onResourceReady(
+        /*resource=*/ expected,
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
 
-    assertEquals(expected, future.get(100, TimeUnit.MILLISECONDS));
+    assertEquals(expected, future.get(1, TimeUnit.MILLISECONDS));
   }
 
   @Test(expected = CancellationException.class)
@@ -176,21 +205,21 @@ public void testThrowsCancellationExceptionIfCancelledBeforeGetWithTimeout()
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGet()
       throws ExecutionException, InterruptedException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get();
   }
 
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionWithNullValueBeforeGet()
       throws ExecutionException, InterruptedException, TimeoutException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get(100, TimeUnit.MILLISECONDS);
   }
 
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionOnGetIfExceptionBeforeGetWithTimeout()
       throws ExecutionException, InterruptedException, TimeoutException {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     future.get(100, TimeUnit.MILLISECONDS);
   }
 
@@ -207,12 +236,25 @@ public void testThrowsExceptionIfGetCalledOnMainThread()
     future.get();
   }
 
+  @Test
+  public void testGetSucceedsOnMainThreadIfDone()
+      throws ExecutionException, InterruptedException {
+    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
+    future.get();
+  }
+
   @Test(expected = InterruptedException.class)
   public void testThrowsInterruptedExceptionIfThreadInterruptedWhenDoneWaiting()
       throws InterruptedException, ExecutionException {
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         Thread.currentThread().interrupt();
         return null;
       }
@@ -224,10 +266,10 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onLoadFailed(null);
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+        future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
         return null;
       }
     }).when(waiter).waitForTimeout(eq(future), anyLong());
@@ -237,9 +279,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test(expected = CancellationException.class)
   public void testThrowsCancellationExceptionIfCancelledWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         future.cancel(false);
         return null;
       }
@@ -261,13 +303,18 @@ public void testThrowsAssertionErrorIfFinishesWaitingWithoutTimeoutAndDoesNotRec
 
   @Test
   public void testNotifiesAllWhenLoadFails() {
-    future.onLoadFailed(null);
+    future.onLoadFailed(/*e=*/ null, /*model=*/ null, future, /*isFirstResource=*/ true);
     verify(waiter).notifyAll(eq(future));
   }
 
   @Test
   public void testNotifiesAllWhenResourceReady() {
-    future.onResourceReady(null, null);
+    future.onResourceReady(
+        /*resource=*/ new Object(),
+        /*model=*/ null,
+        /*target=*/future,
+        DataSource.DATA_DISK_CACHE,
+        true /*isFirstResource*/);
     verify(waiter).notifyAll(eq(future));
   }
 
@@ -289,10 +336,15 @@ public void testDoesNotNotifyAllOnSecondCancel() {
   public void testReturnsResourceIfReceivedWhileWaiting()
       throws ExecutionException, InterruptedException {
     final Object expected = new Object();
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        future.onResourceReady(expected, null);
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+        future.onResourceReady(
+            /*resource=*/ expected,
+            /*model=*/ null,
+            /*target=*/future,
+            DataSource.DATA_DISK_CACHE,
+            true /*isFirstResource*/);
         return null;
       }
     }).when(waiter).waitForTimeout(eq(future), anyLong());
@@ -313,30 +365,31 @@ public void testWaitsForeverIfNoTimeoutSet() throws InterruptedException {
 
   @Test
   public void testWaitsForGivenTimeoutMillisIfTimeoutSet() throws InterruptedException {
-    long timeout = 1234;
+    long timeout = 2;
     try {
-      future.get(1234, TimeUnit.MILLISECONDS);
+      future.get(timeout, TimeUnit.MILLISECONDS);
     } catch (InterruptedException | ExecutionException e) {
       throw new RuntimeException(e);
     } catch (TimeoutException e) {
       // Expected.
     }
 
-    verify(waiter).waitForTimeout(eq(future), eq(timeout));
+    verify(waiter, atLeastOnce()).waitForTimeout(eq(future), eq(timeout));
   }
 
   @Test
   public void testConvertsOtherTimeUnitsToMillisForWaiter() throws InterruptedException {
-    long timeoutSeconds = 10;
+    long timeoutMicros = 1000;
     try {
-      future.get(timeoutSeconds, TimeUnit.SECONDS);
+      future.get(timeoutMicros, TimeUnit.MICROSECONDS);
     } catch (InterruptedException | ExecutionException e) {
       throw new RuntimeException(e);
     } catch (TimeoutException e) {
       // Expected.
     }
 
-    verify(waiter).waitForTimeout(eq(future), eq(TimeUnit.SECONDS.toMillis(timeoutSeconds)));
+    verify(waiter, atLeastOnce())
+        .waitForTimeout(eq(future), eq(TimeUnit.MICROSECONDS.toMillis(timeoutMicros)));
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
new file mode 100644
index 000000000..aa61bc883
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -0,0 +1,393 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.MultiTransformation;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.util.Util;
+import com.google.common.testing.EqualsTester;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class RequestOptionsTest {
+
+  private RequestOptions options;
+  @Mock private Transformation<Bitmap> transformation;
+  private Application app;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    options = new RequestOptions();
+
+    app = RuntimeEnvironment.application;
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_byDefault_isTrue() {
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withFitCenter_isTrue() {
+    options.fitCenter();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+    options.optionalFitCenter();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCenterInside_isTrue() {
+    options.centerInside();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+    options.optionalCenterInside();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCenterCrop_isFalse() {
+    options.centerCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalCenterCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCircleCrop_isFalse() {
+    options.circleCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.circleCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withBitmapTransformation_isFalse() {
+    options.transform(transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalTransform(transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCustomTransformation_isFalse() {
+    options.transform(Bitmap.class, transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalTransform(Bitmap.class, transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withDownsampleStrategy_isTrue() {
+    options.downsample(DownsampleStrategy.CENTER_OUTSIDE);
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleAndThenDontTransform_isTrue() {
+    options.circleCrop().dontTransform();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleAndAppliedDontTransform_isTrue() {
+    options.circleCrop();
+    options.apply(new RequestOptions().dontTransform());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withDontTransformAndAppliedNonScaleTransform_isFalse() {
+    options.fitCenter();
+    options.apply(new RequestOptions().circleCrop());
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleOnly_andAppliedWithScaleOnly_isTrue() {
+    options.circleCrop();
+    options.apply(new RequestOptions().fitCenter());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withScaleOnlyAndAppliedWithoutTransform_isTrue() {
+    options.fitCenter();
+    options.apply(new RequestOptions().dontAnimate());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleOnlyAndAppliedWithoutTransform_isFalse() {
+    options.circleCrop();
+    options.apply(new RequestOptions().dontAnimate());
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_byDefault_isFalse() {
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationSet_byDefault_isFalse() {
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_byDefault_isTrue() {
+    assertThat(options.isTransformationAllowed()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
+    RequestOptions other = new RequestOptions();
+    other.transform(Bitmap.class, transformation);
+    options.apply(other);
+    assertThat(options.isTransformationSet()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationAllowed()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testApplyingDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingTransformation_overridesDontTransform() {
+    options.dontTransform();
+    options.transform(transformation);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingOptions_withDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    RequestOptions other = new RequestOptions();
+    other.dontTransform();
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingOptions_withTransformation_overridesDontTransform() {
+    options.dontTransform();
+    RequestOptions other = new RequestOptions();
+    other.transform(transformation);
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationSet()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
+    options.dontTransform();
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
+    options.transform(transformation);
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  @SuppressWarnings({"unchecked", "varargs"})
+  public void testApplyMultiTransform() {
+    options.transforms(new CircleCrop(), new CenterCrop());
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsKey(Bitmap.class);
+    assertThat(options.getTransformations().get(Bitmap.class))
+      .isInstanceOf(MultiTransformation.class);
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withoutSkipMemoryCache_isFalse() {
+    assertThat(options.isSkipMemoryCacheSet()).isFalse();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheTrue_isTrue() {
+    assertThat(options.skipMemoryCache(true).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheFalse_isTrue() {
+    assertThat(options.skipMemoryCache(false).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withoutDiskCacheStrategy_isFalse() {
+    assertThat(options.isDiskCacheStrategySet()).isFalse();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).isDiskCacheStrategySet())
+        .isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyNonDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.ALL).isDiskCacheStrategySet())
+        .isTrue();
+  }
+
+  @Test
+  public void testEqualsHashCode() {
+    Drawable first = new ColorDrawable(Color.RED);
+    Drawable second = new GradientDrawable();
+    assertThat(first).isNotEqualTo(second);
+    assertThat(Util.bothNullOrEqual(first, second)).isFalse();
+    new EqualsTester()
+        .addEqualityGroup(
+            new RequestOptions().sizeMultiplier(.7f),
+            new RequestOptions().sizeMultiplier(.7f))
+        .addEqualityGroup(new RequestOptions().sizeMultiplier(0.8f))
+        .addEqualityGroup(new RequestOptions().error(1), new RequestOptions().error(1))
+        .addEqualityGroup(new RequestOptions().error(2))
+        .addEqualityGroup(new RequestOptions().error(first), new RequestOptions().error(first))
+        .addEqualityGroup(new RequestOptions().error(second))
+        .addEqualityGroup(new RequestOptions().placeholder(1), new RequestOptions().placeholder(1))
+        .addEqualityGroup(new RequestOptions().placeholder(2))
+        .addEqualityGroup(
+            new RequestOptions().placeholder(first),
+            new RequestOptions().placeholder(first))
+        .addEqualityGroup(new RequestOptions().placeholder(second))
+        .addEqualityGroup(new RequestOptions().fallback(1), new RequestOptions().fallback(1))
+        .addEqualityGroup(new RequestOptions().fallback(2))
+        .addEqualityGroup(
+            new RequestOptions().fallback(first),
+            new RequestOptions().fallback(first))
+        .addEqualityGroup(new RequestOptions().fallback(second))
+        .addEqualityGroup(
+            new RequestOptions().skipMemoryCache(true),
+            new RequestOptions().skipMemoryCache(true))
+        .addEqualityGroup(
+            new RequestOptions(),
+            new RequestOptions().skipMemoryCache(false),
+            new RequestOptions().theme(null),
+            new RequestOptions().onlyRetrieveFromCache(false),
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(false))
+        .addEqualityGroup(
+            new RequestOptions().override(100),
+            new RequestOptions().override(100, 100))
+        .addEqualityGroup(
+            new RequestOptions().override(200),
+            new RequestOptions().override(200, 200))
+        .addEqualityGroup(
+            new RequestOptions().override(100, 200),
+            new RequestOptions().override(100, 200))
+        .addEqualityGroup(
+            new RequestOptions().override(200, 100),
+            new RequestOptions().override(200, 100))
+        .addEqualityGroup(
+            new RequestOptions().centerCrop(),
+            new RequestOptions().centerCrop())
+        .addEqualityGroup(
+            new RequestOptions().optionalCenterCrop(),
+            new RequestOptions().optionalCenterCrop())
+        .addEqualityGroup(new RequestOptions().fitCenter())
+        .addEqualityGroup(new RequestOptions().circleCrop())
+        .addEqualityGroup(new RequestOptions().centerInside())
+        .addEqualityGroup(
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(true),
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(true))
+        .addEqualityGroup(
+            new RequestOptions().onlyRetrieveFromCache(true),
+            new RequestOptions().onlyRetrieveFromCache(true))
+        .addEqualityGroup(
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL),
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL))
+        .addEqualityGroup(
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE))
+        .addEqualityGroup(
+            new RequestOptions().priority(Priority.HIGH),
+            new RequestOptions().priority(Priority.HIGH))
+        .addEqualityGroup(
+            new RequestOptions().priority(Priority.LOW))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.memory("test"), true),
+            new RequestOptions().set(Option.memory("test"), true))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.memory("test"), false))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.memory("test2"), true))
+        .addEqualityGroup(
+            new RequestOptions().decode(Integer.class),
+            new RequestOptions().decode(Integer.class))
+        .addEqualityGroup(
+            new RequestOptions().decode(Float.class))
+        .addEqualityGroup(
+            new RequestOptions().signature(new ObjectKey("test")),
+            new RequestOptions().signature(new ObjectKey("test")))
+        .addEqualityGroup(
+            new RequestOptions().signature(new ObjectKey("test2")))
+        .addEqualityGroup(
+            new RequestOptions().theme(app.getTheme()),
+            new RequestOptions().theme(app.getTheme()))
+        .testEquals();
+  }
+
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
new file mode 100644
index 000000000..b41596250
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -0,0 +1,1150 @@
+package com.bumptech.glide.request;
+
+import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.GlideContext;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.GlideException;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.request.target.SizeReadyCallback;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.request.transition.TransitionFactory;
+import com.bumptech.glide.signature.ObjectKey;
+import com.google.common.base.Equivalence;
+import com.google.common.testing.EquivalenceTester;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("rawtypes")
+public class SingleRequestTest {
+
+  private SingleRequestBuilder builder;
+
+  @Before
+  public void setUp() {
+    builder = new SingleRequestBuilder();
+  }
+
+  @Test
+  public void testIsNotCompleteBeforeReceivingResource() {
+    SingleRequest<List> request = builder.build();
+
+    assertFalse(request.isComplete());
+  }
+
+  @Test
+  public void testCanHandleNullResources() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(null, DataSource.LOCAL);
+
+    assertTrue(request.isFailed());
+    verify(builder.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),
+        eq(builder.target), anyBoolean());
+  }
+
+  @Test
+  public void testCanHandleEmptyResources() {
+    SingleRequest<List> request = builder.build();
+    when(builder.resource.get()).thenReturn(null);
+
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+
+    assertTrue(request.isFailed());
+    verify(builder.engine).release(eq(builder.resource));
+    verify(builder.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean());
+  }
+
+  @Test
+  public void testCanHandleNonConformingResources() {
+    SingleRequest<List> request = builder.build();
+    when(((Resource) (builder.resource)).get())
+        .thenReturn("Invalid mocked String, this should be a List");
+
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    assertTrue(request.isFailed());
+    verify(builder.engine).release(eq(builder.resource));
+    verify(builder.requestListener).onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean());
+  }
+
+  @Test
+  public void testIsNotFailedAfterClear() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
+    request.clear();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsPausedAfterPause() {
+    SingleRequest<List> request = builder.build();
+    request.pause();
+
+    assertTrue(request.isPaused());
+  }
+
+  @Test
+  public void testIsNotCancelledAfterPause() {
+    SingleRequest<List> request = builder.build();
+    request.pause();
+
+    assertFalse(request.isCancelled());
+  }
+
+  @Test
+  public void testIsNotPausedAfterBeginningWhilePaused() {
+    SingleRequest<List> request = builder.build();
+    request.pause();
+    request.begin();
+
+    assertFalse(request.isPaused());
+    assertTrue(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotFailedAfterBegin() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(null, DataSource.DATA_DISK_CACHE);
+    request.begin();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsCompleteAfterReceivingResource() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    assertTrue(request.isComplete());
+  }
+
+  @Test
+  public void testIsNotCompleteAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+    request.clear();
+
+    assertFalse(request.isComplete());
+  }
+
+  @Test
+  public void testIsCancelledAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    assertTrue(request.isCancelled());
+  }
+
+  @Test
+  public void clear_notifiesTarget() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+    request.clear();
+
+    verify(builder.target, times(1)).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void clear_doesNotNotifyTarget_ifRequestCoordinatorReturnsFalseForCanClear() {
+    when(builder.requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(false);
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target, never()).onLoadCleared(any(Drawable.class));
+  }
+
+  @Test
+  public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
+    RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
+    doAnswer(new Answer() {
+      @Override
+      public Object answer(InvocationOnMock invocation) {
+        Request request = (Request) invocation.getArguments()[0];
+        assertFalse(request.isComplete());
+        return true;
+      }
+    }).when(requestCoordinator).canSetImage(any(Request.class));
+
+    SingleRequest<List> request = builder
+        .setRequestCoordinator(requestCoordinator)
+        .build();
+
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(requestCoordinator).canSetImage(eq(request));
+  }
+
+  @Test
+  public void testIsNotFailedWithoutException() {
+    SingleRequest<List> request = builder.build();
+
+    assertFalse(request.isFailed());
+  }
+
+  @Test
+  public void testIsFailedAfterException() {
+    SingleRequest<List> request = builder.build();
+
+    request.onLoadFailed(new GlideException("test"));
+    assertTrue(request.isFailed());
+  }
+
+  @Test
+  public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.onSizeReady(100, 100);
+    request.onSizeReady(100, 100);
+
+    verify(builder.engine, times(1))
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            eq(100),
+            eq(100),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testIsFailedAfterNoResultAndNullException() {
+    SingleRequest<List> request = builder.build();
+
+    request.onLoadFailed(new GlideException("test"));
+    assertTrue(request.isFailed());
+  }
+
+  @Test
+  public void testEngineLoadCancelledOnCancel() {
+    Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
+
+    when(builder.engine
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
+        .thenReturn(loadStatus);
+
+    SingleRequest<List> request = builder.build();
+    request.begin();
+
+    request.onSizeReady(100, 100);
+    request.cancel();
+
+    verify(loadStatus).cancel();
+  }
+
+  @Test
+  public void testResourceIsRecycledOnClear() {
+    SingleRequest<List> request = builder.build();
+
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+    request.clear();
+
+    verify(builder.engine).release(eq(builder.resource));
+  }
+
+  @Test
+  public void testPlaceholderDrawableIsSet() {
+    Drawable expected = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setPlaceholderDrawable(expected)
+        .setTarget(target)
+        .build();
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(expected);
+  }
+
+  @Test
+  public void testErrorDrawableIsSetOnLoadFailed() {
+    Drawable expected = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setErrorDrawable(expected)
+        .setTarget(target)
+        .build();
+
+    request.onLoadFailed(new GlideException("test"));
+
+    assertThat(target.currentPlaceholder).isEqualTo(expected);
+  }
+
+  @Test
+  public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setErrorDrawable(placeholder)
+        .setTarget(target)
+        .setModel(null)
+        .build();
+
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(placeholder);
+  }
+
+  @Test
+  public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
+
+    MockTarget target = new MockTarget();
+
+    SingleRequest<List> request = builder
+        .setPlaceholderDrawable(placeholder)
+        .setErrorDrawable(errorPlaceholder)
+        .setTarget(target)
+        .setModel(null)
+        .build();
+
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(errorPlaceholder);
+  }
+
+
+  @Test
+  public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
+    Drawable placeholder = new ColorDrawable(Color.RED);
+    Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
+    Drawable fallback = new ColorDrawable(Color.BLUE);
+
+    MockTarget target = new MockTarget();
+    SingleRequest<List> request = builder
+        .setPlaceholderDrawable(placeholder)
+        .setErrorDrawable(errorPlaceholder)
+        .setFallbackDrawable(fallback)
+        .setTarget(target)
+        .setModel(null)
+        .build();
+    request.begin();
+
+    assertThat(target.currentPlaceholder).isEqualTo(fallback);
+  }
+
+
+  @Test
+  public void testIsNotRunningBeforeRunCalled() {
+    assertFalse(builder.build().isRunning());
+  }
+
+  @Test
+  public void testIsRunningAfterRunCalled() {
+    Request request = builder.build();
+    request.begin();
+    assertTrue(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterComplete() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterFailing() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.onLoadFailed(new GlideException("test"));
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testIsNotRunningAfterClear() {
+    SingleRequest<List> request = builder.build();
+    request.begin();
+    request.clear();
+
+    assertFalse(request.isRunning());
+  }
+
+  @Test
+  public void testCallsTargetOnResourceReadyIfNoRequestListener() {
+    SingleRequest<List> request = builder
+        .setRequestListener(null)
+        .build();
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.target).onResourceReady(eq(builder.result), anyTransition());
+  }
+
+  @Test
+  public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestListener
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean())).thenReturn(false);
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.target).onResourceReady(eq(builder.result), anyTransition());
+  }
+
+  @Test
+  public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestListener
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean())).thenReturn(true);
+    request.onResourceReady(builder.resource, DataSource.REMOTE);
+
+    verify(builder.target, never()).onResourceReady(any(List.class), anyTransition());
+  }
+
+  @Test
+  public void testCallsTargetOnExceptionIfNoRequestListener() {
+    SingleRequest<List> request = builder
+        .setRequestListener(null)
+        .build();
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target).onLoadFailed(eq(builder.errorDrawable));
+  }
+
+  @Test
+  public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean()))
+        .thenReturn(false);
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target).onLoadFailed(eq(builder.errorDrawable));
+  }
+
+  @Test
+  public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestListener.onLoadFailed(isAGlideException(), any(Number.class),
+        eq(builder.target), anyBoolean()))
+        .thenReturn(true);
+
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target, never()).onLoadFailed(any(Drawable.class));
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithResourceResult() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithModel() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(any(List.class), eq(builder.model), isAListTarget(), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithTarget() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(any(List.class), any(Number.class), eq(builder.target), isADataSource(),
+            anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
+    final SingleRequest<List> request = builder.build();
+
+    when(builder.engine
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
+        .thenAnswer(new Answer<Object>() {
+          @Override
+          public Object answer(InvocationOnMock invocation) {
+            request.onResourceReady(builder.resource, DataSource.MEMORY_CACHE);
+            return null;
+          }
+        });
+
+    request.begin();
+    request.onSizeReady(100, 100);
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
+            eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void
+  testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
+    SingleRequest<List> request = builder.build();
+    request.onSizeReady(100, 100);
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
+            eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
+    SingleRequest<List> request = builder
+        .setRequestCoordinator(null)
+        .build();
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
+            eq(true));
+  }
+
+  @Test
+  public void testRequestListenerIsCalledWithFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestCoordinator.isAnyResourceSet()).thenReturn(false);
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(), isADataSource(),
+            eq(true));
+  }
+
+  @Test
+  public void
+  testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
+    SingleRequest<List> request = builder.build();
+    when(builder.requestCoordinator.isAnyResourceSet()).thenReturn(true);
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.requestListener)
+        .onResourceReady(eq(builder.result), any(Number.class), isAListTarget(),
+            isADataSource(), eq(false));
+  }
+
+  @Test
+  public void testTargetIsCalledWithAnimationFromFactory() {
+    SingleRequest<List> request = builder.build();
+    Transition<List> transition = mockTransition();
+    when(builder.transitionFactory.build(any(DataSource.class), anyBoolean()))
+        .thenReturn(transition);
+    request.onResourceReady(builder.resource, DataSource.DATA_DISK_CACHE);
+
+    verify(builder.target).onResourceReady(eq(builder.result), eq(transition));
+  }
+
+  @Test
+  public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(-1)
+        .setOverrideHeight(100)
+        .build();
+    request.begin();
+
+    verify(builder.target).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(100)
+        .setOverrideHeight(-1)
+        .build();
+    request.begin();
+
+    verify(builder.target).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(100)
+        .setOverrideHeight(100)
+        .build();
+    request.begin();
+
+    verify(builder.target, never()).getSize(any(SizeReadyCallback.class));
+  }
+
+  @Test
+  public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
+    SingleRequest<List> request = builder
+        .setOverrideWidth(1)
+        .setOverrideHeight(2)
+        .build();
+    request.begin();
+
+    verify(builder.engine)
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
+    SingleRequest<List> request = builder
+        .setErrorDrawable(new ColorDrawable(Color.RED))
+        .build();
+    when(builder.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
+    request.onLoadFailed(new GlideException("test"));
+
+    verify(builder.target, never()).onLoadFailed(any(Drawable.class));
+  }
+
+  @Test
+  public void testCanReRunCancelledRequests() {
+    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    when(builder.engine
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            eq(100),
+            eq(100),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
+        .thenAnswer(new CallResourceCallback(builder.resource));
+    SingleRequest<List> request = builder.build();
+
+    request.begin();
+    request.cancel();
+    request.begin();
+
+    verify(builder.target, times(2)).onResourceReady(eq(builder.result), anyTransition());
+  }
+
+  @Test
+  public void testResourceOnlyReceivesOneGetOnResourceReady() {
+    SingleRequest<List> request = builder.build();
+    request.onResourceReady(builder.resource, DataSource.LOCAL);
+
+    verify(builder.resource, times(1)).get();
+  }
+
+  @Test
+  public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
+    SingleRequest<List> request = builder.build();
+    request.cancel();
+    request.onSizeReady(100, 100);
+
+    verify(builder.engine, never())
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+
+  @Test
+  public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    SingleRequest<List> request = builder
+        .setUseUnlimitedSourceGeneratorsPool(true)
+        .build();
+    request.begin();
+
+    verify(builder.engine)
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            eq(true),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testCallsSourceExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(builder.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    SingleRequest<List> request = builder
+        .setUseUnlimitedSourceGeneratorsPool(false)
+        .build();
+    request.begin();
+
+    verify(builder.engine)
+        .load(
+            eq(builder.glideContext),
+            eq(builder.model),
+            eq(builder.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(builder.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            eq(false),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  // Varargs
+  @SuppressWarnings("unchecked")
+  public void testIsEquivalentTo() {
+    EquivalenceTester<SingleRequestBuilder> tester = EquivalenceTester
+        .of(new Equivalence<SingleRequestBuilder>() {
+          @Override
+          protected boolean doEquivalent(
+              @NonNull SingleRequestBuilder a, @NonNull SingleRequestBuilder b) {
+            return a.build().isEquivalentTo(b.build()) && b.build().isEquivalentTo(a.build());
+          }
+
+          @Override
+          protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
+            return 0;
+          }
+        });
+    tester
+        .addEquivalenceGroup(
+            new SingleRequestBuilder(),
+            new SingleRequestBuilder(),
+            // Non-null request listeners are treated as equivalent, even if they're not equal.
+            new SingleRequestBuilder().setRequestListener(mock(RequestListener.class)))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setRequestListener(null),
+            new SingleRequestBuilder().setRequestListener(null))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setOverrideHeight(500),
+            new SingleRequestBuilder().setOverrideHeight(500))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setOverrideWidth(500),
+            new SingleRequestBuilder().setOverrideWidth(500))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setModel(12345),
+            new SingleRequestBuilder().setModel(12345))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setModel(null),
+            new SingleRequestBuilder().setModel(null))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setErrorDrawable(new ColorDrawable(Color.GRAY)),
+            new SingleRequestBuilder().setErrorDrawable(new ColorDrawable(Color.GRAY)))
+        .addEquivalenceGroup(
+            new SingleRequestBuilder().setPriority(Priority.LOW),
+            new SingleRequestBuilder().setPriority(Priority.LOW))
+        .test();
+  }
+
+  static final class SingleRequestBuilder {
+    private Engine engine = mock(Engine.class);
+    private Number model = 123456;
+    @SuppressWarnings("unchecked")
+    private Target<List> target = mock(Target.class);
+    private Resource<List> resource = mockResource();
+    private RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
+    private Drawable placeholderDrawable = null;
+    private Drawable errorDrawable = null;
+    private Drawable fallbackDrawable = null;
+    @SuppressWarnings("unchecked")
+    private RequestListener<List> requestListener = mock(RequestListener.class);
+    @SuppressWarnings("unchecked")
+    private final TransitionFactory<List> transitionFactory = mock(TransitionFactory.class);
+    private int overrideWidth = -1;
+    private int overrideHeight = -1;
+    private List<?> result = new ArrayList<>();
+    private final GlideContext glideContext = mock(GlideContext.class);
+    private final Key signature = new ObjectKey(12345);
+    private Priority priority = Priority.HIGH;
+    private boolean useUnlimitedSourceGeneratorsPool = false;
+    private final Class<List> transcodeClass = List.class;
+    private final Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+
+    SingleRequestBuilder() {
+      when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
+      when(requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(true);
+      when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
+      when(resource.get()).thenReturn(result);
+    }
+
+    SingleRequestBuilder setEngine(Engine engine) {
+      this.engine = engine;
+      return this;
+    }
+
+    SingleRequestBuilder setModel(Number model) {
+      this.model = model;
+      return this;
+    }
+
+    SingleRequestBuilder setTarget(Target<List> target) {
+      this.target = target;
+      return this;
+    }
+
+    SingleRequestBuilder setResource(Resource<List> resource) {
+      this.resource = resource;
+      return this;
+    }
+
+    SingleRequestBuilder setRequestCoordinator(RequestCoordinator requestCoordinator) {
+      this.requestCoordinator = requestCoordinator;
+      return this;
+    }
+
+    SingleRequestBuilder setPlaceholderDrawable(Drawable placeholderDrawable) {
+      this.placeholderDrawable = placeholderDrawable;
+      return this;
+    }
+
+    SingleRequestBuilder setErrorDrawable(Drawable errorDrawable) {
+      this.errorDrawable = errorDrawable;
+      return this;
+    }
+
+    SingleRequestBuilder setFallbackDrawable(Drawable fallbackDrawable) {
+      this.fallbackDrawable = fallbackDrawable;
+      return this;
+    }
+
+    SingleRequestBuilder setRequestListener(RequestListener<List> requestListener) {
+      this.requestListener = requestListener;
+      return this;
+    }
+
+    SingleRequestBuilder setOverrideWidth(int overrideWidth) {
+      this.overrideWidth = overrideWidth;
+      return this;
+    }
+
+    SingleRequestBuilder setOverrideHeight(int overrideHeight) {
+      this.overrideHeight = overrideHeight;
+      return this;
+    }
+
+    SingleRequestBuilder setResult(List<?> result) {
+      this.result = result;
+      return this;
+    }
+
+    SingleRequestBuilder setPriority(Priority priority) {
+      this.priority = priority;
+      return this;
+    }
+
+    SingleRequestBuilder setUseUnlimitedSourceGeneratorsPool(
+        boolean useUnlimitedSourceGeneratorsPool) {
+      this.useUnlimitedSourceGeneratorsPool = useUnlimitedSourceGeneratorsPool;
+      return this;
+    }
+
+    SingleRequest<List> build() {
+      RequestOptions requestOptions = new RequestOptions()
+          .error(errorDrawable)
+          .placeholder(placeholderDrawable)
+          .fallback(fallbackDrawable)
+          .override(overrideWidth, overrideHeight)
+          .priority(priority)
+          .signature(signature)
+          .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
+      return SingleRequest.obtain(
+          /*context=*/glideContext,
+          /*glideContext=*/glideContext,
+          model,
+          transcodeClass,
+          requestOptions,
+          overrideWidth,
+          overrideHeight,
+          priority,
+          target,
+          /*targetListener=*/ null,
+          requestListener,
+          requestCoordinator,
+          engine,
+          transitionFactory);
+    }
+  }
+
+  // TODO do we want to move these to Util?
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> mockTransition() {
+    return mock(Transition.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Target<List> isAListTarget() {
+    return isA(Target.class);
+  }
+
+  private static GlideException isAGlideException() {
+    return isA(GlideException.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Transition<T> anyTransition() {
+    return any(Transition.class);
+  }
+
+  private static class CallResourceCallback implements Answer {
+
+    private final Resource resource;
+
+    CallResourceCallback(Resource resource) {
+      this.resource = resource;
+    }
+
+    @Override
+    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      ResourceCallback cb =
+          (ResourceCallback) invocationOnMock.getArguments()[
+              invocationOnMock.getArguments().length
+                  - 1];
+      cb.onResourceReady(resource, DataSource.REMOTE);
+      return null;
+    }
+  }
+
+  private static class CallSizeReady implements Answer {
+
+    private final int width;
+    private final int height;
+
+    CallSizeReady(int width, int height) {
+      this.width = width;
+      this.height = height;
+    }
+
+    @Override
+    public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      SizeReadyCallback cb = (SizeReadyCallback) invocationOnMock.getArguments()[0];
+      cb.onSizeReady(width, height);
+      return null;
+    }
+  }
+
+  private static class MockTarget implements Target<List> {
+
+    private Drawable currentPlaceholder;
+
+    @Override
+    public void onLoadCleared(@Nullable Drawable placeholder) {
+      currentPlaceholder = placeholder;
+    }
+
+    @Override
+    public void onLoadStarted(@Nullable Drawable placeholder) {
+      currentPlaceholder = placeholder;
+
+    }
+
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      currentPlaceholder = errorDrawable;
+
+    }
+
+    @Override
+    public void onResourceReady(@NonNull List resource,
+        @Nullable Transition<? super List> transition) {
+      currentPlaceholder = null;
+    }
+
+
+    @Override
+    public void getSize(@NonNull SizeReadyCallback cb) {
+    }
+
+    @Override
+    public void removeCallback(@NonNull SizeReadyCallback cb) {
+      // Do nothing.
+    }
+
+    @Override
+    public void setRequest(@Nullable Request request) {
+    }
+
+    @Nullable
+    @Override
+    public Request getRequest() {
+      return null;
+    }
+
+    @Override
+    public void onStart() {
+    }
+
+    @Override
+    public void onStop() {
+
+    }
+
+    @Override
+    public void onDestroy() {
+
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
similarity index 77%
rename from library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index 0b982933f..4850a2d01 100644
--- a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.request;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -16,21 +16,21 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 @RunWith(JUnit4.class)
 public class ThumbnailRequestCoordinatorTest {
-  private Request full;
-  private Request thumb;
+  @Mock private Request full;
+  @Mock private Request thumb;
+  @Mock private RequestCoordinator parent;
   private ThumbnailRequestCoordinator coordinator;
-  private RequestCoordinator parent;
 
   @Before
   public void setUp() {
-    full = mock(Request.class);
-    thumb = mock(Request.class);
-    parent = mock(RequestCoordinator.class);
+    MockitoAnnotations.initMocks(this);
     coordinator = new ThumbnailRequestCoordinator();
     coordinator.setRequests(full, thumb);
   }
@@ -85,6 +85,33 @@ public void testDoesNotStartThumbOnRunIfRunning() {
     verify(thumb, never()).begin();
   }
 
+  @Test
+  public void begin_whenFullIsComplete_startsFull() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    verify(full).begin();
+  }
+
+  @Test
+  public void begin_whenFullIsComplete_doesNotBeginThumb() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    verify(thumb, never()).begin();
+  }
+
+  @Test
+  public void begin_whenFullIsComplete_doesNotSetRunning() {
+    when(full.isComplete()).thenReturn(true);
+
+    coordinator.begin();
+
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
   @Test
   public void testDoesNotStartFullIfClearedByThumb() {
     doAnswer(new Answer<Void>() {
@@ -317,9 +344,9 @@ public void testDoesNotClearThumbOnThumbRequestComplete() {
 
   @Test
   public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
-      when(thumb.isComplete()).thenReturn(true);
-      coordinator.onRequestSuccess(full);
-      verify(thumb, never()).clear();
+    when(thumb.isComplete()).thenReturn(true);
+    coordinator.onRequestSuccess(full);
+    verify(thumb, never()).clear();
   }
 
   @Test
@@ -330,4 +357,51 @@ public void testDoesNotNotifyParentOnThumbRequestComplete() {
 
     verify(parent, never()).onRequestSuccess(any(Request.class));
   }
+
+  @Test
+  public void canNotifyCleared_withThumbRequest_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(thumb)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_andNullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanClear_returnsTrue() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanNotClear_returnsFalse() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    assertThat(coordinator.canNotifyCleared(full)).isFalse();
+  }
+
+  @Test
+  public void testIsEquivalentTo() {
+    ThumbnailRequestCoordinator first = new ThumbnailRequestCoordinator();
+    when(full.isEquivalentTo(full)).thenReturn(true);
+    when(thumb.isEquivalentTo(thumb)).thenReturn(true);
+    first.setRequests(full, thumb);
+    assertTrue(first.isEquivalentTo(first));
+
+    ThumbnailRequestCoordinator second = new ThumbnailRequestCoordinator();
+    second.setRequests(full, full);
+    assertTrue(second.isEquivalentTo(second));
+    assertFalse(second.isEquivalentTo(first));
+    assertFalse(first.isEquivalentTo(second));
+
+    ThumbnailRequestCoordinator third = new ThumbnailRequestCoordinator();
+    third.setRequests(thumb, thumb);
+    assertTrue(third.isEquivalentTo(third));
+    assertFalse(third.isEquivalentTo(first));
+    assertFalse(first.isEquivalentTo(third));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
similarity index 80%
rename from library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index 8a13ace4b..a9a8ffe6e 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -10,7 +10,6 @@
 import android.content.ComponentName;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,22 +18,20 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowAppWidgetManager;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = AppWidgetTargetTest
     .UpdateShadowAppWidgetManager.class)
 public class AppWidgetTargetTest {
-
   private UpdateShadowAppWidgetManager shadowManager;
   private RemoteViews views;
   private int viewId;
 
   @Before
   public void setUp() {
-    shadowManager = (UpdateShadowAppWidgetManager) ShadowExtractor
-        .extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
+    shadowManager = Shadow.extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
     viewId = 1234;
     views = mock(RemoteViews.class);
   }
@@ -43,7 +40,7 @@ public void setUp() {
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName() {
     ComponentName componentName = mock(ComponentName.class);
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     target.onResourceReady(bitmap, null /*glideAnimation*/);
@@ -55,7 +52,7 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName()
   public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
     ComponentName componentName = mock(ComponentName.class);
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
     target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
     /*glideAnimation*/);
@@ -68,7 +65,7 @@ public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
     int[] widgetIds = new int[] { 1 };
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
     Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
     target.onResourceReady(bitmap, null /*glideAnimation*/);
@@ -80,7 +77,7 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
   public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
     int[] widgetIds = new int[] { 1 };
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
     target.onResourceReady(Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null
     /*glideAnimation*/);
@@ -91,48 +88,49 @@ public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullContextWithWidgetIds() {
-    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, 1 /*widgetIds*/);
+    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullContextWithComponentName() {
-    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, mock(ComponentName.class));
+    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId, 1
-    /*widgetIds*/);
+    new AppWidgetTarget(RuntimeEnvironment.application,
+        viewId, null /*remoteViews*/, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId,
-        mock(ComponentName.class));
+    new AppWidgetTarget(RuntimeEnvironment.application,
+        viewId, null /*remoteViews*/, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (int[]) null /*widgetIds*/);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (int[]) null /*widgetIds*/);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsWhenGivenEmptyWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (ComponentName) null);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (ComponentName) null);
   }
 
   @Implements(AppWidgetManager.class)
   public static class UpdateShadowAppWidgetManager extends ShadowAppWidgetManager {
-    public int[] updatedWidgetIds;
-    public RemoteViews updatedRemoteViews;
-    public ComponentName updatedComponentName;
+    int[] updatedWidgetIds;
+    RemoteViews updatedRemoteViews;
+    ComponentName updatedComponentName;
 
     @Implementation
+    @Override
     public void updateAppWidget(int[] appWidgetIds, RemoteViews views) {
       updatedWidgetIds = appWidgetIds;
       updatedRemoteViews = views;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
index 7689e0d9a..31e0bb5c6 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
@@ -5,7 +5,6 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
similarity index 95%
rename from library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
index 238151560..d0967ce08 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
@@ -8,7 +8,6 @@
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -41,7 +40,7 @@ public void testReturnsTargetForBitmapDrawables() {
     BitmapDrawable drawable = new BitmapDrawable(RuntimeEnvironment.application.getResources(),
         Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
 
-    Target target = factory.buildTarget(view, BitmapDrawable.class);
+    Target<BitmapDrawable> target = factory.buildTarget(view, BitmapDrawable.class);
     target.onResourceReady(drawable, null);
     assertThat(target).isInstanceOf(DrawableImageViewTarget.class);
   }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
similarity index 65%
rename from library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
index c734c8baf..336a0ee29 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -4,20 +4,24 @@
 import static org.junit.Assert.assertNull;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Color;
+import android.graphics.drawable.Animatable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
-
 import com.bumptech.glide.request.transition.Transition;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -26,12 +30,15 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class ImageViewTargetTest {
 
+  @Mock private AnimatedDrawable animatedDrawable;
   private ImageView view;
   private TestTarget target;
   private ColorDrawable drawable;
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
     view = new ImageView(RuntimeEnvironment.application);
     target = new TestTarget(view);
     drawable = new ColorDrawable(Color.RED);
@@ -74,7 +81,7 @@ public void testSetsDrawableOnLoadCleared() {
 
   @Test
   public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
-    Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(any(Drawable.class), eq(target))).thenReturn(false);
     Drawable resource = new ColorDrawable(Color.GRAY);
     target.onResourceReady(resource, animation);
@@ -85,7 +92,7 @@ public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
   @Test
   public void testDoesNotSetDrawableOnViewInOnResourceReadyWhenAnimationReturnsTrue() {
     Drawable resource = new ColorDrawable(Color.RED);
-    Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(eq(resource), eq(target))).thenReturn(true);
     target.onResourceReady(resource, animation);
 
@@ -97,23 +104,51 @@ public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
     Drawable placeholder = new ColorDrawable(Color.BLACK);
     view.setImageDrawable(placeholder);
 
-    Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
 
     target.onResourceReady(new ColorDrawable(Color.GREEN), animation);
 
     verify(animation).transition(eq(placeholder), eq(target));
   }
 
-  private static class TestTarget extends ImageViewTarget<Drawable> {
+  @Test
+  public void onResourceReady_withAnimatableResource_startsAnimatableAfterSetResource() {
+    AnimatedDrawable drawable = mock(AnimatedDrawable.class);
+    ImageView view = mock(ImageView.class);
+    target = new TestTarget(view);
+    target.onResourceReady(drawable, /*transition=*/ null);
+
+    InOrder order = inOrder(view, drawable);
+    order.verify(view).setImageDrawable(drawable);
+    order.verify(drawable).start();
+  }
+
+  @Test
+  public void onLoadCleared_withAnimatableDrawable_stopsDrawable() {
+    target.onResourceReady(animatedDrawable, /*transition=*/ null);
+    verify(animatedDrawable).start();
+    verify(animatedDrawable, never()).stop();
+
+    target.onLoadCleared(/*placeholder=*/ null);
+
+    verify(animatedDrawable).stop();
+  }
+
+  private abstract static class AnimatedDrawable extends Drawable implements Animatable {
+    // Intentionally empty.
+  }
+
+  private static final class TestTarget extends ImageViewTarget<Drawable> {
     public Drawable resource;
 
-    public TestTarget(ImageView view) {
+    TestTarget(ImageView view) {
       super(view);
     }
 
     @Override
     protected void setResource(Drawable resource) {
       this.resource = resource;
+      view.setImageDrawable(resource);
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
similarity index 64%
rename from library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index 1a0dfc8d1..d1c51da32 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -10,7 +10,6 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,36 +18,38 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowNotificationManager;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = NotificationTargetTest
     .UpdateShadowNotificationManager.class)
 public class NotificationTargetTest {
-
   private UpdateShadowNotificationManager shadowManager;
   private RemoteViews remoteViews;
   private int viewId;
   private Notification notification;
   private int notificationId;
+  private String notificationTag;
   private NotificationTarget target;
 
   @Before
   public void setUp() {
-    NotificationManager notificationManager = (NotificationManager) RuntimeEnvironment.application
-        .getSystemService(Context.NOTIFICATION_SERVICE);
-    shadowManager = (UpdateShadowNotificationManager) ShadowExtractor.extract(notificationManager);
+    NotificationManager notificationManager =
+        (NotificationManager)
+            RuntimeEnvironment.application.getSystemService(Context.NOTIFICATION_SERVICE);
+    shadowManager = Shadow.extract(notificationManager);
 
     remoteViews = mock(RemoteViews.class);
     viewId = 123;
     notification = mock(Notification.class);
     notificationId = 456;
+    notificationTag = "tag";
 
 
     target =
-        new NotificationTarget(RuntimeEnvironment.application, remoteViews, viewId, 100 /*width*/,
-            100 /*height*/, notification, notificationId);
+        new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+            viewId, remoteViews, notification, notificationId, notificationTag);
   }
 
   @Test
@@ -64,36 +65,42 @@ public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourc
     /*glideAnimation*/);
 
     assertEquals(notificationId, shadowManager.updatedNotificationId);
+    assertEquals(notificationTag, shadowManager.updatedNotificationTag);
     assertEquals(notification, shadowManager.updatedNotification);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new NotificationTarget(null /*context*/, mock(RemoteViews.class), 123 /*viewId*/, 100 /*width*/,
-        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    new NotificationTarget(null /*context*/, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, mock(RemoteViews.class), mock(Notification.class), 456 /*notificationId*/,
+        "tag" /*notificationTag*/);
   }
 
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfNotificationIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, mock(RemoteViews.class), 123 /*viewId*/,
-        100 /*width*/, 100 /*height*/, null /*notification*/, 456 /*notificationId*/);
+    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, mock(RemoteViews.class), null /*notification*/, 456 /*notificationId*/,
+        "tag" /*notificationTag*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfRemoteViewsIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, null /*remoteViews*/, 123 /*viewId*/,
-        100 /*width*/,
-        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, null /*remoteViews*/, mock(Notification.class), 456 /*notificationId*/,
+        "tag" /*notificationTag*/);
   }
 
   @Implements(NotificationManager.class)
   public static class UpdateShadowNotificationManager extends ShadowNotificationManager {
     int updatedNotificationId;
+    String updatedNotificationTag;
     Notification updatedNotification;
 
     @Implementation
-    public void notify(int notificationId, Notification notification) {
+    @Override
+    public void notify(String notificationTag, int notificationId, Notification notification) {
+      updatedNotificationTag = notificationTag;
       updatedNotificationId = notificationId;
       updatedNotification = notification;
     }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
similarity index 96%
rename from library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
index 5a6674534..c3435319f 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
@@ -6,7 +6,6 @@
 
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.request.Request;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,7 +18,7 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class PreloadTargetTest {
 
-  @Mock RequestManager requestManager;
+  @Mock private RequestManager requestManager;
 
   @Before
   public void setUp() {
diff --git a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
index 4ceda7c64..3093df1fb 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
@@ -2,8 +2,9 @@
 
 import static org.mockito.Mockito.mock;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.transition.Transition;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -33,7 +34,13 @@ public void testThrowsOnGetSizeIfGivenHeightIsEqualToZero() {
 
   @Test
   public void testCanBeConstructedWithoutDimensions() {
-    getTarget();
+    new SimpleTarget<Object>() {
+      @Override
+      public void onResourceReady(@NonNull Object resource,
+          @Nullable Transition<? super Object> transition) {
+        // Do nothing.
+      }
+    };
   }
 
   @Test
@@ -46,19 +53,11 @@ public void testGetSizeDoesNotThrowWithSizeOriginal() {
     getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).getSize(mock(SizeReadyCallback.class));
   }
 
-  private SimpleTarget<Object> getTarget() {
-    return new SimpleTarget<Object>() {
-      @Override
-      public void onResourceReady(Object resource, Transition<? super Object> transition) {
-        // Do nothing.
-      }
-    };
-  }
-
   private SimpleTarget<Object> getTarget(int width, int height) {
     return new SimpleTarget<Object>(width, height) {
       @Override
-      public void onResourceReady(Object resource, Transition<? super Object> transition) {
+      public void onResourceReady(@NonNull Object resource,
+          @Nullable Transition<? super Object> transition) {
         // Do nothing.
       }
     };
diff --git a/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
new file mode 100644
index 000000000..69b694138
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -0,0 +1,835 @@
+package com.bumptech.glide.request.target;
+
+import static android.view.ViewGroup.LayoutParams;
+import static android.view.ViewTreeObserver.OnPreDrawListener;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.tests.Util;
+import com.bumptech.glide.util.Preconditions;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.ShadowDisplay;
+import org.robolectric.shadows.ShadowView;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 19, shadows = { ViewTargetTest.SizedShadowView.class,
+    ViewTargetTest.PreDrawShadowViewTreeObserver.class })
+public class ViewTargetTest {
+  private View view;
+  private ViewTarget<View, Object> target;
+  private SizedShadowView shadowView;
+  private PreDrawShadowViewTreeObserver shadowObserver;
+  @Mock private SizeReadyCallback cb;
+  @Mock private Request request;
+  private int sdkVersion;
+  private AttachStateTarget attachStateTarget;
+
+  @Before
+  public void setUp() {
+    sdkVersion = Build.VERSION.SDK_INT;
+    MockitoAnnotations.initMocks(this);
+    view = new View(RuntimeEnvironment.application);
+    target = new TestViewTarget(view);
+    attachStateTarget = new AttachStateTarget(view);
+
+    shadowView = Shadow.extract(view);
+    shadowObserver = Shadow.extract(view.getViewTreeObserver());
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(sdkVersion);
+    ViewTarget.SizeDeterminer.maxDisplayLength = null;
+  }
+
+  @Test
+  public void testReturnsWrappedView() {
+    assertEquals(view, target.getView());
+  }
+
+  @Test
+  public void testReturnsNullFromGetRequestIfNoRequestSet() {
+    assertNull(target.getRequest());
+  }
+
+  @Test(expected = IllegalArgumentException.class)
+  public void testThrowsIfViewTagIsNotRequestObject() {
+    view.setTag(new Object());
+    target.getRequest();
+  }
+
+  @Test
+  public void testCanSetAndRetrieveRequest() {
+    target.setRequest(request);
+
+    assertEquals(request, target.getRequest());
+  }
+
+  @Test
+  public void testRetrievesRequestFromPreviousTargetForView() {
+    target.setRequest(request);
+
+    ViewTarget<View, Object> second = new TestViewTarget(view);
+
+    assertEquals(request, second.getRequest());
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
+    int dimens = 333;
+    shadowView
+        .setWidth(dimens)
+        .setHeight(dimens)
+        .setIsLaidOut(true);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet() {
+    int dimens = 444;
+    LayoutParams layoutParams = new LayoutParams(dimens, dimens);
+    view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  @Test
+  public void getSize_withBothWrapContent_usesDisplayDimens() {
+    LayoutParams layoutParams =
+        new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
+
+    setDisplayDimens(200, 300);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(300, 300);
+  }
+
+  @Test
+  public void getSize_withWrapContentWidthAndValidHeight_usesDisplayDimenAndValidHeight() {
+    int height = 100;
+    LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
+    view.setLayoutParams(params);
+    shadowView.setIsLaidOut(true);
+
+    setDisplayDimens(100, 200);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(200, height);
+  }
+
+  @Test
+  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndDisplayDimen() {
+    int width = 100;
+    LayoutParams params = new LayoutParams(width, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+    shadowView.setIsLaidOut(true);
+
+    setDisplayDimens(200, 100);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(width, 200);
+  }
+
+  @Test
+  public void getSize_withWrapContentWidthAndMatchParentHeight_usesDisplayDimenWidthAndHeight() {
+    LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(500, 600);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int height = 32;
+    shadowView
+        .setHeight(height)
+        .setIsLaidOut(true);
+
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(600, height);
+  }
+
+  @Test
+  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndDisplayDimenHeight() {
+    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(300, 400);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+
+    int width = 32;
+    shadowView
+        .setWidth(width)
+        .setIsLaidOut(true);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(width, 400);
+  }
+
+  @Test
+  public void testMatchParentWidthAndHeight() {
+    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int width = 32;
+    int height = 45;
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
+    target.getSize(cb);
+
+    int width = 12;
+    int height = 32;
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testSizeCallbacksAreCalledInOrderPreDraw() {
+    SizeReadyCallback[] cbs = new SizeReadyCallback[25];
+    for (int i = 0; i < cbs.length; i++) {
+      cbs[i] = mock(SizeReadyCallback.class);
+      target.getSize(cbs[i]);
+    }
+
+    int width = 100, height = 111;
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
+    shadowObserver.fireOnPreDrawListeners();
+
+    InOrder order = inOrder((Object[]) cbs);
+    for (SizeReadyCallback cb : cbs) {
+      order.verify(cb).onSizeReady(eq(width), eq(height));
+    }
+  }
+
+  @Test
+  public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
+    target.getSize(cb);
+    target.getSize(cb);
+
+    view.setLayoutParams(new LayoutParams(100, 100));
+    shadowView.setIsLaidOut(true);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testDoesNotAddMultipleListenersIfMultipleCallbacksAreAdded() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+    target.getSize(cb2);
+    assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
+  }
+
+  @Test
+  public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+
+    view.setLayoutParams(new LayoutParams(100, 100));
+    shadowView.setIsLaidOut(true);
+    shadowObserver.fireOnPreDrawListeners();
+
+    assertThat(shadowObserver.getPreDrawListeners()).hasSize(0);
+
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    view.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+    target.getSize(cb2);
+
+    view.setLayoutParams(new LayoutParams(100, 100));
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb2).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
+    target.getSize(cb);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+    assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
+    target.getSize(cb);
+
+    int width = 689;
+    int height = 354;
+    LayoutParams layoutParams = new LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
+    target.getSize(cb);
+
+    LayoutParams layoutParams = new LayoutParams(1234, 4123);
+    view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
+    shadowObserver.fireOnPreDrawListeners();
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
+    SizeReadyCallback firstCb = mock(SizeReadyCallback.class);
+    SizeReadyCallback secondCb = mock(SizeReadyCallback.class);
+    target.getSize(firstCb);
+    target.getSize(secondCb);
+
+    int width = 68;
+    int height = 875;
+    LayoutParams layoutParams = new LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
+    shadowObserver.fireOnPreDrawListeners();
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(firstCb, times(1)).onSizeReady(eq(width), eq(height));
+    verify(secondCb, times(1)).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
+    target.getSize(cb);
+
+    int width = 1;
+    int height = 2;
+    LayoutParams layoutParams = new LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
+    shadowObserver.setIsAlive(false);
+    shadowObserver.fireOnPreDrawListeners();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfGivenNullView() {
+    new TestViewTarget(null);
+  }
+
+  @Test
+  public void testDecreasesDimensionsByViewPadding() {
+    view.setLayoutParams(new LayoutParams(100, 100));
+    view.setPadding(25, 25, 25, 25);
+    shadowView.setIsLaidOut(true);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(50, 50);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_notLaidOut_notLayoutRequested_callsSizeReady() {
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withLayoutParams_notLaidOut_doesCallSizeReady() {
+    shadowView
+        .setLayoutParams(new LayoutParams(10, 10))
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_emptyParams_notLaidOutOrLayoutRequested_callsSizeReady() {
+    shadowView
+        .setLayoutParams(new LayoutParams(0, 0))
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeReady() {
+    Util.setSdkVersionInt(18);
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(true);
+
+    view.setPadding(50, 50, 50, 50);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  private void setDisplayDimens(Integer width, Integer height) {
+    WindowManager windowManager =
+        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
+    ShadowDisplay shadowDisplay =
+        Shadows.shadowOf(Preconditions.checkNotNull(windowManager).getDefaultDisplay());
+    if (width != null) {
+      shadowDisplay.setWidth(width);
+    }
+
+    if (height != null) {
+      shadowDisplay.setHeight(height);
+    }
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    shadowView.callOnAttachedToWindow();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withCancelledRequest_doesNotPauseRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCancelled()).thenReturn(true);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withPausedRequest_doesNotPauseRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(true);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withRunningRequest_pausesRequestOnce() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request).pause();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterOnLoadCleared_removesListener() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_moreThanOnce_registersObserverOnce() {
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach();
+
+    assertThat(shadowView.attachStateListeners).hasSize(1);
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterMultipleClearOnDetaches_removesListener() {
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach()
+        .clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterLoadCleared_doesNotPauseRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    shadowView.callOnDetachedFromWindow();
+
+    verify(request, never()).pause();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    shadowView.callOnAttachedToWindow();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withRunningRequest_doesNotBeginRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(false);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withPausedRequest_beginsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(true);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_afterLoadClearedAndRestarted_onAttach_beingsREquest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_afterLoadCleared_doesNotBeingRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isPaused()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    shadowView.callOnAttachedToWindow();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void onLoadStarted_withoutClearOnDetach_doesNotAddListener() {
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+
+    assertThat(shadowView.attachStateListeners).isEmpty();
+  }
+
+  // containsExactly does not need its result checked.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
+  @Test
+  public void onLoadCleared_withoutClearOnDetach_doesNotRemoveListeners() {
+    OnAttachStateChangeListener expected = new OnAttachStateChangeListener() {
+      @Override
+      public void onViewAttachedToWindow(View v) {
+      }
+
+      @Override
+      public void onViewDetachedFromWindow(View v) {
+      }
+    };
+    shadowView.addOnAttachStateChangeListener(expected);
+
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+
+    assertThat(shadowView.attachStateListeners).containsExactly(expected);
+  }
+
+  @Implements(ViewTreeObserver.class)
+  public static final class PreDrawShadowViewTreeObserver {
+    private final CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners =
+        new CopyOnWriteArrayList<>();
+    private boolean isAlive = true;
+
+    @SuppressWarnings("unused")
+    @Implementation
+    public void addOnPreDrawListener(OnPreDrawListener listener) {
+      checkIsAlive();
+      preDrawListeners.add(listener);
+    }
+
+    @SuppressWarnings("unused")
+    @Implementation
+    public void removeOnPreDrawListener(OnPreDrawListener listener) {
+      checkIsAlive();
+      preDrawListeners.remove(listener);
+    }
+
+    @Implementation
+    @SuppressWarnings("WeakerAccess")
+    public boolean isAlive() {
+      return isAlive;
+    }
+
+    private void checkIsAlive() {
+      if (!isAlive()) {
+        throw new IllegalStateException("ViewTreeObserver is not alive!");
+      }
+    }
+
+    void setIsAlive(@SuppressWarnings("SameParameterValue") boolean isAlive) {
+      this.isAlive = isAlive;
+    }
+
+    void fireOnPreDrawListeners() {
+      for (OnPreDrawListener listener : preDrawListeners) {
+        listener.onPreDraw();
+      }
+    }
+
+    List<OnPreDrawListener> getPreDrawListeners() {
+      return preDrawListeners;
+    }
+  }
+
+  // Shadows require stronger access and unused values.
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess", "unused"})
+  @Implements(View.class)
+  public static final class SizedShadowView extends ShadowView {
+    @RealObject private View view;
+    private int width;
+    private int height;
+    private LayoutParams layoutParams;
+    private boolean isLaidOut;
+    private boolean isLayoutRequested;
+    private final Set<OnAttachStateChangeListener> attachStateListeners = new HashSet<>();
+
+    public SizedShadowView setWidth(int width) {
+      this.width = width;
+      return this;
+    }
+
+    public SizedShadowView setHeight(int height) {
+      this.height = height;
+      return this;
+    }
+
+    @Implementation
+    public void addOnAttachStateChangeListener(OnAttachStateChangeListener listener) {
+      attachStateListeners.add(listener);
+    }
+
+    @Implementation
+    public void removeOnAttachStateChangeListener(OnAttachStateChangeListener listener) {
+      attachStateListeners.remove(listener);
+    }
+
+    @Implementation
+    public void onAttachedToWindow() {
+      for (OnAttachStateChangeListener listener : attachStateListeners) {
+        listener.onViewAttachedToWindow(view);
+      }
+    }
+
+    @Implementation
+    public void onDetachedFromWindow() {
+      for (OnAttachStateChangeListener listener : attachStateListeners) {
+        listener.onViewDetachedFromWindow(view);
+      }
+    }
+
+    @Override
+    public void callOnAttachedToWindow() {
+      super.callOnAttachedToWindow();
+    }
+
+    @Override
+    public void callOnDetachedFromWindow() {
+      super.callOnDetachedFromWindow();
+    }
+
+    @Implementation
+    public SizedShadowView setLayoutParams(LayoutParams layoutParams) {
+      this.layoutParams = layoutParams;
+      return this;
+    }
+
+    @Implementation
+    public SizedShadowView setIsLaidOut(boolean isLaidOut) {
+      this.isLaidOut = isLaidOut;
+      return this;
+    }
+
+    @Implementation
+    @Override
+    public void requestLayout() {
+      isLayoutRequested = true;
+    }
+
+    @Implementation
+    public int getWidth() {
+      return width;
+    }
+
+    @Implementation
+    public int getHeight() {
+      return height;
+    }
+
+    @Implementation
+    public boolean isLaidOut() {
+      return isLaidOut;
+    }
+
+    @Implementation
+    public boolean isLayoutRequested() {
+      return isLayoutRequested;
+    }
+
+    @Implementation
+    public LayoutParams getLayoutParams() {
+      return layoutParams;
+    }
+  }
+
+  private static final class AttachStateTarget extends ViewTarget<View, Object> {
+    AttachStateTarget(View view) {
+      super(view);
+    }
+
+    @Override
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) { }
+  }
+
+  private static final class TestViewTarget extends ViewTarget<View, Object> {
+
+    TestViewTarget(View view) {
+      super(view);
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onResourceReady(@NonNull Object resource,
+        @Nullable Transition<? super Object> transition) {
+      // Avoid calling super.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onLoadCleared(@Nullable Drawable placeholder) {
+      // Avoid calling super.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onLoadStarted(@Nullable Drawable placeholder) {
+      // Avoid calling super.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Avoid calling super.
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
similarity index 81%
rename from library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
index b6fa33ac8..e02f29e67 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
@@ -2,12 +2,9 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
-import static org.mockito.Mockito.mock;
 
 import android.graphics.drawable.Drawable;
-
 import com.bumptech.glide.load.DataSource;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,8 +20,7 @@
   @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
-    ViewAnimationFactory<Drawable> viewAnimationFactory = mock(ViewAnimationFactory.class);
-    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/);
+    factory = new DrawableCrossFadeFactory(100 /*duration*/, false /*isCrossFadeEnabled*/);
   }
 
   @Test
@@ -40,7 +36,7 @@ public void testReturnsReturnsAnimationIfNotFromMemoryCacheAndIsFirstResource()
   }
 
   @Test
-  public void testReturnsAnimationIfNotFromMemocyCacheAndNotIsFirstResource() {
+  public void testReturnsAnimationIfNotFromMemoryCacheAndNotIsFirstResource() {
     assertNotEquals(NoTransition.<Drawable>get(),
         factory.build(DataSource.DATA_DISK_CACHE, false /*isFirstResource*/));
   }
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
similarity index 64%
rename from library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index 78861713d..e89b6f8bc 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -1,10 +1,8 @@
 package com.bumptech.glide.request.transition;
 
 import static com.bumptech.glide.request.transition.Transition.ViewAdapter;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -13,8 +11,6 @@
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
-import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,13 +27,6 @@ public void setup() {
     harness = new CrossFadeHarness();
   }
 
-  @Test
-  public void testStartsDefaultAnimationIfNoPreviousDrawableIsNotSet() {
-    when(harness.adapter.getView()).thenReturn(harness.view);
-    harness.animation.transition(harness.current, harness.adapter);
-    verify(harness.defaultAnimation).transition(eq(harness.current), eq(harness.adapter));
-  }
-
   @Test
   public void testIgnoresNullViews() {
     when(harness.adapter.getView()).thenReturn(null);
@@ -45,21 +34,28 @@ public void testIgnoresNullViews() {
   }
 
   @Test
-  public void testReturnsFalseIfStartsDefaultAnimation() {
-    assertFalse(harness.animation.transition(harness.current, harness.adapter));
+  public void transition_withNonNullPreviousDrawable_setsTransitionDrawable() {
+    Drawable previous = new ColorDrawable(Color.WHITE);
+    when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
+    harness.animation.transition(harness.current, harness.adapter);
+
+    verify(harness.adapter).setDrawable(any(TransitionDrawable.class));
   }
 
   @Test
-  public void testSetsTransitionDrawableIfPreviousIsNotNull() {
-    Drawable previous = new ColorDrawable(Color.WHITE);
-    when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
+  public void transition_withNullPreviousDrawable_setsTransitionDrawable() {
     harness.animation.transition(harness.current, harness.adapter);
 
     verify(harness.adapter).setDrawable(any(TransitionDrawable.class));
   }
 
   @Test
-  public void testReturnsTrueIfSetsTransitionDrawable() {
+  public void transition_withNoCurrentDrawable_returnsTrue() {
+    assertTrue(harness.animation.transition(harness.current, harness.adapter));
+  }
+
+  @Test
+  public void transition_withCurrentDrawable_returnsTrue() {
     Drawable previous = new ColorDrawable(Color.RED);
     when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
     assertTrue(harness.animation.transition(harness.current, harness.adapter));
@@ -67,13 +63,11 @@ public void testReturnsTrueIfSetsTransitionDrawable() {
 
   @SuppressWarnings("unchecked")
   private static class CrossFadeHarness {
-    Drawable current = new ColorDrawable(Color.GRAY);
-    ViewAdapter adapter = mock(ViewAdapter.class);
-    ImageView view = mock(ImageView.class);
-    Transition<Drawable> defaultAnimation = mock(Transition.class);
-    int duration = 200;
-    DrawableCrossFadeTransition animation =
-        new DrawableCrossFadeTransition(defaultAnimation, duration);
+    final Drawable current = new ColorDrawable(Color.GRAY);
+    final ViewAdapter adapter = mock(ViewAdapter.class);
+    final int duration = 200;
+    final DrawableCrossFadeTransition animation =
+        new DrawableCrossFadeTransition(duration, true /*isCrossFadeEnabled*/);
   }
 }
 
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
index 54ebaff3c..bdfef1c41 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
@@ -11,7 +11,6 @@
 import android.content.Context;
 import android.view.animation.Animation;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
index 52f429f4e..2b50c15d8 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
@@ -11,7 +11,6 @@
 
 import android.view.View;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
index 2d680b57e..831a9d047 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
@@ -5,7 +5,6 @@
 import static org.mockito.Mockito.mock;
 
 import com.bumptech.glide.load.DataSource;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
similarity index 94%
rename from library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
rename to library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
index d7f433788..6f1cb4ec5 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
@@ -11,9 +11,7 @@
 import android.content.Context;
 import android.view.View;
 import android.view.animation.Animation;
-
 import com.bumptech.glide.load.DataSource;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,12 +23,12 @@
 @Config(manifest = Config.NONE)
 public class ViewTransitionAnimationFactoryTest {
   private ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
-  private ViewAnimationFactory factory;
+  private ViewAnimationFactory<Object> factory;
 
   @Before
   public void setUp() {
     viewTransitionAnimationFactory = mock(ViewTransition.ViewTransitionAnimationFactory.class);
-    factory = new ViewAnimationFactory(viewTransitionAnimationFactory);
+    factory = new ViewAnimationFactory<>(viewTransitionAnimationFactory);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
similarity index 73%
rename from library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
rename to library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 2d92de3d4..1efd9b736 100644
--- a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -3,26 +3,25 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
-
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ExifTest {
 
-  private LruByteArrayPool byteArrayPool;
+  private ArrayPool byteArrayPool;
 
-  private InputStream open(String imageName) throws IOException {
+  private InputStream open(String imageName) {
     return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);
   }
 
@@ -30,7 +29,7 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
     InputStream is = null;
     try {
       is = open(filePrefix + "_" + expectedOrientation + ".jpg");
-      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),
+      assertEquals(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool),
           expectedOrientation);
     } catch (IOException e) {
       throw new RuntimeException(e);
@@ -47,13 +46,13 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
 
   @Before
   public void setUp() {
-    byteArrayPool = new LruByteArrayPool();
+    byteArrayPool = new LruArrayPool();
   }
 
   @Test
   public void testIssue387() throws IOException {
     InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
+    assertThat(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool)).isEqualTo(6);
   }
 
   @Test
@@ -73,11 +72,11 @@ public void testPortrait() throws IOException {
   @Test
   public void testHandlesInexactSizesInByteArrayPools() {
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
       assertOrientation("Portrait", i);
     }
     for (int i = 1; i <= 8; i++) {
-      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
+      byteArrayPool.put(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
       assertOrientation("Landscape", i);
     }
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
new file mode 100644
index 000000000..0d2c90bb8
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
@@ -0,0 +1,83 @@
+package com.bumptech.glide.signature;
+
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Answers;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ApplicationVersionSignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    context = RuntimeEnvironment.application;
+  }
+
+  @After
+  public void tearDown() {
+    ApplicationVersionSignature.reset();
+  }
+
+  @Test
+  public void testCanGetKeyForSignature() {
+    Key key = ApplicationVersionSignature.obtain(context);
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
+      throws NoSuchAlgorithmException, UnsupportedEncodingException {
+    keyTester
+        .addEquivalenceGroup(
+            ApplicationVersionSignature.obtain(context),
+            ApplicationVersionSignature.obtain(context))
+        .addEquivalenceGroup(new ObjectKey("test"))
+        .addRegressionTest(
+            ApplicationVersionSignature.obtain(context),
+            "5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9")
+        .test();
+  }
+
+  @Test
+  public void testUnresolvablePackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0))
+        .thenThrow(new NameNotFoundException("test"));
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testMissingPackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0)).thenReturn(null);
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
new file mode 100644
index 000000000..a10b26cd7
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/EmptySignatureTest.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.signature;
+
+
+import static org.mockito.Mockito.mock;
+
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.tests.KeyTester;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class EmptySignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEquals() {
+    keyTester
+        .addEquivalenceGroup(
+            EmptySignature.obtain(),
+            EmptySignature.obtain())
+        .addEquivalenceGroup(mock(Key.class))
+        .addEmptyDigestRegressionTest(EmptySignature.obtain())
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
new file mode 100644
index 000000000..e972c3e2e
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyTester;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MediaStoreSignatureTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void equalsHashCodeAndDigest() {
+    keyTester
+        .addEquivalenceGroup(
+            new MediaStoreSignature("first", 100, 1),
+            new MediaStoreSignature("first", 100, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("second", 100, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("first", 200, 1))
+        .addEquivalenceGroup(new MediaStoreSignature("first", 100, 2))
+        .addRegressionTest(
+            new MediaStoreSignature("first", 100, 1),
+            "04959925006b21081000fd10835cc376343c0e922df0bd7346897ede6f958adf")
+        .test();
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
new file mode 100644
index 000000000..f5656d4a0
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.signature;
+
+import com.bumptech.glide.tests.KeyTester;
+import java.security.NoSuchAlgorithmException;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ObjectKeyTest {
+  @Rule public final KeyTester keyTester = new KeyTester();
+
+  @Test
+  public void testEqualsHashCodeAndDigest() throws NoSuchAlgorithmException {
+    Object object = new Object();
+    keyTester
+        .addEquivalenceGroup(new ObjectKey(object), new ObjectKey(object))
+        .addEquivalenceGroup(new ObjectKey(new Object()))
+        .addEquivalenceGroup(new ObjectKey("test"), new ObjectKey("test"))
+        .addRegressionTest(
+            new ObjectKey("test"),
+            "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08")
+        .test();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java b/library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
similarity index 69%
rename from library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
rename to library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
index 796a09240..3800e8b77 100644
--- a/library/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/BackgroundUtil.java
@@ -1,8 +1,9 @@
 package com.bumptech.glide.tests;
 
-public class BackgroundUtil {
-  public interface BackgroundTester {
-    public void runTest() throws Exception;
+public final class BackgroundUtil {
+
+  private BackgroundUtil() {
+    // Utility class.
   }
 
   public static void testInBackground(BackgroundTester test) throws InterruptedException {
@@ -14,11 +15,11 @@ public static void testInBackground(BackgroundTester test) throws InterruptedExc
     }
   }
 
-  private static class TestThread extends Thread {
+  private static final class TestThread extends Thread {
+    private final BackgroundTester test;
     private Exception exception;
-    private BackgroundTester test;
 
-    public TestThread(BackgroundTester test) {
+    private TestThread(BackgroundTester test) {
       this.test = test;
     }
 
@@ -32,4 +33,8 @@ public void run() {
       }
     }
   }
+
+  public interface BackgroundTester {
+    void runTest();
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/test/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
similarity index 54%
rename from library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
rename to library/test/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
index aa6adc361..326096bad 100644
--- a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
@@ -3,29 +3,32 @@
 import android.content.ContentResolver;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
-
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowContentResolver;
-
+import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
 
 @Implements(ContentResolver.class)
-public class ContentResolverShadow extends ShadowContentResolver {
-  private Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<>();
+public class ContentResolverShadow {
+  private final Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<>();
+  private final Map<Uri, InputStream> inputStreamMap = new HashMap<>();
 
   public void registerFileDescriptor(Uri uri, AssetFileDescriptor fileDescriptor) {
     fileDescriptorMap.put(uri, fileDescriptor);
   }
 
+  public void registerInputStream(Uri uri, InputStream inputStream) {
+    inputStreamMap.put(uri, inputStream);
+  }
+
+  @Implementation
+  public InputStream openInputStream(Uri uri) {
+    return inputStreamMap.get(uri);
+  }
+
   @Implementation
   public AssetFileDescriptor openAssetFileDescriptor(Uri uri, String mode) {
-    AssetFileDescriptor fileDescriptor = fileDescriptorMap.get(uri);
-    if (fileDescriptor != null) {
-      return fileDescriptor;
-    } else {
-      return null;
-    }
+    return fileDescriptorMap.get(uri);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
rename to library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
index f0ed18b27..ddd9d06b8 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.tests;
 
 import android.util.Log;
-
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowLog;
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
similarity index 66%
rename from library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
rename to library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
index c41e4a6f7..fede54a45 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
@@ -4,16 +4,23 @@
 
 import android.os.Looper;
 import android.os.MessageQueue;
-
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.shadows.ShadowLooper;
 
 @Implements(Looper.class)
 public class GlideShadowLooper extends ShadowLooper {
+  public static MessageQueue queue = mock(MessageQueue.class);
 
   @Implementation
   public static MessageQueue myQueue() {
-    return mock(MessageQueue.class);
+    return queue;
+  }
+
+  @Resetter
+  @Override
+  public void reset() {
+    queue = mock(MessageQueue.class);
   }
 }
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
new file mode 100644
index 000000000..8a064db54
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/tests/KeyTester.java
@@ -0,0 +1,153 @@
+package com.bumptech.glide.tests;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assert_;
+import static org.junit.Assert.fail;
+
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.load.Key;
+import com.google.common.base.Equivalence;
+import com.google.common.testing.EquivalenceTester;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+public final class KeyTester implements TestRule {
+  private static final String EMPTY_DIGEST_STRING =
+      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
+  // Use LinkedHashMap to keep iteration based on insertion order.
+  private final Map<Key, String> regressionTests = new LinkedHashMap<>();
+  private final Sha256 sha256 = new Sha256();
+  private final EquivalenceTester<Key> tester = EquivalenceTester.of(new KeyEquivalence(sha256));
+  private boolean isUsedWithoutCallingTest;
+  private boolean isUsedAsRule;
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+
+      @Override
+      public void evaluate() throws Throwable {
+          isUsedAsRule = true;
+          base.evaluate();
+          if (isUsedWithoutCallingTest) {
+            fail("You used KeyTester but failed to call test()!");
+          }
+      }
+    };
+  }
+
+  private void assertUsedAsRule() {
+    if (!isUsedAsRule) {
+      fail("You must use KeyTester as an @Rule");
+    }
+  }
+
+  @CheckResult
+  public KeyTester addEquivalenceGroup(Key first, Key... rest) {
+    assertUsedAsRule();
+    isUsedWithoutCallingTest = true;
+    tester.addEquivalenceGroup(first, rest);
+    return this;
+  }
+
+  @CheckResult
+  public KeyTester addRegressionTest(Key key, String expectedDigest) {
+    assertUsedAsRule();
+    if (EMPTY_DIGEST_STRING.equals(expectedDigest)) {
+      throw new IllegalArgumentException("Expected digest is empty, if this is intended use "
+          + "addEmptyDigestRegressionTest instead");
+    }
+    return addRegressionTestInternal(key, expectedDigest);
+  }
+
+  @CheckResult
+  public KeyTester addEmptyDigestRegressionTest(Key key) {
+    assertUsedAsRule();
+    return addRegressionTestInternal(key, EMPTY_DIGEST_STRING);
+  }
+
+  private KeyTester addRegressionTestInternal(Key key, String expectedDigest) {
+    isUsedWithoutCallingTest = true;
+    String oldValue = regressionTests.put(key, expectedDigest);
+    if (oldValue != null) {
+      throw new IllegalArgumentException(
+          "Given multiple values for: " + key + " old: " + oldValue + " new: " + expectedDigest);
+    }
+    return this;
+  }
+
+  public void test() {
+    assertUsedAsRule();
+    isUsedWithoutCallingTest = false;
+    tester.test();
+
+    assertThat(regressionTests).isNotEmpty();
+    int i = 1;
+    for (Entry<Key, String> entry : regressionTests.entrySet()) {
+      assert_()
+          .withMessage(
+              "Unexpected digest for regression test [" + i + "]: with key: " + entry.getKey())
+          .that(sha256.getStringDigest(entry.getKey())).isEqualTo(entry.getValue());
+      i++;
+    }
+  }
+
+  private static final class Sha256 {
+
+    private final MessageDigest digest;
+
+    Sha256() {
+      try {
+        digest = MessageDigest.getInstance("SHA-256");
+      } catch (NoSuchAlgorithmException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    private byte[] getDigest(Key key) {
+      try {
+        key.updateDiskCacheKey(digest);
+        return digest.digest();
+      } finally {
+        digest.reset();
+      }
+    }
+
+
+    String getStringDigest(Key key) {
+      return com.bumptech.glide.util.Util.sha256BytesToHex(getDigest(key));
+    }
+  }
+
+  /**
+   * Tests equals, hashcode and digest methods of {@link Key}s.
+   */
+  private static final class KeyEquivalence extends Equivalence<Key> {
+
+    private final Sha256 sha256;
+
+    KeyEquivalence(Sha256 sha256) {
+      this.sha256 = sha256;
+    }
+
+    @Override
+    protected boolean doEquivalent(@NonNull Key a, @NonNull Key b) {
+      byte[] aDigest = sha256.getDigest(a);
+      byte[] bDigest = sha256.getDigest(b);
+      return a.equals(b) && Arrays.equals(aDigest, bDigest);
+    }
+
+    @Override
+    protected int doHash(@NonNull Key key) {
+      return key.hashCode();
+    }
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
new file mode 100644
index 000000000..d1814f48f
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.tests;
+
+import com.bumptech.glide.Glide;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/**
+ * Clears out Glide's disk cache and the Glide singleton after every test method.
+ */
+public final class TearDownGlide implements TestRule {
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          Glide.tearDown();
+
+        }
+      }
+    };
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
similarity index 68%
rename from library/src/test/java/com/bumptech/glide/tests/Util.java
rename to library/test/src/test/java/com/bumptech/glide/tests/Util.java
index 366f7d425..bcd5d34f4 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/test/src/test/java/com/bumptech/glide/tests/Util.java
@@ -4,18 +4,14 @@
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.RETURNS_DEFAULTS;
+import static org.mockito.Mockito.mock;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Build;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.engine.Resource;
-
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.util.ReflectionHelpers;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -23,21 +19,50 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.security.MessageDigest;
+import org.mockito.ArgumentCaptor;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.util.ReflectionHelpers;
 
+// FIXME move to testutil module
 public class Util {
 
-  public static String getExpectedClassId(Class clazz) {
-    return clazz.getSimpleName() + "." + clazz.getPackage().getName();
+  /**
+   * Gives the proper generic type to the {@link ArgumentCaptor}.
+   * Only useful when the captor's {@code T} is also a generic type.
+   * Without this it's really ugly to have a properly typed captor object.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> ArgumentCaptor<T> cast(ArgumentCaptor<?> captor) {
+    return (ArgumentCaptor<T>) captor;
   }
 
   public static DataSource isADataSource() {
     return isA(DataSource.class);
   }
 
-  public static Resource<?> anyResource() {
+  public static Context anyContext() {
+    return any();
+  }
+
+  /**
+   * Creates a Mockito argument matcher to be used in verify.
+   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> Resource<T> anyResource() {
     return any(Resource.class);
   }
 
+  /**
+   * Creates a Mockito mock object.
+   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> Resource<T> mockResource() {
+    return mock(Resource.class);
+  }
+
   public static boolean isWindows() {
     return System.getProperty("os.name").startsWith("Windows");
   }
@@ -77,8 +102,8 @@ public static void setSdkVersionInt(int version) {
     ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", version);
   }
 
-  public static class WriteDigest implements Answer<Void> {
-    private String toWrite;
+  public static final class WriteDigest implements Answer<Void> {
+    private final String toWrite;
 
     public WriteDigest(String toWrite) {
       this.toWrite = toWrite;
@@ -87,13 +112,14 @@ public WriteDigest(String toWrite) {
     @Override
     public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
       MessageDigest md = (MessageDigest) invocationOnMock.getArguments()[0];
-      md.update(toWrite.getBytes());
+      md.update(toWrite.getBytes("UTF-8"));
       return null;
     }
   }
 
-  public static class ReturnsSelfAnswer implements Answer<Object> {
+  public static final class ReturnsSelfAnswer implements Answer<Object> {
 
+    @Override
     public Object answer(InvocationOnMock invocation) throws Throwable {
       Object mock = invocation.getMock();
       if (invocation.getMethod().getReturnType().isInstance(mock)) {
@@ -104,9 +130,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }
   }
 
-  public static class CallDataReady<T> implements Answer<Void> {
+  public static final class CallDataReady<T> implements Answer<Void> {
 
-    private T data;
+    private final T data;
 
     public CallDataReady(T data) {
       this.data = data;
@@ -122,7 +148,7 @@ public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
     }
   }
 
-  public static class CreateBitmap implements Answer<Bitmap> {
+  public static final class CreateBitmap implements Answer<Bitmap> {
 
     @Override
     public Bitmap answer(InvocationOnMock invocation) throws Throwable {
diff --git a/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java b/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
new file mode 100644
index 000000000..007e5a26b
--- /dev/null
+++ b/library/test/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
@@ -0,0 +1,67 @@
+package com.bumptech.glide.util;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ByteBufferUtilTest {
+  private static final int BUFFER_SIZE = 16384;
+
+  @Test
+  public void testFromStream_small() throws IOException {
+    testFromStream(4);
+  }
+
+  @Test
+  public void testFromStream_empty() throws IOException {
+    testFromStream(0);
+  }
+
+  @Test
+  public void testFromStream_bufferAndAHalf() throws IOException {
+    testFromStream(BUFFER_SIZE + BUFFER_SIZE / 2);
+  }
+
+  @Test
+  public void testFromStream_massive() throws IOException {
+    testFromStream(12 * BUFFER_SIZE + 12345);
+  }
+
+  /**
+   * All tests are basically the same thing but with different amounts of data.
+   */
+  private void testFromStream(int dataLength) throws IOException {
+    byte[] bytes = createByteData(dataLength);
+    InputStream byteStream = new ByteArrayInputStream(bytes);
+    ByteBuffer byteBuffer = ByteBufferUtil.fromStream(byteStream);
+    assertByteBufferContents(byteBuffer, bytes);
+    byteStream.close();
+  }
+
+  private byte[] createByteData(int size) {
+    byte[] bytes = new byte[size];
+
+    // Put some arbitrary bytes in there.
+    for (int i = 0; i < size; i++) {
+      bytes[i] = (byte) (i % 4);
+    }
+
+    return bytes;
+  }
+
+  private void assertByteBufferContents(ByteBuffer buffer, byte[] expectedBytes) {
+    assertEquals(expectedBytes.length, buffer.limit());
+    for (int i = 0; i < expectedBytes.length; i++) {
+      assertEquals(expectedBytes[i], buffer.get(i));
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
similarity index 78%
rename from library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
index 84d01d0b0..a9a912613 100644
--- a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -6,6 +6,9 @@
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.when;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,13 +17,10 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ContentLengthInputStreamTest {
-  @Mock InputStream wrapped;
+  @Mock private InputStream wrapped;
 
   @Before
   public void setUp() {
@@ -72,7 +72,7 @@ public void testAvailable_handlesReadValueOfZero() throws IOException {
     when(wrapped.read()).thenReturn(0);
 
     assertThat(is.read()).isEqualTo(0);
-    assertThat(is.available()).isEqualTo(contentLength);
+    assertThat(is.available()).isEqualTo(contentLength - 1);
   }
 
   @Test
@@ -95,6 +95,7 @@ public void testRead_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOExc
     when(wrapped.read()).thenReturn(-1);
 
     try {
+      //noinspection ResultOfMethodCallIgnored
       is.read();
       fail("Failed to throw expected exception");
     } catch (IOException e) {
@@ -110,6 +111,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throws
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
 
     try {
+      //noinspection ResultOfMethodCallIgnored
       is.read(new byte[10], 0, 0);
       fail("Failed to throw expected exception");
     } catch (IOException e) {
@@ -121,6 +123,7 @@ public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throws
   public void testRead_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow() throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
     when(wrapped.read()).thenReturn(-1);
+    //noinspection ResultOfMethodCallIgnored
     is.read();
   }
 
@@ -129,6 +132,30 @@ public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow(
       throws IOException {
     InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
+    //noinspection ResultOfMethodCallIgnored
     is.read(new byte[10], 0, 0);
   }
+
+  @Test
+  public void testRead_readWithZeroes_doesNotThrow() throws IOException {
+    ByteArrayInputStream inner = new ByteArrayInputStream(new byte[] {0, 0, 0});
+    InputStream is = ContentLengthInputStream.obtain(inner, 3);
+
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(-1);
+  }
+
+  @Test
+  public void testRead_readWithHighValues_doesNotThrow() throws IOException {
+    ByteArrayInputStream inner =
+        new ByteArrayInputStream(new byte[] {(byte) 0xF0, (byte) 0xA0, (byte) 0xFF});
+    InputStream is = ContentLengthInputStream.obtain(inner, 3);
+
+    assertThat(is.read()).isEqualTo(0xF0);
+    assertThat(is.read()).isEqualTo(0xA0);
+    assertThat(is.read()).isEqualTo(0xFF);
+    assertThat(is.read()).isEqualTo(-1);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
index 8a07d5a27..913432b92 100644
--- a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
@@ -12,17 +12,15 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
-
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.SocketTimeoutException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketTimeoutException;
-
 @RunWith(JUnit4.class)
 public class ExceptionCatchingInputStreamTest {
 
diff --git a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java b/library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
similarity index 86%
rename from library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
index 89cab6985..8418cc85d 100644
--- a/library/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/FixedPreloadSizeProviderTest.java
@@ -11,6 +11,8 @@
 @Config(manifest = Config.NONE, sdk = 18)
 public class FixedPreloadSizeProviderTest {
 
+  // containsExactly doesn't need a return value check.
+  @SuppressWarnings("ResultOfMethodCallIgnored")
   @Test
   public void testReturnsGivenSize() {
     int width = 500;
diff --git a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
similarity index 99%
rename from library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
index 16d5d0187..5684e3c13 100644
--- a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
@@ -3,14 +3,13 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
 public class MarkEnforcingInputStreamTest {
@@ -136,7 +135,7 @@ public void testReturnsEndOfStream_whenSkipping_withZeroBytesRemainingInMarkLimi
     is.mark(MARK_LIMIT);
 
     assertEquals(MARK_LIMIT, is.skip(DATA_SIZE));
-    assertEquals(-1, is.skip(1));
+    assertEquals(0, is.skip(1));
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/util/UtilTest.java b/library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
similarity index 85%
rename from library/src/test/java/com/bumptech/glide/util/UtilTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
index 64f89ff8a..416095784 100644
--- a/library/src/test/java/com/bumptech/glide/util/UtilTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/UtilTest.java
@@ -1,16 +1,16 @@
 package com.bumptech.glide.util;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
 import android.graphics.Bitmap;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 27)
 public class UtilTest {
 
   @Test
@@ -71,4 +71,12 @@ public void testReturnsLargestSizeForNullConfig() {
     int size = Util.getBitmapByteSize(width, height, null);
     assertEquals(width * height * 4, size);
   }
+
+  @Test
+  public void getBitmapByteSize_withRGBA_F16_returnsCorrectSize() {
+    int width = 100;
+    int height = 200;
+    assertThat(Util.getBitmapByteSize(width, height, Bitmap.Config.RGBA_F16))
+        .isEqualTo(width * height * 8);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
rename to library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
index 81ed47525..5cc8f12ff 100644
--- a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
@@ -5,7 +5,6 @@
 
 import android.view.View;
 import android.view.ViewGroup;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -13,6 +12,8 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
+// containsExactly does not need its return value checked.
+@SuppressWarnings("ResultOfMethodCallIgnored")
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ViewPreloadSizeProviderTest {
@@ -47,6 +48,7 @@ public void testDoesNotObtainSizeFromViewOnceSizeIsSet() {
     int height = 456;
     provider.onSizeReady(width, height);
     view.setLayoutParams(new ViewGroup.LayoutParams(1, 1));
+    view.layout(0, 0, 1, 1);
 
     provider.setView(view);
 
@@ -59,6 +61,7 @@ public void testCanObtainFixedSizeFromView() {
     int width = 123;
     int height = 456;
     view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+    view.layout(0, 0, width, height);
 
     provider.setView(view);
 
@@ -82,6 +85,7 @@ public void testCanObtainSizeFromViewWhenGivenViewInConstructor() {
     int width = 100;
     int height = 200;
     view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+    view.layout(0, 0, width, height);
 
     provider = new ViewPreloadSizeProvider<>(view);
 
diff --git a/library/src/test/java/javax/microedition/khronos/opengles/GL.java b/library/test/src/test/java/opengles/GL.java
similarity index 100%
rename from library/src/test/java/javax/microedition/khronos/opengles/GL.java
rename to library/test/src/test/java/opengles/GL.java
diff --git a/library/test/src/test/resources/exif-orientation-examples b/library/test/src/test/resources/exif-orientation-examples
new file mode 160000
index 000000000..9c4ccfaea
--- /dev/null
+++ b/library/test/src/test/resources/exif-orientation-examples
@@ -0,0 +1 @@
+Subproject commit 9c4ccfaea6bfd434ac1c4bb0750ac6fc5848a5f4
diff --git a/library/src/test/resources/issue387_rotated_jpeg.jpg b/library/test/src/test/resources/issue387_rotated_jpeg.jpg
similarity index 100%
rename from library/src/test/resources/issue387_rotated_jpeg.jpg
rename to library/test/src/test/resources/issue387_rotated_jpeg.jpg
diff --git a/library/src/test/resources/org.robolectric.Config.properties b/library/test/src/test/resources/org.robolectric.Config.properties
similarity index 100%
rename from library/src/test/resources/org.robolectric.Config.properties
rename to library/test/src/test/resources/org.robolectric.Config.properties
diff --git a/library/src/test/resources/short_exif_sample.jpg b/library/test/src/test/resources/short_exif_sample.jpg
similarity index 100%
rename from library/src/test/resources/short_exif_sample.jpg
rename to library/test/src/test/resources/short_exif_sample.jpg
diff --git a/library/src/test/resources/test.gif b/library/test/src/test/resources/test.gif
similarity index 100%
rename from library/src/test/resources/test.gif
rename to library/test/src/test/resources/test.gif
diff --git a/samples/contacturi/build.gradle b/samples/contacturi/build.gradle
new file mode 100644
index 000000000..d1f2480ea
--- /dev/null
+++ b/samples/contacturi/build.gradle
@@ -0,0 +1,30 @@
+apply plugin: 'com.android.application'
+
+dependencies {
+    implementation project(':library')
+    implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    annotationProcessor project(':annotation:compiler')
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        applicationId 'com.bumptech.glide.samples.contacturi'
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionCode 1
+        versionName '1.0'
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+task run(type: Exec, dependsOn: 'installDebug') {
+    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.contacturi/.MainActivity'
+}
diff --git a/samples/contacturi/lint.xml b/samples/contacturi/lint.xml
new file mode 100644
index 000000000..ab5a637a0
--- /dev/null
+++ b/samples/contacturi/lint.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+</lint>
diff --git a/samples/contacturi/src/main/AndroidManifest.xml b/samples/contacturi/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..50cd63461
--- /dev/null
+++ b/samples/contacturi/src/main/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.bumptech.glide.samples.contacturi" >
+
+    <uses-permission android:name="android.permission.READ_CONTACTS" />
+
+    <application
+        android:allowBackup="false"
+        android:icon="@android:drawable/sym_def_app_icon"
+        android:label="@string/app_name"
+        android:theme="@style/Theme.AppCompat" >
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
new file mode 100644
index 000000000..14dec10a2
--- /dev/null
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.contacturi;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Ensures that Glide's generated API is created for the Contact Uri sample.
+ */
+@GlideModule
+public class ContactUriModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
new file mode 100644
index 000000000..c072483df
--- /dev/null
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -0,0 +1,116 @@
+package com.bumptech.glide.samples.contacturi;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.ContentUris;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract;
+import android.provider.ContactsContract.Contacts;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.content.ContextCompat;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.ImageView;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
+
+/**
+ * An activity that demonstrates loading photos using
+ * {@link com.bumptech.glide.load.data.StreamLocalUriFetcher content uris} through Glide.
+ * It works by making the user to choose a contact when presses a button,
+ * and after he chooses a contact with photo,
+ * We try to load both a high res image and thumbnail image of that contact with various Uris.
+ */
+public class MainActivity extends Activity {
+  private static final int REQUEST_CONTACT = 1;
+  private static final int READ_CONTACTS = 0;
+
+  private ImageView imageViewContact;
+  private ImageView imageViewLookup;
+  private ImageView imageViewPhoto;
+  private ImageView imageViewDisplayPhoto;
+  private EditText numberEntry;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+
+    imageViewContact = findViewById(R.id.image_contact);
+    imageViewLookup = findViewById(R.id.image_lookup);
+    imageViewPhoto = findViewById(R.id.image_photo);
+    imageViewDisplayPhoto = findViewById(R.id.image_display_photo);
+    numberEntry = findViewById(R.id.number_entry);
+    // Make sure that user gives application required permissions
+    if (ContextCompat.checkSelfPermission(
+        getApplication(),
+        Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+      // No explanation needed, we can request the permission.
+      ActivityCompat.requestPermissions(this,
+      new String[]{Manifest.permission.READ_CONTACTS},
+      READ_CONTACTS);
+    }
+
+    findViewById(R.id.button_pick_contact).setOnClickListener(new View.OnClickListener() {
+      @Override
+      public void onClick(View v) {
+        Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
+        startActivityForResult(intent, REQUEST_CONTACT);
+      }
+    });
+
+    findViewById(R.id.button_find).setOnClickListener(new View.OnClickListener() {
+      @Override
+      public void onClick(View v) {
+        Uri uri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI,
+                                       Uri.encode(numberEntry.getText().toString()));
+        GlideApp.with(MainActivity.this)
+                .load(uri)
+                .override(Target.SIZE_ORIGINAL)
+                .into(imageViewLookup);
+        }
+    });
+  }
+
+  @Override
+  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+    if (requestCode == REQUEST_CONTACT && resultCode == RESULT_OK) {
+      Uri uri = Preconditions.checkNotNull(data.getData());
+      final Cursor cursor = getContentResolver().query(uri, null, null, null, null);
+      try {
+        if (cursor != null && cursor.moveToFirst()) {
+          final long contactId = cursor.getLong(cursor.getColumnIndex(Contacts._ID));
+          showContact(contactId);
+        }
+      } finally {
+        if (cursor != null) {
+          cursor.close();
+        }
+      }
+      return;
+    }
+    super.onActivityResult(requestCode, resultCode, data);
+  }
+
+  private void showContact(long id) {
+    GlideRequests glideRequests = GlideApp.with(this);
+    RequestOptions originalSize = new RequestOptions().override(Target.SIZE_ORIGINAL);
+
+    Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI, id);
+    glideRequests.load(contactUri).apply(originalSize).into(imageViewContact);
+
+    Uri lookupUri = Contacts.getLookupUri(getContentResolver(), contactUri);
+    glideRequests.load(lookupUri).apply(originalSize).into(imageViewLookup);
+
+    Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
+    glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);
+
+    Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
+    glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
+  }
+}
diff --git a/samples/contacturi/src/main/res/layout/activity_main.xml b/samples/contacturi/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..7834e829d
--- /dev/null
+++ b/samples/contacturi/src/main/res/layout/activity_main.xml
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:fitsSystemWindows="true"
+        android:padding="@dimen/activity_horizontal_margin"
+        tools:context="com.bumptech.glide.samples.contacturi.MainActivity">
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+        <Button
+                android:id="@+id/button_pick_contact"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/pick_contact"/>
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:orientation="horizontal">
+
+            <EditText
+                android:id="@+id/number_entry"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:ems="10"
+                android:hint="@string/hint_number_entry"
+                android:inputType="phone" />
+
+            <Button
+                android:id="@+id/button_find"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_search_phone" />
+        </LinearLayout>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_contact"/>
+        <ImageView
+                android:id="@+id/image_contact"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_contact"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_lookup"/>
+        <ImageView
+                android:id="@+id/image_lookup"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_lookup"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_photo"/>
+        <ImageView
+                android:id="@+id/image_photo"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_photo"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_display_photo"/>
+        <ImageView
+                android:id="@+id/image_display_photo"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_display_photo"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/samples/contacturi/src/main/res/values/dimens.xml b/samples/contacturi/src/main/res/values/dimens.xml
new file mode 100644
index 000000000..47c822467
--- /dev/null
+++ b/samples/contacturi/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/samples/contacturi/src/main/res/values/strings.xml b/samples/contacturi/src/main/res/values/strings.xml
new file mode 100644
index 000000000..b258461bb
--- /dev/null
+++ b/samples/contacturi/src/main/res/values/strings.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">ContactUri Sample</string>
+    <string name="pick_contact">Pick Contact</string>
+    <string name="image_contact">Image based on contact Uri, best size on latest Android</string>
+    <string name="image_lookup">Image based on lookup Uri, same as contact Uri</string>
+    <string name="image_photo">Image based on photo Uri, thumbnail sized, usually 96x96px</string>
+    <string name="image_display_photo">Image based on display photo Uri, possibly 512x512px</string>
+    <string name="hint_number_entry">Find by phone number</string>
+    <string name="button_search_phone">Find</string>
+</resources>
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index aec235f5e..37ec1e3b8 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -1,27 +1,27 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
-    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    annotationProcessor project(':annotation:compiler')
+
+    implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.volley:volley:${VOLLEY_VERSION}"
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.flickr'
-        minSdkVersion 11
+        minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
         versionCode 1
-        versionName '1.0.0'
+        versionName '1.0'
     }
 
     compileOptions {
diff --git a/samples/flickr/lint.xml b/samples/flickr/lint.xml
index 5c710c8c7..ac292ab1a 100644
--- a/samples/flickr/lint.xml
+++ b/samples/flickr/lint.xml
@@ -3,4 +3,5 @@
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
 </lint>
diff --git a/samples/flickr/src/main/AndroidManifest.xml b/samples/flickr/src/main/AndroidManifest.xml
index 1a6e4a6ff..191c38149 100644
--- a/samples/flickr/src/main/AndroidManifest.xml
+++ b/samples/flickr/src/main/AndroidManifest.xml
@@ -3,11 +3,11 @@
           package="com.bumptech.glide.samples.flickr">
 
     <uses-permission android:name="android.permission.INTERNET"/>
+    <!--
+    Allows Glide to monitor connectivity status and restart failed requests if users go from a
+    a disconnected to a connected network state.
+    -->
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
-
-    <uses-sdk android:minSdkVersion="10"
-      android:targetSdkVersion="22" />
 
     <application
         android:label="@string/app_name"
@@ -27,10 +27,5 @@
         </activity>
 
         <activity android:name=".FullscreenActivity"/>
-
-        <meta-data
-            android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
-            android:value="GlideModule"/>
     </application>
-
 </manifest>
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
new file mode 100644
index 000000000..1a5346d09
--- /dev/null
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.samples.flickr;
+
+import android.support.annotation.NonNull;
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.samples.flickr.api.Api;
+
+/**
+ * Extension methods for the Flickr sample's generated API.
+ */
+// Required by Glide's annotation processor.
+@SuppressWarnings({"WeakerAccess", "unused"})
+@GlideExtension
+public final class FlickrGlideExtension {
+
+  private FlickrGlideExtension() {
+    // Utility class.
+  }
+
+  @NonNull
+  @GlideOption
+  public static RequestOptions squareThumb(RequestOptions requestOptions) {
+    return requestOptions.centerCrop();
+  }
+
+  @NonNull
+  @GlideOption
+  public static RequestOptions squareMiniThumb(RequestOptions requestOptions) {
+    return requestOptions.centerCrop().override(Api.SQUARE_THUMB_SIZE);
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
index e965d395e..c0a1bce18 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -1,25 +1,38 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
-
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.samples.flickr.api.Photo;
-
 import java.io.InputStream;
 
 /**
- * {@link com.bumptech.glide.module.GlideModule} for the Flickr sample app.
+ * Register {@link FlickrModelLoader} for the Flickr sample app.
  */
-public class FlickrGlideModule implements GlideModule {
+@GlideModule
+public class FlickrGlideModule extends AppGlideModule {
+
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
+  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {
+    super.applyOptions(context, builder);
+    builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_ARGB_8888));
   }
 
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
     registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
   }
+
+  // Disable manifest parsing to avoid adding similar modules twice.
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return false;
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index 708f68e3a..a2b3d2f6e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.content.Context;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
@@ -11,7 +10,6 @@
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
-
 import java.io.InputStream;
 import java.util.List;
 
@@ -20,19 +18,19 @@
  * ExecutorService backing the Engine to download the image and resize it in memory before saving
  * the resized version directly to the disk cache.
  */
-public class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
+public final class FlickrModelLoader extends BaseGlideUrlLoader<Photo> {
 
   /**
    * The default factory for {@link com.bumptech.glide.samples.flickr.FlickrModelLoader}s.
    */
   public static class Factory implements ModelLoaderFactory<Photo, InputStream> {
-    private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
+    private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<>(500);
 
+    @NonNull
     @Override
-    public ModelLoader<Photo, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new FlickrModelLoader(multiFactory.build(GlideUrl.class, InputStream.class),
-          modelCache);
+    public ModelLoader<Photo, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new FlickrModelLoader(
+          multiFactory.build(GlideUrl.class, InputStream.class), modelCache);
     }
 
     @Override
@@ -40,13 +38,13 @@ public void teardown() {
     }
   }
 
-  public FlickrModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader,
-      ModelCache<Photo, GlideUrl> modelCache) {
+  private FlickrModelLoader(
+      ModelLoader<GlideUrl, InputStream> urlLoader, ModelCache<Photo, GlideUrl> modelCache) {
     super(urlLoader, modelCache);
   }
 
   @Override
-  public boolean handles(Photo model) {
+  public boolean handles(@NonNull Photo model) {
     return true;
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index de9b10705..65bc1ceab 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -1,14 +1,11 @@
 package com.bumptech.glide.samples.flickr;
 
-import static com.bumptech.glide.GenericTransitionOptions.withNoTransition;
-import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
-import static com.bumptech.glide.request.RequestOptions.priorityOf;
-
 import android.content.Intent;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v7.widget.GridLayoutManager;
 import android.support.v7.widget.RecyclerView;
@@ -16,22 +13,20 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.FixedPreloadSizeProvider;
-
+import com.bumptech.glide.util.Preconditions;
 import java.util.Collections;
 import java.util.List;
 
 /**
- * A fragment that shows square image thumbnails whose size is determined by the framgent's
+ * A fragment that shows square image thumbnails whose size is determined by the fragment's
  * arguments in a grid pattern.
  */
 public class FlickrPhotoGrid extends Fragment implements PhotoViewer {
@@ -46,9 +41,9 @@
   private int photoSize;
   private RecyclerView grid;
   private boolean thumbnail;
-  private RequestBuilder<Drawable> fullRequest;
-  private RequestBuilder<Drawable> thumbnailRequest;
-  private RequestBuilder<Drawable> preloadRequest;
+  private GlideRequest<Drawable> fullRequest;
+  private GlideRequest<Drawable> thumbnailRequest;
+  private GlideRequest<Drawable> preloadRequest;
   private GridLayoutManager layoutManager;
 
   public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean thumbnail) {
@@ -62,32 +57,29 @@ public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean th
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
-    Bundle args = getArguments();
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+    Bundle args = Preconditions.checkNotNull(getArguments());
     photoSize = args.getInt(IMAGE_SIZE_KEY);
     thumbnail = args.getBoolean(THUMBNAIL_KEY);
 
-    fullRequest = Glide.with(this)
+    fullRequest = GlideApp.with(this)
         .asDrawable()
-        .transition(withNoTransition())
-        .apply(centerCropTransform(getActivity()));
+        .centerCrop();
 
-    thumbnailRequest = Glide.with(this)
+    thumbnailRequest = GlideApp.with(this)
         .asDrawable()
-        .transition(withNoTransition())
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
-            .centerCrop(getActivity())
-            .override(Api.SQUARE_THUMB_SIZE));
+        .centerCrop()
+        .override(Api.SQUARE_THUMB_SIZE);
 
     preloadRequest =
-        thumbnail ? thumbnailRequest.clone().apply(priorityOf(Priority.HIGH)) : fullRequest;
+        thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
 
     final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
 
     final int gridMargin = getResources().getDimensionPixelOffset(R.dimen.grid_margin);
     int spanCount = getResources().getDisplayMetrics().widthPixels / (photoSize + (2 * gridMargin));
-    grid = (RecyclerView) result.findViewById(R.id.flickr_photo_grid);
+    grid = result.findViewById(R.id.flickr_photo_grid);
     layoutManager = new GridLayoutManager(getActivity(), spanCount);
     grid.setLayoutManager(layoutManager);
 
@@ -102,7 +94,7 @@ public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
       @Override
       public void onViewRecycled(RecyclerView.ViewHolder holder) {
         PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;
-        Glide.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
+        GlideApp.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
       }
     });
 
@@ -131,7 +123,7 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
   }
 
   @Override
-  public void onSaveInstanceState(Bundle outState) {
+  public void onSaveInstanceState(@NonNull Bundle outState) {
     super.onSaveInstanceState(outState);
     if (grid != null) {
       int index = layoutManager.findFirstVisibleItemPosition();
@@ -152,11 +144,11 @@ public void onPhotosUpdated(List<Photo> photos) {
     private final LayoutInflater inflater;
     private List<Photo> photos = Collections.emptyList();
 
-    public PhotoAdapter() {
+    PhotoAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
     }
 
-    public void setPhotos(List<Photo> photos) {
+    void setPhotos(List<Photo> photos) {
       this.photos = photos;
       notifyDataSetChanged();
     }
@@ -202,21 +194,23 @@ public int getItemCount() {
       return photos.size();
     }
 
+    @NonNull
     @Override
     public List<Photo> getPreloadItems(int position) {
       return photos.subList(position, position + 1);
     }
 
+    @Nullable
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Photo item) {
       return preloadRequest.load(item);
     }
   }
 
-  private static class PhotoViewHolder extends RecyclerView.ViewHolder {
+  private static final class PhotoViewHolder extends RecyclerView.ViewHolder {
     private final ImageView imageView;
 
-    public PhotoViewHolder(View itemView) {
+    PhotoViewHolder(View itemView) {
       super(itemView);
       imageView = (ImageView) itemView;
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index 8c4496714..a9423c091 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -1,14 +1,14 @@
 package com.bumptech.glide.samples.flickr;
 
 import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
-import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 
 import android.content.Intent;
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
@@ -17,17 +17,13 @@
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.TextView;
-
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
-
 import java.util.Collections;
 import java.util.List;
 
@@ -41,8 +37,8 @@
   private FlickrPhotoListAdapter adapter;
   private List<Photo> currentPhotos;
   private RecyclerView list;
-  private RequestBuilder<Drawable> fullRequest;
-  private RequestBuilder<Drawable> thumbRequest;
+  private GlideRequest<Drawable> fullRequest;
+  private GlideRequest<Drawable> thumbRequest;
   private ViewPreloadSizeProvider<Photo> preloadSizeProvider;
   private LinearLayoutManager layoutManager;
 
@@ -59,19 +55,20 @@ public void onPhotosUpdated(List<Photo> photos) {
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     final View result = inflater.inflate(R.layout.flickr_photo_list, container, false);
 
-    list = (RecyclerView) result.findViewById(R.id.flickr_photo_list);
+    list = result.findViewById(R.id.flickr_photo_list);
     layoutManager = new LinearLayoutManager(getActivity());
     list.setLayoutManager(layoutManager);
     adapter = new FlickrPhotoListAdapter();
     list.setAdapter(adapter);
 
     preloadSizeProvider = new ViewPreloadSizeProvider<>();
-    RecyclerViewPreloader<Photo> preloader = new RecyclerViewPreloader<>(Glide.with(this), adapter,
-        preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
+    RecyclerViewPreloader<Photo> preloader =
+        new RecyclerViewPreloader<>(
+            GlideApp.with(this), adapter, preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
     list.addOnScrollListener(preloader);
     list.setItemViewCacheSize(0);
 
@@ -79,23 +76,23 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
       adapter.setPhotos(currentPhotos);
     }
 
-    final RequestManager requestManager = Glide.with(this);
-    fullRequest = requestManager
+    final GlideRequests glideRequests = GlideApp.with(this);
+    fullRequest = glideRequests
         .asDrawable()
-        .apply(centerCropTransform(getActivity())
-            .placeholder(new ColorDrawable(Color.GRAY)));
+        .centerCrop()
+        .placeholder(new ColorDrawable(Color.GRAY));
 
-    thumbRequest = requestManager
+    thumbRequest = glideRequests
         .asDrawable()
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
-            .override(Api.SQUARE_THUMB_SIZE))
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .override(Api.SQUARE_THUMB_SIZE)
         .transition(withCrossFade());
 
     list.setRecyclerListener(new RecyclerView.RecyclerListener() {
       @Override
       public void onViewRecycled(RecyclerView.ViewHolder holder) {
         PhotoTitleViewHolder vh = (PhotoTitleViewHolder) holder;
-        requestManager.clear(vh.imageView);
+        glideRequests.clear(vh.imageView);
       }
     });
 
@@ -109,7 +106,7 @@ public void onViewRecycled(RecyclerView.ViewHolder holder) {
   }
 
   @Override
-  public void onSaveInstanceState(Bundle outState) {
+  public void onSaveInstanceState(@NonNull Bundle outState) {
     super.onSaveInstanceState(outState);
     if (list != null) {
       int index = layoutManager.findFirstVisibleItemPosition();
@@ -120,16 +117,16 @@ public void onSaveInstanceState(Bundle outState) {
     }
   }
 
-  private class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
+  private final class FlickrPhotoListAdapter extends RecyclerView.Adapter<PhotoTitleViewHolder>
       implements ListPreloader.PreloadModelProvider<Photo> {
     private final LayoutInflater inflater;
     private List<Photo> photos = Collections.emptyList();
 
-    public FlickrPhotoListAdapter() {
+    FlickrPhotoListAdapter() {
       this.inflater = LayoutInflater.from(getActivity());
     }
 
-    public void setPhotos(List<Photo> photos) {
+    void setPhotos(List<Photo> photos) {
       this.photos = photos;
       notifyDataSetChanged();
     }
@@ -170,25 +167,27 @@ public int getItemCount() {
       return photos.size();
     }
 
+    @NonNull
     @Override
     public List<Photo> getPreloadItems(int position) {
       return photos.subList(position, position + 1);
     }
 
+    @Nullable
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Photo item) {
       return fullRequest.thumbnail(thumbRequest.load(item)).load(item);
     }
   }
 
-  private static class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
+  private static final class PhotoTitleViewHolder extends RecyclerView.ViewHolder {
     private final TextView titleView;
     private final ImageView imageView;
 
-    public PhotoTitleViewHolder(View itemView) {
+    PhotoTitleViewHolder(View itemView) {
       super(itemView);
-      imageView = (ImageView) itemView.findViewById(R.id.photo_view);
-      titleView = (TextView) itemView.findViewById(R.id.title_view);
+      imageView = itemView.findViewById(R.id.photo_view);
+      titleView = itemView.findViewById(R.id.title_view);
     }
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index 8a924d58a..d1b57740e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -1,9 +1,7 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.res.Resources;
-import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.HandlerThread;
@@ -12,7 +10,6 @@
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.view.MenuItemCompat;
 import android.support.v4.view.ViewPager;
 import android.support.v7.app.AppCompatActivity;
 import android.text.TextUtils;
@@ -23,16 +20,12 @@
 import android.view.ViewGroup;
 import android.widget.SearchView;
 import android.widget.TextView;
-
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.samples.flickr.api.Query;
-import com.bumptech.glide.samples.flickr.api.RecentQuery;
 import com.bumptech.glide.samples.flickr.api.SearchQuery;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -51,12 +44,14 @@
     implements SearchView.OnQueryTextListener {
   private static final String TAG = "FlickrSearchActivity";
   private static final String STATE_QUERY = "state_search_string";
+  private static final Query DEFAULT_QUERY = new SearchQuery("kitten");
 
   private final QueryListener queryListener = new QueryListener();
+  private final Set<PhotoViewer> photoViewers = new HashSet<>();
+
+  private List<Photo> currentPhotos = new ArrayList<>();
   private View searching;
   private TextView searchTerm;
-  private Set<PhotoViewer> photoViewers = new HashSet<>();
-  private List<Photo> currentPhotos = new ArrayList<>();
   private View searchLoading;
   private BackgroundThumbnailFetcher backgroundThumbnailFetcher;
   private HandlerThread backgroundThread;
@@ -70,13 +65,14 @@
     LIST
   }
 
-  private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() {
-    {
-      put(Page.SMALL, R.string.small);
-      put(Page.MEDIUM, R.string.medium);
-      put(Page.LIST, R.string.list);
-    }
-  };
+  private static final Map<Page, Integer> PAGE_TO_TITLE;
+  static {
+    Map<Page, Integer> temp = new HashMap<>();
+    temp.put(Page.SMALL, R.string.small);
+    temp.put(Page.MEDIUM, R.string.medium);
+    temp.put(Page.LIST, R.string.list);
+    PAGE_TO_TITLE = Collections.unmodifiableMap(temp);
+  }
 
   @Override
   public void onAttachFragment(Fragment fragment) {
@@ -95,8 +91,7 @@ public boolean onCreateOptionsMenu(Menu menu) {
     MenuInflater menuInflater = getMenuInflater();
     menuInflater.inflate(R.menu.search_activity, menu);
 
-    searchView =
-        (SearchView) MenuItemCompat.getActionView(menu.findItem(R.id.search));
+    searchView = (SearchView) menu.findItem(R.id.search).getActionView();
     searchView.setSubmitButtonEnabled(true);
     searchView.setIconified(false);
     searchView.setOnQueryTextListener(this);
@@ -148,7 +143,7 @@ public void onCreate(Bundle savedInstanceState) {
         executeQuery(savedQuery);
       }
     } else {
-      executeQuery(RecentQuery.get());
+      executeQuery(DEFAULT_QUERY);
     }
 
     int smallGridSize = res.getDimensionPixelSize(R.dimen.small_photo_side);
@@ -159,7 +154,8 @@ public void onCreate(Bundle savedInstanceState) {
     if (savedInstanceState == null) {
       // Weight values determined experimentally by measuring the number of incurred GCs while
       // scrolling through the various photo grids/lists.
-      Glide.get(this).preFillBitmapPool(new PreFillType.Builder(smallGridSize).setWeight(1),
+      GlideApp.get(this).preFillBitmapPool(
+          new PreFillType.Builder(smallGridSize).setWeight(1),
           new PreFillType.Builder(mediumGridSize).setWeight(1),
           new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
     }
@@ -189,19 +185,6 @@ protected void onDestroy() {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  @Override
-  public void onTrimMemory(int level) {
-    super.onTrimMemory(level);
-    Glide.get(this).trimMemory(level);
-  }
-
-  @Override
-  public void onLowMemory() {
-    super.onLowMemory();
-    Glide.get(this).clearMemory();
-  }
-
   private void executeSearch(String searchString) {
     Query query = TextUtils.isEmpty(searchString) ? null : new SearchQuery(searchString);
     executeQuery(query);
@@ -267,12 +250,12 @@ public void onSearchFailed(Query query, Exception e) {
     }
   }
 
-  private class FlickrPagerAdapter extends FragmentPagerAdapter {
+  private final class FlickrPagerAdapter extends FragmentPagerAdapter {
 
     private int mLastPosition = -1;
     private Fragment mLastFragment;
 
-    public FlickrPagerAdapter(FragmentManager fm) {
+    FlickrPagerAdapter(FragmentManager fm) {
       super(fm);
     }
 
@@ -286,13 +269,13 @@ public void setPrimaryItem(ViewGroup container, int position, Object object) {
       super.setPrimaryItem(container, position, object);
       if (position != mLastPosition) {
         if (mLastPosition >= 0) {
-          Glide.with(mLastFragment).pauseRequests();
+          GlideApp.with(mLastFragment).pauseRequests();
         }
         Fragment current = (Fragment) object;
         mLastPosition = position;
         mLastFragment = current;
         if (current.isAdded()) {
-          Glide.with(current).resumeRequests();
+          GlideApp.with(current).resumeRequests();
         }
       }
     }
@@ -330,16 +313,17 @@ private int getPageSize(int id) {
   }
 
   private static class BackgroundThumbnailFetcher implements Runnable {
+    private final Context context;
+    private final List<Photo> photos;
+
     private boolean isCancelled;
-    private Context context;
-    private List<Photo> photos;
 
-    public BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
+    BackgroundThumbnailFetcher(Context context, List<Photo> photos) {
       this.context = context;
       this.photos = photos;
     }
 
-    public void cancel() {
+    void cancel() {
       isCancelled = true;
     }
 
@@ -351,10 +335,10 @@ public void run() {
           return;
         }
 
-        FutureTarget<File> futureTarget = Glide.with(context)
+        FutureTarget<File> futureTarget = GlideApp.with(context)
             .downloadOnly()
             .load(photo)
-            .into(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
+            .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
 
         try {
           futureTarget.get();
@@ -367,7 +351,7 @@ public void run() {
             Log.d(TAG, "Got ExecutionException waiting for background downloadOnly", e);
           }
         }
-        Glide.with(context).clear(futureTarget);
+        GlideApp.with(context).clear(futureTarget);
       }
     }
   }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index ab474658f..ba3095dc2 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.samples.flickr;
 
-
 import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
 
 import android.content.Context;
@@ -8,8 +7,6 @@
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
 import android.widget.ImageView;
-
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
 /**
@@ -31,9 +28,6 @@ protected void onCreate(Bundle savedInstanceState) {
     ImageView fullscreenView = (ImageView) findViewById(R.id.fullscreen_view);
     Photo photo = getIntent().getParcelableExtra(ARG_PHOTO);
 
-    Glide.with(this)
-        .load(photo)
-        .apply(fitCenterTransform(this))
-        .into(fullscreenView);
+    GlideApp.with(this).load(photo).apply(fitCenterTransform()).into(fullscreenView);
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
index b91230272..28e88ecb5 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
@@ -1,18 +1,17 @@
 package com.bumptech.glide.samples.flickr;
 
 import com.bumptech.glide.samples.flickr.api.Photo;
-
 import java.util.List;
 
 /**
  * An interface for an object that displays {@link com.bumptech.glide.samples.flickr.api.Photo}
  * objects.
  */
-public interface PhotoViewer {
+interface PhotoViewer {
   /**
    * Called whenever new {@link com.bumptech.glide.samples.flickr.api.Photo}s are loaded.
    *
    * @param photos The loaded photos.
    */
-  public void onPhotosUpdated(List<Photo> photos);
+  void onPhotosUpdated(List<Photo> photos);
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
index 1560cf82e..e6cce5ec7 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.os.Build;
+import android.support.v7.widget.AppCompatImageView;
 import android.util.AttributeSet;
 import android.widget.ImageView;
 
 /**
  * An always square {@link ImageView}.
  */
-public final class SquareImageView extends ImageView {
+public final class SquareImageView extends AppCompatImageView {
 
   public SquareImageView(Context context) {
     super(context);
@@ -23,11 +22,8 @@ public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
   }
 
-  @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-  public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-    super(context, attrs, defStyleAttr, defStyleRes);
-  }
-
+  // We want a square view.
+  @SuppressWarnings("SuspiciousNameCombination")
   @Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     super.onMeasure(widthMeasureSpec, widthMeasureSpec);
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
index e31424079..6fa99de2c 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
@@ -2,14 +2,12 @@
 
 import android.content.Context;
 import android.util.SparseArray;
-
 import com.android.volley.DefaultRetryPolicy;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.StringRequest;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.util.LruCache;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
@@ -19,9 +17,8 @@
 /**
  * A class for interfacing with Flickr's http API.
  */
-public class Api {
+public final class Api {
   private static Api api;
-  private static final String TAG = "FlickrApi";
   private static final String API_KEY = "f0e6fbb5fdf1f3842294a1d21f84e8a6";
   private static final String SIGNED_API_URL =
       "https://api.flickr.com/services/rest/?method=%s&format=json&api_key=" + API_KEY;
@@ -75,7 +72,9 @@ private static String getSizeKey(int width, int height) {
 
     boolean isFirstLargest = true;
     List<String> result = new ArrayList<>();
-    for (int edge : SORTED_SIZE_KEYS) {
+    int size = result.size();
+    for (int i = 0; i < size; i++) {
+      int edge = SORTED_SIZE_KEYS.get(i);
       if (largestEdge <= edge) {
         if (isFirstLargest) {
           isFirstLargest = false;
@@ -88,7 +87,7 @@ private static String getSizeKey(int width, int height) {
 
   }
 
-  public static String getCacheableUrl(Photo photo) {
+  static String getCacheableUrl(Photo photo) {
     return String.format(CACHEABLE_PHOTO_URL, photo.getFarm(), photo.getServer(), photo.getId(),
         photo.getSecret());
   }
@@ -156,10 +155,10 @@ public static Api get(Context context) {
   }
 
   private final RequestQueue requestQueue;
-  private final Set<QueryListener> queryListeners = new HashSet<QueryListener>();
+  private final Set<QueryListener> queryListeners = new HashSet<>();
   private QueryResult lastQueryResult;
 
-  protected Api(Context context) {
+  private Api(Context context) {
     this.requestQueue = Volley.newRequestQueue(context.getApplicationContext());
     QueryListener queryListener = new QueryListener() {
       @Override
@@ -204,7 +203,7 @@ public void query(Query query) {
     private final Query query;
     private final List<Photo> results;
 
-    public QueryResult(Query query, List<Photo> results) {
+    QueryResult(Query query, List<Photo> results) {
       this.query = query;
       this.results = results;
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
index cdc081bf3..5bd75a67c 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
@@ -2,11 +2,9 @@
 
 import com.android.volley.Response;
 import com.android.volley.VolleyError;
-
-import org.json.JSONException;
-
 import java.util.Collection;
 import java.util.List;
+import org.json.JSONException;
 
 /**
  * Handles photo list responses and errors from Flickr API calls.
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
index 36cb19ab6..8ff5f5b9a 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
@@ -2,7 +2,6 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-
 import org.json.JSONException;
 import org.json.JSONObject;
 
@@ -91,6 +90,7 @@ public String toString() {
     return getPartialUrl();
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
index 50522b63e..8345e0392 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.samples.flickr.api;
 
+import java.util.ArrayList;
+import java.util.List;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * Parses a list of {@link Photo} objects from a Flickr API response string containing JSON data.
  */
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
index b3442f26b..2858df855 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/RecentQuery.java
@@ -2,7 +2,7 @@
 
 import android.os.Parcel;
 
-/** Query wusing flickr's recent API. */
+/** Query using Flickr's recent API. */
 public final class RecentQuery implements Query {
   public static final Creator<RecentQuery> CREATOR = new Creator<RecentQuery>() {
     @Override
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
index 5a53ad9fd..d21744355 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
@@ -2,6 +2,6 @@
 <com.bumptech.glide.samples.flickr.SquareImageView
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:scaleType="centerCrop"
-       android:layout_width="fill_parent"
-       android:layout_height="fill_parent"
+       android:layout_width="match_parent"
+       android:layout_height="match_parent"
        android:contentDescription="@string/image_description"/>
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index 8346d8778..7b40050cb 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -1,24 +1,24 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.gallery'
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
-        versionName "1.0"
+        versionName '1.0'
     }
 
     compileOptions {
@@ -29,5 +29,5 @@ android {
 
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
-    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.flickr/.FlickrSearchActivity'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.gallery/.MainActivity'
 }
diff --git a/samples/gallery/lint.xml b/samples/gallery/lint.xml
index 5c710c8c7..ac292ab1a 100644
--- a/samples/gallery/lint.xml
+++ b/samples/gallery/lint.xml
@@ -3,4 +3,5 @@
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
 </lint>
diff --git a/samples/gallery/src/main/AndroidManifest.xml b/samples/gallery/src/main/AndroidManifest.xml
index 7a38c3fb1..41c16f292 100644
--- a/samples/gallery/src/main/AndroidManifest.xml
+++ b/samples/gallery/src/main/AndroidManifest.xml
@@ -4,10 +4,6 @@
 
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
 
-  <uses-sdk
-        android:minSdkVersion="10"
-        android:targetSdkVersion="22" />
-
   <application
           android:label="@string/app_name"
           android:icon="@android:drawable/sym_def_app_icon"
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
new file mode 100644
index 000000000..e5d4888ab
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.gallery;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Ensures that Glide's generated API is created for the Gallery sample.
+ */
+@GlideModule
+public final class GalleryModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
index 35e1376fd..46ac3d232 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.samples.gallery;
 
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.LoaderManager;
 import android.support.v4.content.Loader;
@@ -9,11 +10,7 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
-
 import java.util.List;
 
 /**
@@ -31,8 +28,8 @@ public void onCreate(Bundle savedInstanceState) {
   }
 
   @Override
-  public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
+  public View onCreateView(
+      @NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
     View result = inflater.inflate(R.layout.recycler_view, container, false);
     recyclerView = (RecyclerView) result.findViewById(R.id.recycler_view);
     GridLayoutManager layoutManager = new GridLayoutManager(getActivity(), 1);
@@ -51,11 +48,11 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
   @Override
   public void onLoadFinished(Loader<List<MediaStoreData>> loader,
       List<MediaStoreData> mediaStoreData) {
-    RequestManager requestManager = Glide.with(this);
+    GlideRequests glideRequests = GlideApp.with(this);
     RecyclerAdapter adapter =
-        new RecyclerAdapter(getActivity(), mediaStoreData, requestManager);
+        new RecyclerAdapter(getActivity(), mediaStoreData, glideRequests);
     RecyclerViewPreloader<MediaStoreData> preloader =
-        new RecyclerViewPreloader<>(requestManager, adapter, adapter, 3);
+        new RecyclerViewPreloader<>(glideRequests, adapter, adapter, 3);
     recyclerView.addOnScrollListener(preloader);
     recyclerView.setAdapter(adapter);
   }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index 4c7c3e509..1206230ff 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -1,20 +1,70 @@
 package com.bumptech.glide.samples.gallery;
 
+import android.Manifest.permission;
+import android.content.pm.PackageManager;
+import android.os.Build;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
-
-import com.bumptech.glide.Glide;
+import android.support.v4.content.ContextCompat;
+import android.widget.Toast;
 import com.bumptech.glide.MemoryCategory;
 
 /**
  * Displays a {@link HorizontalGalleryFragment}.
  */
+@RequiresApi(Build.VERSION_CODES.JELLY_BEAN)
 public class MainActivity extends FragmentActivity {
 
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main_activity);
-        Glide.get(this).setMemoryCategory(MemoryCategory.HIGH);
+  private static final int REQUEST_READ_STORAGE = 0;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.main_activity);
+    GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
+        && ContextCompat.checkSelfPermission(this, permission.READ_EXTERNAL_STORAGE)
+        != PackageManager.PERMISSION_GRANTED) {
+      requestStoragePermission();
+    } else {
+      replaceFragment();
+    }
+  }
+
+  private void requestStoragePermission() {
+     ActivityCompat.requestPermissions(this,
+        new String[]{permission.READ_EXTERNAL_STORAGE},
+        REQUEST_READ_STORAGE);
+  }
+
+  private void replaceFragment() {
+    Fragment fragment = new HorizontalGalleryFragment();
+    getSupportFragmentManager()
+        .beginTransaction()
+        .replace(R.id.fragment_container, fragment)
+        .commit();
+  }
+
+  @Override
+  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
+      @NonNull int[] grantResults) {
+    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+    switch (requestCode) {
+      case REQUEST_READ_STORAGE: {
+        // If request is cancelled, the result arrays are empty.
+        if (grantResults.length > 0
+            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+          replaceFragment();
+        } else {
+          Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG)
+              .show();
+          requestStoragePermission();
+        }
+      }
     }
+  }
 }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
index 8663eafdd..c0c924e15 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreData.java
@@ -25,15 +25,15 @@ public int describeContents() {
     return 0;
   }
 
-  public final long rowId;
-  public final Uri uri;
-  public final String mimeType;
-  public final long dateModified;
-  public final int orientation;
-  public final Type type;
-  public final long dateTaken;
+  final long rowId;
+  final Uri uri;
+  final String mimeType;
+  final long dateModified;
+  final int orientation;
+  private final Type type;
+  final long dateTaken;
 
-  public MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long dateModified,
+  MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long dateModified,
       int orientation, Type type) {
     this.rowId = rowId;
     this.uri = uri;
@@ -44,7 +44,7 @@ public MediaStoreData(long rowId, Uri uri, String mimeType, long dateTaken, long
     this.dateTaken = dateTaken;
   }
 
-  MediaStoreData(Parcel in) {
+  private MediaStoreData(Parcel in) {
     rowId = in.readLong();
     uri = Uri.parse(in.readString());
     mimeType = in.readString();
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
index e8d2bb95c..372e9dbe8 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
@@ -6,7 +6,6 @@
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.support.v4.content.AsyncTaskLoader;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -38,7 +37,7 @@
   private boolean observerRegistered = false;
   private final ForceLoadContentObserver forceLoadContentObserver = new ForceLoadContentObserver();
 
-  public MediaStoreDataLoader(Context context) {
+  MediaStoreDataLoader(Context context) {
     super(context);
   }
 
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 1b26904ad..665cccffe 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -1,13 +1,10 @@
 package com.bumptech.glide.samples.gallery;
 
-import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
-import static com.bumptech.glide.request.RequestOptions.signatureOf;
-
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v7.widget.RecyclerView;
 import android.view.Display;
 import android.view.LayoutInflater;
@@ -16,44 +13,40 @@
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
 import android.widget.ImageView;
-
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.signature.MediaStoreSignature;
-
+import com.bumptech.glide.util.Preconditions;
 import java.util.Collections;
 import java.util.List;
 
 /**
  * Displays {@link com.bumptech.glide.samples.gallery.MediaStoreData} in a recycler view.
  */
-class RecyclerAdapter extends RecyclerView.Adapter
+class RecyclerAdapter extends RecyclerView.Adapter<RecyclerAdapter.ListViewHolder>
     implements ListPreloader.PreloadSizeProvider<MediaStoreData>,
     ListPreloader.PreloadModelProvider<MediaStoreData> {
 
   private final List<MediaStoreData> data;
   private final int screenWidth;
-  private final RequestBuilder<Drawable> requestBuilder;
+  private final GlideRequest<Drawable> requestBuilder;
 
   private int[] actualDimensions;
 
-  RecyclerAdapter(Context context, List<MediaStoreData> data, RequestManager requestManager) {
+  RecyclerAdapter(Context context, List<MediaStoreData> data, GlideRequests glideRequests) {
     this.data = data;
-    requestBuilder = requestManager
-        .asDrawable()
-        .apply(fitCenterTransform(context));
+    requestBuilder = glideRequests.asDrawable().fitCenter();
 
     setHasStableIds(true);
 
-    screenWidth = getWidth(context);
+    screenWidth = getScreenWidth(context);
   }
 
   @Override
-  public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
-    final View view = LayoutInflater.from(viewGroup.getContext())
-        .inflate(R.layout.recycler_item, viewGroup, false);
+  public ListViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
+    LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext());
+    final View view = inflater.inflate(R.layout.recycler_item, viewGroup, false);
     view.getLayoutParams().width = screenWidth;
 
     if (actualDimensions == null) {
@@ -73,19 +66,17 @@ public boolean onPreDraw() {
   }
 
   @Override
-  public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {
+  public void onBindViewHolder(ListViewHolder viewHolder, int position) {
     MediaStoreData current = data.get(position);
 
-    final ListViewHolder vh = (ListViewHolder) viewHolder;
-
     Key signature =
         new MediaStoreSignature(current.mimeType, current.dateModified, current.orientation);
 
     requestBuilder
         .clone()
-        .apply(signatureOf(signature))
+        .signature(signature)
         .load(current.uri)
-        .into(vh.image);
+        .into(viewHolder.image);
   }
 
   @Override
@@ -103,55 +94,51 @@ public int getItemViewType(int position) {
     return 0;
   }
 
+  @NonNull
   @Override
   public List<MediaStoreData> getPreloadItems(int position) {
     return Collections.singletonList(data.get(position));
   }
 
+  @Nullable
   @Override
-  public RequestBuilder getPreloadRequestBuilder(MediaStoreData item) {
+  public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull MediaStoreData item) {
     MediaStoreSignature signature =
         new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
     return requestBuilder
         .clone()
-        .apply(signatureOf(signature))
+        .signature(signature)
         .load(item.uri);
   }
 
+  @Nullable
   @Override
-  public int[] getPreloadSize(MediaStoreData item, int adapterPosition, int perItemPosition) {
+  public int[] getPreloadSize(@NonNull MediaStoreData item, int adapterPosition,
+      int perItemPosition) {
     return actualDimensions;
   }
 
   // Display#getSize(Point)
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
   @SuppressWarnings("deprecation")
-  private static int getWidth(Context context) {
+  private static int getScreenWidth(Context context) {
     WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-    Display display = wm.getDefaultDisplay();
-
-    final int result;
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
-      Point size = new Point();
-      display.getSize(size);
-      result = size.x;
-    } else {
-      result = display.getWidth();
-    }
-    return result;
+    Display display = Preconditions.checkNotNull(wm).getDefaultDisplay();
+    Point size = new Point();
+    display.getSize(size);
+    return size.x;
   }
 
   /**
    * ViewHolder containing views to display individual {@link
    * com.bumptech.glide.samples.gallery.MediaStoreData}.
    */
-  public static final class ListViewHolder extends RecyclerView.ViewHolder {
+  static final class ListViewHolder extends RecyclerView.ViewHolder {
 
     private final ImageView image;
 
-    public ListViewHolder(View itemView) {
+    ListViewHolder(View itemView) {
       super(itemView);
-      image = (ImageView) itemView.findViewById(R.id.image);
+      image = itemView.findViewById(R.id.image);
     }
   }
 }
diff --git a/samples/gallery/src/main/res/layout/main_activity.xml b/samples/gallery/src/main/res/layout/main_activity.xml
index 18c1a634f..26fd8b6a8 100644
--- a/samples/gallery/src/main/res/layout/main_activity.xml
+++ b/samples/gallery/src/main/res/layout/main_activity.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<merge xmlns:android="http://schemas.android.com/apk/res/android">
-    <fragment
-            android:name="com.bumptech.glide.samples.gallery.HorizontalGalleryFragment"
-            android:layout_width="match_parent"
-            android:layout_height="match_parent"
-            android:id="@+id/horizontal_gallery_fragment"/>
-</merge>
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  tools:ignore="MergeRootFrame"
+  android:id="@+id/fragment_container"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent" />
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index 54054fe42..f224a53a9 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -1,24 +1,25 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-    compile project(':library')
-    compile(project(':integration:recyclerview')) {
+    implementation project(':library')
+    implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile 'com.google.code.gson:gson:2.3'
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    implementation 'com.google.code.gson:gson:2.8.2'
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.giphy'
-        minSdkVersion 14
+        minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
-        versionName '1.0.0'
+        versionName '1.0'
     }
 
     compileOptions {
diff --git a/samples/giphy/lint.xml b/samples/giphy/lint.xml
index 95a2ab036..94bb2b69c 100644
--- a/samples/giphy/lint.xml
+++ b/samples/giphy/lint.xml
@@ -2,4 +2,5 @@
 <lint>
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
 </lint>
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index 4fa0d5d60..469e1295a 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -3,12 +3,14 @@
           package="com.bumptech.glide.samples.giphy">
 
     <uses-permission android:name="android.permission.INTERNET"/>
-
-    <uses-sdk android:minSdkVersion="14"
-      android:targetSdkVersion="22" />
+    <!--
+    Allows Glide to monitor connectivity status and restart failed requests if users go from a
+    a disconnected to a connected network state.
+    -->
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
 
     <application
-        android:allowBackup="true"
+        android:allowBackup="false"
         android:icon="@android:drawable/sym_def_app_icon"
         android:largeHeap="true"
         android:label="@string/app_name"
@@ -23,10 +25,5 @@
             </intent-filter>
         </activity>
         <activity android:name=".FullscreenActivity"/>
-
-        <meta-data
-            android:name="com.bumptech.glide.samples.giphy.GiphyGlideModule"
-            android:value="GlideModule"/>
     </application>
-
 </manifest>
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
index b7c0de95a..e58c5bd0d 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
@@ -1,11 +1,9 @@
 package com.bumptech.glide.samples.giphy;
 
-import com.google.gson.Gson;
-
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
-
+import com.google.gson.Gson;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -22,23 +20,19 @@
   private static volatile Api api = null;
   private static final String BETA_KEY = "dc6zaTOxFJmzC";
   private static final String BASE_URL = "https://api.giphy.com/";
-  private static final String SEARCH_PATH = "v1/gifs/search";
   private static final String TRENDING_PATH = "v1/gifs/trending";
+  private static final int LIMIT = 100;
+  private static final int OFFSET = 0;
   private final Handler bgHandler;
   private final Handler mainHandler;
-  private final HashSet<Monitor> monitors = new HashSet<Monitor>();
+  private final HashSet<Monitor> monitors = new HashSet<>();
 
   private static String signUrl(String url) {
     return url + "&api_key=" + BETA_KEY;
   }
 
-  private static String getSearchUrl(String query, int limit, int offset) {
-    return signUrl(
-        BASE_URL + SEARCH_PATH + "?q=" + query + "&limit=" + limit + "&offset=" + offset);
-  }
-
-  private static String getTrendingUrl(int limit, int offset) {
-    return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + limit + "&offset=" + offset);
+  private static String getTrendingUrl() {
+    return signUrl(BASE_URL + TRENDING_PATH + "?limit=" + LIMIT + "&offset=" + OFFSET);
   }
 
   /**
@@ -53,7 +47,7 @@ private static String getTrendingUrl(int limit, int offset) {
     void onSearchComplete(SearchResult result);
   }
 
-  public static Api get() {
+  static Api get() {
     if (api == null) {
       synchronized (Api.class) {
         if (api == null) {
@@ -72,21 +66,16 @@ private Api() {
     // Do nothing.
   }
 
-  public void addMonitor(Monitor monitor) {
+  void addMonitor(Monitor monitor) {
     monitors.add(monitor);
   }
 
-  public void removeMonitor(Monitor monitor) {
+  void removeMonitor(Monitor monitor) {
     monitors.remove(monitor);
   }
 
-  public void search(String searchTerm) {
-    String searchUrl = getSearchUrl(searchTerm, 100, 0);
-    query(searchUrl);
-  }
-
-  public void getTrending() {
-    String trendingUrl = getTrendingUrl(100, 0);
+  void getTrending() {
+    String trendingUrl = getTrendingUrl();
     query(trendingUrl);
   }
 
@@ -140,7 +129,7 @@ public void run() {
   /**
    * A POJO mirroring the top level result JSON object returned from Giphy's api.
    */
-  public static class SearchResult {
+  public static final class SearchResult {
     public GifResult[] data;
 
     @Override
@@ -152,15 +141,13 @@ public String toString() {
   /**
    * A POJO mirroring an individual GIF image returned from Giphy's api.
    */
-  public static class GifResult {
+  public static final class GifResult {
     public String id;
-    // Page url not gif url
-    public String url;
-    public GifUrlSet images;
+    GifUrlSet images;
 
     @Override
     public String toString() {
-      return "GifResult{" + "id='" + id + '\'' + ", url='" + url + '\'' + ", images=" + images
+      return "GifResult{" + "id='" + id + '\'' + ", images=" + images
           + '}';
     }
   }
@@ -169,10 +156,10 @@ public String toString() {
    * A POJO mirroring a JSON object with a put of urls of different sizes and dimensions returned
    * for a single image from Giphy's api.
    */
-  public static class GifUrlSet {
-    public GifImage original;
-    public GifImage fixed_width;
-    public GifImage fixed_height;
+  public static final class GifUrlSet {
+    GifImage original;
+    GifImage fixed_width;
+    GifImage fixed_height;
 
     @Override
     public String toString() {
@@ -186,17 +173,14 @@ public String toString() {
    * A POJO mirroring a JSON object for an image with one particular url, size and dimension
    * returned from Giphy's api.
    */
-  public static class GifImage {
-    public String url;
-    public int width;
-    public int height;
-    public int frames;
-    public int size;
+  public static final class GifImage {
+    String url;
+    int width;
+    int height;
 
     @Override
     public String toString() {
-      return "GifImage{" + "url='" + url + '\'' + ", width=" + width + ", height=" + height
-          + ", frames=" + frames + ", size=" + size + '}';
+      return "GifImage{" + "url='" + url + '\'' + ", width=" + width + ", height=" + height + '}';
     }
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
index 47ef06e8e..fd92665ea 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
@@ -1,9 +1,5 @@
 package com.bumptech.glide.samples.giphy;
 
-import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
-
-import com.google.gson.Gson;
-
 import android.app.Activity;
 import android.content.ClipData;
 import android.content.ClipboardManager;
@@ -14,14 +10,13 @@
 import android.os.Bundle;
 import android.view.View;
 import android.widget.ImageView;
-
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.Target;
+import com.google.gson.Gson;
 
 /**
  * An {@link android.app.Activity} for displaying full size original GIFs.
@@ -63,11 +58,11 @@ public void onClick(View view) {
       }
     });
 
-    RequestBuilder<Drawable> thumbnailRequest = Glide.with(this)
+    RequestBuilder<Drawable> thumbnailRequest = GlideApp.with(this)
         .load(result)
-        .apply(decodeTypeOf(Bitmap.class));
+        .decode(Bitmap.class);
 
-    Glide.with(this)
+    GlideApp.with(this)
         .load(result.images.original.url)
         .thumbnail(thumbnailRequest)
         .listener(new RequestListener<Drawable>() {
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
index 7bc9bab9c..6fbca3826 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -1,24 +1,27 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.content.Context;
-
-import com.bumptech.glide.GlideBuilder;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
-
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import java.io.InputStream;
 
 /**
- * {@link com.bumptech.glide.module.GlideModule} implementation for the Giphy sample app.
+ * Configures Glide for the Giphy sample app.
  */
-public class GiphyGlideModule implements GlideModule {
+@GlideModule
+public class GiphyGlideModule extends AppGlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
   }
 
+  // Disable manifest parsing to avoid adding similar modules twice.
   @Override
-  public void registerComponents(Context context, Registry registry) {
-    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
+  public boolean isManifestParsingEnabled() {
+    return false;
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index 3d27c6fe7..a0163074e 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.samples.giphy;
 
-import android.content.Context;
+import android.support.annotation.NonNull;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
-
+import com.bumptech.glide.samples.giphy.Api.GifResult;
 import java.io.InputStream;
 
 /**
@@ -17,32 +16,14 @@
  * Giphy's api into an {@link java.io.InputStream} that can be decoded into an
  * {@link android.graphics.drawable.Drawable}.
  */
-public class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
+public final class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
 
   @Override
-  public boolean handles(Api.GifResult model) {
+  public boolean handles(@NonNull Api.GifResult model) {
     return true;
   }
 
-  /**
-   * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
-   */
-  public static class Factory implements ModelLoaderFactory<Api.GifResult, InputStream> {
-
-
-    @Override
-    public ModelLoader<Api.GifResult, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
-    }
-
-    @Override
-    public void teardown() {
-      // Do nothing.
-    }
-  }
-
-  public GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
+  private GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
     super(urlLoader);
   }
 
@@ -66,4 +47,20 @@ protected String getUrl(Api.GifResult model, int width, int height, Options opti
   private static int getDifference(Api.GifImage gifImage, int width, int height) {
     return Math.abs(width - gifImage.width) + Math.abs(height - gifImage.height);
   }
+
+  /**
+   * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
+   */
+  public static final class Factory implements ModelLoaderFactory<GifResult, InputStream> {
+    @NonNull
+    @Override
+    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index 80e9f4fed..947518cca 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -7,18 +7,20 @@
 import android.content.Intent;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.RecyclerListener;
+import android.support.v7.widget.RecyclerView.ViewHolder;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
-
 import java.util.Collections;
 import java.util.List;
 
@@ -34,25 +36,35 @@ protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.activity_main);
 
-    ImageView giphyLogoView = (ImageView) findViewById(R.id.giphy_logo_view);
+    ImageView giphyLogoView = findViewById(R.id.giphy_logo_view);
 
-    Glide.with(this)
+    GlideApp.with(this)
         .load(R.raw.large_giphy_logo)
         .into(giphyLogoView);
 
-    RecyclerView gifList = (RecyclerView) findViewById(R.id.gif_list);
+    RecyclerView gifList = findViewById(R.id.gif_list);
     LinearLayoutManager layoutManager = new LinearLayoutManager(this);
     gifList.setLayoutManager(layoutManager);
 
-    RequestBuilder<Drawable> gifItemRequest = Glide.with(this).asDrawable();
+    RequestBuilder<Drawable> gifItemRequest = GlideApp.with(this)
+        .asDrawable();
 
     ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider =
         new ViewPreloadSizeProvider<>();
     adapter = new GifAdapter(this, gifItemRequest, preloadSizeProvider);
     gifList.setAdapter(adapter);
     RecyclerViewPreloader<Api.GifResult> preloader =
-        new RecyclerViewPreloader<>(Glide.with(this), adapter, preloadSizeProvider, 4);
+        new RecyclerViewPreloader<>(GlideApp.with(this), adapter, preloadSizeProvider, 4);
     gifList.addOnScrollListener(preloader);
+    gifList.setRecyclerListener(new RecyclerListener() {
+      @Override
+      public void onViewRecycled(ViewHolder holder) {
+        // This is an optimization to reduce the memory usage of RecyclerView's recycled view pool
+        // and good practice when using Glide with RecyclerView.
+        GifViewHolder gifViewHolder = (GifViewHolder) holder;
+        GlideApp.with(MainActivity.this).clear(gifViewHolder.gifView);
+      }
+    });
   }
 
   @Override
@@ -80,19 +92,19 @@ public void onSearchComplete(Api.SearchResult result) {
     private static final Api.GifResult[] EMPTY_RESULTS = new Api.GifResult[0];
 
     private final Activity activity;
-    private RequestBuilder<Drawable> requestBuilder;
-    private ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
+    private final RequestBuilder<Drawable> requestBuilder;
+    private final ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider;
 
     private Api.GifResult[] results = EMPTY_RESULTS;
 
-    public GifAdapter(Activity activity, RequestBuilder<Drawable> requestBuilder,
+    GifAdapter(Activity activity, RequestBuilder<Drawable> requestBuilder,
         ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider) {
       this.activity = activity;
       this.requestBuilder = requestBuilder;
       this.preloadSizeProvider = preloadSizeProvider;
     }
 
-    public void setResults(Api.GifResult[] results) {
+    void setResults(Api.GifResult[] results) {
       if (results != null) {
         this.results = results;
       } else {
@@ -117,14 +129,16 @@ public void onClick(View view) {
               (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
           ClipData clip =
               ClipData.newPlainText("giphy_url", result.images.fixed_height.url);
-          clipboard.setPrimaryClip(clip);
+          Preconditions.checkNotNull(clipboard).setPrimaryClip(clip);
 
           Intent fullscreenIntent = FullscreenActivity.getIntent(activity, result);
           activity.startActivity(fullscreenIntent);
         }
       });
 
-      requestBuilder.load(result).into(holder.gifView);
+      // clearOnDetach let's us stop animating GifDrawables that RecyclerView hasn't yet recycled
+      // but that are currently off screen.
+      requestBuilder.load(result).into(holder.gifView).clearOnDetach();
 
       preloadSizeProvider.setView(holder.gifView);
     }
@@ -139,13 +153,15 @@ public int getItemCount() {
       return results.length;
     }
 
+    @NonNull
     @Override
     public List<Api.GifResult> getPreloadItems(int position) {
       return Collections.singletonList(results[position]);
     }
 
+    @Nullable
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Api.GifResult item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(@NonNull Api.GifResult item) {
       return requestBuilder.load(item);
     }
   }
@@ -153,9 +169,9 @@ public RequestBuilder getPreloadRequestBuilder(Api.GifResult item) {
   private static class GifViewHolder extends RecyclerView.ViewHolder {
     private final ImageView gifView;
 
-    public GifViewHolder(View itemView) {
+    GifViewHolder(View itemView) {
       super(itemView);
-      gifView = (ImageView) itemView.findViewById(R.id.gif_view);
+      gifView = itemView.findViewById(R.id.gif_view);
     }
   }
 }
diff --git a/samples/imgur/.gitignore b/samples/imgur/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/samples/imgur/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/samples/imgur/build.gradle b/samples/imgur/build.gradle
new file mode 100644
index 000000000..215392a94
--- /dev/null
+++ b/samples/imgur/build.gradle
@@ -0,0 +1,59 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+
+    defaultConfig {
+        applicationId "com.bumptech.glide.samples.imgur"
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionCode 1
+        versionName "1.0"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+}
+
+dependencies {
+    implementation project(':library')
+    annotationProcessor project(':annotation:compiler')
+
+    implementation "com.google.dagger:dagger:${DAGGER_VERSION}"
+    annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}"
+    implementation "com.google.dagger:dagger-android:${DAGGER_VERSION}"
+    implementation ("com.google.dagger:dagger-android-support:${DAGGER_VERSION}") {
+        exclude group: "com.android.support"
+    }
+    annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}"
+
+    implementation "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
+    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
+    implementation 'com.squareup.retrofit2:adapter-rxjava:2.3.0'
+
+    implementation 'io.reactivex:rxandroid:1.2.1'
+    implementation 'io.reactivex:rxjava:1.3.4'
+
+    implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:cardview-v7:${ANDROID_SUPPORT_VERSION}"
+    implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+
+    // Fixes a compilation warning related to dagger, see
+    // https://github.com/google/guava/issues/2721.
+    compileOnly "com.google.errorprone:error_prone_annotations:2.1.3"
+}
+
+task run(type: Exec, dependsOn: 'installDebug') {
+    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.card/.MainActivity'
+}
diff --git a/samples/imgur/lint.xml b/samples/imgur/lint.xml
new file mode 100644
index 000000000..ac292ab1a
--- /dev/null
+++ b/samples/imgur/lint.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+</lint>
diff --git a/samples/imgur/src/main/AndroidManifest.xml b/samples/imgur/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..854c9930f
--- /dev/null
+++ b/samples/imgur/src/main/AndroidManifest.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.samples.imgur">
+  <uses-permission android:name="android.permission.INTERNET" />
+  <!--
+  Allows Glide to monitor connectivity status and restart failed requests if users go from a
+  a disconnected to a connected network state.
+  -->
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+  <application
+    android:allowBackup="false"
+    android:icon="@mipmap/ic_launcher"
+    android:label="@string/app_name"
+    android:roundIcon="@mipmap/ic_launcher_round"
+    android:supportsRtl="true"
+    android:theme="@style/AppTheme"
+    android:name="com.bumptech.glide.samples.imgur.ImgurApplication">
+    <activity android:name="com.bumptech.glide.samples.imgur.MainActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity>
+  </application>
+
+</manifest>
\ No newline at end of file
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
new file mode 100644
index 000000000..f64d72143
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.samples.imgur;
+
+import dagger.Module;
+import dagger.Provides;
+import okhttp3.OkHttpClient;
+
+/**
+ * The Application Dagger module for the Imgur sample.
+ */
+@Module
+class ApplicationModule {
+  @Provides
+  OkHttpClient okHttpClient() {
+    return new OkHttpClient();
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
new file mode 100644
index 000000000..c2b788e2b
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.samples.imgur;
+
+import dagger.android.AndroidInjector;
+import dagger.android.support.DaggerApplication;
+
+/**
+ * Runs Dagger injection in the Imgur sample.
+ */
+public final class ImgurApplication extends DaggerApplication {
+  @Override
+  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {
+    return DaggerImgurApplicationComponent.create();
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
new file mode 100644
index 000000000..7b9d639aa
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.samples.imgur;
+
+import com.bumptech.glide.samples.imgur.api.ApiModule;
+import dagger.Component;
+import dagger.android.AndroidInjector;
+import dagger.android.support.AndroidSupportInjectionModule;
+import javax.inject.Singleton;
+
+/**
+ * Specifies Dagger modules for {@link ImgurApplication}.
+ */
+@Singleton
+@Component(modules = {
+    AndroidSupportInjectionModule.class,
+    MainActivityModule.class,
+    ApplicationModule.class,
+    ApiModule.class
+})
+public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
new file mode 100644
index 000000000..c673ad244
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.imgur;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Generates a Glide API for the Imgur sample.
+ */
+@GlideModule(glideName = "ImgurGlide")
+public class ImgurGlideModule extends AppGlideModule {
+  // Intentionally Empty.
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
new file mode 100644
index 000000000..384543997
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
@@ -0,0 +1,114 @@
+package com.bumptech.glide.samples.imgur;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.ViewHolder;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+import com.bumptech.glide.samples.imgur.api.Image;
+import dagger.android.AndroidInjection;
+import java.util.Collections;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Named;
+import rx.Observable;
+import rx.Observer;
+import rx.android.schedulers.AndroidSchedulers;
+import rx.schedulers.Schedulers;
+
+/**
+ * Displays images and GIFs from Imgur in a scrollable list of cards.
+ */
+public final class MainActivity extends AppCompatActivity {
+
+  @Inject @Named("hotViralImages") Observable<List<Image>> fetchImagesObservable;
+  private ImgurImageAdapter adapter;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    AndroidInjection.inject(this);
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+    RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
+
+    recyclerView.setHasFixedSize(true);
+    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
+    recyclerView.setLayoutManager(layoutManager);
+    adapter = new ImgurImageAdapter();
+    recyclerView.setAdapter(adapter);
+
+    fetchImagesObservable
+        .subscribeOn(Schedulers.newThread())
+        .observeOn(AndroidSchedulers.mainThread())
+        .subscribe(new Observer<List<Image>>() {
+          @Override
+          public void onCompleted() { }
+
+          @Override
+          public void onError(Throwable e) { }
+
+          @Override
+          public void onNext(List<Image> images) {
+            adapter.setData(images);
+          }
+        });
+  }
+
+  @Override
+  protected void onDestroy() {
+    super.onDestroy();
+    fetchImagesObservable.unsubscribeOn(AndroidSchedulers.mainThread());
+  }
+
+  private final class ImgurImageAdapter extends RecyclerView.Adapter<ViewHolder> {
+
+    private List<Image> images = Collections.emptyList();
+
+    public void setData(@NonNull List<Image> images) {
+      this.images = images;
+      notifyDataSetChanged();
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      return new ViewHolder(LayoutInflater.from(parent.getContext())
+          .inflate(R.layout.image_card, parent, false));
+    }
+
+    @Override
+    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
+      ViewHolder vh = (ViewHolder) holder;
+      Image image = images.get(position);
+      vh.title.setText(
+          TextUtils.isEmpty(image.title) ? image.description : image.title);
+
+      ImgurGlide.with(vh.imageView)
+          .load(image.link)
+          .into(vh.imageView);
+    }
+
+    @Override
+    public int getItemCount() {
+      return images.size();
+    }
+
+    private final class ViewHolder extends RecyclerView.ViewHolder {
+
+      private final ImageView imageView;
+      private final TextView title;
+
+      ViewHolder(View itemView) {
+        super(itemView);
+        imageView = (ImageView) itemView.findViewById(R.id.image);
+        title = (TextView) itemView.findViewById(R.id.title);
+      }
+    }
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java
new file mode 100644
index 000000000..cef304fb2
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.samples.imgur;
+
+import dagger.Module;
+import dagger.android.ContributesAndroidInjector;
+
+@Module
+abstract class MainActivityModule {
+  @ContributesAndroidInjector
+  abstract MainActivity contributeMainActivityInjector();
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
new file mode 100644
index 000000000..7a70c6dc3
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
@@ -0,0 +1,56 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import dagger.Module;
+import dagger.Provides;
+import java.io.IOException;
+import java.util.List;
+import javax.inject.Named;
+import javax.inject.Singleton;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Response;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
+import rx.Observable;
+
+/** Provides classes related to the Imgur API via Dagger. */
+@Module
+public final class ApiModule {
+
+  @Singleton
+  @Named("hotViralImages")
+  @Provides
+  Observable<List<Image>> provideHotViralImages(ImgurObservables imgurObservables) {
+    return imgurObservables.getHotViralImages(5 /*maxPages*/);
+  }
+
+  @Provides ImgurObservables imgurObservables(ImgurService imgurService) {
+    return new ImgurObservables(imgurService);
+  }
+
+  @Provides ImgurService getImgurService(Retrofit retrofit) {
+    return retrofit.create(ImgurService.class);
+  }
+
+  @Provides Retrofit retrofit() {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .addInterceptor(new Interceptor() {
+          @Override
+          public Response intercept(Chain chain) throws IOException {
+            return chain.proceed(
+                chain.request()
+                    .newBuilder()
+                    .addHeader("Authorization", "Client-ID " + ImgurService.CLIENT_ID)
+                    .build());
+          }
+        })
+        .build();
+    return new Retrofit.Builder()
+        .client(client)
+        .addConverterFactory(GsonConverterFactory.create())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .baseUrl("https://api.imgur.com/3/")
+        .build();
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
new file mode 100644
index 000000000..199752239
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
@@ -0,0 +1,19 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import java.util.List;
+
+/**
+ * Represents Imgur's Gallery resource.
+ *
+ * <p>Populated automatically by GSON.
+ */
+final class Gallery {
+  public List<Image> data;
+
+  @Override
+  public String toString() {
+    return "Gallery{"
+        + "data=" + data
+        + '}';
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
new file mode 100644
index 000000000..af157f8cd
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.samples.imgur.api;
+
+/**
+ * Represents Imgur's Image resource.
+ *
+ * <p>Populated automatically by GSON
+ */
+public final class Image {
+  private String id;
+  public String title;
+  public String description;
+  public String link;
+  boolean is_album;
+
+  @Override
+  public String toString() {
+    return "Image{"
+        + "id='" + id + '\''
+        + ", title='" + title + '\''
+        + ", description='" + description + '\''
+        + ", link='" + link + '\''
+        + ", is_album='" + is_album + '\''
+        + '}';
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
new file mode 100644
index 000000000..478465160
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
@@ -0,0 +1,64 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import rx.Observable;
+import rx.functions.Func1;
+import rx.functions.Func2;
+
+/**
+ * Observables for retrieving metadata from Imgur's API.
+ */
+final class ImgurObservables {
+
+  private final ImgurService imgurService;
+
+  ImgurObservables(ImgurService imgurService) {
+    this.imgurService = imgurService;
+  }
+
+  Observable<List<Image>> getHotViralImages(@SuppressWarnings("SameParameterValue") int maxPages) {
+    return Observable.range(0, maxPages)
+        .flatMap(new Func1<Integer, Observable<List<Image>>>() {
+          @Override
+          public Observable<List<Image>> call(Integer integer) {
+            return imgurService.getHotViral(integer).map(new GetData()).flatMap(
+                new Func1<List<Image>, Observable<List<Image>>>() {
+                  @Override
+                  public Observable<List<Image>> call(List<Image> images) {
+                    for (Iterator<Image> iterator = images.iterator(); iterator.hasNext();) {
+                      if (iterator.next().is_album) {
+                        iterator.remove();
+                      }
+                    }
+                    return Observable.just(images);
+                  }
+                });
+          }
+        })
+        .takeWhile(new Func1<List<Image>, Boolean>() {
+          @Override
+          public Boolean call(List<Image> images) {
+            return !images.isEmpty();
+          }
+        })
+        .scan(new Func2<List<Image>, List<Image>, List<Image>>() {
+          @Override
+          public List<Image> call(List<Image> images, List<Image> images2) {
+            List<Image> result = new ArrayList<>(images.size() + images2.size());
+            result.addAll(images);
+            result.addAll(images2);
+            return result;
+          }
+        })
+        .cache();
+  }
+
+  private static class GetData implements Func1<Gallery, List<Image>> {
+    @Override
+    public List<Image> call(Gallery gallery) {
+      return gallery.data;
+    }
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
new file mode 100644
index 000000000..ddab15062
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import retrofit2.http.GET;
+import retrofit2.http.Path;
+import rx.Observable;
+
+/**
+ * Define's Imgur's API for Retrofit.
+ */
+public interface ImgurService {
+  String CLIENT_ID = "36d1f6bef16370c";
+
+  @GET("gallery/hot/viral/{page}")
+  Observable<Gallery> getHotViral(@Path("page") int page);
+
+  @GET("gallery/hot/{sort}/{page}.json")
+  Observable<Gallery> getHot(@Path("sort") Sort sort, @Path("page") int page);
+
+  @GET("gallery/{section}/{sort}/{page}.json")
+  Observable<Gallery> getGallery(@Path("section") Section section,
+      @Path("sort") Sort sort, @Path("page") int page);
+
+  /**
+   * Sections that Imgur's API allows us to query from.
+   */
+  enum Section {
+    hot,
+    top,
+    user
+  }
+
+  /**
+   * The sort order for content within a particular section.
+   */
+  enum Sort {
+    viral,
+    top,
+    time,
+    rising
+  }
+}
diff --git a/samples/imgur/src/main/res/layout/activity_main.xml b/samples/imgur/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..4e7309f0a
--- /dev/null
+++ b/samples/imgur/src/main/res/layout/activity_main.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merge
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  tools:context="com.bumptech.glide.samples.imgur.MainActivity">
+
+  <android.support.v7.widget.RecyclerView
+    android:id="@+id/recycler_view"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:scrollbars="vertical"
+    />
+</merge>
diff --git a/samples/imgur/src/main/res/layout/image_card.xml b/samples/imgur/src/main/res/layout/image_card.xml
new file mode 100644
index 000000000..92f2cbb76
--- /dev/null
+++ b/samples/imgur/src/main/res/layout/image_card.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:card_view="http://schemas.android.com/apk/res-auto"
+  android:layout_width="match_parent"
+  android:layout_height="wrap_content"
+  android:padding="16dp">
+
+  <android.support.v7.widget.CardView
+    android:id="@+id/card_view"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    card_view:cardCornerRadius="4dp">
+    <LinearLayout
+      android:orientation="vertical"
+      android:padding="16dp"
+      android:gravity="center"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content">
+      <ImageView
+        android:id="@+id/image"
+        android:scaleType="fitCenter"
+        android:layout_width="match_parent"
+        android:layout_height="150dp"
+        android:contentDescription="@null"/>
+      <TextView
+        android:id="@+id/title"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        android:paddingTop="16dp"
+        />
+    </LinearLayout>
+  </android.support.v7.widget.CardView>
+</FrameLayout>
diff --git a/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..cde69bccc
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher_round.png
new file mode 100644
index 000000000..9a078e3e1
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..c133a0cbd
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher_round.png
new file mode 100644
index 000000000..efc028a63
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..bfa42f0e7
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..3af2608a4
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..324e72cdd
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..9bec2e623
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 000000000..aee44e138
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..34947cd6b
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/values/colors.xml b/samples/imgur/src/main/res/values/colors.xml
new file mode 100644
index 000000000..5a077b3a7
--- /dev/null
+++ b/samples/imgur/src/main/res/values/colors.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <color name="colorPrimary">#3F51B5</color>
+  <color name="colorPrimaryDark">#303F9F</color>
+  <color name="colorAccent">#FF4081</color>
+</resources>
diff --git a/samples/imgur/src/main/res/values/strings.xml b/samples/imgur/src/main/res/values/strings.xml
new file mode 100644
index 000000000..73f9f0e5a
--- /dev/null
+++ b/samples/imgur/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+  <string name="app_name">Imgur</string>
+</resources>
diff --git a/samples/imgur/src/main/res/values/styles.xml b/samples/imgur/src/main/res/values/styles.xml
new file mode 100644
index 000000000..ccfe4e02e
--- /dev/null
+++ b/samples/imgur/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+  <!-- Base application theme. -->
+  <style name="AppTheme" parent="Theme.AppCompat">
+    <!-- Customize your theme here. -->
+    <item name="colorPrimary">@color/colorPrimary</item>
+    <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+    <item name="colorAccent">@color/colorAccent</item>
+  </style>
+
+</resources>
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index 973afa473..e6a204650 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -1,12 +1,14 @@
 apply plugin: 'com.android.application'
 
-repositories {
-    mavenCentral()
+dependencies {
+    implementation project(':library')
+    annotationProcessor project(':annotation:compiler')
+    implementation 'com.caverock:androidsvg:1.2.1'
+    implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.svg'
@@ -23,11 +25,6 @@ android {
     }
 }
 
-dependencies {
-    compile project(':library')
-    compile 'com.caverock:androidsvg:1.2.1'
-}
-
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
     commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.svg/.MainActivity'
diff --git a/samples/svg/lint.xml b/samples/svg/lint.xml
index 95a2ab036..94bb2b69c 100644
--- a/samples/svg/lint.xml
+++ b/samples/svg/lint.xml
@@ -2,4 +2,5 @@
 <lint>
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
 </lint>
diff --git a/samples/svg/proguard-rules.pro b/samples/svg/proguard-rules.pro
deleted file mode 100644
index 95c847b91..000000000
--- a/samples/svg/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Users/judds/dev/adt-bundle-mac-x86_64-20131030/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/samples/svg/src/main/AndroidManifest.xml b/samples/svg/src/main/AndroidManifest.xml
index 218bbe4b5..bb5888e5e 100644
--- a/samples/svg/src/main/AndroidManifest.xml
+++ b/samples/svg/src/main/AndroidManifest.xml
@@ -4,17 +4,10 @@
 
     <uses-permission android:name="android.permission.INTERNET"/>
 
-    <uses-sdk
-            android:minSdkVersion="10"
-            android:targetSdkVersion="22" />
-
     <application
-        android:allowBackup="true"
+        android:allowBackup="false"
         android:icon="@android:drawable/sym_def_app_icon"
         android:label="@string/app_name">
-        <meta-data
-            android:name="com.bumptech.glide.samples.svg.SvgModule"
-            android:value="GlideModule"/>
         <activity
             android:name=".MainActivity"
             android:label="@string/app_name">
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
index 0587c01f7..d91a9f665 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.samples.svg;
 
 import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
-import static com.bumptech.glide.request.RequestOptions.placeholderOf;
 
 import android.app.Activity;
 import android.content.ContentResolver;
@@ -12,10 +11,9 @@
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.TextView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
-
+import com.bumptech.glide.util.Preconditions;
 import java.io.File;
 
 /**
@@ -36,10 +34,10 @@ protected void onCreate(Bundle savedInstanceState) {
     imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
     imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);
 
-    requestBuilder = Glide.with(this)
+    requestBuilder = GlideApp.with(this)
         .as(PictureDrawable.class)
-        .apply(placeholderOf(R.drawable.image_loading)
-            .error(R.drawable.image_error))
+        .placeholder(R.drawable.image_loading)
+        .error(R.drawable.image_error)
         .transition(withCrossFade())
         .listener(new SvgSoftwareLayerSetter());
   }
@@ -52,10 +50,11 @@ protected void onStart() {
 
   public void clearCache(View v) {
     Log.w(TAG, "clearing cache");
-    Glide.with(this).clear(imageViewRes);
-    Glide.with(this).clear(imageViewNet);
-    Glide.get(this).clearMemory();
-    File cacheDir = Glide.getPhotoCacheDir(this);
+    GlideRequests glideRequests = GlideApp.with(this);
+    glideRequests.clear(imageViewRes);
+    glideRequests.clear(imageViewNet);
+    GlideApp.get(this).clearMemory();
+    File cacheDir = Preconditions.checkNotNull(Glide.getPhotoCacheDir(this));
     if (cacheDir.isDirectory()) {
       for (File child : cacheDir.listFiles()) {
         if (!child.delete()) {
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
index 3fdd91ad5..ad2212227 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.samples.svg;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
 import com.caverock.androidsvg.SVG;
 import com.caverock.androidsvg.SVGParseException;
-
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -16,16 +16,17 @@
 public class SvgDecoder implements ResourceDecoder<InputStream, SVG> {
 
   @Override
-  public boolean handles(InputStream source, Options options) throws IOException {
+  public boolean handles(@NonNull InputStream source, @NonNull Options options) {
     // TODO: Can we tell?
     return true;
   }
 
-  public Resource<SVG> decode(InputStream source, int width, int height, Options options)
+  public Resource<SVG> decode(@NonNull InputStream source, int width, int height,
+      @NonNull Options options)
       throws IOException {
     try {
       SVG svg = SVG.getFromInputStream(source);
-      return new SimpleResource<SVG>(svg);
+      return new SimpleResource<>(svg);
     } catch (SVGParseException ex) {
       throw new IOException("Cannot load SVG from stream", ex);
     }
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
index 43352acd8..a3fd80abf 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
@@ -2,7 +2,9 @@
 
 import android.graphics.Picture;
 import android.graphics.drawable.PictureDrawable;
-
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
@@ -13,12 +15,13 @@
  * ({@link Picture}).
  */
 public class SvgDrawableTranscoder implements ResourceTranscoder<SVG, PictureDrawable> {
+  @Nullable
   @Override
-  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode) {
+  public Resource<PictureDrawable> transcode(@NonNull Resource<SVG> toTranscode,
+      @NonNull Options options) {
     SVG svg = toTranscode.get();
     Picture picture = svg.renderToPicture();
     PictureDrawable drawable = new PictureDrawable(picture);
-    return new SimpleResource<PictureDrawable>(drawable);
+    return new SimpleResource<>(drawable);
   }
 }
-
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
index b3cfcbfe0..fdd14df98 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -2,26 +2,29 @@
 
 import android.content.Context;
 import android.graphics.drawable.PictureDrawable;
-
-import com.bumptech.glide.GlideBuilder;
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import com.caverock.androidsvg.SVG;
-
 import java.io.InputStream;
 
 /**
  * Module for the SVG sample app.
  */
-public class SvgModule implements GlideModule {
+@GlideModule
+public class SvgModule extends AppGlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
+  public void registerComponents(@NonNull Context context, @NonNull Glide glide,
+      @NonNull Registry registry) {
+    registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
+        .append(InputStream.class, SVG.class, new SvgDecoder());
   }
 
+  // Disable manifest parsing to avoid adding similar modules twice.
   @Override
-  public void registerComponents(Context context, Registry registry) {
-    registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
-        .append(InputStream.class, SVG.class, new SvgDecoder());
+  public boolean isManifestParsingEnabled() {
+    return false;
   }
 }
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
index c3b4aa003..a28a21b7c 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
@@ -1,10 +1,7 @@
 package com.bumptech.glide.samples.svg;
 
-import android.annotation.TargetApi;
 import android.graphics.drawable.PictureDrawable;
-import android.os.Build;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.RequestListener;
@@ -16,16 +13,13 @@
  * {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on
  * a hardware backed {@link android.graphics.Canvas Canvas}.
  */
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class SvgSoftwareLayerSetter implements RequestListener<PictureDrawable> {
 
   @Override
   public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawable> target,
       boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
-    }
+    view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
     return false;
   }
 
@@ -33,9 +27,7 @@ public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawab
   public boolean onResourceReady(PictureDrawable resource, Object model,
       Target<PictureDrawable> target, DataSource dataSource, boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
-    }
+    view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
     return false;
   }
 }
diff --git a/samples/svg/src/main/res/drawable/image_loading.xml b/samples/svg/src/main/res/drawable/image_loading.xml
index ad1bddfad..762e38664 100644
--- a/samples/svg/src/main/res/drawable/image_loading.xml
+++ b/samples/svg/src/main/res/drawable/image_loading.xml
@@ -2,7 +2,7 @@
 <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
     <item>
         <bitmap
-            android:src="@android:drawable/sym_def_app_icon"
+            android:src="@mipmap/ic_launcher"
             android:gravity="center" />
     </item>
     <item
diff --git a/samples/svg/src/main/res/layout/activity_main.xml b/samples/svg/src/main/res/layout/activity_main.xml
index 704faa1f9..bff58690a 100644
--- a/samples/svg/src/main/res/layout/activity_main.xml
+++ b/samples/svg/src/main/res/layout/activity_main.xml
@@ -16,7 +16,7 @@
         android:onClick="clearCache"
         android:clickable="true"
         android:text="@string/hello_world"
-        />
+        android:focusable="true"/>
 
     <Button
         android:id="@+id/button"
diff --git a/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..cde69bccc
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..c133a0cbd
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/svg/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..bfa42f0e7
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/svg/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..324e72cdd
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/svg/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/samples/svg/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 000000000..aee44e138
Binary files /dev/null and b/samples/svg/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/scripts/android-wait-for-emulator.sh b/scripts/android-wait-for-emulator.sh
new file mode 100755
index 000000000..aa6345d8b
--- /dev/null
+++ b/scripts/android-wait-for-emulator.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+
+# Originally written by Ralf Kistner <ralf@embarkmobile.com>, but placed in the public domain
+
+set +e
+
+bootanim=""
+failcounter=0
+timeout_in_sec=360
+
+until [[ "$bootanim" =~ "stopped" ]]; do
+  bootanim=`adb -e shell getprop init.svc.bootanim 2>&1 &`
+  if [[ "$bootanim" =~ "device not found" || "$bootanim" =~ "device offline"
+    || "$bootanim" =~ "running" ]]; then
+    let "failcounter += 1"
+    echo "Waiting for emulator to start"
+    if [[ $failcounter -gt timeout_in_sec ]]; then
+      echo "Timeout ($timeout_in_sec seconds) reached; failed to start emulator"
+      exit 1
+    fi
+  fi
+  sleep 1
+done
+
+echo "Emulator is ready"
diff --git a/scripts/install_firebase.sh b/scripts/install_firebase.sh
new file mode 100755
index 000000000..594d16e87
--- /dev/null
+++ b/scripts/install_firebase.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+set -e
+
+openssl aes-256-cbc -K $encrypted_ad2664a1c4dd_key -iv $encrypted_ad2664a1c4dd_iv -in $GCLOUD_FILE -out gcloud.json -d
+
+wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+tar xf google-cloud-sdk-176.0.0-linux-x86_64.tar.gz
+echo "y" | ./google-cloud-sdk/bin/gcloud components update beta
+./google-cloud-sdk/bin/gcloud auth activate-service-account --key-file gcloud.json
diff --git a/scripts/regenerate_resources.sh b/scripts/regenerate_resources.sh
new file mode 100755
index 000000000..4536c8da9
--- /dev/null
+++ b/scripts/regenerate_resources.sh
@@ -0,0 +1,76 @@
+#!/usr/bin/env bash
+#
+# Generates or regenerates canonical resources for Glide's emulator tests with the cooperation
+# of the BitmapRegressionTester class.
+#
+# Usage:
+# ./scripts/regenerate_resources.sh <com.bumptech.glide.instrumentation.class_name>
+#
+# The class name is optional. If not specified all tests will be run (including those that
+# do not generate resources).
+
+# The signal file that tells BitmapRegressionTester to generate the resource files.
+REGENERATE_FILE_NAME="regenerate"
+# The name of the subfolder on the sdcard where resources are stored on the device/emulator.
+DIRECTORY_NAME="test_files"
+# The full path to a place where the app is able to write resources and we're able to read them.
+DIRECTORY="/sdcard/DCIM/${DIRECTORY_NAME}"
+
+set -e
+
+if [ "$#" -eq 1 ]; then
+  test_restriction="-Pandroid.testInstrumentationRunnerArguments.class=${1}"
+fi
+
+exec 3>&1
+exec 4>&2
+if !(($VERBOSE)); then
+  exec 1>/dev/null
+  exec 2>/dev/null
+fi
+
+echo "Setting up environment..."  1>&3 2>&4
+adb devices | grep -v "List of devices" | grep device \
+  || echo "No devices found, try starting an emulator" 1>&3 2>&4
+
+adb root || true 
+# In case there are any old artifacts from an old or failed test, clean them up.
+adb shell rm -r $DIRECTORY || true
+# Create the signal file.
+# On some emulators touch fails if the directory isn't created first.
+adb shell mkdir /sdcard/DCIM || true
+adb shell mkdir $DIRECTORY || true
+# This actually has to work, previous steps may fail if the directories already exist.
+adb shell touch "${DIRECTORY}/${REGENERATE_FILE_NAME}"
+
+# On APIs > 22 we need to grant the appropriate runtime permissions so our test APK can write
+# resource files to the public sdcard. Cache and internal cache directories aren't consistently
+# available across all versions of Android. So far this is the best cross SDK solution I've 
+# found
+sdk_version=`adb shell getprop ro.build.version.sdk`
+sdk_version=`echo $sdk_version | tr -d '\r'`
+if [[ $sdk_version -gt 22 ]]; then
+  echo "Installing apks and granting runtime permissions..." 1>&3 2>&4
+  ./gradlew :instrumentation:installDebug :instrumentation:installDebugAndroidTest 
+  adb shell pm grant com.bumptech.glide.instrumentation android.permission.WRITE_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation android.permission.READ_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation.test android.permission.WRITE_EXTERNAL_STORAGE
+  adb shell pm grant com.bumptech.glide.instrumentation.test android.permission.READ_EXTERNAL_STORAGE
+fi
+
+echo "Generating updated resource files..." 1>&3 2>&4
+./gradlew :instrumentation:connectedDebugAndroidTest $test_restriction --parallel || true 
+
+echo "Copying updated resource files to res directory..." 1>&3 2>&4
+adb pull $DIRECTORY
+rm "${DIRECTORY_NAME}/${REGENERATE_FILE_NAME}" 
+cp $DIRECTORY_NAME/raw/* instrumentation/src/main/res/raw 
+rm -rf $DIRECTORY_NAME
+adb shell rm -r $DIRECTORY
+ 
+echo "Verifying all tests pass..." 1>&3 2>&4
+
+./gradlew :instrumentation:clean
+./gradlew :instrumentation:connectedDebugAndroidTest $test_restriction --parallel
+
+echo "Complete!" 1>&3 2>&4
diff --git a/scripts/release_checks.sh b/scripts/release_checks.sh
new file mode 100755
index 000000000..e25412f51
--- /dev/null
+++ b/scripts/release_checks.sh
@@ -0,0 +1,87 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$#" -ne 1 ]; then
+  echo "Usage: ./release_checks.sh <major.minor.patch[-SNAPSHOT]>"
+  exit 1
+fi
+
+if [[ $(git status -uno --porcelain) ]]; then
+  echo "One or more changes, commit or revert first."
+  git status -uno --porcelain
+  exit 1
+fi
+if [[ $(git rev-list master...bump/master --count) -ne 0 ]]; then
+  echo "Bump and master are not up to date"
+  git rev-list master...bump/master --pretty
+  exit 1
+fi
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; then
+  echo "Origin and master are not up to date"
+  git rev-list master...origin/master --pretty
+  exit 1
+fi
+if [[ $(git ls-files --exclude-standard --others) ]]; then
+  echo "Untracked files, aborting"
+  exit 1
+fi
+
+version=$1
+echo "Setting version to $version"
+echo -n "Is this a correct? (y/n)? "
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Updating gradle.properties..."
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+sed -i '' "s/VERSION_NAME=.*/VERSION_NAME=${version}/g" gradle.properties
+sed -i '' "s/VERSION_MAJOR=.*/VERSION_MAJOR=$(echo $version | cut -d '.' -f 1)/" gradle.properties
+sed -i '' "s/VERSION_MINOR=.*/VERSION_MINOR=$(echo $version | cut -d '.' -f 2)/" gradle.properties
+sed -i '' "s/VERSION_PATCH=.*/VERSION_PATCH=$(echo $version | cut -d '.' -f 3 | sed 's/-.*//')/" gradle.properties
+
+git diff
+
+echo "Updated gradle.properties, is this correct? (y/n)?"
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Committing..."
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+version_tag="v${version}"
+git add gradle.properties
+git commit -m "Bump version to ${version}"
+if [[ $version != *"SNAPSHOT"* ]]; then
+  echo "Found release version, adding tag, building and uploading"
+  git tag $version_tag
+
+  echo "Building... and uploading"
+  ./gradlew clean build --parallel
+  ./gradlew uploadArchives 
+
+  echo "Upload complete, please verify the output and upload the jars to the GitHub release."
+fi
+
+echo -n "Ready to push, continue? (y/n)? "
+read answer
+if echo "$answer" | grep -iq "^y" ; then
+  echo "Pushing commits"
+else
+  echo "Cancelling"
+  exit 1
+fi
+
+git push origin master
+git push bump master
+if [[ $version != *"SNAPSHOT"* ]]; then
+  echo "Found release version, pushing tags"
+  git push origin $version_tag
+  git push bump $version_tag
+fi
+
diff --git a/scripts/run_instrumentation_tests.sh b/scripts/run_instrumentation_tests.sh
new file mode 100755
index 000000000..412690a8a
--- /dev/null
+++ b/scripts/run_instrumentation_tests.sh
@@ -0,0 +1,20 @@
+#!/usr/bin/env bash
+# Runs instrumentation tests on firebase. Must be run locally, not on travis.
+#
+# Usage: 
+# ./scripts/run_instrumentation_test.sh
+
+./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel
+
+apk_dir=instrumentation/build/outputs/apk
+gcloud firebase test android run \
+  --type instrumentation \
+  --app $apk_dir/instrumentation-debug.apk \
+  --test $apk_dir/instrumentation-debug-androidTest.apk \
+  --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+  --device model=Nexus6P,version=25,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=23,locale=en,orientation=portrait \
+  --device model=Nexus6,version=22,locale=en,orientation=portrait \
+  --device model=Nexus5,version=19,locale=en,orientation=portrait \
+  --project android-glide \
+  --no-auto-google-login \
diff --git a/scripts/run_sample_robo_tests.sh b/scripts/run_sample_robo_tests.sh
new file mode 100755
index 000000000..d7c9cc23d
--- /dev/null
+++ b/scripts/run_sample_robo_tests.sh
@@ -0,0 +1,44 @@
+#!/usr/bin/env bash
+# Runs Firebases' robo tests (monkeyrunner) on Glide's sample apps
+#
+# Usage: 
+# ./scripts/run_sample_robo_tests.sh
+
+set -e
+
+./gradlew :samples:flickr:build \
+  :samples:giphy:build \
+  :samples:contacturi:build \
+  :samples:gallery:build \
+  :samples:imgur:build \
+  :samples:svg:build \
+  --parallel
+
+declare -a samples=("flickr" 
+                "giphy" 
+                "contacturi"
+                "gallery"
+                "imgur"
+                "svg")
+pids=()
+
+for sample in "${samples[@]}"
+do
+  sample_dir="samples/${sample}/build/outputs/apk/"
+  sample_apk="${sample_dir}/${sample}-debug.apk"
+  gcloud firebase test android run \
+    --type robo \
+    --app $sample_apk \
+    --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+    --project android-glide \
+    --no-auto-google-login &
+  pids+=("$!")
+done
+
+for current in "${pids[@]}"
+do
+  wait $current
+done
+       
+
+
diff --git a/scripts/split_by_sdk.sh b/scripts/split_by_sdk.sh
new file mode 100755
index 000000000..8e700ba8a
--- /dev/null
+++ b/scripts/split_by_sdk.sh
@@ -0,0 +1,169 @@
+#!/usr/bin/env bash
+#
+# Loops through all Android API levels that Glide supports (and that 
+# functioning emulators exist for) and runs a particular emulator test file
+# to generate canonical assets. If assets start to fail on a particular sdk
+# level, the test file is updated with the new API level to split on and 
+# assets for that particular api level are added to the test resources 
+# directory.
+#
+# Usage:
+#   ./scripts/split_by_sdk.sh [--abis x86,armeabi-v7a] [--apis 16,17] \
+#      [-v/--verbose] [--tests com.bumptech.glide.TestName1,com.bumptech.glide.TestName2]
+#
+# apis: The Android SDK version(s) you want to run against.
+# abis: The Android CPU types you want to run against
+# v/verbose: Enable verbose logging.
+
+POSITIONAL=()
+while [[ $# -gt 0 ]]
+do
+key="$1"
+
+case $key in
+    --tests)
+    test_classes_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --apis)
+    apis_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    --abis)
+    abis_string="$2"
+    shift # past argument
+    shift # past value
+    ;;
+    -v|--verbose)
+    verbose="1"
+    shift # past argument
+    ;;
+    *)    # unknown option
+    POSITIONAL+=("$1") # save it in an array for later
+    shift # past argument
+    ;;
+esac
+done
+set -- "${POSITIONAL[@]}" # restore positional parameters
+
+if [ -z "$test_classes_string" ]; then
+  test_classes_string=`grep -rwl instrumentation/src/androidTest -e RegressionTest \
+    | grep -v "/test/" \
+    | grep -v ".bak" \
+    | tr '\n' ',' \
+    | sed 's/instrumentation\/src\/androidTest\/java\///g' \
+    | sed 's/\//\./g' \
+    | sed 's/\.java//g' \
+    | sed 's/,*$//g'` 
+fi
+
+if [ -z "$apis_string" ]; then
+  declare -a apis=(
+                  "16" 
+                  #"17" API 17 emulator seems to have trouble starting and I haven't yet found a case where behaviors changed at that API level.
+                  "18"
+                  "19"
+                  # "20" Android Wear, missing x86 emulators.
+                  "21"
+                  "22"
+                  "23"
+                  "24"
+                  "25"
+                  "26")
+else 
+  IFS=',' read -ra apis <<< "$apis_string"
+fi
+
+if [ -z "$abis_string" ]; then
+  declare -a abis=(
+  "x86"
+  "armeabi-v7a"
+  )
+else 
+  IFS=',' read -ra abis <<< "$abis_string"
+fi
+
+IFS=',' read -ra test_classes <<< "$test_classes_string"
+for test_class in "${test_classes[@]}"
+do
+  test_path=`echo $test_class | sed 's/\./\//g' | sed -e 's/^/instrumentation\/src\/androidTest\/java\//' | sed -e 's/$/\.java/'`
+  if [ ! -f "${test_path}" ]; then
+    echo "Missing test $test_class at expected path: $test_path"
+    exit 1
+  fi
+done
+
+if (($verbose)); then
+  printf "tests: "
+  printf '%s,' "${test_classes[@]}"
+  printf "\nabis:"
+  printf '%s,' "${abis[@]}"
+  printf "\napis:"
+  printf '%s,' "${apis[@]}"
+  printf "\n"
+fi
+
+adb devices | grep -v "List of devices" | grep device > /dev/null 2>&1 \
+  && \
+  { \
+    echo "Emulators are already running, kill them before running this script: "; \
+    echo "e.g.: adb -s emulator-5554 emu kill"; \
+    adb devices; \
+    exit 1; \
+  }
+
+exec 3>&1
+exec 4>&2
+if !(($verbose)); then
+  exec 1>/dev/null
+  exec 2>/dev/null
+fi
+
+for abi in "${abis[@]}"
+do
+  if [ "${abi}" == "armeabi-v7a" ]; then
+    emulator_type="default"
+    emulator_script=$ANDROID_HOME/emulator/emulator
+  else 
+    emulator_type="google_apis"
+    emulator_script=$ANDROID_HOME/tools/emulator
+  fi
+
+  for api in "${apis[@]}"
+  do
+    if [ "${abi}" == "armeabi-v7a" ] && [ "${api}" -gt 22 ]; then
+      echo "armeabi-v7a emulators beyond API 22 are unreliable, ignoring ${api}"
+      continue
+    fi
+
+    echo "Checking on API ${api} and ${abi}" 1>&3 2>&4
+    target="system-images;android-${api};${emulator_type};${abi}"
+    sdkmanager --install $target
+    avdmanager create avd --force -n test -k $target --device "Nexus 5X" -c 2000M 
+    QEMU_AUDIO_DRV=none $emulator_script -avd test -no-window &
+    pid=$!
+    ./scripts/android-wait-for-emulator.sh
+    for test_class in "${test_classes[@]}"
+    do
+      test_path=`echo $test_class | sed 's/\./\//g' | sed -e 's/^/instrumentation\/src\/androidTest\/java\//' | sed -e 's/$/\.java/'`
+      ./gradlew :instrumentation:connectedCheck \
+        -Pandroid.testInstrumentationRunnerArguments.class=$test_class
+      if [ $? -ne 0 ]; then
+        echo "Tests for API ${api} failed, updating SplitBySdk and generating resources..." 1>&3 2>&4
+        if [ -z $(grep "@SplitBySdk" $test_path | grep "${api}") ]; then
+          sed -i.bak s/@SplitBySdk\(\{/@SplitBySdk\(\{$api,/ $test_path
+          rm "${test_path}.bak"
+        fi
+        ./scripts/regenerate_resources.sh $test_class #|| { echo "Tests still fail with new resources, aborting";  exit 1; }
+      fi
+    done
+    adb -s emulator-5554 emu kill
+    sleep 1
+    kill -9 $pid
+    pkill emulator64-crash-service
+    pkill emulator-crash-service
+    echo "Finished API ${api}" 1>&3 2>&4
+  done
+done
diff --git a/scripts/travis_after_success.sh b/scripts/travis_after_success.sh
new file mode 100755
index 000000000..d9c2a3042
--- /dev/null
+++ b/scripts/travis_after_success.sh
@@ -0,0 +1,7 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ "$COMPONENT" == "unit" ]; then
+  ./scripts/travis_sonatype_publish.sh
+fi
diff --git a/scripts/travis_before_script.sh b/scripts/travis_before_script.sh
new file mode 100755
index 000000000..e45e901af
--- /dev/null
+++ b/scripts/travis_before_script.sh
@@ -0,0 +1,7 @@
+#!/usr/bin/env bash
+# Copies our debug.keystore file to its expected location to avoid a bug
+# where the Android build system seems to occasionally fail to generate it.
+
+set -e
+
+cp debug.keystore ~/.android/debug.keystore
diff --git a/scripts/travis_create_emulator.sh b/scripts/travis_create_emulator.sh
new file mode 100755
index 000000000..997ffcdcc
--- /dev/null
+++ b/scripts/travis_create_emulator.sh
@@ -0,0 +1,11 @@
+#!/usr/bin/env bash
+
+set -e
+
+target="system-images;android-${ANDROID_TARGET};default;armeabi-v7a"
+echo y | sdkmanager --update
+echo y | sdkmanager --install $target
+avdmanager create avd --force -n test -k $target --device "Nexus 4" -c 2048M
+QEMU_AUDIO_DRV=none $ANDROID_HOME/emulator/emulator -avd test -no-window -memory 2048 &
+
+exit 0
diff --git a/scripts/travis_firebase.sh b/scripts/travis_firebase.sh
new file mode 100755
index 000000000..e405462a5
--- /dev/null
+++ b/scripts/travis_firebase.sh
@@ -0,0 +1,32 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ ! "$firebase_enabled" == "true" ]; then
+  echo "Unable to run Firebase tests for pull requests, exiting"
+  exit 0
+fi
+
+./gradlew :instrumentation:assembleDebug \
+  :instrumentation:assembleDebugAndroidTest \
+  --parallel \
+  -PDISABLE_ERROR_PRONE &
+pid=$!
+./scripts/install_firebase.sh
+wait $pid
+
+apk_dir=instrumentation/build/outputs/apk
+./google-cloud-sdk/bin/gcloud firebase test android run \
+  --type instrumentation \
+  --app $apk_dir/debug/instrumentation-debug.apk \
+  --test $apk_dir/androidTest/debug/instrumentation-debug-androidTest.apk \
+  --device model=Nexus6P,version=27,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=26,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=25,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=24,locale=en,orientation=portrait \
+  --device model=Nexus6P,version=23,locale=en,orientation=portrait \
+  --device model=Nexus6,version=22,locale=en,orientation=portrait \
+  --device model=Nexus5,version=21,locale=en,orientation=portrait \
+  --device model=Nexus5,version=19,locale=en,orientation=portrait \
+  --project android-glide \
+  --no-auto-google-login \
diff --git a/scripts/travis_instrumentation.sh b/scripts/travis_instrumentation.sh
new file mode 100755
index 000000000..d365034bf
--- /dev/null
+++ b/scripts/travis_instrumentation.sh
@@ -0,0 +1,17 @@
+#!/usr/bin/env bash
+
+set -e
+
+echo "Starting emulator for $COMPONENT tests"
+./scripts/travis_create_emulator.sh &
+
+./gradlew :instrumentation:assembleDebug \
+  :instrumentation:assembleDebugAndroidTest \
+  --parallel \
+  -PDISABLE_ERROR_PRONE
+
+echo "Waiting for emulator..."
+android-wait-for-emulator
+
+for i in {1..3}; do ./gradlew :instrumentation:connectedDebugAndroidTest && break; done
+
diff --git a/scripts/travis_samples.sh b/scripts/travis_samples.sh
new file mode 100755
index 000000000..45fe59827
--- /dev/null
+++ b/scripts/travis_samples.sh
@@ -0,0 +1,53 @@
+#!/usr/bin/env bash
+
+set -e
+
+./gradlew :samples:flickr:build \
+  :samples:giphy:build \
+  :samples:contacturi:build \
+  :samples:gallery:build \
+  :samples:imgur:build \
+  :samples:svg:build \
+  --parallel \
+  -PERROR_PRONE="false" &
+pid=$!
+
+if [ ! "$firebase_enabled" == "true" ]; then
+  wait $pid
+  echo "Unable to run Firebase tests for pull requests, exiting"
+  exit 0
+else
+  ./scripts/install_firebase.sh
+  wait $pid
+fi
+
+
+declare -a samples=("flickr"
+                "giphy"
+                "contacturi"
+                "gallery"
+                "imgur"
+                "svg")
+pids=()
+
+for sample in "${samples[@]}"
+do
+  sample_dir="samples/${sample}/build/outputs/apk/debug"
+  sample_apk="${sample_dir}/${sample}-debug.apk"
+  ./google-cloud-sdk/bin/gcloud firebase test android run \
+    --type robo \
+    --app $sample_apk \
+    --device model=Nexus6P,version=26,locale=en,orientation=portrait  \
+    --project android-glide \
+    --no-auto-google-login \
+    --timeout 5m \
+    &
+  pids+=("$!")
+done
+
+for current in "${pids[@]}"
+do
+  wait $current
+done
+
+
diff --git a/scripts/travis_script.sh b/scripts/travis_script.sh
new file mode 100755
index 000000000..ab103e875
--- /dev/null
+++ b/scripts/travis_script.sh
@@ -0,0 +1,23 @@
+#!/usr/bin/env bash
+
+set -e
+
+if [ -z ${encrypted_ad2664a1c4dd_key+x} ] || [ -z ${encrypted_ad2664a1c4dd_iv+x} ] || [ -z ${GCLOUD_FILE} ]; then
+  export firebase_enabled="false"
+else
+  export firebase_enabled="true"
+fi
+
+
+if [ "$COMPONENT" == "unit" ]; then
+  ./scripts/travis_unit.sh
+elif [ "$COMPONENT" == "instrumentation" ]; then
+  ./scripts/travis_instrumentation.sh
+elif [ "$COMPONENT" == "samples" ]; then
+  ./scripts/travis_samples.sh
+elif [ "$COMPONENT" == "firebase" ]; then
+  ./scripts/travis_firebase.sh
+else
+  echo "Unrecognized component: $COMPONENT"
+  exit 1
+fi
diff --git a/scripts/travis-sonatype-publish.sh b/scripts/travis_sonatype_publish.sh
similarity index 100%
rename from scripts/travis-sonatype-publish.sh
rename to scripts/travis_sonatype_publish.sh
diff --git a/scripts/travis_unit.sh b/scripts/travis_unit.sh
new file mode 100755
index 000000000..ec19192f6
--- /dev/null
+++ b/scripts/travis_unit.sh
@@ -0,0 +1,12 @@
+#!/usr/bin/env bash
+
+set -e
+
+./gradlew build \
+  -x :samples:flickr:build \
+  -x :samples:giphy:build \
+  -x :samples:contacturi:build \
+  -x :samples:gallery:build \
+  -x :samples:imgur:build \
+  -x :samples:svg:build \
+  --parallel
diff --git a/scripts/update_javadocs.sh b/scripts/update_javadocs.sh
new file mode 100755
index 000000000..95238183c
--- /dev/null
+++ b/scripts/update_javadocs.sh
@@ -0,0 +1,61 @@
+#!/bin/bash
+#
+# Usage: ./scripts/update_javadocs.sh
+#
+# The version name is pulled automatically from gradle.properties.
+set -e
+set -o pipefail
+
+TEMP_DIR="/tmp/tmp_glide_javadoc"
+JAVADOC_GH_PAGES_DIR="javadocs"
+
+major_version=$(fgrep VERSION_MAJOR gradle.properties | cut -d '=' -f 2)
+minor_version=$(fgrep VERSION_MINOR gradle.properties | cut -d '=' -f 2)
+version="${major_version}${minor_version}0"
+
+echo "Updating javadocs for ${version}"
+
+if [[ $(git status -uno --porcelain) ]];
+then
+  echo "One or more changes, commit or revert first."
+  git status -uno --porcelain
+  exit 1
+fi
+
+if [ -e "$JAVADOC_GH_PAGES_DIR" ];
+then
+  echo "javadocs directory exists locally, remove first."
+  exit 1
+fi
+
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]];
+then
+  echo "Origin and master are not up to date"
+  git rev-list master...origin/master --pretty
+  exit 1
+fi
+if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]];
+then
+  echo "Origin and gh-pages are not up to date"
+  git rev-list gh-pages...origin/gh-pages --pretty
+  exit 1
+fi
+
+git checkout master
+GIT_COMMIT_SHA="$(git rev-parse HEAD)"
+./gradlew clean debugJavadocJar javadoc
+rm -rf $TEMP_DIR
+cp -r glide/build/docs/javadoc $TEMP_DIR
+
+# Add the favicon to the javadocs pages.
+find $TEMP_DIR -name '*.html' -exec sed -i '' -e 's#<head>#<head><link rel="apple-touch-icon" sizes="180x180" href="/glide/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/glide/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/glide/favicon-16x16.png"><link rel="manifest" href="/glide/manifest.json">#' {} \;
+
+git checkout gh-pages
+rm -rf "${JAVADOC_GH_PAGES_DIR}/${version}"
+cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$version
+rm -rf $TEMP_DIR
+git add "${JAVADOC_GH_PAGES_DIR}/$version"
+git commit -m "Update javadocs for version $version" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
+echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${version} and committed"
+git log -1 --pretty=%B
+echo "Ready to push"
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index ec5af0341..8f8d18b7b 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -15,6 +15,12 @@
  *
  *
  * Based on: https://github.com/mcxiaoke/gradle-mvn-push/blob/master/gradle-mvn-push.gradle.
+ *
+ * To install in a local maven repo:
+ * 1. In the project you want to test (not Glide), add mavenLocal() to the repositories list.
+ * 2. In Glide, run: ./gradlew uploadArchives -PLOCAL
+ *
+ * For faster runs add: -x check when building Glide.
  */
 
 apply plugin: 'maven'
@@ -23,34 +29,47 @@ apply plugin: 'signing'
 version = VERSION_NAME
 group = GROUP
 
+static def localMavenRepo() {
+    'file://' + new File(System.getProperty('user.home'), '.m2/repository').absolutePath
+}
+
+@SuppressWarnings("GrMethodMayBeStatic")
 def isReleaseBuild() {
-    return VERSION_NAME.contains("SNAPSHOT") == false
+    return !VERSION_NAME.contains("SNAPSHOT")
 }
 
 def getReleaseRepositoryUrl() {
-    return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
-            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+    return hasProperty('LOCAL') ? localMavenRepo()
+            : hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+            : 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
 }
 
 def getSnapshotRepositoryUrl() {
-    return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
-            : "https://oss.sonatype.org/content/repositories/snapshots/"
+    return hasProperty('LOCAL') ? localMavenRepo()
+            : hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+            : 'https://oss.sonatype.org/content/repositories/snapshots/'
 }
 
 def getRepositoryUsername() {
-    return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME')?NEXUS_USERNAME:"")
+    return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : '')
 }
 
 def getRepositoryPassword() {
-    return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD')?NEXUS_PASSWORD:"")
+    return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : '')
 }
 
 afterEvaluate { project ->
+    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
     // To avoid uploading the default empty jar artifact in the project root directory, we use a custom
     // configuration to specify which artifacts we want to upload.
     uploadArchives {
         repositories {
             mavenDeployer {
+                // allow uploading through FTP protocol with the following command:
+                // gradle uploadArchives -PSNAPSHOT_REPOSITORY_URL=ftp://host/repo/path -PUSERNAME=uname -PPASSWORD=passwd
+                configuration = configurations.create('deployerJars')
+                configuration.dependencies.add dependencies.create('org.apache.maven.wagon:wagon-ftp:2.2')
+
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
 
                 pom.groupId = GROUP
@@ -64,9 +83,40 @@ afterEvaluate { project ->
                     authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
                 }
 
+                pom.whenConfigured { pom ->
+                    pom.packaging = POM_PACKAGING
+                }
+
+                // Dependencies are only automatically included by the release plugin if the release
+                // variant is built. Since we've disabled the release variant to improve build
+                // times, we need to add the dependencies to the pom file explicitly.
+                if (isAndroidProject) {
+                    pom.withXml {
+                        def dependenciesNode = asNode().appendNode('dependencies')
+
+                        project.configurations.implementation.allDependencies.each {
+                            def groupId = it.group
+                            def artifactId = it.name
+                            // If we specify an artifact id that differs from the project name, it won't
+                            // match. To avoid that, we look up the artifact id (and group) by property
+                            // for any project dependencies.
+                            // TODO: there must be a neater way to do this.
+                            if (it instanceof ProjectDependency) {
+                                def properties = it.getDependencyProject().getProperties()
+                                groupId = properties.get("GROUP")
+                                artifactId = properties.get("POM_ARTIFACT_ID")
+                            }
+                            def dependencyNode = dependenciesNode.appendNode('dependency')
+                            dependencyNode.appendNode('groupId', groupId)
+                            dependencyNode.appendNode('artifactId', artifactId)
+                            dependencyNode.appendNode('version', it.version)
+                            dependencyNode.appendNode('scope', 'compile')
+                        }
+                    }
+                }
+
                 pom.project {
                     name = POM_NAME
-                    packaging = POM_PACKAGING
                     description = POM_DESCRIPTION
                     url = POM_URL
 
@@ -78,14 +128,14 @@ afterEvaluate { project ->
 
                     licenses {
                         license {
-                            name = "Simplified BSD License"
-                            url = "http://www.opensource.org/licenses/bsd-license"
-                            distribution = "repo"
+                            name = 'Simplified BSD License'
+                            url = 'http://www.opensource.org/licenses/bsd-license'
+                            distribution = 'repo'
                         }
                         license {
-                            name = "The Apache Software License, Version 2.0"
-                            url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
-                            distribution = "repo"
+                            name = 'The Apache Software License, Version 2.0'
+                            url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                            distribution = 'repo'
                         }
                     }
 
@@ -102,50 +152,90 @@ afterEvaluate { project ->
     }
 
     signing {
-        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        required { isReleaseBuild() && gradle.taskGraph.hasTask('uploadArchives') }
         sign configurations.archives
     }
 
-    if (project.getPlugins().hasPlugin('android') || project.getPlugins().hasPlugin('android-library')) {
-        def releaseVariants = project.android.libraryVariants.findAll { variant ->
-            variant.buildType.name.equalsIgnoreCase("release")
+
+    if (isAndroidProject) {
+        def variants = project.android.libraryVariants.findAll {
+            it.buildType.name.equalsIgnoreCase('debug')
         }
 
-        def androidSdkDirectory = project.android.sdkDirectory
+        def getAndroidSdkDirectory = project.android.sdkDirectory
 
-        task androidJavadocs(type: Javadoc, dependsOn: compileReleaseJava) {
-            source = releaseVariants.collect { it.javaCompile.source }
-            classpath = files(releaseVariants.collect { files(it.javaCompile.classpath.files,
-                    project.android.bootClasspath) })
+        def getAndroidJar = "${getAndroidSdkDirectory}/platforms/${project.android.compileSdkVersion}/android.jar"
 
+        task androidJavadocs(type: Javadoc, dependsOn: assembleDebug) {
+            source = variants.collect { it.javaCompile.source }
+            classpath = files(
+                    getAndroidJar,
+                    project.file("build/intermediates/classes/debug")
+            )
+            doFirst {
+                classpath += files(variants.collect { it.javaCompile.classpath.files })
+            }
             options {
                 links("http://docs.oracle.com/javase/7/docs/api/")
-                linksOffline("http://d.android.com/reference", "${androidSdkDirectory}/docs/reference")
+                linksOffline("http://d.android.com/reference",
+                        "${getAndroidSdkDirectory}/docs/reference")
             }
 
             exclude '**/BuildConfig.java'
             exclude '**/R.java'
         }
 
+        def cleanJavadocTask = task("cleanJavadocTask", type: Delete) {
+            delete androidJavadocs.destinationDir
+        } as Task
+        project.clean.dependsOn(cleanJavadocTask)
+
         task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+            classifier = 'javadoc'
             from androidJavadocs.destinationDir
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
         task androidSourcesJar(type: Jar) {
+            classifier = 'sources'
             from project.android.sourceSets.main.java.source
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
-    }
 
-    artifacts {
-        if (project.getPlugins().hasPlugin('android') || project.getPlugins().hasPlugin('android-library')) {
-            archives androidSourcesJar {
-                classifier "sources"
-            }
-            archives androidJavadocsJar {
-                classifier "javadoc"
-            }
+        task androidLibraryJar(type: Jar, dependsOn: compileDebugJavaWithJavac /* == variant.javaCompile */) {
+            from compileDebugJavaWithJavac.destinationDir
+            exclude '**/R.class'
+            exclude '**/BuildConfig.class'
+            exclude '**/R$*.class'
+            baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
+        }
+
+        artifacts {
+            archives androidLibraryJar
+            archives androidSourcesJar
+            archives androidJavadocsJar
+            // This is unnecessary with a release variant because by default the release variant
+            // includes the release aar in archives. Since we've disabled our release variants and
+            // want to include an aar, we need to manually specify the task that produces the aar
+            // here.
+            archives project.tasks.bundleDebug
+        }
+    } else if (project.plugins.hasPlugin('java')) {
+        task sourcesJar(type: Jar, dependsOn: classes) {
+            classifier = 'sources'
+            from sourceSets.main.allSource
+        }
+
+        task javadocsJar(type: Jar, dependsOn: javadoc) {
+            classifier = 'javadoc'
+            from javadoc.destinationDir
+        }
+
+        artifacts {
+            archives sourcesJar
+            archives javadocsJar
         }
     }
+    logger.info("Published artifacts in ${configurations.archives}:")
+    configurations.archives.artifacts.files.files.each { logger.info("\t$it") }
 }
diff --git a/settings.gradle b/settings.gradle
index 6f0fe1a45..360b59b47 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,7 +1,15 @@
 exec {
-  commandLine "git", "submodule", "update", "--init", "--recursive"
+    commandLine "git", "submodule", "update", "--init", "--recursive"
+    ignoreExitValue true
 }
 include ':library'
+include ':library:pmd'
+include ':library:findbugs'
+include ':library:test'
+include ':instrumentation'
+include ':annotation'
+include ':annotation:compiler'
+include ':annotation:compiler:test'
 include ':glide'
 include ':third_party:gif_decoder'
 include ':third_party:disklrucache'
@@ -9,9 +17,12 @@ include ':samples:flickr'
 include ':samples:giphy'
 include ':samples:svg'
 include ':samples:gallery'
+include ':samples:contacturi'
+include ':samples:imgur'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
+include ':integration:okhttp3'
 include ':integration:gifencoder'
 include ':integration:recyclerview'
 include ':testutil'
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
index d311d940f..54f7cbaf9 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
@@ -17,7 +17,7 @@ private TestResourceUtil() {
    * @param subPath   The sub-path under androidTest/resources where the desired resource is
    *                  located. Should not be prefixed with a '/'
    */
-  public static InputStream openResource(Class testClass, String subPath) {
+  public static InputStream openResource(Class<?> testClass, String subPath) {
     return testClass.getResourceAsStream("/" + subPath);
   }
 }
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
index 2d4ab7b5b..f39342c94 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
@@ -9,12 +9,14 @@
 /**
  * Shared utility classes for tests.
  */
+// Public API.
+@SuppressWarnings("WeakerAccess")
 public final class TestUtil {
   private TestUtil() {
     // Utility class.
   }
 
-  public static byte[] resourceToBytes(Class testClass, String resourceName) throws IOException {
+  public static byte[] resourceToBytes(Class<?> testClass, String resourceName) throws IOException {
     return isToBytes(TestResourceUtil.openResource(testClass, resourceName));
   }
 
@@ -33,7 +35,7 @@ private TestUtil() {
   }
 
   public static String isToString(InputStream is) throws IOException {
-    return new String(isToBytes(is));
+    return new String(isToBytes(is), "utf-8");
   }
 
   public static void assertStreamOf(String expected, InputStream result) throws IOException {
diff --git a/third_party/disklrucache b/third_party/disklrucache
index 847e0dad0..273f119c6 160000
--- a/third_party/disklrucache
+++ b/third_party/disklrucache
@@ -1 +1 @@
-Subproject commit 847e0dad08098c57e6dd12104463780e47e8e24e
+Subproject commit 273f119c607eb55da0627ebb4a0c1b0d1a15b2dc
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index e0904012a..301fd7c7e 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -1,23 +1,23 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
 
 dependencies {
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    implementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 
-    testCompile project(':testutil')
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    testCompile "com.google.truth:truth:${TRUTH_VERSION}"
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
-    testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation project(':testutil')
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
     }
 }
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/third_party/gif_decoder/gradle.properties b/third_party/gif_decoder/gradle.properties
new file mode 100644
index 000000000..9ada85d40
--- /dev/null
+++ b/third_party/gif_decoder/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide GIF Decoder Library
+POM_ARTIFACT_ID=gifdecoder
+POM_PACKAGING=aar
+POM_DESCRIPTION=Implementation of GifDecoder that is more memory efficient to animate for Android devices.
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index b23984a94..8aeaa634d 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -1,147 +1,41 @@
 package com.bumptech.glide.gifdecoder;
 
-/**
- * Copyright (c) 2013 Xcellent Creations, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.os.Build;
+import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.util.Log;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.io.InputStream;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.util.Arrays;
 
 /**
- * Reads frame data from a GIF image source and decodes it into individual frames for animation
- * purposes.  Image data can be read from either and InputStream source or a byte[].
- *
- * This class is optimized for running animations with the frames, there are no methods to get
- * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
- * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
- * in the animation sequence.
- *
- * The animation must be manually moved forward using {@link #advance()} before requesting the next
- * frame.  This method must also be called before you request the first frame or an error will
- * occur.
- *
- * Implementation adapted from sample code published in Lyons. (2004). <em>Java for
- * Programmers</em>, republished under the MIT Open Source License
+ * Shared interface for GIF decoders.
  */
-public class GifDecoder {
-  private static final String TAG = GifDecoder.class.getSimpleName();
-
-  /**
-   * File read status: No errors.
-   */
-  public static final int STATUS_OK = 0;
-  /**
-   * File read status: Error decoding file (may be partially decoded).
-   */
-  public static final int STATUS_FORMAT_ERROR = 1;
-  /**
-   * File read status: Unable to open source.
-   */
-  public static final int STATUS_OPEN_ERROR = 2;
-  /**
-   * Unable to fully decode the current frame.
-   */
-  public static final int STATUS_PARTIAL_DECODE = 3;
-  /**
-   * max decoder pixel stack size.
-   */
-  private static final int MAX_STACK_SIZE = 4096;
-
-  /**
-   * GIF Disposal Method meaning take no action.
-   */
-  private static final int DISPOSAL_UNSPECIFIED = 0;
-  /**
-   * GIF Disposal Method meaning leave canvas from previous frame.
-   */
-  private static final int DISPOSAL_NONE = 1;
-  /**
-   * GIF Disposal Method meaning clear canvas to background color.
-   */
-  private static final int DISPOSAL_BACKGROUND = 2;
-  /**
-   * GIF Disposal Method meaning clear canvas to frame before last.
-   */
-  private static final int DISPOSAL_PREVIOUS = 3;
-
-  private static final int NULL_CODE = -1;
+public interface GifDecoder {
 
-  private static final int INITIAL_FRAME_POINTER = -1;
+  /** File read status: No errors. */
+  int STATUS_OK = 0;
+  /** File read status: Error decoding file (may be partially decoded). */
+  int STATUS_FORMAT_ERROR = 1;
+  /** File read status: Unable to open source. */
+  int STATUS_OPEN_ERROR = 2;
+  /** Unable to fully decode the current frame. */
+  int STATUS_PARTIAL_DECODE = 3;
+  /** The total iteration count which means repeat forever. */
+  int TOTAL_ITERATION_COUNT_FOREVER = 0;
 
-  private static final int BYTES_PER_INTEGER = 4;
-
-  // Global File Header values and parsing flags.
-  // Active color table.
-  private int[] act;
-
-  // Raw GIF data from input source.
-  private ByteBuffer rawData;
-
-  // Raw data read working array.
-  private byte[] block;
-
-  // Temporary buffer for block reading. Reads 16k chunks from the native buffer for processing,
-  // to greatly reduce JNI overhead.
-  private static final int WORK_BUFFER_SIZE = 16384;
-  @Nullable private byte[] workBuffer;
-  private int workBufferSize = 0;
-  private int workBufferPosition = 0;
-
-  private GifHeaderParser parser;
-
-  // LZW decoder working arrays.
-  private short[] prefix;
-  private byte[] suffix;
-  private byte[] pixelStack;
-  private byte[] mainPixels;
-  private int[] mainScratch;
-
-  private int framePointer;
-  private GifHeader header;
-  private BitmapProvider bitmapProvider;
-  private Bitmap previousImage;
-  private boolean savePrevious;
-  private int status;
-  private int sampleSize;
-  private int downsampledHeight;
-  private int downsampledWidth;
-  private boolean isFirstFrameTransparent;
+  /** Android Lint annotation for status codes that can be used with a GIF decoder. */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(value = {STATUS_OK, STATUS_FORMAT_ERROR, STATUS_OPEN_ERROR, STATUS_PARTIAL_DECODE})
+  @interface GifDecodeStatus {
+  }
 
   /**
    * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs
    * from constantly allocating {@link android.graphics.Bitmap}s for every frame.
    */
-  public interface BitmapProvider {
+  interface BitmapProvider {
     /**
      * Returns an {@link Bitmap} with exactly the given dimensions and config.
      *
@@ -151,53 +45,44 @@
      *               android.graphics.Bitmap}.
      */
     @NonNull
-    Bitmap obtain(int width, int height, Bitmap.Config config);
+    Bitmap obtain(int width, int height, @NonNull Bitmap.Config config);
 
     /**
      * Releases the given Bitmap back to the pool.
      */
-    void release(Bitmap bitmap);
+    void release(@NonNull Bitmap bitmap);
 
     /**
      * Returns a byte array used for decoding and generating the frame bitmap.
      *
      * @param size the size of the byte array to obtain
      */
+    @NonNull
     byte[] obtainByteArray(int size);
 
     /**
      * Releases the given byte array back to the pool.
      */
-    void release(byte[] bytes);
-
-  }
-
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
-    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
-  }
+    void release(@NonNull byte[] bytes);
 
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
-      int sampleSize) {
-    this(provider);
-    setData(gifHeader, rawData, sampleSize);
-  }
+    /**
+     * Returns an int array used for decoding/generating the frame bitmaps.
+     */
+    @NonNull
+    int[] obtainIntArray(int size);
 
-  public GifDecoder(BitmapProvider provider) {
-    this.bitmapProvider = provider;
-    header = new GifHeader();
+    /**
+     * Release the given array back to the pool.
+     */
+    void release(@NonNull int[] array);
   }
 
-  public int getWidth() {
-    return header.width;
-  }
+  int getWidth();
 
-  public int getHeight() {
-    return header.height;
-  }
+  int getHeight();
 
-  public ByteBuffer getData() {
-    return rawData;
-  }
+  @NonNull
+  ByteBuffer getData();
 
   /**
    * Returns the current status of the decoder.
@@ -206,16 +91,13 @@ public ByteBuffer getData() {
    * was decoded successfully and/or completely. Format and open failures persist across frames.
    * </p>
    */
-  public int getStatus() {
-    return status;
-  }
+  @GifDecodeStatus
+  int getStatus();
 
   /**
    * Move the animation frame counter forward.
    */
-  public void advance() {
-    framePointer = (framePointer + 1) % header.frameCount;
-  }
+  void advance();
 
   /**
    * Gets display duration for specified frame.
@@ -223,134 +105,96 @@ public void advance() {
    * @param n int index of frame.
    * @return delay in milliseconds.
    */
-  public int getDelay(int n) {
-    int delay = -1;
-    if ((n >= 0) && (n < header.frameCount)) {
-      delay = header.frames.get(n).delay;
-    }
-    return delay;
-  }
+  int getDelay(int n);
 
   /**
    * Gets display duration for the upcoming frame in ms.
    */
-  public int getNextDelay() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      return 0;
-    }
-
-    return getDelay(framePointer);
-  }
+  int getNextDelay();
 
   /**
    * Gets the number of frames read from file.
    *
    * @return frame count.
    */
-  public int getFrameCount() {
-    return header.frameCount;
-  }
+  int getFrameCount();
 
   /**
    * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
    *
    * @return frame index.
    */
-  public int getCurrentFrameIndex() {
-    return framePointer;
-  }
+  int getCurrentFrameIndex();
 
   /**
    * Resets the frame pointer to before the 0th frame, as if we'd never used this decoder to
    * decode any frames.
    */
-  public void resetFrameIndex() {
-    framePointer = INITIAL_FRAME_POINTER;
-  }
+  void resetFrameIndex();
 
   /**
-   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
+   * Gets the "Netscape" loop count, if any. A count of 0 means repeat indefinitely.
    *
-   * @return iteration count if one was specified, else 1.
+   * @deprecated Use {@link #getNetscapeLoopCount()} instead.
+   *             This method cannot distinguish whether the loop count is 1 or doesn't exist.
+   * @return loop count if one was specified, else 1.
    */
-  public int getLoopCount() {
-    return header.loopCount;
-  }
+  @Deprecated
+  int getLoopCount();
+
+  /**
+   * Gets the "Netscape" loop count, if any.
+   * A count of 0 ({@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <br>
+   * Use {@link #getTotalIterationCount()}
+   * to know how many times the animation sequence should be displayed.
+   *
+   * @return loop count if one was specified,
+   *         else -1 ({@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}).
+   */
+  int getNetscapeLoopCount();
+
+  /**
+   * Gets the total count
+   * which represents how many times the animation sequence should be displayed.
+   * A count of 0 ({@link #TOTAL_ITERATION_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <p>
+   *     The total count is calculated as follows by using {@link #getNetscapeLoopCount()}.
+   *     This behavior is the same as most web browsers.
+   *     <table border='1'>
+   *         <tr class='tableSubHeadingColor'><th>{@code getNetscapeLoopCount()}</th>
+   *             <th>The total count</th></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}</td>
+   *             <td>{@link #TOTAL_ITERATION_COUNT_FOREVER}</td></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}</td>
+   *             <td>{@code 1}</td></tr>
+   *         <tr><td>{@code n (n > 0)}</td>
+   *             <td>{@code n + 1}</td></tr>
+   *     </table>
+   * </p>
+   *
+   * @see <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=592735#c5">Discussion about
+   *      the iteration count of animated GIFs (Chromium Issue 592735)</a>
+   *
+   * @return total iteration count calculated from "Netscape" loop count.
+   */
+  int getTotalIterationCount();
 
   /**
    * Returns an estimated byte size for this decoder based on the data provided to {@link
    * #setData(GifHeader, byte[])}, as well as internal buffers.
    */
-  public int getByteSize() {
-    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
-  }
+  int getByteSize();
 
   /**
    * Get the next frame in the animation sequence.
    *
    * @return Bitmap representation of frame.
    */
-  public synchronized Bitmap getNextFrame() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
-            + framePointer);
-      }
-      status = STATUS_FORMAT_ERROR;
-    }
-    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unable to decode frame, status=" + status);
-      }
-      return null;
-    }
-    status = STATUS_OK;
-
-    GifFrame currentFrame = header.frames.get(framePointer);
-    GifFrame previousFrame = null;
-    int previousIndex = framePointer - 1;
-    if (previousIndex >= 0) {
-      previousFrame = header.frames.get(previousIndex);
-    }
-
-    final int savedBgColor = header.bgColor;
-
-    // Set the appropriate color table.
-    if (currentFrame.lct == null) {
-      act = header.gct;
-    } else {
-      act = currentFrame.lct;
-      if (header.bgIndex == currentFrame.transIndex) {
-        header.bgColor = 0;
-      }
-    }
-
-    int save = 0;
-    if (currentFrame.transparency) {
-      save = act[currentFrame.transIndex];
-      // Set transparent color if specified.
-      act[currentFrame.transIndex] = 0;
-    }
-    if (act == null) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "No Valid Color Table");
-      }
-      // No color table defined.
-      status = STATUS_FORMAT_ERROR;
-      return null;
-    }
-
-    // Transfer pixel data to image.
-    Bitmap result = setPixels(currentFrame, previousFrame);
-
-    // Reset the transparent pixel in the color table
-    if (currentFrame.transparency) {
-      act[currentFrame.transIndex] = save;
-    }
-    header.bgColor = savedBgColor;
-
-    return result;
-  }
+  @Nullable
+  Bitmap getNextFrame();
 
   /**
    * Reads GIF image from stream.
@@ -358,103 +202,16 @@ public synchronized Bitmap getNextFrame() {
    * @param is containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public int read(InputStream is, int contentLength) {
-    if (is != null) {
-      try {
-        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
-        int nRead;
-        byte[] data = new byte[16384];
-        while ((nRead = is.read(data, 0, data.length)) != -1) {
-          buffer.write(data, 0, nRead);
-        }
-        buffer.flush();
-
-        read(buffer.toByteArray());
-      } catch (IOException e) {
-        Log.w(TAG, "Error reading data from stream", e);
-      }
-    } else {
-      status = STATUS_OPEN_ERROR;
-    }
-
-    try {
-      if (is != null) {
-        is.close();
-      }
-    } catch (IOException e) {
-      Log.w(TAG, "Error closing stream", e);
-    }
-
-    return status;
-  }
-
-  public void clear() {
-    header = null;
-    mainPixels = null;
-    mainScratch = null;
-    if (previousImage != null) {
-      bitmapProvider.release(previousImage);
-    }
-    previousImage = null;
-    rawData = null;
-    isFirstFrameTransparent = false;
-    if (block != null) {
-      bitmapProvider.release(block);
-    }
-    if (workBuffer != null) {
-      bitmapProvider.release(workBuffer);
-    }
-  }
+  @GifDecodeStatus
+  int read(@Nullable InputStream is, int contentLength);
 
-  public synchronized void setData(GifHeader header, byte[] data) {
-    setData(header, ByteBuffer.wrap(data));
-  }
+  void clear();
 
-  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
-    setData(header, buffer, 1);
-  }
+  void setData(@NonNull GifHeader header, @NonNull byte[] data);
 
-  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
-    if (sampleSize <= 0) {
-      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
-    }
-    // Make sure sample size is a power of 2.
-    sampleSize = Integer.highestOneBit(sampleSize);
-    this.status = STATUS_OK;
-    this.header = header;
-    isFirstFrameTransparent = false;
-    framePointer = INITIAL_FRAME_POINTER;
-    // Initialize the raw data buffer.
-    rawData = buffer.asReadOnlyBuffer();
-    rawData.position(0);
-    rawData.order(ByteOrder.LITTLE_ENDIAN);
-
-    // No point in specially saving an old frame if we're never going to use it.
-    savePrevious = false;
-    for (GifFrame frame : header.frames) {
-      if (frame.dispose == DISPOSAL_PREVIOUS) {
-        savePrevious = true;
-        break;
-      }
-    }
-
-    this.sampleSize = sampleSize;
-    // Now that we know the size, init scratch arrays.
-    // TODO: Find a way to avoid this entirely or at least downsample it
-    // (either should be possible).
-    mainPixels = new byte[header.width * header.height];
-    mainScratch = new int[(header.width / sampleSize) * (header.height / sampleSize)];
-    downsampledWidth = header.width / sampleSize;
-    downsampledHeight = header.height / sampleSize;
-  }
+  void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer);
 
-  private GifHeaderParser getHeaderParser() {
-    if (parser == null) {
-      parser = new GifHeaderParser();
-    }
-    return parser;
-  }
+  void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer, int sampleSize);
 
   /**
    * Reads GIF image from byte array.
@@ -462,380 +219,24 @@ private GifHeaderParser getHeaderParser() {
    * @param data containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public synchronized int read(byte[] data) {
-    this.header = getHeaderParser().setData(data).parseHeader();
-    if (data != null) {
-      setData(header, data);
-    }
+  @GifDecodeStatus
+  int read(@Nullable byte[] data);
 
-    return status;
-  }
 
   /**
-   * Creates new frame image from current data (and previous frames as specified by their
-   * disposition codes).
-   */
-  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
-    // Final location of blended pixels.
-    final int[] dest = mainScratch;
-
-    // fill in starting image contents based on last image's dispose code
-    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
-      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
-      // mainScratch and therefore so will our dest array.
-      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
-        // Start with a canvas filled with the background color
-        int c = 0;
-        if (!currentFrame.transparency) {
-          c = header.bgColor;
-        } else if (framePointer == 0) {
-          // TODO: We should check and see if all individual pixels are replaced. If they are, the
-          // first frame isn't actually transparent. For now, it's simpler and safer to assume
-          // drawing a transparent background means the GIF contains transparency.
-          isFirstFrameTransparent = true;
-        }
-        Arrays.fill(dest, c);
-      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
-        // Start with the previous frame
-        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-            downsampledHeight);
-      }
-    }
-
-    // Decode pixels for this frame  into the global pixels[] scratch.
-    decodeBitmapData(currentFrame);
-
-    int downsampledIH = currentFrame.ih / sampleSize;
-    int downsampledIY = currentFrame.iy / sampleSize;
-    int downsampledIW = currentFrame.iw / sampleSize;
-    int downsampledIX = currentFrame.ix / sampleSize;
-    // Copy each source line to the appropriate place in the destination.
-    int pass = 1;
-    int inc = 8;
-    int iline = 0;
-    boolean isFirstFrame = framePointer == 0;
-    for (int i = 0; i < downsampledIH; i++) {
-      int line = i;
-      if (currentFrame.interlace) {
-        if (iline >= downsampledIH) {
-          pass++;
-          switch (pass) {
-            case 2:
-              iline = 4;
-              break;
-            case 3:
-              iline = 2;
-              inc = 4;
-              break;
-            case 4:
-              iline = 1;
-              inc = 2;
-              break;
-            default:
-              break;
-          }
-        }
-        line = iline;
-        iline += inc;
-      }
-      line += downsampledIY;
-      if (line < downsampledHeight) {
-        int k = line * downsampledWidth;
-        // Start of line in dest.
-        int dx = k + downsampledIX;
-        // End of dest line.
-        int dlim = dx + downsampledIW;
-        if (k + downsampledWidth < dlim) {
-          // Past dest edge.
-          dlim = k + downsampledWidth;
-        }
-        // Start of line in source.
-        int sx = i * sampleSize * currentFrame.iw;
-        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
-        while (dx < dlim) {
-          // Map color and insert in destination.
-          int averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
-          if (averageColor != 0) {
-            dest[dx] = averageColor;
-          } else if (!isFirstFrameTransparent && isFirstFrame) {
-            isFirstFrameTransparent = true;
-          }
-          sx += sampleSize;
-          dx++;
-        }
-      }
-    }
-
-    // Copy pixels into previous image
-    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
-        || currentFrame.dispose == DISPOSAL_NONE)) {
-      if (previousImage == null) {
-        previousImage = getNextBitmap();
-      }
-      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-          downsampledHeight);
-    }
-
-    // Set pixels for current image.
-    Bitmap result = getNextBitmap();
-    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
-    return result;
-  }
-
-  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
-      int currentFrameIw) {
-    int alphaSum = 0;
-    int redSum = 0;
-    int greenSum = 0;
-    int blueSum = 0;
-
-    int totalAdded = 0;
-    // Find the pixels in the current row.
-    for (int i = positionInMainPixels;
-        i < positionInMainPixels + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    // Find the pixels in the next row.
-    for (int i = positionInMainPixels + currentFrameIw;
-        i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    if (totalAdded == 0) {
-      return 0;
-    } else {
-      return ((alphaSum / totalAdded) << 24)
-          | ((redSum / totalAdded) << 16)
-          | ((greenSum / totalAdded) << 8)
-          | (blueSum / totalAdded);
-     }
-  }
-
-  /**
-   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
-   */
-  private void decodeBitmapData(GifFrame frame) {
-    workBufferSize = 0;
-    workBufferPosition = 0;
-    if (frame != null) {
-      // Jump to the frame start position.
-      rawData.position(frame.bufferFrameStart);
-    }
-
-    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
-    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
-        i, datum,
-        dataSize, first, top, bi, pi;
-
-    if (mainPixels == null || mainPixels.length < npix) {
-      // Allocate new pixel array.
-      mainPixels = new byte[npix];
-    }
-    if (prefix == null) {
-      prefix = new short[MAX_STACK_SIZE];
-    }
-    if (suffix == null) {
-      suffix = new byte[MAX_STACK_SIZE];
-    }
-    if (pixelStack == null) {
-      pixelStack = new byte[MAX_STACK_SIZE + 1];
-    }
-
-    // Initialize GIF data stream decoder.
-    dataSize = readByte();
-    clear = 1 << dataSize;
-    endOfInformation = clear + 1;
-    available = clear + 2;
-    oldCode = NULL_CODE;
-    codeSize = dataSize + 1;
-    codeMask = (1 << codeSize) - 1;
-    for (code = 0; code < clear; code++) {
-      // XXX ArrayIndexOutOfBoundsException.
-      prefix[code] = 0;
-      suffix[code] = (byte) code;
-    }
-
-    // Decode GIF pixel stream.
-    datum = bits = count = first = top = pi = bi = 0;
-    for (i = 0; i < npix; ) {
-      // Load bytes until there are enough bits for a code.
-      if (count == 0) {
-        // Read a new data block.
-        count = readBlock();
-        if (count <= 0) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-        bi = 0;
-      }
-
-      datum += (((int) block[bi]) & 0xff) << bits;
-      bits += 8;
-      bi++;
-      count--;
-
-      while (bits >= codeSize) {
-        // Get the next code.
-        code = datum & codeMask;
-        datum >>= codeSize;
-        bits -= codeSize;
-
-        // Interpret the code.
-        if (code == clear) {
-          // Reset decoder.
-          codeSize = dataSize + 1;
-          codeMask = (1 << codeSize) - 1;
-          available = clear + 2;
-          oldCode = NULL_CODE;
-          continue;
-        }
-
-        if (code > available) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-
-        if (code == endOfInformation) {
-          break;
-        }
-
-        if (oldCode == NULL_CODE) {
-          pixelStack[top++] = suffix[code];
-          oldCode = code;
-          first = code;
-          continue;
-        }
-        inCode = code;
-        if (code >= available) {
-          pixelStack[top++] = (byte) first;
-          code = oldCode;
-        }
-        while (code >= clear) {
-          pixelStack[top++] = suffix[code];
-          code = prefix[code];
-        }
-        first = ((int) suffix[code]) & 0xff;
-        pixelStack[top++] = (byte) first;
-
-        // Add a new string to the string table.
-        if (available < MAX_STACK_SIZE) {
-          prefix[available] = (short) oldCode;
-          suffix[available] = (byte) first;
-          available++;
-          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-            codeSize++;
-            codeMask += available;
-          }
-        }
-        oldCode = inCode;
-
-        while (top > 0) {
-          // Pop a pixel off the pixel stack.
-          mainPixels[pi++] = pixelStack[--top];
-          i++;
-        }
-      }
-    }
-
-    // Clear missing pixels.
-    for (i = pi; i < npix; i++) {
-      mainPixels[i] = 0;
-    }
-  }
-
-  /**
-   * Reads the next chunk for the intermediate work buffer.
-   */
-  private void readChunkIfNeeded() {
-    if (workBufferSize > workBufferPosition) {
-      return;
-    }
-    if (workBuffer == null) {
-      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
-    }
-    workBufferPosition = 0;
-    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
-    rawData.get(workBuffer, 0, workBufferSize);
-  }
-
-  /**
-   * Reads a single byte from the input stream.
-   */
-  private int readByte() {
-    try {
-      readChunkIfNeeded();
-      return workBuffer[workBufferPosition++] & 0xFF;
-    } catch (Exception e) {
-      status = STATUS_FORMAT_ERROR;
-      return 0;
-    }
-  }
-
-  /**
-   * Reads next variable length block from input.
+   * Sets the default {@link android.graphics.Bitmap.Config} to use when decoding frames of a GIF.
+   *
+   * <p>Valid options are {@link android.graphics.Bitmap.Config#ARGB_8888} and
+   * {@link android.graphics.Bitmap.Config#RGB_565}.
+   * {@link android.graphics.Bitmap.Config#ARGB_8888} will produce higher quality frames, but will
+   * also use 2x the memory of {@link android.graphics.Bitmap.Config#RGB_565}.
    *
-   * @return number of bytes stored in "buffer".
+   * <p>Defaults to {@link android.graphics.Bitmap.Config#ARGB_8888}
+   *
+   * <p>This value is not a guarantee. For example if set to
+   * {@link android.graphics.Bitmap.Config#RGB_565} and the GIF contains transparent pixels,
+   * {@link android.graphics.Bitmap.Config#ARGB_8888} will be used anyway to support the
+   * transparency.
    */
-  private int readBlock() {
-    int blockSize = readByte();
-    if (blockSize > 0) {
-      try {
-        if (block == null) {
-          block = bitmapProvider.obtainByteArray(255);
-        }
-        final int remaining = workBufferSize - workBufferPosition;
-        if (remaining >= blockSize) {
-          // Block can be read from the current work buffer.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
-          workBufferPosition += blockSize;
-        } else if (rawData.remaining() + remaining >= blockSize) {
-          // Block can be read in two passes.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
-          workBufferPosition = workBufferSize;
-          readChunkIfNeeded();
-          final int secondHalfRemaining = blockSize - remaining;
-          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
-          workBufferPosition += secondHalfRemaining;
-        } else {
-          status = STATUS_FORMAT_ERROR;
-        }
-      } catch (Exception e) {
-        Log.w(TAG, "Error Reading Block", e);
-        status = STATUS_FORMAT_ERROR;
-      }
-    }
-    return blockSize;
-  }
-
-  private Bitmap getNextBitmap() {
-    Bitmap.Config config = isFirstFrameTransparent
-        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
-    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
-    setAlpha(result);
-    return result;
-  }
-
-  @TargetApi(12)
-  private static void setAlpha(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= 12) {
-      bitmap.setHasAlpha(true);
-    }
-  }
+  void setDefaultBitmapConfig(@NonNull Bitmap.Config format);
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
index 6da8c9e40..a4d980d3e 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
@@ -1,9 +1,57 @@
 package com.bumptech.glide.gifdecoder;
 
+import android.support.annotation.ColorInt;
+import android.support.annotation.IntDef;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
 /**
  * Inner model class housing metadata for each frame.
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 class GifFrame {
+  /**
+   * GIF Disposal Method meaning take no action.
+   * <p><b>GIF89a</b>: <i>No disposal specified.
+   * The decoder is not required to take any action.</i></p>
+   */
+  static final int DISPOSAL_UNSPECIFIED = 0;
+  /**
+   * GIF Disposal Method meaning leave canvas from previous frame.
+   * <p><b>GIF89a</b>: <i>Do not dispose.
+   * The graphic is to be left in place.</i></p>
+   */
+  static final int DISPOSAL_NONE = 1;
+  /**
+   * GIF Disposal Method meaning clear canvas to background color.
+   * <p><b>GIF89a</b>: <i>Restore to background color.
+   * The area used by the graphic must be restored to the background color.</i></p>
+   */
+  static final int DISPOSAL_BACKGROUND = 2;
+  /**
+   * GIF Disposal Method meaning clear canvas to frame before last.
+   * <p><b>GIF89a</b>: <i>Restore to previous.
+   * The decoder is required to restore the area overwritten by the graphic
+   * with what was there prior to rendering the graphic.</i></p>
+   */
+  static final int DISPOSAL_PREVIOUS = 3;
+
+  /**
+   * <p><b>GIF89a</b>:
+   * <i>Indicates the way in which the graphic is to be treated after being displayed.</i></p>
+   * Disposal methods 0-3 are defined, 4-7 are reserved for future use.
+   *
+   * @see #DISPOSAL_UNSPECIFIED
+   * @see #DISPOSAL_NONE
+   * @see #DISPOSAL_BACKGROUND
+   * @see #DISPOSAL_PREVIOUS
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(value = {DISPOSAL_UNSPECIFIED, DISPOSAL_NONE, DISPOSAL_BACKGROUND, DISPOSAL_PREVIOUS})
+  private @interface GifDisposalMethod {
+  }
+
   int ix, iy, iw, ih;
   /**
    * Control Flag.
@@ -16,13 +64,14 @@
   /**
    * Disposal Method.
    */
+  @GifDisposalMethod
   int dispose;
   /**
    * Transparency Index.
    */
   int transIndex;
   /**
-   * Delay, in ms, to next frame.
+   * Delay, in milliseconds, to next frame.
    */
   int delay;
   /**
@@ -32,5 +81,6 @@
   /**
    * Local Color Table.
    */
+  @ColorInt
   int[] lct;
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index 5b57212ec..7a60b5f46 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.gifdecoder;
 
+import android.support.annotation.ColorInt;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -8,34 +9,46 @@
  * metadata like width and height that can be used to decode each individual frame of the GIF. Can
  * be shared by one or more {@link com.bumptech.glide.gifdecoder.GifDecoder}s to play the same
  * animated GIF in multiple views.
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 public class GifHeader {
 
+  /** The "Netscape" loop count which means loop forever. */
+  public static final int NETSCAPE_LOOP_COUNT_FOREVER = 0;
+  /** Indicates that this header has no "Netscape" loop count. */
+  public static final int NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST = -1;
+
+  @ColorInt
   int[] gct = null;
+  @GifDecoder.GifDecodeStatus
   int status = GifDecoder.STATUS_OK;
   int frameCount = 0;
 
   GifFrame currentFrame;
-  List<GifFrame> frames = new ArrayList<GifFrame>();
-  // Logical screen size.
-  // Full image width.
+  final List<GifFrame> frames = new ArrayList<>();
+  /** Logical screen size: Full image width. */
   int width;
-  // Full image height.
+  /** Logical screen size: Full image height. */
   int height;
 
   // 1 : global color table flag.
   boolean gctFlag;
-  // 2-4 : color resolution.
-  // 5 : gct sort flag.
-  // 6-8 : gct size.
+  /**
+   * Size of Global Color Table.
+   * The value is already computed to be a regular number, this field doesn't store the exponent.
+   */
   int gctSize;
-  // Background color index.
+  /** Background color index into the Global/Local color table. */
   int bgIndex;
-  // Pixel aspect ratio.
+  /**
+   * Pixel aspect ratio.
+   * Factor used to compute an approximation of the aspect ratio of the pixel in the original image.
+   */
   int pixelAspect;
-  //TODO: this is set both during reading the header and while decoding frames...
+  @ColorInt
   int bgColor;
-  int loopCount;
+  int loopCount = NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
 
   public int getHeight() {
     return height;
@@ -52,6 +65,7 @@ public int getNumFrames() {
   /**
    * Global status code of GIF data parsing.
    */
+  @GifDecoder.GifDecodeStatus
   public int getStatus() {
     return status;
   }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index 2036b6cab..47f6e25df 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -1,9 +1,12 @@
 package com.bumptech.glide.gifdecoder;
 
 import static com.bumptech.glide.gifdecoder.GifDecoder.STATUS_FORMAT_ERROR;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_NONE;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
-
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -11,15 +14,106 @@
 
 /**
  * A class responsible for creating {@link com.bumptech.glide.gifdecoder.GifHeader}s from data
- * representing animated gifs.
+ * representing animated GIFs.
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 public class GifHeaderParser {
-  public static final String TAG = "GifHeaderParser";
+  private static final String TAG = "GifHeaderParser";
+
+  private static final int MASK_INT_LOWEST_BYTE = 0x000000FF;
+
+  /** Identifies the beginning of an Image Descriptor. */
+  private static final int IMAGE_SEPARATOR = 0x2C;
+  /** Identifies the beginning of an extension block. */
+  private static final int EXTENSION_INTRODUCER = 0x21;
+  /** This block is a single-field block indicating the end of the GIF Data Stream. */
+  private static final int TRAILER = 0x3B;
+  // Possible labels that identify the current extension block.
+  private static final int LABEL_GRAPHIC_CONTROL_EXTENSION = 0xF9;
+  private static final int LABEL_APPLICATION_EXTENSION = 0xFF;
+  private static final int LABEL_COMMENT_EXTENSION = 0xFE;
+  private static final int LABEL_PLAIN_TEXT_EXTENSION = 0x01;
+
+  // Graphic Control Extension packed field masks
+
+  /**
+   * Mask (bits 4-2) to extract Disposal Method of the current frame.
+   *
+   * @see GifFrame.GifDisposalMethod possible values
+   */
+  private static final int GCE_MASK_DISPOSAL_METHOD = 0b00011100;
+  /**
+   * Shift so the Disposal Method extracted from the packed value is on the least significant bit.
+   */
+  private static final int GCE_DISPOSAL_METHOD_SHIFT = 2;
+  /**
+   * Mask (bit 0) to extract Transparent Color Flag of the current frame.
+   * <p><b>GIF89a</b>: <i>Indicates whether a transparency index is given
+   * in the Transparent Index field.</i></p>
+   * Possible values are:<ul>
+   * <li>0 - Transparent Index is not given.</li>
+   * <li>1 - Transparent Index is given.</li>
+   * </ul>
+   */
+  private static final int GCE_MASK_TRANSPARENT_COLOR_FLAG = 0b00000001;
+
+  // Image Descriptor packed field masks (describing Local Color Table)
+
+  /**
+   * Mask (bit 7) to extract Local Color Table Flag of the current image.
+   * <p><b>GIF89a</b>: <i>Indicates the presence of a Local Color Table
+   * immediately following this Image Descriptor.</i></p>
+   */
+  private static final int DESCRIPTOR_MASK_LCT_FLAG = 0b10000000;
+  /**
+   * Mask (bit 6) to extract Interlace Flag of the current image.
+   * <p><b>GIF89a</b>: <i>Indicates if the image is interlaced.
+   * An image is interlaced in a four-pass interlace pattern.</i></p>
+   * Possible values are:<ul>
+   * <li>0 - Image is not interlaced.</li>
+   * <li>1 - Image is interlaced.</li>
+   * </ul>
+   */
+  private static final int DESCRIPTOR_MASK_INTERLACE_FLAG = 0b01000000;
+  /**
+   * Mask (bits 2-0) to extract Size of the Local Color Table of the current image.
+   * <p><b>GIF89a</b>: <i>If the Local Color Table Flag is set to 1, the value in this
+   * field is used to calculate the number of bytes contained in the Local Color Table.
+   * To determine that actual size of the color table, raise 2 to [the value of the field + 1].
+   * This value should be 0 if there is no Local Color Table specified.</i></p>
+   */
+  private static final int DESCRIPTOR_MASK_LCT_SIZE = 0b00000111;
 
-  // The minimum frame delay in hundredths of a second.
-  static final int MIN_FRAME_DELAY = 3;
-  // The default frame delay in hundredths of a second for GIFs with frame delays less than the
-  // minimum.
+  // Logical Screen Descriptor packed field masks (describing Global Color Table)
+
+  /**
+   * Mask (bit 7) to extract Global Color Table Flag of the current image.
+   * <p><b>GIF89a</b>: <i>Indicates the presence of a Global Color Table
+   * immediately following this Image Descriptor.</i></p>
+   * Possible values are:<ul>
+   * <li>0 - No Global Color Table follows, the Background Color Index field is meaningless.</li>
+   * <li>1 - A Global Color Table will immediately follow,
+   * the Background Color Index field is meaningful.</li>
+   * </ul>
+   */
+  private static final int LSD_MASK_GCT_FLAG = 0b10000000;
+  /**
+   * Mask (bits 2-0) to extract Size of the Global Color Table of the current image.
+   * <p><b>GIF89a</b>: <i>If the Global Color Table Flag is set to 1, the value in this
+   * field is used to calculate the number of bytes contained in the Global Color Table.
+   * To determine that actual size of the color table, raise 2 to [the value of the field + 1].
+   * Even if there is no Global Color Table specified, set this field according to the above
+   * formula so that decoders can choose the best graphics mode to display the stream in.</i></p>
+   */
+  private static final int LSD_MASK_GCT_SIZE = 0b00000111;
+
+  /** The minimum frame delay in hundredths of a second. */
+  static final int MIN_FRAME_DELAY = 2;
+  /**
+   * The default frame delay in hundredths of a second.
+   * This is used for GIFs with frame delays less than the minimum.
+   */
   static final int DEFAULT_FRAME_DELAY = 10;
 
   private static final int MAX_BLOCK_SIZE = 256;
@@ -30,7 +124,7 @@
   private GifHeader header;
   private int blockSize = 0;
 
-  public GifHeaderParser setData(ByteBuffer data) {
+  public GifHeaderParser setData(@NonNull ByteBuffer data) {
     reset();
     rawData = data.asReadOnlyBuffer();
     rawData.position(0);
@@ -38,7 +132,7 @@ public GifHeaderParser setData(ByteBuffer data) {
     return this;
   }
 
-  public GifHeaderParser setData(byte[] data) {
+  public GifHeaderParser setData(@Nullable byte[] data) {
     if (data != null) {
       setData(ByteBuffer.wrap(data));
     } else {
@@ -60,6 +154,7 @@ private void reset() {
     blockSize = 0;
   }
 
+  @NonNull
   public GifHeader parseHeader() {
     if (rawData == null) {
       throw new IllegalStateException("You must call setData() before parseHeader()");
@@ -79,69 +174,81 @@ public GifHeader parseHeader() {
     return header;
   }
 
+  /**
+   * Determines if the GIF is animated by trying to read in the first 2 frames
+   * This method re-parses the data even if the header has already been read.
+   */
+  public boolean isAnimated() {
+    readHeader();
+    if (!err()) {
+      readContents(2 /* maxFrames */);
+    }
+    return header.frameCount > 1;
+  }
+
   /**
    * Main file parser. Reads GIF content blocks.
    */
   private void readContents() {
+    readContents(Integer.MAX_VALUE /* maxFrames */);
+  }
+
+  /**
+   * Main file parser. Reads GIF content blocks. Stops after reading maxFrames
+   */
+  private void readContents(int maxFrames) {
     // Read GIF file content blocks.
     boolean done = false;
-    while (!(done || err())) {
+    while (!(done || err() || header.frameCount > maxFrames)) {
       int code = read();
       switch (code) {
-        // Image separator.
-        case 0x2C:
-          // The graphics control extension is optional, but will always come first if it exists.
-          // If one did
-          // exist, there will be a non-null current frame which we should use. However if one
-          // did not exist,
-          // the current frame will be null and we must create it here. See issue #134.
+        case IMAGE_SEPARATOR:
+          // The Graphic Control Extension is optional, but will always come first if it exists.
+          // If one did exist, there will be a non-null current frame which we should use.
+          // However if one did not exist, the current frame will be null
+          // and we must create it here. See issue #134.
           if (header.currentFrame == null) {
             header.currentFrame = new GifFrame();
           }
           readBitmap();
           break;
-        // Extension.
-        case 0x21:
-          code = read();
-          switch (code) {
-            // Graphics control extension.
-            case 0xf9:
+        case EXTENSION_INTRODUCER:
+          int extensionLabel = read();
+          switch (extensionLabel) {
+            case LABEL_GRAPHIC_CONTROL_EXTENSION:
               // Start a new frame.
               header.currentFrame = new GifFrame();
               readGraphicControlExt();
               break;
-            // Application extension.
-            case 0xff:
+            case LABEL_APPLICATION_EXTENSION:
               readBlock();
-              String app = "";
+              StringBuilder app = new StringBuilder();
               for (int i = 0; i < 11; i++) {
-                app += (char) block[i];
+                app.append((char) block[i]);
               }
-              if (app.equals("NETSCAPE2.0")) {
+              if (app.toString().equals("NETSCAPE2.0")) {
                 readNetscapeExt();
               } else {
                 // Don't care.
                 skip();
               }
               break;
-            // Comment extension.
-            case 0xfe:
+            case LABEL_COMMENT_EXTENSION:
               skip();
               break;
-            // Plain text extension.
-            case 0x01:
+            case LABEL_PLAIN_TEXT_EXTENSION:
               skip();
               break;
-            // Uninteresting extension.
             default:
+              // Uninteresting extension.
               skip();
           }
           break;
-        // Terminator.
-        case 0x3b:
+        case TRAILER:
+          // This block is a single-field block indicating the end of the GIF Data Stream.
           done = true;
           break;
-        // Bad byte, but keep going and see what happens break;
+        // Bad byte, but keep going and see what happens
         case 0x00:
         default:
           header.status = STATUS_FORMAT_ERROR;
@@ -150,20 +257,31 @@ private void readContents() {
   }
 
   /**
-   * Reads Graphics Control Extension values.
+   * Reads Graphic Control Extension values.
    */
   private void readGraphicControlExt() {
     // Block size.
     read();
-    // Packed fields.
+    /*
+     * Graphic Control Extension packed field:
+     *      7 6 5 4 3 2 1 0
+     *     +---------------+
+     *  1  |     |     | | |
+     *
+     * Reserved                    3 Bits
+     * Disposal Method             3 Bits
+     * User Input Flag             1 Bit
+     * Transparent Color Flag      1 Bit
+     */
     int packed = read();
     // Disposal method.
-    header.currentFrame.dispose = (packed & 0x1c) >> 2;
-    if (header.currentFrame.dispose == 0) {
+    //noinspection WrongConstant field has to be extracted from packed value
+    header.currentFrame.dispose = (packed & GCE_MASK_DISPOSAL_METHOD) >> GCE_DISPOSAL_METHOD_SHIFT;
+    if (header.currentFrame.dispose == DISPOSAL_UNSPECIFIED) {
       // Elect to keep old image if discretionary.
-      header.currentFrame.dispose = 1;
+      header.currentFrame.dispose = DISPOSAL_NONE;
     }
-    header.currentFrame.transparency = (packed & 1) != 0;
+    header.currentFrame.transparency = (packed & GCE_MASK_TRANSPARENT_COLOR_FLAG) != 0;
     // Delay in milliseconds.
     int delayInHundredthsOfASecond = readShort();
     // TODO: consider allowing -1 to indicate show forever.
@@ -187,16 +305,23 @@ private void readBitmap() {
     header.currentFrame.iw = readShort();
     header.currentFrame.ih = readShort();
 
+    /*
+     * Image Descriptor packed field:
+     *     7 6 5 4 3 2 1 0
+     *    +---------------+
+     * 9  | | | |   |     |
+     *
+     * Local Color Table Flag     1 Bit
+     * Interlace Flag             1 Bit
+     * Sort Flag                  1 Bit
+     * Reserved                   2 Bits
+     * Size of Local Color Table  3 Bits
+     */
     int packed = read();
-    // 1 - local color table flag interlace
-    boolean lctFlag = (packed & 0x80) != 0;
-    int lctSize = (int) Math.pow(2, (packed & 0x07) + 1);
-    // 3 - sort flag
-    // 4-5 - reserved lctSize = 2 << (packed & 7); // 6-8 - local color
-    // table size
-    header.currentFrame.interlace = (packed & 0x40) != 0;
+    boolean lctFlag = (packed & DESCRIPTOR_MASK_LCT_FLAG) != 0;
+    int lctSize = (int) Math.pow(2, (packed & DESCRIPTOR_MASK_LCT_SIZE) + 1);
+    header.currentFrame.interlace = (packed & DESCRIPTOR_MASK_INTERLACE_FLAG) != 0;
     if (lctFlag) {
-      // Read table.
       header.currentFrame.lct = readColorTable(lctSize);
     } else {
       // No local color table.
@@ -226,8 +351,8 @@ private void readNetscapeExt() {
       readBlock();
       if (block[0] == 1) {
         // Loop count sub-block.
-        int b1 = ((int) block[1]) & 0xff;
-        int b2 = ((int) block[2]) & 0xff;
+        int b1 = ((int) block[1]) & MASK_INT_LOWEST_BYTE;
+        int b2 = ((int) block[2]) & MASK_INT_LOWEST_BYTE;
         header.loopCount = (b2 << 8) | b1;
       }
     } while ((blockSize > 0) && !err());
@@ -238,11 +363,11 @@ private void readNetscapeExt() {
    * Reads GIF file header information.
    */
   private void readHeader() {
-    String id = "";
+    StringBuilder id = new StringBuilder();
     for (int i = 0; i < 6; i++) {
-      id += (char) read();
+      id.append((char) read());
     }
-    if (!id.startsWith("GIF")) {
+    if (!id.toString().startsWith("GIF")) {
       header.status = STATUS_FORMAT_ERROR;
       return;
     }
@@ -260,14 +385,20 @@ private void readLSD() {
     // Logical screen size.
     header.width = readShort();
     header.height = readShort();
-    // Packed fields
+    /*
+     * Logical Screen Descriptor packed field:
+     *      7 6 5 4 3 2 1 0
+     *     +---------------+
+     *  4  | |     | |     |
+     *
+     * Global Color Table Flag     1 Bit
+     * Color Resolution            3 Bits
+     * Sort Flag                   1 Bit
+     * Size of Global Color Table  3 Bits
+     */
     int packed = read();
-    // 1 : global color table flag.
-    header.gctFlag = (packed & 0x80) != 0;
-    // 2-4 : color resolution.
-    // 5 : gct sort flag.
-    // 6-8 : gct size.
-    header.gctSize = 2 << (packed & 7);
+    header.gctFlag = (packed & LSD_MASK_GCT_FLAG) != 0;
+    header.gctSize = (int) Math.pow(2, (packed & LSD_MASK_GCT_SIZE) + 1);
     // Background color index.
     header.bgIndex = read();
     // Pixel aspect ratio
@@ -277,13 +408,14 @@ private void readLSD() {
   /**
    * Reads color table as 256 RGB integer values.
    *
-   * @param ncolors int number of colors to read.
+   * @param nColors int number of colors to read.
    * @return int array containing 256 colors (packed ARGB with full alpha).
    */
-  private int[] readColorTable(int ncolors) {
-    int nbytes = 3 * ncolors;
+  @Nullable
+  private int[] readColorTable(int nColors) {
+    int nBytes = 3 * nColors;
     int[] tab = null;
-    byte[] c = new byte[nbytes];
+    byte[] c = new byte[nBytes];
 
     try {
       rawData.get(c);
@@ -293,11 +425,11 @@ private void readLSD() {
       tab = new int[MAX_BLOCK_SIZE];
       int i = 0;
       int j = 0;
-      while (i < ncolors) {
-        int r = ((int) c[j++]) & 0xff;
-        int g = ((int) c[j++]) & 0xff;
-        int b = ((int) c[j++]) & 0xff;
-        tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
+      while (i < nColors) {
+        int r = ((int) c[j++]) & MASK_INT_LOWEST_BYTE;
+        int g = ((int) c[j++]) & MASK_INT_LOWEST_BYTE;
+        int b = ((int) c[j++]) & MASK_INT_LOWEST_BYTE;
+        tab[i++] = 0xFF000000 | (r << 16) | (g << 8) | b;
       }
     } catch (BufferUnderflowException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -326,16 +458,15 @@ private void skip() {
     int blockSize;
     do {
       blockSize = read();
-      rawData.position(rawData.position() + blockSize);
+      int newPosition = Math.min(rawData.position() + blockSize, rawData.limit());
+      rawData.position(newPosition);
     } while (blockSize > 0);
   }
 
   /**
    * Reads next variable length block from input.
-   *
-   * @return number of bytes stored in "buffer"
    */
-  private int readBlock() {
+  private void readBlock() {
     blockSize = read();
     int n = 0;
     if (blockSize > 0) {
@@ -355,20 +486,19 @@ private int readBlock() {
         header.status = STATUS_FORMAT_ERROR;
       }
     }
-    return n;
   }
 
   /**
    * Reads a single byte from the input stream.
    */
   private int read() {
-    int curByte = 0;
+    int currByte = 0;
     try {
-      curByte = rawData.get() & 0xFF;
+      currByte = rawData.get() & MASK_INT_LOWEST_BYTE;
     } catch (Exception e) {
       header.status = STATUS_FORMAT_ERROR;
     }
-    return curByte;
+    return currByte;
   }
 
   /**
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
new file mode 100644
index 000000000..4ce8a73c3
--- /dev/null
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -0,0 +1,847 @@
+package com.bumptech.glide.gifdecoder;
+
+/*
+ * Copyright (c) 2013 Xcellent Creations, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_BACKGROUND;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_NONE;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_PREVIOUS;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.support.annotation.ColorInt;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+/**
+ * Reads frame data from a GIF image source and decodes it into individual frames for animation
+ * purposes.  Image data can be read from either and InputStream source or a byte[].
+ *
+ * <p>This class is optimized for running animations with the frames, there are no methods to get
+ * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
+ * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
+ * in the animation sequence.
+ *
+ * <p>The animation must be manually moved forward using {@link #advance()} before requesting the
+ * next frame.  This method must also be called before you request the first frame or an error
+ * will occur.
+ *
+ * <p>Implementation adapted from sample code published in Lyons. (2004). <em>Java for
+ * Programmers</em>, republished under the MIT Open Source License
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
+ */
+public class StandardGifDecoder implements GifDecoder {
+  private static final String TAG = StandardGifDecoder.class.getSimpleName();
+
+  /** Maximum pixel stack size for decoding LZW compressed data. */
+  private static final int MAX_STACK_SIZE = 4 * 1024;
+
+  private static final int NULL_CODE = -1;
+
+  private static final int INITIAL_FRAME_POINTER = -1;
+
+  private static final int BYTES_PER_INTEGER = Integer.SIZE / 8;
+
+  private static final int MASK_INT_LOWEST_BYTE = 0x000000FF;
+
+  @ColorInt
+  private static final int COLOR_TRANSPARENT_BLACK = 0x00000000;
+
+  // Global File Header values and parsing flags.
+  /**
+   * Active color table.
+   * Maximum size is 256, see GifHeaderParser.readColorTable
+   */
+  @ColorInt
+  private int[] act;
+  /** Private color table that can be modified if needed. */
+  @ColorInt
+  private final int[] pct = new int[256];
+
+  private final GifDecoder.BitmapProvider bitmapProvider;
+
+  /** Raw GIF data from input source. */
+  private ByteBuffer rawData;
+
+  /** Raw data read working array. */
+  private byte[] block;
+
+  private GifHeaderParser parser;
+
+  // LZW decoder working arrays.
+  private short[] prefix;
+  private byte[] suffix;
+  private byte[] pixelStack;
+  private byte[] mainPixels;
+  @ColorInt
+  private int[] mainScratch;
+
+  private int framePointer;
+  private GifHeader header;
+  private Bitmap previousImage;
+  private boolean savePrevious;
+  @GifDecodeStatus
+  private int status;
+  private int sampleSize;
+  private int downsampledHeight;
+  private int downsampledWidth;
+  @Nullable
+  private Boolean isFirstFrameTransparent;
+  @NonNull
+  private Bitmap.Config bitmapConfig = Config.ARGB_8888;
+
+  // Public API.
+  @SuppressWarnings("unused")
+  public StandardGifDecoder(
+      @NonNull GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
+    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
+  }
+
+  public StandardGifDecoder(
+      @NonNull GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
+      int sampleSize) {
+    this(provider);
+    setData(gifHeader, rawData, sampleSize);
+  }
+
+  public StandardGifDecoder(
+      @NonNull GifDecoder.BitmapProvider provider) {
+    this.bitmapProvider = provider;
+    header = new GifHeader();
+  }
+
+  @Override
+  public int getWidth() {
+    return header.width;
+  }
+
+  @Override
+  public int getHeight() {
+    return header.height;
+  }
+
+  @NonNull
+  @Override
+  public ByteBuffer getData() {
+    return rawData;
+  }
+
+  @Override
+  public int getStatus() {
+    return status;
+  }
+
+  @Override
+  public void advance() {
+    framePointer = (framePointer + 1) % header.frameCount;
+  }
+
+  @Override
+  public int getDelay(int n) {
+    int delay = -1;
+    if ((n >= 0) && (n < header.frameCount)) {
+      delay = header.frames.get(n).delay;
+    }
+    return delay;
+  }
+
+  @Override
+  public int getNextDelay() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      return 0;
+    }
+
+    return getDelay(framePointer);
+  }
+
+  @Override
+  public int getFrameCount() {
+    return header.frameCount;
+  }
+
+  @Override
+  public int getCurrentFrameIndex() {
+    return framePointer;
+  }
+
+  @Override
+  public void resetFrameIndex() {
+    framePointer = INITIAL_FRAME_POINTER;
+  }
+
+  @Deprecated
+  @Override
+  public int getLoopCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
+    return header.loopCount;
+  }
+
+  @Override
+  public int getNetscapeLoopCount() {
+    return header.loopCount;
+  }
+
+  @Override
+  public int getTotalIterationCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_FOREVER) {
+      return TOTAL_ITERATION_COUNT_FOREVER;
+    }
+    return header.loopCount + 1;
+  }
+
+  @Override
+  public int getByteSize() {
+    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
+  }
+
+  @Nullable
+  @Override
+  public synchronized Bitmap getNextFrame() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to decode frame"
+            + ", frameCount=" + header.frameCount
+            + ", framePointer=" + framePointer
+        );
+      }
+      status = STATUS_FORMAT_ERROR;
+    }
+    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to decode frame, status=" + status);
+      }
+      return null;
+    }
+    status = STATUS_OK;
+
+    if (block == null) {
+      block = bitmapProvider.obtainByteArray(255);
+    }
+
+    GifFrame currentFrame = header.frames.get(framePointer);
+    GifFrame previousFrame = null;
+    int previousIndex = framePointer - 1;
+    if (previousIndex >= 0) {
+      previousFrame = header.frames.get(previousIndex);
+    }
+
+    // Set the appropriate color table.
+    act = currentFrame.lct != null ? currentFrame.lct : header.gct;
+    if (act == null) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "No valid color table found for frame #" + framePointer);
+      }
+      // No color table defined.
+      status = STATUS_FORMAT_ERROR;
+      return null;
+    }
+
+    // Reset the transparent pixel in the color table
+    if (currentFrame.transparency) {
+      // Prepare local copy of color table ("pct = act"), see #1068
+      System.arraycopy(act, 0, pct, 0, act.length);
+      // Forget about act reference from shared header object, use copied version
+      act = pct;
+      // Set transparent color if specified.
+      act[currentFrame.transIndex] = COLOR_TRANSPARENT_BLACK;
+    }
+
+    // Transfer pixel data to image.
+    return setPixels(currentFrame, previousFrame);
+  }
+
+  @Override
+  public int read(@Nullable InputStream is, int contentLength) {
+    if (is != null) {
+      try {
+        int capacity = (contentLength > 0) ? (contentLength + 4 * 1024) : 16 * 1024;
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
+        int nRead;
+        byte[] data = new byte[16 * 1024];
+        while ((nRead = is.read(data, 0, data.length)) != -1) {
+          buffer.write(data, 0, nRead);
+        }
+        buffer.flush();
+
+        read(buffer.toByteArray());
+      } catch (IOException e) {
+        Log.w(TAG, "Error reading data from stream", e);
+      }
+    } else {
+      status = STATUS_OPEN_ERROR;
+    }
+
+    try {
+      if (is != null) {
+        is.close();
+      }
+    } catch (IOException e) {
+      Log.w(TAG, "Error closing stream", e);
+    }
+
+    return status;
+  }
+
+  @Override
+  public void clear() {
+    header = null;
+    if (mainPixels != null) {
+      bitmapProvider.release(mainPixels);
+    }
+    if (mainScratch != null) {
+      bitmapProvider.release(mainScratch);
+    }
+    if (previousImage != null) {
+      bitmapProvider.release(previousImage);
+    }
+    previousImage = null;
+    rawData = null;
+    isFirstFrameTransparent = null;
+    if (block != null) {
+      bitmapProvider.release(block);
+    }
+  }
+
+  @Override
+  public synchronized void setData(@NonNull GifHeader header, @NonNull byte[] data) {
+    setData(header, ByteBuffer.wrap(data));
+  }
+
+  @Override
+  public synchronized void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer) {
+    setData(header, buffer, 1);
+  }
+
+  @Override
+  public synchronized void setData(@NonNull GifHeader header, @NonNull ByteBuffer buffer,
+      int sampleSize) {
+    if (sampleSize <= 0) {
+      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
+    }
+    // Make sure sample size is a power of 2.
+    sampleSize = Integer.highestOneBit(sampleSize);
+    this.status = STATUS_OK;
+    this.header = header;
+    framePointer = INITIAL_FRAME_POINTER;
+    // Initialize the raw data buffer.
+    rawData = buffer.asReadOnlyBuffer();
+    rawData.position(0);
+    rawData.order(ByteOrder.LITTLE_ENDIAN);
+
+    // No point in specially saving an old frame if we're never going to use it.
+    savePrevious = false;
+    for (GifFrame frame : header.frames) {
+      if (frame.dispose == DISPOSAL_PREVIOUS) {
+        savePrevious = true;
+        break;
+      }
+    }
+
+    this.sampleSize = sampleSize;
+    downsampledWidth = header.width / sampleSize;
+    downsampledHeight = header.height / sampleSize;
+    // Now that we know the size, init scratch arrays.
+    // TODO Find a way to avoid this entirely or at least downsample it (either should be possible).
+    mainPixels = bitmapProvider.obtainByteArray(header.width * header.height);
+    mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);
+  }
+
+  @NonNull
+  private GifHeaderParser getHeaderParser() {
+    if (parser == null) {
+      parser = new GifHeaderParser();
+    }
+    return parser;
+  }
+
+  @Override
+  @GifDecodeStatus
+  public synchronized int read(@Nullable byte[] data) {
+    this.header = getHeaderParser().setData(data).parseHeader();
+    if (data != null) {
+      setData(header, data);
+    }
+
+    return status;
+  }
+
+  @Override
+  public void setDefaultBitmapConfig(@NonNull Bitmap.Config config) {
+    if (config != Bitmap.Config.ARGB_8888 && config != Bitmap.Config.RGB_565) {
+      throw new IllegalArgumentException("Unsupported format: " + config
+          + ", must be one of " + Bitmap.Config.ARGB_8888 + " or " + Bitmap.Config.RGB_565);
+    }
+
+    bitmapConfig = config;
+  }
+
+  /**
+   * Creates new frame image from current data (and previous frames as specified by their
+   * disposition codes).
+   */
+  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
+    // Final location of blended pixels.
+    final int[] dest = mainScratch;
+
+    // clear all pixels when meet first frame and drop prev image from last loop
+    if (previousFrame == null) {
+      if (previousImage != null) {
+        bitmapProvider.release(previousImage);
+      }
+      previousImage = null;
+      Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
+    }
+
+    // clear all pixels when dispose is 3 but previousImage is null.
+    // When DISPOSAL_PREVIOUS and previousImage didn't be set, new frame should draw on
+    // a empty image
+    if (previousFrame != null && previousFrame.dispose == DISPOSAL_PREVIOUS
+            && previousImage == null) {
+      Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
+    }
+
+    // fill in starting image contents based on last image's dispose code
+    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
+      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
+      // mainScratch and therefore so will our dest array.
+      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
+        // Start with a canvas filled with the background color
+        @ColorInt int c = COLOR_TRANSPARENT_BLACK;
+        if (!currentFrame.transparency) {
+          c = header.bgColor;
+          if (currentFrame.lct != null && header.bgIndex == currentFrame.transIndex) {
+            c = COLOR_TRANSPARENT_BLACK;
+          }
+        } else if (framePointer == 0) {
+          // TODO: We should check and see if all individual pixels are replaced. If they are, the
+          // first frame isn't actually transparent. For now, it's simpler and safer to assume
+          // drawing a transparent background means the GIF contains transparency.
+          isFirstFrameTransparent = true;
+        }
+        // The area used by the graphic must be restored to the background color.
+        int downsampledIH = previousFrame.ih / sampleSize;
+        int downsampledIY = previousFrame.iy / sampleSize;
+        int downsampledIW = previousFrame.iw / sampleSize;
+        int downsampledIX = previousFrame.ix / sampleSize;
+        int topLeft = downsampledIY * downsampledWidth + downsampledIX;
+        int bottomLeft = topLeft + downsampledIH * downsampledWidth;
+        for (int left = topLeft; left < bottomLeft; left += downsampledWidth) {
+          int right = left + downsampledIW;
+          for (int pointer = left; pointer < right; pointer++) {
+            dest[pointer] = c;
+          }
+        }
+      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
+        // Start with the previous frame
+        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+            downsampledHeight);
+      }
+    }
+
+    // Decode pixels for this frame into the global pixels[] scratch.
+    decodeBitmapData(currentFrame);
+
+    if (currentFrame.interlace || sampleSize != 1) {
+      copyCopyIntoScratchRobust(currentFrame);
+    } else {
+      copyIntoScratchFast(currentFrame);
+    }
+
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
+
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  private void copyIntoScratchFast(GifFrame currentFrame) {
+    int[] dest = mainScratch;
+    int downsampledIH = currentFrame.ih;
+    int downsampledIY = currentFrame.iy;
+    int downsampledIW = currentFrame.iw;
+    int downsampledIX = currentFrame.ix;
+    // Copy each source line to the appropriate place in the destination.
+    boolean isFirstFrame = framePointer == 0;
+    int width = this.downsampledWidth;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    byte transparentColorIndex = -1;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i + downsampledIY;
+      int k = line * width;
+      // Start of line in dest.
+      int dx = k + downsampledIX;
+      // End of dest line.
+      int dlim = dx + downsampledIW;
+      if (k + width < dlim) {
+        // Past dest edge.
+        dlim = k + width;
+      }
+      // Start of line in source.
+      int sx = i * currentFrame.iw;
+
+      while (dx < dlim) {
+        byte byteCurrentColorIndex = mainPixels[sx];
+        int currentColorIndex = ((int) byteCurrentColorIndex) & MASK_INT_LOWEST_BYTE;
+        if (currentColorIndex != transparentColorIndex) {
+          int color = act[currentColorIndex];
+          if (color != COLOR_TRANSPARENT_BLACK) {
+            dest[dx] = color;
+          } else {
+            transparentColorIndex = byteCurrentColorIndex;
+          }
+        }
+        ++sx;
+        ++dx;
+      }
+    }
+
+    isFirstFrameTransparent =
+        isFirstFrameTransparent == null && isFirstFrame && transparentColorIndex != -1;
+  }
+
+  private void copyCopyIntoScratchRobust(GifFrame currentFrame) {
+    int[] dest = mainScratch;
+    int downsampledIH = currentFrame.ih / sampleSize;
+    int downsampledIY = currentFrame.iy / sampleSize;
+    int downsampledIW = currentFrame.iw / sampleSize;
+    int downsampledIX = currentFrame.ix / sampleSize;
+    // Copy each source line to the appropriate place in the destination.
+    int pass = 1;
+    int inc = 8;
+    int iline = 0;
+    boolean isFirstFrame = framePointer == 0;
+    int sampleSize = this.sampleSize;
+    int downsampledWidth = this.downsampledWidth;
+    int downsampledHeight = this.downsampledHeight;
+    byte[] mainPixels = this.mainPixels;
+    int[] act = this.act;
+    @Nullable
+    Boolean isFirstFrameTransparent = this.isFirstFrameTransparent;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i;
+      if (currentFrame.interlace) {
+        if (iline >= downsampledIH) {
+          pass++;
+          switch (pass) {
+            case 2:
+              iline = 4;
+              break;
+            case 3:
+              iline = 2;
+              inc = 4;
+              break;
+            case 4:
+              iline = 1;
+              inc = 2;
+              break;
+            default:
+              break;
+          }
+        }
+        line = iline;
+        iline += inc;
+      }
+      line += downsampledIY;
+      boolean isNotDownsampling = sampleSize == 1;
+      if (line < downsampledHeight) {
+        int k = line * downsampledWidth;
+        // Start of line in dest.
+        int dx = k + downsampledIX;
+        // End of dest line.
+        int dlim = dx + downsampledIW;
+        if (k + downsampledWidth < dlim) {
+          // Past dest edge.
+          dlim = k + downsampledWidth;
+        }
+        // Start of line in source.
+        int sx = i * sampleSize * currentFrame.iw;
+        if (isNotDownsampling) {
+          int averageColor;
+          while (dx < dlim) {
+            int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;
+            averageColor = act[currentColorIndex];
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (isFirstFrame && isFirstFrameTransparent == null) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
+          }
+        } else {
+          int averageColor;
+          int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+          while (dx < dlim) {
+            // Map color and insert in destination.
+            // TODO: This is substantially slower (up to 50ms per frame) than just grabbing the
+            // current color index above, even with a sample size of 1.
+            averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+            if (averageColor != COLOR_TRANSPARENT_BLACK) {
+              dest[dx] = averageColor;
+            } else if (isFirstFrame && isFirstFrameTransparent == null) {
+              isFirstFrameTransparent = true;
+            }
+            sx += sampleSize;
+            dx++;
+          }
+        }
+      }
+    }
+
+    if (this.isFirstFrameTransparent == null) {
+      this.isFirstFrameTransparent = isFirstFrameTransparent == null
+          ? false : isFirstFrameTransparent;
+    }
+  }
+
+  @ColorInt
+  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
+      int currentFrameIw) {
+    int alphaSum = 0;
+    int redSum = 0;
+    int greenSum = 0;
+    int blueSum = 0;
+
+    int totalAdded = 0;
+    // Find the pixels in the current row.
+    for (int i = positionInMainPixels;
+         i < positionInMainPixels + sampleSize && i < mainPixels.length
+             && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & MASK_INT_LOWEST_BYTE;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & MASK_INT_LOWEST_BYTE;
+        redSum += currentColor >> 16 & MASK_INT_LOWEST_BYTE;
+        greenSum += currentColor >> 8 & MASK_INT_LOWEST_BYTE;
+        blueSum += currentColor & MASK_INT_LOWEST_BYTE;
+        totalAdded++;
+      }
+    }
+    // Find the pixels in the next row.
+    for (int i = positionInMainPixels + currentFrameIw;
+         i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
+             && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & MASK_INT_LOWEST_BYTE;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & MASK_INT_LOWEST_BYTE;
+        redSum += currentColor >> 16 & MASK_INT_LOWEST_BYTE;
+        greenSum += currentColor >> 8 & MASK_INT_LOWEST_BYTE;
+        blueSum += currentColor & MASK_INT_LOWEST_BYTE;
+        totalAdded++;
+      }
+    }
+    if (totalAdded == 0) {
+      return COLOR_TRANSPARENT_BLACK;
+    } else {
+      return ((alphaSum / totalAdded) << 24)
+          | ((redSum / totalAdded) << 16)
+          | ((greenSum / totalAdded) << 8)
+          | (blueSum / totalAdded);
+    }
+  }
+
+  /**
+   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
+   */
+  private void decodeBitmapData(GifFrame frame) {
+    if (frame != null) {
+      // Jump to the frame start position.
+      rawData.position(frame.bufferFrameStart);
+    }
+
+    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
+    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
+        i, datum, dataSize, first, top, bi, pi;
+
+    if (mainPixels == null || mainPixels.length < npix) {
+      // Allocate new pixel array.
+      mainPixels = bitmapProvider.obtainByteArray(npix);
+    }
+    byte[] mainPixels = this.mainPixels;
+    if (prefix == null) {
+      prefix = new short[MAX_STACK_SIZE];
+    }
+    short[] prefix = this.prefix;
+    if (suffix == null) {
+      suffix = new byte[MAX_STACK_SIZE];
+    }
+    byte[] suffix = this.suffix;
+    if (pixelStack == null) {
+      pixelStack = new byte[MAX_STACK_SIZE + 1];
+    }
+    byte[] pixelStack = this.pixelStack;
+
+    // Initialize GIF data stream decoder.
+    dataSize = readByte();
+    clear = 1 << dataSize;
+    endOfInformation = clear + 1;
+    available = clear + 2;
+    oldCode = NULL_CODE;
+    codeSize = dataSize + 1;
+    codeMask = (1 << codeSize) - 1;
+
+    for (code = 0; code < clear; code++) {
+      // XXX ArrayIndexOutOfBoundsException.
+      prefix[code] = 0;
+      suffix[code] = (byte) code;
+    }
+    byte[] block = this.block;
+    // Decode GIF pixel stream.
+    i = datum = bits = count = first = top = pi = bi = 0;
+    while (i < npix) {
+      // Read a new data block.
+      if (count == 0) {
+        count = readBlock();
+        if (count <= 0) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
+        }
+        bi = 0;
+      }
+
+      datum += (((int) block[bi]) & MASK_INT_LOWEST_BYTE) << bits;
+      bits += 8;
+      ++bi;
+      --count;
+
+      while (bits >= codeSize) {
+        // Get the next code.
+        code = datum & codeMask;
+        datum >>= codeSize;
+        bits -= codeSize;
+
+        // Interpret the code.
+        if (code == clear) {
+          // Reset decoder.
+          codeSize = dataSize + 1;
+          codeMask = (1 << codeSize) - 1;
+          available = clear + 2;
+          oldCode = NULL_CODE;
+          continue;
+        } else if (code == endOfInformation) {
+          break;
+        } else if (oldCode == NULL_CODE) {
+          pixelStack[top] = suffix[code];
+          ++top;
+          oldCode = code;
+          first = code;
+          continue;
+        }
+
+        inCode = code;
+        if (code >= available) {
+          pixelStack[top] = (byte) first;
+          ++top;
+          code = oldCode;
+        }
+
+        while (code >= clear) {
+          pixelStack[top] = suffix[code];
+          ++top;
+          code = prefix[code];
+        }
+        first = ((int) suffix[code]) & MASK_INT_LOWEST_BYTE;
+
+        mainPixels[pi] = (byte) first;
+        ++pi;
+        ++i;
+
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi] = pixelStack[--top];
+          ++pi;
+          ++i;
+        }
+
+        // Add a new string to the string table.
+        if (available < MAX_STACK_SIZE) {
+          prefix[available] = (short) oldCode;
+          suffix[available] = (byte) first;
+          ++available;
+          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
+            ++codeSize;
+            codeMask += available;
+          }
+        }
+        oldCode = inCode;
+      }
+    }
+
+    // Clear missing pixels.
+    Arrays.fill(mainPixels, pi, npix, (byte) COLOR_TRANSPARENT_BLACK);
+  }
+
+  /**
+   * Reads a single byte from the input stream.
+   */
+  private int readByte() {
+    return rawData.get() & MASK_INT_LOWEST_BYTE;
+  }
+
+  /**
+   * Reads next variable length block from input.
+   *
+   * @return number of bytes stored in "buffer".
+   */
+  private int readBlock() {
+    int blockSize = readByte();
+    if (blockSize <= 0) {
+      return blockSize;
+    }
+    rawData.get(block, 0, Math.min(blockSize, rawData.remaining()));
+    return blockSize;
+  }
+
+  private Bitmap getNextBitmap() {
+    Bitmap.Config config = isFirstFrameTransparent == null || isFirstFrameTransparent
+        ? Bitmap.Config.ARGB_8888 : bitmapConfig;
+    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
+    result.setHasAlpha(true);
+    return result;
+  }
+}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 9566e4c32..cc25027e0 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -2,20 +2,23 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.robolectric.Shadows.shadowOf;
 
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.testutil.TestUtil;
-
+import java.io.IOException;
+import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-
-import java.io.IOException;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
 
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
@@ -37,7 +40,7 @@ public void testCanDecodeFramesFromTestGif() throws IOException {
     GifHeaderParser headerParser = new GifHeaderParser();
     headerParser.setData(data);
     GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(header, data);
     decoder.advance();
     Bitmap bitmap = decoder.getNextFrame();
@@ -50,17 +53,47 @@ public void testFrameIndexStartsAtNegativeOne() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
 
+  @Test
+  public void testTotalIterationCountIsOneIfNetscapeLoopCountDoesntExist() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(1, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsForeverIfNetscapeLoopCountIsForever() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_FOREVER;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsTwoIfNetscapeLoopCountIsOne() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = 1;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(2, decoder.getTotalIterationCount());
+  }
+
   @Test
   public void testAdvanceIncrementsFrameIndex() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     assertEquals(0, decoder.getCurrentFrameIndex());
@@ -71,7 +104,7 @@ public void testAdvanceWrapsIndexBackToZero() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 2;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -84,7 +117,7 @@ public void testSettingDataResetsFramePointer() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -94,6 +127,65 @@ public void testSettingDataResetsFramePointer() {
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
 
+  @Test
+  @Config(shadows = {CustomShadowBitmap.class})
+  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalBackground()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_background.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap firstFrame = decoder.getNextFrame();
+    decoder.advance();
+    decoder.getNextFrame();
+    decoder.advance();
+    Bitmap firstFrameTwice = decoder.getNextFrame();
+    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
+        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
+  }
+
+  @Test
+  @Config(shadows = {CustomShadowBitmap.class})
+  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalNone() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_none.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap firstFrame = decoder.getNextFrame();
+    decoder.advance();
+    decoder.getNextFrame();
+    decoder.advance();
+    Bitmap firstFrameTwice = decoder.getNextFrame();
+    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
+        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
+  }
+
+  /**
+   * Preserve generated bitmap data for checking.
+   */
+  @Implements(Bitmap.class)
+  public static class CustomShadowBitmap extends ShadowBitmap {
+
+    private int[] pixels;
+
+    @Implementation
+    public void setPixels(int[] pixels, int offset, int stride,
+        int x, int y, int width, int height) {
+      this.pixels = new int[pixels.length];
+      System.arraycopy(pixels, 0, this.pixels, 0, this.pixels.length);
+    }
+
+    public int[] getPixels() {
+      return pixels;
+    }
+  }
+
   private static class MockProvider implements GifDecoder.BitmapProvider {
 
     @NonNull
@@ -105,19 +197,31 @@ public Bitmap obtain(int width, int height, Bitmap.Config config) {
     }
 
     @Override
-    public void release(Bitmap bitmap) {
+    public void release(@NonNull Bitmap bitmap) {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public byte[] obtainByteArray(int size) {
       return new byte[size];
     }
 
     @Override
-    public void release(byte[] bytes) {
+    public void release(@NonNull byte[] bytes) {
       // Do nothing.
     }
 
+    @NonNull
+    @Override
+    public int[] obtainIntArray(int size) {
+      return new int[size];
+    }
+
+    @Override
+    public void release(@NonNull int[] array) {
+      // Do Nothing
+    }
+
   }
 }
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index fa14b3870..8fc2efa9e 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -4,19 +4,18 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;
 import com.bumptech.glide.testutil.TestUtil;
-
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.GifHeaderParser}.
  */
@@ -66,12 +65,64 @@ public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOEx
     assertEquals(GifDecoder.STATUS_OK, header.status);
   }
 
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIsZero() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_0.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_FOREVER, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_1() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_1.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(1, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x0F()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_255.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(255, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x10()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_256.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(256, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0xFF()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_65535.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(65535, header.loopCount);
+  }
+
+  @Test
+  public void testLoopCountReturnsMinusOneWithoutNetscapeIterationCount()
+          throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_without_netscape_iteration.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST, header.loopCount);
+  }
+
   @Test
   public void testCanReadImageDescriptorWithoutGraphicalExtension() {
     final int lzwMinCodeSize = 2;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
     GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
@@ -89,7 +140,7 @@ private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH
             + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
@@ -153,7 +204,7 @@ public void testSetsFrameLocalColorTableToNullIfNoColorTable() {
     final int lzwMinCodeSize = 2;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
+            .getImageDataSize()).order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
     GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
@@ -173,7 +224,7 @@ public void testSetsFrameLocalColorTableIfHasColorTable() {
     final int numColors = 4;
     ByteBuffer buffer = ByteBuffer.allocate(
         GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize) + GifBytesTestUtil.getColorTableLength(numColors))
+            .getImageDataSize() + GifBytesTestUtil.getColorTableLength(numColors))
         .order(ByteOrder.LITTLE_ENDIAN);
     GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
     GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, true /*hasLct*/, numColors);
@@ -197,7 +248,7 @@ public void testCanParseMultipleFrames() {
     final int expectedFrames = 3;
 
     final int frameSize = GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-        .getImageDataSize(lzwMinCodeSize);
+        .getImageDataSize();
     ByteBuffer buffer =
         ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + expectedFrames * frameSize)
             .order(ByteOrder.LITTLE_ENDIAN);
@@ -214,6 +265,49 @@ public void testCanParseMultipleFrames() {
     assertEquals(expectedFrames, header.frames.size());
   }
 
+  @Test
+  public void testIsAnimatedMultipleFrames() {
+    final int lzwMinCodeSize = 2;
+    final int numFrames = 3;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize();
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    for (int i = 0; i < numFrames; i++) {
+      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+      GifBytesTestUtil.writeFakeImageData(buffer, 2);
+    }
+
+    parser.setData(buffer.array());
+    assertTrue(parser.isAnimated());
+  }
+
+  @Test
+  public void testIsNotAnimatedOneFrame() {
+    final int lzwMinCodeSize = 2;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize();
+
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+    GifBytesTestUtil.writeFakeImageData(buffer, 2);
+
+    parser.setData(buffer.array());
+    assertFalse(parser.isAnimated());
+  }
+
+
   @Test(expected = IllegalStateException.class)
   public void testThrowsIfParseHeaderCalledBeforeSetData() {
     GifHeaderParser parser = new GifHeaderParser();
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
index 7a32733a6..4752afc3c 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
@@ -17,7 +17,7 @@ public static int getColorTableLength(int numColors) {
     return 3 * numColors;
   }
 
-  public static int getImageDataSize(int lzwMinCodeSize) {
+  public static int getImageDataSize() {
     // TODO: fill this out.
     return 4;
   }
@@ -78,7 +78,7 @@ public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, bool
     // Version - 89a.
     out.put((byte) 0x38).put((byte) 0x39).put((byte) 0x61);
 
-    /** LSD (Logical Screen Descriptor) **/
+    /* LSD (Logical Screen Descriptor) **/
     // Width.
     out.putShort((short) width);
     // Height.
@@ -89,7 +89,7 @@ public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, bool
     // Color resolution - next three bits.
     byte colorResolution = 1 << 5;
     // Sort flag - next bit;
-    byte sortFlag = 0 << 4;
+    byte sortFlag = 0;
     // exponent of size of color table, size = 2^(1 + exponent) - least significant 3 bits.
     byte size = (byte) gctSize;
 
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
index 680f49d09..f09e8596e 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
@@ -2,13 +2,12 @@
 
 import static org.junit.Assert.assertArrayEquals;
 
+import java.nio.ByteBuffer;
+import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.test.GifBytesTestUtil}.
  */
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif
new file mode 100644
index 000000000..3dd7c1cb6
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif
new file mode 100644
index 000000000..480dc8c64
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif
new file mode 100644
index 000000000..62a489ea2
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif
new file mode 100644
index 000000000..c0443cd42
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif
new file mode 100644
index 000000000..b976157c3
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif
new file mode 100644
index 000000000..f67b1b6bf
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif b/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif
new file mode 100644
index 000000000..3c64b1d65
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif b/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif
new file mode 100644
index 000000000..158e329ba
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif differ
diff --git a/third_party/gif_encoder/README.third_party b/third_party/gif_encoder/README.third_party
index 981a8a04d..40fafebcb 100644
--- a/third_party/gif_encoder/README.third_party
+++ b/third_party/gif_encoder/README.third_party
@@ -4,7 +4,7 @@ License: Notice
 License File: LICENSE
 
 Description:
-Android port of a gif encoder.
+Android port of a GIF encoder.
 
 See also:
 http://members.ozemail.com.au/~dekker/NEUQUANT.HTML
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index aa1123f67..f05bd08b8 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -4,8 +4,9 @@
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
-
 import java.io.BufferedOutputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -22,6 +23,7 @@
  *     e.setDelay(1000);   // 1 frame per sec
  *     e.addFrame(image1);
  *     e.addFrame(image2);
+ *     e.addFrame(image3, 100, 100);    // set position of the frame
  *     e.finish();
  * </pre>
  *
@@ -38,13 +40,18 @@
 public class AnimatedGifEncoder {
     private static final String TAG = "AnimatedGifEncoder";
 
-    // The minimum % of an images pixels that must be transparent for us to set a transparent index automatically.
+    // The minimum % of an images pixels that must be transparent for us to set a transparent index
+    // automatically.
     private static final double MIN_TRANSPARENT_PERCENTAGE = 4d;
 
     private int width; // image size
 
     private int height;
 
+    private int fixedWidth;   // set by setSize()
+
+    private int fixedHeight;
+
     private Integer transparent = null; // transparent color if given
 
     private int transIndex; // transparent index in color table
@@ -140,28 +147,52 @@ public void setTransparent(int color) {
      * Adds next GIF frame. The frame is not written immediately, but is actually
      * deferred until the next frame is received so that timing data can be
      * inserted. Invoking <code>finish()</code> flushes all frames. If
-     * <code>setSize</code> was not invoked, the size of the first image is used
-     * for all subsequent frames.
+     * <code>setSize</code> was invoked, the size is used for all subsequent frames.
+     * Otherwise, the actual size of the image is used for each frames.
      *
      * @param im
      *          BufferedImage containing frame to write.
      * @return true if successful.
      */
-    public boolean addFrame(Bitmap im) {
+    public boolean addFrame(@Nullable Bitmap im) {
+        return addFrame(im, 0, 0);
+    }
+
+    /**
+     * Adds next GIF frame to the specified position. The frame is not written immediately, but is
+     * actually deferred until the next frame is received so that timing data can be inserted.
+     * Invoking <code>finish()</code> flushes all frames. If <code>setSize</code> was invoked, the
+     * size is used for all subsequent frames. Otherwise, the actual size of the image is used for
+     * each frame.
+     *
+     * See page 11 of http://giflib.sourceforge.net/gif89.txt for the position of the frame
+     *
+     * @param im
+     *          BufferedImage containing frame to write.
+     * @param x
+     *          Column number, in pixels, of the left edge of the image, with respect to the left
+     *          edge of the Logical Screen.
+     * @param y
+     *          Row number, in pixels, of the top edge of the image with respect to the top edge of
+     *          the Logical Screen.
+     * @return true if successful.
+     */
+    public boolean addFrame(@Nullable Bitmap im, int x, int y) {
         if ((im == null) || !started) {
             return false;
         }
         boolean ok = true;
         try {
-            if (!sizeSet) {
-                // use first frame's size
-                setSize(im.getWidth(), im.getHeight());
+            if (sizeSet) {
+                setFrameSize(fixedWidth, fixedHeight);
+            } else {
+                setFrameSize(im.getWidth(), im.getHeight());
             }
             image = im;
             getImagePixels(); // convert to correct format if necessary
             analyzePixels(); // build color table & map pixels
             if (firstFrame) {
-                writeLSD(); // logical screen descriptior
+                writeLSD(); // logical screen descriptor
                 writePalette(); // global color table
                 if (repeat >= 0) {
                     // use NS app extension to indicate reps
@@ -169,7 +200,7 @@ public boolean addFrame(Bitmap im) {
                 }
             }
             writeGraphicCtrlExt(); // write graphic control extension
-            writeImageDesc(); // image descriptor
+            writeImageDesc(x, y); // image descriptor
             if (!firstFrame) {
                 writePalette(); // local color table
             }
@@ -192,7 +223,7 @@ public boolean finish() {
         boolean ok = true;
         started = false;
         try {
-            out.write(0x3b); // gif trailer
+            out.write(0x3b); // GIF trailer
             out.flush();
             if (closeStream) {
                 out.close();
@@ -243,8 +274,8 @@ public void setQuality(int quality) {
     }
 
     /**
-     * Sets the GIF frame size. The default size is the size of the first frame
-     * added if this method is not invoked.
+     * Sets the fixed GIF frame size for all the frames.
+     * This should be called before start.
      *
      * @param w
      *          int frame width.
@@ -252,15 +283,33 @@ public void setQuality(int quality) {
      *          int frame width.
      */
     public void setSize(int w, int h) {
-        if (started && !firstFrame)
+        if (started) {
             return;
+        }
+
+        fixedWidth = w;
+        fixedHeight = h;
+        if (fixedWidth < 1) {
+            fixedWidth = 320;
+        }
+        if (fixedHeight < 1) {
+            fixedHeight = 240;
+        }
+
+        sizeSet = true;
+    }
+
+    /**
+     * Sets current GIF frame size.
+     *
+     * @param w
+     *          int frame width.
+     * @param h
+     *          int frame width.
+     */
+    private void setFrameSize(int w, int h) {
         width = w;
         height = h;
-        if (width < 1)
-            width = 320;
-        if (height < 1)
-            height = 240;
-        sizeSet = true;
     }
 
     /**
@@ -271,7 +320,7 @@ public void setSize(int w, int h) {
      *          OutputStream on which GIF images are written.
      * @return false if initial write failed.
      */
-    public boolean start(OutputStream os) {
+    public boolean start(@Nullable OutputStream os) {
         if (os == null)
             return false;
         boolean ok = true;
@@ -292,8 +341,8 @@ public boolean start(OutputStream os) {
      *          String containing output file name.
      * @return false if open or initial write failed.
      */
-    public boolean start(String file) {
-        boolean ok = true;
+    public boolean start(@NonNull String file) {
+        boolean ok;
         try {
             out = new BufferedOutputStream(new FileOutputStream(file));
             ok = start(out);
@@ -400,11 +449,12 @@ private void getImagePixels() {
         }
 
         double transparentPercentage = 100 * totalTransparentPixels / (double) pixelsInt.length;
-        // Assume images with greater where more than n% of the pixels are transparent actually have transparency.
-        // See issue #214.
+        // Assume images with greater where more than n% of the pixels are transparent actually have
+        // transparency. See issue #214.
         hasTransparentPixels = transparentPercentage > MIN_TRANSPARENT_PERCENTAGE;
         if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "got pixels for frame with " + transparentPercentage + "% transparent pixels");
+            Log.d(TAG, "got pixels for frame with " + transparentPercentage
+                + "% transparent pixels");
         }
     }
 
@@ -442,10 +492,10 @@ private void writeGraphicCtrlExt() throws IOException {
     /**
      * Writes Image Descriptor
      */
-    private void writeImageDesc() throws IOException {
+    private void writeImageDesc(int x, int y) throws IOException {
         out.write(0x2c); // image separator
-        writeShort(0); // image position x,y = 0,0
-        writeShort(0);
+        writeShort(x); // image position
+        writeShort(y);
         writeShort(width); // image size
         writeShort(height);
         // packed fields
diff --git a/third_party/gradle.properties b/third_party/gradle.properties
new file mode 100644
index 000000000..d01cfd2be
--- /dev/null
+++ b/third_party/gradle.properties
@@ -0,0 +1,3 @@
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-thirdparty
