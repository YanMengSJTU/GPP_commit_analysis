diff --git a/build.gradle b/build.gradle
index d9423ea2d..c689d6105 100644
--- a/build.gradle
+++ b/build.gradle
@@ -67,7 +67,16 @@ subprojects { project ->
                  * See https://github.com/google/dagger/issues/945
                  * and https://bugs.openjdk.java.net/browse/JDK-8190452
                  */ \
-                << "-Xlint:-classfile"
+                << "-Xlint:-classfile" \
+                /*
+                 * Disable deprecation warnings for ViewTarget/BaseTarget for now.
+                 */ \
+                << "-Xlint:-deprecation"
+
+            if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
+                // It's often useful to track individual objects when debugging object pooling.
+                options.compilerArgs << "-Xep:ObjectToString:OFF"
+            }
         }
     }
 
diff --git a/gradle.properties b/gradle.properties
index 3b2e684c4..ff68f1306 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 org.gradle.daemon=true
-org.gradle.configureondemand=true
+org.gradle.configureondemand=false
 
 VERSION_NAME=4.8.0-SNAPSHOT
 VERSION_MAJOR=4
@@ -16,15 +16,16 @@ POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
 ANDROID_SUPPORT_VERSION=27.1.1
+ANDROIDX_TEST_VERSION=1.1.0-alpha4
 VOLLEY_VERSION=1.0.0
 OK_HTTP_VERSION=3.9.1
-ANDROID_GRADLE_VERSION=3.0.1
+ANDROID_GRADLE_VERSION=3.1.3
 DAGGER_VERSION=2.11
 
 JUNIT_VERSION=4.13-SNAPSHOT
 # Matches the version in Google.
 MOCKITO_VERSION=1.9.5
-MOCKITO_ANDROID_VERSION=2.11.0
+MOCKITO_ANDROID_VERSION=2.21.0
 ROBOLECTRIC_VERSION=3.6.1
 MOCKWEBSERVER_VERSION=3.0.0-RC1
 TRUTH_VERSION=0.36
@@ -34,7 +35,7 @@ JAVAPOET_VERSION=1.9.0
 
 PMD_VERSION=6.0.0
 FINDBUGS_VERSION=3.0.0
-ERROR_PRONE_VERSION=2.1.4-SNAPSHOT
+ERROR_PRONE_VERSION=2.3.1
 ERROR_PRONE_PLUGIN_VERSION=0.0.13
 VIOLATIONS_PLUGIN_VERSION=1.8
 
diff --git a/instrumentation/build.gradle b/instrumentation/build.gradle
index c9ab489a7..84c4dc6f2 100644
--- a/instrumentation/build.gradle
+++ b/instrumentation/build.gradle
@@ -19,14 +19,13 @@ dependencies {
     androidTestImplementation "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}"
     androidTestImplementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
     androidTestImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
-    androidTestImplementation 'com.android.support.test:runner:1.0.1'
-    androidTestImplementation 'com.android.support.test:rules:1.0.1'
+    androidTestImplementation "androidx.test:runner:${ANDROIDX_TEST_VERSION}"
+    androidTestImplementation "androidx.test:rules:${ANDROIDX_TEST_VERSION}"
     androidTestImplementation "com.google.truth:truth:${TRUTH_VERSION}"
     androidTestImplementation "junit:junit:${JUNIT_VERSION}"
     // Not totally clear why this is required, but it seems to be missing when tests are run on
     // 4.1.2 and 4.2.0 emulators.
     androidTestImplementation 'com.google.code.findbugs:jsr305:3.0.2'
-
 }
 
 android {
@@ -38,7 +37,7 @@ android {
         targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
         versionName '1.0'
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
     }
 
     compileOptions {
diff --git a/instrumentation/src/androidTest/java/android/support/test/InstrumentationRegistry.java b/instrumentation/src/androidTest/java/android/support/test/InstrumentationRegistry.java
new file mode 100644
index 000000000..0b988917e
--- /dev/null
+++ b/instrumentation/src/androidTest/java/android/support/test/InstrumentationRegistry.java
@@ -0,0 +1,10 @@
+package android.support.test;
+
+import android.content.Context;
+
+// Workaround for https://github.com/mockito/mockito/issues/1472.
+public final class InstrumentationRegistry {
+  public static Context getTargetContext() {
+    return androidx.test.InstrumentationRegistry.getTargetContext();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
index 920e9635b..fdc9d34cd 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
@@ -8,8 +8,8 @@
 import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
 import android.net.Uri;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.test.ConcurrencyHelper;
 import com.bumptech.glide.test.GlideApp;
 import com.bumptech.glide.test.ResourceIds;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
index 6a47f43b5..364ef5150 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java
@@ -5,8 +5,8 @@
 import static org.junit.Assert.fail;
 
 import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.test.ConcurrencyHelper;
 import com.bumptech.glide.test.GlideApp;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
index 194d5afbf..cd2ef820f 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -17,10 +17,10 @@
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.os.Looper;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
 import android.view.ViewGroup.LayoutParams;
 import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
index 17e397879..b98962c90 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java
@@ -4,8 +4,8 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.test.BitmapRegressionTester;
 import com.bumptech.glide.test.CanonicalBitmap;
 import com.bumptech.glide.test.GlideApp;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
index 9f8947a90..0f9d5727f 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java
@@ -4,8 +4,8 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.test.BitmapRegressionTester;
 import com.bumptech.glide.test.CanonicalBitmap;
 import com.bumptech.glide.test.GlideApp;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
index 9d52425d6..a2df666d1 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java
@@ -4,8 +4,8 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.test.BitmapRegressionTester;
 import com.bumptech.glide.test.CanonicalBitmap;
 import com.bumptech.glide.test.GlideApp;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
index 87ae694a7..014d0942b 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java
@@ -8,10 +8,10 @@
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
 import android.support.v4.content.ContextCompat;
 import android.util.Base64;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.test.ConcurrencyHelper;
 import com.bumptech.glide.test.ResourceIds;
 import com.bumptech.glide.test.TearDownGlide;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
index 0035a04a6..d84b55ac8 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java
@@ -6,8 +6,8 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Build;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.test.ConcurrencyHelper;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
index c71ba9e34..033aecfec 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java
@@ -13,8 +13,8 @@
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.TransformationUtils;
 import com.bumptech.glide.request.RequestOptions;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
index 2e4898227..2e6dcbb74 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java
@@ -13,8 +13,8 @@
 import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
index bdda5fed0..5945ef428 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java
@@ -5,8 +5,8 @@
 
 import android.content.Context;
 import android.graphics.drawable.Drawable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.DiskCache.Factory;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
index d4f749822..b2f7a4aa4 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java
@@ -5,8 +5,8 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.test.BitmapRegressionTester;
 import com.bumptech.glide.test.CanonicalBitmap;
 import com.bumptech.glide.test.GlideApp;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
index 4e9ff73da..7365aa0c5 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
@@ -15,8 +15,8 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.drawable.Drawable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
index b6abc374d..db3802c31 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
@@ -17,10 +17,10 @@
 import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
 import android.widget.AbsListView.LayoutParams;
 import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
index de411130c..f1290ef9e 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
@@ -13,8 +13,8 @@
 import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
index 3512c382e..38ef87b5c 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadResourcesWithDownsamplerTest.java
@@ -13,8 +13,8 @@
 import android.os.Build;
 import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Options;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
index d99570490..6a559af37 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
@@ -8,8 +8,8 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.test.ConcurrencyHelper;
 import com.bumptech.glide.test.GlideApp;
 import com.bumptech.glide.test.ResourceIds;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
index 96c983ae0..3a57f5293 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
@@ -16,8 +16,8 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
 import com.bumptech.glide.test.ResourceIds;
 import com.bumptech.glide.test.TearDownGlide;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
index 493bf7292..a87d44a81 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java
@@ -5,8 +5,8 @@
 import android.content.Context;
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
-import android.support.test.InstrumentationRegistry;
 import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
 import com.bumptech.glide.test.ConcurrencyHelper;
 import com.bumptech.glide.test.GlideApp;
 import com.bumptech.glide.test.GlideRequests;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
index 2019c1758..5a9167a85 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java
@@ -3,9 +3,9 @@
 import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
 import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.manager.Lifecycle;
 import com.bumptech.glide.manager.LifecycleListener;
 import com.bumptech.glide.manager.RequestManagerTreeNode;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
index c89ea575c..91e1c14b2 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -11,9 +11,9 @@
 
 import android.content.Context;
 import android.graphics.drawable.Drawable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
 import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.RequestListener;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
index 0b9404aed..3e59c4b22 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RoundedCornersRegressionTest.java
@@ -6,8 +6,8 @@
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.resource.bitmap.RoundedCorners;
 import com.bumptech.glide.test.BitmapRegressionTester;
 import com.bumptech.glide.test.CanonicalBitmap;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
index aeaaa61ec..c1b532f3a 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java
@@ -10,8 +10,8 @@
 import android.graphics.ColorSpace;
 import android.graphics.ColorSpace.Named;
 import android.os.Build;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
index 764032c3f..bdc7fa0fd 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
@@ -18,8 +18,8 @@
 import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.support.annotation.Nullable;
-import android.support.test.runner.AndroidJUnit4;
 import android.util.DisplayMetrics;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index 57c48916e..9d5bddd32 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -5,13 +5,13 @@
 import android.Manifest.permission;
 import android.content.Context;
 import android.os.Build;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.rule.GrantPermissionRule;
-import android.support.test.runner.AndroidJUnit4;
 import android.view.View;
 import android.view.WindowManager;
 import android.view.WindowManager.LayoutParams;
 import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.rule.GrantPermissionRule;
+import androidx.test.runner.AndroidJUnit4;
 import com.bumptech.glide.load.resource.gif.GifDrawable.GifState;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.OnEveryFrameListener;
 import com.bumptech.glide.request.target.Target;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
index f0510cca1..fa8a62338 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapRegressionTester.java
@@ -7,7 +7,7 @@
 import android.os.Build;
 import android.os.Environment;
 import android.support.annotation.Nullable;
-import android.support.test.InstrumentationRegistry;
+import androidx.test.InstrumentationRegistry;
 import com.bumptech.glide.RequestBuilder;
 import java.io.BufferedOutputStream;
 import java.io.File;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
index 050dee021..cdacb09bd 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java
@@ -6,8 +6,8 @@
 import android.graphics.drawable.Drawable;
 import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
-import android.support.test.InstrumentationRegistry;
 import android.support.v4.content.res.ResourcesCompat;
+import androidx.test.InstrumentationRegistry;
 import com.google.common.truth.FailureMetadata;
 import com.google.common.truth.Subject;
 import com.google.common.truth.Truth;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
index e71aadaf0..d990cf4f8 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java
@@ -5,7 +5,7 @@
 import android.graphics.BitmapFactory;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.test.InstrumentationRegistry;
+import androidx.test.InstrumentationRegistry;
 import com.bumptech.glide.util.Preconditions;
 
 public final class CanonicalBitmap {
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
index edca18631..20888d70a 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -6,8 +6,8 @@
 import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.test.InstrumentationRegistry;
 import android.widget.ImageView;
+import androidx.test.InstrumentationRegistry;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.request.FutureTarget;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
index c1f14110d..2726152f6 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/MockModelLoader.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 import android.support.annotation.NonNull;
-import android.support.test.InstrumentationRegistry;
+import androidx.test.InstrumentationRegistry;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
index d751f0f07..8a6b15ce4 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 import android.content.res.Resources;
-import android.support.test.InstrumentationRegistry;
+import androidx.test.InstrumentationRegistry;
 
 /**
  * Internally in google we don't appear to be able to reference resource ids directly, this class is
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
index a99644ddb..61263c353 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.test;
 
-import android.support.test.InstrumentationRegistry;
+import androidx.test.InstrumentationRegistry;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import org.junit.rules.TestRule;
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
index 2c89c9227..e702b7fc5 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
@@ -2,7 +2,7 @@
 
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.test.InstrumentationRegistry;
+import androidx.test.InstrumentationRegistry;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
diff --git a/library/build.gradle b/library/build.gradle
index a47b7173b..6f01832e2 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -18,6 +18,16 @@ dependencies {
     if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
         errorprone "com.google.errorprone:error_prone_core:${ERROR_PRONE_VERSION}"
     }
+
+    testImplementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    testImplementation project(':testutil')
+    testImplementation 'com.google.guava:guava-testlib:18.0'
+    testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
+    testImplementation "junit:junit:${JUNIT_VERSION}"
+    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}"
+    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
+    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 2e0f06b5f..705db20aa 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -1,5 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest package="com.bumptech.glide">
-
-    <application/>
+  <application/>
 </manifest>
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index ef11d7a21..1efe114f8 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -66,15 +66,23 @@ private ModelLoaderRegistry(@NonNull MultiModelLoaderFactory multiModelLoaderFac
     }
   }
 
+  // We're allocating in a loop to avoid allocating empty lists that will never have anything added
+  // to them.
+  @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
   @NonNull
-  public synchronized <A> List<ModelLoader<A, ?>> getModelLoaders(@NonNull A model) {
+  public <A> List<ModelLoader<A, ?>> getModelLoaders(@NonNull A model) {
     List<ModelLoader<A, ?>> modelLoaders = getModelLoadersForClass(getClass(model));
     int size = modelLoaders.size();
-    List<ModelLoader<A, ?>> filteredLoaders = new ArrayList<>(size);
+    boolean isEmpty = true;
+    List<ModelLoader<A, ?>> filteredLoaders = Collections.emptyList();
     //noinspection ForLoopReplaceableByForEach to improve perf
     for (int i = 0; i < size; i++) {
       ModelLoader<A, ?> loader = modelLoaders.get(i);
       if (loader.handles(model)) {
+        if (isEmpty) {
+          filteredLoaders = new ArrayList<>(size - i);
+          isEmpty = false;
+        }
         filteredLoaders.add(loader);
       }
     }
@@ -92,7 +100,8 @@ private ModelLoaderRegistry(@NonNull MultiModelLoaderFactory multiModelLoaderFac
   }
 
   @NonNull
-  private <A> List<ModelLoader<A, ?>> getModelLoadersForClass(@NonNull Class<A> modelClass) {
+  private synchronized <A> List<ModelLoader<A, ?>> getModelLoadersForClass(
+      @NonNull Class<A> modelClass) {
     List<ModelLoader<A, ?>> loaders = cache.get(modelClass);
     if (loaders == null) {
       loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
index 792de64a3..026a3233f 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
@@ -8,16 +8,23 @@
  * A base {@link Target} for loading {@link com.bumptech.glide.load.engine.Resource}s that provides
  * basic or empty implementations for most methods.
  *
- * <p> For maximum efficiency, clear this target when you have finished using or displaying the
- * {@link com.bumptech.glide.load.engine.Resource} loaded into it using
- * {@link com.bumptech.glide.RequestManager#clear(Target)}.</p>
+ * <p>For maximum efficiency, clear this target when you have finished using or displaying the
+ * {@link com.bumptech.glide.load.engine.Resource} loaded into it using {@link
+ * com.bumptech.glide.RequestManager#clear(Target)}.
  *
- * <p> For loading {@link com.bumptech.glide.load.engine.Resource}s into {@link android.view.View}s,
- * {@link com.bumptech.glide.request.target.ViewTarget} or
- * {@link com.bumptech.glide.request.target.ImageViewTarget} are preferable.</p>
+ * <p>For loading {@link com.bumptech.glide.load.engine.Resource}s into {@link android.view.View}s,
+ * {@link com.bumptech.glide.request.target.ViewTarget} or {@link
+ * com.bumptech.glide.request.target.ImageViewTarget} are preferable.
  *
  * @param <Z> The type of resource that will be received by this target.
+ * @deprecated Use {@link CustomViewTarget} if loading the content into a view, the download API if
+ *     in the background
+ *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a a fully
+ *     implemented {@link Target} for any specialized use-cases. Using BaseView is unsafe if the
+ *     user does not implement {@link #onLoadCleared}, resulting in recycled bitmaps being
+ *     referenced from the UI and hard to root-cause crashes.
  */
+@Deprecated
 public abstract class BaseTarget<Z> implements Target<Z> {
 
   private Request request;
diff --git a/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java
new file mode 100644
index 000000000..77f69eb4a
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java
@@ -0,0 +1,495 @@
+package com.bumptech.glide.request.target;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.IdRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import android.util.Log;
+import android.view.Display;
+import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
+import android.view.ViewGroup.LayoutParams;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+import com.bumptech.glide.R;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A base {@link Target} for loading {@link android.graphics.Bitmap}s into {@link View}s that
+ * provides default implementations for most methods and can determine the size of views using a
+ * {@link android.view.ViewTreeObserver.OnDrawListener}.
+ *
+ * @param <T> The specific subclass of view wrapped by this target.
+ * @param <Z> The resource type this target will receive.
+ */
+public abstract class CustomViewTarget<T extends View, Z> implements Target<Z> {
+  private static final String TAG = "CustomViewTarget";
+  @IdRes private static final int VIEW_TAG_ID =
+      R.id.glide_custom_view_target_tag;
+
+  private final SizeDeterminer sizeDeterminer;
+
+  protected final T view;
+  @Nullable private OnAttachStateChangeListener attachStateListener;
+  private boolean isClearedByUs;
+  private boolean isAttachStateListenerAdded;
+  @IdRes private int overrideTag;
+
+  /** Constructor that defaults {@code waitForLayout} to {@code false}. */
+  public CustomViewTarget(@NonNull T view) {
+    this.view = Preconditions.checkNotNull(view);
+    sizeDeterminer = new SizeDeterminer(view);
+  }
+
+  /**
+   * A required callback invoked when the resource is no longer valid and must be freed.
+   *
+   * <p>You must ensure that any current Drawable received in
+   * {@link #onResourceReady(Object, Transition)} is no longer used before redrawing the container
+   * (usually a View) or changing its visibility. <b>Not doing so will result in crashes in your
+   * app.</b>
+   *
+   * @param placeholder The placeholder drawable to optionally show, or null.
+   */
+  protected abstract void onResourceCleared(@Nullable Drawable placeholder);
+
+  /**
+   * An optional callback invoked when a resource load is started.
+   *
+   * @see Target#onLoadStarted(Drawable)
+   * @param placeholder The placeholder drawable to optionally show, or null.
+   */
+  protected void onResourceLoading(@Nullable Drawable placeholder) {
+    // Default empty.
+  }
+
+  @Override
+  public void onStart() {
+    // Default empty.
+  }
+
+  @Override
+  public void onStop() {
+    // Default empty.
+  }
+
+  @Override
+  public void onDestroy() {
+    // Default empty.
+  }
+
+  /**
+   * Indicates that Glide should always wait for any pending layout pass before checking for the
+   * size an {@link View}.
+   *
+   * <p>By default, Glide will only wait for a pending layout pass if it's unable to resolve the
+   * size from the {@link LayoutParams} or valid non-zero values for {@link View#getWidth()} and
+   * {@link View#getHeight()}.
+   *
+   * <p>Because calling this method forces Glide to wait for the layout pass to occur before
+   * starting loads, setting this parameter to {@code true} can cause Glide to asynchronous load an
+   * image even if it's in the memory cache. The load will happen asynchronously because Glide has
+   * to wait for a layout pass to occur, which won't necessarily happen in the same frame as when
+   * the image is requested. As a result, using this method can resulting in flashing in some cases
+   * and should be used sparingly.
+   *
+   * <p>If the {@link LayoutParams} of the wrapped {@link View} are set to fixed sizes, they will
+   * still be used instead of the {@link View}'s dimensions even if this method is called. This
+   * parameter is a fallback only.
+   */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @NonNull
+  public final CustomViewTarget<T, Z> waitForLayout() {
+    sizeDeterminer.waitForLayout = true;
+    return this;
+  }
+
+  /**
+   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its {@link
+   * android.view.Window} and restarts the {@link Request} when the {@link View} is re-attached from
+   * its {@link android.view.Window}.
+   *
+   * <p>This is an experimental API that may be removed in a future version.
+   *
+   * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when
+   * transitioning screens or swapping adapters in scrolling views. However it also substantially
+   * increases the odds that images will not be in memory if users subsequently return to a screen
+   * where images were previously loaded. Whether or not this happens will depend on the number of
+   * images loaded in the new screen and the size of the memory cache. Increasing the size of the
+   * memory cache can improve this behavior but it largely negates the memory benefits of using this
+   * method.
+   *
+   * <p>Use this method with caution and measure your memory usage to ensure that it's actually
+   * improving your memory usage in the cases you care about.
+   */
+  // Public API.
+  @NonNull
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  public final CustomViewTarget<T, Z> clearOnDetach() {
+    if (attachStateListener != null) {
+      return this;
+    }
+    attachStateListener = new OnAttachStateChangeListener() {
+      @Override
+      public void onViewAttachedToWindow(View v) {
+        resumeMyRequest();
+      }
+
+      @Override
+      public void onViewDetachedFromWindow(View v) {
+        pauseMyRequest();
+      }
+    };
+    maybeAddAttachStateListener();
+    return this;
+  }
+
+  /**
+   * Override the android resource id to store temporary state allowing loads to be automatically
+   * cancelled and resources re-used in scrolling lists.
+   *
+   * <p>Unlike {@link ViewTarget}, it is <b>not</b> necessary to set a custom tag id if your app
+   * uses {@link View#setTag(Object)}. It is only necessary if loading several Glide resources into
+   * the same view, for example one foreground and one background view.
+   *
+   * @param tagId The android resource id to use.
+   */
+  // Public API.
+  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"})
+  public final CustomViewTarget<T, Z> useTagId(@IdRes int tagId) {
+    if (this.overrideTag != 0) {
+      throw new IllegalArgumentException("You cannot change the tag id once it has been set.");
+    }
+    this.overrideTag = tagId;
+    return this;
+  }
+
+  /** Returns the wrapped {@link android.view.View}. */
+  @NonNull
+  public final T getView() {
+    return view;
+  }
+
+  /**
+   * Determines the size of the view by first checking {@link android.view.View#getWidth()} and
+   * {@link android.view.View#getHeight()}. If one or both are zero, it then checks the view's
+   * {@link LayoutParams}. If one or both of the params width and height are less than or equal to
+   * zero, it then adds an {@link android.view.ViewTreeObserver.OnPreDrawListener} which waits until
+   * the view has been measured before calling the callback with the view's drawn width and height.
+   *
+   * @param cb {@inheritDoc}
+   */
+  @Override
+  public final void getSize(@NonNull SizeReadyCallback cb) {
+    sizeDeterminer.getSize(cb);
+  }
+
+  @Override
+  public final void removeCallback(@NonNull SizeReadyCallback cb) {
+    sizeDeterminer.removeCallback(cb);
+  }
+
+  @Override
+  public final void onLoadStarted(@Nullable Drawable placeholder) {
+    maybeAddAttachStateListener();
+    onResourceLoading(placeholder);
+  }
+
+  @Override
+  public final void onLoadCleared(@Nullable Drawable placeholder) {
+    sizeDeterminer.clearCallbacksAndListener();
+
+    onResourceCleared(placeholder);
+    if (!isClearedByUs) {
+      maybeRemoveAttachStateListener();
+    }
+  }
+
+  /**
+   * Stores the request using {@link View#setTag(Object)}.
+   *
+   * @param request {@inheritDoc}
+   */
+  @Override
+  public final void setRequest(@Nullable Request request) {
+    setTag(request);
+  }
+
+  /** Returns any stored request using {@link android.view.View#getTag()}. */
+  @Override
+  @Nullable
+  public final Request getRequest() {
+    Object tag = getTag();
+    if (tag != null) {
+      if (tag instanceof Request) {
+        return (Request) tag;
+      } else {
+        throw new IllegalArgumentException("You must not pass non-R.id ids to setTag(id)");
+      }
+    }
+    return null;
+  }
+
+  @Override
+  public String toString() {
+    return "Target for: " + view;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final void resumeMyRequest() {
+    Request request = getRequest();
+    if (request != null && request.isCleared()) {
+      request.begin();
+    }
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Synthetic
+  final void pauseMyRequest() {
+    Request request = getRequest();
+    if (request != null) {
+      isClearedByUs = true;
+      request.clear();
+      isClearedByUs = false;
+    }
+  }
+
+  private void setTag(@Nullable Object tag) {
+    view.setTag(overrideTag == 0 ? VIEW_TAG_ID : overrideTag, tag);
+  }
+
+  @Nullable
+  private Object getTag() {
+    return view.getTag(overrideTag == 0 ? VIEW_TAG_ID : overrideTag);
+  }
+
+  private void maybeAddAttachStateListener() {
+    if (attachStateListener == null || isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.addOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = true;
+  }
+
+  private void maybeRemoveAttachStateListener() {
+    if (attachStateListener == null || !isAttachStateListenerAdded) {
+      return;
+    }
+
+    view.removeOnAttachStateChangeListener(attachStateListener);
+    isAttachStateListenerAdded = false;
+  }
+
+  @VisibleForTesting
+  static final class SizeDeterminer {
+    // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
+    private static final int PENDING_SIZE = 0;
+    @VisibleForTesting
+    @Nullable
+    static Integer maxDisplayLength;
+    private final View view;
+    private final List<SizeReadyCallback> cbs = new ArrayList<>();
+    @Synthetic boolean waitForLayout;
+
+    @Nullable private SizeDeterminerLayoutListener layoutListener;
+
+    SizeDeterminer(@NonNull View view) {
+      this.view = view;
+    }
+
+    // Use the maximum to avoid depending on the device's current orientation.
+    private static int getMaxDisplayLength(@NonNull Context context) {
+      if (maxDisplayLength == null) {
+        WindowManager windowManager =
+            (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
+        Point displayDimensions = new Point();
+        display.getSize(displayDimensions);
+        maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);
+      }
+      return maxDisplayLength;
+    }
+
+    private void notifyCbs(int width, int height) {
+      // One or more callbacks may trigger the removal of one or more additional callbacks, so we
+      // need a copy of the list to avoid a concurrent modification exception. One place this
+      // happens is when a full request completes from the in memory cache while its thumbnail is
+      // still being loaded asynchronously. See #2237.
+      for (SizeReadyCallback cb : new ArrayList<>(cbs)) {
+        cb.onSizeReady(width, height);
+      }
+    }
+
+    @Synthetic
+    void checkCurrentDimens() {
+      if (cbs.isEmpty()) {
+        return;
+      }
+
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (!isViewStateAndSizeValid(currentWidth, currentHeight)) {
+        return;
+      }
+
+      notifyCbs(currentWidth, currentHeight);
+      clearCallbacksAndListener();
+    }
+
+    void getSize(@NonNull SizeReadyCallback cb) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
+        cb.onSizeReady(currentWidth, currentHeight);
+        return;
+      }
+
+      // We want to notify callbacks in the order they were added and we only expect one or two
+      // callbacks to be added a time, so a List is a reasonable choice.
+      if (!cbs.contains(cb)) {
+        cbs.add(cb);
+      }
+      if (layoutListener == null) {
+        ViewTreeObserver observer = view.getViewTreeObserver();
+        layoutListener = new SizeDeterminerLayoutListener(this);
+        observer.addOnPreDrawListener(layoutListener);
+      }
+    }
+
+    /**
+     * The callback may be called anyway if it is removed by another {@link SizeReadyCallback} or
+     * otherwise removed while we're notifying the list of callbacks.
+     *
+     * <p>See #2237.
+     */
+    void removeCallback(@NonNull SizeReadyCallback cb) {
+      cbs.remove(cb);
+    }
+
+    void clearCallbacksAndListener() {
+      // Keep a reference to the layout attachStateListener and remove it here
+      // rather than having the observer remove itself because the observer
+      // we add the attachStateListener to will be almost immediately merged into
+      // another observer and will therefore never be alive. If we instead
+      // keep a reference to the attachStateListener and remove it here, we get the
+      // current view tree observer and should succeed.
+      ViewTreeObserver observer = view.getViewTreeObserver();
+      if (observer.isAlive()) {
+        observer.removeOnPreDrawListener(layoutListener);
+      }
+      layoutListener = null;
+      cbs.clear();
+    }
+
+    private boolean isViewStateAndSizeValid(int width, int height) {
+      return isDimensionValid(width) && isDimensionValid(height);
+    }
+
+    private int getTargetHeight() {
+      int verticalPadding = view.getPaddingTop() + view.getPaddingBottom();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.height : PENDING_SIZE;
+      return getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);
+    }
+
+    private int getTargetWidth() {
+      int horizontalPadding = view.getPaddingLeft() + view.getPaddingRight();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.width : PENDING_SIZE;
+      return getTargetDimen(view.getWidth(), layoutParamSize, horizontalPadding);
+    }
+
+    private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
+      // We consider the View state as valid if the View has non-null layout params and a non-zero
+      // layout params width and height. This is imperfect. We're making an assumption that View
+      // parents will obey their child's layout parameters, which isn't always the case.
+      int adjustedParamSize = paramSize - paddingSize;
+      if (adjustedParamSize > 0) {
+        return adjustedParamSize;
+      }
+
+      // Since we always prefer layout parameters with fixed sizes, even if waitForLayout is true,
+      // we might as well ignore it and just return the layout parameters above if we have them.
+      // Otherwise we should wait for a layout pass before checking the View's dimensions.
+      if (waitForLayout && view.isLayoutRequested()) {
+        return PENDING_SIZE;
+      }
+
+      // We also consider the View state valid if the View has a non-zero width and height. This
+      // means that the View has gone through at least one layout pass. It does not mean the Views
+      // width and height are from the current layout pass. For example, if a View is re-used in
+      // RecyclerView or ListView, this width/height may be from an old position. In some cases
+      // the dimensions of the View at the old position may be different than the dimensions of the
+      // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to
+      // change them. Nevertheless, in most cases this should be a reasonable choice.
+      int adjustedViewSize = viewSize - paddingSize;
+      if (adjustedViewSize > 0) {
+        return adjustedViewSize;
+      }
+
+      // Finally we consider the view valid if the layout parameter size is set to wrap_content.
+      // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a
+      // coherent choice, it's extremely dangerous because original images may be much too large to
+      // fit in memory or so large that only a couple can fit in memory, causing OOMs. If users want
+      // the original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content
+      // may never resolve to a real size unless we load something, we aim for a square whose length
+      // is the largest screen size. That way we're loading something and that something has some
+      // hope of being downsampled to a size that the device can support. We also log a warning that
+      // tries to explain what Glide is doing and why some alternatives are preferable.
+      // Since WRAP_CONTENT is sometimes used as a default layout parameter, we always wait for
+      // layout to complete before using this fallback parameter (ConstraintLayout among others).
+      if (!view.isLayoutRequested() && paramSize == LayoutParams.WRAP_CONTENT) {
+        if (Log.isLoggable(TAG, Log.INFO)) {
+          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
+              + " this device's screen dimensions. If you want to load the original image and are"
+              + " ok with the corresponding memory cost and OOMs (depending on the input size), use"
+              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set"
+              + " layout_width and layout_height to fixed dimension, or use .override() with fixed"
+              + " dimensions.");
+        }
+        return getMaxDisplayLength(view.getContext());
+      }
+
+      // If the layout parameters are < padding, the view size is < padding, or the layout
+      // parameters are set to match_parent or wrap_content and no layout has occurred, we should
+      // wait for layout and repeat.
+      return PENDING_SIZE;
+    }
+
+    private boolean isDimensionValid(int size) {
+      return size > 0 || size == SIZE_ORIGINAL;
+    }
+
+    private static final class SizeDeterminerLayoutListener
+        implements ViewTreeObserver.OnPreDrawListener {
+      private final WeakReference<SizeDeterminer> sizeDeterminerRef;
+
+      SizeDeterminerLayoutListener(@NonNull SizeDeterminer sizeDeterminer) {
+        sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
+      }
+
+      @Override
+      public boolean onPreDraw() {
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "OnGlobalLayoutListener called attachStateListener=" + this);
+        }
+        SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
+        if (sizeDeterminer != null) {
+          sizeDeterminer.checkCurrentDimens();
+        }
+        return true;
+      }
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index 4c2143ab1..107330551 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -9,6 +9,7 @@
  * A simple {@link com.bumptech.glide.request.target.Target} base class with default (usually no-op)
  * implementations of non essential methods that allows the caller to specify an exact width/height.
  * Typically use cases look something like this:
+ *
  * <pre>
  * <code>
  * Target<Bitmap> target =
@@ -40,27 +41,32 @@
  * load into the same {@link View} or caller repeatedly using this class, always retain a reference
  * to the previous instance and either call {@link com.bumptech.glide.RequestManager#clear(Target)}
  * on the old instance before starting a new load or you must re-use the old instance for the new
- * load. Glide's {@link com.bumptech.glide.RequestBuilder#into(Target)} method returns the
- * {@link Target} instance you provided to make retaining a reference to the {@link Target} as easy
- * as possible. That said, you must wait until you're completely finished with the resource before
+ * load. Glide's {@link com.bumptech.glide.RequestBuilder#into(Target)} method returns the {@link
+ * Target} instance you provided to make retaining a reference to the {@link Target} as easy as
+ * possible. That said, you must wait until you're completely finished with the resource before
  * calling {@link com.bumptech.glide.RequestManager#clear(Target)} and you should always null out
  * references to any loaded resources in {@link Target#onLoadCleared(Drawable)}.
  *
- * <p>Always try to provide a size when using this class. Use
- * {@link SimpleTarget#SimpleTarget(int, int)} whenever possible with values that are <em>not</em>
- * {@link Target#SIZE_ORIGINAL}. Using {@link Target#SIZE_ORIGINAL} is unsafe if you're loading
- * large images or are running your application on older or memory constrained devices because it
- * can cause Glide to load very large images into memory. In some cases those images may throw
- * {@link OutOfMemoryError} and in others they may exceed the texture limit for the device, which
- * will prevent them from being rendered. Providing a valid size allows Glide to downsample large
- * images, which can avoid issues with texture size or memory limitations. You don't have to worry
- * about providing a size in most cases if you use {@link ViewTarget} so prefer {@link ViewTarget}
- * over this class whenver possible.
+ * <p>Always try to provide a size when using this class. Use {@link SimpleTarget#SimpleTarget(int,
+ * int)} whenever possible with values that are <em>not</em> {@link Target#SIZE_ORIGINAL}. Using
+ * {@link Target#SIZE_ORIGINAL} is unsafe if you're loading large images or are running your
+ * application on older or memory constrained devices because it can cause Glide to load very large
+ * images into memory. In some cases those images may throw {@link OutOfMemoryError} and in others
+ * they may exceed the texture limit for the device, which will prevent them from being rendered.
+ * Providing a valid size allows Glide to downsample large images, which can avoid issues with
+ * texture size or memory limitations. You don't have to worry about providing a size in most cases
+ * if you use {@link ViewTarget} so prefer {@link ViewTarget} over this class whenver possible.
  *
  * @see <a href="http://bumptech.github.io/glide/doc/targets.html">Glide's Target docs page</a>
- *
  * @param <Z> The type of resource that this target will receive.
+ * @deprecated Use {@link CustomViewTarget} if loading the content into a view, the download API if
+ *     in the background
+ *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a a fully
+ *     implemented {@link Target} for any specialized use-cases. Using BaseView is unsafe if the
+ *     user does not implement {@link #onLoadCleared}, resulting in recycled bitmaps being
+ *     referenced from the UI and hard to root-cause crashes.
  */
+@Deprecated
 public abstract class SimpleTarget<Z> extends BaseTarget<Z> {
   private final int width;
   private final int height;
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index e9eb1a538..502234774 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -42,14 +42,14 @@
   void onLoadStarted(@Nullable Drawable placeholder);
 
   /**
-   * A lifecycle callback that is called when a load fails.
+   * A <b>mandatory</b> lifecycle callback that is called when a load fails.
    *
-   * <p> Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)
-   * } if the model object is null.
+   * <p>Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable) }
+   * if the model object is null.
    *
-   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
-   * Transition)} is no longer displayed before redrawing the container (usually a View) or
-   * changing its visibility.
+   * <p>You <b>must</b> ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer used before redrawing the container (usually a View) or changing its
+   * visibility.
    *
    * @param errorDrawable The error drawable to optionally show, or null.
    */
@@ -63,11 +63,12 @@
   void onResourceReady(@NonNull R resource, @Nullable Transition<? super R> transition);
 
   /**
-   * A lifecycle callback that is called when a load is cancelled and its resources are freed.
+   * A <b>mandatory</b> lifecycle callback that is called when a load is cancelled and its resources
+   * are freed.
    *
-   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
-   * Transition)} is no longer displayed before redrawing the container (usually a View) or
-   * changing its visibility.
+   * <p>You <b>must</b> ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer used before redrawing the container (usually a View) or changing its
+   * visibility.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 8df9ef60d..9bc6d8b2e 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -26,21 +26,25 @@
  * provides default implementations for most most methods and can determine the size of views using
  * a {@link android.view.ViewTreeObserver.OnDrawListener}.
  *
- * <p> To detect {@link View} reuse in {@link android.widget.ListView} or any {@link
+ * <p>To detect {@link View} reuse in {@link android.widget.ListView} or any {@link
  * android.view.ViewGroup} that reuses views, this class uses the {@link View#setTag(Object)} method
  * to store some metadata so that if a view is reused, any previous loads or resources from previous
- * loads can be cancelled or reused. </p>
+ * loads can be cancelled or reused.
  *
- * <p> Any calls to {@link View#setTag(Object)}} on a View given to this class will result in
+ * <p>Any calls to {@link View#setTag(Object)}} on a View given to this class will result in
  * excessive allocations and and/or {@link IllegalArgumentException}s. If you must call {@link
  * View#setTag(Object)} on a view, use {@link #setTagId(int)} to specify a custom tag for Glide to
  * use.
  *
- * <p> Subclasses must call super in {@link #onLoadCleared(Drawable)} </p>
+ * <p>Subclasses must call super in {@link #onLoadCleared(Drawable)}
  *
  * @param <T> The specific subclass of view wrapped by this target.
  * @param <Z> The resource type this target will receive.
+ * @deprecated Use {@link CustomViewTarget}. Using this class is unsafe without implementing {@link
+ *     #onLoadCleared} and results in recycled bitmaps being referenced from the UI and hard to
+ *     root-cause crashes.
  */
+@Deprecated
 public abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {
   private static final String TAG = "ViewTarget";
   private static boolean isTagUsedAtLeastOnce;
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index 8f0bee837..c1e11a194 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -111,6 +111,8 @@ public static void toStream(@NonNull ByteBuffer byteBuffer,
     }
   }
 
+  // We check the appropriate offsets, so this is a spurious warning.
+  @SuppressWarnings("ByteBufferBackingArray")
   @NonNull
   public static byte[] toBytes(@NonNull ByteBuffer byteBuffer) {
     final byte[] result;
diff --git a/library/src/main/res/values/ids.xml b/library/src/main/res/values/ids.xml
new file mode 100644
index 000000000..c8c7c74dd
--- /dev/null
+++ b/library/src/main/res/values/ids.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <item name="glide_custom_view_target_tag" type="id"/>
+</resources>
\ No newline at end of file
diff --git a/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
new file mode 100644
index 000000000..899090631
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java
@@ -0,0 +1,697 @@
+package com.bumptech.glide.request.target;
+
+import static android.view.ViewGroup.LayoutParams;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.Display;
+import android.view.View;
+import android.view.View.OnAttachStateChangeListener;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+import android.widget.FrameLayout;
+import com.bumptech.glide.request.Request;
+import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
+import com.google.common.truth.Truth;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.ReflectionHelpers;
+
+/**
+ * Test for {@link CustomViewTarget}.
+ *
+ * TODO: This should really be in the tests subproject, but that causes errors because the R class
+ * referenced in {@link CustomViewTarget} can't be found. This should be fixable with some gradle
+ * changes, but I've so far failed to figure out the right set of commands.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 19, manifest = "build/intermediates/manifests/full/debug/AndroidManifest.xml")
+public class CustomViewTargetTest {
+  private ActivityController<Activity> activity;
+  private View view;
+  private ViewGroup parent;
+  private CustomViewTarget<View, Object> target;
+  @Mock private SizeReadyCallback cb;
+  @Mock private Request request;
+  private int sdkVersion;
+  private AttachStateTarget attachStateTarget;
+
+  @Before
+  public void setUp() {
+    sdkVersion = Build.VERSION.SDK_INT;
+    MockitoAnnotations.initMocks(this);
+    activity = Robolectric.buildActivity(Activity.class).create().start().postCreate(null).resume();
+    view = new View(activity.get());
+    target = new TestViewTarget(view);
+    attachStateTarget = new AttachStateTarget(view);
+
+    activity.get().setContentView(view);
+    parent = (ViewGroup) view.getParent();
+  }
+
+  @After
+  public void tearDown() {
+    setSdkVersionInt(sdkVersion);
+    CustomViewTarget.SizeDeterminer.maxDisplayLength = null;
+  }
+
+  @Test
+  public void testReturnsWrappedView() {
+    assertEquals(view, target.getView());
+  }
+
+  @Test
+  public void testReturnsNullFromGetRequestIfNoRequestSet() {
+    assertNull(target.getRequest());
+  }
+
+  @Test
+  public void testCanSetAndRetrieveRequest() {
+    target.setRequest(request);
+
+    assertEquals(request, target.getRequest());
+  }
+
+  @Test
+  public void testRetrievesRequestFromPreviousTargetForView() {
+    target.setRequest(request);
+
+    CustomViewTarget<View, Object> second = new TestViewTarget(view);
+
+    assertEquals(request, second.getRequest());
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
+    int dimens = 333;
+    activity.get().setContentView(view);
+    view.layout(0, 0, dimens, dimens);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet() {
+    int dimens = 444;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(dimens, dimens);
+    view.setLayoutParams(layoutParams);
+    view.requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(eq(dimens), eq(dimens));
+  }
+
+  @Test
+  public void getSize_withBothWrapContent_usesDisplayDimens() {
+    LayoutParams layoutParams =
+        new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(layoutParams);
+
+    setDisplayDimens(200, 300);
+
+    activity.visible();
+    view.layout(0, 0, 0, 0);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(300, 300);
+  }
+
+  @Test
+  public void getSize_withWrapContentWidthAndValidHeight_usesDisplayDimenAndValidHeight() {
+    int height = 100;
+    LayoutParams params = new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, height);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(100, 200);
+
+    activity.visible();
+    view.setRight(0);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(200, height);
+  }
+
+  @Test
+  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndDisplayDimen() {
+    int width = 100;
+    LayoutParams params = new FrameLayout.LayoutParams(width, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+    setDisplayDimens(200, 100);
+    parent.getLayoutParams().height = 200;
+
+    activity.visible();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(width, 200);
+  }
+
+  @Test
+  public void getSize_withWrapContentWidthAndMatchParentHeight_usesDisplayDimenWidthAndHeight() {
+    LayoutParams params =
+        new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(500, 600);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int height = 32;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(600, height);
+  }
+
+  @Test
+  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndDisplayDimenHeight() {
+    LayoutParams params =
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+    view.setLayoutParams(params);
+
+    setDisplayDimens(300, 400);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int width = 32;
+    parent.getLayoutParams().width = 32;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(width, 400);
+  }
+
+  @Test
+  public void testMatchParentWidthAndHeight() {
+    LayoutParams params =
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+    view.setLayoutParams(params);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    int width = 32;
+    int height = 45;
+    parent.getLayoutParams().width = width;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
+    target.getSize(cb);
+
+    int width = 12;
+    int height = 32;
+    parent.getLayoutParams().width = width;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testSizeCallbacksAreCalledInOrderPreDraw() {
+    SizeReadyCallback[] cbs = new SizeReadyCallback[25];
+    for (int i = 0; i < cbs.length; i++) {
+      cbs[i] = mock(SizeReadyCallback.class);
+      target.getSize(cbs[i]);
+    }
+
+    int width = 100, height = 111;
+    parent.getLayoutParams().width = width;
+    parent.getLayoutParams().height = height;
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    InOrder order = inOrder((Object[]) cbs);
+    for (SizeReadyCallback cb : cbs) {
+      order.verify(cb).onSizeReady(eq(width), eq(height));
+    }
+  }
+
+  @Test
+  public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
+    target.getSize(cb);
+    target.getSize(cb);
+
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testDoesNotAddMultipleListenersIfMultipleCallbacksAreAdded() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+    target.getSize(cb2);
+    view.getViewTreeObserver().dispatchOnPreDraw();
+    // assertThat(shadowObserver.getPreDrawListeners()).hasSize(1);
+  }
+
+  @Test
+  public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest() {
+    SizeReadyCallback cb1 = mock(SizeReadyCallback.class);
+    target.getSize(cb1);
+
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    SizeReadyCallback cb2 = mock(SizeReadyCallback.class);
+    view.setLayoutParams(
+        new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+    target.getSize(cb2);
+
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb2).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
+    target.getSize(cb);
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+
+    activity.visible();
+    verify(cb).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
+    target.getSize(cb);
+
+    int width = 689;
+    int height = 354;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    view.requestLayout();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
+    activity.visible();
+    target.getSize(cb);
+
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(1234, 4123);
+    view.setLayoutParams(layoutParams);
+    view.requestLayout();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
+    SizeReadyCallback firstCb = mock(SizeReadyCallback.class);
+    SizeReadyCallback secondCb = mock(SizeReadyCallback.class);
+    target.getSize(firstCb);
+    target.getSize(secondCb);
+
+    int width = 68;
+    int height = 875;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    activity.visible();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+    view.getViewTreeObserver().dispatchOnPreDraw();
+
+    verify(firstCb, times(1)).onSizeReady(eq(width), eq(height));
+    verify(secondCb, times(1)).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test
+  public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
+    target.getSize(cb);
+
+    int width = 1;
+    int height = 2;
+    LayoutParams layoutParams = new FrameLayout.LayoutParams(width, height);
+    view.setLayoutParams(layoutParams);
+    ViewTreeObserver vto = view.getViewTreeObserver();
+    view.requestLayout();
+    activity.visible();
+    assertFalse(vto.isAlive());
+    vto.dispatchOnPreDraw();
+
+    verify(cb).onSizeReady(eq(width), eq(height));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void testThrowsIfGivenNullView() {
+    new TestViewTarget(null);
+  }
+
+  @Test
+  public void testDecreasesDimensionsByViewPadding() {
+    activity.visible();
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.setPadding(25, 25, 25, 25);
+    view.requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(50, 50);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_notLaidOut_notLayoutRequested_callsSizeReady() {
+    view.setRight(100);
+    view.setBottom(100);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withLayoutParams_notLaidOut_doesCallSizeReady() {
+    view.setLayoutParams(new FrameLayout.LayoutParams(10, 10));
+    view.setRight(100);
+    view.setBottom(100);
+    target.getSize(cb);
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_emptyParams_notLaidOutOrLayoutRequested_callsSizeReady() {
+    view.setLayoutParams(new FrameLayout.LayoutParams(0, 0));
+    view.setRight(100);
+    view.setBottom(100);
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeReady() {
+    setSdkVersionInt(18);
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(100, 100);
+  }
+
+  @Test
+  public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
+    view.setLayoutParams(new FrameLayout.LayoutParams(100, 100));
+    view.requestLayout();
+    view.setPadding(50, 50, 50, 50);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  private void setDisplayDimens(Integer width, Integer height) {
+    WindowManager windowManager =
+        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
+    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
+    if (width != null) {
+      Shadows.shadowOf(display).setWidth(width);
+    }
+
+    if (height != null) {
+      Shadows.shadowOf(display).setHeight(height);
+    }
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    activity.visible();
+  }
+
+  // This behavior isn't clearly correct, but it doesn't seem like there's any harm to clear an
+  // already cleared request, so we might as well avoid the extra check/complexity in the code.
+  @Test
+  public void clearOnDetach_onDetach_withClearedRequest_clearsRequest() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_withRunningRequest_pausesRequestOnce() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterOnLoadCleared_removesListener() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    parent.removeView(view);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_moreThanOnce_registersObserverOnce() {
+    activity.visible();
+    attachStateTarget.setRequest(request);
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach();
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterMultipleClearOnDetaches_removesListener() {
+    activity.visible();
+    attachStateTarget
+        .clearOnDetach()
+        .clearOnDetach()
+        .clearOnDetach();
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.setRequest(request);
+    parent.removeView(view);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onDetach_afterLoadCleared_clearsRequest() {
+    activity.visible();
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    parent.removeView(view);
+
+    verify(request).clear();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withNullRequest_doesNothing() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(null);
+    activity.visible();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withRunningRequest_doesNotBeginRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(false);
+    activity.visible();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_withClearedRequest_beginsRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    activity.visible();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_afterLoadClearedAndRestarted_onAttach_beingsREquest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    activity.visible();
+
+    verify(request).begin();
+  }
+
+  @Test
+  public void clearOnDetach_onAttach_afterLoadCleared_doesNotBeingRequest() {
+    attachStateTarget.clearOnDetach();
+    attachStateTarget.setRequest(request);
+    when(request.isCleared()).thenReturn(true);
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+    activity.visible();
+
+    verify(request, never()).begin();
+  }
+
+  @Test
+  public void onLoadStarted_withoutClearOnDetach_doesNotAddListener() {
+    activity.visible();
+    target.setRequest(request);
+    attachStateTarget.onLoadStarted(/*placeholder=*/ null);
+    parent.removeView(view);
+
+    verify(request, never()).clear();
+  }
+
+  @Test
+  public void onLoadCleared_withoutClearOnDetach_doesNotRemoveListeners() {
+    final AtomicInteger count = new AtomicInteger();
+    OnAttachStateChangeListener expected =
+        new OnAttachStateChangeListener() {
+          @Override
+          public void onViewAttachedToWindow(View v) {
+            count.incrementAndGet();
+          }
+
+          @Override
+          public void onViewDetachedFromWindow(View v) {
+            // Intentionally Empty.
+          }
+        };
+    view.addOnAttachStateChangeListener(expected);
+
+    attachStateTarget.onLoadCleared(/*placeholder=*/ null);
+
+    activity.visible();
+
+    Truth.assertThat(count.get()).isEqualTo(1);
+  }
+
+  private static final class AttachStateTarget extends CustomViewTarget<View, Object> {
+    AttachStateTarget(View view) {
+      super(view);
+    }
+
+    @Override
+    protected void onResourceCleared(@Nullable Drawable placeholder) {
+      // Intentionally Empty.
+    }
+
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Intentionally Empty.
+    }
+
+    @Override
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
+      // Intentionally Empty.
+    }
+  }
+
+  private static final class TestViewTarget extends CustomViewTarget<View, Object> {
+
+    TestViewTarget(View view) {
+      super(view);
+    }
+
+    @Override
+    protected void onResourceCleared(@Nullable Drawable placeholder) {
+      // Intentionally Empty.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onResourceReady(
+        @NonNull Object resource, @Nullable Transition<? super Object> transition) {
+      // Avoid calling super.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onResourceLoading(@Nullable Drawable placeholder) {
+      // Avoid calling super.
+    }
+
+    // We're intentionally avoiding the super call.
+    @SuppressWarnings("MissingSuperCall")
+    @Override
+    public void onLoadFailed(@Nullable Drawable errorDrawable) {
+      // Avoid calling super.
+    }
+  }
+
+  private static void setSdkVersionInt(int version) {
+    ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", version);
+  }
+}
diff --git a/library/test/src/test/java/com/bumptech/glide/GlideTest.java b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
index 24b43b552..7efa6b523 100644
--- a/library/test/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java
@@ -646,7 +646,9 @@ public void testLoadDrawable() {
         .load(drawable)
         .into(target);
 
-    verify(target).onResourceReady(eq(drawable), any(Transition.class));
+    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);
+    verify(target).onResourceReady(drawableCaptor.capture(), any(Transition.class));
+    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.RED);
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index a3156e2d7..7734cd208 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -17,6 +17,7 @@
 import static org.mockito.Mockito.when;
 
 import android.os.Handler;
+import android.os.Looper;
 import android.support.v4.util.Pools;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
@@ -229,14 +230,14 @@ public void testDoesNotNotifyCancelledIfReceivedException() {
 
   @Test
   public void testReleasesResourceIfCancelledOnReady() {
-    ShadowLooper shadowLooper = Shadows.shadowOf(harness.mainHandler.getLooper());
-    shadowLooper.pause();
+    Looper looper = harness.mainHandler.getLooper();
+    Shadows.shadowOf(looper).pause();
 
     EngineJob<Object> job = harness.getJob();
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
     job.cancel();
-    shadowLooper.runOneTask();
+    Shadows.shadowOf(looper).runOneTask();
 
     verify(harness.resource).recycle();
   }
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
index 234b0f0e3..fe3f959f1 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
@@ -9,7 +9,6 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -29,7 +28,7 @@ public void testIGetNullIfNoMatchingBitmapExists() {
 
   @Test
   public void testICanAddAndGetABitmapOfTheSameSizeAndDimensions() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertEquals(bitmap,
         strategy.get(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888));
@@ -37,44 +36,44 @@ public void testICanAddAndGetABitmapOfTheSameSizeAndDimensions() {
 
   @Test
   public void testICantGetABitmapOfTheSameDimensionsButDifferentConfigs() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
   }
 
   @Test
   public void testICantGetABitmapOfTheSameDimensionsAndSizeButDifferentConfigs() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     strategy.put(bitmap);
     assertNull(strategy.get(100, 100, Bitmap.Config.RGB_565));
   }
 
   @Test
   public void testICantGetABitmapOfDifferentWidths() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(99, 100, Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testICantGetABitmapOfDifferentHeights() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(100, 99, Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testICantGetABitmapOfDifferentDimensionsButTheSameSize() {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     strategy.put(bitmap);
     assertNull(strategy.get(50, 200, Bitmap.Config.ARGB_8888));
   }
 
   @Test
   public void testMultipleBitmapsOfDifferentAttributesCanBeAddedAtOnce() {
-    Bitmap first = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    Bitmap second = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Bitmap third = ShadowBitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);
+    Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
+    Bitmap second = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Bitmap third = Bitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);
 
     strategy.put(first);
     strategy.put(second);
@@ -87,9 +86,9 @@ public void testMultipleBitmapsOfDifferentAttributesCanBeAddedAtOnce() {
 
   @Test
   public void testLeastRecentlyUsedAttributeSetIsRemovedFirst() {
-    final Bitmap leastRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-    final Bitmap other = ShadowBitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);
-    final Bitmap mostRecentlyUsed = ShadowBitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    final Bitmap leastRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
+    final Bitmap other = Bitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);
+    final Bitmap mostRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
     strategy.get(100, 100, Bitmap.Config.ALPHA_8);
     strategy.get(1000, 1000, Bitmap.Config.RGB_565);
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index f83e4be00..ab73d11e3 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -25,7 +25,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowBitmap;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -239,7 +238,7 @@ private Bitmap createMutableBitmap() {
   }
 
   private Bitmap createMutableBitmap(Bitmap.Config config) {
-    Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, config);
+    Bitmap bitmap = Bitmap.createBitmap(100, 100, config);
     Shadows.shadowOf(bitmap).setMutable(true);
     return bitmap;
 
diff --git a/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
index c894ded76..1f5536b3a 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -425,15 +425,10 @@ public void getFallback_afterApplyingOptionsWithFallbackId_returnsNull() {
 
   @Test
   public void getFallback_afterApplyingOptionsWithFallbackDrawable_returnsNewDrawable() {
-    Drawable expected = new ColorDrawable(Color.GREEN);
     RequestOptions toApply = new RequestOptions();
 
-    assertThat(
-        options
-          .fallback(new ColorDrawable(Color.RED))
-          .apply(toApply)
-          .getFallbackDrawable())
-        .isEqualTo(expected);
+    RequestOptions apply = options.fallback(new ColorDrawable(Color.RED)).apply(toApply);
+    assertThat(((ColorDrawable) apply.getFallbackDrawable()).getColor()).isEqualTo(Color.RED);
   }
 
   /**
diff --git a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 1327af04d..8341cd3c7 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -883,9 +883,6 @@ protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
         .addEquivalenceGroup(
             new SingleRequestBuilder().setModel(null),
             new SingleRequestBuilder().setModel(null))
-        .addEquivalenceGroup(
-            new SingleRequestBuilder().setErrorDrawable(new ColorDrawable(Color.GRAY)),
-            new SingleRequestBuilder().setErrorDrawable(new ColorDrawable(Color.GRAY)))
         .addEquivalenceGroup(
             new SingleRequestBuilder().setPriority(Priority.LOW),
             new SingleRequestBuilder().setPriority(Priority.LOW))
diff --git a/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
index 336a0ee29..9fd3f101d 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.request.target;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.mockito.Matchers.any;
@@ -19,6 +20,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.InOrder;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
@@ -108,7 +110,9 @@ public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
 
     target.onResourceReady(new ColorDrawable(Color.GREEN), animation);
 
-    verify(animation).transition(eq(placeholder), eq(target));
+    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);
+    verify(animation).transition(drawableCaptor.capture(), eq(target));
+    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.GREEN);
   }
 
   @Test
diff --git a/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index 0ea32764e..f6ae534f4 100644
--- a/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -19,6 +19,7 @@
 import android.os.Build;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.view.Display;
 import android.view.View;
 import android.view.View.OnAttachStateChangeListener;
 import android.view.ViewTreeObserver;
@@ -46,7 +47,6 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
-import org.robolectric.shadows.ShadowDisplay;
 import org.robolectric.shadows.ShadowView;
 
 @RunWith(RobolectricTestRunner.class)
@@ -470,14 +470,13 @@ public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
   private void setDisplayDimens(Integer width, Integer height) {
     WindowManager windowManager =
         (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
-    ShadowDisplay shadowDisplay =
-        Shadows.shadowOf(Preconditions.checkNotNull(windowManager).getDefaultDisplay());
+    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();
     if (width != null) {
-      shadowDisplay.setWidth(width);
+      Shadows.shadowOf(display).setWidth(width);
     }
 
     if (height != null) {
-      shadowDisplay.setHeight(height);
+      Shadows.shadowOf(display).setHeight(height);
     }
   }
 
@@ -687,7 +686,7 @@ void fireOnPreDrawListeners() {
     private LayoutParams layoutParams;
     private boolean isLaidOut;
     private boolean isLayoutRequested;
-    private final Set<OnAttachStateChangeListener> attachStateListeners = new HashSet<>();
+    final Set<OnAttachStateChangeListener> attachStateListeners = new HashSet<>();
 
     public SizedShadowView setWidth(int width) {
       this.width = width;
diff --git a/samples/imgur/build.gradle b/samples/imgur/build.gradle
index 215392a94..825ea2f16 100644
--- a/samples/imgur/build.gradle
+++ b/samples/imgur/build.gradle
@@ -50,7 +50,7 @@ dependencies {
 
     // Fixes a compilation warning related to dagger, see
     // https://github.com/google/guava/issues/2721.
-    compileOnly "com.google.errorprone:error_prone_annotations:2.1.3"
+    compileOnly "com.google.errorprone:error_prone_annotations:${ERROR_PRONE_VERSION}"
 }
 
 task run(type: Exec, dependsOn: 'installDebug') {
