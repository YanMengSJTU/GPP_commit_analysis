diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index da727f2ac..fe060621a 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -349,6 +349,6 @@
         </codeStyleSettings>
       </value>
     </option>
-    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />
   </component>
 </project>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index 7e00e8d6a..e3dc14645 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,8 +3,8 @@ android:
   components:
   - tools
   - platform-tools
-  - build-tools-22.0.1
-  - android-22
+  - build-tools-25.0.2
+  - android-25
   - extra-android-m2repository
   - extra-android-support
 
@@ -12,8 +12,7 @@ android:
   - 'android-sdk-license.*'
 
 jdk:
-  - openjdk7
-  - oraclejdk7
+  - oraclejdk8
 
 sudo: false
 
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 2576a1c95..d3fc25937 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -12,31 +12,6 @@ When in doubt, file an issue. We'd rather close a few duplicate issues than let
 Similarly if you support a particular feature request, feel free to let us know by commenting on the issue or [subscribing][6] to the issue.
 
 To file a new issue, please use our issue template and fill out the template as much as possible (remove irrelevant parts).
-
-<pre>**Glide Version**:
-**Integration libraries**:
-**Device/Android Version**:
-**Issue details / Repro steps / Use case background**:
-
-**Glide load line**:
-```java
-Glide.with(...).....load(...).....into(...);
-```
-
-**Layout XML**:
-```xml
-&lt;...Layout&gt;
-    &lt;ImageView android:scaleType="..." ... /&gt;
-&lt;/..Layout&gt;
-```
-
-**Stack trace / LogCat**:
-```ruby
-paste stack trace here
-```
-</pre>
-
-You can save [this as a bookmark or just click it][1] to create a new issue.
 The more information you can provide, the more likely we are to be able help.
 
 
@@ -70,4 +45,4 @@ Labels on issues are managed by contributors, you don't have to worry about them
 [3]: http://webchat.freenode.net/?channels=glide-library
 [4]: https://developers.google.com/open-source/cla/individual
 [5]: https://github.com/bumptech/glide
-[6]: https://help.github.com/articles/subscribing-to-conversations/
\ No newline at end of file
+[6]: https://help.github.com/articles/subscribing-to-conversations/
diff --git a/ISSUE_TEMPLATE.md b/ISSUE_TEMPLATE.md
new file mode 100644
index 000000000..f76cfa70d
--- /dev/null
+++ b/ISSUE_TEMPLATE.md
@@ -0,0 +1,50 @@
+<!--
+Please fill in the below fields with some data to help us best diagnose the issue.
+The more specific you are, the better! You can help a lot by not making us ask these questions.
+Feel free to remove any irrelevant parts that you know are not related to the issue.
+Any HTML comment like this will be stripped when rendering markdown, no need to delete them.
+-->
+
+
+<!-- What version of Glide you're running, for example: 3.7.1 | 3.8.0-SNAPSHOT | 4.0.0-SNAPSHOT
+It's essentially the version number from your build.gradle: `dependencies { compile '...:x.y.z' }` -->
+**Glide Version**:
+
+<!-- Do you use any integration library, like OkHttp3 or Volley? For example:
+Fails to display with stock networking, but works with okhttp3-1.4.0 -->
+**Integration libraries**:
+
+<!-- What devices you managed to get the issue to come up on? For example:
+fails on Galaxy S4/GT-I9500 4.4.2, works fine on Nexus 6P 5.1 and Genymotion Nexus 5 5.0.1 -->
+**Device/Android Version**:
+
+<!-- Share the details of your issue in prose, detailing actual and expected behavior. It also helps if you give some info **why** you are trying to do something as opposed to **what** is not working. -->
+**Issue details / Repro steps / Use case background**: 
+
+<!-- How do you use Glide?
+Make sure you include everything as is in your app's code:
+Changing a single method parameter can yield totally different results.
+Please clarify any magic variables that appear in the code, for example: "// `this` is a Fragment"
+-->
+**Glide load line / `GlideModule` (if any) / list Adapter code (if any)**:
+```java
+Glide.with...
+```
+
+<!-- How does your app look like?
+We're most interested in the layout attributes and the hierarchy around the ImageView -->
+**Layout XML**:
+```xml
+<FrameLayout xmlns:android="...
+```
+
+<!--
+What is the error message that you got in the log?
+You can find some help on diagnosing issues here: https://github.com/bumptech/glide/wiki/Debugging-and-Error-Handling
+-->
+**Stack trace / LogCat**:
+```ruby
+paste stack trace and/or log here
+```
+
+<!-- Bonus points if you attach a relevant screenshot, screen recording or a small demo project -->
diff --git a/PULL_REQUEST_TEMPLATE.md b/PULL_REQUEST_TEMPLATE.md
new file mode 100644
index 000000000..3cd191bf1
--- /dev/null
+++ b/PULL_REQUEST_TEMPLATE.md
@@ -0,0 +1,14 @@
+<!-- Make sure you've run `gradlew clean check jar assemble` before commit. -->
+<!-- Don't forget that you can always force push to your private branches to make changes. -->
+<!-- Please make sure there are no weird commits in the change set by rebasing to latest upstream. -->
+<!-- Please squash typo/checkstyle/review fix commits into the base commit. -->
+
+## Description
+<!-- Please describe the changes you made on a high level. -->
+<!-- Make sure you reference the GitHub issue here if this change is related to one. -->
+
+## Motivation and Context
+<!-- Why is this change required? What problem does it solve? -->
+<!-- If it's fixing a bug reference it or provide repro steps. -->
+
+<!-- If you have any issues feel free to create the PR anyway, we'll help to resolve them. -->
\ No newline at end of file
diff --git a/README.md b/README.md
index 1831f82cb..42b2d5802 100644
--- a/README.md
+++ b/README.md
@@ -50,9 +50,9 @@ Or Maven:
 
 For info on using the bleeding edge, see the [Snapshots][17] wiki page.
 
-Proguard
+ProGuard
 --------
-Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:
+Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):
 
 ```pro
 -keep public class * implements com.bumptech.glide.module.GlideModule
@@ -60,6 +60,9 @@ Depending on your proguard config and usage, you may need to include the followi
   **[] $VALUES;
   public *;
 }
+
+# for DexGuard only
+-keepresourcexmlelements manifest/application/meta-data@value=GlideModule
 ```
 
 How do I use Glide?
@@ -98,7 +101,6 @@ Simple use cases will look something like this:
 
   return myImageView;
 }
-
 ```
 
 Status
@@ -158,7 +160,7 @@ To open the project in IntelliJ IDEA:
 Getting Help
 ------------
 To report a specific problem or feature request, [open a new issue on Github][5]. For questions, suggestions, or
-anything else, join or email [Glide's discussion group][6], or join our IRC channel: [irc.freenode.net#glide-library][13].
+anything else, email [Glide's discussion group][6], or join our IRC channel: [irc.freenode.net#glide-library][13].
 
 Contributing
 ------------
@@ -167,7 +169,7 @@ Before submitting pull requests, contributors must sign Google's [individual con
 Thanks
 ------
 * The **Android team** and **Jake Wharton** for the [disk cache implementation][8] Glide's disk cache is based on.
-* **Dave Smith** for the [gif decoder gist][9] Glide's gif decoder is based on.
+* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on.
 * **Chris Banes** for his [gradle-mvn-push][10] script.
 * **Corey Hall** for Glide's [amazing logo][11].
 * Everyone who has contributed code and reported issues!
@@ -202,4 +204,4 @@ This is not an official Google product.
 [16]: https://github.com/bumptech/glide/blob/master/LICENSE
 [17]: https://github.com/bumptech/glide/wiki/Snapshots
 [18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
-[19]: https://github.com/wasabeef/glide-transformations
\ No newline at end of file
+[19]: https://github.com/wasabeef/glide-transformations
diff --git a/annotation/.gitignore b/annotation/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/build.gradle b/annotation/build.gradle
new file mode 100644
index 000000000..d6a7f76df
--- /dev/null
+++ b/annotation/build.gradle
@@ -0,0 +1,3 @@
+apply plugin: 'java'
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
\ No newline at end of file
diff --git a/annotation/compiler/.gitignore b/annotation/compiler/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/compiler/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/compiler/build.gradle b/annotation/compiler/build.gradle
new file mode 100644
index 000000000..0b51f2584
--- /dev/null
+++ b/annotation/compiler/build.gradle
@@ -0,0 +1,17 @@
+import org.gradle.internal.jvm.Jvm
+
+apply plugin: 'java'
+
+dependencies {
+    compile 'com.squareup:javapoet:1.8.0'
+    compile 'com.google.auto.service:auto-service:1.0-rc3'
+    compile 'com.google.code.findbugs:jsr305:3.0.1'
+    compile project(':annotation')
+    // This is to support com.sun.tootls.javac.util.List, currently used in RootModuleGenerator.
+    compile files(Jvm.current().getToolsJar())
+
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile 'com.google.testing.compile:compile-testing:0.10'
+}
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/annotation/compiler/gradle.properties b/annotation/compiler/gradle.properties
new file mode 100644
index 000000000..1f7f8a7a7
--- /dev/null
+++ b/annotation/compiler/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide Annotation processor
+POM_ARTIFACT_ID=compiler
+POM_PACKAGING=jar
+POM_DESCRIPTION=Glide's anntation processor. Should be included in all Applications and in all libraries that use Glide's modules for configuration.
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
new file mode 100644
index 000000000..6e45b850a
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
@@ -0,0 +1,230 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeSpec.Builder;
+import com.squareup.javapoet.WildcardTypeName;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates a new implementation of a AppGlideModule that calls all included LibraryGlideModules
+ * and the original AppGlideModule.
+ *
+ * <p>The generated class will always call the AppGlideModule last to give it priority over choices
+ * made or classes registered in LibraryGlideModules.
+ *
+ * <p>Android logging is included to allow developers to see exactly which modules are included at
+ * runtime.
+ *
+ * <p>The generated class looks something like this:
+ * <pre>
+ * <code>
+ *  final class GeneratedAppGlideModuleImpl extends com.bumptech.glide.GeneratedAppGlideModule {
+ *    private final com.bumptech.glide.samples.giphy.GiphyGlideModule appGlideModule;
+ *
+ *    GeneratedAppGlideModule() {
+ *      appGlideModule = new com.bumptech.glide.samples.giphy.GiphyGlideModule();
+ *      if (android.util.Log.isLoggable("Glide", android.util.Log.DEBUG)) {
+ *        android.util.Log.d("Glide", "Discovered AppGlideModule from annotation:"
+ *            + " com.bumptech.glide.samples.giphy.GiphyGlideModule");
+ *        android.util.Log.d("Glide", "Discovered LibraryGlideModule from annotation:"
+ *            + "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule");
+ *      }
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public void applyOptions(android.content.Context context,
+ *        com.bumptech.glide.GlideBuilder builder) {
+ *      appGlideModule.applyOptions(context, builder);
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public void registerComponents(android.content.Context context,
+ *        com.bumptech.glide.Registry registry) {
+ *      new com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule()
+ *          .registerComponents(context, registry);
+ *      appGlideModule.registerComponents(context, registry);
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public boolean isManifestParsingEnabled() {
+ *      return appGlideModule.isManifestParsingEnabled();
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public java.util.Set<java.lang.Class<?>> getExcludedModuleClasses() {
+ *      return appGlideModule.getExcludedModuleClasses();
+ *    }
+ *  }
+ * </code>
+ * </pre>
+ */
+final class AppModuleGenerator {
+  static final String GENERATED_ROOT_MODULE_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String GLIDE_LOG_TAG = "Glide";
+  private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME =
+      "GeneratedAppGlideModuleImpl";
+  private static final String GENERATED_ROOT_MODULE_SIMPLE_NAME = "GeneratedAppGlideModule";
+  private final ProcessorUtil processorUtil;
+
+  AppModuleGenerator(ProcessorUtil processorUtil) {
+    this.processorUtil = processorUtil;
+  }
+
+  TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {
+    ClassName appGlideModuleClassName = ClassName.get(appGlideModule);
+    Set<String> excludedGlideModuleClassNames =
+        getExcludedGlideModuleClassNames(appGlideModule);
+
+    MethodSpec constructor =
+        generateConstructor(
+            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+
+    MethodSpec registerComponents =
+        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+
+    MethodSpec getExcludedModuleClasses =
+        generateGetExcludedModuleClasses(excludedGlideModuleClassNames);
+
+    MethodSpec applyOptions =
+        MethodSpec.methodBuilder("applyOptions")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(ClassName.get("android.content", "Context"), "context")
+            .addParameter(ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+            .addStatement("appGlideModule.applyOptions(context, builder)", appGlideModule)
+            .build();
+
+    MethodSpec isManifestParsingEnabled =
+        MethodSpec.methodBuilder("isManifestParsingEnabled")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .returns(boolean.class)
+            .addStatement("return appGlideModule.isManifestParsingEnabled()", appGlideModule)
+            .build();
+
+    Builder builder = TypeSpec.classBuilder(GENERATED_APP_MODULE_IMPL_SIMPLE_NAME)
+        .addModifiers(Modifier.FINAL)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build()
+        )
+        .superclass(
+            ClassName.get(GENERATED_ROOT_MODULE_PACKAGE_NAME, GENERATED_ROOT_MODULE_SIMPLE_NAME))
+        .addField(appGlideModuleClassName, "appGlideModule", Modifier.PRIVATE, Modifier.FINAL)
+        .addMethod(constructor)
+        .addMethod(applyOptions)
+        .addMethod(registerComponents)
+        .addMethod(isManifestParsingEnabled)
+        .addMethod(getExcludedModuleClasses);
+
+    ClassName generatedRequestManagerFactoryClassName =
+        ClassName.get(
+            RequestManagerFactoryGenerator.GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME,
+            RequestManagerFactoryGenerator.GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME);
+
+    builder.addMethod(
+        MethodSpec.methodBuilder("getRequestManagerFactory")
+            .addAnnotation(Override.class)
+            .returns(generatedRequestManagerFactoryClassName)
+            .addStatement("return new $T()", generatedRequestManagerFactoryClassName)
+            .build());
+    return builder.build();
+  }
+
+  // TODO: When we drop support for parsing GlideModules from AndroidManifests, remove this method.
+  private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNames) {
+    TypeName wildCardOfObject = WildcardTypeName.subtypeOf(Object.class);
+    ParameterizedTypeName classOfWildcardOfObjet =
+        ParameterizedTypeName.get(ClassName.get(Class.class), wildCardOfObject);
+    ParameterizedTypeName setOfClassOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(Set.class), classOfWildcardOfObjet);
+    ParameterizedTypeName hashSetOfClassOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(HashSet.class), classOfWildcardOfObjet);
+    MethodSpec.Builder builder = MethodSpec.methodBuilder("getExcludedModuleClasses")
+        .addModifiers(Modifier.PUBLIC)
+        .addAnnotation(Override.class)
+        .returns(setOfClassOfWildcardOfObject);
+
+    if (excludedClassNames.isEmpty()) {
+      builder.addStatement("return $T.emptySet()", Collections.class);
+    } else {
+      builder.addStatement(
+          "$T excludedClasses = new $T()", setOfClassOfWildcardOfObject,
+          hashSetOfClassOfWildcardOfObject);
+      for (String excludedClassName : excludedClassNames) {
+        // TODO: Remove this when we no longer support manifest parsing.
+        // Using a Literal ($L) instead of a type ($T) to get a fully qualified import that allows
+        // us to suppress deprecation warnings. Aimed at deprecated GlideModules.
+        builder.addStatement("excludedClasses.add($L.class)", excludedClassName);
+      }
+      builder.addStatement("return excludedClasses");
+    }
+
+    return builder.build();
+  }
+
+  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,
+      Set<String> excludedGlideModuleClassNames) {
+    MethodSpec.Builder registerComponents =
+        MethodSpec.methodBuilder("registerComponents")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(ClassName.get("android.content", "Context"), "context")
+            .addParameter(ClassName.get("com.bumptech.glide", "Registry"), "registry");
+
+    for (String glideModule : libraryGlideModuleClassNames) {
+      if (excludedGlideModuleClassNames.contains(glideModule)) {
+        continue;
+      }
+      ClassName moduleClassName = ClassName.bestGuess(glideModule);
+      registerComponents.addStatement(
+          "new $T().registerComponents(context, registry)", moduleClassName);
+    }
+    // Order matters here. The AppGlideModule must be called last.
+    registerComponents.addStatement("appGlideModule.registerComponents(context, registry)");
+    return registerComponents.build();
+  }
+
+  private MethodSpec generateConstructor(ClassName appGlideModule,
+      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {
+    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
+    constructorBuilder.addStatement("appGlideModule = new $T()", appGlideModule);
+
+    ClassName androidLogName = ClassName.get("android.util", "Log");
+
+    // Add some log lines to indicate to developers which modules where discovered.
+    constructorBuilder.beginControlFlow("if ($T.isLoggable($S, $T.DEBUG))",
+        androidLogName, GLIDE_LOG_TAG, androidLogName);
+    constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+        "Discovered AppGlideModule from annotation: " + appGlideModule);
+    // Excluded GlideModule classes from the manifest are logged in Glide's singleton.
+    for (String glideModule : libraryGlideModuleClassNames) {
+      ClassName moduleClassName = ClassName.bestGuess(glideModule);
+      if (excludedGlideModuleClassNames.contains(glideModule)) {
+        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);
+      } else {
+        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+            "Discovered LibraryGlideModule from annotation: " + moduleClassName);
+      }
+    }
+    constructorBuilder.endControlFlow();
+    return constructorBuilder.build();
+  }
+
+  private Set<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
+    return processorUtil.findClassValuesFromAnnotationOnClassAsNames(
+        appGlideModule, Excludes.class);
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
new file mode 100644
index 000000000..87b30e2a6
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
@@ -0,0 +1,180 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Runs the final steps of Glide's annotation process and generates the combined
+ * {@link AppGlideModule}, {@link com.bumptech.glide.Glide},
+ * {@link com.bumptech.glide.RequestManager}, and
+ * {@link com.bumptech.glide.request.RequestOptions} classes.
+ */
+final class AppModuleProcessor {
+  private static final String COMPILER_PACKAGE_NAME =
+      GlideAnnotationProcessor.class.getPackage().getName();
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final List<TypeElement> appGlideModules = new ArrayList<>();
+  private final RequestOptionsGenerator requestOptionsGenerator;
+  private final RequestManagerGenerator requestManagerGenerator;
+  private final AppModuleGenerator appModuleGenerator;
+  private final RequestBuilderGenerator requestBuilderGenerator;
+  private final RequestManagerFactoryGenerator requestManagerFactoryGenerator;
+  private final GlideGenerator glideGenerator;
+
+  AppModuleProcessor(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    appModuleGenerator = new AppModuleGenerator(processorUtil);
+    requestOptionsGenerator = new RequestOptionsGenerator(processingEnv, processorUtil);
+    requestManagerGenerator = new RequestManagerGenerator(processingEnv, processorUtil);
+    requestManagerFactoryGenerator = new RequestManagerFactoryGenerator(processingEnv);
+    glideGenerator = new GlideGenerator(processingEnv, processorUtil);
+    requestBuilderGenerator = new RequestBuilderGenerator(processingEnv, processorUtil);
+  }
+
+  void processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
+     for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+       if (processorUtil.isAppGlideModule(element)) {
+         appGlideModules.add(element);
+       }
+     }
+
+    processorUtil.debugLog("got app modules: " + appGlideModules);
+
+    if (appGlideModules.size() > 1) {
+      throw new IllegalStateException(
+          "You cannot have more than one AppGlideModule, found: " + appGlideModules);
+    }
+  }
+
+  boolean maybeWriteAppModule() {
+    // appGlideModules is added to in order to catch errors where multiple AppGlideModules may be
+    // present for a single application or library. Because we only add to appGlideModules, we use
+    // isGeneratedAppGlideModuleWritten to make sure the GeneratedAppGlideModule is written at
+    // most once.
+    if (appGlideModules.isEmpty()) {
+      return false;
+    }
+    TypeElement appModule = appGlideModules.get(0);
+    processorUtil.debugLog("Processing app module: " + appModule);
+    // If this package is null, it means there are no classes with this package name. One way this
+    // could happen is if we process an annotation and reach this point without writing something
+    // to the package. We do not error check here because that shouldn't happen with the
+    // current implementation.
+    PackageElement glideGenPackage =
+        processingEnv.getElementUtils().getPackageElement(COMPILER_PACKAGE_NAME);
+    FoundIndexedClassNames indexedClassNames = getIndexedClassNames(glideGenPackage);
+
+    // Write all generated code to the package containing the AppGlideModule. Doing so fixes
+    // classpath collisions if more than one Application containing a AppGlideModule is included
+    // in a project.
+    String generatedCodePackageName = appModule.getEnclosingElement().toString();
+
+    TypeSpec generatedRequestOptions = null;
+    if (!indexedClassNames.extensions.isEmpty()) {
+      generatedRequestOptions =
+          requestOptionsGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);
+      writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
+    }
+
+    TypeSpec generatedRequestBuilder =
+        requestBuilderGenerator.generate(generatedCodePackageName, generatedRequestOptions);
+    writeRequestBuilder(generatedCodePackageName, generatedRequestBuilder);
+
+    TypeSpec requestManager =
+        requestManagerGenerator.generate(
+            generatedCodePackageName, generatedRequestOptions, generatedRequestBuilder,
+            indexedClassNames.extensions);
+    writeRequestManager(generatedCodePackageName, requestManager);
+
+    TypeSpec requestManagerFactory =
+        requestManagerFactoryGenerator.generate(generatedCodePackageName, requestManager);
+    writeRequestManagerFactory(requestManagerFactory);
+
+    TypeSpec glide =
+        glideGenerator.generate(generatedCodePackageName, getGlideName(appModule), requestManager);
+    writeGlide(generatedCodePackageName, glide);
+
+    TypeSpec generatedAppGlideModule =
+        appModuleGenerator.generate(appModule, indexedClassNames.glideModules);
+    writeAppModule(generatedAppGlideModule);
+
+    processorUtil.infoLog("Wrote GeneratedAppGlideModule with: " + indexedClassNames.glideModules);
+
+    return true;
+  }
+
+  private String getGlideName(TypeElement appModule) {
+    return appModule.getAnnotation(GlideModule.class).glideName();
+  }
+
+  @SuppressWarnings("unchecked")
+  private FoundIndexedClassNames getIndexedClassNames(PackageElement glideGenPackage) {
+    Set<String> glideModules = new HashSet<>();
+    Set<String> extensions = new HashSet<>();
+    List<? extends Element> glideGeneratedElements = glideGenPackage.getEnclosedElements();
+    for (Element indexer : glideGeneratedElements) {
+      Index annotation = indexer.getAnnotation(Index.class);
+      // If the annotation is null, it means we've come across another class in the same package
+      // that we can safely ignore.
+      if (annotation != null) {
+        Collections.addAll(glideModules, annotation.modules());
+        Collections.addAll(extensions, annotation.extensions());
+      }
+    }
+
+    processorUtil.debugLog("Found GlideModules: " + glideModules);
+    return new FoundIndexedClassNames(glideModules, extensions);
+  }
+
+  private void writeGlide(String packageName, TypeSpec glide) {
+    processorUtil.writeClass(packageName, glide);
+  }
+
+  private void writeRequestManager(String packageName, TypeSpec requestManager) {
+    processorUtil.writeClass(packageName, requestManager);
+  }
+
+  // We dont' care about collisions in IDEs since this class isn't an API class.
+  private void writeRequestManagerFactory(TypeSpec requestManagerFactory) {
+    processorUtil.writeClass(
+        AppModuleGenerator.GENERATED_ROOT_MODULE_PACKAGE_NAME, requestManagerFactory);
+  }
+
+  // The app module we generate subclasses a package private class. We don't care about classpath
+  // collisions in IDEs since this class isn't an API class.
+  private void writeAppModule(TypeSpec appModule) {
+    processorUtil.writeClass(AppModuleGenerator.GENERATED_ROOT_MODULE_PACKAGE_NAME, appModule);
+  }
+
+  private void writeRequestOptions(String packageName, TypeSpec requestOptions) {
+    processorUtil.writeClass(packageName, requestOptions);
+  }
+
+  private void writeRequestBuilder(String packageName, TypeSpec requestBuilder) {
+    processorUtil.writeClass(packageName, requestBuilder);
+  }
+
+  private static final class FoundIndexedClassNames {
+    final Set<String> glideModules;
+    final Set<String> extensions;
+
+    private FoundIndexedClassNames(Set<String> glideModules, Set<String> extensions) {
+      this.glideModules = glideModules;
+      this.extensions = extensions;
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
new file mode 100644
index 000000000..4d6ac80c8
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
@@ -0,0 +1,43 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Writes Indexer classes annotated with {@link Index} for all
+ * classes found annotated with {@link GlideExtension}.
+ */
+final class ExtensionProcessor {
+  private final ProcessorUtil processorUtil;
+  private final IndexerGenerator indexerGenerator;
+
+  ExtensionProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+    this.processorUtil = processorUtil;
+    this.indexerGenerator = indexerGenerator;
+  }
+
+  boolean processExtensions(Set<? extends TypeElement> set, RoundEnvironment env) {
+    List<TypeElement> elements = processorUtil.getElementsFor(GlideExtension.class, env);
+    processorUtil.debugLog("Processing types : " + elements);
+    for (TypeElement typeElement : elements) {
+      GlideExtensionValidator.validateExtension(typeElement);
+      processorUtil.debugLog("Processing elements: " + typeElement.getEnclosedElements());
+    }
+
+    if (elements.isEmpty()) {
+      return false;
+    }
+    TypeSpec spec = indexerGenerator.generate(elements);
+    processorUtil.writeIndexer(spec);
+    return true;
+  }
+
+  Set<String> getSupportedAnnotationTypes() {
+    return Collections.singleton(GlideExtension.class.getName());
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
new file mode 100644
index 000000000..9046219e2
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
@@ -0,0 +1,129 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideType;
+import com.google.auto.service.AutoService;
+import java.util.HashSet;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.TypeElement;
+
+// Links in Javadoc will work due to build setup, even though there is no direct dependency here.
+/**
+ * Generates classes based on Glide's annotations that configure Glide, add support for additional
+ * resource types, and/or extend Glide's API.
+ *
+ * <p>This processor discovers all {@link AppGlideModule} and
+ * {@link LibraryGlideModule} implementations that are
+ * annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any implementations missing the
+ * annotation will be ignored.
+ *
+ * <p>This processor also discovers all {@link com.bumptech.glide.annotation.GlideExtension}
+ * annotated classes.
+ *
+ * <p>Multiple classes are generated by this processor:
+ * <ul>
+ *   <li>For {@link LibraryGlideModule}s - A GlideIndexer class in a
+ *      specific package that will later be used by the processor to discover all
+ *      {@link LibraryGlideModule} classes.
+ *   <li>For {@link AppGlideModule}s - A single
+ *      {@link AppGlideModule} implementation
+ *     ({@link com.bumptech.glide.GeneratedAppGlideModule}) that calls all
+ *     {@link LibraryGlideModule}s and the
+ *     original {@link AppGlideModule} in the correct order when Glide is
+ *     initialized.
+ *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -
+ *   <ul>
+ *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains
+ *     static versions of all builder methods in the base class and both static and instance
+ *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
+ *     <li>If one or more methods in one or more
+ *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
+ *     {@link GlideType}:
+ *     <ul>
+ *       <li>A {@link com.bumptech.glide.RequestManager} implementation containing a generated
+ *       method for each method annotated with
+ *       {@link GlideType}.
+ *       <li>A {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ *       implementation that produces the generated {@link com.bumptech.glide.RequestManager}s.
+ *       <li>A {@link com.bumptech.glide.Glide} look-alike that implements all static methods in
+ *       the {@link com.bumptech.glide.Glide} singleton and returns the generated
+ *       {@link com.bumptech.glide.RequestManager} implementation when appropriate.
+ *     </ul>
+ *   </ul>
+ * </ul>
+ *
+ * <p>{@link AppGlideModule} implementations must only be included in
+ * applications, not in libraries. There must be exactly one
+ * {@link AppGlideModule} implementation per
+ * Application. The {@link AppGlideModule} class is
+ * used as a signal that all modules have been found and that the final merged
+ * {@link com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
+ */
+@AutoService(Processor.class)
+public final class GlideAnnotationProcessor extends AbstractProcessor {
+  static final boolean DEBUG = false;
+  private ProcessorUtil processorUtil;
+  private LibraryModuleProcessor libraryModuleProcessor;
+  private AppModuleProcessor appModuleProcessor;
+  private boolean isGeneratedAppGlideModuleWritten;
+  private ExtensionProcessor extensionProcessor;
+
+  @Override
+  public synchronized void init(ProcessingEnvironment processingEnvironment) {
+    super.init(processingEnvironment);
+    processorUtil = new ProcessorUtil(processingEnvironment);
+    IndexerGenerator indexerGenerator = new IndexerGenerator(processorUtil);
+    libraryModuleProcessor = new LibraryModuleProcessor(processorUtil, indexerGenerator);
+    appModuleProcessor = new AppModuleProcessor(processingEnvironment, processorUtil);
+    extensionProcessor = new ExtensionProcessor(processorUtil, indexerGenerator);
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    Set<String> result = new HashSet<>();
+    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());
+    result.addAll(extensionProcessor.getSupportedAnnotationTypes());
+    return result;
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+   /**
+   * Each round we do the following:
+   * <ol>
+   *   <li>Find all AppGlideModules and save them to an instance variable (throw if > 1).
+   *   <li>Find all LibraryGlideModules
+   *   <li>For each LibraryGlideModule, write an Indexer with an Annotation with the class name.
+   *   <li>If we wrote any Indexers, return and wait for the next round.
+   *   <li>If we didn't write any Indexers and there is a AppGlideModule, write the
+   *   GeneratedAppGlideModule. Once the GeneratedAppGlideModule is written, we expect to be
+   *   finished. Any further generation of related classes will result in errors.
+   * </ol>
+   */
+  @Override
+  public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {
+    processorUtil.process();
+    boolean newModulesWritten = libraryModuleProcessor.processModules(set, env);
+    boolean newExtensionWritten = extensionProcessor.processExtensions(set, env);
+    appModuleProcessor.processModules(set, env);
+
+    if (newExtensionWritten || newModulesWritten) {
+      if (isGeneratedAppGlideModuleWritten) {
+        throw new IllegalStateException("Cannot process annotations after writing AppGlideModule");
+      }
+      return true;
+    }
+
+    if (!isGeneratedAppGlideModuleWritten) {
+      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();
+    }
+    return true;
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
new file mode 100644
index 000000000..488c5578f
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -0,0 +1,94 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.annotation.GlideType;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Validates that classes annotated with {@link com.bumptech.glide.annotation.GlideExtension}
+ * contains methods with the expected format.
+ *
+ * <p>Validation is performed so that errors can be found when a library is compiled. Without
+ * validation, an error written in to a library wouldn't be found until Glide tried to generate code
+ * for an Application.
+ */
+final class GlideExtensionValidator {
+
+  private GlideExtensionValidator() { }
+
+  static void validateExtension(TypeElement typeElement) {
+    if (!typeElement.getModifiers().contains(Modifier.PUBLIC)) {
+      throw new IllegalArgumentException("RequestOptionsExtensions must be public");
+    }
+    for (Element element : typeElement.getEnclosedElements()) {
+      if (element.getKind() == ElementKind.CONSTRUCTOR) {
+        if (!element.getModifiers().contains(Modifier.PRIVATE)) {
+          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
+              + " constructors and only static methods. Found a non-private constructor");
+        }
+        ExecutableElement executableElement = (ExecutableElement) element;
+        if (!executableElement.getParameters().isEmpty()) {
+          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
+              + " constructors and only static methods. Found parameters in the constructor");
+        }
+        continue;
+      }
+      if (element.getKind() == ElementKind.METHOD) {
+        ExecutableElement executableElement = (ExecutableElement) element;
+        if (executableElement.getAnnotation(GlideOption.class) != null) {
+          validateExtendsRequestOptions(executableElement);
+        } else if (executableElement.getAnnotation(GlideType.class) != null) {
+          validateExtendsRequestManager(executableElement);
+        }
+      }
+    }
+  }
+
+  private static void validateExtendsRequestOptions(ExecutableElement executableElement) {
+    validateStaticVoid(executableElement, GlideOption.class);
+    if (executableElement.getParameters().isEmpty()) {
+      throw new IllegalArgumentException("@GlideOption methods must take a "
+          + "RequestOptions object as their first parameter, but given none");
+    }
+    VariableElement first = executableElement.getParameters().get(0);
+    TypeMirror expected = first.asType();
+    if (!expected.toString().equals(
+        "com.bumptech.glide.request.RequestOptions")) {
+      throw new IllegalArgumentException("@GlideOption methods must take a"
+          + " RequestOptions object as their first parameter, but given: " + expected);
+    }
+  }
+
+  private static void validateExtendsRequestManager(ExecutableElement executableElement) {
+    validateStaticVoid(executableElement, GlideType.class);
+    if (executableElement.getParameters().size() != 1) {
+      throw new IllegalArgumentException("@GlideType methods must take a"
+          + " RequestOptions object as their first and only parameter, found multiple for: "
+      + executableElement.getEnclosingElement() + "#" + executableElement);
+    }
+
+    VariableElement first = executableElement.getParameters().get(0);
+    TypeMirror expected = first.asType();
+    if (!expected.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
+      throw new IllegalArgumentException("@GlideType methods must take a"
+          + " RequestBuilder object as their first parameter, but given: " + expected);
+    }
+  }
+
+  private static void validateStaticVoid(ExecutableElement executableElement, Class<?> clazz) {
+    if (!executableElement.getModifiers().contains(Modifier.STATIC)) {
+      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must be static");
+    }
+    TypeMirror returnType = executableElement.getReturnType();
+    if (returnType.getKind() != TypeKind.VOID) {
+      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must return void");
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
new file mode 100644
index 000000000..1f54c7667
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
@@ -0,0 +1,197 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.google.common.base.Function;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates a Glide look-alike that acts as the entry point to the generated API
+ * (GlideApp.with(...)).
+ *
+ * <p>>Generated {@link com.bumptech.glide.Glide} look-alikes look like this (note that the name
+ * is configurable in {@link com.bumptech.glide.annotation.GlideModule}):
+ * <pre>
+ * <code>
+ * public final class GlideApp {
+ *   private GiphyGlide() {
+ *   }
+ *
+ *   public static File getPhotoCacheDir(Context context) {
+ *     return Glide.getPhotoCacheDir(context);
+ *   }
+ *
+ *   public static File getPhotoCacheDir(Context context, String cacheName) {
+ *     return Glide.getPhotoCacheDir(context, cacheName);
+ *   }
+ *
+ *   public static Glide get(Context context) {
+ *     return Glide.get(context);
+ *   }
+ *
+ *   public static void tearDown() {
+ *     Glide.tearDown();
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Context context) {
+ *     return (GeneratedRequestManager) Glide.with(context);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Activity activity) {
+ *    return (GeneratedRequestManager) Glide.with(activity);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(FragmentActivity activity) {
+ *     return (GeneratedRequestManager) Glide.with(activity);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Fragment fragment) {
+ *     return (GeneratedRequestManager) Glide.with(fragment);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(android.support.v4.app.Fragment fragment) {
+ *     return (GeneratedRequestManager) Glide.with(fragment);
+ *   }
+ * </code>
+ * </pre>
+ */
+final class GlideGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final TypeElement glideType;
+  private final TypeElement requestManagerType;
+
+  GlideGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    Elements elementUtils = processingEnv.getElementUtils();
+
+    requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(
+      String generatedCodePackageName, String glideName, TypeSpec generatedRequestManager) {
+    return TypeSpec.classBuilder(glideName)
+        .addJavadoc(
+            "The entry point for interacting with Glide for Applications\n"
+                + "\n"
+                + "<p>Includes all generated APIs from all\n"
+                + "{@link $T}s in source and dependent libraries.\n"
+                + "\n"
+                + "<p>This class is generated and should not be modified"
+                + "\n"
+                + "@see $T\n", GlideExtension.class, glideType)
+        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addMethod(MethodSpec.constructorBuilder()
+            .addModifiers(Modifier.PRIVATE)
+            .build())
+        .addMethods(
+            generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager))
+        .build();
+  }
+
+  private List<MethodSpec> generateOverridesForGlideMethods(
+      final String generatedCodePackageName, final TypeSpec generatedRequestManager) {
+    return Lists.transform(discoverGlideMethodsToOverride(),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            if (isGlideWithMethod(input)) {
+              return overrideGlideWithMethod(
+                  generatedCodePackageName, generatedRequestManager, input);
+            } else {
+              return overrideGlideStaticMethod(input);
+            }
+          }
+        });
+  }
+
+  private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride) {
+    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+
+    TypeElement element =
+        (TypeElement) processingEnv.getTypeUtils().asElement(methodToOverride.getReturnType());
+
+    MethodSpec.Builder builder =
+        MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+            .addParameters(Lists.transform(parameters,
+                new Function<VariableElement, ParameterSpec>() {
+                  @Override
+                  public ParameterSpec apply(VariableElement input) {
+                    return ParameterSpec.get(input);
+                  }
+            }));
+
+    boolean returnsValue = element != null;
+    if (returnsValue) {
+      builder.returns(ClassName.get(element));
+    }
+
+    String code = returnsValue ? "return " : "";
+    code += "$T.$N(";
+    List<Object> args = new ArrayList<>();
+    args.add(ClassName.get(glideType));
+    args.add(methodToOverride.getSimpleName());
+    if (!parameters.isEmpty()) {
+      for (VariableElement param : parameters) {
+        code += "$L, ";
+        args.add(param.getSimpleName());
+      }
+      code = code.substring(0, code.length() - 2);
+    }
+    code += ")";
+    builder.addStatement(code, args.toArray(new Object[0]));
+    return builder.build();
+  }
+
+  private List<ExecutableElement> discoverGlideMethodsToOverride() {
+    return processorUtil.findStaticMethods(glideType);
+  }
+
+  private boolean isGlideWithMethod(ExecutableElement element) {
+    return processorUtil.isReturnValueTypeMatching(element, requestManagerType);
+  }
+
+  private MethodSpec overrideGlideWithMethod(
+      String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {
+    ClassName generatedRequestManagerClassName =
+        ClassName.get(packageName, generatedRequestManager.name);
+    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+    Preconditions.checkArgument(
+        parameters.size() == 1, "Expected size of 1, but got %s", methodToOverride);
+    VariableElement parameter = parameters.iterator().next();
+    return MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+        .returns(generatedRequestManagerClassName)
+        .addParameter(ClassName.get(parameter.asType()), parameter.getSimpleName().toString())
+        .addStatement("return ($T) $T.$N($L)",
+            generatedRequestManagerClassName, glideType,
+            methodToOverride.getSimpleName().toString(),
+            parameter.getSimpleName())
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
new file mode 100644
index 000000000..afae52f38
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
@@ -0,0 +1,109 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.List;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates an empty class with an annotation containing the class names of one or more
+ * LibraryGlideModules and/or one or more GlideExtensions.
+ *
+ * <p>We use a separate class so that LibraryGlideModules and GlideExtensions written in libraries
+ * can be bundled into an AAR and later retrieved by the annotation processor when it processes the
+ * AppGlideModule in an application.
+ *
+ * <p>The output file generated by this class with a LibraryGlideModule looks like this:
+ * <pre>
+ * <code>
+ *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
+ *      modules = "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule"
+ *  )
+ *  public class Indexer_GlideModule_com_bumptech_glide_integration_okhttp3_OkHttpLibraryGlideModule
+ *  {
+ *  }
+ * </code>
+ * </pre>
+ *
+ * <p>The output file generated by this class with a GlideExtension looks like this:
+ * <pre>
+ * <code>
+ *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
+ *      extensions = "com.bumptech.glide.integration.gif.GifOptions"
+ *  )
+ *  public class Indexer_GlideExtension_com_bumptech_glide_integration_gif_GifOptions {
+ *  }
+ * </code>
+ * </pre>
+ * </p>
+ */
+final class IndexerGenerator {
+  private static final String INDEXER_NAME_PREFIX = "GlideIndexer_";
+  private final ProcessorUtil processorUtil;
+
+  IndexerGenerator(ProcessorUtil processorUtil) {
+    this.processorUtil = processorUtil;
+  }
+
+  TypeSpec generate(List<TypeElement> types) {
+    List<TypeElement> modules =  new ArrayList<>();
+    List<TypeElement> extensions = new ArrayList<>();
+    for (TypeElement element : types) {
+      if (processorUtil.isExtension(element)) {
+        extensions.add(element);
+      } else if (processorUtil.isLibraryGlideModule(element)) {
+        modules.add(element);
+      } else {
+        throw new IllegalArgumentException("Unrecognized type: " + element);
+      }
+    }
+    if (!modules.isEmpty() && !extensions.isEmpty()) {
+      throw new IllegalArgumentException("Given both modules and extensions, expected one or the "
+          + "other. Modules: " + modules + " Extensions: " + extensions);
+    }
+    if (!modules.isEmpty()) {
+      return generate(types, GlideModule.class);
+    } else {
+      return generate(types, GlideExtension.class);
+    }
+  }
+
+  private static TypeSpec generate(List<TypeElement> libraryModules,
+      Class<? extends Annotation> annotation) {
+    AnnotationSpec.Builder annotationBuilder =
+        AnnotationSpec.builder(Index.class);
+
+    String value = getAnnotationValue(annotation);
+    for (TypeElement childModule : libraryModules) {
+      annotationBuilder.addMember(value, "$S", ClassName.get(childModule).toString());
+    }
+
+    String indexerName = INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_";
+    for (TypeElement element : libraryModules) {
+      indexerName += element.getQualifiedName().toString().replace(".", "_");
+      indexerName += "_";
+    }
+    indexerName = indexerName.substring(0, indexerName.length() - 1);
+
+    return TypeSpec.classBuilder(indexerName)
+        .addAnnotation(annotationBuilder.build())
+        .addModifiers(Modifier.PUBLIC)
+        .build();
+  }
+
+  private static String getAnnotationValue(Class<? extends Annotation> annotation) {
+    if (annotation == GlideModule.class) {
+      return "modules";
+    } else if (annotation == GlideExtension.class) {
+      return "extensions";
+    } else {
+      throw new IllegalArgumentException("Unrecognized annotation: " + annotation);
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
new file mode 100644
index 000000000..8f79cb7e2
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates Indexer classes annotated with {@link Index} for all
+ * {@link LibraryGlideModule}s.
+ */
+final class LibraryModuleProcessor {
+  private ProcessorUtil processorUtil;
+  private IndexerGenerator indexerGenerator;
+
+  LibraryModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+    this.processorUtil = processorUtil;
+    this.indexerGenerator = indexerGenerator;
+  }
+
+  boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
+     // Order matters here, if we find an Indexer below, we return before writing the root module.
+    // If we fail to add to appModules before then, we might accidentally skip a valid RootModule.
+    List<TypeElement> libraryGlideModules = new ArrayList<>();
+    for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+      // Root elements are added separately and must be checked separately because they're sub
+      // classes of LibraryGlideModules.
+      if (processorUtil.isAppGlideModule(element)) {
+        continue;
+      } else if (!processorUtil.isLibraryGlideModule(element)) {
+        throw new IllegalStateException("@GlideModule can only be applied to LibraryGlideModule"
+            + " and AppGlideModule implementations, not: " + element);
+      }
+
+      libraryGlideModules.add(element);
+    }
+
+    processorUtil.debugLog("got child modules: " + libraryGlideModules);
+    if (libraryGlideModules.isEmpty()) {
+      return false;
+    }
+
+    TypeSpec indexer = indexerGenerator.generate(libraryGlideModules);
+    processorUtil.writeIndexer(indexer);
+    processorUtil.debugLog("Wrote an Indexer this round, skipping the app module to ensure all "
+        + "indexers are found");
+     // If I write an Indexer in a round in the target package, then try to find all classes in
+    // the target package, my newly written Indexer won't be found. Since we wrote a class with
+    // an Annotation handled by this processor, we know we will be called again in the next round
+    // and we can safely wait to write our AppGlideModule until then.
+    return true;
+  }
+
+  Set<String> getSupportedAnnotationTypes() {
+    return Collections.singleton(GlideModule.class.getName());
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
new file mode 100644
index 000000000..5229afc21
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -0,0 +1,364 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor.DEBUG;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.sun.tools.javac.code.Attribute;
+import com.sun.tools.javac.code.Type.ClassType;
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+/**
+ * Utilities for writing classes and logging.
+ */
+final class ProcessorUtil {
+  private static final String GLIDE_MODULE_PACKAGE_NAME = "com.bumptech.glide.module";
+  private static final String APP_GLIDE_MODULE_SIMPLE_NAME = "AppGlideModule";
+  private static final String LIBRARY_GLIDE_MODULE_SIMPLE_NAME = "LibraryGlideModule";
+  private static final String APP_GLIDE_MODULE_QUALIFIED_NAME =
+      GLIDE_MODULE_PACKAGE_NAME + "." + APP_GLIDE_MODULE_SIMPLE_NAME;
+  private static final String LIBRARY_GLIDE_MODULE_QUALIFIED_NAME =
+      GLIDE_MODULE_PACKAGE_NAME + "." + LIBRARY_GLIDE_MODULE_SIMPLE_NAME;
+  private static final String COMPILER_PACKAGE_NAME =
+      GlideAnnotationProcessor.class.getPackage().getName();
+
+  private final ProcessingEnvironment processingEnv;
+  private final TypeElement appGlideModuleType;
+  private final TypeElement libraryGlideModuleType;
+  private int round;
+
+  ProcessorUtil(ProcessingEnvironment processingEnv) {
+    this.processingEnv = processingEnv;
+
+    appGlideModuleType =
+        processingEnv.getElementUtils().getTypeElement(APP_GLIDE_MODULE_QUALIFIED_NAME);
+    libraryGlideModuleType =
+        processingEnv.getElementUtils().getTypeElement(LIBRARY_GLIDE_MODULE_QUALIFIED_NAME);
+  }
+
+  void process() {
+    round++;
+  }
+
+  boolean isAppGlideModule(TypeElement element) {
+    return processingEnv.getTypeUtils().isAssignable(element.asType(),
+        appGlideModuleType.asType());
+  }
+
+  boolean isLibraryGlideModule(TypeElement element) {
+    return processingEnv.getTypeUtils().isAssignable(element.asType(),
+        libraryGlideModuleType.asType());
+  }
+
+  boolean isExtension(TypeElement element) {
+    return element.getAnnotation(GlideExtension.class) != null;
+  }
+
+  void writeIndexer(TypeSpec indexer) {
+    writeClass(COMPILER_PACKAGE_NAME, indexer);
+  }
+
+  void writeClass(String packageName, TypeSpec clazz) {
+    try {
+      debugLog("Writing class:\n" + clazz);
+      JavaFile.builder(packageName, clazz).build().writeTo(processingEnv.getFiler());
+    } catch (Throwable e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  List<ExecutableElement> findAnnotatedElementsInClasses(
+      Set<String> classNames, Class<? extends Annotation> annotationClass) {
+    List<ExecutableElement> result = new ArrayList<>();
+    for (String glideExtensionClassName : classNames) {
+      TypeElement glideExtension = processingEnv.getElementUtils()
+          .getTypeElement(glideExtensionClassName);
+      for (Element element : glideExtension.getEnclosedElements()) {
+        if (element.getAnnotation(annotationClass) != null) {
+          result.add((ExecutableElement) element);
+        }
+      }
+    }
+    return result;
+  }
+
+  List<TypeElement> getElementsFor(
+      Class<? extends Annotation> clazz, RoundEnvironment env) {
+    Collection<? extends Element> annotatedElements = env.getElementsAnnotatedWith(clazz);
+    return ElementFilter.typesIn(annotatedElements);
+  }
+
+  /**
+   * Generates a Javadoc code block for generated methods that delegate to methods in
+   * {@link GlideExtension}s.
+   *
+   * <p>The generated block looks something like this:
+   * <pre>
+   * <code>
+   *   {@literal @see} com.extension.package.name.ExtensionClassName#extensionMethod(arg1, argN)
+   * </code>
+   * </pre>
+   *
+   * @param method The method from the {@link GlideExtension} annotated class that the generated
+   * method this Javadoc will be attached to delegates to.
+   */
+  CodeBlock generateSeeMethodJavadoc(ExecutableElement method) {
+    // Use the simple name of the containing type instead of just the containing type's TypeMirror
+    // so that we avoid appending <CHILD> or other type arguments to the class and breaking
+    // Javadoc's linking.
+    // With this we get @see RequestOptions#methodName().
+    // With just ClassName.get(element.getEnclosingElement().asType()), we get:
+    // @see RequestOptions<CHILD>#methodName().
+    return generateSeeMethodJavadoc(getJavadocSafeName(method.getEnclosingElement()),
+        method.getSimpleName().toString(), method.getParameters());
+  }
+
+  /**
+   * Generates a Javadoc block for generated methods that delegate to other methods.
+   *
+   * <p>The generated block looks something like this:
+   * <pre>
+   * <code>
+   *     {@literal @see} com.package.ClassContainingMethod.methodSimpleName(
+   *         methodParam1, methodParamN)
+   * </code>
+   * </pre>
+   * @param nameOfClassContainingMethod The simple class name of the class containing the method
+   * without any generic types like {@literal <T>}.
+   * @param methodSimpleName The name of the method.
+   * @param methodParameters A maybe empty list of all the parameters for the method in question.
+   */
+  CodeBlock generateSeeMethodJavadoc(
+      TypeName nameOfClassContainingMethod, String methodSimpleName,
+      List<? extends VariableElement> methodParameters) {
+    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
+        methodSimpleName, Lists.transform(methodParameters,
+            new Function<VariableElement, Object>() {
+              @Override
+              public Object apply(VariableElement input) {
+                return getJavadocSafeName(input);
+              }
+            }));
+  }
+
+  CodeBlock generateSeeMethodJavadoc(
+      TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {
+    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
+        methodSpec.name, Lists.transform(methodSpec.parameters,
+            new Function<ParameterSpec, Object>() {
+              @Override
+              public Object apply(ParameterSpec input) {
+                return input.type;
+              }
+            }));
+  }
+
+  private CodeBlock generateSeeMethodJavadocInternal(
+      TypeName nameOfClassContainingMethod, String methodName,
+      List<Object> safeParameterNames) {
+     String javadocString = "@see $T#$L(";
+    List<Object> javadocArgs = new ArrayList<>();
+    javadocArgs.add(nameOfClassContainingMethod);
+    javadocArgs.add(methodName);
+
+    for (Object param : safeParameterNames) {
+      javadocString += "$T, ";
+      javadocArgs.add(param);
+    }
+    if (javadocArgs.size() > 2) {
+      javadocString = javadocString.substring(0, javadocString.length() - 2);
+    }
+    javadocString += ")\n";
+    return CodeBlock.of(javadocString, javadocArgs.toArray(new Object[0]));
+  }
+
+
+   /**
+   * Returns a safe String to use in a Javadoc that will function in a link.
+   *
+   * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>}
+   * in {@literal RequestOptions<T>} for example).
+   */
+  private TypeName getJavadocSafeName(Element element) {
+    Types typeUtils = processingEnv.getTypeUtils();
+    TypeMirror type = element.asType();
+    if (typeUtils.asElement(type) == null) {
+      // If there is no Element, it's a primitive and can't have additional types, so we're done.
+      return ClassName.get(element.asType());
+    }
+    Name simpleName = typeUtils.asElement(type).getSimpleName();
+    return ClassName.bestGuess(simpleName.toString());
+  }
+
+  void debugLog(String toLog) {
+    if (DEBUG) {
+      infoLog(toLog);
+    }
+  }
+
+  void infoLog(String toLog) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "[" + round + "] " + toLog);
+  }
+
+  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeElement returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findStaticMethodsReturning(TypeElement clazz, TypeElement returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.STATIC))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findStaticMethods(TypeElement clazz) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods((TypeMirror) null /*returnType*/, MethodType.STATIC))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  Set<String> findClassValuesFromAnnotationOnClassAsNames(
+      Element clazz, Class<? extends Annotation> annotationClass) {
+    String annotationClassName = annotationClass.getName();
+    AnnotationValue excludedModuleAnnotationValue = null;
+    for (AnnotationMirror annotationMirror : clazz.getAnnotationMirrors()) {
+      // Two different AnnotationMirrors the same class might not be equal, so compare Strings
+      // instead. This check is necessary because a given class may have multiple Annotations.
+      if (!annotationClassName.equals(annotationMirror.getAnnotationType().toString())) {
+        continue;
+      }
+      Set<? extends Map.Entry<? extends ExecutableElement, ? extends AnnotationValue>> values =
+          annotationMirror.getElementValues().entrySet();
+      // Excludes has only one value. If we ever change that, we'd need to iterate over all
+      // values in the entry set and compare the keys to whatever our Annotation's attribute is
+      // (usually value).
+      if (values.size() != 1) {
+        throw new IllegalArgumentException("Expected single value, but found: " + values);
+      }
+      excludedModuleAnnotationValue = values.iterator().next().getValue();
+      if (excludedModuleAnnotationValue == null) {
+        throw new NullPointerException("Failed to find Excludes#value");
+      }
+    }
+    if (excludedModuleAnnotationValue == null) {
+      return Collections.emptySet();
+    }
+    Object value = excludedModuleAnnotationValue.getValue();
+    if (value instanceof List) {
+      List values = (List) value;
+      Set<String> result = new HashSet<>(values.size());
+      for (Object current : values) {
+        Attribute.Class currentClass = (Attribute.Class) current;
+        result.add(currentClass.getValue().toString());
+      }
+      return result;
+    } else {
+      ClassType classType = (ClassType) value;
+      return Collections.singleton(classType.toString());
+    }
+  }
+
+  private enum MethodType {
+    STATIC,
+    INSTANCE
+  }
+
+  private final class FilterPublicMethods implements Predicate<Element> {
+    @Nullable
+    private final TypeMirror returnType;
+    private final MethodType methodType;
+
+    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType)  {
+      this.returnType = returnType;
+      this.methodType = methodType;
+    }
+
+    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType)  {
+      this(returnType != null ? returnType.asType() : null, methodType);
+    }
+
+    @Override
+    public boolean apply(@Nullable Element input) {
+      if (input == null
+          || input.getKind() != ElementKind.METHOD
+          || !input.getModifiers().contains(Modifier.PUBLIC)) {
+        return false;
+      }
+      boolean isStatic = input.getModifiers().contains(Modifier.STATIC);
+      if (methodType == MethodType.STATIC && !isStatic) {
+        return false;
+      } else if (methodType == MethodType.INSTANCE && isStatic) {
+        return false;
+      }
+      ExecutableElement method = (ExecutableElement) input;
+      if (returnType == null) {
+        return true;
+      }
+      return isReturnValueTypeMatching(method, returnType);
+    }
+  }
+
+  boolean isReturnValueTypeMatching(ExecutableElement method, TypeElement expectedReturnType) {
+    return isReturnValueTypeMatching(method, expectedReturnType.asType());
+  }
+
+  private boolean isReturnValueTypeMatching(
+      ExecutableElement method, TypeMirror expectedReturnType) {
+    return processingEnv.getTypeUtils().isAssignable(
+        method.getReturnType(), expectedReturnType);
+  }
+
+  private static final class ToMethod implements Function<Element, ExecutableElement> {
+
+    @Nullable
+    @Override
+    public ExecutableElement apply(@Nullable Element input) {
+      return (ExecutableElement) input;
+    }
+  }
+
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
new file mode 100644
index 000000000..21c147ddc
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -0,0 +1,351 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import com.squareup.javapoet.WildcardTypeName;
+import java.io.File;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Generates a {@link com.bumptech.glide.RequestBuilder} subclass containing all methods from
+ * the base class, all methods from {@link com.bumptech.glide.request.RequestOptions} and all
+ * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated
+ * classes.
+ *
+ * <p>Generated code looks like this:
+ * <pre>
+ * <code>
+ * public final class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> {
+ *   GlideRequest(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+ *     super(transcodeClass, other);
+ *   }
+ *
+ *   GlideRequest(GlideContext context, RequestManager requestManager,
+ *       Class<TranscodeType> transcodeClass) {
+ *     super(context, requestManager ,transcodeClass);
+ *   }
+ *
+ *   {@literal @Override}
+ *   protected GlideRequest<File> getDownloadOnlyRequest() {
+ *    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+ *   }
+ *
+ *   /**
+ *    * {@literal @see} GlideOptions#dontAnimate()
+ *    *\/
+ *   public GlideRequest<TranscodeType> dontAnimate() {
+ *     if (getMutableOptions() instanceof GlideOptions) {
+ *       this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+ *     } else {
+ *       this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+ *     }
+ *     return this;
+ *   }
+ *
+ *   /**
+ *    * {@literal @see} RequestOptions#sizeMultiplier(float)
+ *    *\/
+ *   public GlideRequest<TranscodeType> sizeMultiplier(float sizeMultiplier) {
+ *     this.requestOptions = getMutableOptions().sizeMultiplier(sizeMultiplier);
+ *     return this;
+ *   }
+ *
+ *   ...
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestBuilderGenerator {
+  private static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  private static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
+
+  private static final String REQUEST_BUILDER_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String REQUEST_BUILDER_SIMPLE_NAME = "RequestBuilder";
+  static final String REQUEST_BUILDER_QUALIFIED_NAME =
+      REQUEST_BUILDER_PACKAGE_NAME + "." + REQUEST_BUILDER_SIMPLE_NAME;
+
+  // Uses package private methods and variables.
+  private static final String GENERATED_REQUEST_BUILDER_SIMPLE_NAME = "GlideRequest";
+
+  /**
+   * An arbitrary name of the Generic type in the generated RequestBuilder.
+   * e.g. RequestBuilder<TranscodeType>
+   */
+  private static final String TRANSCODE_TYPE_NAME = "TranscodeType";
+  /** A set of method names to avoid overriding from RequestOptions. */
+  private static final ImmutableSet<String> EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS =
+      ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private ClassName generatedRequestBuilderClassName;
+  private final TypeVariableName transcodeTypeName;
+  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;
+  private final TypeElement requestOptionsType;
+  private final TypeElement requestBuilderType;
+  private ClassName requestOptionsClassName;
+
+  RequestBuilderGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    requestBuilderType = processingEnv.getElementUtils()
+        .getTypeElement(REQUEST_BUILDER_QUALIFIED_NAME);
+
+    transcodeTypeName = TypeVariableName.get(TRANSCODE_TYPE_NAME);
+
+    requestOptionsType = processingEnv.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {
+    generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);
+    generatedRequestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);
+
+    if (generatedOptions != null) {
+      requestOptionsClassName =
+          ClassName.get(generatedCodePackageName, generatedOptions.name);
+    } else {
+      requestOptionsClassName =
+          ClassName.get(
+              RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,
+              RequestBuilderGenerator.REQUEST_OPTIONS_SIMPLE_NAME);
+    }
+
+    ParameterizedTypeName requestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(
+            ClassName.get(REQUEST_BUILDER_PACKAGE_NAME, REQUEST_BUILDER_SIMPLE_NAME),
+            transcodeTypeName);
+
+    return TypeSpec.classBuilder(GENERATED_REQUEST_BUILDER_SIMPLE_NAME)
+        .addJavadoc("Contains all public methods from {@link $T}, all options from\n",
+            requestBuilderType)
+        .addJavadoc("{@link $T} and all generated options from\n", requestOptionsType)
+        .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class)
+        .addJavadoc("{@link $T} annotated classes.\n", GlideExtension.class)
+        .addJavadoc("\n")
+        .addJavadoc("<p>Generated code, do not modify.\n")
+        .addJavadoc("\n")
+        .addJavadoc("@see $T\n", requestBuilderType)
+        .addJavadoc("@see $T\n", requestOptionsType)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "unused")
+                .addMember("value", "$S", "deprecation")
+                .build())
+        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addTypeVariable(transcodeTypeName)
+        .superclass(requestBuilderOfTranscodeType)
+        .addMethods(generateConstructors())
+        .addMethod(generateDownloadOnlyRequestMethod())
+        .addMethods(generateGeneratedRequestOptionsEquivalents(generatedOptions))
+        .addMethods(generateRequestBuilderOverrides())
+        .build();
+  }
+
+  /**
+   * Generates overrides of all methods in {@link com.bumptech.glide.RequestBuilder} that return
+   * {@link com.bumptech.glide.RequestBuilder} so that they return our generated subclass instead.
+   */
+  private List<MethodSpec> generateRequestBuilderOverrides() {
+    TypeMirror rawRequestBuilderType =
+        processingEnv.getTypeUtils().erasure(requestBuilderType.asType());
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestBuilderType, rawRequestBuilderType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestBuilderOverride(input);
+          }
+        });
+  }
+
+  /**
+   * Generates an override of a particular method in {@link com.bumptech.glide.RequestBuilder} that
+   * returns {@link com.bumptech.glide.RequestBuilder} so that it returns our generated subclass
+   * instead.
+   */
+  private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOverride) {
+    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // exactly one type argument, so this is safe unless those assumptions change.
+    TypeMirror typeArgument =
+        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
+
+    ParameterizedTypeName generatedRequestBuilderOfType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
+
+    return MethodSpec.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(",
+                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build())
+        .build();
+  }
+
+  /**
+   * Generates methods with equivalent names and arguments to methods annotated with
+   * {@link GlideOption} in
+   * {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
+   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   */
+  private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(
+      @Nullable final TypeSpec generatedOptions) {
+    if (generatedOptions == null) {
+      return Collections.emptyList();
+    }
+    return FluentIterable
+        .from(generatedOptions.methodSpecs)
+        .filter(new Predicate<MethodSpec>() {
+          @Override
+          public boolean apply(MethodSpec input) {
+            return isUsefulGeneratedRequestOption(input);
+          }
+        })
+        .transform(new Function<MethodSpec, MethodSpec>() {
+          @Override
+          public MethodSpec apply(MethodSpec input) {
+            return generateGeneratedRequestOptionEquivalent(input);
+          }
+        })
+        .toList();
+  }
+
+  /**
+   * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our
+   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   *
+   * <p>Only newly generated methods will be included in the generated
+   * {@link com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
+   * methods that override other methods to avoid duplicates.
+   */
+  private boolean isUsefulGeneratedRequestOption(MethodSpec requestOptionMethod) {
+    return
+        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionMethod.name)
+        && requestOptionMethod.hasModifier(Modifier.PUBLIC)
+        && !requestOptionMethod.hasModifier(Modifier.STATIC)
+        && requestOptionMethod.returnType.toString()
+            .equals(requestOptionsClassName.toString());
+  }
+
+   /**
+   * Generates a particular method with  an equivalent name and arguments to the given method
+   * from the generated {@link com.bumptech.glide.request.BaseRequestBuilder} subclass.
+   */
+  private MethodSpec generateGeneratedRequestOptionEquivalent(MethodSpec requestOptionMethod) {
+    CodeBlock callRequestOptionsMethod = CodeBlock.builder()
+        .add(".$N(", requestOptionMethod.name)
+        .add(FluentIterable.from(requestOptionMethod.parameters)
+            .transform(new Function<ParameterSpec, String>() {
+              @Override
+              public String apply(ParameterSpec input) {
+                return input.name;
+              }
+            })
+            .join(Joiner.on(", ")))
+        .add(");\n")
+        .build();
+
+    return MethodSpec.methodBuilder(requestOptionMethod.name)
+        .addJavadoc(
+            processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod))
+        .addModifiers(Modifier.PUBLIC)
+        .addTypeVariables(requestOptionMethod.typeVariables)
+        .addParameters(requestOptionMethod.parameters)
+        .returns(generatedRequestBuilderOfTranscodeType)
+        .beginControlFlow(
+            "if (getMutableOptions() instanceof $T)", requestOptionsClassName)
+        .addCode("this.requestOptions = (($T) getMutableOptions())",
+            requestOptionsClassName)
+        .addCode(callRequestOptionsMethod)
+        .nextControlFlow("else")
+        .addCode(CodeBlock.of("this.requestOptions = new $T().apply(this.requestOptions)",
+            requestOptionsClassName))
+        .addCode(callRequestOptionsMethod)
+        .endControlFlow()
+        .addStatement("return this")
+        .build();
+  }
+
+  private List<MethodSpec> generateConstructors() {
+    ParameterizedTypeName classOfTranscodeType =
+        ParameterizedTypeName.get(ClassName.get(Class.class), transcodeTypeName);
+
+    TypeName wildcardOfObject = WildcardTypeName.subtypeOf(Object.class);
+    ParameterizedTypeName requestBuilderOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(requestBuilderType), wildcardOfObject);
+
+    MethodSpec firstConstructor =
+        MethodSpec.constructorBuilder()
+            .addParameter(classOfTranscodeType, "transcodeClass")
+            .addParameter(requestBuilderOfWildcardOfObject, "other")
+        .addStatement("super($N, $N)", "transcodeClass", "other")
+        .build();
+
+    ClassName glide = ClassName.get("com.bumptech.glide", "Glide");
+    ClassName requestManager = ClassName.get("com.bumptech.glide", "RequestManager");
+    MethodSpec secondConstructor =
+        MethodSpec.constructorBuilder()
+            .addParameter(glide, "glide")
+            .addParameter(requestManager, "requestManager")
+            .addParameter(classOfTranscodeType, "transcodeClass")
+            .addStatement("super($N, $N ,$N)", "glide", "requestManager", "transcodeClass")
+            .build();
+    return ImmutableList.of(firstConstructor, secondConstructor);
+  }
+
+  /**
+   * Overrides the protected downloadOnly method in {@link com.bumptech.glide.RequestBuilder} to
+   * return our generated subclass instead.
+   */
+  private MethodSpec generateDownloadOnlyRequestMethod() {
+    ParameterizedTypeName generatedRequestBuilderOfFile
+        = ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
+    return MethodSpec.methodBuilder("getDownloadOnlyRequest")
+        .addAnnotation(Override.class)
+        .returns(generatedRequestBuilderOfFile)
+        .addModifiers(Modifier.PROTECTED)
+        .addStatement("return new $T<>($T.class, $N).apply($N)",
+            generatedRequestBuilderClassName, File.class, "this",
+            "DOWNLOAD_ONLY_OPTIONS")
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
new file mode 100644
index 000000000..a86bb1a37
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
@@ -0,0 +1,89 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates an implementation of
+ * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
+ * generated {@link com.bumptech.glide.RequestManager} implementation.
+ *
+ * <p>Generated {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ * classes look like this:
+ * <pre>
+ * <code>
+ * public class GeneratedRequestManagerFactory
+ *     implements RequestManagerRetriever.RequestManagerFactory {
+ *   {@literal @Override}
+ *   public RequestManager build(Glide glide, Lifecycle lifecycle,
+ *       RequestManagerTreeNode treeNode) {
+ *     return new GeneratedRequestManager(glide, lifecycle, treeNode);
+ *   }
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestManagerFactoryGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+  private static final String LIFECYCLE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.Lifecycle";
+  private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerTreeNode";
+  private static final String REQUEST_MANAGER_FACTORY_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME =
+      "com.bumptech.glide";
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME =
+      "GeneratedRequestManagerFactory";
+
+  private final TypeElement glideType;
+  private final TypeElement lifecycleType;
+  private final TypeElement requestManagerTreeNodeType;
+  private final TypeElement requestManagerFactoryInterface;
+  private final ClassName requestManagerClassName;
+
+  RequestManagerFactoryGenerator(ProcessingEnvironment processingEnv) {
+    Elements elementUtils = processingEnv.getElementUtils();
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+    lifecycleType = elementUtils.getTypeElement(LIFECYCLE_QUALIFIED_NAME);
+    requestManagerTreeNodeType =
+        elementUtils.getTypeElement(REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME);
+
+    requestManagerFactoryInterface =
+        elementUtils.getTypeElement(REQUEST_MANAGER_FACTORY_QUALIFIED_NAME);
+
+    TypeElement requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+    requestManagerClassName = ClassName.get(requestManagerType);
+
+  }
+
+  TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestManagerSpec) {
+    return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME)
+        .addModifiers(Modifier.FINAL)
+        .addSuperinterface(ClassName.get(requestManagerFactoryInterface))
+        .addJavadoc("Generated code, do not modify\n")
+        .addMethod(
+            MethodSpec.methodBuilder("build")
+                .addModifiers(Modifier.PUBLIC)
+                .addAnnotation(Override.class)
+                .returns(requestManagerClassName)
+                .addParameter(ClassName.get(glideType), "glide")
+                .addParameter(ClassName.get(lifecycleType), "lifecycle")
+                .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                .addStatement(
+                    "return new $T(glide, lifecycle, treeNode)",
+                    ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name))
+                .build()
+        )
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
new file mode 100644
index 000000000..9bc11e7dc
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -0,0 +1,296 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates an implementation of {@link com.bumptech.glide.RequestManager} that contains generated
+ * methods from {@link GlideExtension}s and {@link GlideType}.
+ *
+ * <p>Generated {@link com.bumptech.glide.RequestManager} implementations look like this:
+ * <pre>
+ * <code>
+ * public final class GeneratedRequestManager extends RequestManager {
+ *   GeneratedRequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+ *     super(glide, lifecycle, treeNode);
+ *   }
+ *
+ *   public RequestBuilder<GifDrawable> asGif() {
+ *     RequestBuilder<GifDrawable> requestBuilder = this.as(GifDrawable.class);
+ *     GifOptions.asGif(requestBuilder);
+ *     return requestBuilder;
+ *   }
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestManagerGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+  private static final String LIFECYCLE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.Lifecycle";
+  private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerTreeNode";
+
+  private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME =
+      "GlideRequests";
+
+  private ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final ClassName requestManagerClassName;
+  private final TypeElement lifecycleType;
+  private final TypeElement requestManagerTreeNodeType;
+  private final TypeElement glideType;
+  private final TypeElement requestManagerType;
+  private final TypeElement requestBuilderType;
+  private ClassName generatedRequestBuilderClassName;
+
+  RequestManagerGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    Elements elementUtils = processingEnv.getElementUtils();
+
+    requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+    requestManagerClassName = ClassName.get(requestManagerType);
+
+    lifecycleType = elementUtils.getTypeElement(LIFECYCLE_QUALIFIED_NAME);
+    requestManagerTreeNodeType =
+        elementUtils.getTypeElement(REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME);
+
+    requestBuilderType =
+        elementUtils.getTypeElement(RequestBuilderGenerator.REQUEST_BUILDER_QUALIFIED_NAME);
+
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+  }
+
+  @Nullable
+  TypeSpec generate(
+      String generatedCodePackageName, @Nullable TypeSpec requestOptions, TypeSpec requestBuilder,
+      Set<String> glideExtensions) {
+    generatedRequestBuilderClassName = ClassName.get(generatedCodePackageName, requestBuilder.name);
+    return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_SIMPLE_NAME)
+         .superclass(requestManagerClassName)
+         .addJavadoc("Includes all additions from methods in {@link $T}s\n"
+                 + "annotated with {@link $T}\n"
+                 + "\n"
+                 + "<p>Generated code, do not modify\n",
+             GlideExtension.class, GlideType.class)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build())
+         .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+         .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
+         .addMethod(generateCallSuperConstructor())
+         .addMethods(generateAdditionalRequestManagerMethods(glideExtensions))
+         .addMethods(generateRequestManagerMethodOverrides())
+         .addMethods(
+             FluentIterable.from(
+                 Collections.singletonList(
+                     generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
+                 .filter(Predicates.<MethodSpec>notNull()))
+         .build();
+  }
+
+  private MethodSpec generateCallSuperConstructor() {
+    return MethodSpec.constructorBuilder()
+        .addModifiers(Modifier.PUBLIC)
+        .addParameter(ClassName.get(glideType), "glide")
+        .addParameter(ClassName.get(lifecycleType), "lifecycle")
+        .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
+        .addStatement("super(glide, lifecycle, treeNode)")
+        .build();
+  }
+
+  private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec requestBuilder) {
+    TypeVariableName resourceType = TypeVariableName.get("ResourceType");
+    ParameterizedTypeName classOfResouceType = ParameterizedTypeName
+        .get(ClassName.get(Class.class), resourceType);
+
+    ClassName generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, requestBuilder.name);
+
+    ParameterizedTypeName requestBuilderOfResourceType = ParameterizedTypeName
+        .get(generatedRequestBuilderClassName, resourceType);
+
+    return MethodSpec.methodBuilder("as")
+        .addModifiers(Modifier.PUBLIC)
+        .addAnnotation(Override.class)
+        .addTypeVariable(TypeVariableName.get("ResourceType"))
+        .addParameter(classOfResouceType, "resourceClass")
+        .returns(requestBuilderOfResourceType)
+        .addStatement("return new $T<>(glide, this, resourceClass)",
+            this.generatedRequestBuilderClassName)
+        .build();
+  }
+
+  private List<MethodSpec> generateRequestManagerMethodOverrides() {
+    // Without the erasure, this is a RequestBuilder<Y>. A RequestBuilder<X> is not assignable to a
+    // RequestBuilder<Y>. After type erasure this is a RequestBuilder. A RequestBuilder<X> is
+    // assignable to the raw RequestBuilder.
+    TypeMirror rawRequestBuilder = processingEnv.getTypeUtils()
+        .erasure(requestBuilderType.asType());
+
+    final TypeElement classType =
+        processingEnv.getElementUtils().getTypeElement(Class.class.getCanonicalName());
+    final TypeMirror rawClassType = processingEnv.getTypeUtils().erasure(classType.asType());
+
+    return FluentIterable.from(
+        processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
+        .filter(new Predicate<ExecutableElement>() {
+          @Override
+          public boolean apply(ExecutableElement input) {
+            // Skip the <T> as(Class<T>) method.
+            return !input.getSimpleName().toString().equals("as")
+                || input.getParameters().size() != 1
+                || !processingEnv.getTypeUtils().isAssignable(
+                    input.getParameters().get(0).asType(), rawClassType);
+          }
+        })
+        .transform(new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestManagerMethodOverride(input);
+          }
+        })
+        .toList();
+  }
+
+  /**
+   * Generates overrides of existing RequestManager methods so that they return our generated
+   * RequestBuilder subtype.
+   */
+  private MethodSpec generateRequestManagerMethodOverride(ExecutableElement methodToOverride) {
+     // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // exactly one type argument, so this is safe unless those assumptions change.
+    TypeMirror typeArgument =
+        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
+
+    ParameterizedTypeName generatedRequestBuilderOfType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
+
+    return MethodSpec.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(",
+                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build())
+        .build();
+  }
+
+  private List<MethodSpec> generateAdditionalRequestManagerMethods(
+      Set<String> glideExtensions) {
+    List<ExecutableElement> requestManagerExtensionMethods =
+        processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);
+
+    return Lists.transform(requestManagerExtensionMethods,
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateAdditionalRequestManagerMethod(input);
+          }
+        });
+  }
+
+  // Generates methods added to RequestManager via GlideExtensions.
+  private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement extensionMethod) {
+    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
+        GlideType.class).iterator().next();
+    ClassName returnTypeClassName = ClassName.bestGuess(returnType);
+    ParameterizedTypeName parameterizedTypeName =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
+
+    return MethodSpec.methodBuilder(extensionMethod.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC)
+        .returns(parameterizedTypeName)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addStatement(
+            "$T requestBuilder = this.as($T.class)", parameterizedTypeName, returnTypeClassName)
+        .addStatement("$T.$N(requestBuilder)",
+            extensionMethod.getEnclosingElement(), extensionMethod.getSimpleName())
+        .addStatement("return requestBuilder")
+        .build();
+  }
+
+  /**
+   * The {@link com.bumptech.glide.request.RequestOptions} subclass should always be our
+   * generated subclass type to avoid inadvertent errors where a different subclass is applied that
+   * accidentally wipes out some logic in overidden methods in our generated subclass.
+   */
+  @Nullable
+  private MethodSpec generateOverrideSetRequestOptions(
+      String generatedCodePackageName, @Nullable TypeSpec generatedRequestOptions) {
+    if (generatedRequestOptions == null) {
+      return null;
+    }
+
+    Elements elementUtils = processingEnv.getElementUtils();
+    TypeElement requestOptionsType =
+            elementUtils.getTypeElement(
+                RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
+    TypeElement androidNonNullType =
+            elementUtils.getTypeElement("android.support.annotation.NonNull");
+
+    // This class may have just been generated and therefore may not be found if we try to obtain
+    // it via Elements, so use just the String version instead.
+    String generatedRequestOptionsQualifiedName =
+        generatedCodePackageName + "." + generatedRequestOptions.name;
+
+    String methodName = "setRequestOptions";
+    String parameterName = "toSet";
+
+    return MethodSpec.methodBuilder(methodName)
+        .addAnnotation(Override.class)
+        .addModifiers(Modifier.PROTECTED)
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(requestOptionsType), parameterName)
+                .addAnnotation(ClassName.get(androidNonNullType))
+                .build())
+        .beginControlFlow("if ($N instanceof $L)",
+            parameterName, generatedRequestOptionsQualifiedName)
+        .addStatement("super.$N($N)", methodName, parameterName)
+        .nextControlFlow("else")
+        .addStatement("super.setRequestOptions(new $L().apply($N))",
+            generatedRequestOptionsQualifiedName, parameterName)
+        .endControlFlow()
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
new file mode 100644
index 000000000..b9d7e913d
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -0,0 +1,614 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;
+import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_NONE;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
+import com.google.common.base.Strings;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.CodeBlock.Builder;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * Generates a new implementation of {@link com.bumptech.glide.request.RequestOptions}
+ * containing static versions of methods included in the base class and static and instance versions
+ * of all methods annotated with {@link GlideOption} in classes annotated with
+ * {@link GlideExtension}.
+ *
+ * <p>The generated class looks something like this:
+ * <pre>
+ * <code>
+ * public final class GlideOptions extends com.bumptech.glide.request.RequestOptions {
+ *
+ *   public static com.google.android.apps.photos.glide.GlideOptions signatureOf(
+ *       com.bumptech.glide.load.Key arg0) {
+ *     return new com.google.android.apps.photos.glide.GlideOptions()
+ *         .apply(com.bumptech.glide.request.RequestOptions.signatureOf(arg0));
+ *   }
+ *
+ *   ... // The rest of the static versions of methods from RequestOptions go here.
+ *
+ *   // Now on to methods generated from an extension:
+ *   public com.bumptech.glide.GlideOptions dontAnimate() {
+ *     com.bumptech.glide.integration.gifdecoder.GifOptions.dontAnimate(this);
+ *     return this;
+ *   }
+ *
+ *   public static com.bumptech.glide.GlideOptions noAnimation() {
+ *     return new com.bumptech.glide.GlideOptions().dontAnimate();
+ *   }
+ * }
+ * </code>
+ * </pre>
+ * </p>
+ */
+final class RequestOptionsGenerator {
+  private static final String GENERATED_REQUEST_OPTIONS_SIMPLE_NAME = "GlideOptions";
+  static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
+
+  private final ProcessingEnvironment processingEnvironment;
+  private final ClassName requestOptionsName;
+  private final TypeElement requestOptionsType;
+  private final ProcessorUtil processorUtil;
+  private ClassName glideOptionsName;
+  private int nextStaticFieldUniqueId;
+
+  RequestOptionsGenerator(
+      ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
+    this.processingEnvironment = processingEnvironment;
+    this.processorUtil = processorUtil;
+
+    requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME,
+        REQUEST_OPTIONS_SIMPLE_NAME);
+
+    requestOptionsType = processingEnvironment.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(String generatedCodePackageName, Set<String> glideExtensionClassNames) {
+    glideOptionsName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_OPTIONS_SIMPLE_NAME);
+
+    List<MethodAndStaticVar> methodsForExtensions =
+        generateMethodsForExtensions(glideExtensionClassNames);
+
+    Set<MethodSignature> extensionMethodSignatures = ImmutableSet.copyOf(
+        Iterables.transform(methodsForExtensions,
+            new Function<MethodAndStaticVar, MethodSignature>() {
+              @Nullable
+              @Override
+              public MethodSignature apply(MethodAndStaticVar f) {
+                return new MethodSignature(f.method);
+              }
+            }));
+
+    List<MethodAndStaticVar> staticOverrides = generateStaticMethodOverridesForRequestOptions();
+    List<MethodSpec> instanceOverrides = generateInstanceMethodOverridesForRequestOptions();
+
+    List<MethodAndStaticVar> allMethodsAndStaticVars = new ArrayList<>();
+    for (MethodAndStaticVar item : staticOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(item.method))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(item);
+    }
+    for (MethodSpec methodSpec : instanceOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(methodSpec))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(new MethodAndStaticVar(methodSpec));
+    }
+    allMethodsAndStaticVars.addAll(methodsForExtensions);
+
+    TypeSpec.Builder classBuilder = TypeSpec.classBuilder(GENERATED_REQUEST_OPTIONS_SIMPLE_NAME)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build())
+        .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
+        .addModifiers(Modifier.FINAL)
+        .addModifiers(Modifier.PUBLIC)
+        .superclass(requestOptionsName);
+
+    for (MethodAndStaticVar methodAndStaticVar : allMethodsAndStaticVars) {
+      if (methodAndStaticVar.method != null) {
+        classBuilder.addMethod(methodAndStaticVar.method);
+      }
+      if (methodAndStaticVar.staticField != null) {
+        classBuilder.addField(methodAndStaticVar.staticField);
+      }
+    }
+    return classBuilder.build();
+  }
+
+  private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
+    Builder builder = CodeBlock.builder()
+        .add("Automatically generated from {@link $T} annotated classes.\n",
+            GlideExtension.class)
+        .add("\n")
+        .add("@see $T\n", requestOptionsName);
+
+    for (String glideExtensionClass : glideExtensionClassNames) {
+      builder.add("@see $T\n", ClassName.bestGuess(glideExtensionClass));
+    }
+    return builder.build();
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForExtensions(
+      Set<String> glideExtensionClassNames) {
+    List<ExecutableElement> requestOptionExtensionMethods =
+        processorUtil.findAnnotatedElementsInClasses(
+            glideExtensionClassNames, GlideOption.class);
+
+    List<MethodAndStaticVar> result = new ArrayList<>(requestOptionExtensionMethods.size());
+    for (ExecutableElement requestOptionsExtensionMethod : requestOptionExtensionMethods) {
+      result.addAll(generateMethodsForRequestOptionsExtension(requestOptionsExtensionMethod));
+    }
+
+    return result;
+  }
+
+  private List<MethodSpec> generateInstanceMethodOverridesForRequestOptions() {
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestOptionsType, requestOptionsType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestOptionOverride(input);
+          }
+        });
+  }
+
+  private MethodSpec generateRequestOptionOverride(ExecutableElement methodToOverride) {
+    return MethodSpec.overriding(methodToOverride)
+        .returns(glideOptionsName)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(", glideOptionsName, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build())
+        .build();
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtension(
+      ExecutableElement element) {
+    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);
+    int overrideType = getOverrideType(element);
+    if (isOverridingRequestOptionsMethod && overrideType == OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Accidentally attempting to override a method in"
+          + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
+          + " if this is intentional. Offending method: "
+          + element.getEnclosingElement() + "#" + element);
+    } else if (!isOverridingRequestOptionsMethod && overrideType != OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Requested to override an existing method in"
+          + " RequestOptions, but no such method was found. Offending method: "
+          + element.getEnclosingElement() + "#" + element);
+    }
+    String methodName = element.getSimpleName().toString();
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addModifiers(Modifier.PUBLIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+        .returns(glideOptionsName);
+
+    // The 0th element is expected to be a RequestOptions object.
+    List<? extends VariableElement> parameters =
+        element.getParameters().subList(1, element.getParameters().size());
+
+    // Add the correct super() call.
+    if (overrideType == OVERRIDE_EXTEND) {
+      String callSuper = "super.$L(";
+      List<Object> args = new ArrayList<>();
+      args.add(element.getSimpleName().toString());
+      if (!parameters.isEmpty()) {
+        for (VariableElement variable : parameters) {
+          callSuper += "$L, ";
+          args.add(variable.getSimpleName().toString());
+        }
+        callSuper = callSuper.substring(0, callSuper.length() - 2);
+      }
+      callSuper += ")";
+
+      builder.addStatement(callSuper, args.toArray(new Object[0]))
+          .addJavadoc(processorUtil.generateSeeMethodJavadoc(
+              requestOptionsName, methodName, parameters))
+          .addAnnotation(Override.class);
+    }
+
+    for (VariableElement variable : parameters) {
+      builder.addParameter(getParameterSpec(variable));
+    }
+
+    // Adds: <AnnotatedClass>.<thisMethodName>(RequestOptions<?>, <arg1>, <arg2>, <argN>);
+    List<Object> args = new ArrayList<>();
+    String code = "$T.$L($L, ";
+    args.add(ClassName.get(element.getEnclosingElement().asType()));
+    args.add(element.getSimpleName().toString());
+    args.add("this");
+    if (!parameters.isEmpty()) {
+      for (VariableElement variable : parameters) {
+        code += "$L, ";
+        args.add(variable.getSimpleName().toString());
+      }
+    }
+    code = code.substring(0, code.length() - 2);
+    code += ")";
+    builder.addStatement(code, args.toArray(new Object[0]));
+
+    builder.addStatement("return this");
+
+    List<MethodAndStaticVar> result = new ArrayList<>();
+
+    result.add(new MethodAndStaticVar(builder.build()));
+    result.add(generateStaticMethodEquivalentForExtensionMethod(element));
+
+    return result;
+  }
+
+  private List<MethodAndStaticVar> generateStaticMethodOverridesForRequestOptions() {
+    List<ExecutableElement> staticMethodsThatReturnRequestOptions =
+        processorUtil.findStaticMethodsReturning(requestOptionsType, requestOptionsType);
+    List<MethodAndStaticVar> staticMethods = new ArrayList<>();
+    for (ExecutableElement element : staticMethodsThatReturnRequestOptions) {
+      if (element.getAnnotation(Deprecated.class) != null) {
+        continue;
+      }
+      staticMethods.add(generateStaticMethodEquivalentForRequestOptionsStaticMethod(element));
+    }
+    return staticMethods;
+  }
+
+  /**
+   * This method is a bit of a hack, but it lets us tie the static version of a method with the
+   * instance version. In turn that lets us call the instance versions on the generated subclass,
+   * instead of just delegating to the RequestOptions static methods. Using the instance methods
+   * on the generated subclass allows our static methods to properly call code that overrides
+   * an existing method in RequestOptions.
+   *
+   * <p>The string names here just map between the static methods in
+   * {@link com.bumptech.glide.request.RequestOptions} and the instance methods they call.
+   */
+  private static String getInstanceMethodNameFromStaticMethodName(String staticMethodName) {
+    String equivalentInstanceMethodName;
+    if ("bitmapTransform".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "transform";
+    } else if ("decodeTypeOf".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "decode";
+    } else if (staticMethodName.endsWith("Transform")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 9);
+    } else if (staticMethodName.endsWith("Of")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 2);
+    } else if ("noTransformation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontTransform";
+    } else if ("noAnimation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontAnimate";
+    } else if (staticMethodName.equals("option")) {
+      equivalentInstanceMethodName = "set";
+    } else {
+      throw new IllegalArgumentException("Unrecognized static method name: " + staticMethodName);
+    }
+    return equivalentInstanceMethodName;
+  }
+
+  private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStaticMethod(
+      ExecutableElement staticMethod) {
+    boolean memoize = memoizeStaticMethodFromArguments(staticMethod);
+    String staticMethodName = staticMethod.getSimpleName().toString();
+
+    String equivalentInstanceMethodName =
+        getInstanceMethodNameFromStaticMethodName(staticMethodName);
+
+    MethodSpec.Builder methodSpecBuilder =
+        MethodSpec.methodBuilder(staticMethodName)
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
+        .returns(glideOptionsName);
+
+    List<? extends VariableElement> parameters = staticMethod.getParameters();
+    String createNewOptionAndCall = "new $T().$N(";
+    if (!parameters.isEmpty()) {
+      for (VariableElement parameter : parameters) {
+        methodSpecBuilder.addParameter(getParameterSpec(parameter));
+        createNewOptionAndCall += parameter.getSimpleName().toString();
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall += ".getApplicationContext()";
+        }
+        createNewOptionAndCall += ", ";
+      }
+      createNewOptionAndCall =
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
+    }
+    createNewOptionAndCall += ")";
+
+    FieldSpec requiredStaticField = null;
+    if (memoize) {
+      // Generates code that looks like:
+      // if (GlideOptions.<methodName> == null) {
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
+      // }
+
+      // Mix in an incrementing unique id to handle method overloading.
+      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
+          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+          .build();
+      methodSpecBuilder.beginControlFlow(
+          "if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName, staticVariableName, glideOptionsName, equivalentInstanceMethodName,
+              "autoClone()")
+          .endControlFlow()
+          .addStatement("return $T.$N", glideOptionsName, staticVariableName);
+    } else {
+      // Generates code that looks like:
+      // return new GlideOptions().<methodName>()
+      methodSpecBuilder.addStatement(
+          "return " + createNewOptionAndCall, glideOptionsName, equivalentInstanceMethodName);
+    }
+
+    List<? extends TypeParameterElement> typeParameters = staticMethod.getTypeParameters();
+    for (TypeParameterElement typeParameterElement : typeParameters) {
+      methodSpecBuilder.addTypeVariable(
+          TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
+    }
+
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
+  }
+
+  private static boolean memoizeStaticMethodFromArguments(ExecutableElement staticMethod) {
+    return staticMethod.getParameters().isEmpty()
+        || (staticMethod.getParameters().size() == 1
+        && staticMethod.getParameters().get(0).getSimpleName().toString()
+        .equals("android.content.Context"));
+  }
+
+  private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
+      ExecutableElement instanceMethod) {
+    boolean skipStaticMethod = skipStaticMethod(instanceMethod);
+    if (skipStaticMethod) {
+      return new MethodAndStaticVar();
+    }
+    String staticMethodName = getStaticMethodName(instanceMethod);
+    String instanceMethodName = instanceMethod.getSimpleName().toString();
+    if (Strings.isNullOrEmpty(staticMethodName)) {
+      if (instanceMethodName.startsWith("dont")) {
+        staticMethodName = "no" + instanceMethodName.replace("dont", "");
+      } else {
+        staticMethodName = instanceMethodName + "Of";
+      }
+    }
+    boolean memoize = memoizeStaticMethodFromAnnotation(instanceMethod);
+
+    MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
+        .returns(glideOptionsName);
+
+    List<? extends VariableElement> parameters = instanceMethod.getParameters();
+
+    // Always remove the first parameter because it's always RequestOptions in extensions. The
+    // actual method we want to generate will pass the RequestOptions in to the extension method,
+    // but should not itself require a RequestOptions object to be passed in.
+    if (parameters.isEmpty()) {
+      throw new IllegalArgumentException(
+          "Expected non-empty parameters for: " + instanceMethod);
+    }
+    // Remove is not supported.
+    parameters = parameters.subList(1, parameters.size());
+
+    String createNewOptionAndCall = "new $T().$L(";
+    if (!parameters.isEmpty()) {
+      for (VariableElement parameter : parameters) {
+        methodSpecBuilder.addParameter(getParameterSpec(parameter));
+        createNewOptionAndCall += parameter.getSimpleName().toString();
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall += ".getApplicationContext()";
+        }
+        createNewOptionAndCall += ", ";
+      }
+      createNewOptionAndCall =
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
+    }
+    createNewOptionAndCall += ")";
+
+    FieldSpec requiredStaticField = null;
+    if (memoize) {
+      // if (GlideOptions.<methodName> == null) {
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
+      // }
+
+      // Mix in an incrementing unique id to handle method overloading.
+      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
+          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+          .build();
+      methodSpecBuilder.beginControlFlow(
+          "if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName, staticVariableName, glideOptionsName, instanceMethodName,
+              "autoClone()")
+          .endControlFlow()
+          .addStatement("return $T.$N", glideOptionsName, staticVariableName);
+    } else {
+      // return new GlideOptions().<methodName>()
+      methodSpecBuilder.addStatement(
+          "return " + createNewOptionAndCall, glideOptionsName, instanceMethodName);
+    }
+
+    List<? extends TypeParameterElement> typeParameters = instanceMethod.getTypeParameters();
+    for (TypeParameterElement typeParameterElement : typeParameters) {
+      methodSpecBuilder.addTypeVariable(
+          TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
+    }
+
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
+  }
+
+  private boolean isAndroidContext(VariableElement variableElement) {
+    Element element = processingEnvironment.getTypeUtils().asElement(variableElement.asType());
+    return element.toString().equals("android.content.Context");
+  }
+
+  private boolean isMethodInRequestOptions(ExecutableElement toFind) {
+    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
+    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
+    // first type.
+    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
+    String toFindSimpleName = toFind.getSimpleName().toString();
+    for (Element element : requestOptionsType.getEnclosedElements()) {
+      if (element.getKind() != ElementKind.METHOD) {
+        continue;
+      }
+      ExecutableElement inBase = (ExecutableElement) element;
+      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
+        List<String> parameterNamesInBase =
+            getComparableParameterNames(inBase, false /*skipFirst*/);
+        if (parameterNamesInBase.equals(toFindParameterNames)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private static ParameterSpec getParameterSpec(VariableElement variable) {
+    return ParameterSpec.builder(
+        TypeName.get(variable.asType()), variable.getSimpleName().toString()).build();
+  }
+
+  private static List<String> getComparableParameterNames(
+      ExecutableElement element, boolean skipFirst) {
+    List<? extends VariableElement> parameters = element.getParameters();
+    if (skipFirst) {
+      parameters = parameters.subList(1, parameters.size());
+    }
+    List<String> result = new ArrayList<>(parameters.size());
+    for (VariableElement parameter : parameters) {
+      result.add(parameter.asType().toString());
+    }
+    return result;
+  }
+
+  private static int getOverrideType(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption.override();
+  }
+
+  @Nullable
+  private static String getStaticMethodName(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    String result = glideOption != null ? glideOption.staticMethodName() : null;
+    return Strings.emptyToNull(result);
+  }
+
+  private static boolean memoizeStaticMethodFromAnnotation(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption != null && glideOption.memoizeStaticMethod();
+  }
+
+  private static boolean skipStaticMethod(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption != null && glideOption.skipStaticMethod();
+  }
+
+  private static final class MethodAndStaticVar {
+    @Nullable
+    final MethodSpec method;
+    @Nullable
+    final FieldSpec staticField;
+
+    MethodAndStaticVar() {
+      this(null /*method*/);
+    }
+
+    MethodAndStaticVar(@Nullable MethodSpec method) {
+      this(method, null /*staticField*/);
+    }
+
+    MethodAndStaticVar(@Nullable MethodSpec method, @Nullable FieldSpec staticField) {
+      this.method = method;
+      this.staticField = staticField;
+    }
+  }
+
+  private static final class MethodSignature {
+    private final TypeName returnType;
+    private final List<TypeName> parameterTypes;
+    private final Set<Modifier> modifiers;
+    private final String name;
+
+    MethodSignature(MethodSpec spec) {
+      name = spec.name;
+      modifiers = spec.modifiers;
+      returnType = spec.returnType;
+      parameterTypes =
+          Lists.transform(spec.parameters, new Function<ParameterSpec, TypeName>() {
+            @Nullable
+            @Override
+            public TypeName apply(ParameterSpec parameterSpec) {
+              return parameterSpec.type;
+
+            }
+          });
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof MethodSignature) {
+        MethodSignature other = (MethodSignature) o;
+        return name.equals(other.name)
+            && returnType.equals(other.returnType)
+            && parameterTypes.equals(other.parameterTypes)
+            && modifiers.equals(other.modifiers);
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hashCode(name, returnType, parameterTypes, modifiers);
+    }
+  }
+}
diff --git a/annotation/gradle.properties b/annotation/gradle.properties
new file mode 100644
index 000000000..d43789528
--- /dev/null
+++ b/annotation/gradle.properties
@@ -0,0 +1,5 @@
+POM_NAME=Glide Annotations
+POM_ARTIFACT_ID=annotations
+POM_PACKAGING=jar
+POM_DESCRIPTION=A set of annotations for configuring Glide.
+GROUP=com.github.bumptech.glide.annotation
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
new file mode 100644
index 000000000..0a15f5a0d
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Specifies a set of GlideModule and/or LibraryGlideModule classes that should be excluded
+ * from an application.
+ *
+ * <p>Used only on AppGlideModules. Adding this annotation to other classes will have no affect.
+ *
+ * <p>Cannot be used to exclude AppGlideModules (there must be at most one per Application anyway).
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Excludes {
+  Class[] value();
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
new file mode 100644
index 000000000..bb525c849
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicate a class that extends Glide's public API.
+ *
+ * @see GlideOption
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.SOURCE)
+public @interface GlideExtension { }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
new file mode 100644
index 000000000..690b8f727
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies AppGlideModules and ChildeGlideModules for Glide's annotation processor to merge at
+ * compile time.
+ *
+ * <p>Replaces <meta-data /> tags in AndroidManifest.xml.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.SOURCE)
+public @interface GlideModule {
+  /**
+   * Returns the name of the class that will be used as a replacement for
+   * {@link com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
+   */
+  String glideName() default "GlideApp";
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
new file mode 100644
index 000000000..50bfbecb0
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
@@ -0,0 +1,83 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies methods in {@link GlideExtension} annotated classes that extend
+ * {@link com.bumptech.glide.request.RequestOptions}.
+ *
+ * <p>All annotated methods will be added to a single
+ * {@link com.bumptech.glide.request.RequestOptions} implementation generated per application.
+ * Overlapping method names in different extensions may cause errors at compile time.
+ *
+ * <p>Static equivalents of annotated methods will also be generated.
+ *
+ * <p>Methods with this annotation will only be found if they belong to classes annotated with
+ * {@link GlideExtension}.
+ */
+@Target(ElementType.METHOD)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+public @interface GlideOption {
+   /** Does not intend to override a method in a super class. */
+  int OVERRIDE_NONE = 0;
+  /** Expects to call super and then add additional functionality to an overridden method. */
+  int OVERRIDE_EXTEND = 1;
+  /** Expects to not call super and replace an overridden method. */
+  int OVERRIDE_REPLACE = 2;
+
+  /**
+   * Determines how and whether a generated method should extend a method from it's parent.
+   *
+   * <p>Must be one of {@link #OVERRIDE_NONE}, {@link #OVERRIDE_EXTEND}, {@link #OVERRIDE_REPLACE}.
+   *
+   * <p>The extended method is determined by String and argument matching against methods in the
+   * extended class. If {@link #OVERRIDE_NONE} is used and the method and arguments match a method
+   * in the extended class, a compile time error will result. Similarly if any other override type
+   * is used and no method/arguments in the extended class match, a compile time error will result.
+   */
+  int override() default OVERRIDE_NONE;
+
+  /**
+   * Sets the name for the generated static version of this method.
+   *
+   * <p>If this value is not set, the static method name is just the original method name with "Of"
+   * appended.
+   */
+  String staticMethodName() default "";
+
+  /**
+   * {@code true} to indicate that it's safe to statically memoize the result of this method using
+   * {@link com.bumptech.glide.request.RequestOptions#autoClone()}.
+   *
+   * <p>This method should only be used for no-arg methods where there's only a single possible
+   * value.
+   *
+   * <p>Memoization can save object allocations for frequently used options.
+   */
+  boolean memoizeStaticMethod() default false;
+
+  /**
+   * {@code true} to prevent a static builder method from being generated.
+   *
+   * <p>By default static methods are generated for all methods annotated with
+   * {@link GlideOption}. These static factory methods allow for a cleaner API when used
+   * with {@link com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
+   * simply creates a new {@link com.bumptech.glide.request.RequestOptions} object, calls the
+   * instance version of the method on it and returns it. For example:
+   * <pre>
+   * <code>
+   * public static GlideOptions noAnimation() {
+   *   return new GlideOptions().dontAnimate();
+   * }
+   * </code>
+   * </pre>
+   *
+   * @see #memoizeStaticMethod()
+   * @see #staticMethodName()
+   */
+  boolean skipStaticMethod() default false;
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
new file mode 100644
index 000000000..f0c19a599
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
@@ -0,0 +1,39 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies methods in {@link GlideExtension} annotated classes that extend
+ * {@link com.bumptech.glide.RequestManager}.
+ *
+ * <p>If one or more method is found with this annotation, an additional API entry point that
+ * exposes a generated {@link com.bumptech.glide.RequestManager} subclass will be created. The
+ * generated API entry point acts as a drop in replacement for Glide. Glide.with(fragment) becomes
+ * GlideApp.with(fragment). Although the Glide.with variant will still be available, only the new
+ * API entry point will provide access to these additional methods.
+ *
+ * <p>The name of the API entry point created when one of these methods is found can be controlled
+ * by {@link GlideModule#glideName()}.
+ *
+ * <p>Methods with this annotation will only be found if they are contained in a class annotated
+ * with {@link GlideExtension}.
+ *
+ * <p>Methods annotated with GlideType must have a single parameter. The type of the
+ * single parameter must be {@link com.bumptech.glide.request.RequestOptions}, with a type
+ * matching the value of {@link #value()}.
+ */
+@Target(ElementType.METHOD)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+public @interface GlideType {
+
+  /**
+   * A Resource class name, like GifDrawable.class, Bitmap.class etc.
+   *
+   * <p>Must match the type of the {@link com.bumptech.glide.request.RequestOptions} parameter.
+   */
+  Class<?> value();
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
new file mode 100644
index 000000000..81ba54ae1
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used to retrieve LibraryGlideModule and GlideExtension classes in our annotation processor from
+ * libraries and applications.
+ *
+ * <p>Part of the internals of Glide's annotation processor and not for public use.
+ */
+@Target(ElementType.TYPE)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+@interface Index {
+  String[] modules() default {};
+  String[] extensions() default {};
+}
diff --git a/build.gradle b/build.gradle
index 72e455faf..de9f3c9d1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -9,7 +9,6 @@ buildscript {
     dependencies {
         classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}"
         classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}"
-        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}"
     }
 }
 
@@ -65,11 +64,14 @@ subprojects { project ->
 
     gradle.projectsEvaluated {
         tasks.withType(JavaCompile) {
-            if (!name.contains('Test')) {
-                options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
-            }
+            options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
         }
     }
+
+    // We generate a combined javadoc, no need to create javadocs for each library independently.
+    if (!project.name.equals('glide')) {
+        tasks.withType(Javadoc).all { enabled = false }
+    }
 }
 
 task wrapper(type: Wrapper) {
diff --git a/checkstyle.xml b/checkstyle.xml
index a3c9878b7..b5285c17f 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -96,7 +96,7 @@
 
           <property name="sortStaticImportsAlphabetically" value="true"/>
            <property name="severity" value="error"/>
-           <property name="groups" value="com.google,*,java,javax"/>
+           <property name="groups" value="*"/>
            <!-- This ensures that static imports go first. -->
            <property name="option" value="top"/>
            <property name="tokens" value="STATIC_IMPORT, IMPORT"/>
diff --git a/glide/build.gradle b/glide/build.gradle
index be3f5da1c..4e8216ad8 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -1,69 +1,142 @@
 apply plugin: 'java'
 
-evaluationDependsOn(':third_party:gif_decoder')
-evaluationDependsOn(':third_party:disklrucache')
-evaluationDependsOn(':library')
+// The paths of Android projects that should be included in the jar and javadoc.
+static def getAndroidPathsForJar() {
+    [':third_party:gif_decoder', ':library']
+}
+
+// The paths of Java projects that should be included in the jar and javadoc.
+static def getJavaPathsForJar() {
+    [':third_party:disklrucache']
+}
+
+// The paths of Android projects that should be included only in Javadoc, not in the jar.
+static def getAndroidPathsForJavadoc() {
+    [
+            ':integration:okhttp',
+            ':integration:okhttp3',
+            ':integration:volley',
+            ':integration:gifencoder'
+    ]
+}
+
+// The paths of Java projects that should be included only in Javadoc, not in the jar.
+static def getJavaPathsForJavadoc() {
+    [':annotation', ':annotation:compiler']
+}
+
+(getAndroidPathsForJavadoc() + getAndroidPathsForJar() +
+        getJavaPathsForJar() + getJavaPathsForJavadoc()).forEach {
+    evaluationDependsOn(it)
+}
+
+def asProjects(paths) {
+    paths.collect { project(it) }
+}
 
 def getAndroidSdkDirectory() {
-  project(':library').android.sdkDirectory
+    project(':library').android.sdkDirectory
 }
 
 def getAndroidCompileSdkVersion() {
-  project(':library').android.compileSdkVersion
+    project(':library').android.compileSdkVersion
+}
+
+def getInternalAndroidProjectsForJar() {
+    asProjects(getAndroidPathsForJar())
 }
 
-def getInternalAndroidProjects() {
-    [':third_party:gif_decoder', ':library'].collect { project(it) }
+def getInternalJavaProjectsForJar() {
+    asProjects(getJavaPathsForJar())
 }
-def getInternalJavaProjects() {
-    [':third_party:disklrucache'].collect { project(it) }
+
+def getInternalAndroidProjectsForJavadoc() {
+    asProjects(getAndroidPathsForJavadoc())
+}
+
+def getInternalJavaProjectsForJavadoc() {
+    asProjects(getJavaPathsForJavadoc())
 }
 
-def getAllInternalProjects() {
-    getInternalAndroidProjects() + getInternalJavaProjects()
+def getReleaseVariantAndroidProjectsForJar() {
+    getAndroidLibraryVariantsForJar('release')
 }
 
-def getReleaseVariantAndroidProjects() {
-    getAndroidLibraryVariants('release')
+def getAndroidLibraryVariantsForJar(variantName) {
+    getAndroidLibraryVariants(getInternalAndroidProjectsForJar(), variantName)
 }
 
-def getAndroidLibraryVariants(variantName) {
-    getInternalAndroidProjects().collect { project ->
+def getAndroidLibraryVariantsForJavadoc(variantName) {
+    getAndroidLibraryVariants(getInternalAndroidProjectsForJavadoc(), variantName)
+}
+
+static def getAndroidLibraryVariants(projects, variantName) {
+    projects.collect { project ->
         project.android.libraryVariants.findAll { type ->
             type.buildType.name.equalsIgnoreCase(variantName)
         }
     }.sum()
 }
 
-def getSourceFilesForVariant(variantName) {
-    getAndroidLibraryVariants(variantName).collect { it.javaCompile.source } +
-            getInternalJavaProjects().collect { it.sourceSets.main.allJava }
+def getSourceFilesForVariantJar(variantName) {
+    getAndroidLibraryVariantsForJar(variantName).collect { it.javaCompile.source } +
+            getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }
+}
+
+def getSourceFilesForVariantJavadoc(variantName) {
+    getAndroidLibraryVariantsForJavadoc(variantName).collect { it.javaCompile.source } +
+            getInternalJavaProjectsForJavadoc().collect { it.sourceSets.main.allJava }
 }
 
 def getAndroidJar() {
     "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar"
 }
 
+def getSupportJar() {
+    "${getAndroidSdkDirectory()}/extras/android/support/v4/android-support-v4.jar"
+}
+
 project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
 
-// Generate javadocs and sources containing batched documentation and sources for all internal projects.
+// Generate javadocs and sources containing batched documentation and sources for all internal
+// projects.
 ['release', 'debug'].each { variantName ->
 
     task("${variantName}SourceJar", type: Jar) {
-      from getSourceFilesForVariant(variantName)
+      from getSourceFilesForVariantJar(variantName)
     }
 
     def javadocTask = task("${variantName}Javadoc", type: Javadoc) {
-        source = getSourceFilesForVariant(variantName)
+        source = getSourceFilesForVariantJar(variantName)
+        source += getSourceFilesForVariantJavadoc(variantName)
 
-        classpath = files(getAndroidLibraryVariants(variantName).collect {
-            files(it.javaCompile.classpath.files, getAndroidJar())
+        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {
+            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
+        })
+        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {
+            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
         })
-        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }
+        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {
+            it.sourceSets.main.compileClasspath.files
+        }.flatten())
+        classpathFiles += (getInternalJavaProjectsForJar().collect {
+            it.sourceSets.main.compileClasspath.files
+        }.flatten())
+        // Finds dependencies of Android packages that would otherwise be ignored (Volley in
+        // particular)
+        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {
+            files("${it.projectDir}/build/intermediates/classes/release")
+        }
+        classpath = files(classpathFiles)
 
         options {
             links("http://docs.oracle.com/javase/7/docs/api/")
-            linksOffline("http://d.android.com/reference", "${getAndroidSdkDirectory()}/docs/reference")
+            links("https://square.github.io/okhttp/3.x/okhttp/")
+            links("https://square.github.io/okhttp/2.x/okhttp/")
+            // TODO: Ideally this would point to something hosted by Android.
+            links("http://afzaln.com/volley/")
+            linksOffline("http://d.android.com/reference",
+                    "${getAndroidSdkDirectory()}/docs/reference")
         }
 
         exclude '**/BuildConfig.java'
@@ -76,23 +149,30 @@ project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
     clean.dependsOn(cleanJavadocTask)
 
     def javadocJarTask = task("${variantName}JavadocJar", type: Jar) {
-      from javadocTask.destinationDir
+        from javadocTask.destinationDir
     } as Task
     javadocJarTask.dependsOn(javadocTask)
 }
 
 jar {
     from files(
-            getReleaseVariantAndroidProjects().collect { variant ->
+            getReleaseVariantAndroidProjectsForJar().collect { variant ->
                 variant.javaCompile.destinationDir
             }
     )
     exclude "**/R.class"
     exclude "**/BuildConfig.class"
-    from files(getInternalJavaProjects().collect { it.sourceSets.main.output })
+    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output })
+}
+
+def getAllInternalProjectBuildDeps() {
+    getInternalAndroidProjectsForJar() + getInternalJavaProjectsForJar() +
+            getInternalJavaProjectsForJavadoc() + getInternalAndroidProjectsForJavadoc()
 }
 
-getAllInternalProjects().each { project ->
+getAllInternalProjectBuildDeps().each { project ->
+    releaseJavadoc.dependsOn(project.tasks.assemble)
+    debugJavadoc.dependsOn(project.tasks.assemble)
     jar.dependsOn(project.tasks.build)
 }
 
diff --git a/gradle.properties b/gradle.properties
index aab6d6df7..609cc1234 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -15,26 +15,25 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
-
-SUPPORT_V4_VERSION=22.2.0
-SUPPORT_V7_VERSION=22.2.0
-VOLLEY_VERSION=1.0.16
+SUPPORT_V4_VERSION=25.3.1
+SUPPORT_V7_VERSION=25.3.1
+VOLLEY_VERSION=1.0.0
 OK_HTTP_VERSION=3.0.1
-# TODO: use this in library/build.gradle.
-ANDROID_GRADLE_VERSION=1.2.3
+ANDROID_GRADLE_VERSION=2.3.0
 
-ROBOLECTRIC_GRADLE_VERSION=1.1.0
 COVERALLS_GRADLE_VERSION=2.4.0
 JUNIT_VERSION=4.12
 MOCKITO_VERSION=1.10.19
-ROBOLECTRIC_VERSION=3.0-rc3
+ROBOLECTRIC_VERSION=3.3.2
 MOCKWEBSERVER_VERSION=3.0.0-RC1
 TRUTH_VERSION=0.26
 
 FINDBUGS_VERSION=3.0.0
 JACOCO_VERSION=0.7.1.201405082137
 
-COMPILE_SDK_VERSION=22
-BUILD_TOOLS_VERSION=22.0.1
-TARGET_SDK_VERSION=22
-MIN_SDK_VERSION=10
+COMPILE_SDK_VERSION=25
+BUILD_TOOLS_VERSION=25.0.2
+TARGET_SDK_VERSION=25
+MIN_SDK_VERSION=14
+
+org.gradle.jvmargs=-Xmx2048M
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 63c5ca6b5..06cc66097 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Nov 25 12:48:39 CET 2015
+#Fri Mar 31 22:27:21 PDT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.9-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index 0eddb12b8..7219f4ffa 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
 
 dependencies {
     compile project(':library')
diff --git a/integration/gifencoder/gradle.properties b/integration/gifencoder/gradle.properties
index 9687ee227..1ceaa1dac 100644
--- a/integration/gifencoder/gradle.properties
+++ b/integration/gifencoder/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide GifEncoder Integration
 POM_ARTIFACT_ID=gifencoder-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library allowing users to re-encode or create animated GIFs
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index f3ca40290..9051d5f12 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -1,11 +1,12 @@
 package com.bumptech.glide.integration.gifencoder;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.util.Log;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
 import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
@@ -20,7 +21,6 @@
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.ByteBufferUtil;
 import com.bumptech.glide.util.LogTime;
-
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -59,15 +59,17 @@ public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest)
   private static final Factory FACTORY = new Factory();
   private static final String TAG = "GifEncoder";
   private final GifDecoder.BitmapProvider provider;
+  private Context context;
   private final BitmapPool bitmapPool;
   private final Factory factory;
 
-  public ReEncodingGifResourceEncoder(BitmapPool bitmapPool) {
-    this(bitmapPool, FACTORY);
+  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {
+    this(context, bitmapPool, FACTORY);
   }
 
   // Visible for testing.
-  ReEncodingGifResourceEncoder(BitmapPool bitmapPool, Factory factory) {
+  ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {
+    this.context = context;
     this.bitmapPool = bitmapPool;
     provider = new GifBitmapProvider(bitmapPool);
     this.factory = factory;
@@ -115,7 +117,7 @@ private boolean encodeTransformedToFile(GifDrawable drawable, File file) {
 
     }
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Re-encoded gif with " + drawable.getFrameCount() + " frames and "
+      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and "
           + drawable.getBuffer().limit() + " bytes in " + LogTime.getElapsedMillis(startTime)
           + " ms");
     }
@@ -157,7 +159,7 @@ private boolean writeDataDirect(ByteBuffer data, File file) {
       ByteBufferUtil.toFile(data, file);
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Failed to write gif data", e);
+        Log.w(TAG, "Failed to write GIF data", e);
       }
       return false;
     }
@@ -180,8 +182,9 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
       Transformation<Bitmap> transformation, GifDrawable drawable) {
     // TODO: what if current frame is null?
     Resource<Bitmap> bitmapResource = factory.buildFrameResource(currentFrame, bitmapPool);
-    Resource<Bitmap> transformedResource = transformation
-        .transform(bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
+    Resource<Bitmap> transformedResource =
+        transformation.transform(
+            context, bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
     if (!bitmapResource.equals(transformedResource)) {
       bitmapResource.recycle();
     }
@@ -192,7 +195,7 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
   static class Factory {
 
     public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
-      return new GifDecoder(bitmapProvider);
+      return new StandardGifDecoder(bitmapProvider);
     }
 
     public GifHeaderParser buildParser() {
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index 0f9ade749..dde1d0243 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -13,8 +13,9 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
+import android.content.Context;
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
@@ -27,7 +28,10 @@
 import com.bumptech.glide.load.resource.UnitTransformation;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -39,11 +43,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.nio.ByteBuffer;
-
 /**
  * Tests for {@link com.bumptech.glide.integration.gifencoder.ReEncodingGifResourceEncoder}.
  */
@@ -68,6 +67,8 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
+    Application context = RuntimeEnvironment.application;
+
     ReEncodingGifResourceEncoder.Factory factory = mock(ReEncodingGifResourceEncoder.Factory.class);
     when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
     when(factory.buildParser()).thenReturn(parser);
@@ -75,7 +76,8 @@ public void setUp() {
     when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class)))
         .thenReturn(frameResource);
 
-    when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt()))
+    // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!)
+    when(frameTransformation.transform(anyContext(), any(Resource.class), anyInt(), anyInt()))
         .thenReturn(frameResource);
 
     when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
@@ -83,11 +85,11 @@ public void setUp() {
 
     when(resource.get()).thenReturn(gifDrawable);
 
-    encoder = new ReEncodingGifResourceEncoder(mock(BitmapPool.class), factory);
+    encoder = new ReEncodingGifResourceEncoder(context, mock(BitmapPool.class), factory);
     options = new Options();
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, true);
 
-    file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    file = new File(context.getCacheDir(), "test");
   }
 
   @After
@@ -247,7 +249,8 @@ public void testWritesTransformedBitmaps() {
 
     Bitmap transformedFrame = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
     when(transformedResource.get()).thenReturn(transformedFrame);
-    when(frameTransformation.transform(eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
+    when(frameTransformation.transform(
+        anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
         .thenReturn(transformedResource);
     when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
 
@@ -259,7 +262,7 @@ public void testWritesTransformedBitmaps() {
   @Test
   public void testRecyclesFrameResourceBeforeWritingIfTransformedResourceIsDifferent() {
     when(decoder.getFrameCount()).thenReturn(1);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(transformedResource);
     Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
     when(transformedResource.get()).thenReturn(expected);
@@ -278,7 +281,7 @@ public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDi
     when(decoder.getFrameCount()).thenReturn(1);
     Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
     when(transformedResource.get()).thenReturn(expected);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(transformedResource);
 
     when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
@@ -293,7 +296,7 @@ public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDi
   @Test
   public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed() {
     when(decoder.getFrameCount()).thenReturn(1);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(frameResource);
     Bitmap expected = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
     when(frameResource.get()).thenReturn(expected);
@@ -332,4 +335,8 @@ private String getEncodedData() {
       throw new RuntimeException(e);
     }
   }
+
+  private static Context anyContext() {
+    return any(Context.class);
+  }
 }
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index 2a48a7443..c01164e2e 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -2,6 +2,7 @@ apply plugin: 'com.android.library'
 
 dependencies {
     compile project(':library')
+    annotationProcessor project(':annotation:compiler')
 
     compile "com.squareup.okhttp:okhttp:2.7.1"
 }
diff --git a/integration/okhttp/gradle.properties b/integration/okhttp/gradle.properties
index 990db7764..e725ea973 100644
--- a/integration/okhttp/gradle.properties
+++ b/integration/okhttp/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide OkHttp Integration
 POM_ARTIFACT_ID=okhttp-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide
diff --git a/integration/okhttp/src/main/AndroidManifest.xml b/integration/okhttp/src/main/AndroidManifest.xml
index c11d7167d..738e5c900 100644
--- a/integration/okhttp/src/main/AndroidManifest.xml
+++ b/integration/okhttp/src/main/AndroidManifest.xml
@@ -1,9 +1,5 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.bumptech.glide.integration.okhttp">
 
-    <application>
-        <meta-data
-            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule"
-            android:value="GlideModule"/>
-    </application>
+    <application />
 </manifest>
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index 873c58611..9301703b6 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.content.Context;
-
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.module.GlideModule;
-
 import java.io.InputStream;
 
 /**
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
new file mode 100644
index 000000000..5a46639f9
--- /dev/null
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.integration.okhttp;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * Registers OkHttp related classes via Glide's annotation processor.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public class OkHttpLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 3fac54a39..2b1f90a78 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -1,17 +1,16 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
+import com.bumptech.glide.util.Synthetic;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Map;
@@ -26,8 +25,8 @@
   private static final String TAG = "OkHttpFetcher";
   private final OkHttpClient client;
   private final GlideUrl url;
-  private InputStream stream;
-  private ResponseBody responseBody;
+  @Synthetic InputStream stream;
+  @Synthetic ResponseBody responseBody;
 
   public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
     this.client = client;
@@ -37,7 +36,6 @@ public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
   @Override
   public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
-    boolean isUserAgentSet = false;
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
       requestBuilder.addHeader(key, headerEntry.getValue());
@@ -55,9 +53,9 @@ public void onFailure(Request request, IOException e) {
 
       @Override
       public void onResponse(Response response) throws IOException {
+        responseBody = response.body();
         if (response.isSuccessful()) {
-          long contentLength = response.body().contentLength();
-          responseBody = response.body();
+          long contentLength = responseBody.contentLength();
           stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
         } else if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 8a55295e1..48468bf63 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -1,14 +1,11 @@
 package com.bumptech.glide.integration.okhttp;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.squareup.okhttp.OkHttpClient;
-
 import java.io.InputStream;
 
 /**
@@ -69,8 +66,7 @@ public Factory(OkHttpClient client) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
     }
 
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
index 6ef7599ff..59a222795 100644
--- a/integration/okhttp3/build.gradle
+++ b/integration/okhttp3/build.gradle
@@ -2,6 +2,7 @@ apply plugin: 'com.android.library'
 
 dependencies {
     compile project(':library')
+    annotationProcessor project(':annotation:compiler')
 
     compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
 }
diff --git a/integration/okhttp3/gradle.properties b/integration/okhttp3/gradle.properties
index 4e8d18972..f241acfb1 100644
--- a/integration/okhttp3/gradle.properties
+++ b/integration/okhttp3/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide OkHttp 3.x Integration
 POM_ARTIFACT_ID=okhttp3-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library to use OkHttp 3.x to fetch data over http/https in Glide
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
index 17799b54f..1c05bf678 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
-
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.module.GlideModule;
-
 import java.io.InputStream;
 
 /**
@@ -17,7 +15,11 @@
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
  * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ *
+ * @deprecated Replaced by {@link OkHttpLibraryGlideModule} for Applications that use Glide's
+ * annotations.
  */
+@Deprecated
 public class OkHttpGlideModule implements GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
new file mode 100644
index 000000000..911b5acac
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * Registers OkHttp related classes via Glide's annotation processor.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
index 0aa8b2fe3..61adb97b1 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -1,21 +1,20 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
+import com.bumptech.glide.util.Synthetic;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Map;
 import okhttp3.Call;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Map;
-
 /**
  * Fetches an {@link InputStream} using the okhttp library.
  */
@@ -23,8 +22,8 @@
   private static final String TAG = "OkHttpFetcher";
   private final Call.Factory client;
   private final GlideUrl url;
-  private InputStream stream;
-  private ResponseBody responseBody;
+  @Synthetic InputStream stream;
+  @Synthetic ResponseBody responseBody;
   private volatile Call call;
 
   public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
@@ -53,9 +52,9 @@ public void onFailure(Call call, IOException e) {
 
       @Override
       public void onResponse(Call call, Response response) throws IOException {
+        responseBody = response.body();
         if (response.isSuccessful()) {
-          long contentLength = response.body().contentLength();
-          responseBody = response.body();
+          long contentLength = responseBody.contentLength();
           stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
         } else if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
index 984000a46..b63164a59 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -1,17 +1,14 @@
 package com.bumptech.glide.integration.okhttp3;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import java.io.InputStream;
 import okhttp3.Call;
 import okhttp3.OkHttpClient;
 
-import java.io.InputStream;
-
 /**
  * A simple model loader for fetching media over http/https using OkHttp.
  */
@@ -69,8 +66,7 @@ public Factory(Call.Factory client) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
     }
 
diff --git a/integration/recyclerview/gradle.properties b/integration/recyclerview/gradle.properties
index 7bf1e8bea..700106ff1 100644
--- a/integration/recyclerview/gradle.properties
+++ b/integration/recyclerview/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide RecyclerView Integration
 POM_ARTIFACT_ID=recyclerview-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library to display images in RecyclerView.
diff --git a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
index 6e062e393..47be184a7 100644
--- a/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java
@@ -4,7 +4,6 @@
 import android.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v7.widget.RecyclerView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.ListPreloader.PreloadModelProvider;
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index 7c9f79531..8f04a9b1a 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -1,9 +1,9 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
 
 dependencies {
     compile project(':library')
-    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
+    compile "com.android.volley:volley:${VOLLEY_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
diff --git a/integration/volley/gradle.properties b/integration/volley/gradle.properties
index ff93096bd..198619280 100644
--- a/integration/volley/gradle.properties
+++ b/integration/volley/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide Volley Integration
 POM_ARTIFACT_ID=volley-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library to use Volley to fetch data over http/https in Glide
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
index 85f2b5add..669e7b732 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
-
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.module.GlideModule;
-
 import java.io.InputStream;
 
 /**
@@ -16,8 +14,11 @@
  *
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ * information, see {@link com.bumptech.glide.module.GlideModule}.
+ *
+ * @deprecated Replaced with {@link VolleyLibraryGlideModule}.
  */
+@Deprecated
 public class VolleyGlideModule implements GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
new file mode 100644
index 000000000..22f12df4e
--- /dev/null
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.integration.volley;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a
+ * Volley based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public class VolleyLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
+  }
+}
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
index 837efdc8a..bbc313217 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java
@@ -3,7 +3,6 @@
 import com.android.volley.Request;
 import com.android.volley.Request.Priority;
 import com.bumptech.glide.load.data.DataFetcher.DataCallback;
-
 import java.io.InputStream;
 import java.util.Map;
 
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
deleted file mode 100644
index b1cd97f05..000000000
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.bumptech.glide.integration.volley;
-
-import com.android.volley.Request;
-import com.android.volley.Response;
-import com.android.volley.VolleyError;
-
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
-/**
- * TODO: contribute cancel modifications to volley and remove this class.
- *
- * A Future that represents a Volley request.
- *
- * Used by providing as your response and error listeners. For example:
- * <pre>
- * RequestFuture&lt;JSONObject&gt; future = RequestFuture.newFuture();
- * MyRequest request = new MyRequest(URL, future, future);
- *
- * // If you want to be able to cancel the request:
- * future.setRequest(requestQueue.add(request));
- *
- * // Otherwise:
- * requestQueue.add(request);
- *
- * try {
- *   JSONObject response = future.get();
- *   // do something with response
- * } catch (InterruptedException e) {
- *   // handle the error
- * } catch (ExecutionException e) {
- *   // handle the error
- * }
- * </pre>
- *
- * @param <T> The type of parsed response this future expects.
- */
-public class VolleyRequestFuture<T> implements Future<T>,
-    Response.Listener<T>,
-    Response.ErrorListener {
-  private Request<?> mRequest;
-  private boolean mResultReceived = false;
-  private T mResult;
-  private VolleyError mException;
-  private boolean mIsCancelled = false;
-
-  public static <E> VolleyRequestFuture<E> newFuture() {
-    return new VolleyRequestFuture<E>();
-  }
-
-  public synchronized void setRequest(Request<?> request) {
-    mRequest = request;
-    if (mIsCancelled && mRequest != null) {
-      mRequest.cancel();
-    }
-  }
-
-  @Override
-  public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-    if (isDone()) {
-      return false;
-    }
-    mIsCancelled = true;
-    if (mRequest != null) {
-      mRequest.cancel();
-    }
-    notifyAll();
-
-    return true;
-  }
-
-  @Override
-  public T get() throws InterruptedException, ExecutionException {
-    try {
-      return doGet(null);
-    } catch (TimeoutException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override
-  public T get(long timeout, TimeUnit unit)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    return doGet(TimeUnit.MILLISECONDS.convert(timeout, unit));
-  }
-
-  private synchronized T doGet(Long timeoutMs)
-      throws InterruptedException, ExecutionException, TimeoutException {
-    if (mException != null) {
-      throw new ExecutionException(mException);
-    }
-
-    if (mResultReceived) {
-      return mResult;
-    }
-
-    if (isCancelled()) {
-      throw new CancellationException();
-    }
-
-    if (timeoutMs == null) {
-      wait(0);
-    } else if (timeoutMs > 0) {
-      wait(timeoutMs);
-    }
-
-    if (mException != null) {
-      throw new ExecutionException(mException);
-    }
-
-    if (isCancelled()) {
-      throw new CancellationException();
-    }
-
-    if (!mResultReceived) {
-      throw new TimeoutException();
-    }
-
-    return mResult;
-  }
-
-  @Override
-  public boolean isCancelled() {
-    return mIsCancelled;
-  }
-
-  @Override
-  public synchronized boolean isDone() {
-    return mResultReceived || mException != null || isCancelled();
-  }
-
-  @Override
-  public synchronized void onResponse(T response) {
-    mResultReceived = true;
-    mResult = response;
-    notifyAll();
-  }
-
-  @Override
-  public synchronized void onErrorResponse(VolleyError error) {
-    mException = error;
-    notifyAll();
-  }
-}
-
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index 89466cfca..f0b4340fa 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.integration.volley;
 
 import android.util.Log;
-
 import com.android.volley.AuthFailureError;
 import com.android.volley.NetworkResponse;
 import com.android.volley.Request;
@@ -13,7 +12,6 @@
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
-
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.util.Collections;
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index a07ef442e..02c3c0921 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
-
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.load.Options;
@@ -9,7 +8,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 
 /**
@@ -73,8 +71,7 @@ public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory factory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {
       return new VolleyUrlLoader(requestQueue, requestFactory);
     }
 
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index cbf27f64f..b1271b9a2 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -10,7 +10,6 @@
 import static org.mockito.Mockito.when;
 
 import android.os.SystemClock;
-
 import com.android.volley.RequestQueue;
 import com.android.volley.VolleyError;
 import com.android.volley.toolbox.Volley;
@@ -18,9 +17,14 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -37,13 +41,6 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowSystemClock;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.CountDownLatch;
-
 /**
  * Tests {@link com.bumptech.glide.integration.volley.VolleyStreamFetcher} against server
  * responses.
diff --git a/library/build.gradle b/library/build.gradle
index bde7cf66c..bcef2c2bb 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
 apply plugin: 'maven'
 apply plugin: 'findbugs'
 apply plugin: 'pmd'
@@ -19,6 +18,7 @@ coveralls {
 dependencies {
     compile project(':third_party:gif_decoder')
     compile project(':third_party:disklrucache')
+    compile project(':annotation')
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
 
     testCompile project(':testutil')
@@ -34,6 +34,10 @@ dependencies {
 android.testOptions.unitTests.all {
     // configure max heap size of the test JVM
     maxHeapSize = '2048m'
+    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {
+        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0
+        jvmArgs '-XX:MaxPermSize=2048m'
+    }
 }
 
 android {
@@ -107,9 +111,9 @@ afterEvaluate {
 
     check.dependsOn('pmd')
 
-    task jacocoTestReport(type: JacocoReport, dependsOn: testDebug) {
-        def coverageSourceDirs = ['src/main/java']
-        group = "Reporting"
+   task jacocoTestReport(type: JacocoReport, dependsOn: testDebugUnitTest) {
+       def coverageSourceDirs = ['src/main/java']
+       group = "Reporting"
         description = "Generate Jacoco coverage reports"
 
         classDirectories = fileTree(
@@ -137,8 +141,9 @@ afterEvaluate {
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
 // exclude <dependency> tag for android support-v4 library from :glide's pom
 // this will ensure that this warning will not prevent the build from completing:
-// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries but is a jar
-// most users will need to override support-v4 version anyway if a newer version is available
+// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries
+// but is a jar. Most users will need to override support-v4 version anyway if a newer version is
+// available
 // TODO make support-v4 a <scope>runtime</scope> dependency in pom.xml
 afterEvaluate {
     uploadArchives.repositories.mavenDeployer.pom.whenConfigured { p ->
diff --git a/library/lint.xml b/library/lint.xml
index ff7e5955c..869eb6598 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -1,4 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="AllowBackup" severity="ignore"/>
+    <!-- TODO: Fix this after RequestManager#get(View) uses official APIs -->
+    <issue id="RestrictedApi" severity="ignore"/>
 </lint>
diff --git a/library/pmd-ruleset.xml b/library/pmd-ruleset.xml
index 01bb11a73..76249e191 100644
--- a/library/pmd-ruleset.xml
+++ b/library/pmd-ruleset.xml
@@ -35,4 +35,24 @@
     </rule>
 
 
+    <!--Overrides default check to avoid violation when @Synthetic annotation is present-->
+    <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor"
+          message="Document empty constructor">
+
+        <properties>
+            <property name="xpath">
+                <value>
+                    <![CDATA[
+//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and
+($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false'
+ and not(../Annotation/MarkerAnnotation/Name[@Image='Synthetic'])]
+ ]]>
+                </value>
+            </property>
+
+        </properties>
+
+    </rule>
+
+
 </ruleset>
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
index 0432be6d2..078afb542 100644
--- a/library/proguard-rules.txt
+++ b/library/proguard-rules.txt
@@ -1,4 +1,5 @@
 -keep public class * implements com.bumptech.glide.module.GlideModule
+-keep public class * extends com.bumptech.glide.GeneratedAppGlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
     **[] $VALUES;
     public *;
diff --git a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
new file mode 100644
index 000000000..1c852b961
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.module.AppGlideModule;
+import java.util.Set;
+
+/**
+ * A temporary interface to allow {@link AppGlideModule}s to exclude
+ * {@link com.bumptech.glide.annotation.GlideModule}s to ease the migration from
+ * {@link com.bumptech.glide.annotation.GlideModule}s to Glide's annotation processing system.
+ */
+@Deprecated
+abstract class GeneratedAppGlideModule extends AppGlideModule {
+  /**
+   * This method can be removed when manifest parsing is no longer supported.
+   */
+  @Deprecated
+  @NonNull
+  abstract Set<Class<?>> getExcludedModuleClasses();
+
+  @Nullable
+  RequestManagerRetriever.RequestManagerFactory getRequestManagerFactory() {
+    return null;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
index 47657e942..1fe9588f5 100644
--- a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide;
 
+import com.bumptech.glide.request.transition.TransitionFactory;
+import com.bumptech.glide.request.transition.ViewPropertyTransition;
+
 /**
  * Implementation of {@link TransitionOptions} that exposes only generic methods that can be applied
  * to any resource type.
@@ -8,9 +11,43 @@
  */
 @SuppressWarnings("PMD.UseUtilityClass")
 public final class GenericTransitionOptions<TranscodeType> extends
-  TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
-
+    TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
+  /**
+   * Removes any existing animation put on the builder.
+   *
+   * @see GenericTransitionOptions#dontTransition()
+   */
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {
     return new GenericTransitionOptions<TranscodeType>().dontTransition();
   }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given view animation.
+   *
+   * @see GenericTransitionOptions#transition(int)
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      int viewAnimationId) {
+    return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);
+  }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given animator.
+   *
+   * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator)
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      ViewPropertyTransition.Animator animator) {
+    return new GenericTransitionOptions<TranscodeType>().transition(animator);
+  }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given transition factory.
+   *
+   * @see GenericTransitionOptions#transition(TransitionFactory)
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      TransitionFactory<? super TranscodeType> transitionFactory) {
+    return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 68843d6fb..a6ef96c89 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -12,10 +12,11 @@
 import android.os.Build;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
-
+import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.data.InputStreamRewinder;
@@ -48,6 +49,7 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableEncoder;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
@@ -68,14 +70,17 @@
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 import java.io.InputStream;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
 
 /**
  * A singleton to present a simple static interface for building requests with
@@ -95,8 +100,10 @@
   private final GlideContext glideContext;
   private final Registry registry;
   private final ArrayPool arrayPool;
+  private final RequestManagerRetriever requestManagerRetriever;
   private final ConnectivityMonitorFactory connectivityMonitorFactory;
   private final List<RequestManager> managers = new ArrayList<>();
+  private MemoryCategory memoryCategory = MemoryCategory.NORMAL;
 
   /**
    * Returns a directory with a default name in the private cache directory of the application to
@@ -144,17 +151,7 @@ public static Glide get(Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
-          Context applicationContext = context.getApplicationContext();
-          List<GlideModule> modules = new ManifestParser(applicationContext).parse();
-
-          GlideBuilder builder = new GlideBuilder(applicationContext);
-          for (GlideModule module : modules) {
-            module.applyOptions(applicationContext, builder);
-          }
-          glide = builder.createGlide();
-          for (GlideModule module : modules) {
-            module.registerComponents(applicationContext, glide.registry);
-          }
+          initGlide(context);
         }
       }
     }
@@ -162,11 +159,96 @@ public static Glide get(Context context) {
     return glide;
   }
 
-  // For testing.
-  static void tearDown() {
+  @VisibleForTesting
+  public static void init(Glide glide) {
+    Glide.glide = glide;
+  }
+
+  @VisibleForTesting
+  public static void tearDown() {
     glide = null;
   }
 
+  @SuppressWarnings("deprecation")
+  private static void initGlide(Context context) {
+    Context applicationContext = context.getApplicationContext();
+
+    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
+    List<GlideModule> manifestModules = Collections.emptyList();
+    if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
+      manifestModules = new ManifestParser(applicationContext).parse();
+    }
+
+    if (annotationGeneratedModule != null
+        && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
+      Set<Class<?>> excludedModuleClasses =
+          annotationGeneratedModule.getExcludedModuleClasses();
+      for (Iterator<GlideModule> iterator = manifestModules.iterator(); iterator.hasNext();) {
+        GlideModule current = iterator.next();
+        if (!excludedModuleClasses.contains(current.getClass())) {
+          continue;
+        }
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "AppGlideModule excludes manifest GlideModule: " + current);
+        }
+        iterator.remove();
+      }
+    }
+
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      for (GlideModule glideModule : manifestModules) {
+        Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
+      }
+    }
+
+    RequestManagerRetriever.RequestManagerFactory factory =
+        annotationGeneratedModule != null
+            ? annotationGeneratedModule.getRequestManagerFactory() : null;
+    GlideBuilder builder = new GlideBuilder()
+        .setRequestManagerFactory(factory);
+    for (GlideModule module : manifestModules) {
+      module.applyOptions(applicationContext, builder);
+    }
+    if (annotationGeneratedModule != null) {
+      annotationGeneratedModule.applyOptions(applicationContext, builder);
+    }
+    glide = builder.build(applicationContext);
+    for (GlideModule module : manifestModules) {
+      module.registerComponents(applicationContext, glide.registry);
+    }
+    if (annotationGeneratedModule != null) {
+      annotationGeneratedModule.registerComponents(applicationContext, glide.registry);
+    }
+  }
+
+  @Nullable
+  @SuppressWarnings({"unchecked", "deprecation"})
+  private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
+    GeneratedAppGlideModule result = null;
+    try {
+      Class<GeneratedAppGlideModule> clazz =
+          (Class<GeneratedAppGlideModule>)
+              Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
+      result = clazz.newInstance();
+    } catch (ClassNotFoundException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
+            + " annotationProcessor compile dependency on com.github.bumptech.glide:glide:compiler"
+            + " in your application and a @GlideModule annotated AppGlideModule implementation or"
+            + " LibraryGlideModules will be silently ignored");
+      }
+    } catch (InstantiationException e) {
+      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+          + " If you've manually implemented this class, remove your implementation. The Annotation"
+          + " processor will generate a correct implementation.", e);
+    } catch (IllegalAccessException e) {
+      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+          + " If you've manually implemented this class, remove your implementation. The Annotation"
+          + " processor will generate a correct implementation.", e);
+    }
+    return result;
+  }
+
   @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   Glide(
       Context context,
@@ -174,6 +256,7 @@ static void tearDown() {
       MemoryCache memoryCache,
       BitmapPool bitmapPool,
       ArrayPool arrayPool,
+      RequestManagerRetriever requestManagerRetriever,
       ConnectivityMonitorFactory connectivityMonitorFactory,
       int logLevel,
       RequestOptions defaultRequestOptions) {
@@ -181,19 +264,23 @@ static void tearDown() {
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
     this.memoryCache = memoryCache;
+    this.requestManagerRetriever = requestManagerRetriever;
     this.connectivityMonitorFactory = connectivityMonitorFactory;
 
     DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
     bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
 
-    Resources resources = context.getResources();
+    final Resources resources = context.getResources();
+
+    registry = new Registry();
+    registry.register(new DefaultImageHeaderParser());
 
-    Downsampler downsampler =
-        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);
+    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
+        resources.getDisplayMetrics(), bitmapPool, arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
-        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);
-    registry = new Registry(context)
-        .register(ByteBuffer.class, new ByteBufferEncoder())
+        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+
+    registry.register(ByteBuffer.class, new ByteBufferEncoder())
         .register(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
         .append(ByteBuffer.class, Bitmap.class,
@@ -212,12 +299,12 @@ static void tearDown() {
         .append(ParcelFileDescriptor.class, BitmapDrawable.class,
             new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
         .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
-        /* Gifs */
+        /* GIFs */
         .prepend(InputStream.class, GifDrawable.class,
-            new StreamGifDecoder(byteBufferGifDecoder, arrayPool))
+            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
         .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
         .register(GifDrawable.class, new GifDrawableEncoder())
-        /* Gif Frames */
+        /* GIF Frames */
         .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
         .append(GifDecoder.class, Bitmap.class, new GifFrameResourceDecoder(bitmapPool))
         /* Files */
@@ -229,24 +316,36 @@ static void tearDown() {
         .append(File.class, File.class, new UnitModelLoader.Factory<File>())
         /* Models */
         .register(new InputStreamRewinder.Factory(arrayPool))
-        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(int.class, ParcelFileDescriptor.class, new ResourceLoader.FileDescriptorFactory())
-        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(Integer.class, ParcelFileDescriptor.class,
-            new ResourceLoader.FileDescriptorFactory())
+        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(
+                int.class,
+                ParcelFileDescriptor.class,
+                new ResourceLoader.FileDescriptorFactory(resources))
+        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(
+                Integer.class,
+                ParcelFileDescriptor.class,
+                new ResourceLoader.FileDescriptorFactory(resources))
         .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
-        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new AssetUriLoader.FileDescriptorFactory())
-        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new UriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new UriLoader.FileDescriptorFactory())
+        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
+        .append(
+                Uri.class,
+                ParcelFileDescriptor.class,
+                new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
+        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
+        .append(
+            Uri.class,
+             InputStream.class,
+             new UriLoader.StreamFactory(context.getContentResolver()))
+        .append(Uri.class, ParcelFileDescriptor.class,
+             new UriLoader.FileDescriptorFactory(context.getContentResolver()))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
-        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory())
+        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
         .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
         .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
         .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
@@ -288,6 +387,13 @@ public ArrayPool getArrayPool() {
     return arrayPool;
   }
 
+  /**
+   * @return The context associated with this instance.
+   */
+  public Context getContext() {
+    return glideContext.getBaseContext();
+  }
+
   ConnectivityMonitorFactory getConnectivityMonitorFactory() {
     return connectivityMonitorFactory;
   }
@@ -366,6 +472,14 @@ public void clearDiskCache() {
     engine.clearDiskCache();
   }
 
+
+  /**
+   * Internal method.
+   */
+  public RequestManagerRetriever getRequestManagerRetriever() {
+    return requestManagerRetriever;
+  }
+
   /**
    * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
    *
@@ -375,13 +489,28 @@ public void clearDiskCache() {
    * used to temporarily increase or decrease memory usage for a single Activity or part of the app.
    * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want
    * to change the default. </p>
+   *
+   * @return the previous MemoryCategory used by Glide.
    */
-  public void setMemoryCategory(MemoryCategory memoryCategory) {
+  public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
     // Engine asserts this anyway when removing resources, fail faster and consistently
     Util.assertMainThread();
     // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.setSizeMultiplier(memoryCategory.getMultiplier());
     bitmapPool.setSizeMultiplier(memoryCategory.getMultiplier());
+    MemoryCategory oldCategory = this.memoryCategory;
+    this.memoryCategory = memoryCategory;
+    return oldCategory;
+  }
+
+  private static RequestManagerRetriever getRetriever(@Nullable Context context) {
+    // Context could be null for other reasons (ie the user passes in null), but in practice it will
+    // only occur due to errors with the Fragment lifecycle.
+    Preconditions.checkNotNull(
+        "You cannot start a load on a not yet attached View or a  Fragment where getActivity() "
+            + "returns null (which usually occurs when getActivity() is called before the Fragment "
+            + "is attached or after the Fragment is destroyed).");
+    return Glide.get(context).getRequestManagerRetriever();
   }
 
   /**
@@ -407,8 +536,7 @@ public void setMemoryCategory(MemoryCategory memoryCategory) {
    * @see #with(android.support.v4.app.FragmentActivity)
    */
   public static RequestManager with(Context context) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(context);
+    return getRetriever(context).get(context);
   }
 
   /**
@@ -419,8 +547,7 @@ public static RequestManager with(Context context) {
    * @return A RequestManager for the given activity that can be used to start a load.
    */
   public static RequestManager with(Activity activity) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(activity);
+    return getRetriever(activity).get(activity);
   }
 
   /**
@@ -432,8 +559,7 @@ public static RequestManager with(Activity activity) {
    * @return A RequestManager for the given FragmentActivity that can be used to start a load.
    */
   public static RequestManager with(FragmentActivity activity) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(activity);
+    return getRetriever(activity).get(activity);
   }
 
   /**
@@ -443,10 +569,8 @@ public static RequestManager with(FragmentActivity activity) {
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   public static RequestManager with(android.app.Fragment fragment) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(fragment);
+    return getRetriever(fragment.getActivity()).get(fragment);
   }
 
   /**
@@ -458,8 +582,31 @@ public static RequestManager with(android.app.Fragment fragment) {
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
   public static RequestManager with(Fragment fragment) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(fragment);
+    return getRetriever(fragment.getActivity()).get(fragment);
+  }
+
+  /**
+   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},
+   * {@link android.app.Fragment}, or {@link Activity} that contains the View.
+   *
+   * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View
+   * is a child of the View returned by the {@link Fragment#getView()}} method.
+   *
+   * <p>This method will not work if the View is not attached. Prefer the Activity and Fragment
+   * variants unless you're loading in a View subclass.
+   *
+   * <p>This method may be inefficient for large hierarchies. Consider memoizing the result after
+   * the View is attached.
+   *
+   * <p>When used in Applications that use the non-support {@link android.app.Fragment} classes,
+   * calling this method will produce noisy logs from {@link android.app.FragmentManager}. Consider
+   * avoiding entirely or using the {@link Fragment}s from the support library instead.
+   *
+   * @param view The view to search for a containing Fragment or Activity from.
+   * @return A RequestManager that can be used to start a load.
+   */
+  public static RequestManager with(View view) {
+    return getRetriever(view.getContext()).get(view);
   }
 
   public Registry getRegistry() {
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 445507323..784aa08b9 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -1,14 +1,12 @@
 package com.bumptech.glide;
 
 import android.content.Context;
-import android.os.Build;
+import android.support.annotation.Nullable;
 import android.util.Log;
-
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
@@ -19,14 +17,14 @@
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;
 import com.bumptech.glide.request.RequestOptions;
 
 /**
  * A builder class for setting default structural classes for Glide to use.
  */
 public final class GlideBuilder {
-  private final Context context;
-
   private Engine engine;
   private BitmapPool bitmapPool;
   private ArrayPool arrayPool;
@@ -38,10 +36,8 @@
   private ConnectivityMonitorFactory connectivityMonitorFactory;
   private int logLevel = Log.INFO;
   private RequestOptions defaultRequestOptions = new RequestOptions();
-
-  GlideBuilder(Context context) {
-    this.context = context.getApplicationContext();
-  }
+  @Nullable
+  private RequestManagerFactory requestManagerFactory;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -150,7 +146,7 @@ public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
    * <p>Applying additional options with {@link
-   * RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions)} will override defaults
+   * RequestBuilder#apply(RequestOptions)} will override defaults
    * set here.
    *
    * @param requestOptions The options to use by default.
@@ -255,16 +251,23 @@ public GlideBuilder setLogLevel(int logLevel) {
     return this;
   }
 
+  GlideBuilder setRequestManagerFactory(
+      @Nullable RequestManagerRetriever.RequestManagerFactory factory) {
+    this.requestManagerFactory = factory;
+    return this;
+  }
+
   // For testing.
   GlideBuilder setEngine(Engine engine) {
     this.engine = engine;
     return this;
   }
 
-  Glide createGlide() {
+  public Glide build(Context context) {
     if (sourceExecutor == null) {
       sourceExecutor = GlideExecutor.newSourceExecutor();
     }
+
     if (diskCacheExecutor == null) {
       diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
@@ -278,12 +281,8 @@ Glide createGlide() {
     }
 
     if (bitmapPool == null) {
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-        int size = memorySizeCalculator.getBitmapPoolSize();
-        bitmapPool = new LruBitmapPool(size);
-      } else {
-        bitmapPool = new BitmapPoolAdapter();
-      }
+      int size = memorySizeCalculator.getBitmapPoolSize();
+      bitmapPool = new LruBitmapPool(size);
     }
 
     if (arrayPool == null) {
@@ -299,15 +298,20 @@ Glide createGlide() {
     }
 
     if (engine == null) {
-      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor);
+      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,
+          GlideExecutor.newUnlimitedSourceExecutor());
     }
 
+    RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(
+        requestManagerFactory);
+
     return new Glide(
         context,
         engine,
         memoryCache,
         bitmapPool,
         arrayPool,
+        requestManagerRetriever,
         connectivityMonitorFactory,
         logLevel,
         defaultRequestOptions.lock());
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index 2753b6503..ebf5f06fd 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -9,7 +9,6 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index fba351ea0..ddaae41d7 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -1,16 +1,12 @@
 package com.bumptech.glide;
 
-import android.app.Activity;
-import android.app.Fragment;
 import android.support.annotation.Nullable;
-import android.support.v4.app.FragmentActivity;
 import android.widget.AbsListView;
-
 import com.bumptech.glide.request.target.BaseTarget;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.util.List;
 import java.util.Queue;
 
@@ -93,41 +89,6 @@
     int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
   }
 
-  /**
-   * Helper constructor that accepts an {@link Activity}.
-   */
-  public ListPreloader(Activity activity, PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
-    this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link FragmentActivity}.
-   */
-  public ListPreloader(FragmentActivity fragmentActivity,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link Fragment}.
-   */
-  public ListPreloader(Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
-   */
-  public ListPreloader(android.support.v4.app.Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
   /**
    * Constructor for {@link com.bumptech.glide.ListPreloader} that accepts interfaces for providing
    * the dimensions of images to preload, the list of models to preload for a given position, and
@@ -217,7 +178,7 @@ private void preloadAdapterPosition(List<T> items, int position, boolean isIncre
   private void preloadItem(T item, int position, int i) {
     final int[] dimensions = this.preloadDimensionProvider.getPreloadSize(item, position, i);
     if (dimensions != null) {
-      RequestBuilder preloadRequestBuilder =
+      RequestBuilder<Object> preloadRequestBuilder =
           this.preloadModelProvider.getPreloadRequestBuilder(item);
       preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
     }
@@ -250,8 +211,11 @@ public PreloadTarget next(int width, int height) {
   }
 
   private static class PreloadTarget extends BaseTarget<Object> {
-    private int photoHeight;
-    private int photoWidth;
+    @Synthetic int photoHeight;
+    @Synthetic int photoWidth;
+
+    @Synthetic
+    PreloadTarget() { }
 
     @Override
     public void onResourceReady(Object resource, Transition<? super Object> transition) {
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index dea54a6b9..7468be5be 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.data.DataRewinder;
@@ -17,12 +16,12 @@
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.load.resource.transcode.TranscoderRegistry;
 import com.bumptech.glide.provider.EncoderRegistry;
+import com.bumptech.glide.provider.ImageHeaderParserRegistry;
 import com.bumptech.glide.provider.LoadPathCache;
 import com.bumptech.glide.provider.ModelToResourceClassCache;
 import com.bumptech.glide.provider.ResourceDecoderRegistry;
 import com.bumptech.glide.provider.ResourceEncoderRegistry;
 import com.bumptech.glide.util.pool.FactoryPools;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -37,20 +36,21 @@
   private final ResourceEncoderRegistry resourceEncoderRegistry;
   private final DataRewinderRegistry dataRewinderRegistry;
   private final TranscoderRegistry transcoderRegistry;
+  private final ImageHeaderParserRegistry imageHeaderParserRegistry;
 
   private final ModelToResourceClassCache modelToResourceClassCache =
       new ModelToResourceClassCache();
   private final LoadPathCache loadPathCache = new LoadPathCache();
   private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();
 
-  public Registry(Context context) {
-    this.modelLoaderRegistry =
-        new ModelLoaderRegistry(context.getApplicationContext(), exceptionListPool);
+  public Registry() {
+    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);
     this.encoderRegistry = new EncoderRegistry();
     this.decoderRegistry = new ResourceDecoderRegistry();
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
     this.dataRewinderRegistry = new DataRewinderRegistry();
     this.transcoderRegistry = new TranscoderRegistry();
+    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();
   }
 
   public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
@@ -87,6 +87,11 @@ public Registry register(DataRewinder.Factory factory) {
     return this;
   }
 
+  public Registry register(ImageHeaderParser parser) {
+    imageHeaderParserRegistry.add(parser);
+    return this;
+  }
+
   /**
    * Use the given factory to build a {@link com.bumptech.glide.load.model.ModelLoader} for models
    * of the given class. Generally the best use of this method is to replace one of the default
@@ -224,6 +229,14 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     return result;
   }
 
+  public List<ImageHeaderParser> getImageHeaderParsers() {
+    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();
+    if (result.isEmpty()) {
+      throw new NoImageHeaderParserException();
+    }
+    return result;
+  }
+
   /**
    * Thrown when no {@link com.bumptech.glide.load.model.ModelLoader} is registered for a given
    * model class.
@@ -233,7 +246,7 @@ public NoModelLoaderAvailableException(Object model) {
       super("Failed to find any ModelLoaders for model: " + model);
     }
 
-    public NoModelLoaderAvailableException(Class modelClass, Class dataClass) {
+    public NoModelLoaderAvailableException(Class<?> modelClass, Class<?> dataClass) {
       super("Failed to find any ModelLoaders for model: " + modelClass + " and data: " + dataClass);
     }
   }
@@ -264,4 +277,13 @@ public MissingComponentException(String message) {
       super(message);
     }
   }
+
+  /**
+   * Thrown when no {@link ImageHeaderParser} is registered.
+   */
+  public static final class NoImageHeaderParserException extends MissingComponentException {
+    public NoImageHeaderParserException() {
+      super("Failed to find image header parser.");
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index d22e33b2f..81fea6e36 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -6,9 +6,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestCoordinator;
@@ -23,7 +21,6 @@
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 import java.net.URL;
 import java.util.UUID;
@@ -37,16 +34,18 @@
 public class RequestBuilder<TranscodeType> implements Cloneable {
   private static final TransitionOptions<?, ?> DEFAULT_ANIMATION_OPTIONS =
       new GenericTransitionOptions<Object>();
-  private static final BaseRequestOptions<?> DOWNLOAD_ONLY_OPTIONS =
+  // Used in generated subclasses
+  protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
   private final GlideContext context;
   private final RequestManager requestManager;
   private final Class<TranscodeType> transcodeClass;
-  private final BaseRequestOptions<?> defaultRequestOptions;
+  private final RequestOptions defaultRequestOptions;
+  private final Glide glide;
 
-  @NonNull private BaseRequestOptions<?> requestOptions;
+  @NonNull protected RequestOptions requestOptions;
   @SuppressWarnings("unchecked")
   private TransitionOptions<?, ? super TranscodeType> transitionOptions =
       (TransitionOptions<?, ? super TranscodeType>) DEFAULT_ANIMATION_OPTIONS;
@@ -60,38 +59,41 @@
   private boolean isModelSet;
   private boolean isThumbnailBuilt;
 
-  RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
-    this(other.context, other.requestManager, transcodeClass);
-    model = other.model;
-    isModelSet = other.isModelSet;
-    requestOptions = other.requestOptions;
-  }
-
-  RequestBuilder(GlideContext context, RequestManager requestManager,
+  protected RequestBuilder(Glide glide, RequestManager requestManager,
       Class<TranscodeType> transcodeClass) {
+    this.glide = glide;
     this.requestManager = requestManager;
-    this.context = Preconditions.checkNotNull(context);
+    this.context = glide.getGlideContext();
     this.transcodeClass = transcodeClass;
-
     this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
     this.requestOptions = defaultRequestOptions;
   }
 
+  protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+    this(other.glide, other.requestManager, transcodeClass);
+    model = other.model;
+    isModelSet = other.isModelSet;
+    requestOptions = other.requestOptions;
+  }
+
   /**
    * Applies the given options to the request, options set or unset in the given options will
    * replace those previously set in options in this class.
    *
-   * @see BaseRequestOptions#apply(BaseRequestOptions)
+   * @see RequestOptions#apply(RequestOptions)
    * @return This request builder.
    */
-  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
+  public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
     Preconditions.checkNotNull(requestOptions);
-    BaseRequestOptions<?> toMutate = defaultRequestOptions == this.requestOptions
-        ? this.requestOptions.clone() : this.requestOptions;
-    this.requestOptions = toMutate.apply(requestOptions);
+    this.requestOptions = getMutableOptions().apply(requestOptions);
     return this;
   }
 
+  protected RequestOptions getMutableOptions() {
+    return defaultRequestOptions == this.requestOptions
+        ? this.requestOptions.clone() : this.requestOptions;
+  }
+
   /**
    * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
    * this load completes.
@@ -146,8 +148,8 @@
 
   /**
    * Loads a resource in an identical manner to this request except with the dimensions of the
-   * target multiplied by the given size multiplier. If the thumbnail load completes before the
-   * fullsize load, the thumbnail will be shown. If the thumbnail load completes after the fullsize
+   * target multiplied by the given size multiplier. If the thumbnail load completes before the full
+   * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
    * load, the thumbnail will not be shown.
    *
    * <p> Note - The thumbnail resource will be smaller than the size requested so the target (or
@@ -157,9 +159,9 @@
    * <p> Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
    * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.BaseRequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.BaseRequestOptions#error(int)}, and
-   * {@link #listener(RequestListener)} will only be used on the fullsize load and will not be
+   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
+   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
+   * {@link #listener(RequestListener)} will only be used on the full size load and will not be
    * copied for the thumbnail load. </p>
    *
    * <p> Recursive calls to thumbnail are supported. </p>
@@ -204,11 +206,11 @@
    * <p> Note - this method caches data using only the given String as the cache key. If the data is
    * a Uri outside of your control, or you otherwise expect the data represented by the given String
    * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create that identifies the data currently at the given String that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
    * </p>
    *
@@ -227,11 +229,11 @@
    * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
    * represented by Uris from some content providers may change without the Uri changing, which
    * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create based on the data at the given Uri that will invalidate the cache
    * if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate. </p>
    *
    * @see #load(Object)
@@ -249,11 +251,11 @@
    * <p> Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
    * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)}
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
    * to mixin a signature you create that identifies the data currently in the File that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
    * </p>
    *
@@ -277,7 +279,7 @@
    * version code before each install and you replace a Drawable with different data without
    * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
    * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link BaseRequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
+   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
    * during development, and re-enabling the default
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds. </p>
    *
@@ -388,17 +390,21 @@
       }
       switch (view.getScaleType()) {
         case CENTER_CROP:
-          requestOptions.optionalCenterCrop(context);
+          requestOptions.optionalCenterCrop();
           break;
         case CENTER_INSIDE:
-          requestOptions.optionalCenterInside(context);
+          requestOptions.optionalCenterInside();
           break;
         case FIT_CENTER:
         case FIT_START:
         case FIT_END:
-          requestOptions.optionalFitCenter(context);
+          requestOptions.optionalFitCenter();
+          break;
+        case FIT_XY:
+          requestOptions.optionalCenterInside();
           break;
-        //$CASES-OMITTED$
+        case CENTER:
+        case MATRIX:
         default:
           // Do nothing.
       }
@@ -412,11 +418,11 @@
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    * @see RequestManager#clear(Target)
    *
@@ -431,7 +437,7 @@
    * Returns a future that can be used to do a blocking get on a background thread.
    *
    * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
-   * since the width and height will be overriden by values passed to {@link
+   * since the width and height will be overridden by values passed to {@link
    * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
    * with override values are applied, or whenever you want to retrieve the image in its original
    * size.
@@ -448,11 +454,11 @@
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    */
   public FutureTarget<TranscodeType> submit(int width, int height) {
@@ -483,11 +489,11 @@ public void run() {
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    * @return A {@link Target} that can be used to cancel the load via
    * {@link RequestManager#clear(Target)}.
@@ -543,7 +549,7 @@ public void run() {
     return getDownloadOnlyRequest().submit(width, height);
   }
 
-  private RequestBuilder<File> getDownloadOnlyRequest() {
+  protected RequestBuilder<File> getDownloadOnlyRequest() {
     return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
   }
 
@@ -609,7 +615,7 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
       Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,
           priority, overrideWidth, overrideHeight);
-      BaseRequestOptions<?> thumbnailOptions = requestOptions.clone()
+      RequestOptions thumbnailOptions = requestOptions.clone()
           .sizeMultiplier(thumbSizeMultiplier);
 
       Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,
@@ -625,7 +631,7 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
   }
 
   private Request obtainRequest(Target<TranscodeType> target,
-      BaseRequestOptions<?> requestOptions, RequestCoordinator requestCoordinator,
+      RequestOptions requestOptions, RequestCoordinator requestCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,
       int overrideWidth, int overrideHeight) {
     requestOptions.lock();
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 18ebfb427..3a1ecec2a 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -12,9 +12,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.view.View;
-
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.BitmapTransitionOptions;
 import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
@@ -24,14 +22,13 @@
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.manager.TargetTracker;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 
 /**
@@ -53,8 +50,8 @@
       diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
-  private final GlideContext context;
-  private final Lifecycle lifecycle;
+  protected final Glide glide;
+  @Synthetic final Lifecycle lifecycle;
   private final RequestTracker requestTracker;
   private final RequestManagerTreeNode treeNode;
   private final TargetTracker targetTracker = new TargetTracker();
@@ -68,22 +65,27 @@ public void run() {
   private final ConnectivityMonitor connectivityMonitor;
 
   @NonNull
-  private BaseRequestOptions<?> defaultRequestOptions;
-  @NonNull
-  private BaseRequestOptions<?> requestOptions;
+  private RequestOptions requestOptions;
 
-  public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
-    this(context, lifecycle, treeNode,
-        new RequestTracker(), Glide.get(context).getConnectivityMonitorFactory());
+  public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+    this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory());
   }
 
-  RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,
-      RequestTracker requestTracker, ConnectivityMonitorFactory factory) {
-    this.context = Glide.get(context).getGlideContext();
+  // Our usage is safe here.
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+  RequestManager(
+      Glide glide,
+      Lifecycle lifecycle,
+      RequestManagerTreeNode treeNode,
+      RequestTracker requestTracker,
+      ConnectivityMonitorFactory factory) {
+    this.glide = glide;
     this.lifecycle = lifecycle;
     this.treeNode = treeNode;
     this.requestTracker = requestTracker;
 
+    final Context context = glide.getGlideContext().getBaseContext();
+
     connectivityMonitor =
         factory.build(context, new RequestManagerConnectivityListener(requestTracker));
 
@@ -98,10 +100,17 @@ public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNo
     }
     lifecycle.addListener(connectivityMonitor);
 
-    defaultRequestOptions = this.context.getDefaultRequestOptions();
-    requestOptions = defaultRequestOptions;
+    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
+
+    glide.registerRequestManager(this);
+  }
+
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    this.requestOptions = toSet.clone().autoClone();
+  }
 
-    Glide.get(context).registerRequestManager(this);
+  private void updateRequestOptions(RequestOptions toUpdate) {
+    this.requestOptions.apply(toUpdate);
   }
 
   /**
@@ -118,14 +127,12 @@ public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNo
    *
    * <p>The modified options will only be applied to loads started after this method is called.
    *
-   * @see RequestBuilder#apply(BaseRequestOptions)
+   * @see RequestBuilder#apply(RequestOptions)
    *
    * @return This request manager.
    */
   public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions) {
-    BaseRequestOptions<?> toMutate = this.requestOptions == defaultRequestOptions
-        ? this.requestOptions.clone() : this.defaultRequestOptions;
-    this.requestOptions = toMutate.apply(requestOptions);
+    updateRequestOptions(requestOptions);
     return this;
   }
 
@@ -147,8 +154,7 @@ public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions)
    * @return This request manager.
    */
   public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
-    this.defaultRequestOptions = requestOptions;
-    this.requestOptions = requestOptions;
+    setRequestOptions(requestOptions);
     return this;
   }
 
@@ -156,14 +162,14 @@ public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
    */
   public void onTrimMemory(int level) {
-    context.onTrimMemory(level);
+    glide.getGlideContext().onTrimMemory(level);
   }
 
   /**
    * @see android.content.ComponentCallbacks2#onLowMemory()
    */
   public void onLowMemory() {
-    context.onLowMemory();
+    glide.getGlideContext().onLowMemory();
   }
 
   /**
@@ -270,7 +276,7 @@ public void onDestroy() {
     lifecycle.removeListener(this);
     lifecycle.removeListener(connectivityMonitor);
     mainHandler.removeCallbacks(addSelfToLifecycle);
-    Glide.get(context).unregisterRequestManager(this);
+    glide.unregisterRequestManager(this);
   }
 
   /**
@@ -280,7 +286,8 @@ public void onDestroy() {
    * @return A new request builder for loading a {@link android.graphics.Bitmap}
    */
   public RequestBuilder<Bitmap> asBitmap() {
-    return as(Bitmap.class).transition(new BitmapTransitionOptions()).apply(DECODE_TYPE_BITMAP);
+    return as(Bitmap.class).transition(new GenericTransitionOptions<Bitmap>())
+            .apply(DECODE_TYPE_BITMAP);
   }
 
   /**
@@ -371,7 +378,7 @@ public void onDestroy() {
    * @return A new request builder for loading the given resource class.
    */
   public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(context, this, resourceClass);
+    return new RequestBuilder<>(glide, this, resourceClass);
   }
 
   /**
@@ -384,7 +391,7 @@ public void onDestroy() {
    * @param view The view to cancel loads and free resources for.
    * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's
    *                                  tag.
-   * @see #clear(Target).
+   * @see #clear(Target)
    */
   public void clear(View view) {
     clear(new ClearTarget(view));
@@ -416,7 +423,7 @@ public void run() {
   private void untrackOrDelegate(Target<?> target) {
     boolean isOwnedByUs = untrack(target);
     if (!isOwnedByUs) {
-      Glide.get(context).removeFromManagers(target);
+      glide.removeFromManagers(target);
     }
   }
 
@@ -441,7 +448,7 @@ void track(Target<?> target, Request request) {
     requestTracker.runRequest(request);
   }
 
-  BaseRequestOptions<?> getDefaultRequestOptions() {
+  RequestOptions getDefaultRequestOptions() {
     return requestOptions;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/TransitionOptions.java b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
index ea285ebf3..7768f6fcc 100644
--- a/library/src/main/java/com/bumptech/glide/TransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
@@ -28,9 +28,9 @@ public final CHILD dontTransition() {
   }
 
   /**
-   * Sets a {@link android.view.animation} to run on the wrapped target when an resource load
-   * finishes. Will only be run if the resource was loaded asynchronously (ie was not in the memory
-   * cache)
+   * Sets an {@link android.view.animation.Animation} to run on the wrapped target when an resource
+   * load finishes.
+   * Will only be run if the resource was loaded asynchronously (i.e. was not in the memory cache).
    *
    * @param viewAnimationId The resource id of the {@link android.view.animation} to use as the
    *                        transition.
@@ -42,8 +42,8 @@ public final CHILD transition(int viewAnimationId) {
 
   /**
    * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target
-   * may be wrapping when a resource load finishes. Will only be run if the load was loaded
-   * asynchronously (ie was not in the memory cache).
+   * may be wrapping when a resource load finishes.
+   * Will only be run if the load was loaded asynchronously (i.e. was not in the memory cache).
    *
    * @param animator The {@link com.bumptech.glide.request.transition.ViewPropertyTransition
    *                 .Animator} to run.
diff --git a/library/src/main/java/com/bumptech/glide/load/HttpException.java b/library/src/main/java/com/bumptech/glide/load/HttpException.java
index ad53292c1..6b4430c98 100644
--- a/library/src/main/java/com/bumptech/glide/load/HttpException.java
+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load;
 
 import android.support.annotation.Nullable;
-
 import java.io.IOException;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
new file mode 100644
index 000000000..6cecef3ac
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
@@ -0,0 +1,63 @@
+package com.bumptech.glide.load;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * Interface for the ImageHeaderParser.
+ */
+public interface ImageHeaderParser {
+  /**
+   * A constant indicating we were unable to parse the orientation from the image either because
+   * no exif segment containing orientation data existed, or because of an I/O error attempting to
+   * read the exif segment.
+   */
+  int UNKNOWN_ORIENTATION = -1;
+
+  /**
+   * The format of the image data including whether or not the image may include transparent
+   * pixels.
+   */
+  enum ImageType {
+    GIF(true),
+    JPEG(false),
+    RAW(false),
+    /** PNG type with alpha. */
+    PNG_A(true),
+    /** PNG type without alpha. */
+    PNG(false),
+    /** WebP type with alpha. */
+    WEBP_A(true),
+    /** WebP type without alpha. */
+    WEBP(false),
+    /**
+     * Unrecognized type.
+     */
+    UNKNOWN(false);
+    private final boolean hasAlpha;
+
+    ImageType(boolean hasAlpha) {
+      this.hasAlpha = hasAlpha;
+    }
+
+    public boolean hasAlpha() {
+      return hasAlpha;
+    }
+  }
+
+  ImageType getType(InputStream is) throws IOException;
+  ImageType getType(ByteBuffer byteBuffer) throws IOException;
+
+  /**
+   * Parse the orientation from the image header. If it doesn't handle this image type (or this is
+   * not an image) it will return a default value rather than throwing an exception.
+   *
+   * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
+   * contain an orientation
+   * @throws IOException
+   */
+  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;
+  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
new file mode 100644
index 000000000..b092e15f2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+/**
+ * Utilities for the ImageHeaderParser.
+ */
+public final class ImageHeaderParserUtils {
+  // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer but
+  // will resize up to this amount if necessary.
+  private static final int MARK_POSITION = 5 * 1024 * 1024;
+
+  private ImageHeaderParserUtils() { }
+
+  /** Returns the ImageType for the given InputStream. */
+  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable InputStream is,
+      ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    for (ImageHeaderParser parser : parsers) {
+      try {
+        ImageType type = parser.getType(is);
+        if (type != ImageType.UNKNOWN) {
+          return type;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /** Returns the ImageType for the given ByteBuffer. */
+  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteBuffer buffer)
+      throws IOException {
+    if (buffer == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    for (ImageHeaderParser parser : parsers) {
+      ImageType type = parser.getType(buffer);
+      if (type != ImageType.UNKNOWN) {
+        return type;
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /** Returns the orientation for the given InputStream. */
+  public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable InputStream is,
+      ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageHeaderParser.UNKNOWN_ORIENTATION;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    for (ImageHeaderParser parser : parsers) {
+      try {
+        int orientation = parser.getOrientation(is, byteArrayPool);
+        if (orientation != ImageHeaderParser.UNKNOWN_ORIENTATION) {
+          return orientation;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index f8fdd6d37..c4c5d712b 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load;
 
+import android.content.Context;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.security.MessageDigest;
 import java.util.Arrays;
 import java.util.Collection;
@@ -32,11 +32,12 @@ public MultiTransformation(Collection<? extends Transformation<T>> transformatio
   }
 
   @Override
-  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(
+      Context context, Resource<T> resource, int outWidth, int outHeight) {
     Resource<T> previous = resource;
 
     for (Transformation<T> transformation : transformations) {
-      Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);
+      Resource<T> transformed = transformation.transform(context, previous, outWidth, outHeight);
       if (previous != null && !previous.equals(resource) && !previous.equals(transformed)) {
         previous.recycle();
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
index e3b70a8c4..a63bdc44b 100644
--- a/library/src/main/java/com/bumptech/glide/load/Option.java
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -1,9 +1,7 @@
 package com.bumptech.glide.load;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/Options.java b/library/src/main/java/com/bumptech/glide/load/Options.java
index 909cb3620..32aa7c227 100644
--- a/library/src/main/java/com/bumptech/glide/load/Options.java
+++ b/library/src/main/java/com/bumptech/glide/load/Options.java
@@ -2,7 +2,6 @@
 
 import android.support.v4.util.ArrayMap;
 import android.support.v4.util.SimpleArrayMap;
-
 import java.security.MessageDigest;
 import java.util.Map;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
index ebac41d1e..f8e67f7e0 100644
--- a/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java
@@ -1,9 +1,7 @@
 package com.bumptech.glide.load;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.engine.Resource;
-
 import java.io.IOException;
 
 /**
@@ -21,7 +19,7 @@
    * <p> Decoders should make a best effort attempt to quickly determine if they are likely to be
    * able to decode data, but should not attempt to completely read the given data. A typical
    * implementation would check the file headers verify they match content the decoder expects to
-   * handle (ie a GIF decoder should verify that the image contains the GIF header block. </p>
+   * handle (i.e. a GIF decoder should verify that the image contains the GIF header block. </p>
    *
    * <p> Decoders that return {@code true} from {@link #handles(Object, Options)} may still
    * return {@code null} from {@link #decode(Object, int, int, Options)} if the data is
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index b11a635bd..659dad412 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.content.Context;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -40,6 +41,7 @@
    * Transformation. Otherwise the resource you request may be loaded from disk cache and your
    * Transformation may not be called.
    *
+   * @param context The Application context
    * @param resource  The resource to transform.
    * @param outWidth  The width of the view or target the resource will be displayed in, or {@link
    *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
@@ -49,5 +51,5 @@
    *                  original resource height.
    * @return The transformed resource.
    */
-  Resource<T> transform(Resource<T> resource, int outWidth, int outHeight);
+  Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 25ae1c129..7a379c792 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -2,10 +2,8 @@
 
 import android.content.res.AssetManager;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
-
 import java.io.IOException;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
index 1bd464284..29f9e4cc9 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.data;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 
@@ -35,6 +34,7 @@
 
     /**
      * Called when the load fails.
+     *
      * @param e a non-null {@link Exception} indicating why the load failed.
      */
     void onLoadFailed(Exception e);
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
index 63914f07c..1d7ce3c2e 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java
@@ -1,47 +1,47 @@
 package com.bumptech.glide.load.data;
 
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.HashMap;
 import java.util.Map;
 
 /**
  * Stores a mapping of data class to {@link com.bumptech.glide.load.data.DataRewinder.Factory} and
- * allows  registation of new types and factories.
+ * allows registration of new types and factories.
  */
 public class DataRewinderRegistry {
-  private final Map<Class, DataRewinder.Factory> rewinders = new HashMap<>();
-  private static final DataRewinder.Factory DEFAULT_FACTORY = new DataRewinder.Factory<Object>() {
-    @Override
-    public DataRewinder<Object> build(Object data) {
-      return new DefaultRewinder(data);
-    }
+  private final Map<Class<?>, DataRewinder.Factory<?>> rewinders = new HashMap<>();
+  private static final DataRewinder.Factory<?> DEFAULT_FACTORY =
+      new DataRewinder.Factory<Object>() {
+        @Override
+        public DataRewinder<Object> build(Object data) {
+          return new DefaultRewinder(data);
+        }
 
-    @Override
-    public Class<Object> getDataClass() {
-      throw new UnsupportedOperationException("Not implemented");
-    }
-  };
+        @Override
+        public Class<Object> getDataClass() {
+          throw new UnsupportedOperationException("Not implemented");
+        }
+      };
 
-  public synchronized void register(DataRewinder.Factory factory) {
+  public synchronized void register(DataRewinder.Factory<?> factory) {
     rewinders.put(factory.getDataClass(), factory);
   }
 
   @SuppressWarnings("unchecked")
   public synchronized <T> DataRewinder<T> build(T data) {
     Preconditions.checkNotNull(data);
-    DataRewinder.Factory result = rewinders.get(data.getClass());
+    DataRewinder.Factory<T> result = (DataRewinder.Factory<T>) rewinders.get(data.getClass());
     if (result == null) {
       for (DataRewinder.Factory<?> registeredFactory : rewinders.values()) {
         if (registeredFactory.getDataClass().isAssignableFrom(data.getClass())) {
-          result = registeredFactory;
+          result = (DataRewinder.Factory<T>) registeredFactory;
           break;
         }
       }
     }
 
     if (result == null) {
-      result = DEFAULT_FACTORY;
+      result = (DataRewinder.Factory<T>) DEFAULT_FACTORY;
     }
     return result.build(data);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
index 6adf9ffa5..893efb440 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
@@ -2,7 +2,6 @@
 
 import android.content.res.AssetManager;
 import android.os.ParcelFileDescriptor;
-
 import java.io.IOException;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 489892e3b..7d3492701 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -1,11 +1,9 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
@@ -13,8 +11,8 @@
  * Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}.
  */
 public class FileDescriptorLocalUriFetcher extends LocalUriFetcher<ParcelFileDescriptor> {
-  public FileDescriptorLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  public FileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index d9062bb12..e441bef2a 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -2,14 +2,13 @@
 
 import android.text.TextUtils;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.HttpException;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
 import com.bumptech.glide.util.LogTime;
-
+import com.bumptech.glide.util.Synthetic;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
@@ -23,7 +22,6 @@
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "HttpUrlFetcher";
   private static final int MAXIMUM_REDIRECTS = 5;
-  private static final int DEFAULT_TIMEOUT_MS = 2500;
   // Visible for testing.
   static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
       new DefaultHttpUrlConnectionFactory();
@@ -36,8 +34,8 @@
   private InputStream stream;
   private volatile boolean isCancelled;
 
-  public HttpUrlFetcher(GlideUrl glideUrl) {
-    this(glideUrl, DEFAULT_TIMEOUT_MS, DEFAULT_CONNECTION_FACTORY);
+  public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
+    this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);
   }
 
   // Visible for testing.
@@ -95,6 +93,10 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
     urlConnection.setUseCaches(false);
     urlConnection.setDoInput(true);
 
+    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that
+    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.
+    urlConnection.setInstanceFollowRedirects(false);
+
     // Connect explicitly to avoid errors in decoders if connection fails.
     urlConnection.connect();
     if (isCancelled) {
@@ -167,6 +169,10 @@ public DataSource getDataSource() {
   }
 
   private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
+
+    @Synthetic
+    DefaultHttpUrlConnectionFactory() { }
+
     @Override
     public HttpURLConnection build(URL url) throws IOException {
       return (HttpURLConnection) url.openConnection();
diff --git a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
index a79a24c33..08fce42d8 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java
@@ -2,7 +2,6 @@
 
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
-
 import java.io.IOException;
 import java.io.InputStream;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index add61c095..0f6488260 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -1,13 +1,10 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
@@ -21,25 +18,24 @@
 public abstract class LocalUriFetcher<T> implements DataFetcher<T> {
   private static final String TAG = "LocalUriFetcher";
   private final Uri uri;
-  private final Context context;
+  private final ContentResolver contentResolver;
   private T data;
 
   /**
    * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
    *
-   * @param context Any {@link android.content.Context}.
+   * @param contentResolver Any {@link android.content.ContentResolver}.
    * @param uri     A Uri pointing to a local asset. This load will fail if the uri isn't openable
    *                by {@link ContentResolver#openInputStream(android.net.Uri)}
    * @see ContentResolver#openInputStream(android.net.Uri)
    */
-  public LocalUriFetcher(Context context, Uri uri) {
-    this.context = context.getApplicationContext();
+  public LocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    this.contentResolver = contentResolver;
     this.uri = uri;
   }
 
   @Override
   public final void loadData(Priority priority, DataCallback<? super T> callback) {
-    ContentResolver contentResolver = context.getContentResolver();
     try {
       data = loadResource(uri, contentResolver);
     } catch (FileNotFoundException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
index 3fb7b3974..00879955f 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.data;
 
 import android.content.res.AssetManager;
-
 import java.io.IOException;
 import java.io.InputStream;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index 0704a922a..fe0eed476 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -1,9 +1,11 @@
 package com.bumptech.glide.load.data;
 
+import android.annotation.TargetApi;
 import android.content.ContentResolver;
-import android.content.Context;
+import android.content.UriMatcher;
 import android.net.Uri;
-
+import android.os.Build;
+import android.provider.ContactsContract;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -12,20 +14,78 @@
  * Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}.
  */
 public class StreamLocalUriFetcher extends LocalUriFetcher<InputStream> {
-  public StreamLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  /**
+   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537)
+   */
+  private static final int ID_CONTACTS_LOOKUP = 1;
+  /**
+   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo)
+   */
+  private static final int ID_CONTACTS_THUMBNAIL = 2;
+  /**
+   * A contact uri (e.g. content://com.android.contacts/contacts/38)
+   */
+  private static final int ID_CONTACTS_CONTACT = 3;
+  /**
+   * A contact display photo (high resolution) uri
+   * (e.g. content://com.android.contacts/5/display_photo)
+   */
+  private static final int ID_CONTACTS_PHOTO = 4;
+  /**
+   * Match the incoming Uri for special cases which we can handle nicely.
+   */
+  private static final UriMatcher URI_MATCHER;
+
+  static {
+    URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_CONTACTS_LOOKUP);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_CONTACTS_LOOKUP);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_CONTACTS_THUMBNAIL);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACTS_CONTACT);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/display_photo", ID_CONTACTS_PHOTO);
+  }
+
+  public StreamLocalUriFetcher(ContentResolver resolver, Uri uri) {
+    super(resolver, uri);
   }
 
   @Override
   protected InputStream loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    InputStream inputStream = contentResolver.openInputStream(uri);
+    InputStream inputStream = loadResourceFromUri(uri, contentResolver);
     if (inputStream == null) {
-      throw new FileNotFoundException("InputStream is null for :" + uri);
+      throw new FileNotFoundException("InputStream is null for " + uri);
     }
     return inputStream;
   }
 
+
+  private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    switch (URI_MATCHER.match(uri)) {
+      case ID_CONTACTS_CONTACT:
+        return openContactPhotoInputStream(contentResolver, uri);
+      case ID_CONTACTS_LOOKUP:
+        // If it was a Lookup uri then resolve it first, then continue loading the contact uri.
+        uri = ContactsContract.Contacts.lookupContact(contentResolver, uri);
+        if (uri == null) {
+          throw new FileNotFoundException("Contact cannot be found");
+        }
+        return openContactPhotoInputStream(contentResolver, uri);
+      case ID_CONTACTS_THUMBNAIL:
+      case ID_CONTACTS_PHOTO:
+      case UriMatcher.NO_MATCH:
+      default:
+        return contentResolver.openInputStream(uri);
+    }
+  }
+
+  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+  private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {
+    return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
+        true /*preferHighres*/);
+  }
+
   @Override
   protected void close(InputStream data) throws IOException {
     data.close();
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index e5e67fdd7..f7f7db337 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -1,18 +1,17 @@
 package com.bumptech.glide.load.data.mediastore;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.util.Log;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.ExifOrientationStream;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -21,29 +20,33 @@
  * A {@link DataFetcher} implementation for {@link InputStream}s that loads data from thumbnail
  * files obtained from the {@link MediaStore}.
  */
+@SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
 public class ThumbFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "MediaStoreThumbFetcher";
-  private final Context context;
   private final Uri mediaStoreImageUri;
   private final ThumbnailStreamOpener opener;
   private InputStream inputStream;
 
+  // TODO(nnaze): These build methods do not need the full Glide or Context objects.
+
   public static ThumbFetcher buildImageFetcher(Context context, Uri uri) {
-    return build(context, uri, new ImageThumbnailQuery());
+    return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));
   }
 
   public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
-    return build(context, uri, new VideoThumbnailQuery());
+    return build(context, uri, new VideoThumbnailQuery(context.getContentResolver()));
   }
 
   private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
     ArrayPool byteArrayPool = Glide.get(context).getArrayPool();
-    return new ThumbFetcher(context, uri, new ThumbnailStreamOpener(query, byteArrayPool));
+    ThumbnailStreamOpener opener = new ThumbnailStreamOpener(
+        Glide.get(context).getRegistry().getImageHeaderParsers(), query, byteArrayPool,
+        context.getContentResolver());
+    return new ThumbFetcher(uri, opener);
   }
 
   // Visible for testing.
-  ThumbFetcher(Context context, Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
-    this.context = context;
+  ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
     this.mediaStoreImageUri = mediaStoreImageUri;
     this.opener = opener;
   }
@@ -64,11 +67,11 @@ public void loadData(Priority priority, DataCallback<? super InputStream> callba
   }
 
   private InputStream openThumbInputStream() throws FileNotFoundException {
-    InputStream result = opener.open(context, mediaStoreImageUri);
+    InputStream result = opener.open(mediaStoreImageUri);
 
     int orientation = -1;
     if (result != null) {
-      orientation = opener.getOrientation(context, mediaStoreImageUri);
+      orientation = opener.getOrientation(mediaStoreImageUri);
     }
 
     if (orientation != -1) {
@@ -104,6 +107,13 @@ public DataSource getDataSource() {
   }
 
   static class VideoThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    VideoThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
       MediaStore.Video.Thumbnails.DATA
     };
@@ -112,19 +122,26 @@ public DataSource getDataSource() {
         + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String videoId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { videoId },
+          new String[] {videoId},
           null /*sortOrder*/);
     }
   }
 
 
   static class ImageThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    ImageThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
       MediaStore.Images.Thumbnails.DATA,
     };
@@ -133,13 +150,13 @@ public Cursor query(Context context, Uri uri) {
         + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String imageId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { imageId },
+          new String[] {imageId},
           null /*sortOrder*/);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
index befebff43..07474cd13 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
 
 interface ThumbnailQuery {
-  Cursor query(Context context, Uri uri);
+  Cursor query(Uri uri);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index e6cfbc23f..323f02e17 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -1,64 +1,75 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
+import android.content.ContentResolver;
 import android.database.Cursor;
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Log;
-
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.List;
 
 class ThumbnailStreamOpener {
   private static final String TAG = "ThumbStreamOpener";
   private static final FileService DEFAULT_SERVICE = new FileService();
+
   private final FileService service;
   private final ThumbnailQuery query;
   private final ArrayPool byteArrayPool;
+  private final ContentResolver contentResolver;
+  private final List<ImageHeaderParser> parsers;
 
-  public ThumbnailStreamOpener(ThumbnailQuery query, ArrayPool byteArrayPool) {
-    this(DEFAULT_SERVICE, query, byteArrayPool);
+  public ThumbnailStreamOpener(
+      List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
+    this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
-  public ThumbnailStreamOpener(FileService service, ThumbnailQuery query,
-      ArrayPool byteArrayPool) {
+  public ThumbnailStreamOpener(
+      List<ImageHeaderParser> parsers,
+      FileService service,
+      ThumbnailQuery query,
+      ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
     this.service = service;
     this.query = query;
     this.byteArrayPool = byteArrayPool;
+    this.contentResolver = contentResolver;
+    this.parsers = parsers;
   }
 
-  public int getOrientation(Context context, Uri uri) {
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
+  public int getOrientation(Uri uri) {
     InputStream is = null;
     try {
-      is = context.getContentResolver().openInputStream(uri);
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
-    } catch (IOException e) {
+      is = contentResolver.openInputStream(uri);
+      return ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
+      // openInputStream can throw NPEs.
+    } catch (IOException | NullPointerException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "Failed to open uri: " + uri, e);
+        Log.d(TAG, "Failed to open uri: " + uri, e);
       }
     } finally {
       if (is != null) {
-          try {
-              is.close();
-          } catch (IOException e) {
-              // Ignored.
-          }
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
       }
     }
-    return orientation;
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
   }
 
-  public InputStream open(Context context, Uri uri) throws FileNotFoundException {
+  public InputStream open(Uri uri) throws FileNotFoundException {
     Uri thumbnailUri = null;
     InputStream inputStream = null;
 
-    final Cursor cursor = query.query(context, uri);
+    final Cursor cursor = query.query(uri);
     try {
       if (cursor == null || !cursor.moveToFirst()) {
         return null;
@@ -78,7 +89,13 @@ public InputStream open(Context context, Uri uri) throws FileNotFoundException {
       }
     }
     if (thumbnailUri != null) {
-      inputStream = context.getContentResolver().openInputStream(thumbnailUri);
+      try {
+        inputStream = contentResolver.openInputStream(thumbnailUri);
+        // openInputStream can throw NPEs.
+      } catch (NullPointerException e) {
+        throw (FileNotFoundException)
+          new FileNotFoundException("NPE opening uri: " + thumbnailUri).initCause(e);
+      }
     }
     return inputStream;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
index bb8284dec..a97652e7d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
@@ -5,7 +5,6 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
-
 import java.io.File;
 import java.util.List;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
index 36e9ac5fb..e70792c74 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine;
 
 import com.bumptech.glide.load.Key;
-
 import java.security.MessageDigest;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
index 85e274eca..eb7d4a4bd 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
@@ -3,7 +3,6 @@
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.cache.DiskCache;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
index 2b42d1f9b..ae7cddb8d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.data.DataFetcher;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index 3a010fed0..bbd9504ed 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -12,7 +12,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
 import com.bumptech.glide.load.resource.UnitTransformation;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
@@ -199,8 +198,14 @@ boolean isSourceKey(Key key) {
       int size = loadData.size();
       for (int i = 0; i < size; i++) {
         LoadData<?> data = loadData.get(i);
-        cacheKeys.add(data.sourceKey);
-        cacheKeys.addAll(data.alternateKeys);
+        if (!cacheKeys.contains(data.sourceKey)) {
+          cacheKeys.add(data.sourceKey);
+        }
+        for (int j = 0; j < data.alternateKeys.size(); j++) {
+          if (!cacheKeys.contains(data.alternateKeys.get(j))) {
+            cacheKeys.add(data.alternateKeys.get(j));
+          }
+        }
       }
     }
     return cacheKeys;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 907826b3a..8b2abacef 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -2,7 +2,6 @@
 
 import android.support.v4.util.Pools;
 import android.util.Log;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.Registry;
@@ -16,9 +15,9 @@
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -38,30 +37,31 @@
     Poolable {
   private static final String TAG = "DecodeJob";
 
-  private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
+  @Synthetic final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
   private final List<Exception> exceptions = new ArrayList<>();
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
   private final DiskCacheProvider diskCacheProvider;
   private final Pools.Pool<DecodeJob<?>> pool;
-  private final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
+  @Synthetic final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
   private final ReleaseManager releaseManager = new ReleaseManager();
 
   private GlideContext glideContext;
-  private Key signature;
+  @Synthetic Key signature;
   private Priority priority;
   private EngineKey loadKey;
-  private int width;
-  private int height;
-  private DiskCacheStrategy diskCacheStrategy;
-  private Options options;
+  @Synthetic int width;
+  @Synthetic int height;
+  @Synthetic DiskCacheStrategy diskCacheStrategy;
+  @Synthetic Options options;
   private Callback<R> callback;
   private int order;
   private Stage stage;
   private RunReason runReason;
   private long startFetchTime;
+  private boolean onlyRetrieveFromCache;
 
   private Thread currentThread;
-  private Key currentSourceKey;
+  @Synthetic Key currentSourceKey;
   private Key currentAttemptingKey;
   private Object currentData;
   private DataSource currentDataSource;
@@ -89,6 +89,7 @@
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean onlyRetrieveFromCache,
       Options options,
       Callback<R> callback,
       int order) {
@@ -113,6 +114,7 @@
     this.width = width;
     this.height = height;
     this.diskCacheStrategy = diskCacheStrategy;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     this.options = options;
     this.callback = callback;
     this.order = order;
@@ -142,7 +144,7 @@ void release(boolean isRemovedFromQueue) {
   }
 
   /**
-   * Called when we've finished encoding (either becasue the encode process is complete, or because
+   * Called when we've finished encoding (either because the encode process is complete, or because
    * we don't have anything to encode).
    */
   private void onEncodeComplete() {
@@ -317,7 +319,8 @@ private Stage getNextStage(Stage current) {
         return diskCacheStrategy.decodeCachedData()
             ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
       case DATA_CACHE:
-        return Stage.SOURCE;
+        // Skip loading from source if the user opted to only retrieve the resource from cache.
+        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
       case SOURCE:
       case FINISHED:
         return Stage.FINISHED;
@@ -351,6 +354,7 @@ public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetche
   @Override
   public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
       DataSource dataSource) {
+    fetcher.cleanup();
     GlideException exception = new GlideException("Fetching data failed", e);
     exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
     exceptions.add(exception);
@@ -384,6 +388,10 @@ private void decodeFromRetrievedData() {
   }
 
   private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {
+    if (resource instanceof Initializable) {
+      ((Initializable) resource).initialize();
+    }
+
     Resource<R> result = resource;
     LockedResource<R> lockedResource = null;
     if (deferredEncodeManager.hasResourceToEncode()) {
@@ -456,11 +464,12 @@ public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
-  class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
+  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
 
     private final DataSource dataSource;
 
-    public DecodeCallback(DataSource dataSource) {
+    @Synthetic
+    DecodeCallback(DataSource dataSource) {
       this.dataSource = dataSource;
     }
 
@@ -471,7 +480,7 @@ public DecodeCallback(DataSource dataSource) {
       Resource<Z> transformed = decoded;
       if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
         appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
-        transformed = appliedTransformation.transform(decoded, width, height);
+        transformed = appliedTransformation.transform(glideContext, decoded, width, height);
       }
       // TODO: Make this the responsibility of the Transformation.
       if (!decoded.equals(transformed)) {
@@ -526,6 +535,9 @@ public DecodeCallback(DataSource dataSource) {
     private boolean isEncodeComplete;
     private boolean isFailed;
 
+    @Synthetic
+    ReleaseManager() { }
+
     synchronized boolean release(boolean isRemovedFromQueue) {
       isReleased = true;
       return isComplete(isRemovedFromQueue);
@@ -561,6 +573,9 @@ private boolean isComplete(boolean isRemovedFromQueue) {
     private ResourceEncoder<Z> encoder;
     private LockedResource<Z> toEncode;
 
+    @Synthetic
+    DeferredEncodeManager() { }
+
     // We just need the encoder and resource type to match, which this will enforce.
     @SuppressWarnings("unchecked")
     <X> void init(Key key, ResourceEncoder<X> encoder, LockedResource<X> toEncode) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
index 929515277..6198bc5f0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
@@ -2,12 +2,10 @@
 
 import android.support.v4.util.Pools.Pool;
 import android.util.Log;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
-
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 3d1e3133e..1dc070d50 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -4,7 +4,6 @@
 import android.os.MessageQueue;
 import android.support.v4.util.Pools;
 import android.util.Log;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -17,9 +16,9 @@
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
-
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.util.HashMap;
@@ -33,7 +32,7 @@
     EngineResource.ResourceListener {
   private static final String TAG = "Engine";
   private static final int JOB_POOL_SIZE = 150;
-  private final Map<Key, EngineJob> jobs;
+  private final Map<Key, EngineJob<?>> jobs;
   private final EngineKeyFactory keyFactory;
   private final MemoryCache cache;
   private final EngineJobFactory engineJobFactory;
@@ -50,10 +49,10 @@
    * Allows a request to indicate it no longer is interested in a given load.
    */
   public static class LoadStatus {
-    private final EngineJob engineJob;
+    private final EngineJob<?> engineJob;
     private final ResourceCallback cb;
 
-    public LoadStatus(ResourceCallback cb, EngineJob engineJob) {
+    public LoadStatus(ResourceCallback cb, EngineJob<?> engineJob) {
       this.cb = cb;
       this.engineJob = engineJob;
     }
@@ -63,17 +62,27 @@ public void cancel() {
     }
   }
 
-  public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
-      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor) {
-    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, null, null, null, null,
-        null, null);
+  public Engine(MemoryCache memoryCache,
+      DiskCache.Factory diskCacheFactory,
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor) {
+    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
+        null, null, null, null, null, null);
   }
 
   // Visible for testing.
-  Engine(MemoryCache cache, DiskCache.Factory diskCacheFactory, GlideExecutor diskCacheExecutor,
-      GlideExecutor sourceExecutor, Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,
-      Map<Key, WeakReference<EngineResource<?>>> activeResources, EngineJobFactory engineJobFactory,
-      DecodeJobFactory decodeJobFactory, ResourceRecycler resourceRecycler) {
+  Engine(MemoryCache cache,
+      DiskCache.Factory diskCacheFactory,
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
+      Map<Key, EngineJob<?>> jobs,
+      EngineKeyFactory keyFactory,
+      Map<Key, WeakReference<EngineResource<?>>> activeResources,
+      EngineJobFactory engineJobFactory,
+      DecodeJobFactory decodeJobFactory,
+      ResourceRecycler resourceRecycler) {
     this.cache = cache;
     this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
@@ -93,7 +102,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
     this.jobs = jobs;
 
     if (engineJobFactory == null) {
-      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor, this);
+      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor,
+          sourceUnlimitedExecutor, this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -143,6 +153,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       boolean isTransformationRequired,
       Options options,
       boolean isMemoryCacheable,
+      boolean useUnlimitedSourceExecutorPool,
+      boolean onlyRetrieveFromCache,
       ResourceCallback cb) {
     Util.assertMainThread();
     long startTime = LogTime.getLogTime();
@@ -168,7 +180,7 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       return null;
     }
 
-    EngineJob current = jobs.get(key);
+    EngineJob<?> current = jobs.get(key);
     if (current != null) {
       current.addCallback(cb);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -177,7 +189,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       return new LoadStatus(cb, current);
     }
 
-    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable);
+    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
+        useUnlimitedSourceExecutorPool);
     DecodeJob<R> decodeJob = decodeJobFactory.build(
         glideContext,
         model,
@@ -191,6 +204,7 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
         diskCacheStrategy,
         transformations,
         isTransformationRequired,
+        onlyRetrieveFromCache,
         options,
         engineJob);
     jobs.put(key, engineJob);
@@ -243,22 +257,22 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
   private EngineResource<?> getEngineResourceFromCache(Key key) {
     Resource<?> cached = cache.remove(key);
 
-    final EngineResource result;
+    final EngineResource<?> result;
     if (cached == null) {
       result = null;
     } else if (cached instanceof EngineResource) {
       // Save an object allocation if we've cached an EngineResource (the typical case).
-      result = (EngineResource) cached;
+      result = (EngineResource<?>) cached;
     } else {
-      result = new EngineResource(cached, true /*isMemoryCacheable*/);
+      result = new EngineResource<>(cached, true /*isMemoryCacheable*/);
     }
     return result;
   }
 
-  public void release(Resource resource) {
+  public void release(Resource<?> resource) {
     Util.assertMainThread();
     if (resource instanceof EngineResource) {
-      ((EngineResource) resource).release();
+      ((EngineResource<?>) resource).release();
     } else {
       throw new IllegalArgumentException("Cannot release anything but an EngineResource");
     }
@@ -283,7 +297,7 @@ public void onEngineJobComplete(Key key, EngineResource<?> resource) {
   @Override
   public void onEngineJobCancelled(EngineJob engineJob, Key key) {
     Util.assertMainThread();
-    EngineJob current = jobs.get(key);
+    EngineJob<?> current = jobs.get(key);
     if (engineJob.equals(current)) {
       jobs.remove(key);
     }
@@ -345,7 +359,7 @@ public DiskCache getDiskCache() {
   }
 
   private static class ResourceWeakReference extends WeakReference<EngineResource<?>> {
-    private final Key key;
+    @Synthetic final Key key;
 
     public ResourceWeakReference(Key key, EngineResource<?> r,
         ReferenceQueue<? super EngineResource<?>> q) {
@@ -379,8 +393,8 @@ public boolean queueIdle() {
 
   // Visible for testing.
   static class DecodeJobFactory {
-    private final DecodeJob.DiskCacheProvider diskCacheProvider;
-    private final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
+    @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
+    @Synthetic final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
         new FactoryPools.Factory<DecodeJob<?>>() {
           @Override
           public DecodeJob<?> create() {
@@ -406,6 +420,7 @@ public boolean queueIdle() {
         DiskCacheStrategy diskCacheStrategy,
         Map<Class<?>, Transformation<?>> transformations,
         boolean isTransformationRequired,
+        boolean onlyRetrieveFromCache,
         Options options,
         DecodeJob.Callback<R> callback) {
       DecodeJob<R> result = (DecodeJob<R>) pool.acquire();
@@ -422,6 +437,7 @@ public boolean queueIdle() {
           diskCacheStrategy,
           transformations,
           isTransformationRequired,
+          onlyRetrieveFromCache,
           options,
           callback,
           creationOrder++);
@@ -430,28 +446,32 @@ public boolean queueIdle() {
 
   // Visible for testing.
   static class EngineJobFactory {
-    private final GlideExecutor diskCacheExecutor;
-    private final GlideExecutor sourceExecutor;
-    private final EngineJobListener listener;
-    private final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
+    @Synthetic final GlideExecutor diskCacheExecutor;
+    @Synthetic final GlideExecutor sourceExecutor;
+    @Synthetic final GlideExecutor sourceUnlimitedExecutor;
+    @Synthetic final EngineJobListener listener;
+    @Synthetic final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
         new FactoryPools.Factory<EngineJob<?>>() {
           @Override
           public EngineJob<?> create() {
-            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, listener, pool);
+            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
+                listener, pool);
           }
         });
 
     EngineJobFactory(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
-        EngineJobListener listener) {
+        GlideExecutor sourceUnlimitedExecutor, EngineJobListener listener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
+      this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
       this.listener = listener;
     }
 
     @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable) {
+    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,
+        boolean useUnlimitedSourceGeneratorPool) {
       EngineJob<R> result = (EngineJob<R>) pool.acquire();
-      return result.init(key, isMemoryCacheable);
+      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index c58965ca1..6c193eafc 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -4,15 +4,14 @@
 import android.os.Looper;
 import android.os.Message;
 import android.support.v4.util.Pools;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -39,9 +38,11 @@
   private final EngineJobListener listener;
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
+  private final GlideExecutor sourceUnlimitedExecutor;
 
   private Key key;
   private boolean isCacheable;
+  private boolean useUnlimitedSourceGeneratorPool;
   private Resource<?> resource;
   private DataSource dataSource;
   private boolean hasResource;
@@ -57,31 +58,38 @@
   private volatile boolean isCancelled;
 
   EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
       EngineJobListener listener, Pools.Pool<EngineJob<?>> pool) {
-    this(diskCacheExecutor, sourceExecutor, listener, pool, DEFAULT_FACTORY);
+    this(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, listener, pool,
+        DEFAULT_FACTORY);
   }
 
   // Visible for testing.
   EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
       EngineJobListener listener, Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
+    this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
     this.listener = listener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
 
   // Visible for testing.
-  EngineJob<R> init(Key key, boolean isCacheable) {
+  EngineJob<R> init(Key key, boolean isCacheable, boolean useUnlimitedSourceGeneratorPool) {
     this.key = key;
     this.isCacheable = isCacheable;
+    this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
     return this;
   }
 
   public void start(DecodeJob<R> decodeJob) {
     this.decodeJob = decodeJob;
-    GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : sourceExecutor;
+    GlideExecutor executor = decodeJob.willDecodeFromCache()
+        ? diskCacheExecutor
+        : getActiveSourceExecutor();
     executor.execute(decodeJob);
   }
 
@@ -110,6 +118,10 @@ public void removeCallback(ResourceCallback cb) {
     }
   }
 
+  private GlideExecutor getActiveSourceExecutor() {
+    return useUnlimitedSourceGeneratorPool ? sourceUnlimitedExecutor : sourceExecutor;
+  }
+
   // We cannot remove callbacks while notifying our list of callbacks directly because doing so
   // would cause a ConcurrentModificationException. However, we need to obey the cancellation
   // request such that if notifying a callback early in the callbacks list cancels a callback later
@@ -136,8 +148,9 @@ void cancel() {
 
     isCancelled = true;
     decodeJob.cancel();
-    boolean isPendingJobRemoved =
-        diskCacheExecutor.remove(decodeJob) || sourceExecutor.remove(decodeJob);
+    boolean isPendingJobRemoved = diskCacheExecutor.remove(decodeJob)
+        || sourceExecutor.remove(decodeJob)
+        || sourceUnlimitedExecutor.remove(decodeJob);
     listener.onEngineJobCancelled(this, key);
 
     if (isPendingJobRemoved) {
@@ -150,7 +163,8 @@ boolean isCancelled() {
     return isCancelled;
   }
 
-  private void handleResultOnMainThread() {
+  @Synthetic
+  void handleResultOnMainThread() {
     stateVerifier.throwIfRecycled();
     if (isCancelled) {
       resource.recycle();
@@ -181,7 +195,8 @@ private void handleResultOnMainThread() {
     release(false /*isRemovedFromQueue*/);
   }
 
-  private void handleCancelledOnMainThread() {
+  @Synthetic
+  void handleCancelledOnMainThread() {
     stateVerifier.throwIfRecycled();
     if (!isCancelled) {
       throw new IllegalStateException("Not cancelled");
@@ -227,11 +242,12 @@ public void reschedule(DecodeJob<?> job) {
     if (isCancelled) {
       MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();
     } else {
-      sourceExecutor.execute(job);
+      getActiveSourceExecutor().execute(job);
     }
   }
 
-  private void handleExceptionOnMainThread() {
+  @Synthetic
+  void handleExceptionOnMainThread() {
     stateVerifier.throwIfRecycled();
     if (isCancelled) {
       release(false /*isRemovedFromQueue*/);
@@ -268,9 +284,12 @@ public StateVerifier getVerifier() {
 
   private static class MainThreadCallback implements Handler.Callback {
 
+    @Synthetic
+    MainThreadCallback() { }
+
     @Override
     public boolean handleMessage(Message message) {
-      EngineJob job = (EngineJob) message.obj;
+      EngineJob<?> job = (EngineJob<?>) message.obj;
       switch (message.what) {
         case MSG_COMPLETE:
           job.handleResultOnMainThread();
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index 855f48b04..a95e820a8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -4,7 +4,6 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 import java.util.Map;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
index b458d3132..ec00d0a06 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java
@@ -3,7 +3,6 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
-
 import java.util.Map;
 
 class EngineKeyFactory {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index 0ba087590..c03168f69 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine;
 
 import android.os.Looper;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index 5ae6da255..4dca3166a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -3,10 +3,8 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
-
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.PrintWriter;
@@ -59,10 +57,10 @@ public Throwable fillInStackTrace() {
   /**
    * Returns a list of causes that are immediate children of this exception.
    *
-   * @see #getRootCauses().
-   *
    * <p>Causes may or may not be {@link GlideException GlideExceptions}. Causes may also not be root
-   * causes, and in turn my have been caused by other failures.
+   * causes, and in turn my have been caused by other failures.</p>
+   *
+   * @see #getRootCauses()
    */
   public List<Exception> getCauses() {
     return causes;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
new file mode 100644
index 000000000..9b34820b1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.load.engine;
+
+/**
+ * A callback allowing a resource to do some optimization on a background thread before being
+ * returned to the ui.
+ */
+public interface Initializable {
+
+  /**
+   * Called on a background thread so the {@link Resource} can do some eager initialization.
+   */
+  void initialize();
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
index 4df0cc8ed..d182da6ea 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
@@ -1,11 +1,9 @@
 package com.bumptech.glide.load.engine;
 
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
index 3e21cc186..5ee05aca7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine;
 
 import android.support.v4.util.Pools;
-
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
 
@@ -33,7 +33,8 @@
     return result;
   }
 
-  private LockedResource() { }
+  @Synthetic
+  LockedResource() { }
 
   private void init(Resource<Z> toWrap) {
     isRecycled = false;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index 0801cd92b..b0d444ed9 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -6,7 +6,6 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
-
 import java.io.File;
 import java.util.List;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
index f6221fa1d..2fbd7051e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -5,7 +5,6 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
-
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
index ddd5d55cb..6d8d365b8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRecycler.java
@@ -3,7 +3,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 
 /**
@@ -33,10 +33,13 @@ public void recycle(Resource<?> resource) {
   private static class ResourceRecyclerCallback implements Handler.Callback {
     public static final int RECYCLE_RESOURCE = 1;
 
+    @Synthetic
+    ResourceRecyclerCallback() { }
+
     @Override
     public boolean handleMessage(Message message) {
       if (message.what == RECYCLE_RESOURCE) {
-        Resource resource = (Resource) message.obj;
+        Resource<?> resource = (Resource<?>) message.obj;
         resource.recycle();
         return true;
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
index 275ea1b06..c3f3420dc 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine;
 
 import android.util.Log;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Key;
@@ -9,7 +8,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoader.LoadData;
 import com.bumptech.glide.util.LogTime;
-
 import java.util.Collections;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
index 048a43247..18427396a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 /**
  * Interface for handling operations on a primitive array type.
- * @param <T> Array type (eg byte[], int[])
+ * @param <T> Array type (e.g. byte[], int[])
  */
 public interface ArrayAdapterInterface<T> {
 
@@ -15,11 +15,6 @@
    */
   int getArrayLength(T array);
 
-  /**
-   * Reset the array for re-use (e.g. set all values to 0).
-   */
-  void resetArray(T array);
-
   /**
    * Allocate and return an array of the specified size.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
index 34d78b312..bfdb18621 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -22,6 +22,8 @@
    * Returns a non-null array of the given type with a length >= to the given size.
    *
    * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   *
+   * <p>This class makes no guarantees about the contents of the returned array.
    */
   <T> T get(int size, Class<T> arrayClass);
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
index 1a24f4c9c..f9448856b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.graphics.Bitmap;
-
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 
 /**
@@ -54,7 +54,8 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());
   }
 
-  private static String getBitmapString(int width, int height, Bitmap.Config config) {
+  @Synthetic
+  static String getBitmapString(int width, int height, Bitmap.Config config) {
     return "[" + width + "x" + height + "], " + config;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
index 32702852b..ffdba43d3 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import com.bumptech.glide.util.Util;
-
 import java.util.Queue;
 
 abstract class BaseKeyPool<T extends Poolable> {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
index 96a79def3..95f5ff708 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import java.util.Arrays;
-
 /**
  * Adapter for handling primitive byte arrays.
  */
@@ -19,11 +17,6 @@ public int getArrayLength(byte[] array) {
     return array.length;
   }
 
-  @Override
-  public void resetArray(byte[] array) {
-    Arrays.fill(array, (byte) 0);
-  }
-
   @Override
   public byte[] newArray(int length) {
     return new byte[length];
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index ea29e42ad..d190a475f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
 import android.support.annotation.Nullable;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -120,7 +120,7 @@ private void makeTail(LinkedEntry<K, V> entry) {
   }
 
   private static class LinkedEntry<K, V> {
-    private final K key;
+    @Synthetic final K key;
     private List<V> values;
     LinkedEntry<K, V> next;
     LinkedEntry<K, V> prev;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
index e6f8129be..4fb179c38 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import java.util.Arrays;
-
 /**
  * Adapter for handling primitive int arrays.
  */
@@ -19,11 +17,6 @@ public int getArrayLength(int[] array) {
     return array.length;
   }
 
-  @Override
-  public void resetArray(int[] array) {
-    Arrays.fill(array, 0);
-  }
-
   @Override
   public int[] newArray(int length) {
     return new int[length];
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
index 072aa25fd..6da2cb0e0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -3,9 +3,8 @@
 import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
 import android.util.Log;
-
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.NavigableMap;
@@ -29,8 +28,8 @@
 
   private final GroupedLinkedMap<Key, Object> groupedMap = new GroupedLinkedMap<>();
   private final KeyPool keyPool = new KeyPool();
-  private final Map<Class, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();
-  private final Map<Class, ArrayAdapterInterface> adapters = new HashMap<>();
+  private final Map<Class<?>, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();
+  private final Map<Class<?>, ArrayAdapterInterface<?>> adapters = new HashMap<>();
   private final int maxSize;
   private int currentSize;
 
@@ -52,7 +51,8 @@ public LruArrayPool(int maxSize) {
   public synchronized <T> void put(T array, Class<T> arrayClass) {
     ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
     int size = arrayAdapter.getArrayLength(array);
-    if (!isSmallEnoughForReuse(size)) {
+    int arrayBytes = size * arrayAdapter.getElementSizeInBytes();
+    if (!isSmallEnoughForReuse(arrayBytes)) {
       return;
     }
     Key key = keyPool.get(size, arrayClass);
@@ -61,7 +61,7 @@ public LruArrayPool(int maxSize) {
     NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
     Integer current = sizes.get(key.size);
     sizes.put(key.size, current == null ? 1 : current + 1);
-    currentSize += size * arrayAdapter.getElementSizeInBytes();
+    currentSize += arrayBytes;
     evict();
   }
 
@@ -85,9 +85,7 @@ public LruArrayPool(int maxSize) {
       }
     }
 
-    if (result != null) {
-      arrayAdapter.resetArray(result);
-    } else {
+    if (result == null) {
       if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
         Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
       }
@@ -102,8 +100,8 @@ public LruArrayPool(int maxSize) {
     return (T) groupedMap.get(key);
   }
 
-  private boolean isSmallEnoughForReuse(int intSize) {
-    return intSize <= maxSize / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
+  private boolean isSmallEnoughForReuse(int byteSize) {
+    return byteSize <= maxSize / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
   }
 
   private boolean mayFillRequest(int requestedSize, Integer actualSize) {
@@ -176,7 +174,7 @@ private void decrementArrayOfSize(int size, Class<?> arrayClass) {
 
   @SuppressWarnings("unchecked")
   private <T> ArrayAdapterInterface<T> getAdapterFromType(Class<T> arrayPoolClass) {
-    ArrayAdapterInterface adapter = adapters.get(arrayPoolClass);
+    ArrayAdapterInterface<?> adapter = adapters.get(arrayPoolClass);
     if (adapter == null) {
       if (arrayPoolClass.equals(int[].class)) {
         adapter = new IntegerArrayAdapter();
@@ -188,7 +186,7 @@ private void decrementArrayOfSize(int size, Class<?> arrayClass) {
       }
       adapters.put(arrayPoolClass, adapter);
     }
-    return adapter;
+    return (ArrayAdapterInterface<T>) adapter;
   }
 
   // VisibleForTesting
@@ -205,7 +203,10 @@ int getCurrentSize() {
 
   private static final class KeyPool extends BaseKeyPool<Key> {
 
-    Key get(int size, Class arrayClass) {
+    @Synthetic
+    KeyPool() { }
+
+    Key get(int size, Class<?> arrayClass) {
       Key result = get();
       result.init(size, arrayClass);
       return result;
@@ -219,14 +220,14 @@ protected Key create() {
 
   private static final class Key implements Poolable {
     private final KeyPool pool;
-    private int size;
-    private Class arrayClass;
+    @Synthetic int size;
+    private Class<?> arrayClass;
 
     Key(KeyPool pool) {
       this.pool = pool;
     }
 
-    void init(int length, Class arrayClass) {
+    void init(int length, Class<?> arrayClass) {
       this.size = length;
       this.arrayClass = arrayClass;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 8edb0f23c..2cf9c0f37 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -8,7 +8,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
@@ -169,17 +169,10 @@ private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config
   // Setting these two values provides Bitmaps that are essentially equivalent to those returned
   // from Bitmap.createBitmap.
   private static void normalize(Bitmap bitmap) {
-    maybeSetAlpha(bitmap);
+    bitmap.setHasAlpha(true);
     maybeSetPreMultiplied(bitmap);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-  private static void maybeSetAlpha(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
-      bitmap.setHasAlpha(true);
-    }
-  }
-
   @TargetApi(Build.VERSION_CODES.KITKAT)
   private static void maybeSetPreMultiplied(Bitmap bitmap) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
@@ -292,6 +285,10 @@ public void remove(Bitmap bitmap) {
   }
 
   private static class NullBitmapTracker implements BitmapTracker {
+
+    @Synthetic
+    NullBitmapTracker() { }
+
     @Override
     public void add(Bitmap bitmap) {
       // Do nothing.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index 4e9dbdd2e..05964ba05 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -4,9 +4,8 @@
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.support.annotation.Nullable;
-
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.util.HashMap;
 import java.util.Map;
 import java.util.NavigableMap;
@@ -180,7 +179,7 @@ protected Key create() {
   static final class Key implements Poolable {
     private final KeyPool pool;
 
-    private int size;
+    @Synthetic int size;
     private Bitmap.Config config;
 
     public Key(KeyPool pool) {
@@ -226,7 +225,8 @@ public int hashCode() {
     }
   }
 
-  private static String getBitmapString(int size, Bitmap.Config config) {
+  @Synthetic
+  static String getBitmapString(int size, Bitmap.Config config) {
     return "[" + size + "](" + config + ")";
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index 007ae8151..205ec7e4f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -4,9 +4,8 @@
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.support.annotation.Nullable;
-
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.util.TreeMap;
 
 /**
@@ -102,7 +101,8 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(size);
   }
 
-  private static String getBitmapString(int size) {
+  @Synthetic
+  static String getBitmapString(int size) {
     return "[" + size + "]";
   }
 
@@ -124,7 +124,7 @@ protected Key create() {
   // Visible for testing.
   static final class Key implements Poolable {
     private final KeyPool pool;
-    private int size;
+    @Synthetic int size;
 
     Key(KeyPool pool) {
       this.pool = pool;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
index 01736759f..31cdcf025 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java
@@ -1,9 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Key;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
index 73bbe74c7..d551af16a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import com.bumptech.glide.load.Key;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
index 35586d8ae..13318a8fc 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
@@ -2,7 +2,7 @@
 
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayDeque;
 import java.util.HashMap;
 import java.util.Map;
@@ -65,12 +65,18 @@ void release(Key key) {
   private static class WriteLock  {
     final Lock lock = new ReentrantLock();
     int interestedThreads;
+
+    @Synthetic
+    WriteLock() { }
   }
 
   private static class WriteLockPool {
     private static final int MAX_POOL_SIZE = 10;
     private final Queue<WriteLock> pool = new ArrayDeque<>();
 
+    @Synthetic
+    WriteLockPool() { }
+
     WriteLock obtain() {
       WriteLock result;
       synchronized (pool) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index 4aeb30c6d..c0e6f5269 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -5,11 +5,9 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.util.Log;
-
 import com.bumptech.glide.disklrucache.DiskLruCache;
 import com.bumptech.glide.disklrucache.DiskLruCache.Value;
 import com.bumptech.glide.load.Key;
-
 import java.io.File;
 import java.io.IOException;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
index 885a8e97e..ab4ca652c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.content.Context;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
index a69112738..225743b89 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.content.Context;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 455204dca..44071a869 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.annotation.SuppressLint;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LruCache;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
index b432c2825..3cf56d4c5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 49ee8459b..7e0bb505e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.engine.cache;
 
-import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
 import android.text.format.Formatter;
 import android.util.DisplayMetrics;
 import android.util.Log;
-
 import com.bumptech.glide.util.Preconditions;
 
 /**
@@ -110,12 +108,13 @@ private String toMb(int bytes) {
     return Formatter.formatFileSize(context, bytes);
   }
 
-  @TargetApi(Build.VERSION_CODES.KITKAT)
   private static boolean isLowMemoryDevice(ActivityManager activityManager) {
+    // Explicitly check with an if statement, on some devices both parts of boolean expressions
+    // can be evaluated even if we'd normally expect a short circuit.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       return activityManager.isLowRamDevice();
     } else {
-      return Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB;
+      return false;
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index 612350704..2a81c4d9a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -1,13 +1,12 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.support.v4.util.Pools;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.LruCache;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
-
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
@@ -56,7 +55,7 @@ private String calculateHexStringDigest(Key key) {
 
   private static final class PoolableDigestContainer implements FactoryPools.Poolable {
 
-    private final MessageDigest messageDigest;
+    @Synthetic final MessageDigest messageDigest;
     private final StateVerifier stateVerifier = StateVerifier.newInstance();
 
     PoolableDigestContainer(MessageDigest messageDigest) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index dd970fb84..b79e11178 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -4,13 +4,15 @@
 import android.os.StrictMode.ThreadPolicy;
 import android.support.annotation.NonNull;
 import android.util.Log;
-
+import com.bumptech.glide.util.Synthetic;
 import java.io.File;
 import java.io.FilenameFilter;
+import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -44,6 +46,17 @@
   private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
   private final boolean executeSynchronously;
 
+  /**
+   * The default thread name prefix for executors from unlimited thread pool used to
+   * load/decode/transform data not found in cache.
+   */
+  private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
+  /**
+   * The default keep alive time for threads in source unlimited executor pool in milliseconds.
+   */
+  private static final long SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS =
+      TimeUnit.SECONDS.toMillis(10);
+
   /**
    * Returns a new fixed thread pool with the default thread count returned from
    * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
@@ -108,16 +121,68 @@ public static GlideExecutor newSourceExecutor(int threadCount, String name,
         false /*preventNetworkOperations*/, false /*executeSynchronously*/);
   }
 
+  /**
+   * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
+   * created by default, {@link #SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS} keep alive
+   * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
+   * blocking queue, for example, {@link PriorityBlockingQueue} effectively won't create more than
+   * {@code corePoolSize} threads.
+   * See <a href=
+   * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">
+   * ThreadPoolExecutor documentation</a>.
+   *
+   * <p>Source executors allow network operations on their threads.
+   */
+  public static GlideExecutor newUnlimitedSourceExecutor() {
+    return new GlideExecutor(0 /* corePoolSize */,
+        Integer.MAX_VALUE /* maximumPoolSize */,
+        SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS,
+        SOURCE_UNLIMITED_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT,
+        false /*preventNetworkOperations*/,
+        false /*executeSynchronously*/,
+        new SynchronousQueue<Runnable>());
+  }
+
   // Visible for testing.
   GlideExecutor(int poolSize, String name,
       UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
       boolean executeSynchronously) {
+    this(
+        poolSize /* corePoolSize */,
+        poolSize /* maximumPoolSize */,
+        0 /* keepAliveTimeInMs */,
+        name,
+        uncaughtThrowableStrategy,
+        preventNetworkOperations,
+        executeSynchronously);
+  }
+
+  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously) {
+    this(
+        corePoolSize,
+        maximumPoolSize,
+        keepAliveTimeInMs,
+        name,
+        uncaughtThrowableStrategy,
+        preventNetworkOperations,
+        executeSynchronously,
+        new PriorityBlockingQueue<Runnable>());
+  }
+
+  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously, BlockingQueue<Runnable> queue) {
     super(
-        poolSize /*corePoolSize*/,
-        poolSize /*maximumPoolSize*/,
-        0 /*keepAliveTime*/,
+        corePoolSize,
+        maximumPoolSize,
+        keepAliveTimeInMs,
         TimeUnit.MILLISECONDS,
-        new PriorityBlockingQueue<Runnable>(),
+        queue,
         new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
     this.executeSynchronously = executeSynchronously;
   }
@@ -139,10 +204,21 @@ public void execute(Runnable command) {
 
   private <T> Future<T> maybeWait(Future<T> future) {
     if (executeSynchronously) {
-        try {
-        future.get();
-      } catch (InterruptedException | ExecutionException e) {
-        throw new RuntimeException(e);
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
       }
     }
     return future;
@@ -167,6 +243,10 @@ public void execute(Runnable command) {
    * http://goo.gl/8H670N.
    */
   public static int calculateBestThreadCount() {
+    // We override the current ThreadPolicy to allow disk reads.
+    // This shouldn't actually do disk-IO and accesses a device file.
+    // See: https://github.com/bumptech/glide/issues/1170
+    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
     File[] cpus = null;
     try {
       File cpuInfo = new File(CPU_LOCATION);
@@ -181,6 +261,8 @@ public boolean accept(File file, String s) {
       if (Log.isLoggable(TAG, Log.ERROR)) {
         Log.e(TAG, "Failed to calculate accurate cpu count", t);
       }
+    } finally {
+      StrictMode.setThreadPolicy(originalPolicy);
     }
 
     int cpuCount = cpus != null ? cpus.length : 0;
@@ -230,13 +312,13 @@ protected void handle(Throwable t) {
   }
 
   /**
-   * A {@link java.util.concurrent.ThreadFactory} that builds threads with priority {@link
+   * A {@link java.util.concurrent.ThreadFactory} that builds threads slightly above priority {@link
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
     private final String name;
-    private final UncaughtThrowableStrategy uncaughtThrowableStrategy;
-    private final boolean preventNetworkOperations;
+    @Synthetic final UncaughtThrowableStrategy uncaughtThrowableStrategy;
+    @Synthetic final boolean preventNetworkOperations;
     private int threadNum;
 
     DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy,
@@ -251,7 +333,9 @@ public synchronized Thread newThread(@NonNull Runnable runnable) {
       final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
         @Override
         public void run() {
-          android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+          android.os.Process.setThreadPriority(
+              android.os.Process.THREAD_PRIORITY_BACKGROUND
+              + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE);
           if (preventNetworkOperations) {
             StrictMode.setThreadPolicy(
                 new ThreadPolicy.Builder()
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index 04243f947..a2f92a9db 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -5,13 +5,12 @@
 import android.os.Looper;
 import android.os.SystemClock;
 import android.util.Log;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.security.MessageDigest;
 import java.util.HashSet;
 import java.util.Set;
@@ -143,6 +142,9 @@ private long getNextDelay() {
 
   private static class UniqueKey implements Key {
 
+    @Synthetic
+    UniqueKey() { }
+
     @Override
     public void updateDiskCacheKey(MessageDigest messageDigest) {
       throw new UnsupportedOperationException();
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index 9bd0fd808..42a5a46c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -3,12 +3,10 @@
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
-
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.util.Util;
-
 import java.util.HashMap;
 import java.util.Map;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
index b423df158..9c07fb07c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/PreFillType.java
@@ -2,7 +2,6 @@
 
 import android.graphics.Bitmap;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.util.Preconditions;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
index baa57e8c9..7083de7bc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -1,17 +1,14 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorAssetPathFetcher;
 import com.bumptech.glide.load.data.StreamAssetPathFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 
 /**
@@ -61,10 +58,15 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       AssetFetcherFactory<InputStream> {
 
+    private final AssetManager assetManager;
+
+    public StreamFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
@@ -85,10 +87,15 @@ public void teardown() {
       ParcelFileDescriptor>,
       AssetFetcherFactory<ParcelFileDescriptor> {
 
+    private final AssetManager assetManager;
+
+    public FileDescriptorFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 52683e37d..8a486cce7 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -1,13 +1,10 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.EmptySignature;
-
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -90,8 +87,7 @@ public DataSource getDataSource() {
   public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
 
     @Override
-    public ModelLoader<byte[], ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
         @Override
         public ByteBuffer convert(byte[] model) {
@@ -117,8 +113,7 @@ public void teardown() {
   public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
 
     @Override
-    public ModelLoader<byte[], InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<InputStream>() {
         @Override
         public InputStream convert(byte[] model) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
index 4fbd048eb..278d16f2f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferEncoder.java
@@ -1,11 +1,9 @@
 package com.bumptech.glide.load.model;
 
 import android.util.Log;
-
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index febd8bc1b..cb28480a1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -1,15 +1,12 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -37,8 +34,7 @@ public boolean handles(File file) {
   public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
 
     @Override
-    public ModelLoader<File, ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<File, ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
       return new ByteBufferFileLoader();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
index 1a105edde..0e3297acb 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -1,14 +1,11 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.util.Base64;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -20,7 +17,7 @@
  *
  * <p>See http://www.ietf.org/rfc/rfc2397.txt  for a complete description of the 'data' URL scheme.
  *
- * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],somedata"</pre>
+ * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],some_data</pre>
  *
  * @param <Data> The type of data that can be opened.
  */
@@ -148,8 +145,7 @@ public void close(InputStream inputStream) throws IOException {
     }
 
     @Override
-    public final ModelLoader<String, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new DataUrlLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index e917a8f8b..104af06e4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -1,15 +1,12 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.os.ParcelFileDescriptor;
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -115,8 +112,7 @@ public Factory(FileOpener<Data> opener) {
     }
 
     @Override
-    public final ModelLoader<File, Data> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<File, Data> build(MultiModelLoaderFactory multiFactory) {
       return new FileLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index 91cd2ebb1..02a26aa26 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -3,10 +3,8 @@
 import android.net.Uri;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
-
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.security.MessageDigest;
@@ -37,6 +35,8 @@
   @Nullable private URL safeUrl;
   @Nullable private volatile byte[] cacheKeyBytes;
 
+  private int hashCode;
+
   public GlideUrl(URL url) {
     this(url, Headers.DEFAULT);
   }
@@ -141,8 +141,10 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    int hashCode = getCacheKey().hashCode();
-    hashCode = 31 * hashCode + headers.hashCode();
+    if (hashCode == 0) {
+      hashCode = getCacheKey().hashCode();
+      hashCode = 31 * hashCode + headers.hashCode();
+    }
     return hashCode;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 27164f763..31b30bb5d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
 import android.text.TextUtils;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -131,7 +130,7 @@ public int hashCode() {
      * Adds a value for the given header and returns this builder.
      *
      * <p> Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
-     * (ie an oauth token). </p>
+     * (i.e. an OAuth token). </p>
      *
      * @see #addHeader(String, LazyHeaderFactory)
 
@@ -168,7 +167,7 @@ public Builder addHeader(String key, LazyHeaderFactory factory) {
      * <p> If the given value is {@code null}, the header at the given key will be removed. </p>
      *
      * <p> Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
-     * (ie an oauth token). </p>
+     * (i.e. an OAuth token). </p>
      */
     public Builder setHeader(String key, String value) {
       return setHeader(key, value == null ? null : new StringHeaderFactory(value));
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index ac81aa270..5326fd2d9 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -5,14 +5,12 @@
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.text.TextUtils;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.File;
 import java.io.FileNotFoundException;
 
@@ -99,8 +97,14 @@ public DataSource getDataSource() {
    */
   public static final class Factory implements ModelLoaderFactory<Uri, File> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, File> build(Context context, MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, File> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreFileLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
index 0a4ce4c06..a4f10978a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java
@@ -1,10 +1,8 @@
 package com.bumptech.glide.load.model;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
-
 import java.util.Queue;
 
 /**
@@ -110,7 +108,7 @@ public void release() {
     @Override
     public boolean equals(Object o) {
       if (o instanceof ModelKey) {
-        ModelKey other = (ModelKey) o;
+        @SuppressWarnings("unchecked") ModelKey<A> other = (ModelKey<A>) o;
         return width == other.width && height == other.height && model.equals(other.model);
       }
       return false;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
index c64c6d2bd..230551c5d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.load.model;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.Collections;
 import java.util.List;
 
@@ -23,7 +21,7 @@
  *
  * This not only avoids having to duplicate dimensions in xml and in your code in order to determine
  * the size of a view on devices with different densities, but also allows you to use layout weights
- * or otherwise programatically put the dimensions of the view without forcing you to fetch a
+ * or otherwise programmatically put the dimensions of the view without forcing you to fetch a
  * generic resource size.
  *
  * The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index c3813f9ad..19e126019 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -18,13 +18,11 @@
   /**
    * Build a concrete ModelLoader for this model type.
    *
-   * @param context      A context that cannot be retained by the factory but can be retained by the
-   *                     {@link ModelLoader}
    * @param multiFactory A map of classes to factories that can be used to construct additional
    *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
    * @return A new {@link ModelLoader}
    */
-  ModelLoader<T, Y> build(Context context, MultiModelLoaderFactory multiFactory);
+  ModelLoader<T, Y> build(MultiModelLoaderFactory multiFactory);
 
   /**
    * A lifecycle method that will be called when this factory is about to replaced.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index bf3ffbab4..77923f2c4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -1,8 +1,7 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -18,8 +17,8 @@
   private final MultiModelLoaderFactory multiModelLoaderFactory;
   private final ModelLoaderCache cache = new ModelLoaderCache();
 
-  public ModelLoaderRegistry(Context context, Pool<List<Exception>> exceptionListPool) {
-    this(new MultiModelLoaderFactory(context, exceptionListPool));
+  public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
+    this(new MultiModelLoaderFactory(exceptionListPool));
   }
 
   // Visible for testing.
@@ -95,6 +94,9 @@ public ModelLoaderRegistry(Context context, Pool<List<Exception>> exceptionListP
   private static class ModelLoaderCache {
     private final Map<Class<?>, Entry<?>> cachedModelLoaders = new HashMap<>();
 
+    @Synthetic
+    ModelLoaderCache() { }
+
     public void clear() {
       cachedModelLoaders.clear();
     }
@@ -113,7 +115,7 @@ public void clear() {
     }
 
     private static class Entry<Model> {
-      private final List<ModelLoader<Model, ?>> loaders;
+      @Synthetic final List<ModelLoader<Model, ?>> loaders;
 
       public Entry(List<ModelLoader<Model, ?>> loaders) {
         this.loaders = loaders;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index 4466666b7..dd8b59921 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
@@ -10,7 +9,6 @@
 import com.bumptech.glide.load.data.DataFetcher.DataCallback;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.util.Preconditions;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index 3948b6736..4c63136a5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -22,20 +20,18 @@
   private static final Factory DEFAULT_FACTORY = new Factory();
   private static final ModelLoader<Object, Object> EMPTY_MODEL_LOADER = new EmptyModelLoader();
   private final List<Entry<?, ?>> entries = new ArrayList<>();
-  private final Context context;
   private final Factory factory;
   private final Set<Entry<?, ?>> alreadyUsedEntries = new HashSet<>();
   private final Pool<List<Exception>> exceptionListPool;
 
-  public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool) {
-    this(context, exceptionListPool, DEFAULT_FACTORY);
+  public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
+    this(exceptionListPool, DEFAULT_FACTORY);
   }
 
   // Visible for testing.
-  MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool,
+  MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool,
       Factory factory) {
     this.exceptionListPool = exceptionListPool;
-    this.context = context.getApplicationContext();
     this.factory = factory;
   }
 
@@ -158,8 +154,7 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
 
   @SuppressWarnings("unchecked")
   private <Model, Data> ModelLoader<Model, Data> build(Entry<?, ?> entry) {
-    return (ModelLoader<Model, Data>) Preconditions
-        .checkNotNull(entry.factory.build(context, this));
+    return (ModelLoader<Model, Data>) Preconditions.checkNotNull(entry.factory.build(this));
   }
 
   @SuppressWarnings("unchecked")
@@ -169,8 +164,8 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
 
   private static class Entry<Model, Data> {
     private final Class<Model> modelClass;
-    private final Class<Data> dataClass;
-    private final ModelLoaderFactory<Model, Data> factory;
+    @Synthetic final Class<Data> dataClass;
+    @Synthetic final ModelLoaderFactory<Model, Data> factory;
 
     public Entry(Class<Model> modelClass, Class<Data> dataClass,
         ModelLoaderFactory<Model, Data> factory) {
@@ -197,6 +192,9 @@ public boolean handles(Class<?> modelClass) {
 
   private static class EmptyModelLoader implements ModelLoader<Object, Object> {
 
+    @Synthetic
+    EmptyModelLoader() { }
+
     @Nullable
     @Override
     public LoadData<Object> buildLoadData(Object o, int width, int height, Options options) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 8c420ae9f..24fc4b6ef 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -1,15 +1,12 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.Nullable;
 import android.util.Log;
-
 import com.bumptech.glide.load.Options;
-
 import java.io.InputStream;
 
 /**
@@ -23,10 +20,6 @@
   private final ModelLoader<Uri, Data> uriLoader;
   private final Resources resources;
 
-  public ResourceLoader(Context context, ModelLoader<Uri, Data> uriLoader) {
-    this(context.getResources(), uriLoader);
-  }
-
   public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
     this.resources = resources;
     this.uriLoader = uriLoader;
@@ -65,10 +58,15 @@ public boolean handles(Integer model) {
    */
   public static class StreamFactory implements ModelLoaderFactory<Integer, InputStream> {
 
+    private final Resources resources;
+
+    public StreamFactory(Resources resources) {
+      this.resources = resources;
+    }
+
     @Override
-    public ModelLoader<Integer, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context, multiFactory.build(Uri.class, InputStream.class));
+    public ModelLoader<Integer, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(resources, multiFactory.build(Uri.class, InputStream.class));
     }
 
     @Override
@@ -83,11 +81,16 @@ public void teardown() {
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<Integer, ParcelFileDescriptor> {
 
+    private final Resources resources;
+
+    public FileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
     @Override
-    public ModelLoader<Integer, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context,
-          multiFactory.build(Uri.class, ParcelFileDescriptor.class));
+    public ModelLoader<Integer, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
index 496dd9e84..28a06ca9e 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java
@@ -1,11 +1,9 @@
 package com.bumptech.glide.load.model;
 
 import android.util.Log;
-
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index 5f878b1c5..62061cf16 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,13 +1,10 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Options;
-
 import java.io.File;
 import java.io.InputStream;
 
@@ -63,8 +60,7 @@ private static Uri toFileUri(String path) {
   public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
     @Override
-    public ModelLoader<String, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
     }
 
@@ -81,8 +77,7 @@ public void teardown() {
       implements ModelLoaderFactory<String, ParcelFileDescriptor> {
 
     @Override
-    public ModelLoader<String, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index e93e41371..198f01bfa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -70,8 +68,7 @@ public DataSource getDataSource() {
   public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
 
     @Override
-    public ModelLoader<Model, Model> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Model, Model> build(MultiModelLoaderFactory multiFactory) {
       return new UnitModelLoader<>();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index d6a66a163..26cc3be5f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -1,16 +1,13 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
@@ -36,18 +33,16 @@
       )
   );
 
-  private final Context context;
   private final LocalUriFetcherFactory<Data> factory;
 
-  public UriLoader(Context context, LocalUriFetcherFactory<Data> factory) {
-    this.context = context;
+  public UriLoader(LocalUriFetcherFactory<Data> factory) {
     this.factory = factory;
   }
 
   @Override
   public LoadData<Data> buildLoadData(Uri model, int width, int height,
       Options options) {
-    return new LoadData<>(new ObjectKey(model), factory.build(context, model));
+    return new LoadData<>(new ObjectKey(model), factory.build(model));
   }
 
   @Override
@@ -61,7 +56,7 @@ public boolean handles(Uri model) {
    * @param <Data> The type of data the returned {@link DataFetcher} will obtain.
    */
   public interface LocalUriFetcherFactory<Data> {
-    DataFetcher<Data> build(Context context, Uri uri);
+    DataFetcher<Data> build(Uri uri);
   }
 
   /**
@@ -70,15 +65,20 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       LocalUriFetcherFactory<InputStream> {
 
+    private final ContentResolver contentResolver;
+
+    public StreamFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     @Override
-    public DataFetcher<InputStream> build(Context context, Uri uri) {
-      return new StreamLocalUriFetcher(context, uri);
+    public DataFetcher<InputStream> build(Uri uri) {
+      return new StreamLocalUriFetcher(contentResolver, uri);
     }
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
@@ -94,15 +94,20 @@ public void teardown() {
       ParcelFileDescriptor>,
       LocalUriFetcherFactory<ParcelFileDescriptor> {
 
+    private final ContentResolver contentResolver;
+
+    public FileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     @Override
-    public DataFetcher<ParcelFileDescriptor> build(Context context, Uri uri) {
-      return new FileDescriptorLocalUriFetcher(context, uri);
+    public DataFetcher<ParcelFileDescriptor> build(Uri uri) {
+      return new FileDescriptorLocalUriFetcher(contentResolver, uri);
     }
 
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
index f71d7e789..af2f2459a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -1,10 +1,7 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
@@ -50,8 +47,7 @@ public boolean handles(Uri uri) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlUriLoader<>(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index d10f4fac6..d2944e47e 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -2,14 +2,12 @@
 
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
-
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collections;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
index a42d2ca14..d29625946 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -1,8 +1,7 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
 import android.support.annotation.Nullable;
-
+import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -10,7 +9,6 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 
 /**
@@ -18,6 +16,15 @@
  * com.bumptech.glide.load.model.GlideUrl} (http/https URLS) into {@link java.io.InputStream} data.
  */
 public class HttpGlideUrlLoader implements ModelLoader<GlideUrl, InputStream> {
+  /**
+   * An integer option that is used to determine the maximum connect and read timeout durations (in
+   * milliseconds) for network connections.
+   *
+   * <p>Defaults to 2500ms.
+   */
+  public static final Option<Integer> TIMEOUT = Option.memory(
+      "com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout", 2500);
+
   @Nullable private final ModelCache<GlideUrl, GlideUrl> modelCache;
 
   public HttpGlideUrlLoader() {
@@ -41,7 +48,8 @@ public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
         url = model;
       }
     }
-    return new LoadData<>(url, new HttpUrlFetcher(url));
+    int timeout = options.get(TIMEOUT);
+    return new LoadData<>(url, new HttpUrlFetcher(url, timeout));
   }
 
   @Override
@@ -56,8 +64,7 @@ public boolean handles(GlideUrl model) {
     private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpGlideUrlLoader(modelCache);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
index e3f11a6f4..37b1e12fa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -1,14 +1,11 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
@@ -44,8 +41,7 @@ public boolean handles(Uri model) {
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
index 635d8c131..c10cfc90a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -2,7 +2,6 @@
 
 import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
@@ -10,7 +9,6 @@
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 
 /**
@@ -43,9 +41,14 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreImageThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index 1ab758391..2263f1cc5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -3,7 +3,6 @@
 import android.content.Context;
 import android.net.Uri;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;
 import com.bumptech.glide.load.data.mediastore.ThumbFetcher;
@@ -12,7 +11,6 @@
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
 import com.bumptech.glide.signature.ObjectKey;
-
 import java.io.InputStream;
 
 /**
@@ -35,6 +33,7 @@
   @Nullable
   public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
+      // TODO(nnaze): Tighten down this call to just the dependencies neede by buildVideoFetcher
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
     } else {
       return null;
@@ -57,9 +56,14 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreVideoThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
index 5cbda7216..1dc7951d4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -1,13 +1,10 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-
 import java.io.InputStream;
 import java.net.URL;
 
@@ -40,8 +37,7 @@ public boolean handles(URL model) {
   public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
 
     @Override
-    public ModelLoader<URL, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<URL, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
index 702ed39f0..023e2d978 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.resource;
 
+import android.content.Context;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.security.MessageDigest;
 
 /**
@@ -28,7 +28,7 @@ private UnitTransformation() {
   }
 
   @Override
-  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight) {
     return resource;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
index 6b9d9afae..5a0f9064d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
@@ -4,14 +4,12 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.io.IOException;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
index 162783822..a414e6dd0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableEncoder.java
@@ -2,13 +2,11 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index fc80aa1fa..989664e20 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.drawable.BitmapDrawable;
-
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 import com.bumptech.glide.util.Util;
@@ -16,7 +16,8 @@
  * given {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is
  * recycled. </p>
  */
-public class BitmapDrawableResource extends DrawableResource<BitmapDrawable> {
+public class BitmapDrawableResource extends DrawableResource<BitmapDrawable>
+    implements Initializable {
   private final BitmapPool bitmapPool;
 
   public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
@@ -38,4 +39,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(drawable.getBitmap());
   }
+
+  @Override
+  public void initialize() {
+    drawable.getBitmap().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
index 6527b931e..299e31d42 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -3,13 +3,11 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -17,31 +15,43 @@
  */
 public class BitmapDrawableTransformation implements Transformation<BitmapDrawable> {
 
-  private final Context context;
-  private final BitmapPool bitmapPool;
   private final Transformation<Bitmap> wrapped;
 
-  public BitmapDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
-    this(context, Glide.get(context).getBitmapPool(), wrapped);
+  public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
+    this.wrapped = Preconditions.checkNotNull(wrapped);
+  }
+
+  /**
+   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
+   */
+  @Deprecated
+  public BitmapDrawableTransformation(
+      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
+    this(wrapped);
   }
 
-  // Visible for testing.
-  BitmapDrawableTransformation(Context context, BitmapPool bitmapPool,
+  /**
+   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
+   */
+  @Deprecated
+  public BitmapDrawableTransformation(
+      @SuppressWarnings("unused") Context context,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
       Transformation<Bitmap> wrapped) {
-    this.context = context.getApplicationContext();
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
-    this.wrapped = Preconditions.checkNotNull(wrapped);
+    this(wrapped);
   }
 
   @Override
-  public Resource<BitmapDrawable> transform(Resource<BitmapDrawable> drawableResourceToTransform,
-      int outWidth, int outHeight) {
+  public Resource<BitmapDrawable> transform(
+      Context context, Resource<BitmapDrawable> drawableResourceToTransform, int outWidth,
+      int outHeight) {
     BitmapDrawable drawableToTransform = drawableResourceToTransform.get();
     Bitmap bitmapToTransform = drawableToTransform.getBitmap();
 
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     BitmapResource bitmapResourceToTransform = BitmapResource.obtain(bitmapToTransform, bitmapPool);
     Resource<Bitmap> transformedBitmapResource =
-        wrapped.transform(bitmapResourceToTransform, outWidth, outHeight);
+        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
 
     if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
       return drawableResourceToTransform;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index d769ae12a..b4ef6c4ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -2,7 +2,6 @@
 
 import android.graphics.Bitmap;
 import android.util.Log;
-
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
@@ -10,7 +9,6 @@
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
-
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 4753d2476..102c688c0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -2,7 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.support.annotation.Nullable;
-
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
@@ -11,7 +11,8 @@
 /**
  * A resource wrapping a {@link android.graphics.Bitmap} object.
  */
-public class BitmapResource implements Resource<Bitmap> {
+public class BitmapResource implements Resource<Bitmap>,
+    Initializable {
   private final Bitmap bitmap;
   private final BitmapPool bitmapPool;
 
@@ -55,4 +56,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(bitmap);
   }
+
+  @Override
+  public void initialize() {
+    bitmap.prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index cdd367c82..f204cc54e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -3,7 +3,6 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
@@ -53,23 +52,29 @@
  */
 public abstract class BitmapTransformation implements Transformation<Bitmap> {
 
-  private final BitmapPool bitmapPool;
+  public BitmapTransformation() {
+    // Intentionally empty.
+  }
 
-  public BitmapTransformation(Context context) {
-    this(Glide.get(context).getBitmapPool());
+  @Deprecated
+  public BitmapTransformation(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public BitmapTransformation(BitmapPool bitmapPool) {
-    this.bitmapPool = bitmapPool;
+  @Deprecated
+  public BitmapTransformation(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   @Override
-  public final Resource<Bitmap> transform(Resource<Bitmap> resource, int outWidth, int outHeight) {
+  public final Resource<Bitmap> transform(
+      Context context, Resource<Bitmap> resource, int outWidth, int outHeight) {
     if (!Util.isValidDimensions(outWidth, outHeight)) {
       throw new IllegalArgumentException(
           "Cannot apply transformation on width: " + outWidth + " or height: " + outHeight
               + " less than or equal to zero and not Target.SIZE_ORIGINAL");
     }
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Bitmap toTransform = resource.get();
     int targetWidth = outWidth == Target.SIZE_ORIGINAL ? toTransform.getWidth() : outWidth;
     int targetHeight = outHeight == Target.SIZE_ORIGINAL ? toTransform.getHeight() : outHeight;
@@ -109,9 +114,9 @@ public BitmapTransformation(BitmapPool bitmapPool) {
    * @param toTransform The {@link android.graphics.Bitmap} to transform.
    * @param outWidth    The ideal width of the transformed bitmap (the transformed width does not
    *                    need to match exactly).
-   * @param outHeight   The ideal height of the transformed bitmap (the transformed heightdoes not
+   * @param outHeight   The ideal height of the transformed bitmap (the transformed height does not
    *                    need to match exactly).
    */
-  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
-      int outWidth, int outHeight);
+  protected abstract Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
index 6a89df27a..f24c63ce6 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -1,14 +1,144 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
+import android.graphics.drawable.Drawable;
 import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.request.transition.BitmapTransitionFactory;
+import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
+import com.bumptech.glide.request.transition.TransitionFactory;
 
 /**
- * Provides {@link Bitmap} specific animation options.
- *
- * TODO: we should probably just use GenericAnimationOptions instead.
+ * Contains {@link Bitmap} specific animation options.
  */
-public final class BitmapTransitionOptions extends TransitionOptions<BitmapTransitionOptions,
-    Bitmap> {
+public final class BitmapTransitionOptions extends
+    TransitionOptions<BitmapTransitionOptions, Bitmap> {
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade()
+   */
+  public static BitmapTransitionOptions withCrossFade() {
+    return new BitmapTransitionOptions().crossFade();
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int)
+   */
+  public static BitmapTransitionOptions withCrossFade(int duration) {
+    return new BitmapTransitionOptions().crossFade(duration);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int, int)
+   */
+  public static BitmapTransitionOptions withCrossFade(int animationId, int duration) {
+    return new BitmapTransitionOptions().crossFade(animationId, duration);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory)
+   */
+  public static BitmapTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return new BitmapTransitionOptions().crossFade(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory.Builder)
+   */
+  public static BitmapTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory.Builder builder) {
+    return new BitmapTransitionOptions().crossFade(builder);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a any animation
+   * that is possible on drawables.
+   *
+   * @see #transitionUsing(TransitionFactory)
+   */
+  public static BitmapTransitionOptions withWrapped(
+      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+    return new BitmapTransitionOptions().transitionUsing(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that uses the given transition factory.
+   *
+   * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
+   */
+  public static BitmapTransitionOptions with(
+      TransitionFactory<Bitmap> transitionFactory) {
+    return new BitmapTransitionOptions().transition(transitionFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public BitmapTransitionOptions crossFade() {
+    return crossFade(new DrawableCrossFadeFactory.Builder());
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param duration The duration of the animation, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}.
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
+  public BitmapTransitionOptions crossFade(int duration) {
+    return crossFade(new DrawableCrossFadeFactory.Builder(duration));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param animationId The id of the animation to use if no placeholder or previous resource is
+   *     set, see {@code DrawableCrossFadeFactory.Builder#setDefaultAnimationId(int)}.
+   * @param duration The duration of the cross fade, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}.
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
+  public BitmapTransitionOptions crossFade(int animationId, int duration) {
+    return crossFade(
+        new DrawableCrossFadeFactory.Builder(duration)
+            .setDefaultAnimationId(animationId));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return transitionUsing(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Enables a any Drawable based animation to run on Bitmaps as well.
+   */
+  public BitmapTransitionOptions transitionUsing(
+      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+    return transition(new BitmapTransitionFactory(drawableCrossFadeFactory));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+    return transitionUsing(builder.build());
+  }
 }
+
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
index b8cb4624a..6a6c9ec8f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ByteBufferBitmapDecoder.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index c81d59b9b..bdc38562a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -3,9 +3,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -19,19 +17,25 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterCrop";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterCrop(Context context) {
-    super(context);
+  public CenterCrop() {
+    // Intentionally empty.
+  }
+
+  @Deprecated
+  public CenterCrop(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public CenterCrop(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  @Deprecated
+  public CenterCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
index daeb15fad..6efdbad47 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -3,9 +3,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -19,17 +17,29 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterInside(Context context) {
-    super(context);
+  public CenterInside() {
+    // Intentionally empty.
+  }
+
+  /**
+   * Use {@link #CenterInside()}.
+   */
+  @Deprecated
+  public CenterInside(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public CenterInside(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  /**
+   * Use {@link #CenterInside()}.
+   */
+  @Deprecated
+  public CenterInside(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
index 39b602969..655487175 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
@@ -3,9 +3,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -21,19 +19,31 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CircleCrop." + VERSION;
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CircleCrop(Context context) {
-    super(context);
+  public CircleCrop() {
+    // Intentionally empty.
+  }
+
+  /**
+   * @deprecated Use {@link #CircleCrop()}.
+   */
+  @Deprecated
+  public CircleCrop(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public CircleCrop(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  /**
+   * @deprecated Use {@link #CircleCrop()}
+   */
+  @Deprecated
+  public CircleCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
similarity index 79%
rename from library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
rename to library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index 6f261e000..5bfe67f8c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -1,16 +1,15 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.GIF;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.JPEG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG_A;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.UNKNOWN;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.GIF;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.JPEG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG_A;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.UNKNOWN;
 
 import android.util.Log;
-
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -20,59 +19,25 @@
 /**
  * A class for parsing the exif orientation and other data from an image header.
  */
-public class ImageHeaderParser {
-  private static final String TAG = "ImageHeaderParser";
-  /**
-   * A constant indicating we were unable to parse the orientation from the image either because
-   * no exif segment containing orientation data existed, or because of an I/O error attempting to
-   * read the exif segment.
-   */
-  public static final int UNKNOWN_ORIENTATION = -1;
-
-  /**
-   * The format of the image data including whether or not the image may include transparent
-   * pixels.
-   */
-  public enum ImageType {
-    GIF(true),
-    JPEG(false),
-    /** PNG type with alpha. */
-    PNG_A(true),
-    /** PNG type without alpha. */
-    PNG(false),
-    /** WebP type with alpha. */
-    WEBP_A(true),
-    /** WebP type without alpha. */
-    WEBP(false),
-    /**
-     * Unrecognized type.
-     */
-    UNKNOWN(false);
-    private final boolean hasAlpha;
-
-    ImageType(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
-  }
+public final class DefaultImageHeaderParser implements ImageHeaderParser {
+  // Due to https://code.google.com/p/android/issues/detail?id=97751.
+  // TAG needs to be under 23 chars, so "Default" > "Dflt".
+  private static final String TAG = "DfltImageHeaderParser";
 
   private static final int GIF_HEADER = 0x474946;
   private static final int PNG_HEADER = 0x89504E47;
-  private static final int EXIF_MAGIC_NUMBER = 0xFFD8;
+  static final int EXIF_MAGIC_NUMBER = 0xFFD8;
   // "MM".
   private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
   // "II".
   private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
-  private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
-  private static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
+  static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
+  static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
       JPEG_EXIF_SEGMENT_PREAMBLE.getBytes(Charset.forName("UTF-8"));
   private static final int SEGMENT_SOS = 0xDA;
   private static final int MARKER_EOI = 0xD9;
-  private static final int SEGMENT_START_ID = 0xFF;
-  private static final int EXIF_SEGMENT_TYPE = 0xE1;
+  static final int SEGMENT_START_ID = 0xFF;
+  static final int EXIF_SEGMENT_TYPE = 0xE1;
   private static final int ORIENTATION_TAG_TYPE = 0x0112;
   private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
   // WebP-related
@@ -91,28 +56,29 @@ public boolean hasAlpha() {
   private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
   private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
 
-  private final ArrayPool byteArrayPool;
-  private final Reader reader;
+  @Override
+  public ImageType getType(InputStream is) throws IOException {
+    return getType(new StreamReader(Preconditions.checkNotNull(is)));
+  }
 
-  public ImageHeaderParser(InputStream is, ArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(is);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new StreamReader(is);
+  @Override
+  public ImageType getType(ByteBuffer byteBuffer) throws IOException {
+    return getType(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)));
   }
 
-  public ImageHeaderParser(ByteBuffer byteBuffer, ArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(byteBuffer);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new ByteBufferReader(byteBuffer);
+  @Override
+  public int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException {
+    return getOrientation(new StreamReader(Preconditions.checkNotNull(is)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  // 0xD0A3C68 -> <htm
-  // 0xCAFEBABE -> <!DOCTYPE...
-  public boolean hasAlpha() throws IOException {
-    return getType().hasAlpha();
+  @Override
+  public int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException {
+    return getOrientation(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  public ImageType getType() throws IOException {
+  private ImageType getType(Reader reader) throws IOException {
     int firstTwoBytes = reader.getUInt16();
 
     // JPEG.
@@ -173,7 +139,7 @@ public ImageType getType() throws IOException {
    * contain an orientation
    * @throws IOException
    */
-  public int getOrientation() throws IOException {
+  private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOException {
     final int magicNumber = reader.getUInt16();
 
     if (!handles(magicNumber)) {
@@ -182,7 +148,7 @@ public int getOrientation() throws IOException {
       }
       return UNKNOWN_ORIENTATION;
     } else {
-      int exifSegmentLength = moveToExifSegmentAndGetLength();
+      int exifSegmentLength = moveToExifSegmentAndGetLength(reader);
       if (exifSegmentLength == -1) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Failed to parse exif segment length, or exif segment not found");
@@ -192,14 +158,15 @@ public int getOrientation() throws IOException {
 
       byte[] exifData = byteArrayPool.get(exifSegmentLength, byte[].class);
       try {
-        return parseExifSegment(exifData, exifSegmentLength);
+        return parseExifSegment(reader, exifData, exifSegmentLength);
       } finally {
         byteArrayPool.put(exifData, byte[].class);
       }
     }
   }
 
-  private int parseExifSegment(byte[] tempArray, int exifSegmentLength) throws IOException {
+  private int parseExifSegment(Reader reader, byte[] tempArray, int exifSegmentLength)
+      throws IOException {
     int read = reader.read(tempArray, exifSegmentLength);
     if (read != exifSegmentLength) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -239,7 +206,7 @@ private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
    * Moves reader to the start of the exif segment and returns the length of the exif segment or
    * {@code -1} if no exif segment is found.
    */
-  private int moveToExifSegmentAndGetLength() throws IOException {
+  private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
     short segmentId, segmentType;
     int segmentLength;
     while (true) {
@@ -379,29 +346,33 @@ private static boolean handles(int imageMagicNumber) {
         || imageMagicNumber == INTEL_TIFF_MAGIC_NUMBER;
   }
 
-  private static class RandomAccessReader {
+  private static final class RandomAccessReader {
     private final ByteBuffer data;
 
-    public RandomAccessReader(byte[] data, int length) {
+    RandomAccessReader(byte[] data, int length) {
       this.data = (ByteBuffer) ByteBuffer.wrap(data)
           .order(ByteOrder.BIG_ENDIAN)
           .limit(length);
     }
 
-    public void order(ByteOrder byteOrder) {
+    void order(ByteOrder byteOrder) {
       this.data.order(byteOrder);
     }
 
-    public int length() {
+    int length() {
       return data.remaining();
     }
 
-    public int getInt32(int offset) {
-      return data.getInt(offset);
+    int getInt32(int offset) {
+      return isAvailable(offset, 4) ? data.getInt(offset) : -1;
+    }
+
+    short getInt16(int offset) {
+      return isAvailable(offset, 2) ? data.getShort(offset) : -1;
     }
 
-    public short getInt16(int offset) {
-      return data.getShort(offset);
+    private boolean isAvailable(int offset, int byteSize) {
+      return data.remaining() - offset >= byteSize;
     }
   }
 
@@ -413,11 +384,11 @@ public short getInt16(int offset) {
     int getByte() throws IOException;
   }
 
-  private static class ByteBufferReader implements Reader {
+  private static final class ByteBufferReader implements Reader {
 
     private final ByteBuffer byteBuffer;
 
-    public ByteBufferReader(ByteBuffer byteBuffer) {
+    ByteBufferReader(ByteBuffer byteBuffer) {
       this.byteBuffer = byteBuffer;
       byteBuffer.order(ByteOrder.BIG_ENDIAN);
     }
@@ -442,7 +413,10 @@ public long skip(long total) throws IOException {
     @Override
     public int read(byte[] buffer, int byteCount) throws IOException {
       int toRead = Math.min(byteCount, byteBuffer.remaining());
-      byteBuffer.get(buffer, 0 /*dstOffset*/, byteCount);
+      if (toRead == 0) {
+        return -1;
+      }
+      byteBuffer.get(buffer, 0 /*dstOffset*/, toRead);
       return toRead;
     }
 
@@ -455,10 +429,10 @@ public int getByte() throws IOException {
     }
   }
 
-  private static class StreamReader implements Reader {
+  private static final class StreamReader implements Reader {
     private final InputStream is;
     // Motorola / big endian byte order.
-    public StreamReader(InputStream is) {
+    StreamReader(InputStream is) {
       this.is = is;
     }
 
@@ -515,4 +489,3 @@ public int getByte() throws IOException {
     }
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index c5c293483..71548c5e9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import com.bumptech.glide.util.Synthetic;
+
 /**
  * Indicates the algorithm to use when downsampling images.
  */
@@ -60,9 +62,9 @@
   public static final DownsampleStrategy NONE = new None();
 
   /**
-   * Default strategy, currently {@link #AT_LEAST}.
+   * Default strategy, currently {@link #CENTER_OUTSIDE}.
    */
-  public static final DownsampleStrategy DEFAULT = AT_LEAST;
+  public static final DownsampleStrategy DEFAULT = CENTER_OUTSIDE;
 
   /**
    * Returns a float (0, +infinity) indicating a scale factor to apply to the source
@@ -99,6 +101,9 @@ public abstract SampleSizeRounding getSampleSizeRounding(int sourceWidth, int so
 
   private static class FitCenter extends DownsampleStrategy {
 
+    @Synthetic
+    FitCenter() { }
+
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
@@ -115,7 +120,11 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   }
 
   private static class CenterOutside extends DownsampleStrategy {
-     @Override
+
+    @Synthetic
+    CenterOutside() { }
+
+    @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
       float widthPercentage = requestedWidth / (float) sourceWidth;
@@ -132,6 +141,9 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
 
   private static class AtLeast extends DownsampleStrategy {
 
+    @Synthetic
+    AtLeast() { }
+
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
@@ -147,6 +159,10 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   }
 
   private static class AtMost extends DownsampleStrategy {
+
+    @Synthetic
+    AtMost() { }
+
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
@@ -166,7 +182,11 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
   }
 
   private static class None extends DownsampleStrategy {
-     @Override
+
+    @Synthetic
+    None() { }
+
+    @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
       return 1f;
@@ -181,6 +201,9 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
 
   private static class CenterInside extends DownsampleStrategy {
 
+    @Synthetic
+    CenterInside() { }
+
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
         int requestedHeight) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index d84dd89ab..e16adcc79 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -4,10 +4,12 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.os.Build;
+import android.support.annotation.Nullable;
 import android.util.DisplayMetrics;
 import android.util.Log;
-
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
@@ -17,12 +19,14 @@
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 
@@ -47,6 +51,30 @@
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
           DownsampleStrategy.AT_LEAST);
 
+  /**
+   * Ensure that the size of the bitmap is fixed to the requested width and height of the
+   * resource from the caller.  The final resource dimensions may differ from the requested
+   * width and height, and thus setting this to true may result in the bitmap size differing
+   * from the resource dimensions.
+   *
+   * This can be used as a performance optimization for KitKat and above by fixing the size of the
+   * bitmap for a collection of requested resources so that the bitmap pool will not need to
+   * allocate new bitmaps for images of different sizes.
+   */
+  public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
+
+  private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
+  private static final String ICO_MIME_TYPE = "image/x-ico";
+  private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
+      Collections.unmodifiableSet(
+          new HashSet<>(
+              Arrays.asList(
+                  WBMP_MIME_TYPE,
+                  ICO_MIME_TYPE
+              )
+          )
+      );
   private static final DecodeCallbacks EMPTY_CALLBACKS = new DecodeCallbacks() {
     @Override
     public void onObtainBounds() {
@@ -74,9 +102,11 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
   private final ArrayPool byteArrayPool;
+  private final List<ImageHeaderParser> parsers;
 
-  public Downsampler(DisplayMetrics displayMetrics, BitmapPool bitmapPool,
-       ArrayPool byteArrayPool) {
+  public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetrics,
+      BitmapPool bitmapPool, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.displayMetrics = Preconditions.checkNotNull(displayMetrics);
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
@@ -140,10 +170,12 @@ public boolean handles(ByteBuffer byteBuffer) {
 
     DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
     DownsampleStrategy downsampleStrategy = options.get(DOWNSAMPLE_STRATEGY);
+    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
 
     try {
       Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
-          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight, callbacks);
+          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,
+          fixBitmapToRequestedDimensions, callbacks);
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
@@ -154,25 +186,61 @@ public boolean handles(ByteBuffer byteBuffer) {
   private Bitmap decodeFromWrappedStreams(InputStream is,
       BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
       DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,
-      DecodeCallbacks callbacks) throws IOException {
+      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {
 
     int[] sourceDimensions = getDimensions(is, options, callbacks);
     int sourceWidth = sourceDimensions[0];
     int sourceHeight = sourceDimensions[1];
     String sourceMimeType = options.outMimeType;
 
-    int orientation = getOrientation(is);
-    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(getOrientation(is));
+    int orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
+    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
 
     options.inPreferredConfig = getConfig(is, decodeFormat);
     if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
       options.inDither = true;
     }
-    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, requestedWidth,
-        requestedHeight, options);
 
-    Bitmap downsampled = downsampleWithSize(is, options, bitmapPool, sourceWidth,
-        sourceHeight, callbacks);
+    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
+    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
+
+    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,
+        targetHeight, options);
+
+    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
+    if ((options.inSampleSize == 1 || isKitKatOrGreater)
+        && shouldUsePool(is)) {
+      int expectedWidth;
+      int expectedHeight;
+      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {
+        expectedWidth = targetWidth;
+        expectedHeight = targetHeight;
+      } else {
+        float densityMultiplier = isScaling(options)
+            ? (float) options.inTargetDensity / options.inDensity : 1f;
+        int sampleSize = options.inSampleSize;
+        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
+        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
+        expectedWidth = Math.round(downsampledWidth * densityMultiplier);
+        expectedHeight = Math.round(downsampledHeight * densityMultiplier);
+
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
+              + " [" + sourceWidth + "x" + sourceHeight + "]"
+              + ", sampleSize: " + sampleSize
+              + ", targetDensity: " + options.inTargetDensity
+              + ", density: " + options.inDensity
+              + ", density multiplier: " + densityMultiplier);
+        }
+      }
+      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
+      // will be -1 here.
+      if (expectedWidth > 0 && expectedHeight > 0) {
+        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);
+      }
+    }
+    Bitmap downsampled = decodeStream(is, options, callbacks);
     callbacks.onDecodeComplete(bitmapPool, downsampled);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -197,16 +265,13 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
 
   // Visible for testing.
   static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesToRotate,
-      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight,
+      int sourceWidth, int sourceHeight, int targetWidth, int targetHeight,
       BitmapFactory.Options options) {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
       return;
     }
 
-    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
-    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
-
     final float exactScaleFactor;
     if (degreesToRotate == 90 || degreesToRotate == 270) {
       // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
@@ -240,9 +305,17 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
         ? Math.max(widthScaleFactor, heightScaleFactor)
         : Math.min(widthScaleFactor, heightScaleFactor);
 
-    int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
-    if (rounding == SampleSizeRounding.MEMORY && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
-      powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+    int powerOfTwoSampleSize;
+    // BitmapFactory does not support downsampling wbmp files on platforms <= M. See b/27305903.
+    if (Build.VERSION.SDK_INT <= 23
+        && NO_DOWNSAMPLE_PRE_N_MIME_TYPES.contains(options.outMimeType)) {
+      powerOfTwoSampleSize = 1;
+    } else {
+      powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
+      if (rounding == SampleSizeRounding.MEMORY
+          && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
+        powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+      }
     }
 
     float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;
@@ -272,54 +345,6 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
     }
   }
 
-  private int getOrientation(InputStream is) throws IOException {
-    is.mark(MARK_POSITION);
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
-    try {
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine the image orientation from header", e);
-      }
-    } finally {
-      is.reset();
-    }
-    return orientation;
-  }
-
-  private Bitmap downsampleWithSize(InputStream is, BitmapFactory.Options options,
-      BitmapPool pool, int sourceWidth, int sourceHeight, DecodeCallbacks callbacks)
-      throws IOException {
-    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
-    if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT)
-        && shouldUsePool(is)) {
-
-      float densityMultiplier = isScaling(options)
-          ? (float) options.inTargetDensity / options.inDensity : 1f;
-
-      int sampleSize = options.inSampleSize;
-      int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
-      int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
-      int expectedWidth = Math.round(downsampledWidth * densityMultiplier);
-      int expectedHeight = Math.round(downsampledHeight * densityMultiplier);
-
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
-            + " [" + sourceWidth + "x" + sourceHeight + "]"
-            + ", sampleSize: " + sampleSize
-            + ", targetDensity: " + options.inTargetDensity
-            + ", density: " + options.inDensity
-            + ", density multiplier: " + densityMultiplier);
-      }
-      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
-      // will be -1 here.
-      if (expectedWidth > 0 && expectedHeight > 0) {
-        setInBitmap(options, pool, expectedWidth, expectedHeight, options.inPreferredConfig);
-      }
-    }
-    return decodeStream(is, options, callbacks);
-  }
-
   private boolean shouldUsePool(InputStream is) throws IOException {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
@@ -327,9 +352,8 @@ private boolean shouldUsePool(InputStream is) throws IOException {
       return true;
     }
 
-    is.mark(MARK_POSITION);
     try {
-      final ImageHeaderParser.ImageType type = new ImageHeaderParser(is, byteArrayPool).getType();
+      ImageHeaderParser.ImageType type = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
       // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
       // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
       return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(type);
@@ -337,8 +361,6 @@ private boolean shouldUsePool(InputStream is) throws IOException {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Cannot determine the image type from header", e);
       }
-    } finally {
-      is.reset();
     }
     return false;
   }
@@ -351,16 +373,13 @@ private boolean shouldUsePool(InputStream is) throws IOException {
     }
 
     boolean hasAlpha = false;
-    is.mark(MARK_POSITION);
     try {
-      hasAlpha = new ImageHeaderParser(is, byteArrayPool).hasAlpha();
+      hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Cannot determine whether the image has alpha or not from header"
             + ", format " + format, e);
       }
-    } finally {
-      is.reset();
     }
 
     return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
@@ -433,31 +452,27 @@ private static void logDecode(int sourceWidth, int sourceHeight, String outMimeT
         + ", thread: " + Thread.currentThread().getName());
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static String getInBitmapString(BitmapFactory.Options options) {
-    return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB
-        ? getBitmapString(options.inBitmap) : null;
+    return getBitmapString(options.inBitmap);
   }
 
+  @Nullable
   @TargetApi(Build.VERSION_CODES.KITKAT)
   private static String getBitmapString(Bitmap bitmap) {
-    final String result;
     if (bitmap == null) {
-      result = null;
-    } else {
-      String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
-          ? " (" + bitmap.getAllocationByteCount() + ")" : "";
-      result = "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
-          + sizeString;
+      return null;
     }
-    return result;
+
+    String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
+        ? " (" + bitmap.getAllocationByteCount() + ")" : "";
+    return  "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
+        + sizeString;
   }
 
   // BitmapFactory throws an IllegalArgumentException if any error occurs attempting to decode a
   // file when inBitmap is non-null, including those caused by partial or corrupt data. We still log
   // the error because the IllegalArgumentException is supposed to catch errors reusing Bitmaps, so
   // want some useful log output. In most cases this can be safely treated as a normal IOException.
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentException e,
       int outWidth, int outHeight, String outMimeType, BitmapFactory.Options options) {
     return new IOException("Exception decoding bitmap"
@@ -467,16 +482,12 @@ private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentExc
           + ", inBitmap: " + getInBitmapString(options), e);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
-      int height, Bitmap.Config config) {
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-      options.inBitmap = bitmapPool.getDirty(width, height, config);
-    }
+      int height) {
+    // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
+    options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static synchronized BitmapFactory.Options getDefaultOptions() {
     BitmapFactory.Options decodeBitmapOptions;
     synchronized (OPTIONS_QUEUE) {
@@ -497,7 +508,6 @@ private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.inTempStorage = null;
     decodeBitmapOptions.inDither = false;
@@ -510,11 +520,8 @@ private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.outWidth = 0;
     decodeBitmapOptions.outHeight = 0;
     decodeBitmapOptions.outMimeType = null;
-
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      decodeBitmapOptions.inBitmap = null;
-      decodeBitmapOptions.inMutable = true;
-    }
+    decodeBitmapOptions.inBitmap = null;
+    decodeBitmapOptions.inMutable = true;
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
index 9f728b1b3..c29ef691d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
@@ -3,9 +3,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.security.MessageDigest;
 
 /**
@@ -17,12 +15,24 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.FitCenter";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public FitCenter(Context context) {
-    super(context);
+  public FitCenter() {
+    // Intentionally empty.
+  }
+
+  /**
+   * @deprecated Use {@link #FitCenter()}.
+   */
+  @Deprecated
+  public FitCenter(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public FitCenter(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  /**
+   * @deprecated Use {@link #FitCenter()}.
+   */
+  @Deprecated
+  public FitCenter(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index 9a4b7b205..412c5cc5b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -4,8 +4,8 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
@@ -15,7 +15,8 @@
  * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
  * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
  */
-public class LazyBitmapDrawableResource implements Resource<BitmapDrawable> {
+public class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
+    Initializable {
 
   private final Bitmap bitmap;
   private final Resources resources;
@@ -55,4 +56,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(bitmap);
   }
+
+  @Override
+  public void initialize() {
+    bitmap.prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 187d3633f..24f2f35ef 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -18,7 +18,6 @@
  */
 
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
index 33af8b853..be3e804a2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -2,10 +2,9 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -22,8 +21,7 @@
    * @param roundingRadius the corner radius (in device-specific pixels).
    * @throws IllegalArgumentException if rounding radius is 0 or less.
    */
-  public RoundedCorners(BitmapPool bitmapPool, int roundingRadius) {
-    super(bitmapPool);
+  public RoundedCorners(int roundingRadius) {
     Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
     this.roundingRadius = roundingRadius;
   }
@@ -31,15 +29,28 @@ public RoundedCorners(BitmapPool bitmapPool, int roundingRadius) {
   /**
    * @param roundingRadius the corner radius (in device-specific pixels).
    * @throws IllegalArgumentException if rounding radius is 0 or less.
+   *
+   * @deprecated Use {@link #RoundedCorners(int)}
    */
-  public RoundedCorners(Context context, int roundingRadius) {
-    super(context);
-    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
-    this.roundingRadius = roundingRadius;
+  @Deprecated
+  public RoundedCorners(@SuppressWarnings("unused") BitmapPool bitmapPool, int roundingRadius) {
+    this(roundingRadius);
+  }
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   *
+   * @deprecated Use {@link #RoundedCorners(int)}
+   */
+  @Deprecated
+  public RoundedCorners(@SuppressWarnings("unused") Context context, int roundingRadius) {
+    this(roundingRadius);
   }
 
   @Override
-  protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.roundedCorners(pool, toTransform, outWidth, outHeight,
         roundingRadius);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
index 7d580e161..78ec0ff8b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -9,7 +8,6 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.ExceptionCatchingInputStream;
 import com.bumptech.glide.util.MarkEnforcingInputStream;
-
 import java.io.IOException;
 import java.io.InputStream;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 85da2b8c8..e7abbb8ab 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.BitmapShader;
 import android.graphics.Canvas;
@@ -15,10 +14,11 @@
 import android.os.Build;
 import android.support.annotation.NonNull;
 import android.util.Log;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
+import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.Lock;
@@ -34,17 +34,22 @@
   private static final int CIRCLE_CROP_PAINT_FLAGS = PAINT_FLAGS | Paint.ANTI_ALIAS_FLAG;
   private static final Paint CIRCLE_CROP_SHAPE_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
+
+  // See #738.
+  private static final List<String> MODELS_REQUIRING_BITMAP_LOCK =
+      Arrays.asList(
+          "XT1097",
+          "XT1085");
   /**
    * https://github.com/bumptech/glide/issues/738 On some devices (Moto X with android 5.1) bitmap
    * drawing is not thread safe.
    * This lock only locks for these specific devices. For other types of devices the lock is always
    * available and therefore does not impact performance
    */
-  private static final Lock BITMAP_DRAWABLE_LOCK = "XT1097".equals(Build.MODEL)
-      // TODO: Switch to Build.VERSION_CODES.LOLLIPOP_MR1 when apps have updated target API levels.
-      && Build.VERSION.SDK_INT == 22
-      ? new ReentrantLock()
-      : new NoLock();
+  private static final Lock BITMAP_DRAWABLE_LOCK =
+      MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL)
+          && Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP_MR1
+          ? new ReentrantLock() : new NoLock();
 
   static {
     CIRCLE_CROP_BITMAP_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
@@ -191,14 +196,7 @@ public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBi
    *                    transformation.
    */
   public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
-    setAlphaIfAvailable(outBitmap, inBitmap.hasAlpha());
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-  private static void setAlphaIfAvailable(Bitmap bitmap, boolean hasAlpha) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1 && bitmap != null) {
-      bitmap.setHasAlpha(hasAlpha);
-    }
+    outBitmap.setHasAlpha(inBitmap.hasAlpha());
   }
 
   /**
@@ -321,7 +319,7 @@ public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
 
     Bitmap result = pool.get(destMinEdge, destMinEdge, Bitmap.Config.ARGB_8888);
-    setAlphaIfAvailable(result, true /*hasAlpha*/);
+    result.setHasAlpha(true);
 
     BITMAP_DRAWABLE_LOCK.lock();
     try {
@@ -377,7 +375,7 @@ public static Bitmap roundedCorners(@NonNull BitmapPool pool, @NonNull Bitmap in
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
     Bitmap result = pool.get(width, height, Bitmap.Config.ARGB_8888);
 
-    setAlphaIfAvailable(result, true /* hasAlpha */);
+    result.setHasAlpha(true);
 
     BitmapShader shader = new BitmapShader(toTransform, Shader.TileMode.CLAMP,
         Shader.TileMode.CLAMP);
@@ -456,6 +454,10 @@ static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
   }
 
   private static final class NoLock implements Lock {
+
+    @Synthetic
+    NoLock() { }
+
     @Override
     public void lock() {
       // do nothing
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index 9c240aed5..98d9a0e59 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -4,14 +4,12 @@
 import android.graphics.Bitmap;
 import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
index 815c14b8f..41315a302 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.resource.bytes;
 
 import com.bumptech.glide.load.data.DataRewinder;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 4cea85519..163cbe50a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -1,21 +1,24 @@
 package com.bumptech.glide.load.resource.drawable;
 
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
-
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.Preconditions;
 
 /**
- * Simple wrapper for an Android {@link Drawable} which returns a {@link
- * android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable} based on it's {@link
- * android.graphics.drawable.Drawable.ConstantState state}.
+ * Simple wrapper for an Android {@link Drawable} which returns a
+ * {@link android.graphics.drawable.Drawable.ConstantState#newDrawable() new drawable}
+ * based on it's {@link android.graphics.drawable.Drawable.ConstantState state}.
  *
  * <b>Suggested usages only include {@code T}s where the new drawable is of the same or descendant
  * class.</b>
  *
  * @param <T> type of the wrapped {@link Drawable}
  */
-public abstract class DrawableResource<T extends Drawable> implements Resource<T> {
+public abstract class DrawableResource<T extends Drawable> implements Resource<T>,
+    Initializable {
   protected final T drawable;
 
   public DrawableResource(T drawable) {
@@ -25,11 +28,19 @@ public DrawableResource(T drawable) {
   @SuppressWarnings("unchecked")
   @Override
   public final T get() {
-    // Drawables contain temporary state related to how they're being displayed (alpha, color
-    // filter etc), so
-    // return a new copy each time. If we ever return the original drawable, it's temporary state
-    // may be changed
+    // Drawables contain temporary state related to how they're being displayed
+    // (alpha, color filter etc), so return a new copy each time.
+    // If we ever return the original drawable, it's temporary state may be changed
     // and subsequent copies may end up with that temporary state. See #276.
     return (T) drawable.getConstantState().newDrawable();
   }
+
+  @Override
+  public void initialize() {
+    if (drawable instanceof BitmapDrawable) {
+      ((BitmapDrawable) drawable).getBitmap().prepareToDraw();
+    } else if (drawable instanceof GifDrawable) {
+      ((GifDrawable) drawable).getFirstFrame().prepareToDraw();
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index 9d8c8a2f2..ebf582b81 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -1,9 +1,9 @@
 package com.bumptech.glide.load.resource.drawable;
 
 import android.graphics.drawable.Drawable;
-
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
+import com.bumptech.glide.request.transition.TransitionFactory;
 
 /**
  * Contains {@link Drawable} specific animation options.
@@ -11,28 +11,113 @@
 public final class DrawableTransitionOptions extends
     TransitionOptions<DrawableTransitionOptions, Drawable> {
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade()
+   */
   public static DrawableTransitionOptions withCrossFade() {
     return new DrawableTransitionOptions().crossFade();
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int)
+   */
   public static DrawableTransitionOptions withCrossFade(int duration) {
     return new DrawableTransitionOptions().crossFade(duration);
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int, int)
+   */
   public static DrawableTransitionOptions withCrossFade(int animationId, int duration) {
     return new DrawableTransitionOptions().crossFade(animationId, duration);
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory)
+   */
+  public static DrawableTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return new DrawableTransitionOptions().crossFade(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory.Builder)
+   */
+  public static DrawableTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory.Builder builder) {
+    return new DrawableTransitionOptions().crossFade(builder);
+  }
+
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that uses the given transition factory.
+   *
+   * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
+   */
+  public static DrawableTransitionOptions with(
+      TransitionFactory<Drawable> transitionFactory) {
+    return new DrawableTransitionOptions().transition(transitionFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
   public DrawableTransitionOptions crossFade() {
-    return transition(new DrawableCrossFadeFactory());
+    return crossFade(new DrawableCrossFadeFactory.Builder());
   }
 
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param duration The duration of the animation, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
   public DrawableTransitionOptions crossFade(int duration) {
-    return transition(new DrawableCrossFadeFactory(duration));
+    return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
 
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param animationId The id of the animation to use if no placeholder or previous resource is
+   *     set, see {@code DrawableCrossFadeFactory.Builder#setDefaultAnimationId(int)}.
+   * @param duration The duration of the cross fade, see
+   *     {@code DrawableCrossFadeFactory.Builder(int)}
+   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   */
   public DrawableTransitionOptions crossFade(int animationId, int duration) {
-    return transition(new DrawableCrossFadeFactory(animationId, duration));
+    return crossFade(
+        new DrawableCrossFadeFactory.Builder(duration)
+            .setDefaultAnimationId(animationId));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return transition(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+    return crossFade(builder.build());
   }
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
index 01c54c297..e932f3caf 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileDecoder.java
@@ -3,7 +3,6 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
index 4cc540b0c..beeec792e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileResource.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.resource.file;
 
 import com.bumptech.glide.load.resource.SimpleResource;
-
 import java.io.File;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index 51f73252d..2b56d271e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -3,26 +3,26 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.util.Log;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.List;
 import java.util.Queue;
 
 /**
@@ -44,28 +44,33 @@
   private static final GifHeaderParserPool PARSER_POOL = new GifHeaderParserPool();
 
   private final Context context;
+  private final List<ImageHeaderParser> parsers;
   private final GifHeaderParserPool parserPool;
   private final BitmapPool bitmapPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
   public ByteBufferGifDecoder(Context context) {
-    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
+    this(context, Glide.get(context).getRegistry().getImageHeaderParsers(),
+        Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
   }
 
   public ByteBufferGifDecoder(
-      Context context, BitmapPool bitmapPool, ArrayPool arrayPool) {
-    this(context, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
+      Context context, List<ImageHeaderParser> parsers, BitmapPool bitmapPool,
+      ArrayPool arrayPool) {
+    this(context, parsers, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
   // Visible for testing.
   ByteBufferGifDecoder(
       Context context,
+      List<ImageHeaderParser> parsers,
       BitmapPool bitmapPool,
       ArrayPool arrayPool,
       GifHeaderParserPool parserPool,
       GifDecoderFactory gifDecoderFactory) {
-    this.context = context;
+    this.context = context.getApplicationContext();
+    this.parsers = parsers;
     this.bitmapPool = bitmapPool;
     this.gifDecoderFactory = gifDecoderFactory;
     this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
@@ -74,9 +79,8 @@ public ByteBufferGifDecoder(
 
   @Override
   public boolean handles(ByteBuffer source, Options options) throws IOException {
-    ArrayPool byteArrayPool = new LruArrayPool();
     return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+        && ImageHeaderParserUtils.getType(parsers, source) == ImageType.GIF;
   }
 
   @Override
@@ -114,7 +118,7 @@ private GifDrawableResource decode(ByteBuffer byteBuffer, int width, int height,
             firstFrame);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Decoded gif from stream in " + LogTime.getElapsedMillis(startTime));
+      Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
     }
 
     return new GifDrawableResource(gifDrawable);
@@ -128,7 +132,7 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
     // than 0.
     int sampleSize = Math.max(1, powerOfTwoSampleSize);
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Downsampling gif"
+      Log.v(TAG, "Downsampling GIF"
           + ", sampleSize: " + sampleSize
           + ", target dimens: [" + targetWidth + "x" + targetHeight + "]"
           + ", actual dimens: [" + gifHeader.getWidth() + "x" + gifHeader.getHeight() + "]");
@@ -140,7 +144,7 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
   static class GifDecoderFactory {
     public GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
         ByteBuffer data, int sampleSize) {
-      return new GifDecoder(provider, header, data, sampleSize);
+      return new StandardGifDecoder(provider, header, data, sampleSize);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index dd75da497..a9d231006 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -4,7 +4,6 @@
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index dfcffbc6f..5e6f98eed 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
-import android.annotation.TargetApi;
+import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;
+
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -11,14 +12,13 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
+import android.support.annotation.VisibleForTesting;
 import android.view.Gravity;
-
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-
 import java.nio.ByteBuffer;
 
 /**
@@ -58,11 +58,11 @@
    */
   private boolean isVisible = true;
   /**
-   * The number of times we've looped over all the frames in the gif.
+   * The number of times we've looped over all the frames in the GIF.
    */
   private int loopCount;
   /**
-   * The number of times to loop through the gif animation.
+   * The number of times to loop through the GIF animation.
    */
   private int maxLoopCount = LOOP_FOREVER;
 
@@ -87,25 +87,33 @@
    *                            height of the view or
    *                            {@link com.bumptech.glide.request.target.Target}
    *                            this drawable is being loaded into).
-   * @param gifDecoder          The decoder to use to decode gif data.
-   * @param firstFrame          The decoded and transformed first frame of this gif.
+   * @param gifDecoder          The decoder to use to decode GIF data.
+   * @param firstFrame          The decoded and transformed first frame of this GIF.
    * @see #setFrameTransformation(com.bumptech.glide.load.Transformation, android.graphics.Bitmap)
    */
   public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool,
       Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
       Bitmap firstFrame) {
-    this(new GifState(context, bitmapPool,
-        new GifFrameLoader(context, gifDecoder, targetFrameWidth, targetFrameHeight,
-            frameTransformation, firstFrame)));
+    this(
+        new GifState(
+            bitmapPool,
+            new GifFrameLoader(
+                // TODO(b/27524013): Factor out this call to Glide.get()
+                Glide.get(context),
+                gifDecoder,
+                targetFrameWidth,
+                targetFrameHeight,
+                frameTransformation,
+                firstFrame)));
   }
 
   GifDrawable(GifState state) {
     this.state = Preconditions.checkNotNull(state);
   }
 
-  // Visible for testing.
-  GifDrawable(Context context, GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
-    this(new GifState(context, bitmapPool, frameLoader));
+  @VisibleForTesting
+  GifDrawable(GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
+    this(new GifState(bitmapPool, frameLoader));
     this.paint = paint;
   }
 
@@ -146,6 +154,15 @@ private void resetLoopCount() {
     loopCount = 0;
   }
 
+  /**
+   * Starts the animation from the first frame. Can only be called while animation is not running.
+   */
+  public void startFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "You cannot restart a currently running animation.");
+    state.frameLoader.setNextStartFromFirstFrame();
+    start();
+  }
+
   @Override
   public void start() {
     isStarted = true;
@@ -162,6 +179,8 @@ public void stop() {
   }
 
   private void startRunning() {
+    Preconditions.checkArgument(!isRecycled, "You cannot start a recycled Drawable. Ensure that"
+        + "you clear any references to the Drawable when clearing the corresponding request.");
     // If we have only a single frame, we don't want to decode it endlessly.
     if (state.frameLoader.getFrameCount() == 1) {
       invalidateSelf();
@@ -179,6 +198,9 @@ private void stopRunning() {
 
   @Override
   public boolean setVisible(boolean visible, boolean restart) {
+    Preconditions.checkArgument(!isRecycled, "Cannot change the visibility of a recycled resource."
+        + " Ensure that you unset the Drawable from your View before changing the View's"
+        + " visibility.");
     isVisible = visible;
     if (!visible) {
       stopRunning();
@@ -260,10 +282,9 @@ public int getOpacity() {
     return PixelFormat.TRANSPARENT;
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @Override
   public void onFrameReady() {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && getCallback() == null) {
+    if (getCallback() == null) {
       stop();
       invalidateSelf();
       return;
@@ -305,7 +326,9 @@ public void setLoopCount(int loopCount) {
     }
 
     if (loopCount == LOOP_INTRINSIC) {
-      maxLoopCount = state.frameLoader.getLoopCount();
+      int intrinsicCount = state.frameLoader.getLoopCount();
+      maxLoopCount =
+          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;
     } else {
       maxLoopCount = loopCount;
     }
@@ -313,13 +336,11 @@ public void setLoopCount(int loopCount) {
 
   static class GifState extends ConstantState {
     static final int GRAVITY = Gravity.FILL;
-    final Context context;
     final BitmapPool bitmapPool;
     final GifFrameLoader frameLoader;
 
-    public GifState(Context context, BitmapPool bitmapPool, GifFrameLoader frameLoader) {
+    public GifState(BitmapPool bitmapPool, GifFrameLoader frameLoader) {
       this.bitmapPool = bitmapPool;
-      this.context = context.getApplicationContext();
       this.frameLoader = frameLoader;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
index 44268ec8e..f2f842381 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableEncoder.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.util.Log;
-
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.io.File;
 import java.io.IOException;
 
@@ -32,7 +30,7 @@ public boolean encode(Resource<GifDrawable> data, File file, Options options) {
       success = true;
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Failed to encode gif drawable data", e);
+        Log.w(TAG, "Failed to encode GIF drawable data", e);
       }
     }
     return success;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index 6b8301462..d0275e023 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.load.resource.gif;
 
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 
 /**
  * A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
-public class GifDrawableResource extends DrawableResource<GifDrawable> {
+public class GifDrawableResource extends DrawableResource<GifDrawable>
+    implements Initializable {
   public GifDrawableResource(GifDrawable drawable) {
     super(drawable);
   }
@@ -25,4 +27,9 @@ public void recycle() {
     drawable.stop();
     drawable.recycle();
   }
+
+  @Override
+  public void initialize() {
+    drawable.getFirstFrame().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index 1d78c736e..06b1a4fb4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -2,14 +2,12 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -19,30 +17,43 @@
  */
 public class GifDrawableTransformation implements Transformation<GifDrawable> {
   private final Transformation<Bitmap> wrapped;
-  private final BitmapPool bitmapPool;
 
-  public GifDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
-    this(wrapped, Glide.get(context).getBitmapPool());
+  public GifDrawableTransformation(Transformation<Bitmap> wrapped) {
+    this.wrapped = Preconditions.checkNotNull(wrapped);
+  }
+
+  /**
+   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}.
+   */
+  @Deprecated
+  public GifDrawableTransformation(
+      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
+    this(wrapped);
   }
 
-  public GifDrawableTransformation(Transformation<Bitmap> wrapped, BitmapPool bitmapPool) {
-    this.wrapped = Preconditions.checkNotNull(wrapped);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+  /**
+   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}
+   */
+  @Deprecated
+  public GifDrawableTransformation(
+      Transformation<Bitmap> wrapped, @SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this(wrapped);
   }
 
   @Override
-  public Resource<GifDrawable> transform(Resource<GifDrawable> resource, int outWidth,
-      int outHeight) {
+  public Resource<GifDrawable> transform(
+      Context context, Resource<GifDrawable> resource, int outWidth, int outHeight) {
     GifDrawable drawable = resource.get();
 
     // The drawable needs to be initialized with the correct width and height in order for a view
     // displaying it to end up with the right dimensions. Since our transformations may arbitrarily
-    // modify the dimensions of our gif, here we create a stand in for a frame and pass it to the
+    // modify the dimensions of our GIF, here we create a stand in for a frame and pass it to the
     // transformation to see what the final transformed dimensions will be so that our drawable can
     // report the correct intrinsic width and height.
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Bitmap firstFrame = drawable.getFirstFrame();
     Resource<Bitmap> bitmapResource = new BitmapResource(firstFrame, bitmapPool);
-    Resource<Bitmap> transformed = wrapped.transform(bitmapResource, outWidth, outHeight);
+    Resource<Bitmap> transformed = wrapped.transform(context, bitmapResource, outWidth, outHeight);
     if (!bitmapResource.equals(transformed)) {
       bitmapResource.recycle();
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index d6b4263ec..9ad656df5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -3,13 +3,11 @@
 import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemClock;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
@@ -17,12 +15,13 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 import java.util.ArrayList;
@@ -32,12 +31,13 @@
 class GifFrameLoader {
   private final GifDecoder gifDecoder;
   private final Handler handler;
-  private final Context context;
   private final List<FrameCallback> callbacks = new ArrayList<>();
-  private final RequestManager requestManager;
+  @Synthetic final RequestManager requestManager;
+  private final BitmapPool bitmapPool;
 
   private boolean isRunning = false;
   private boolean isLoadPending = false;
+  private boolean startFromFirstFrame = false;
   private RequestBuilder<Bitmap> requestBuilder;
   private DelayTarget current;
   private boolean isCleared;
@@ -49,24 +49,37 @@
     void onFrameReady();
   }
 
-  public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int height,
-      Transformation<Bitmap> transformation, Bitmap firstFrame) {
-    this(context,
-        Glide.with(context),
+  public GifFrameLoader(
+      Glide glide,
+      GifDecoder gifDecoder,
+      int width,
+      int height,
+      Transformation<Bitmap> transformation,
+      Bitmap firstFrame) {
+    this(
+        glide.getBitmapPool(),
+        Glide.with(glide.getContext()),
         gifDecoder,
         null /*handler*/,
-        getRequestBuilder(context, width, height), transformation, firstFrame);
+        getRequestBuilder(Glide.with(glide.getContext()), width, height),
+        transformation,
+        firstFrame);
   }
 
   @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
-  GifFrameLoader(Context context, RequestManager requestManager, GifDecoder gifDecoder,
-      Handler handler, RequestBuilder<Bitmap> requestBuilder, Transformation<Bitmap> transformation,
+  GifFrameLoader(
+      BitmapPool bitmapPool,
+      RequestManager requestManager,
+      GifDecoder gifDecoder,
+      Handler handler,
+      RequestBuilder<Bitmap> requestBuilder,
+      Transformation<Bitmap> transformation,
       Bitmap firstFrame) {
     this.requestManager = requestManager;
     if (handler == null) {
       handler = new Handler(Looper.getMainLooper(), new FrameLoaderCallback());
     }
-    this.context = context;
+    this.bitmapPool = bitmapPool;
     this.handler = handler;
     this.requestBuilder = requestBuilder;
 
@@ -78,7 +91,7 @@ public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int hei
   void setFrameTransformation(Transformation<Bitmap> transformation, Bitmap firstFrame) {
     this.transformation = Preconditions.checkNotNull(transformation);
     this.firstFrame = Preconditions.checkNotNull(firstFrame);
-    requestBuilder = requestBuilder.apply(new RequestOptions().transform(context, transformation));
+    requestBuilder = requestBuilder.apply(new RequestOptions().transform(transformation));
   }
 
   Transformation<Bitmap> getFrameTransformation() {
@@ -140,7 +153,7 @@ int getFrameCount() {
   }
 
   int getLoopCount() {
-    return gifDecoder.getLoopCount();
+    return gifDecoder.getTotalIterationCount();
   }
 
   private void start() {
@@ -181,6 +194,10 @@ private void loadNextFrame() {
     if (!isRunning || isLoadPending) {
       return;
     }
+    if (startFromFirstFrame) {
+      gifDecoder.resetFrameIndex();
+      startFromFirstFrame = false;
+    }
     isLoadPending = true;
     // Get the delay before incrementing the pointer because the delay indicates the amount of time
     // we want to spend on the current frame.
@@ -194,11 +211,16 @@ private void loadNextFrame() {
 
   private void recycleFirstFrame() {
     if (firstFrame != null) {
-      Glide.get(context).getBitmapPool().put(firstFrame);
+      bitmapPool.put(firstFrame);
       firstFrame = null;
     }
   }
 
+  void setNextStartFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "Can't restart a running animation");
+    startFromFirstFrame = true;
+  }
+
   // Visible for testing.
   void onFrameReady(DelayTarget delayTarget) {
     if (isCleared) {
@@ -229,6 +251,9 @@ void onFrameReady(DelayTarget delayTarget) {
     public static final int MSG_DELAY = 1;
     public static final int MSG_CLEAR = 2;
 
+    @Synthetic
+    FrameLoaderCallback() { }
+
     @Override
     public boolean handleMessage(Message msg) {
       if (msg.what == MSG_DELAY) {
@@ -246,7 +271,7 @@ public boolean handleMessage(Message msg) {
   // Visible for testing.
   static class DelayTarget extends SimpleTarget<Bitmap> {
     private final Handler handler;
-    private final int index;
+    @Synthetic final int index;
     private final long targetTime;
     private Bitmap resource;
 
@@ -268,9 +293,14 @@ public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transiti
     }
   }
 
-  private static RequestBuilder<Bitmap> getRequestBuilder(Context context, int width, int height) {
-    return Glide.with(context).asBitmap().apply(
-        diskCacheStrategyOf(DiskCacheStrategy.NONE).skipMemoryCache(true).override(width, height));
+  private static RequestBuilder<Bitmap> getRequestBuilder(
+      RequestManager requestManager, int width, int height) {
+    return requestManager
+        .asBitmap()
+        .apply(
+            diskCacheStrategyOf(DiskCacheStrategy.NONE)
+                .skipMemoryCache(true)
+                .override(width, height));
   }
 
   // Visible for testing.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index a644056aa..4e887ed11 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -26,8 +25,7 @@ public boolean handles(GifDecoder source, Options options) {
   }
 
   @Override
-  public Resource<Bitmap> decode(GifDecoder source, int width, int height,
-      Options options) {
+  public Resource<Bitmap> decode(GifDecoder source, int width, int height, Options options) {
     Bitmap bitmap = source.getNextFrame();
     return BitmapResource.obtain(bitmap, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index 91038724c..baf4abc43 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -1,19 +1,19 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.util.Log;
-
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.List;
 
 /**
  * A relatively inefficient decoder for {@link com.bumptech.glide.load.resource.gif.GifDrawable}
@@ -30,11 +30,13 @@
   public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
       "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
 
+  private final List<ImageHeaderParser> parsers;
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private final ArrayPool byteArrayPool;
 
-  public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder,
-      ArrayPool byteArrayPool) {
+  public StreamGifDecoder(List<ImageHeaderParser> parsers, ResourceDecoder<ByteBuffer,
+      GifDrawable> byteBufferDecoder, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.byteBufferDecoder = byteBufferDecoder;
     this.byteArrayPool = byteArrayPool;
   }
@@ -42,7 +44,7 @@ public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecod
   @Override
   public boolean handles(InputStream source, Options options) throws IOException {
     return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+        && ImageHeaderParserUtils.getType(parsers, source, byteArrayPool) == ImageType.GIF;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index af4a0281b..5e8419a7c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -1,10 +1,8 @@
 package com.bumptech.glide.load.resource.transcode;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
-
 import java.io.ByteArrayOutputStream;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
index b3993cbb2..9fbbd4c05 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -4,7 +4,6 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
index 98e3f9790..94ff7864d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
@@ -4,7 +4,6 @@
 import com.bumptech.glide.load.resource.bytes.BytesResource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.ByteBufferUtil;
-
 import java.nio.ByteBuffer;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
index c0a0bdb42..b632c35ad 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -75,7 +76,7 @@
   private static final class Entry<Z, R> {
     private final Class<Z> fromClass;
     private final Class<R> toClass;
-    private final ResourceTranscoder<Z, R> transcoder;
+    @Synthetic final ResourceTranscoder<Z, R> transcoder;
 
     Entry(Class<Z> fromClass, Class<R> toClass, ResourceTranscoder<Z, R> transcoder) {
       this.fromClass = fromClass;
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index 177165f4e..fd88428e8 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.manager;
 
 import com.bumptech.glide.util.Util;
-
 import java.util.Collections;
 import java.util.Set;
 import java.util.WeakHashMap;
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index d191bda2a..d2967bffa 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -6,15 +6,16 @@
 import android.content.IntentFilter;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * Uses {@link android.net.ConnectivityManager} to identify connectivity changes.
  */
 class DefaultConnectivityMonitor implements ConnectivityMonitor {
   private final Context context;
-  private final ConnectivityListener listener;
+  @Synthetic final ConnectivityListener listener;
 
-  private boolean isConnected;
+  @Synthetic boolean isConnected;
   private boolean isRegistered;
 
   private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() {
@@ -53,7 +54,8 @@ private void unregister() {
     isRegistered = false;
   }
 
-  private boolean isConnected(Context context) {
+  @Synthetic
+  boolean isConnected(Context context) {
     ConnectivityManager connectivityManager =
         (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
     NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
diff --git a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
index 41505a86e..5d811cc49 100644
--- a/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.manager;
 
 import com.bumptech.glide.RequestManager;
-
 import java.util.Collections;
 import java.util.Set;
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 86cb7bd8a..af6d7f599 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -7,9 +7,9 @@
 import android.os.Build;
 import android.support.annotation.Nullable;
 import android.util.Log;
-
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -23,7 +23,6 @@
  * @see com.bumptech.glide.manager.RequestManagerRetriever
  * @see com.bumptech.glide.RequestManager
  */
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class RequestManagerFragment extends Fragment {
   private static final String TAG = "RMFragment";
   private final ActivityFragmentLifecycle lifecycle;
@@ -146,7 +145,7 @@ private boolean isDescendant(Fragment fragment) {
 
   private void registerFragmentWithRoot(Activity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = RequestManagerRetriever.get()
+    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getRequestManagerFragment(activity.getFragmentManager(), null);
     if (rootRequestManagerFragment != this) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
@@ -200,6 +199,7 @@ public void onDestroy() {
 
   @Override
   public void onTrimMemory(int level) {
+    super.onTrimMemory(level);
     // If an activity is re-created, onTrimMemory may be called before a manager is ever put.
     // See #329.
     if (requestManager != null) {
@@ -209,6 +209,7 @@ public void onTrimMemory(int level) {
 
   @Override
   public void onLowMemory() {
+    super.onLowMemory();
     // If an activity is re-created, onLowMemory may be called before a manager is ever put.
     // See #329.
     if (requestManager != null) {
@@ -222,6 +223,10 @@ public String toString() {
   }
 
   private class FragmentRequestManagerTreeNode implements RequestManagerTreeNode {
+
+    @Synthetic
+    FragmentRequestManagerTreeNode() { }
+
     @Override
     public Set<RequestManager> getDescendants() {
       Set<RequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index 1ca543956..b07a23677 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -6,17 +6,24 @@
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.os.Build;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
+import android.support.v4.util.ArrayMap;
 import android.util.Log;
-
+import android.view.View;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
-
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -29,14 +36,14 @@
   static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
   private static final String TAG = "RMRetriever";
 
-  /**
-   * The singleton instance of RequestManagerRetriever.
-   */
-  private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();
-
   private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
   private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
 
+  // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
+  // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
+  private static final String FRAGMENT_INDEX_KEY = "key";
+  private static final String FRAGMENT_MANAGER_GET_FRAGMENT_KEY = "i";
+
   /**
    * The top application level RequestManager.
    */
@@ -60,16 +67,16 @@
    * Main thread handler to handle cleaning up pending fragment maps.
    */
   private final Handler handler;
+  private final RequestManagerFactory factory;
 
-  /**
-   * Retrieves and returns the RequestManagerRetriever singleton.
-   */
-  public static RequestManagerRetriever get() {
-    return INSTANCE;
-  }
+  // Objects used to find Fragments and Activities containing views.
+  private final ArrayMap<View, Fragment> tempViewToSupportFragment = new ArrayMap<>();
+  private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
+  private final Bundle tempBundle = new Bundle();
 
   // Visible for testing.
-  RequestManagerRetriever() {
+  public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
+    this.factory = factory != null ? factory : DEFAULT_FACTORY;
     handler = new Handler(Looper.getMainLooper(), this /* Callback */);
   }
 
@@ -82,9 +89,11 @@ private RequestManager getApplicationManager(Context context) {
           // activity. However, in this case since the manager attached to the application will not
           // receive lifecycle events, we must force the manager to start resumed using
           // ApplicationLifecycle.
+
+          // TODO(b/27524013): Factor out this Glide.get() call.
+          Glide glide = Glide.get(context);
           applicationManager =
-              new RequestManager(context.getApplicationContext(), new ApplicationLifecycle(),
-                  new EmptyRequestManagerTreeNode());
+              factory.build(glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
         }
       }
     }
@@ -114,15 +123,13 @@ public RequestManager get(FragmentActivity activity) {
     } else {
       assertNotDestroyed(activity);
       FragmentManager fm = activity.getSupportFragmentManager();
-      return supportFragmentGet(activity, fm, null);
+      return supportFragmentGet(activity, fm, null /*parentHint*/);
     }
   }
 
   public RequestManager get(Fragment fragment) {
-    if (fragment.getActivity() == null) {
-      throw new IllegalArgumentException(
-          "You cannot start a load on a fragment before it is attached");
-    }
+    Preconditions.checkNotNull(fragment.getActivity(),
+          "You cannot start a load on a fragment before it is attached or after it is destroyed");
     if (Util.isOnBackgroundThread()) {
       return get(fragment.getActivity().getApplicationContext());
     } else {
@@ -131,14 +138,142 @@ public RequestManager get(Fragment fragment) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   public RequestManager get(Activity activity) {
-    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+    if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
       assertNotDestroyed(activity);
       android.app.FragmentManager fm = activity.getFragmentManager();
-      return fragmentGet(activity, fm, null);
+      return fragmentGet(activity, fm, null /*parentHint*/);
+    }
+  }
+
+  public RequestManager get(View view) {
+    if (Util.isOnBackgroundThread()) {
+      return get(view.getContext().getApplicationContext());
+    }
+
+    Preconditions.checkNotNull(view);
+    Preconditions.checkNotNull(view.getContext(),
+        "Unable to obtain a request manager for a view without a Context");
+    Activity activity = findActivity(view.getContext());
+    // The view might be somewhere else, like a service.
+    if (activity == null) {
+      return get(view.getContext().getApplicationContext());
+    }
+
+    // Support Fragments.
+    if (activity instanceof FragmentActivity) {
+      Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
+      if (fragment == null) {
+        return get(activity);
+      }
+      return get(fragment);
+    }
+
+    // Standard Fragments.
+    android.app.Fragment fragment = findFragment(view, activity);
+    if (fragment == null) {
+      return get(activity);
+    }
+    return get(fragment);
+  }
+
+  private static void findAllSupportFragmentsWithViews(
+      @Nullable Collection<Fragment> topLevelFragments,
+      Map<View, Fragment> result) {
+    if (topLevelFragments == null) {
+      return;
+    }
+    for (Fragment fragment : topLevelFragments) {
+      if (fragment.getView() == null) {
+        continue;
+      }
+      result.put(fragment.getView(), fragment);
+      findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);
+    }
+  }
+
+  @Nullable
+  private Fragment findSupportFragment(View target, FragmentActivity activity) {
+    tempViewToSupportFragment.clear();
+    findAllSupportFragmentsWithViews(
+        activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
+    Fragment result = null;
+    View activityRoot = activity.findViewById(android.R.id.content);
+    View current = target;
+    while (!current.equals(activityRoot)) {
+      result = tempViewToSupportFragment.get(current);
+      if (result != null) {
+        break;
+      }
+      if (current.getParent() instanceof View) {
+        current = (View) current.getParent();
+      } else {
+        break;
+      }
+    }
+
+    tempViewToSupportFragment.clear();
+    return result;
+  }
+
+  @Nullable
+  private android.app.Fragment findFragment(View target, Activity activity) {
+    tempViewToFragment.clear();
+    findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
+
+    android.app.Fragment result = null;
+
+    View activityRoot = activity.findViewById(android.R.id.content);
+    View current = target;
+     while (!current.equals(activityRoot)) {
+      result = tempViewToFragment.get(current);
+      if (result != null) {
+        break;
+      }
+      if (current.getParent() instanceof View) {
+        current = (View) current.getParent();
+      } else {
+        break;
+      }
+    }
+    tempViewToFragment.clear();
+    return result;
+  }
+
+  // TODO: Consider using an accessor class in the support library package to more directly retrieve
+  // non-support Fragments.
+  private void findAllFragmentsWithViews(
+      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+    int index = 0;
+    while (true) {
+      tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
+      android.app.Fragment fragment = null;
+      try {
+        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_MANAGER_GET_FRAGMENT_KEY);
+      } catch (Exception e) {
+        // This generates log spam from FragmentManager anyway.
+      }
+      if (fragment == null) {
+        break;
+      }
+      if (fragment.getView() != null) {
+        result.put(fragment.getView(), fragment);
+        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) {
+          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+        }
+      }
+    }
+  }
+
+  private Activity findActivity(Context context) {
+    if (context instanceof Activity) {
+      return (Activity) context;
+    } else if (context instanceof ContextWrapper) {
+      return findActivity(((ContextWrapper) context).getBaseContext());
+    } else {
+      return null;
     }
   }
 
@@ -180,14 +315,15 @@ RequestManagerFragment getRequestManagerFragment(
     return current;
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
+  private RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
       android.app.Fragment parentHint) {
     RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -210,12 +346,15 @@ SupportRequestManagerFragment getSupportRequestManagerFragment(
     return current;
   }
 
-  RequestManager supportFragmentGet(Context context, FragmentManager fm, Fragment parentHint) {
+  private RequestManager supportFragmentGet(Context context, FragmentManager fm,
+      Fragment parentHint) {
     SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -246,4 +385,20 @@ public boolean handleMessage(Message message) {
     }
     return handled;
   }
+
+  /**
+   * Used internally to create {@link RequestManager}s.
+   */
+  public interface RequestManagerFactory {
+    RequestManager build(
+        Glide glide, Lifecycle lifecycle, RequestManagerTreeNode requestManagerTreeNode);
+  }
+
+  private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
+    @Override
+    public RequestManager build(Glide glide, Lifecycle lifecycle,
+        RequestManagerTreeNode requestManagerTreeNode) {
+      return new RequestManager(glide, lifecycle, requestManagerTreeNode);
+    }
+  };
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
index 87f982947..38d341b3a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.manager;
 
 import com.bumptech.glide.RequestManager;
-
 import java.util.Set;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 48d5882a7..78a66c6a3 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -2,7 +2,6 @@
 
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Util;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index df141b567..a61b3af9b 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -1,14 +1,14 @@
 package com.bumptech.glide.manager;
 
 import android.annotation.SuppressLint;
-import android.app.Activity;
+import android.content.Context;
 import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
-
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -135,7 +135,7 @@ private boolean isDescendant(Fragment fragment) {
 
   private void registerFragmentWithRoot(FragmentActivity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = RequestManagerRetriever.get()
+    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getSupportRequestManagerFragment(activity.getSupportFragmentManager(), null);
     if (rootRequestManagerFragment != this) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
@@ -150,8 +150,8 @@ private void unregisterFragmentWithRoot() {
   }
 
   @Override
-  public void onAttach(Activity activity) {
-    super.onAttach(activity);
+  public void onAttach(Context context) {
+    super.onAttach(context);
     try {
       registerFragmentWithRoot(getActivity());
     } catch (IllegalStateException e) {
@@ -204,6 +204,10 @@ public String toString() {
   }
 
   private class SupportFragmentRequestManagerTreeNode implements RequestManagerTreeNode {
+
+    @Synthetic
+    SupportFragmentRequestManagerTreeNode() { }
+
     @Override
     public Set<RequestManager> getDescendants() {
       Set<SupportRequestManagerFragment> descendantFragments =
diff --git a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
index 6c83dd896..64dd276db 100644
--- a/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java
@@ -2,7 +2,6 @@
 
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Util;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
diff --git a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
new file mode 100644
index 000000000..9d40b969c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
@@ -0,0 +1,40 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.GlideBuilder;
+
+/**
+ * Defines a set of dependencies and options to use when initializing Glide within an application.
+ *
+ * <p>There can be at most one {@link AppGlideModule} in an application. Only Applications
+ * can include a {@link AppGlideModule}. Libraries must use {@link LibraryGlideModule}.
+ *
+ * <p>Classes that extend {@link AppGlideModule} must be annotated with
+ * {@link com.bumptech.glide.annotation.GlideModule} to be processed correctly.
+ *
+ * <p>Classes that extend {@link AppGlideModule} can optionally be annotated with
+ * {@link com.bumptech.glide.annotation.Excludes} to optionally exclude one or more
+ * {@link LibraryGlideModule} and/or {@link GlideModule} classes.
+ *
+ * <p>Once an application has migrated itself and all libraries it depends on to use Glide's
+ * annotation processor, {@link AppGlideModule} implementations should override
+ * {@link #isManifestParsingEnabled()} and return {@code false}.
+ */
+public abstract class AppGlideModule extends LibraryGlideModule implements AppliesOptions {
+  /**
+   * Returns {@code true} if Glide should check the AndroidManifest for {@link GlideModule}s.
+   *
+   * <p>Implementations should return {@code false} after they and their dependencies have migrated
+   * to Glide's annotation processor.
+   *
+   * <p>Returns {@code true} by default.
+   */
+  public boolean isManifestParsingEnabled() {
+    return true;
+  }
+
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Default empty impl.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
new file mode 100644
index 000000000..923d364f7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.GlideBuilder;
+
+/**
+ * An internal interface, to be removed when {@link GlideModule}s are removed.
+ */
+interface AppliesOptions {
+  /**
+   * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
+   * singleton is created.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context An Application {@link android.content.Context}.
+   * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
+   */
+  void applyOptions(Context context, GlideBuilder builder);
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/GlideModule.java b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
index 132e669f8..b8e2108e6 100644
--- a/library/src/main/java/com/bumptech/glide/module/GlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
@@ -1,8 +1,5 @@
 package com.bumptech.glide.module;
 
-import android.content.Context;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 
 /**
@@ -53,28 +50,9 @@
  * applying conflicting settings in different modules. If an application depends on libraries that
  * have conflicting modules, the application should consider avoiding the library modules and
  * instead providing their required dependencies in a single application module. </p>
+ *
+ * @deprecated Libraries should use {@link LibraryGlideModule} and Applications should use
+ * {@link AppGlideModule}.
  */
-public interface GlideModule {
-
-  /**
-   * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
-   * singleton is created.
-   *
-   * <p> This method will be called once and only once per implementation. </p>
-   *
-   * @param context An Application {@link android.content.Context}.
-   * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
-   */
-  void applyOptions(Context context, GlideBuilder builder);
-
-  /**
-   * Lazily register components immediately after the Glide singleton is created but before any
-   * requests can be started.
-   *
-   * <p> This method will be called once and only once per implementation. </p>
-   *
-   * @param context  An Application {@link android.content.Context}.
-   * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
-   */
-  void registerComponents(Context context, Registry registry);
-}
+@Deprecated
+public interface GlideModule extends RegistersComponents, AppliesOptions { }
diff --git a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
new file mode 100644
index 000000000..f543d3729
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+
+/**
+ * Registers a set of components to use when initializing Glide within an app when
+ * Glide's annotation processor is used.
+ *
+ * <p>Any number of LibraryGlideModules can be contained within any library or application.
+ *
+ * <p>LibraryGlideModules are called in no defined order. If LibraryGlideModules within an
+ * application conflict, {@link AppGlideModule}s can use the
+ * {@link com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of
+ * the conflicting modules.
+ */
+public abstract class LibraryGlideModule implements RegistersComponents {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    // Default empty impl.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index 7d9a755e5..9b0eb69a8 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -3,7 +3,7 @@
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
-
+import android.util.Log;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -11,6 +11,7 @@
  * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
  */
 public final class ManifestParser {
+  private static final String TAG = "ManifestParser";
   private static final String GLIDE_MODULE_VALUE = "GlideModule";
 
   private final Context context;
@@ -19,25 +20,43 @@ public ManifestParser(Context context) {
     this.context = context;
   }
 
+  @SuppressWarnings("deprecation")
   public List<GlideModule> parse() {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Loading Glide modules");
+    }
     List<GlideModule> modules = new ArrayList<>();
     try {
       ApplicationInfo appInfo = context.getPackageManager()
           .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
-      if (appInfo.metaData != null) {
-        for (String key : appInfo.metaData.keySet()) {
-          if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
-            modules.add(parseModule(key));
+      if (appInfo.metaData == null) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Got null app info metadata");
+        }
+        return modules;
+      }
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Got app info metadata: " + appInfo.metaData);
+      }
+      for (String key : appInfo.metaData.keySet()) {
+        if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
+          modules.add(parseModule(key));
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Loaded Glide module: " + key);
           }
         }
       }
     } catch (PackageManager.NameNotFoundException e) {
       throw new RuntimeException("Unable to find metadata to parse GlideModules", e);
     }
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Finished loading Glide modules");
+    }
 
     return modules;
   }
 
+  @SuppressWarnings("deprecation")
   private static GlideModule parseModule(String className) {
     Class<?> clazz;
     try {
@@ -49,9 +68,13 @@ private static GlideModule parseModule(String className) {
     Object module;
     try {
       module = clazz.newInstance();
-    } catch (InstantiationException | IllegalAccessException e) {
+    } catch (InstantiationException e) {
+      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
+              e);
+      // These can't be combined until API minimum is 19.
+    } catch (IllegalAccessException e) {
       throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-          e);
+              e);
     }
 
     if (!(module instanceof GlideModule)) {
diff --git a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
new file mode 100644
index 000000000..1c6d8c9b8
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+
+/**
+ * An internal interface, to be removed when {@link GlideModule}s are removed.
+ */
+interface RegistersComponents {
+
+  /**
+   * Lazily register components immediately after the Glide singleton is created but before any
+   * requests can be started.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context  An Application {@link android.content.Context}.
+   * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
+   */
+  void registerComponents(Context context, Registry registry);
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
index 915bd0024..29bd3af62 100644
--- a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.provider;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.Encoder;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -31,7 +30,7 @@
 
   private static final class Entry<T> {
     private final Class<T> dataClass;
-    private final Encoder<T> encoder;
+    @Synthetic final Encoder<T> encoder;
 
     public Entry(Class<T> dataClass, Encoder<T> encoder) {
       this.dataClass = dataClass;
diff --git a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
new file mode 100644
index 000000000..af329320e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.provider;
+
+import com.bumptech.glide.load.ImageHeaderParser;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains an unordered list of {@link ImageHeaderParser}s capable of parsing image headers.
+ */
+public final class ImageHeaderParserRegistry {
+  private final List<ImageHeaderParser> parsers = new ArrayList<>();
+
+  public synchronized List<ImageHeaderParser> getParsers() {
+    return parsers;
+  }
+
+  public synchronized void add(ImageHeaderParser parser) {
+    parsers.add(parser);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
index f9c68b34a..6cc5d9630 100644
--- a/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java
@@ -2,10 +2,8 @@
 
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
-
 import com.bumptech.glide.load.engine.LoadPath;
 import com.bumptech.glide.util.MultiClassKey;
-
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
index 01e771d7d..076661dfa 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java
@@ -2,9 +2,7 @@
 
 import android.support.annotation.Nullable;
 import android.support.v4.util.ArrayMap;
-
 import com.bumptech.glide.util.MultiClassKey;
-
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
 
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
index b56158351..877114e90 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
@@ -1,13 +1,13 @@
 package com.bumptech.glide.provider;
 
 import com.bumptech.glide.load.ResourceDecoder;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Contains an ordered list of {@link ResourceDecoder}s capable of decoding arbitrary data types
- * into arbitrary resource types from highest priority decoders to loweset priority decoders.
+ * into arbitrary resource types from highest priority decoders to lowest priority decoders.
  */
 @SuppressWarnings("rawtypes")
 public class ResourceDecoderRegistry {
@@ -51,8 +51,8 @@
 
   private static class Entry<T, R> {
     private final Class<T> dataClass;
-    private final Class<R> resourceClass;
-    private final ResourceDecoder<T, R> decoder;
+    @Synthetic final Class<R> resourceClass;
+    @Synthetic final ResourceDecoder<T, R> decoder;
 
     public Entry(Class<T> dataClass, Class<R> resourceClass, ResourceDecoder<T, R> decoder) {
       this.dataClass = dataClass;
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
index e5f5ef9c7..e096cc759 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.provider;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.ResourceEncoder;
-
+import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -35,14 +34,15 @@
 
   private static final class Entry<T> {
     private final Class<T> resourceClass;
-    private final ResourceEncoder<T> encoder;
+    @Synthetic final ResourceEncoder<T> encoder;
 
     Entry(Class<T> resourceClass, ResourceEncoder<T> encoder) {
       this.resourceClass = resourceClass;
       this.encoder = encoder;
     }
 
-    private boolean handles(Class<?> resourceClass) {
+    @Synthetic
+    boolean handles(Class<?> resourceClass) {
       return this.resourceClass.isAssignableFrom(resourceClass);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
deleted file mode 100644
index f9df455c9..000000000
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ /dev/null
@@ -1,945 +0,0 @@
-package com.bumptech.glide.request;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
-import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.CenterInside;
-import com.bumptech.glide.load.resource.bitmap.CircleCrop;
-import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
-import com.bumptech.glide.load.resource.bitmap.Downsampler;
-import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
-import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
-import com.bumptech.glide.signature.EmptySignature;
-import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Contains and exposes a variety of non type specific options that can be applied to a load in
- * Glide.
- *
- * <p> If {@link #lock()} has been called, this class will throw if any further mutations are
- * attempted. To unlock, use {@link #clone()}. </p>
- *
- * @param <CHILD> The concrete and <em>final</em> subclass.
- */
-public abstract class BaseRequestOptions<CHILD extends BaseRequestOptions<CHILD>>
-    implements Cloneable {
-  private static final int UNSET = -1;
-  private static final int SIZE_MULTIPLIER = 1 << 1;
-  private static final int DISK_CACHE_STRATEGY = 1 << 2;
-  private static final int PRIORITY = 1 << 3;
-  private static final int ERROR_PLACEHOLDER = 1 << 4;
-  private static final int ERROR_ID = 1 << 5;
-  private static final int PLACEHOLDER = 1 << 6;
-  private static final int PLACEHOLDER_ID = 1 << 7;
-  private static final int IS_CACHEABLE = 1 << 8;
-  private static final int OVERRIDE = 1 << 9;
-  private static final int SIGNATURE = 1 << 10;
-  private static final int TRANSFORMATION = 1 << 11;
-  private static final int RESOURCE_CLASS = 1 << 12;
-  private static final int FALLBACK = 1 << 13;
-  private static final int FALLBACK_ID = 1 << 14;
-  private static final int THEME = 1 << 15;
-  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
-  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
-
-  private int fields;
-
-  private float sizeMultiplier = 1f;
-  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
-  private Priority priority = Priority.NORMAL;
-  private Drawable errorPlaceholder;
-  private int errorId;
-  private Drawable placeholderDrawable;
-  private int placeholderId;
-  private boolean isCacheable = true;
-  private int overrideHeight = UNSET;
-  private int overrideWidth = UNSET;
-  private Key signature = EmptySignature.obtain();
-  private boolean isTransformationRequired;
-  private boolean isTransformationAllowed = true;
-  private Drawable fallbackDrawable;
-  private int fallbackId;
-
-  private Options options = new Options();
-  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-  private Class<?> resourceClass = Object.class;
-  private boolean isLocked;
-  private Resources.Theme theme;
-  private boolean isAutoCloneEnabled;
-
-  /**
-   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
-   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
-   * (particularly {@link android.graphics.Bitmap}s on devices with overly dense screens.
-   *
-   * @param sizeMultiplier The multiplier to apply to the
-   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
-   *                       loading the resource.
-   * @return This request builder.
-   */
-  public final CHILD sizeMultiplier(float sizeMultiplier) {
-    if (isAutoCloneEnabled) {
-      return clone().sizeMultiplier(sizeMultiplier);
-    }
-
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-    }
-    this.sizeMultiplier = sizeMultiplier;
-    fields |= SIZE_MULTIPLIER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load.
-   *
-   * <p> Defaults to {@link com.bumptech.glide.load.engine.DiskCacheStrategy#AUTOMATIC}. </p>
-   *
-   * <p> For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} is
-   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
-   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#DATA} or
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}. </p>
-   *
-   * @param strategy The strategy to use.
-   * @return This request builder.
-   */
-  public final CHILD diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
-    if (isAutoCloneEnabled) {
-      return clone().diskCacheStrategy(strategy);
-    }
-    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
-    fields |= DISK_CACHE_STRATEGY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the priority for this load.
-   *
-   * @param priority A priority.
-   * @return This request builder.
-   */
-  public final CHILD priority(@NonNull Priority priority) {
-    if (isAutoCloneEnabled) {
-      return clone().priority(priority);
-    }
-
-    this.priority = Preconditions.checkNotNull(priority);
-    fields |= PRIORITY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD placeholder(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(drawable);
-    }
-
-    this.placeholderDrawable = drawable;
-    fields |= PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resource to
-   * display while a resource is loading.
-   *
-   * @param resourceId The id of the resource to use as a placeholder
-   * @return This request builder.
-   */
-  public final CHILD placeholder(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(resourceId);
-    }
-
-    this.placeholderId = resourceId;
-    fields |= PLACEHOLDER_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
-   * error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD fallback(Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(drawable);
-    }
-
-    this.fallbackDrawable = drawable;
-    fields |= FALLBACK;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
-   * the error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param resourceId The id of the resource to use as a fallback.
-   * @return This request builder.
-   */
-  public final CHILD fallback(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(resourceId);
-    }
-
-    this.fallbackId = resourceId;
-    fields |= FALLBACK_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a {@link Drawable} to display if a load fails.
-   *
-   * @param drawable The drawable to display.
-   * @return This request builder.
-   */
-  public final CHILD error(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().error(drawable);
-    }
-
-    this.errorPlaceholder = drawable;
-    fields |= ERROR_PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if a load fails.
-   *
-   * @param resourceId The id of the resource to use as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD error(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().error(resourceId);
-    }
-    this.errorId = resourceId;
-    fields |= ERROR_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
-   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
-   * {@link #fallback(Drawable)}.
-   *
-   * @param theme The theme to use when loading Drawables.
-   * @return this request builder.
-   */
-  public final CHILD theme(Resources.Theme theme) {
-    if (isAutoCloneEnabled) {
-      return clone().theme(theme);
-    }
-
-    this.theme = theme;
-    fields |= THEME;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Allows the loaded resource to skip the memory cache.
-   *
-   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
-   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
-   *
-   * @param skip True to allow the resource to skip the memory cache.
-   * @return This request builder.
-   */
-  public final CHILD skipMemoryCache(boolean skip) {
-    if (isAutoCloneEnabled) {
-      return clone().skipMemoryCache(true);
-    }
-
-    this.isCacheable = !skip;
-    fields |= IS_CACHEABLE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given values. This is useful for thumbnails, and should only be used for other cases when you
-   * need a very specific image size.
-   *
-   * @param width  The width in pixels to use to load the resource.
-   * @param height The height in pixels to use to load the resource.
-   * @return This request builder.
-   */
-  public final CHILD override(int width, int height) {
-    if (isAutoCloneEnabled) {
-      return clone().override(width, height);
-    }
-
-    this.overrideWidth = width;
-    this.overrideHeight = height;
-    fields |= OVERRIDE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given size.
-   *
-   * @see #override(int, int)
-   * @param size The width and height to use.
-   * @return This request builder.
-   */
-  public final CHILD override(int size) {
-    return override(size, size);
-  }
-
-  /**
-   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
-   * more control over when cached data is invalidated.
-   *
-   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
-   *
-   * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current
-   *                  state of the model that will be mixed in to the cache key.
-   * @return This request builder.
-   * @see com.bumptech.glide.signature.StringSignature
-   */
-  public final CHILD signature(@NonNull Key signature) {
-    if (isAutoCloneEnabled) {
-      return clone().signature(signature);
-    }
-
-    this.signature = Preconditions.checkNotNull(signature);
-    fields |= SIGNATURE;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   *
-   * <p> Even if this object was locked, the cloned object returned from this method will not be
-   * locked. </p>
-   */
-  @SuppressWarnings("unchecked")
-  @Override
-  public final CHILD clone() {
-    try {
-      BaseRequestOptions<CHILD> result = (BaseRequestOptions<CHILD>) super.clone();
-      result.options = new Options();
-      result.options.putAll(options);
-      result.transformations = new HashMap<>();
-      result.transformations.putAll(transformations);
-      result.isLocked = false;
-      result.isAutoCloneEnabled = false;
-      return (CHILD) result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public final <T> CHILD set(@NonNull Option<T> option, @NonNull T value) {
-    if (isAutoCloneEnabled) {
-      return clone().set(option, value);
-    }
-
-    Preconditions.checkNotNull(option);
-    Preconditions.checkNotNull(value);
-    options.set(option, value);
-    return selfOrThrowIfLocked();
-  }
-
-  public final CHILD decode(@NonNull Class<?> resourceClass) {
-    if (isAutoCloneEnabled) {
-      return clone().decode(resourceClass);
-    }
-
-    this.resourceClass = Preconditions.checkNotNull(resourceClass);
-    fields |= RESOURCE_CLASS;
-    return selfOrThrowIfLocked();
-  }
-
-  public final boolean isTransformationAllowed() {
-    return isTransformationAllowed;
-  }
-
-  public final boolean isTransformationSet() {
-    return isSet(TRANSFORMATION);
-  }
-
-  public final boolean isLocked() {
-    return isLocked;
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
-   */
-  public CHILD encodeFormat(@NonNull Bitmap.CompressFormat format) {
-    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_QUALITY}.
-   */
-  public CHILD encodeQuality(int quality) {
-    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
-  }
-
-  /**
-   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
-   * {@link Downsampler}.
-   *
-   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
-   * decoded using a decoder that cannot control the format
-   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
-   * ignore the requested format if it can't display the image (ie RGB_565 is requested, but the
-   * image has alpha).
-   */
-  public CHILD format(@NonNull DecodeFormat format) {
-    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the time position of the frame to extract from a video.
-   *
-   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
-   *                        Android framework implementation return a representative frame.
-   */
-  public CHILD frame(long frameTimeMicros) {
-    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
-  }
-
-  /**
-   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
-   * {@link Downsampler}.
-   */
-  public CHILD downsample(@NonNull DownsampleStrategy strategy) {
-    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerCrop(android.content.Context)
-   */
-  public CHILD optionalCenterCrop(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalCenterCrop(android.content.Context)
-   */
-  public CHILD centerCrop(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #fitCenter(android.content.Context)
-   */
-  public CHILD optionalFitCenter(Context context) {
-    return optionalTransform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalFitCenter(android.content.Context)
-   */
-  public CHILD fitCenter(Context context) {
-    return transform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerInside(Context) (android.content.Context)
-   */
-  public CHILD optionalCenterInside(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalCenterInside(Context) (android.content.Context)
-   */
-  public CHILD centerInside(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link Context}.
-   * @see #optionalTransform(Context, Transformation)
-   * @see #circleCrop(Context)
-   */
-  public CHILD optionalCircleCrop(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
-   * an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link Context}.
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterCrop(Context)
-   */
-  public CHILD circleCrop(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));
-  }
-
-  final CHILD optionalTransform(Context context, DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(context, downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return optionalTransform(context, transformation);
-  }
-
-  final CHILD transform(Context context, DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(context, downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return transform(context, transformation);
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context        Any {@link android.content.Context}.
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #optionalTransform(android.content.Context, com.bumptech.glide.load.Transformation)
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public CHILD transform(Context context, @NonNull Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(context, transformation);
-    }
-
-    optionalTransform(context, transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context        Any {@link android.content.Context}.
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #transform(android.content.Context, com.bumptech.glide.load.Transformation)
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public CHILD optionalTransform(Context context, Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(context, transformation);
-    }
-
-    optionalTransform(Bitmap.class, transformation);
-    // TODO: remove BitmapDrawable decoder and this transformation.
-    optionalTransform(BitmapDrawable.class,
-        new BitmapDrawableTransformation(context, transformation));
-    optionalTransform(GifDrawable.class, new GifDrawableTransformation(context, transformation));
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and allows unknown resource types to be ignored.
-   *
-   * <p> Users can apply different transformations for each resource class. Applying a
-   * {@link com.bumptech.glide.load.Transformation} for a resource type that already has a
-   * {@link com.bumptech.glide.load.Transformation} will override the previous call. </p>
-   *
-   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
-   * an unknown resource class will throw an exception. To allow unknown types, users must always
-   * call the optional version of each method. </p>
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   */
-  public final <T> CHILD optionalTransform(Class<T> resourceClass,
-      Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(resourceClass, transformation);
-    }
-
-    Preconditions.checkNotNull(resourceClass);
-    Preconditions.checkNotNull(transformation);
-    transformations.put(resourceClass, transformation);
-    fields |= TRANSFORMATION;
-    isTransformationAllowed = true;
-    fields |= TRANSFORMATION_ALLOWED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and throws if asked to transform an unknown resource type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public final <T> CHILD transform(Class<T> resourceClass, Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(resourceClass, transformation);
-    }
-
-    optionalTransform(resourceClass, transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Removes all applied {@link com.bumptech.glide.load.Transformation Transformations} for all
-   * resource classes and allows unknown resource types to be transformed without throwing an
-   * exception.
-   */
-  public final CHILD dontTransform() {
-    if (isAutoCloneEnabled) {
-      return clone().dontTransform();
-    }
-
-    transformations.clear();
-    fields &= ~TRANSFORMATION;
-    isTransformationRequired = false;
-    fields &= ~TRANSFORMATION_REQUIRED;
-    isTransformationAllowed = false;
-    fields |= TRANSFORMATION_ALLOWED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Disables resource decoders that return animated resources so any resource returned will be
-   * static.
-   *
-   * <p> To disable transitions (fades etc) use
-   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
-   */
-  public final CHILD dontAnimate() {
-    if (isAutoCloneEnabled) {
-      return clone().dontAnimate();
-    }
-
-    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
-    set(StreamGifDecoder.DISABLE_ANIMATION, true);
-    return selfOrThrowIfLocked();
-  }
-
-  public final CHILD apply(BaseRequestOptions<?> other) {
-    if (isAutoCloneEnabled) {
-      return clone().apply(other);
-    }
-
-    if (isSet(other.fields, SIZE_MULTIPLIER)) {
-      sizeMultiplier = other.sizeMultiplier;
-    }
-    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
-      diskCacheStrategy = other.diskCacheStrategy;
-    }
-    if (isSet(other.fields, PRIORITY)) {
-      priority = other.priority;
-    }
-    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
-      errorPlaceholder = other.errorPlaceholder;
-    }
-    if (isSet(other.fields, ERROR_ID)) {
-      errorId = other.errorId;
-    }
-    if (isSet(other.fields, PLACEHOLDER)) {
-      placeholderDrawable = other.placeholderDrawable;
-    }
-    if (isSet(other.fields, PLACEHOLDER_ID)) {
-      placeholderId = other.placeholderId;
-    }
-    if (isSet(other.fields, IS_CACHEABLE)) {
-      isCacheable = other.isCacheable;
-    }
-    if (isSet(other.fields, OVERRIDE)) {
-      overrideWidth = other.overrideWidth;
-      overrideHeight = other.overrideHeight;
-    }
-    if (isSet(other.fields, SIGNATURE)) {
-      signature = other.signature;
-    }
-    if (isSet(other.fields, RESOURCE_CLASS)) {
-      resourceClass = other.resourceClass;
-    }
-    if (isSet(other.fields, FALLBACK)) {
-      fallbackDrawable = other.fallbackDrawable;
-    }
-    if (isSet(other.fields, FALLBACK_ID)) {
-      fallbackId = other.fallbackId;
-    }
-    if (isSet(other.fields, THEME)) {
-      theme = other.theme;
-    }
-    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
-      isTransformationAllowed = other.isTransformationAllowed;
-    }
-    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
-      isTransformationRequired = other.isTransformationRequired;
-    }
-    if (isSet(other.fields, TRANSFORMATION)) {
-      transformations.putAll(other.transformations);
-    }
-
-    // Applying options with dontTransform() is expected to clear our transformations.
-    if (!isTransformationAllowed) {
-      transformations.clear();
-      fields &= ~TRANSFORMATION;
-      isTransformationRequired = false;
-      fields &= ~TRANSFORMATION_REQUIRED;
-    }
-
-    fields |= other.fields;
-    options.putAll(other.options);
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Throws if any further mutations are attempted.
-   *
-   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
-   */
-  @SuppressWarnings("unchecked")
-  public final CHILD lock() {
-    isLocked = true;
-    // This is the only place we should not check locked.
-    return (CHILD) this;
-  }
-
-  /**
-   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
-   * before the mutation resulting in all methods returning a new Object and leaving the original
-   * locked object unmodified.
-   *
-   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
-   * are mutable and are not locked.
-   */
-  public final CHILD autoLock() {
-    if (isLocked && !isAutoCloneEnabled) {
-      throw new IllegalStateException("You cannot auto lock an already locked options object"
-          + ", try clone() first");
-    }
-    isAutoCloneEnabled = true;
-    return lock();
-  }
-
-  @SuppressWarnings("unchecked")
-  private CHILD selfOrThrowIfLocked() {
-    if (isLocked) {
-      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
-    }
-    return (CHILD) this;
-  }
-
-  public final Map<Class<?>, Transformation<?>> getTransformations() {
-    return transformations;
-  }
-
-  public final boolean isTransformationRequired() {
-    return isTransformationRequired;
-  }
-
-  public final Options getOptions() {
-    return options;
-  }
-
-  public final Class<?> getResourceClass() {
-    return resourceClass;
-  }
-
-  public final DiskCacheStrategy getDiskCacheStrategy() {
-    return diskCacheStrategy;
-  }
-
-  public final Drawable getErrorPlaceholder() {
-    return errorPlaceholder;
-  }
-
-  public final int getErrorId() {
-    return errorId;
-  }
-
-  public final int getPlaceholderId() {
-    return placeholderId;
-  }
-
-  public final Drawable getPlaceholderDrawable() {
-    return placeholderDrawable;
-  }
-
-  public final int getFallbackId() {
-    return fallbackId;
-  }
-
-  public final Drawable getFallbackDrawable() {
-    return fallbackDrawable;
-  }
-
-  public final Resources.Theme getTheme() {
-    return theme;
-  }
-
-  public final boolean isMemoryCacheable() {
-    return isCacheable;
-  }
-
-  public final Key getSignature() {
-    return signature;
-  }
-
-  public final boolean isPrioritySet() {
-    return isSet(PRIORITY);
-  }
-
-  public final Priority getPriority() {
-    return priority;
-  }
-
-  public final int getOverrideWidth() {
-    return overrideWidth;
-  }
-
-  public final boolean isValidOverride() {
-    return Util.isValidDimensions(overrideWidth, overrideHeight);
-  }
-
-  public final int getOverrideHeight() {
-    return overrideHeight;
-  }
-
-  public final float getSizeMultiplier() {
-    return sizeMultiplier;
-  }
-
-  private boolean isSet(int flag) {
-    return isSet(fields, flag);
-  }
-
-  private static boolean isSet(int fields, int flag) {
-    return (fields & flag) != 0;
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
index aa485d357..063b96dd8 100644
--- a/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.request;
 
 import com.bumptech.glide.request.target.Target;
-
 import java.util.concurrent.Future;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 681a949ce..3280c9249 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -3,11 +3,9 @@
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
-
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -83,17 +81,15 @@ public RequestFutureTarget(Handler mainHandler, int width, int height) {
 
   @Override
   public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-    if (isCancelled) {
-      return true;
+    if (isDone()) {
+      return false;
     }
-
-    final boolean result = !isDone();
-    if (result) {
-      isCancelled = true;
-      waiter.notifyAll(this);
+    isCancelled = true;
+    waiter.notifyAll(this);
+    if (mayInterruptIfRunning) {
+      clearOnMainThread();
     }
-    clearOnMainThread();
-    return result;
+    return true;
   }
 
   @Override
@@ -181,7 +177,7 @@ public synchronized void onResourceReady(R resource, Transition<? super R> trans
 
   private synchronized R doGet(Long timeoutMillis)
       throws ExecutionException, InterruptedException, TimeoutException {
-    if (assertBackgroundThread) {
+    if (assertBackgroundThread && !isDone()) {
       Util.assertBackgroundThread();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index 0bde3e95a..0644473d2 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.request;
 
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.target.Target;
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 3bf554ecd..e796c58cb 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -1,27 +1,63 @@
 package com.bumptech.glide.request;
 
 import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
+import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CenterInside;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.FitCenter;
+import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
+import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
+import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
- * The standard concrete implementation of {@link com.bumptech.glide.request.BaseRequestOptions}.
- *
- * <p> Uses with custom types, transformations, or options can subclass and customize. {@link
- * com.bumptech.glide.request.BaseRequestOptions}. </p>
+ * Provides type independent options to customize loads with Glide.
  */
 @SuppressWarnings({"PMD.UseUtilityClass", "unused"})
-public final class RequestOptions extends BaseRequestOptions<RequestOptions> {
+public class RequestOptions implements Cloneable {
+  private static final int UNSET = -1;
+  private static final int SIZE_MULTIPLIER = 1 << 1;
+  private static final int DISK_CACHE_STRATEGY = 1 << 2;
+  private static final int PRIORITY = 1 << 3;
+  private static final int ERROR_PLACEHOLDER = 1 << 4;
+  private static final int ERROR_ID = 1 << 5;
+  private static final int PLACEHOLDER = 1 << 6;
+  private static final int PLACEHOLDER_ID = 1 << 7;
+  private static final int IS_CACHEABLE = 1 << 8;
+  private static final int OVERRIDE = 1 << 9;
+  private static final int SIGNATURE = 1 << 10;
+  private static final int TRANSFORMATION = 1 << 11;
+  private static final int RESOURCE_CLASS = 1 << 12;
+  private static final int FALLBACK = 1 << 13;
+  private static final int FALLBACK_ID = 1 << 14;
+  private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
+  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
 
   private static RequestOptions skipMemoryCacheTrueOptions;
   private static RequestOptions skipMemoryCacheFalseOptions;
@@ -32,6 +68,31 @@
   private static RequestOptions noTransformOptions;
   private static RequestOptions noAnimationOptions;
 
+  private int fields;
+  private float sizeMultiplier = 1f;
+  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
+  private Priority priority = Priority.NORMAL;
+  private Drawable errorPlaceholder;
+  private int errorId;
+  private Drawable placeholderDrawable;
+  private int placeholderId;
+  private boolean isCacheable = true;
+  private int overrideHeight = RequestOptions.UNSET;
+  private int overrideWidth = RequestOptions.UNSET;
+  private Key signature = EmptySignature.obtain();
+  private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
+  private Drawable fallbackDrawable;
+  private int fallbackId;
+  private Options options = new Options();
+  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+  private Class<?> resourceClass = Object.class;
+  private boolean isLocked;
+  private Resources.Theme theme;
+  private boolean isAutoCloneEnabled;
+  private boolean useUnlimitedSourceGeneratorsPool;
+  private boolean onlyRetrieveFromCache;
+
   /**
    * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
    */
@@ -87,12 +148,12 @@ public static RequestOptions errorOf(int errorId) {
   public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
     if (skipMemoryCache) {
       if (skipMemoryCacheTrueOptions == null) {
-        skipMemoryCacheTrueOptions = new RequestOptions().skipMemoryCache(true).autoLock();
+        skipMemoryCacheTrueOptions = new RequestOptions().skipMemoryCache(true).autoClone();
       }
       return skipMemoryCacheTrueOptions;
     } else {
       if (skipMemoryCacheFalseOptions == null) {
-        skipMemoryCacheFalseOptions = new RequestOptions().skipMemoryCache(false).autoLock();
+        skipMemoryCacheFalseOptions = new RequestOptions().skipMemoryCache(false).autoClone();
       }
       return skipMemoryCacheFalseOptions;
     }
@@ -121,69 +182,89 @@ public static RequestOptions signatureOf(@NonNull Key signature) {
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #fitCenter(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link #fitCenter()} set.
    */
-  public static RequestOptions fitCenterTransform(Context context) {
+  public static RequestOptions fitCenterTransform() {
     if (fitCenterOptions == null) {
       fitCenterOptions = new RequestOptions()
-          .fitCenter(context.getApplicationContext())
-          .autoLock();
+          .fitCenter()
+          .autoClone();
     }
     return fitCenterOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #centerInside(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link #centerInside()} set.
    */
-  public static RequestOptions centerInsideTransform(Context context) {
+  public static RequestOptions centerInsideTransform() {
     if (centerInsideOptions == null) {
       centerInsideOptions = new RequestOptions()
-              .centerInside(context.getApplicationContext())
-              .autoLock();
+              .centerInside()
+              .autoClone();
     }
     return centerInsideOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #circleCrop(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
    */
-  public static RequestOptions centerCropTransform(Context context) {
+  public static RequestOptions centerCropTransform() {
     if (centerCropOptions == null) {
       centerCropOptions = new RequestOptions()
-          .centerCrop(context.getApplicationContext())
-          .autoLock();
+          .centerCrop()
+          .autoClone();
     }
     return centerCropOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set.
    */
-  public static RequestOptions circleCropTransform(Context context) {
+  public static RequestOptions circleCropTransform() {
     if (circleCropOptions == null) {
       circleCropOptions = new RequestOptions()
-          .circleCrop(context.getApplicationContext())
-          .autoLock();
+          .circleCrop()
+          .autoClone();
     }
     return circleCropOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #transform(Context, Transformation)} set.
+   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
+   *
+   * @deprecated Use {@link #bitmapTransform(Transformation)}.
+   */
+  @Deprecated
+  public static RequestOptions bitmapTransform(
+      Context context, @NonNull Transformation<Bitmap> transformation) {
+    return bitmapTransform(transformation);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
    */
-  public static RequestOptions bitmapTransform(Context context,
-      @NonNull Transformation<Bitmap> transformation) {
-    return new RequestOptions().transform(context, transformation);
+  public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new RequestOptions().transform(transformation);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
+   *
+   * @deprecated use {@link #noTransformation()}
    */
+  @Deprecated
   public static RequestOptions noTransform() {
+    return noTransformation();
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
+   */
+  public static RequestOptions noTransformation() {
     if (noTransformOptions == null) {
       noTransformOptions = new RequestOptions()
           .dontTransform()
-          .autoLock();
+          .autoClone();
     }
     return noTransformOptions;
   }
@@ -248,8 +329,966 @@ public static RequestOptions noAnimation() {
     if (noAnimationOptions == null) {
       noAnimationOptions = new RequestOptions()
           .dontAnimate()
-          .autoLock();
+          .autoClone();
     }
     return noAnimationOptions;
   }
+
+  private static boolean isSet(int fields, int flag) {
+    return (fields & flag) != 0;
+  }
+
+  /**
+   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
+   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
+   * (particularly {@link Bitmap}s on devices with overly dense screens.
+   *
+   * @param sizeMultiplier The multiplier to apply to the
+   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
+   *                       loading the resource.
+   * @return This request builder.
+   */
+  public RequestOptions sizeMultiplier(float sizeMultiplier) {
+    if (isAutoCloneEnabled) {
+      return clone().sizeMultiplier(sizeMultiplier);
+    }
+
+    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+    }
+    this.sizeMultiplier = sizeMultiplier;
+    fields |= SIZE_MULTIPLIER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useUnlimitedSourceGeneratorsPool(flag);
+    }
+
+    this.useUnlimitedSourceGeneratorsPool = flag;
+    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to true, will only load an item if found in the cache, and will not fetch from source.
+   */
+  public RequestOptions onlyRetrieveFromCache(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().onlyRetrieveFromCache(flag);
+    }
+
+    this.onlyRetrieveFromCache = flag;
+    fields |= ONLY_RETRIEVE_FROM_CACHE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link DiskCacheStrategy} to use for this load.
+   *
+   * <p> Defaults to {@link DiskCacheStrategy#AUTOMATIC}. </p>
+   *
+   * <p> For most applications {@link DiskCacheStrategy#RESOURCE} is
+   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
+   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
+   * using {@link DiskCacheStrategy#DATA} or
+   * {@link DiskCacheStrategy#ALL}. </p>
+   *
+   * @param strategy The strategy to use.
+   * @return This request builder.
+   */
+  public RequestOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    if (isAutoCloneEnabled) {
+      return clone().diskCacheStrategy(strategy);
+    }
+    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
+    fields |= DISK_CACHE_STRATEGY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the priority for this load.
+   *
+   * @param priority A priority.
+   * @return This request builder.
+   */
+  public RequestOptions priority(@NonNull Priority priority) {
+    if (isAutoCloneEnabled) {
+      return clone().priority(priority);
+    }
+
+    this.priority = Preconditions.checkNotNull(priority);
+    fields |= PRIORITY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display while a resource is loading.
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  public RequestOptions placeholder(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(drawable);
+    }
+
+    this.placeholderDrawable = drawable;
+    fields |= PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an Android resource id for a {@link Drawable} resource to
+   * display while a resource is loading.
+   *
+   * @param resourceId The id of the resource to use as a placeholder
+   * @return This request builder.
+   */
+  public RequestOptions placeholder(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(resourceId);
+    }
+
+    this.placeholderId = resourceId;
+    fields |= PLACEHOLDER_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  public RequestOptions fallback(Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(drawable);
+    }
+
+    this.fallbackDrawable = drawable;
+    fields |= FALLBACK;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
+   * the error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param resourceId The id of the resource to use as a fallback.
+   * @return This request builder.
+   */
+  public RequestOptions fallback(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(resourceId);
+    }
+
+    this.fallbackId = resourceId;
+    fields |= FALLBACK_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a {@link Drawable} to display if a load fails.
+   *
+   * @param drawable The drawable to display.
+   * @return This request builder.
+   */
+  public RequestOptions error(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().error(drawable);
+    }
+
+    this.errorPlaceholder = drawable;
+    fields |= ERROR_PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if a load fails.
+   *
+   * @param resourceId The id of the resource to use as a placeholder.
+   * @return This request builder.
+   */
+  public RequestOptions error(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().error(resourceId);
+    }
+    this.errorId = resourceId;
+    fields |= ERROR_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
+   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
+   * {@link #fallback(Drawable)}.
+   *
+   * @param theme The theme to use when loading Drawables.
+   * @return this request builder.
+   */
+  public RequestOptions theme(Resources.Theme theme) {
+    if (isAutoCloneEnabled) {
+      return clone().theme(theme);
+    }
+
+    this.theme = theme;
+    fields |= THEME;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Allows the loaded resource to skip the memory cache.
+   *
+   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
+   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
+   *
+   * @param skip True to allow the resource to skip the memory cache.
+   * @return This request builder.
+   */
+  public RequestOptions skipMemoryCache(boolean skip) {
+    if (isAutoCloneEnabled) {
+      return clone().skipMemoryCache(true);
+    }
+
+    this.isCacheable = !skip;
+    fields |= IS_CACHEABLE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given values. This is useful for thumbnails, and should only be used for other cases when you
+   * need a very specific image size.
+   *
+   * @param width  The width in pixels to use to load the resource.
+   * @param height The height in pixels to use to load the resource.
+   * @return This request builder.
+   */
+  public RequestOptions override(int width, int height) {
+    if (isAutoCloneEnabled) {
+      return clone().override(width, height);
+    }
+
+    this.overrideWidth = width;
+    this.overrideHeight = height;
+    fields |= OVERRIDE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given size.
+   *
+   * @see #override(int, int)
+   * @param size The width and height to use.
+   * @return This request builder.
+   */
+  public RequestOptions override(int size) {
+    return override(size, size);
+  }
+
+  /**
+   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
+   * more control over when cached data is invalidated.
+   *
+   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
+   *
+   * @param signature A unique non-null {@link Key} representing the current
+   *                  state of the model that will be mixed in to the cache key.
+   * @return This request builder.
+   * @see com.bumptech.glide.signature.ObjectKey
+   */
+  public RequestOptions signature(@NonNull Key signature) {
+    if (isAutoCloneEnabled) {
+      return clone().signature(signature);
+    }
+
+    this.signature = Preconditions.checkNotNull(signature);
+    fields |= SIGNATURE;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Returns a copy of this request builder with all of the options put so far on this builder.
+   *
+   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * changes to one builder will not affect the other builder. However, in addition to immutable
+   * arguments, the current model is not copied copied so changes to the model will affect both
+   * builders. </p>
+   *
+   * <p> Even if this object was locked, the cloned object returned from this method will not be
+   * locked. </p>
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  public RequestOptions clone() {
+    try {
+      RequestOptions result = (RequestOptions) super.clone();
+      result.options = new Options();
+      result.options.putAll(options);
+      result.transformations = new HashMap<>();
+      result.transformations.putAll(transformations);
+      result.isLocked = false;
+      result.isAutoCloneEnabled = false;
+      return (RequestOptions) result;
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public <T> RequestOptions set(@NonNull Option<T> option, @NonNull T value) {
+    if (isAutoCloneEnabled) {
+      return clone().set(option, value);
+    }
+
+    Preconditions.checkNotNull(option);
+    Preconditions.checkNotNull(value);
+    options.set(option, value);
+    return selfOrThrowIfLocked();
+  }
+
+  public RequestOptions decode(@NonNull Class<?> resourceClass) {
+    if (isAutoCloneEnabled) {
+      return clone().decode(resourceClass);
+    }
+
+    this.resourceClass = Preconditions.checkNotNull(resourceClass);
+    fields |= RESOURCE_CLASS;
+    return selfOrThrowIfLocked();
+  }
+
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
+  public final boolean isTransformationSet() {
+    return isSet(TRANSFORMATION);
+  }
+
+  public final boolean isLocked() {
+    return isLocked;
+  }
+
+  /**
+   * Sets the value for key
+   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
+   */
+  public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the value for key
+   * {@link BitmapEncoder#COMPRESSION_QUALITY}.
+   */
+  public RequestOptions encodeQuality(int quality) {
+    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
+  }
+
+  /**
+   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
+   * {@link Downsampler}.
+   *
+   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
+   * decoded using a decoder that cannot control the format
+   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
+   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
+   * image has alpha).
+   */
+  public RequestOptions format(@NonNull DecodeFormat format) {
+    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the time position of the frame to extract from a video.
+   *
+   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
+   *                        Android framework implementation return a representative frame.
+   */
+  public RequestOptions frame(long frameTimeMicros) {
+    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
+  }
+
+  /**
+   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
+   * {@link Downsampler}.
+   */
+  public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerCrop()
+   */
+  public RequestOptions optionalCenterCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context any {@link Context}.
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   *
+   * @deprecated Use {@link #centerCrop()}.
+   */
+  @Deprecated
+  public RequestOptions centerCrop(@SuppressWarnings("unused") Context context) {
+    return centerCrop();
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()} ()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  public RequestOptions centerCrop() {
+    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #fitCenter()
+   */
+  public RequestOptions optionalFitCenter() {
+    return optionalTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link FitCenter} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalFitCenter()
+   */
+  public RequestOptions fitCenter() {
+    return transform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link Context}.
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   *
+   * @deprecated Use {@link #optionalCenterInside()}
+   */
+  @Deprecated
+  public RequestOptions optionalCenterInside(@SuppressWarnings("unused") Context context) {
+    return optionalCenterInside();
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   */
+  public RequestOptions optionalCenterInside() {
+    return optionalTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CenterInside} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterInside()
+   */
+  public RequestOptions centerInside() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Transformation)
+   * @see #circleCrop()
+   */
+  public RequestOptions optionalCircleCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link Context}.
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   *
+   * @deprecated Use {@link #circleCrop()}.
+   */
+  @Deprecated
+  public RequestOptions circleCrop(@SuppressWarnings("unused") Context context) {
+    return circleCrop();
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  public RequestOptions circleCrop() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
+  }
+
+  // calling optionalTransform() on the result of clone() requires greater access.
+  @SuppressWarnings("WeakerAccess")
+  final RequestOptions optionalTransform(DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return optionalTransform(transformation);
+  }
+
+  // calling transform() on the result of clone() requires greater access.
+  @SuppressWarnings("WeakerAccess")
+  final RequestOptions transform(DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation);
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for
+   *                       {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  public RequestOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(transformation);
+    }
+
+    optionalTransform(transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context        Any {@link Context}.
+   * @param transformation Any {@link Transformation} for
+   *                       {@link Bitmap}s.
+   * @see #transform(Class, Transformation)
+   *
+   * @deprecated Use {@link #optionalTransform(Transformation)}
+   */
+  @Deprecated
+  public RequestOptions optionalTransform(Context context, Transformation<Bitmap> transformation) {
+    return optionalTransform(transformation);
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for
+   *                       {@link Bitmap}s.
+   * @see #transform(Transformation)
+   * @see #transform(Class, Transformation)
+   */
+  public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(transformation);
+    }
+
+    optionalTransform(Bitmap.class, transformation);
+    // TODO: remove BitmapDrawable decoder and this transformation.
+    optionalTransform(BitmapDrawable.class,
+        new BitmapDrawableTransformation(transformation));
+    optionalTransform(GifDrawable.class, new GifDrawableTransformation(transformation));
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and allows unknown resource types to be ignored.
+   *
+   * <p> Users can apply different transformations for each resource class. Applying a
+   * {@link Transformation} for a resource type that already has a
+   * {@link Transformation} will override the previous call. </p>
+   *
+   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
+   * an unknown resource class will throw an exception. To allow unknown types, users must always
+   * call the optional version of each method. </p>
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   */
+  public <T> RequestOptions optionalTransform(Class<T> resourceClass,
+      Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(resourceClass, transformation);
+    }
+
+    Preconditions.checkNotNull(resourceClass);
+    Preconditions.checkNotNull(transformation);
+    transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and throws if asked to transform an unknown resource type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   * @see #optionalTransform(Class, Transformation)
+   */
+  public <T> RequestOptions transform(
+      Class<T> resourceClass, Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(resourceClass, transformation);
+    }
+
+    optionalTransform(resourceClass, transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Removes all applied {@link Transformation Transformations} for all
+   * resource classes and allows unknown resource types to be transformed without throwing an
+   * exception.
+   */
+  public RequestOptions dontTransform() {
+    if (isAutoCloneEnabled) {
+      return clone().dontTransform();
+    }
+
+    transformations.clear();
+    fields &= ~TRANSFORMATION;
+    isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Disables resource decoders that return animated resources so any resource returned will be
+   * static.
+   *
+   * <p> To disable transitions (fades etc) use
+   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
+   */
+  public RequestOptions dontAnimate() {
+    if (isAutoCloneEnabled) {
+      return clone().dontAnimate();
+    }
+
+    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
+    set(StreamGifDecoder.DISABLE_ANIMATION, true);
+    return selfOrThrowIfLocked();
+  }
+
+  public RequestOptions apply(RequestOptions other) {
+    if (isAutoCloneEnabled) {
+      return clone().apply(other);
+    }
+
+    if (isSet(other.fields, SIZE_MULTIPLIER)) {
+      sizeMultiplier = other.sizeMultiplier;
+    }
+    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
+      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
+    }
+    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
+      diskCacheStrategy = other.diskCacheStrategy;
+    }
+    if (isSet(other.fields, PRIORITY)) {
+      priority = other.priority;
+    }
+    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
+      errorPlaceholder = other.errorPlaceholder;
+    }
+    if (isSet(other.fields, ERROR_ID)) {
+      errorId = other.errorId;
+    }
+    if (isSet(other.fields, PLACEHOLDER)) {
+      placeholderDrawable = other.placeholderDrawable;
+    }
+    if (isSet(other.fields, PLACEHOLDER_ID)) {
+      placeholderId = other.placeholderId;
+    }
+    if (isSet(other.fields, IS_CACHEABLE)) {
+      isCacheable = other.isCacheable;
+    }
+    if (isSet(other.fields, OVERRIDE)) {
+      overrideWidth = other.overrideWidth;
+      overrideHeight = other.overrideHeight;
+    }
+    if (isSet(other.fields, SIGNATURE)) {
+      signature = other.signature;
+    }
+    if (isSet(other.fields, RESOURCE_CLASS)) {
+      resourceClass = other.resourceClass;
+    }
+    if (isSet(other.fields, FALLBACK)) {
+      fallbackDrawable = other.fallbackDrawable;
+    }
+    if (isSet(other.fields, FALLBACK_ID)) {
+      fallbackId = other.fallbackId;
+    }
+    if (isSet(other.fields, THEME)) {
+      theme = other.theme;
+    }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+    }
+    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
+      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+    }
+
+    fields |= other.fields;
+    options.putAll(other.options);
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Throws if any further mutations are attempted.
+   *
+   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
+   */
+  @SuppressWarnings("unchecked")
+  public RequestOptions lock() {
+    isLocked = true;
+    // This is the only place we should not check locked.
+    return (RequestOptions) this;
+  }
+
+  /**
+   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
+   * before the mutation resulting in all methods returning a new Object and leaving the original
+   * locked object unmodified.
+   *
+   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
+   * are mutable and are not locked.
+   */
+  public RequestOptions autoClone() {
+    if (isLocked && !isAutoCloneEnabled) {
+      throw new IllegalStateException("You cannot auto lock an already locked options object"
+          + ", try clone() first");
+    }
+    isAutoCloneEnabled = true;
+    return lock();
+  }
+
+  @SuppressWarnings("unchecked")
+  private RequestOptions selfOrThrowIfLocked() {
+    if (isLocked) {
+      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
+    }
+    return (RequestOptions) this;
+  }
+
+  public final Map<Class<?>, Transformation<?>> getTransformations() {
+    return transformations;
+  }
+
+  public final boolean isTransformationRequired() {
+    return isTransformationRequired;
+  }
+
+  public final Options getOptions() {
+    return options;
+  }
+
+  public final Class<?> getResourceClass() {
+    return resourceClass;
+  }
+
+  public final DiskCacheStrategy getDiskCacheStrategy() {
+    return diskCacheStrategy;
+  }
+
+  public final Drawable getErrorPlaceholder() {
+    return errorPlaceholder;
+  }
+
+  public final int getErrorId() {
+    return errorId;
+  }
+
+  public final int getPlaceholderId() {
+    return placeholderId;
+  }
+
+  public final Drawable getPlaceholderDrawable() {
+    return placeholderDrawable;
+  }
+
+  public final int getFallbackId() {
+    return fallbackId;
+  }
+
+  public final Drawable getFallbackDrawable() {
+    return fallbackDrawable;
+  }
+
+  public final Resources.Theme getTheme() {
+    return theme;
+  }
+
+  public final boolean isMemoryCacheable() {
+    return isCacheable;
+  }
+
+  public final Key getSignature() {
+    return signature;
+  }
+
+  public final boolean isPrioritySet() {
+    return isSet(PRIORITY);
+  }
+
+  public final Priority getPriority() {
+    return priority;
+  }
+
+  public final int getOverrideWidth() {
+    return overrideWidth;
+  }
+
+  public final boolean isValidOverride() {
+    return Util.isValidDimensions(overrideWidth, overrideHeight);
+  }
+
+  public final int getOverrideHeight() {
+    return overrideHeight;
+  }
+
+  public final float getSizeMultiplier() {
+    return sizeMultiplier;
+  }
+
+  private boolean isSet(int flag) {
+    return isSet(fields, flag);
+  }
+
+  public final boolean getUseUnlimitedSourceGeneratorsPool() {
+    return useUnlimitedSourceGeneratorsPool;
+  }
+
+  public final boolean getOnlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 4509e3401..53050e86f 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -5,7 +5,6 @@
 import android.support.v4.content.res.ResourcesCompat;
 import android.support.v4.util.Pools;
 import android.util.Log;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -17,6 +16,7 @@
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
@@ -85,7 +85,7 @@
   private GlideContext glideContext;
   private Object model;
   private Class<R> transcodeClass;
-  private BaseRequestOptions<?> requestOptions;
+  private RequestOptions requestOptions;
   private int overrideWidth;
   private int overrideHeight;
   private Priority priority;
@@ -107,7 +107,7 @@
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
@@ -137,7 +137,8 @@
     return request;
   }
 
-  private SingleRequest() {
+  @Synthetic
+  SingleRequest() {
     // just create, instances are reused with recycle/init
   }
 
@@ -145,7 +146,7 @@ private void init(
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
@@ -281,7 +282,7 @@ public void pause() {
     status = Status.PAUSED;
   }
 
-  private void releaseResource(Resource resource) {
+  private void releaseResource(Resource<?> resource) {
     engine.release(resource);
     this.resource = null;
   }
@@ -373,8 +374,8 @@ public void onSizeReady(int width, int height) {
     status = Status.RUNNING;
 
     float sizeMultiplier = requestOptions.getSizeMultiplier();
-    this.width = Math.round(sizeMultiplier * width);
-    this.height = Math.round(sizeMultiplier * height);
+    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
+    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
@@ -393,12 +394,18 @@ public void onSizeReady(int width, int height) {
         requestOptions.isTransformationRequired(),
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
+        requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+        requestOptions.getOnlyRetrieveFromCache(),
         this);
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
   }
 
+  private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
+    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
+  }
+
   private boolean canSetResource() {
     return requestCoordinator == null || requestCoordinator.canSetImage(this);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index d878f0c07..996f41ad3 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -27,7 +27,7 @@ public void setRequests(Request full, Request thumb) {
   }
 
   /**
-   * Returns true if the request is either the request loading the fullsize image or if the request
+   * Returns true if the request is either the request loading the full size image or if the request
    * loading the full size image has not yet completed.
    *
    * @param request {@inheritDoc}
@@ -42,7 +42,7 @@ private boolean parentCanSetImage() {
   }
 
   /**
-   * Returns true if the request is the request loading the fullsize image and if neither the full
+   * Returns true if the request is the request loading the full size image and if neither the full
    * nor the thumbnail image have completed successfully.
    *
    * @param request {@inheritDoc}.
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index ccfe0f1fe..5259a5973 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -5,7 +5,6 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
index 1c3e2407a..792de64a3 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
-
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.Request;
 
 /**
@@ -23,27 +23,28 @@
   private Request request;
 
   @Override
-  public void setRequest(Request request) {
+  public void setRequest(@Nullable Request request) {
     this.request = request;
   }
 
   @Override
+  @Nullable
   public Request getRequest() {
     return request;
   }
 
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
   @Override
-  public void onLoadStarted(Drawable placeholder) {
+  public void onLoadStarted(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
   @Override
-  public void onLoadFailed(Drawable errorDrawable) {
+  public void onLoadFailed(@Nullable Drawable errorDrawable) {
     // Do nothing.
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
index f58eceda3..f5d978a22 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
@@ -10,8 +10,8 @@
 import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
-
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A wrapper drawable to square the wrapped drawable so that it expands to fill a square with
@@ -81,7 +81,6 @@ public void setFilterBitmap(boolean filter) {
     wrapped.setFilterBitmap(filter);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @Override
   public Callback getCallback() {
     return wrapped.getCallback();
@@ -196,8 +195,8 @@ public ConstantState getConstantState() {
 
   static class State extends ConstantState {
     private final ConstantState wrapped;
-    private final int width;
-    private final int height;
+    @Synthetic final int width;
+    @Synthetic final int height;
 
     State(State other) {
       this(other.wrapped, other.width, other.height);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index 85ed326a4..eb4fa50ab 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -4,7 +4,6 @@
 import android.graphics.drawable.Drawable;
 import android.support.annotation.Nullable;
 import android.widget.ImageView;
-
 import com.bumptech.glide.request.transition.Transition;
 
 /**
@@ -54,7 +53,7 @@ public void setDrawable(Drawable drawable) {
   @Override
   public void onLoadStarted(@Nullable Drawable placeholder) {
     super.onLoadStarted(placeholder);
-    setResource(null);
+    setResourceInternal(null);
     setDrawable(placeholder);
   }
 
@@ -67,7 +66,7 @@ public void onLoadStarted(@Nullable Drawable placeholder) {
   @Override
   public void onLoadFailed(@Nullable Drawable errorDrawable) {
     super.onLoadFailed(errorDrawable);
-    setResource(null);
+    setResourceInternal(null);
     setDrawable(errorDrawable);
   }
 
@@ -80,19 +79,16 @@ public void onLoadFailed(@Nullable Drawable errorDrawable) {
   @Override
   public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
-    setResource(null);
+    setResourceInternal(null);
     setDrawable(placeholder);
   }
 
   @Override
   public void onResourceReady(Z resource, @Nullable Transition<? super Z> transition) {
     if (transition == null || !transition.transition(resource, this)) {
-      setResource(resource);
-    }
-
-    if (resource instanceof Animatable) {
-      animatable = (Animatable) resource;
-      animatable.start();
+      setResourceInternal(resource);
+    } else {
+      maybeUpdateAnimatable(resource);
     }
   }
 
@@ -110,6 +106,20 @@ public void onStop() {
     }
   }
 
+  private void setResourceInternal(@Nullable Z resource) {
+    maybeUpdateAnimatable(resource);
+    setResource(resource);
+  }
+
+  private void maybeUpdateAnimatable(@Nullable Z resource) {
+    if (resource instanceof Animatable) {
+      animatable = (Animatable) resource;
+      animatable.start();
+    } else {
+      animatable = null;
+    }
+  }
+
   protected abstract void setResource(@Nullable Z resource);
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index 35d32b295..481523111 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -6,7 +6,6 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Preconditions;
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index 2245adace..0488526e6 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -2,7 +2,6 @@
 
 import android.graphics.drawable.Drawable;
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.manager.LifecycleListener;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
@@ -31,11 +30,15 @@
    * A lifecycle callback that is called when a load is started.
    *
    * <p> Note - This may not be called for every load, it is possible for example for loads to fail
-   * before the load starts (when the model object is null). </p>
+   * before the load starts (when the model object is null).
    *
    * <p> Note - This method may be called multiple times before any other lifecycle method is
    * called. Loads can be paused and restarted due to lifecycle or connectivity events and each
-   * restart may cause a call here. </p>
+   * restart may cause a call here.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
@@ -45,7 +48,11 @@
    * A lifecycle callback that is called when a load fails.
    *
    * <p> Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)
-   * } if the model object is null. </p>
+   * } if the model object is null.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param errorDrawable The error drawable to optionally show, or null.
    */
@@ -61,6 +68,10 @@
   /**
    * A lifecycle callback that is called when a load is cancelled and its resources are freed.
    *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
+   *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
   void onLoadCleared(@Nullable Drawable placeholder);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 336d4b069..0dd6742b7 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -1,21 +1,15 @@
 package com.bumptech.glide.request.target;
 
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.graphics.Point;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.support.annotation.Nullable;
 import android.util.Log;
-import android.view.Display;
 import android.view.View;
 import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
-import android.view.WindowManager;
-
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Preconditions;
-
+import com.bumptech.glide.util.Synthetic;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.List;
@@ -167,15 +161,14 @@ public static void setTagId(int tagId) {
   }
 
   private static class SizeDeterminer {
-    // Some negative sizes (WRAP_CONTENT) are valid, 0 is never valid.
+    // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
     private static final int PENDING_SIZE = 0;
     private final View view;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
 
     @Nullable private SizeDeterminerLayoutListener layoutListener;
-    @Nullable private Point displayDimens;
 
-    public SizeDeterminer(View view) {
+    SizeDeterminer(View view) {
       this.view = view;
     }
 
@@ -185,14 +178,15 @@ private void notifyCbs(int width, int height) {
       }
     }
 
-    private void checkCurrentDimens() {
+    @Synthetic
+    void checkCurrentDimens() {
       if (cbs.isEmpty()) {
         return;
       }
 
-      int currentWidth = getViewWidthOrParam();
-      int currentHeight = getViewHeightOrParam();
-      if (!isSizeValid(currentWidth) || !isSizeValid(currentHeight)) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (!isViewStateAndSizeValid(currentWidth, currentHeight)) {
         return;
       }
 
@@ -201,22 +195,22 @@ private void checkCurrentDimens() {
     }
 
     void getSize(SizeReadyCallback cb) {
-      int currentWidth = getViewWidthOrParam();
-      int currentHeight = getViewHeightOrParam();
-      if (isSizeValid(currentWidth) && isSizeValid(currentHeight)) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
         cb.onSizeReady(currentWidth, currentHeight);
-      } else {
-        // We want to notify callbacks in the order they were added and we only expect one or two
-        // callbacks to
-        // be added a time, so a List is a reasonable choice.
-        if (!cbs.contains(cb)) {
-          cbs.add(cb);
-        }
-        if (layoutListener == null) {
-          final ViewTreeObserver observer = view.getViewTreeObserver();
-          layoutListener = new SizeDeterminerLayoutListener(this);
-          observer.addOnPreDrawListener(layoutListener);
-        }
+        return;
+      }
+
+      // We want to notify callbacks in the order they were added and we only expect one or two
+      // callbacks to be added a time, so a List is a reasonable choice.
+      if (!cbs.contains(cb)) {
+        cbs.add(cb);
+      }
+      if (layoutListener == null) {
+        ViewTreeObserver observer = view.getViewTreeObserver();
+        layoutListener = new SizeDeterminerLayoutListener(this);
+        observer.addOnPreDrawListener(layoutListener);
       }
     }
 
@@ -235,64 +229,67 @@ void clearCallbacksAndListener() {
       cbs.clear();
     }
 
-    private int getViewHeightOrParam() {
-      final LayoutParams layoutParams = view.getLayoutParams();
-      if (isSizeValid(view.getHeight())) {
-        return view.getHeight();
-      } else if (layoutParams != null) {
-        return getSizeForParam(layoutParams.height, true /*isHeight*/);
-      } else {
-        return PENDING_SIZE;
-      }
+    private boolean isViewStateAndSizeValid(int width, int height) {
+      return isViewStateValid() && isSizeValid(width) && isSizeValid(height);
     }
 
-    private int getViewWidthOrParam() {
-      final LayoutParams layoutParams = view.getLayoutParams();
-      if (isSizeValid(view.getWidth())) {
-        return view.getWidth();
-      } else if (layoutParams != null) {
-        return getSizeForParam(layoutParams.width, false /*isHeight*/);
-      } else {
-        return PENDING_SIZE;
+    private boolean isViewStateValid() {
+      // We consider the view state as valid if the view has
+      // non-null layout params and a non-zero layout width and height.
+      if (view.getLayoutParams() != null
+          && view.getLayoutParams().width > 0
+          && view.getLayoutParams().height > 0) {
+        return true;
       }
-    }
 
-    private int getSizeForParam(int param, boolean isHeight) {
-      if (param == LayoutParams.WRAP_CONTENT) {
-        Point displayDimens = getDisplayDimens();
-        return isHeight ? displayDimens.y : displayDimens.x;
-      } else {
-        return param;
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+        return view.isLaidOut();
       }
+      return !view.isLayoutRequested();
     }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
-    @SuppressWarnings("deprecation")
-    private Point getDisplayDimens() {
-      if (displayDimens != null) {
-        return displayDimens;
+    private int getTargetHeight() {
+      int verticalPadding = view.getPaddingTop() + view.getPaddingBottom();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.height : PENDING_SIZE;
+      return getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);
+    }
+
+    private int getTargetWidth() {
+      int horizontalPadding = view.getPaddingLeft() + view.getPaddingRight();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.width : PENDING_SIZE;
+      return getTargetDimen(view.getWidth(), layoutParamSize, horizontalPadding);
+    }
+
+    private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
+      int adjustedViewSize = viewSize - paddingSize;
+      if (isSizeValid(adjustedViewSize)) {
+        return adjustedViewSize;
+      }
+
+      if (paramSize == PENDING_SIZE) {
+        return PENDING_SIZE;
       }
-      WindowManager windowManager =
-          (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
-      Display display = windowManager.getDefaultDisplay();
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
-        displayDimens = new Point();
-        display.getSize(displayDimens);
+
+      if (paramSize == LayoutParams.WRAP_CONTENT) {
+        return SIZE_ORIGINAL;
+      } else if (paramSize > 0) {
+        return paramSize - paddingSize;
       } else {
-        displayDimens = new Point(display.getWidth(), display.getHeight());
+        return PENDING_SIZE;
       }
-      return displayDimens;
     }
 
     private boolean isSizeValid(int size) {
-      return size > 0 || size == LayoutParams.WRAP_CONTENT;
+      return size > 0 || size == SIZE_ORIGINAL;
     }
 
     private static class SizeDeterminerLayoutListener implements ViewTreeObserver
         .OnPreDrawListener {
       private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
-      public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
+      SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
         sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
       }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
new file mode 100644
index 000000000..012d2009b
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
@@ -0,0 +1,54 @@
+package com.bumptech.glide.request.transition;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.load.DataSource;
+
+/**
+ * A {@link TransitionFactory} for complex types that have a {@link android.graphics.Bitmap} inside.
+ * The transitioning bitmap is wrapped in a {@link android.graphics.drawable.BitmapDrawable}.
+ * Most commonly used with {@link DrawableCrossFadeFactory}.
+ *
+ * @param <R> The type of the composite object that contains the {@link android.graphics.Bitmap} to
+ *            be transitioned.
+ */
+public abstract class BitmapContainerTransitionFactory<R> implements TransitionFactory<R> {
+  private final TransitionFactory<Drawable> realFactory;
+
+  public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory) {
+    this.realFactory = realFactory;
+  }
+
+  @Override
+  public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
+    Transition<Drawable> transition = realFactory.build(dataSource, isFirstResource);
+    return new BitmapGlideAnimation(transition);
+  }
+
+  /**
+   * Retrieve the Bitmap from a composite object.
+   * <p><b>Warning:</b> Do not convert any arbitrary object to Bitmap
+   * via expensive drawing here, this method is called on the UI thread.</p>
+   *
+   * @param current composite object containing a Bitmap and some other information
+   * @return the Bitmap contained within {@code current}
+   */
+  protected abstract Bitmap getBitmap(R current);
+
+  private class BitmapGlideAnimation implements Transition<R> {
+    private final Transition<Drawable> transition;
+
+    public BitmapGlideAnimation(Transition<Drawable> transition) {
+      this.transition = transition;
+    }
+
+    @Override
+    public boolean transition(R current, ViewAdapter adapter) {
+      Resources resources = adapter.getView().getResources();
+      Drawable currentBitmap = new BitmapDrawable(resources, getBitmap(current));
+      return transition.transition(currentBitmap, adapter);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
new file mode 100644
index 000000000..a6982b5d5
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
@@ -0,0 +1,23 @@
+package com.bumptech.glide.request.transition;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+
+/**
+ * A {@link TransitionFactory} for {@link android.graphics.Bitmap}s that uses a Drawable transition
+ * factory to transition from an existing drawable already visible on the target to the new bitmap.
+ *
+ * @see BitmapContainerTransitionFactory
+ */
+public class BitmapTransitionFactory extends BitmapContainerTransitionFactory<Bitmap> {
+  public BitmapTransitionFactory(@NonNull TransitionFactory<Drawable> realFactory) {
+    super(realFactory);
+  }
+
+  @Override
+  @NonNull
+  protected Bitmap getBitmap(@NonNull Bitmap current) {
+    return current;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index e4e3a0d93..f81f5c3d0 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -4,7 +4,6 @@
 import android.graphics.drawable.Drawable;
 import android.view.animation.AlphaAnimation;
 import android.view.animation.Animation;
-
 import com.bumptech.glide.load.DataSource;
 
 /**
@@ -15,35 +14,20 @@
  * <p> Resources are usually loaded from the memory cache just before the user can see the view, for
  * example when the user changes screens or scrolls back and forth in a list. In those cases the
  * user typically does not expect to see a transition. As a result, when the resource is loaded from
- * the memory cache this factory produces an {@link NoTransition}. </p>
+ * the memory cache this factory produces an {@link NoTransition}.
  */
 public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
-  private static final int DEFAULT_DURATION_MS = 300;
   private final ViewAnimationFactory<Drawable> viewAnimationFactory;
   private final int duration;
+  private final boolean isCrossFadeEnabled;
   private DrawableCrossFadeTransition firstResourceTransition;
   private DrawableCrossFadeTransition secondResourceTransition;
 
-  public DrawableCrossFadeFactory() {
-    this(DEFAULT_DURATION_MS);
-  }
-
-  public DrawableCrossFadeFactory(int duration) {
-    this(new ViewAnimationFactory<Drawable>(
-        new DefaultViewTransitionAnimationFactory(duration)), duration);
-  }
-
-  public DrawableCrossFadeFactory(int defaultAnimationId, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimationId), duration);
-  }
-
-  public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimation), duration);
-  }
-
-  DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory, int duration) {
+  protected DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory,
+      int duration, boolean isCrossFadeEnabled) {
     this.viewAnimationFactory = viewAnimationFactory;
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   @Override
@@ -59,36 +43,117 @@ public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
 
   private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {
       if (firstResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(dataSource, true /*isFirstResource*/);
-          firstResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+        firstResourceTransition = buildTransition(dataSource, true /*isFirstResource*/);
       }
       return firstResourceTransition;
   }
 
   private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {
       if (secondResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(dataSource, false /*isFirstResource*/);
-          secondResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+        secondResourceTransition = buildTransition(dataSource, false /*isFirstResource*/);
       }
       return secondResourceTransition;
   }
 
-  private static class DefaultViewTransitionAnimationFactory implements ViewTransition
-      .ViewTransitionAnimationFactory {
+  private DrawableCrossFadeTransition buildTransition(DataSource dataSource,
+      boolean isFirstResource) {
+    Transition<Drawable> defaultAnimation =
+        viewAnimationFactory.build(dataSource, isFirstResource);
+    return new DrawableCrossFadeTransition(defaultAnimation, duration, isCrossFadeEnabled);
+  }
+
+  private static final class DefaultViewTransitionAnimationFactory implements
+      ViewTransition.ViewTransitionAnimationFactory {
 
-    private final int duration;
+    private final int durationMillis;
 
-    DefaultViewTransitionAnimationFactory(int duration) {
-      this.duration = duration;
+    DefaultViewTransitionAnimationFactory(int durationMillis) {
+      this.durationMillis = durationMillis;
     }
 
     @Override
     public Animation build(Context context) {
       AlphaAnimation animation = new AlphaAnimation(0f, 1f);
-      animation.setDuration(duration);
+      animation.setDuration(durationMillis);
       return animation;
     }
   }
+
+  /**
+   * A Builder for {@link DrawableCrossFadeFactory}.
+   */
+  public static class Builder {
+    private static final int DEFAULT_DURATION_MS = 300;
+    private int durationMillis;
+    private ViewAnimationFactory<Drawable> factory;
+    private boolean isCrossFadeEnabled;
+
+    public Builder() {
+      this(DEFAULT_DURATION_MS);
+    }
+
+    /**
+     * @param durationMillis The duration of both the default animation when no previous Drawable
+     *     is present and the cross fade animation when a previous Drawable is present. This value
+     *     will not be used by the default animation if {@link #setDefaultAnimationId(int)},
+     *     {@link #setDefaultAnimation(Animation)}, or
+     *     {@link #setDefaultAnimationFactory(ViewAnimationFactory)} is called.
+     */
+    public Builder(int durationMillis) {
+      this.durationMillis = durationMillis;
+      factory = new ViewAnimationFactory<>(
+          new DefaultViewTransitionAnimationFactory(durationMillis));
+    }
+
+    /**
+     * Enables or disables animating the alpha of the {@link Drawable} the cross fade will animate
+     * from.
+     *
+     * <p>Defaults to {@code false}.
+     *
+     * @param isCrossFadeEnabled If {@code true} the previous {@link Drawable}'s alpha will be
+     *     animated from 100 to 0 while the new {@link Drawable}'s alpha is
+     *     animated from 0 to 100. Otherwise the previous {@link Drawable}'s
+     *     alpha will remain at 100 throughout the animation. See
+     *     {@link android.graphics.drawable.TransitionDrawable#setCrossFadeEnabled(boolean)}
+     */
+    public Builder setCrossFadeEnabled(boolean isCrossFadeEnabled) {
+      this.isCrossFadeEnabled = isCrossFadeEnabled;
+      return this;
+    }
+
+    /**
+     * Sets the resource id of the {@link Animation} to use when no previous {@link Drawable} is
+     * available to animate from.
+     *
+     * <p>Defaults to a simple fade in.
+     */
+    public Builder setDefaultAnimationId(int animationId) {
+      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animationId));
+    }
+
+    /**
+     * Sets the {@link Animation} to use when no previous {@link Drawable} is available to animate
+     * from.
+     *
+     * <p>It is not safe to use the same {@link Animation} object for multiple animations
+     * simultaneously. Always pass in a new instance to this method.
+     */
+    public Builder setDefaultAnimation(Animation animation) {
+      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animation));
+    }
+
+    /**
+     * Sets the {@link ViewAnimationFactory} to use to generate animations to animate when no
+     * previous {@link Drawable} is available to animate from.
+     */
+    public Builder setDefaultAnimationFactory(ViewAnimationFactory<Drawable> factory) {
+      this.factory = factory;
+      return this;
+    }
+
+    public DrawableCrossFadeFactory build() {
+      return new DrawableCrossFadeFactory(factory, durationMillis, isCrossFadeEnabled);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index 2cbca19c7..ee1ff46e2 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -13,17 +13,28 @@
 public class DrawableCrossFadeTransition implements Transition<Drawable> {
   private final Transition<Drawable> defaultAnimation;
   private final int duration;
+  private final boolean isCrossFadeEnabled;
 
   /**
    * Constructor that takes a default animation and a duration in milliseconds that the cross fade
    * animation should last.
    *
+   * @param defaultAnimation The {@link Transition} to use if there is no previous
+   *                         {@link Drawable} (either a placeholder or previous resource) to
+   *                         transition from.
    * @param duration The duration that the cross fade animation should run if there is something to
    *                 cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
+   * @param isCrossFadeEnabled If {@code true}, animates the previous resource's alpha to 0 while
+   *                         animating the new resource's alpha to 100. Otherwise, only animates
+   *                         the new resource's alpha to 100 while leaving the previous resource's
+   *                         alpha at 100. See
+   *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
-  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration) {
+  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration,
+      boolean isCrossFadeEnabled) {
     this.defaultAnimation = defaultAnimation;
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   /**
@@ -43,7 +54,7 @@ public boolean transition(Drawable current, ViewAdapter adapter) {
     if (previous != null) {
       TransitionDrawable transitionDrawable =
           new TransitionDrawable(new Drawable[] { previous, current });
-      transitionDrawable.setCrossFadeEnabled(true);
+      transitionDrawable.setCrossFadeEnabled(isCrossFadeEnabled);
       transitionDrawable.startTransition(duration);
       adapter.setDrawable(transitionDrawable);
       return true;
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
index 2417f8ab6..d5a1c1e33 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request.transition;
 
 import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.util.Synthetic;
 
 /**
  * A simple {@link Transition} that performs no actions.
@@ -9,7 +10,7 @@
  * {@link com.bumptech.glide.request.target.Target}.
  */
 public class NoTransition<R> implements Transition<R> {
-  private static final NoTransition<?> NO_ANIMATION = new NoTransition<Object>();
+  @Synthetic static final NoTransition<?> NO_ANIMATION = new NoTransition<Object>();
   @SuppressWarnings("rawtypes")
   private static final TransitionFactory<?> NO_ANIMATION_FACTORY = new NoAnimationFactory();
 
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
index 0aad3abef..661c27715 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java
@@ -3,7 +3,6 @@
 import android.content.Context;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
-
 import com.bumptech.glide.load.DataSource;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 907a4effb..974dc0abd 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -3,9 +3,7 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-
 import com.bumptech.glide.load.Key;
-
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
 
diff --git a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
index 56d4c474d..93f572c0f 100644
--- a/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/EmptySignature.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.load.Key;
-
 import java.security.MessageDigest;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index 4c0474748..e14e1a573 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -2,7 +2,6 @@
 
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Util;
-
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
diff --git a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
index 0637bcada..50ccc9f3f 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ObjectKey.java
@@ -2,7 +2,6 @@
 
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
-
 import java.security.MessageDigest;
 
 /**
@@ -11,8 +10,8 @@
  * method to the {@link java.security.MessageDigest} in
  * {@link #updateDiskCacheKey(java.security.MessageDigest)}.
  *
- * <p> The Object's {@link #toString()} method must be unique and suitable for use as a disk cache
- * key. </p>
+ * <p>The Object's {@link #toString()} method must be unique and suitable for use as a disk cache
+ * key.</p>
  */
 public final class ObjectKey implements Key {
   private final Object object;
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index a3f5c3de0..788901575 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -142,9 +142,9 @@ private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
   }
 
   static final class SafeArray {
-    private final int offset;
-    private final int limit;
-    private final byte[] data;
+    @Synthetic final int offset;
+    @Synthetic final int limit;
+    @Synthetic final byte[] data;
 
     public SafeArray(byte[] data, int offset, int limit) {
       this.data = data;
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
index eac7dfec4..0f4803ace 100644
--- a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -2,7 +2,6 @@
 
 import android.text.TextUtils;
 import android.util.Log;
-
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -52,7 +51,9 @@ public synchronized int available() throws IOException {
 
   @Override
   public synchronized int read() throws IOException {
-    return checkReadSoFarOrThrow(super.read());
+    int value = super.read();
+    checkReadSoFarOrThrow(value >= 0 ? 1 : -1);
+    return value;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
index c0b9a8940..b6c9e40d4 100644
--- a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.util;
 
 import com.bumptech.glide.ListPreloader;
-
 import java.util.Arrays;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index 1377e3a15..0d47fd7d7 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.util;
 
 import android.support.annotation.Nullable;
-
 import java.util.LinkedHashMap;
 import java.util.Map;
 
diff --git a/library/src/main/java/com/bumptech/glide/util/Preconditions.java b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
index 8356ab943..121ead84c 100644
--- a/library/src/main/java/com/bumptech/glide/util/Preconditions.java
+++ b/library/src/main/java/com/bumptech/glide/util/Preconditions.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.util;
 
 import android.text.TextUtils;
-
 import java.util.Collection;
 
 /**
diff --git a/library/src/main/java/com/bumptech/glide/util/Synthetic.java b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
new file mode 100644
index 000000000..0d1140b04
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/util/Synthetic.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.util;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that target's visibility can be relaxed to avoid synthetic methods.
+ */
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.TYPE})
+public @interface Synthetic {
+}
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 0f9c35794..ea66b1126 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -4,9 +4,7 @@
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Looper;
-
 import com.bumptech.glide.request.target.Target;
-
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -92,7 +90,7 @@ public static int getBitmapByteSize(int width, int height, Bitmap.Config config)
   }
 
   private static int getBytesPerPixel(Bitmap.Config config) {
-    // A bitmap by decoding a gif has null "config" in certain environments.
+    // A bitmap by decoding a GIF has null "config" in certain environments.
     if (config == null) {
       config = Bitmap.Config.ARGB_8888;
     }
@@ -152,7 +150,7 @@ public static boolean isOnMainThread() {
   }
 
   /**
-   * Returns {@code true} if called on the main thread, {@code false} otherwise.
+   * Returns {@code true} if called on a background thread, {@code false} otherwise.
    */
   public static boolean isOnBackgroundThread() {
     return !isOnMainThread();
@@ -172,13 +170,13 @@ public static boolean isOnBackgroundThread() {
    * <p> See #303 and #375. </p>
    */
   public static <T> List<T> getSnapshot(Collection<T> other) {
-      // toArray creates a new ArrayList internally and this way we can guarantee entries will not
-      // be null. See #322.
-      List<T> result = new ArrayList<T>(other.size());
-      for (T item : other) {
-          result.add(item);
-      }
-      return result;
+    // toArray creates a new ArrayList internally and this way we can guarantee entries will not
+    // be null. See #322.
+    List<T> result = new ArrayList<T>(other.size());
+    for (T item : other) {
+      result.add(item);
+    }
+    return result;
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index f37f74fe8..5f341a5b4 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.util;
 
 import android.view.View;
-
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.request.transition.Transition;
-
 import java.util.Arrays;
 
 /**
@@ -75,14 +73,13 @@ public void setView(View view) {
   }
 
   private static final class SizeViewTarget extends ViewTarget<View, Object> {
-
     public SizeViewTarget(View view, SizeReadyCallback callback) {
       super(view);
       getSize(callback);
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition transition) {
+    public void onResourceReady(Object resource, Transition<? super Object> transition) {
       // Do nothing
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
index 009ddebf6..23416d80d 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -4,7 +4,6 @@
 import android.support.v4.util.Pools.SimplePool;
 import android.support.v4.util.Pools.SynchronizedPool;
 import android.util.Log;
-
 import java.util.ArrayList;
 import java.util.List;
 
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
index 65460d082..7e6577dd3 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/StateVerifier.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.util.pool;
 
+import com.bumptech.glide.util.Synthetic;
+
 /**
  * Verifies that the job is not in the recycled state.
  */
@@ -20,7 +22,7 @@ public static StateVerifier newInstance() {
   private StateVerifier() { }
 
   /**
-   * Throws an exception if we believe our object is recycled and inactive (ie is currently in an
+   * Throws an exception if we believe our object is recycled and inactive (i.e. is currently in an
    * object pool).
    */
   public abstract void throwIfRecycled();
@@ -33,6 +35,9 @@ private StateVerifier() { }
   private static class DefaultStateVerifier extends StateVerifier {
     private volatile boolean isReleased;
 
+    @Synthetic
+    DefaultStateVerifier() { }
+
     @Override
     public void throwIfRecycled() {
       if (isReleased) {
@@ -50,6 +55,9 @@ public void setRecycled(boolean isRecycled) {
     // Keeps track of the stack trace where our state was set to recycled.
     private volatile RuntimeException recycledAtStackTraceException;
 
+    @Synthetic
+    DebugStateVerifier() { }
+
     @Override
     public void throwIfRecycled() {
       if (recycledAtStackTraceException != null) {
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index 18fc12548..62a086519 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -29,7 +29,6 @@
 import android.os.ParcelFileDescriptor;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
@@ -56,7 +55,15 @@
 import com.bumptech.glide.tests.GlideShadowLooper;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.testutil.TestResourceUtil;
-
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Map;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -70,20 +77,10 @@
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
-import org.robolectric.internal.ShadowExtractor;
 import org.robolectric.res.builder.RobolectricPackageManager;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.nio.ByteBuffer;
-import java.util.HashMap;
-import java.util.Map;
-
 /**
  * Tests for the {@link Glide} interface and singleton.
  */
@@ -92,7 +89,9 @@
     GlideTest.ShadowFileDescriptorContentResolver.class,
     GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
     GlideTest.MutableShadowBitmap.class })
+@SuppressWarnings({"unchecked", "deprecation"})
 public class GlideTest {
+  @SuppressWarnings("rawtypes")
   private Target target = null;
   private ImageView imageView;
   private RequestManager requestManager;
@@ -101,8 +100,7 @@
   public void setUp() throws Exception {
     Glide.tearDown();
 
-    RobolectricPackageManager pm =
-        (RobolectricPackageManager) RuntimeEnvironment.application.getPackageManager();
+    RobolectricPackageManager pm = RuntimeEnvironment.getRobolectricPackageManager();
     ApplicationInfo info =
         pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
     info.metaData = new Bundle();
@@ -112,6 +110,7 @@ public void setUp() throws Exception {
     target = mock(Target.class);
     imageView = new ImageView(RuntimeEnvironment.application);
     imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
+    imageView.layout(0, 0, 100, 100);
     doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
 
     Handler bgHandler = mock(Handler.class);
@@ -126,7 +125,7 @@ public Boolean answer(InvocationOnMock invocation) throws Throwable {
 
     Lifecycle lifecycle = mock(Lifecycle.class);
     RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-    requestManager = new RequestManager(getContext(), lifecycle, treeNode);
+    requestManager = new RequestManager(Glide.get(getContext()), lifecycle, treeNode);
     requestManager.resumeRequests();
   }
 
@@ -142,8 +141,8 @@ public void testCanSetMemoryCategory() {
 
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder(getContext()).setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
-            .createGlide();
+        new GlideBuilder().setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
+            .build(getContext());
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -156,8 +155,8 @@ public void testClearMemory() {
     MemoryCache memoryCache = mock(MemoryCache.class);
 
     Glide glide =
-        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .createGlide();
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
+            .build(getContext());
 
     glide.clearMemory();
 
@@ -171,8 +170,8 @@ public void testTrimMemory() {
     MemoryCache memoryCache = mock(MemoryCache.class);
 
     Glide glide =
-        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .createGlide();
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
+            .build(getContext());
 
     final int level = 123;
 
@@ -329,13 +328,13 @@ private void runTestUriStringDefaultLoader() {
   private void runTestStringDefaultLoader(String string) {
     requestManager.load(string).listener(new RequestListener<Drawable>() {
       @Override
-      public boolean onLoadFailed(GlideException e, Object model, Target target,
+      public boolean onLoadFailed(GlideException e, Object model, Target<Drawable> target,
           boolean isFirstResource) {
         throw new RuntimeException("Load failed");
       }
 
       @Override
-      public boolean onResourceReady(Drawable resource, Object model, Target target,
+      public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target,
           DataSource dataSource, boolean isFirstResource) {
         return false;
       }
@@ -531,9 +530,9 @@ public void testByteData() {
 
   @Test
   public void testClone() throws IOException {
-    Target firstTarget = mock(Target.class);
+    Target<Drawable> firstTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(firstTarget).getSize(isA(SizeReadyCallback.class));
-    Target secondTarget = mock(Target.class);
+    Target<Drawable> secondTarget = mock(Target.class);
     doAnswer(new CallSizeReady(100, 100)).when(secondTarget).getSize(isA(SizeReadyCallback.class));
     RequestBuilder<Drawable> firstRequest = requestManager
         .load(mockUri("content://first"));
@@ -545,14 +544,14 @@ public void testClone() throws IOException {
         .into(secondTarget);
 
     verify(firstTarget).onResourceReady(isA(Drawable.class), isA(Transition.class));
-    verify(secondTarget).onResourceReady(notNull(), isA(Transition.class));
+    verify(secondTarget).onResourceReady(notNull(Drawable.class), isA(Transition.class));
   }
 
   @SuppressWarnings("unchecked")
   private <T, Z> void registerFailFactory(Class<T> failModel, Class<Z> failResource)
       throws Exception {
     DataFetcher<Z> failFetcher = mock(DataFetcher.class);
-    doAnswer(new Util.CallDataReady(null))
+    doAnswer(new Util.CallDataReady<>(null))
         .when(failFetcher)
         .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
     when(failFetcher.getDataClass()).thenReturn(failResource);
@@ -561,8 +560,7 @@ public void testClone() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), failFetcher));
     when(failLoader.handles(isA(failModel))).thenReturn(true);
     ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
-    when(failFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(failLoader);
+    when(failFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(failLoader);
 
     Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
   }
@@ -581,7 +579,7 @@ private String mockUri(Uri uri, InputStream is) {
     }
     ContentResolver contentResolver = RuntimeEnvironment.application.getContentResolver();
     ShadowFileDescriptorContentResolver shadowContentResolver =
-        (ShadowFileDescriptorContentResolver) ShadowExtractor.extract(contentResolver);
+        (ShadowFileDescriptorContentResolver) Shadow.extract(contentResolver);
     shadowContentResolver.registerInputStream(uri, is);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
@@ -600,8 +598,7 @@ private Context getContext() {
   private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
     ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
-    when(modelLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(modelLoader);
+    when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
     Glide.get(RuntimeEnvironment.application).getRegistry()
         .prepend(modelClass, InputStream.class, modelLoaderFactory);
@@ -612,7 +609,7 @@ private Context getContext() {
     ModelLoader<T, InputStream> modelLoader = mock(ModelLoader.class);
     DataFetcher<InputStream> fetcher = mock(DataFetcher.class);
     try {
-      doAnswer(new Util.CallDataReady(new ByteArrayInputStream(new byte[0]))).when(fetcher)
+      doAnswer(new Util.CallDataReady<>(new ByteArrayInputStream(new byte[0]))).when(fetcher)
           .loadData(isA(Priority.class), isA(DataFetcher.DataCallback.class));
     } catch (Exception e) {
       // Do nothing.
@@ -692,7 +689,7 @@ public void registerComponents(Context context, Registry registry) {
           .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
       when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
       ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-      when(mockUrlLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
+      when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
           .thenReturn(mockUrlLoader);
 
       registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
@@ -704,6 +701,7 @@ public void registerComponents(Context context, Registry registry) {
   // a different part of the test. Each one ends up with different registered uris, which causes
   // tests to fail. We shouldn't need to do this, but using static maps seems to fix the issue.
   @Implements(value = ContentResolver.class)
+  @SuppressWarnings("unused")
   public static class ShadowFileDescriptorContentResolver {
     private static final Map<Uri, AssetFileDescriptor> URI_TO_FILE_DESCRIPTOR = new HashMap<>();
     private static final Map<Uri, InputStream> URI_TO_INPUT_STREAMS = new HashMap<>();
diff --git a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
index b76b5dc58..f1b8b51e8 100644
--- a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.tests.Util.cast;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -7,11 +8,15 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.graphics.Bitmap;
-
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
-
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,19 +27,11 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ListPreloaderTest {
 
-  @Mock private RequestBuilder<Bitmap> request;
+  @Mock private RequestBuilder<Object> request;
   @Mock private RequestManager requestManager;
 
   @Before
@@ -71,8 +68,7 @@ public void testGetItemsIsCalledInOrderIncreasing() {
     }
 
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-
-      public int expectedPosition;
+      private int expectedPosition;
 
       @Override
       public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
@@ -85,7 +81,8 @@ public void testGetItemsIsCalledInOrderIncreasing() {
       }
 
       @Override
-      public RequestBuilder<Bitmap> getPreloadRequestBuilder(Object item) {
+      @SuppressWarnings("unchecked")
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition++;
         return mock(RequestBuilder.class);
@@ -129,7 +126,7 @@ public void testGetItemsIsCalledInOrderDecreasing() {
     }
 
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      int expectedPosition = toPreload - 1;
+      private int expectedPosition = toPreload - 1;
 
       @Override
       public int[] getPreloadSize(Object item, int adapterPosition, int itemPosition) {
@@ -145,7 +142,8 @@ public void testGetItemsIsCalledInOrderDecreasing() {
       }
 
       @Override
-      public RequestBuilder<Bitmap> getPreloadRequestBuilder(Object item) {
+      @SuppressWarnings("unchecked")
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         assertEquals(objects.get(expectedPosition), item);
         expectedPosition--;
         return mock(RequestBuilder.class);
@@ -249,7 +247,7 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
     objects.add(new Object());
     objects.add(new Object());
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      public int expectedPosition = (1 + 10) * 2;
+      private int expectedPosition = (1 + 10) * 2;
 
       @Override
       public List<Object> getPreloadItems(int position) {
@@ -265,7 +263,7 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
       }
 
       @Override
-      public RequestBuilder getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         return request;
       }
     };
@@ -285,7 +283,7 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
     objects.add(new Object());
     objects.add(new Object());
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
-      int expectedPosition = objects.size() * 2 - 1;
+      private int expectedPosition = objects.size() * 2 - 1;
 
       @Override
       public List<Object> getPreloadItems(int position) {
@@ -301,7 +299,7 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
       }
 
       @Override
-      public RequestBuilder getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         return request;
       }
     };
@@ -316,12 +314,13 @@ public RequestBuilder getPreloadRequestBuilder(Object item) {
     assertEquals(expected, allValues);
   }
 
-  private List<Integer> getTargetsSizes(RequestBuilder<?> requestBuilder, VerificationMode mode) {
+  private <R> List<Integer> getTargetsSizes(
+      RequestBuilder<R> requestBuilder, VerificationMode mode) {
     ArgumentCaptor<Integer> integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
-    ArgumentCaptor<Target> targetArgumentCaptor = ArgumentCaptor.forClass(Target.class);
+    ArgumentCaptor<Target<R>> targetArgumentCaptor = cast(ArgumentCaptor.forClass(Target.class));
     SizeReadyCallback cb = mock(SizeReadyCallback.class);
     verify(requestBuilder, mode).into(targetArgumentCaptor.capture());
-    for (Target target : targetArgumentCaptor.getAllValues()) {
+    for (Target<R> target : targetArgumentCaptor.getAllValues()) {
       target.getSize(cb);
     }
     verify(cb, mode).onSizeReady(integerArgumentCaptor.capture(), integerArgumentCaptor.capture());
@@ -341,7 +340,7 @@ public void testItemsArePreloadedWithGlide() {
       }
 
       @Override
-      public RequestBuilder getPreloadRequestBuilder(Object item) {
+      public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         loadedObjects.add(item);
         return super.getPreloadRequestBuilder(item);
       }
@@ -367,7 +366,8 @@ public ListPreloaderAdapter() {
     }
 
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Object item) {
+    @SuppressWarnings("unchecked")
+    public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
       return mock(RequestBuilder.class);
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index d27622655..5be7653f0 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -8,13 +8,11 @@
 import static org.mockito.Mockito.when;
 
 import android.widget.ImageView;
-
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.BackgroundUtil;
-
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,19 +28,27 @@
 public class RequestBuilderTest {
   @Mock GlideContext glideContext;
   @Mock RequestManager requestManager;
+  private Glide glide;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    glide = Glide.get(RuntimeEnvironment.application);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new RequestBuilder(null /*context*/, requestManager, Object.class);
+    new RequestBuilder<>(null /*context*/, requestManager, Object.class);
   }
 
   @Test(expected = NullPointerException.class)
-  public void testThrowsWhenGlideAnimationFactoryIsNull() {
+  public void testThrowsWhenTransitionsOptionsIsNull() {
+    //noinspection ConstantConditions testing if @NonNull is enforced
     getNullModelRequest().transition(null);
   }
 
@@ -53,7 +59,7 @@ public void testDoesNotThrowWithNullModelWhenRequestIsBuilt() {
 
   @Test
   public void testAddsNewRequestToRequestTracker() {
-    Target target = mock(Target.class);
+    Target<Object> target = mock(Target.class);
     getNullModelRequest().into(target);
 
     verify(requestManager).track(eq(target), isA(Request.class));
@@ -62,7 +68,7 @@ public void testAddsNewRequestToRequestTracker() {
   @Test
   public void testRemovesPreviousRequestFromRequestTracker() {
     Request previous = mock(Request.class);
-    Target target = mock(Target.class);
+    Target<Object> target = mock(Target.class);
     when(target.getRequest()).thenReturn(previous);
 
     getNullModelRequest().into(target);
@@ -72,7 +78,8 @@ public void testRemovesPreviousRequestFromRequestTracker() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfGivenNullTarget() {
-    getNullModelRequest().into((Target) null);
+    //noinspection ConstantConditions testing if @NonNull is enforced
+    getNullModelRequest().into((Target<Object>) null);
   }
 
   @Test(expected = NullPointerException.class)
@@ -94,7 +101,7 @@ public void runTest() throws Exception {
 
   @Test(expected = RuntimeException.class)
   public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
-    final Target target = mock(Target.class);
+    final Target<Object> target = mock(Target.class);
     testInBackground(new BackgroundUtil.BackgroundTester() {
       @Override
       public void runTest() throws Exception {
@@ -103,13 +110,13 @@ public void runTest() throws Exception {
     });
   }
 
-  private RequestBuilder getNullModelRequest() {
+  private RequestBuilder<Object> getNullModelRequest() {
     when(glideContext.buildImageViewTarget(isA(ImageView.class), isA(Class.class)))
         .thenReturn(mock(Target.class));
     when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
     when(requestManager.getDefaultRequestOptions())
-        .thenReturn((BaseRequestOptions) new RequestOptions());
-    return new RequestBuilder(glideContext, requestManager, Object.class)
+        .thenReturn((RequestOptions) new RequestOptions());
+    return new RequestBuilder<>(glide, requestManager, Object.class)
         .load((Object) null);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
index 0e171262f..68551d56d 100644
--- a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -11,7 +11,6 @@
 import static org.mockito.Mockito.when;
 
 import android.content.Context;
-
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitor.ConnectivityListener;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
@@ -20,7 +19,6 @@
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -57,8 +55,13 @@ public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable
           }
         });
     requestTracker = mock(RequestTracker.class);
-    manager = new RequestManager(RuntimeEnvironment.application, lifecycle, treeNode,
-        requestTracker, factory);
+    manager =
+        new RequestManager(
+            Glide.get(RuntimeEnvironment.application),
+            lifecycle,
+            treeNode,
+            requestTracker,
+            factory);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
index a8a46640a..9a23a4680 100644
--- a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -1,30 +1,33 @@
 package com.bumptech.glide.load;
 
+import static com.bumptech.glide.tests.Util.anyContext;
+import static com.bumptech.glide.tests.Util.anyResource;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
+import org.robolectric.RuntimeEnvironment;
 
 @RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
 public class MultiTransformationTest {
 
   @Mock Transformation<Object> first;
@@ -32,10 +35,13 @@
   @Mock Resource<Object> initial;
   @Mock Resource<Object> firstTransformed;
   @Mock Resource<Object> secondTransformed;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+
+    context = RuntimeEnvironment.application;
   }
 
   @Test
@@ -44,32 +50,34 @@ public void testAppliesTransformationsInOrder() {
     final int height = 768;
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    when(first.transform(eq(initial), eq(width), eq(height))).thenReturn(firstTransformed);
+    when(first.transform(anyContext(), eq(initial), eq(width), eq(height)))
+        .thenReturn(firstTransformed);
 
-    when(second.transform(eq(firstTransformed), eq(width), eq(height)))
+    when(second.transform(anyContext(), eq(firstTransformed), eq(width), eq(height)))
         .thenReturn(secondTransformed);
 
-    assertEquals(secondTransformed, transformation.transform(initial, width, height));
+    assertEquals(secondTransformed, transformation.transform(context, initial, width, height));
   }
 
   @Test
   public void testInitialResourceIsNotRecycled() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
 
-    MultiTransformation<Object> transformation = new MultiTransformation(first);
+    MultiTransformation<Object> transformation = new MultiTransformation<>(first);
 
-    transformation.transform(initial, 123, 456);
+    transformation.transform(context, initial, 123, 456);
 
     verify(initial, never()).recycle();
   }
 
   @Test
   public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformations() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-    when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    transformation.transform(initial, 1111, 2222);
+    transformation.transform(context, initial, 1111, 2222);
 
     verify(initial, never()).recycle();
   }
@@ -77,35 +85,38 @@ public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformati
   @Test
   public void
   testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);
-    when(second.transform(any(Resource.class), anyInt(), anyInt()))
-        .thenReturn(mock(Resource.class));
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(mockResource());
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    transformation.transform(initial, 1, 2);
+    transformation.transform(context, initial, 1, 2);
 
     verify(initial, never()).recycle();
   }
 
   @Test
   public void testFinalResourceIsNotRecycled() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first);
 
-    transformation.transform(mock(Resource.class), 111, 222);
+    transformation.transform(context, mockResource(), 111, 222);
 
     verify(firstTransformed, never()).recycle();
   }
 
   @Test
   public void testIntermediateResourcesAreRecycled() {
-    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);
-    when(second.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(secondTransformed);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(secondTransformed);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
 
-    transformation.transform(mock(Resource.class), 233, 454);
+    transformation.transform(context, mockResource(), 233, 454);
 
     verify(firstTransformed).recycle();
   }
@@ -118,7 +129,7 @@ public void testEquals() throws NoSuchAlgorithmException {
 
     doAnswer(new Util.WriteDigest("second")).when(second)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(new MultiTransformation<>(first),
-        new MultiTransformation<>(second));
+    KeyAssertions.assertDifferent(
+        new MultiTransformation<>(first), new MultiTransformation<>(second));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
index 7205db1dc..bac793e3b 100644
--- a/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load;
 
 import com.google.common.testing.EqualsTester;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
index d60e9c262..77c6a93f5 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -4,18 +4,16 @@
 
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
-
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ExifOrientationStreamTest {
@@ -38,13 +36,12 @@ public void testIncludesGivenExifOrientation() throws IOException {
       for (int j = 0; j < 8; j++) {
         InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
         InputStream wrapped = new ExifOrientationStream(toWrap, i);
-        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
 
         toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
         wrapped = new ExifOrientationStream(toWrap, i);
-        parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
       }
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
index 4e2b4636f..ae3982203 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java
@@ -9,9 +9,8 @@
 import android.content.res.AssetFileDescriptor;
 import android.content.res.AssetManager;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.Priority;
-
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,8 +19,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class FileDescriptorAssetPathFetcherTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 4cef86d3a..94fd216bf 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -10,10 +10,16 @@
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.testutil.TestUtil;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -24,14 +30,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-
 /**
  * Tests {@link com.bumptech.glide.load.data.HttpUrlFetcher} against server responses. Tests for
  * behavior (connection/disconnection/options) should go in
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
index 7f70a4a82..7ad707409 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java
@@ -9,7 +9,11 @@
 
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.model.GlideUrl;
-
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,12 +23,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class HttpUrlFetcherTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index af261f814..b5980ac6b 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -8,9 +8,10 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.Priority;
-
+import java.io.Closeable;
+import java.io.FileNotFoundException;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,10 +21,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.Closeable;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LocalUriFetcherTest {
@@ -64,7 +61,7 @@ public void testHandlesExceptionOnClose() throws Exception {
     final Closeable closeable = mock(Closeable.class);
 
     public TestLocalUriFetcher(Context context, Uri uri) {
-      super(context, uri);
+      super(context.getContentResolver(), uri);
     }
 
     @Override
diff --git a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
index 2f57e9cc1..5b03e0f83 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java
@@ -6,9 +6,9 @@
 import static org.mockito.Mockito.when;
 
 import android.content.res.AssetManager;
-
 import com.bumptech.glide.Priority;
-
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -17,9 +17,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamAssetPathFetcherTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
index 0b0673dc3..4ceec4c8f 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
@@ -7,21 +7,17 @@
 
 import android.net.Uri;
 import android.provider.MediaStore;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ThumbFetcherTest {
@@ -38,12 +34,12 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
-    fetcher = new ThumbFetcher(RuntimeEnvironment.application, uri, opener);
+    fetcher = new ThumbFetcher(uri, opener);
   }
 
   @Test
   public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.LOW, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
@@ -51,7 +47,7 @@ public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
 
   @Test
   public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.HIGH, callback);
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index f06fd0382..50535836c 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -8,13 +8,20 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.content.ContentResolver;
 import android.database.MatrixCursor;
 import android.net.Uri;
 import android.provider.MediaStore;
-
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,11 +31,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.fakes.RoboCursor;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ThumbnailStreamOpenerTest {
@@ -41,43 +43,41 @@ public void setUp() {
 
   @Test
   public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri))).thenReturn(null);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(null);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(new MatrixCursor(new String[1]));
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(new MatrixCursor(new String[1]));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
     MatrixCursor cursor = new MatrixCursor(new String[1]);
     cursor.addRow(new Object[] { "" });
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(cursor);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(cursor);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfFileDoesNotExist() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.exists(eq(harness.file))).thenReturn(false);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnNullIfFileLengthIsZero() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.length(eq(harness.file))).thenReturn(0L);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testClosesCursor() throws FileNotFoundException {
-    harness.get().open(RuntimeEnvironment.application, harness.uri);
+    harness.get().open(harness.uri);
     assertTrue(harness.cursor.isClosed());
   }
 
@@ -86,27 +86,33 @@ public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundExcep
     InputStream expected = new ByteArrayInputStream(new byte[0]);
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .registerInputStream(harness.uri, expected);
-    assertEquals(expected, harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertEquals(expected, harness.get().open(harness.uri));
   }
 
   @Test
   public void testVideoQueryReturnsVideoCursor() {
     Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.VideoThumbnailQuery query = new ThumbFetcher.VideoThumbnailQuery();
+    ThumbFetcher.VideoThumbnailQuery query =
+        new ThumbFetcher.VideoThumbnailQuery(getContentResolver());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
   }
 
   @Test
   public void testImageQueryReturnsImageCursor() {
     Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.ImageThumbnailQuery query = new ThumbFetcher.ImageThumbnailQuery();
+    ThumbFetcher.ImageThumbnailQuery query =
+        new ThumbFetcher.ImageThumbnailQuery(getContentResolver());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
+  }
+
+  private static ContentResolver getContentResolver() {
+    return RuntimeEnvironment.application.getContentResolver();
   }
 
   private static class Harness {
@@ -119,14 +125,17 @@ public void testImageQueryReturnsImageCursor() {
 
     public Harness() {
       cursor.addRow(new String[] { file.getAbsolutePath() });
-      when(query.query(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(cursor);
+      when(query.query(eq(uri))).thenReturn(cursor);
       when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
       when(service.exists(eq(file))).thenReturn(true);
       when(service.length(eq(file))).thenReturn(1L);
     }
 
     public ThumbnailStreamOpener get() {
-      return new ThumbnailStreamOpener(service, query, byteArrayPool);
+      List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+      parsers.add(new DefaultImageHeaderParser());
+      return new ThumbnailStreamOpener(
+          parsers, service, query, byteArrayPool, getContentResolver());
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index 3a4f231ef..81687fa35 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -11,12 +11,11 @@
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.tests.ContentResolverShadow;
-
+import java.io.FileNotFoundException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,9 +24,7 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-import org.robolectric.internal.ShadowExtractor;
-
-import java.io.FileNotFoundException;
+import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
@@ -46,14 +43,15 @@ public void testLoadResource_returnsFileDescriptor() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
     ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
     when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(parcelFileDescriptor);
     shadow.registerFileDescriptor(uri, assetFileDescriptor);
 
-    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(eq(parcelFileDescriptor));
   }
@@ -64,10 +62,11 @@ public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
     shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
 
-    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onLoadFailed(isA(FileNotFoundException.class));
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index 16f6d63cc..a7fb2d580 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -7,12 +7,13 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
 import com.bumptech.glide.tests.ContentResolverShadow;
-
+import java.io.ByteArrayInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -21,11 +22,7 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-import org.robolectric.internal.ShadowExtractor;
-
-import java.io.ByteArrayInputStream;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
+import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
@@ -43,10 +40,10 @@ public void testLoadResource_returnsInputStream() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
     shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
 
-    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
   }
@@ -57,11 +54,11 @@ public void testLoadResource_withNullInputStream_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
 
     shadow.registerInputStream(uri, null /*inputStream*/);
 
-    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.LOW, callback);
 
     verify(callback).onLoadFailed(isA(FileNotFoundException.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
index 33ea85ac1..01c767634 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java
@@ -6,7 +6,9 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util.WriteDigest;
-
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,10 +16,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(JUnit4.class)
 public class DataCacheKeyTest {
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 2f3ea0229..6a740e638 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -2,6 +2,7 @@
 
 import static com.bumptech.glide.tests.Util.anyResource;
 import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
@@ -17,13 +18,13 @@
 
 import android.os.Handler;
 import android.support.v4.util.Pools;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
-
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,9 +36,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLooper;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class EngineJobTest {
@@ -109,7 +107,7 @@ public void testListenerNotifiedJobCompleteOnException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
     ShadowLooper.runUiThreadTasks();
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
+    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
   }
 
   @Test
@@ -180,7 +178,7 @@ public void testRemovingAllCallbacksCancelsRunner() {
   @SuppressWarnings("unchecked")
   @Test
   public void removingSomeCallbacksDoesNotCancelRunner() {
-    EngineJob job = harness.getJob();
+    EngineJob<Object> job = harness.getJob();
     job.addCallback(mock(ResourceCallback.class));
     job.removeCallback(harness.cb);
 
@@ -222,7 +220,7 @@ public void testDoesNotNotifyCancelledIfReceivedException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
-    verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());
+    verify(harness.listener).onEngineJobComplete(eq(harness.key), isNull(EngineResource.class));
     verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
   }
 
@@ -256,9 +254,9 @@ public void testNotifiesNewCallbackOfResourceIfCallbackIsAddedDuringOnResourceRe
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.addCallback(newCallback);
         return null;
       }
@@ -274,13 +272,13 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test
   public void testNotifiesNewCallbackOfExceptionIfCallbackIsAddedDuringOnException() {
     harness = new EngineJobHarness();
-    final EngineJob job = harness.getJob();
+    final EngineJob<Object> job = harness.getJob();
     final ResourceCallback existingCallback = mock(ResourceCallback.class);
     final ResourceCallback newCallback = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.addCallback(newCallback);
         return null;
       }
@@ -299,9 +297,9 @@ public void testRemovingCallbackDuringOnResourceReadyIsIgnoredIfCallbackHasAlrea
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(cb);
         return null;
       }
@@ -320,9 +318,9 @@ public void testRemovingCallbackDuringOnExceptionIsIgnoredIfCallbackHasAlreadyBe
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback cb = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(cb);
         return null;
       }
@@ -342,9 +340,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(notYetCalled);
         return null;
       }
@@ -363,9 +361,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     final EngineJob<Object> job = harness.getJob();
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(notYetCalled);
         return null;
       }
@@ -387,9 +385,9 @@ public void testRemovingCallbackDuringOnExceptionPreventsCallbackFromBeingCalled
     final ResourceCallback called = mock(ResourceCallback.class);
     final ResourceCallback notYetCalled = mock(ResourceCallback.class);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         job.removeCallback(notYetCalled);
         return null;
       }
@@ -441,27 +439,41 @@ public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSourceOnlyOnStart
     verify(harness.decodeJob).run();
   }
 
+  @Test
+  public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOnlyOnStart() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    EngineJob<Object> job = harness.getJob();
+
+    when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    harness.diskCacheService.shutdownNow();
+    job.start(harness.decodeJob);
+
+    verify(harness.decodeJob).run();
+  }
+
   @SuppressWarnings("unchecked")
   private static class MultiCbHarness {
     Key key = mock(Key.class);
-    Resource<Object> resource = mock(Resource.class);
+    Resource<Object> resource = mockResource();
     EngineResource<Object> engineResource = mock(EngineResource.class);
     EngineJobListener listener = mock(EngineJobListener.class);
     boolean isCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
     int numCbs = 10;
     List<ResourceCallback> cbs = new ArrayList<>();
     EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
     EngineJob<Object> job;
     GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
     GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      job = new EngineJob<>(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      job = new EngineJob<>(diskCacheService, sourceService, sourceUnlimitedService, listener, pool,
+          factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
@@ -477,20 +489,23 @@ public MultiCbHarness() {
     Key key = mock(Key.class);
     Handler mainHandler = new Handler();
     ResourceCallback cb = mock(ResourceCallback.class);
-    Resource<Object> resource = mock(Resource.class);
+    Resource<Object> resource = mockResource();
     EngineResource<Object> engineResource = mock(EngineResource.class);
     EngineJobListener listener = mock(EngineJobListener.class);
     GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
     GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     boolean isCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DataSource dataSource = DataSource.DATA_DISK_CACHE;
 
     public EngineJob<Object> getJob() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      EngineJob result = new EngineJob(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      EngineJob<Object> result = new EngineJob<>(
+          diskCacheService, sourceService, sourceUnlimitedService, listener, pool, factory)
+          .init(key, isCacheable, useUnlimitedSourceGeneratorPool);
       result.addCallback(cb);
       return result;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
index e2c13d0e7..0e691225f 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineKeyTest.java
@@ -11,7 +11,10 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collections;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,11 +23,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collections;
-
 /**
  * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object)
  * equals} and SHA-1 disk cache key are different on any difference in ID or existence of a certain
@@ -44,9 +42,10 @@ public void setUp() {
     String id = "testId";
     int width = 1;
     int height = 2;
-    Class resourceClass = Object.class;
-    Class transcodeClass = Integer.class;
+    Class<?> resourceClass = Object.class;
+    Class<?> transcodeClass = Integer.class;
     Key signature = mock(Key.class);
+    @SuppressWarnings("unchecked")
     Transformation<Object> transformation = mock(Transformation.class);
     Options options = new Options();
 
@@ -99,9 +98,9 @@ public void testDiffersIfSignatureDiffers()
       throws UnsupportedEncodingException, NoSuchAlgorithmException {
     EngineKey first = harness.build();
     Key signature = mock(Key.class);
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         MessageDigest digest = (MessageDigest) invocationOnMock.getArguments()[0];
         digest.update("signature".getBytes("UTF-8"));
         return null;
@@ -135,7 +134,7 @@ public void testDiffersIfTranscodeClassDiffers()
   public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {
     EngineKey first = harness.build();
 
-    Transformation<Object> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
     harness.transformation = other;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index 1f328c03d..c4a05be94 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -10,7 +11,6 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.load.Key;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,10 +25,9 @@
   private Key cacheKey = mock(Key.class);
   private Resource<Object> resource;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
-    resource = mock(Resource.class);
+    resource = mockResource();
     engineResource = new EngineResource<>(resource, true /*isMemoryCacheable*/);
     listener = mock(EngineResource.ResourceListener.class);
     engineResource.setResourceListener(cacheKey, listener);
@@ -146,9 +145,9 @@ public void testThrowsIfWrappedResourceIsNull() {
 
   @Test
   public void testCanSetAndGetIsCacheable() {
-    engineResource = new EngineResource<>(mock(Resource.class), true);
+    engineResource = new EngineResource<>(mockResource(), true);
     assertTrue(engineResource.isCacheable());
-    engineResource = new EngineResource<>(mock(Resource.class), false);
+    engineResource = new EngineResource<>(mockResource(), false);
     assertFalse(engineResource.isCacheable());
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index ac0098a9d..6a5cb537c 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -2,6 +2,7 @@
 
 import static com.bumptech.glide.tests.Util.anyResource;
 import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -31,7 +32,9 @@
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
-
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -40,12 +43,9 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.Map;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { GlideShadowLooper.class })
+@SuppressWarnings("unchecked")
 public class EngineTest {
   private EngineTestHarness harness;
 
@@ -97,7 +97,6 @@ public void testNewRunnerIsNotCreatedAndPostedWithExistingLoad() {
   }
 
   @Test
-  @SuppressWarnings("unchecked")
   public void testCallbackIsAddedToExistingRunnerWithExistingLoad() {
     harness.doLoad();
 
@@ -175,7 +174,7 @@ public void testNullLoadStatusIsReturnedIfResourceIsActive() {
   @Test
   public void testActiveResourcesIsNotCheckedIfReturnedFromCache() {
     when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);
-    EngineResource other = mock(EngineResource.class);
+    EngineResource<?> other = mock(EngineResource.class);
     harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));
 
     harness.doLoad();
@@ -227,14 +226,14 @@ public void testResourceIsReturnedFromCacheIfPresent() {
   @Test
   public void testHandlesNonEngineResourcesFromCacheIfPresent() {
     final Object expected = new Object();
-    Resource fromCache = mock(Resource.class);
+    @SuppressWarnings("rawtypes") Resource fromCache = mockResource();
     when(fromCache.get()).thenReturn(expected);
     when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-        Resource resource = (Resource) invocationOnMock.getArguments()[0];
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+        Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[0];
         assertEquals(expected, resource.get());
         return null;
       }
@@ -350,19 +349,18 @@ public void testResourceIsAddedToCacheOnReleased() {
     final Object expected = new Object();
     when(harness.resource.isCacheable()).thenReturn(true);
     when(harness.resource.get()).thenReturn(expected);
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];
         assertEquals(expected, resource.get());
         return null;
       }
-    }).when(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
+    }).when(harness.cache).put(eq(harness.cacheKey), anyResource());
 
     harness.engine.onResourceReleased(harness.cacheKey, harness.resource);
 
-
-    verify(harness.cache).put(eq(harness.cacheKey), any(Resource.class));
+    verify(harness.cache).put(eq(harness.cacheKey), anyResource());
   }
 
   @Test
@@ -421,7 +419,21 @@ public void testKeyFactoryIsGivenNecessaryArguments() {
   public void testFactoryIsGivenNecessaryArguments() {
     harness.doLoad();
 
-    verify(harness.engineJobFactory).build(eq(harness.cacheKey), eq(true) /*isMemoryCacheable*/);
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(false) /*useUnlimitedSourceGeneratorPool*/);
+  }
+
+  @Test
+  public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    harness.doLoad();
+
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(true) /*useUnlimitedSourceGeneratorPool*/);
   }
 
   @Test
@@ -433,7 +445,7 @@ public void testReleaseReleasesEngineResource() {
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfAskedToReleaseNonEngineResource() {
-    harness.engine.release(mock(Resource.class));
+    harness.engine.release(mockResource());
   }
 
   @Test(expected = RuntimeException.class)
@@ -446,13 +458,13 @@ public void runTest() throws Exception {
     });
   }
 
-  @SuppressWarnings("unchecked")
   private static class EngineTestHarness {
     EngineKey cacheKey = mock(EngineKey.class);
     EngineKeyFactory keyFactory = mock(EngineKeyFactory.class);
     ResourceCallback cb = mock(ResourceCallback.class);
+    @SuppressWarnings("rawtypes")
     EngineResource resource = mock(EngineResource.class);
-    Map<Key, EngineJob> jobs = new HashMap<>();
+    Map<Key, EngineJob<?>> jobs = new HashMap<>();
     Map<Key, WeakReference<EngineResource<?>>> activeResources = new HashMap<>();
 
     int width = 100;
@@ -460,7 +472,7 @@ public void runTest() throws Exception {
 
     Object model = new Object();
     MemoryCache cache = mock(MemoryCache.class);
-    EngineJob job;
+    EngineJob<?> job;
     Engine engine;
     Engine.EngineJobFactory engineJobFactory = mock(Engine.EngineJobFactory.class);
     Engine.DecodeJobFactory decodeJobFactory = mock(Engine.DecodeJobFactory.class);
@@ -470,6 +482,8 @@ public void runTest() throws Exception {
     Options options = new Options();
     GlideContext glideContext = mock(GlideContext.class);
     boolean isMemoryCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
+    boolean onlyRetrieveFromCache = false;
 
     public EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
@@ -479,25 +493,30 @@ public EngineTestHarness() {
 
       engine = new Engine(cache, mock(DiskCache.Factory.class),
           GlideExecutor.newDiskCacheExecutor(),
-          MockGlideExecutor.newMainThreadExecutor(), jobs, keyFactory, activeResources,
+          MockGlideExecutor.newMainThreadExecutor(),
+          MockGlideExecutor.newMainThreadUnlimitedExecutor(),
+          jobs, keyFactory, activeResources,
           engineJobFactory, decodeJobFactory, resourceRecycler);
     }
 
     public Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean())).thenReturn(job);
+      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean()))
+          .thenReturn((EngineJob<Object>) job);
       return engine.load(glideContext,
           model,
           signature,
           width,
           height,
-          Object.class,
-          Object.class,
+          Object.class /*resourceClass*/,
+          Object.class /*transcodeClass*/,
           Priority.HIGH,
           DiskCacheStrategy.ALL,
           transformations,
           false /*isTransformationRequired*/,
           options,
           isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
+          onlyRetrieveFromCache,
           cb);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
index 97bac56e7..b2d467fac 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java
@@ -10,16 +10,14 @@
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(JUnit4.class)
 public class ResourceCacheKeyTest {
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
index 9d4257b6d..80405ffc9 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceRecyclerTest.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.load.engine;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 import android.os.Looper;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,7 +28,7 @@ public void setUp() {
 
   @Test
   public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
-    Resource resource = mock(Resource.class);
+    Resource<?> resource = mockResource();
     Shadows.shadowOf(Looper.getMainLooper()).pause();
     recycler.recycle(resource);
     verify(resource).recycle();
@@ -37,11 +36,11 @@ public void testRecyclesResourceSynchronouslyIfNotAlreadyRecyclingResource() {
 
   @Test
   public void testDoesNotRecycleChildResourceSynchronously() {
-    Resource parent = mock(Resource.class);
-    final Resource child = mock(Resource.class);
-    doAnswer(new Answer() {
+    Resource<?> parent = mockResource();
+    final Resource<?> child = mockResource();
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         recycler.recycle(child);
         return null;
       }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
index e81521160..5ee47b04b 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyKeyTest.java
@@ -6,12 +6,9 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.AttributeStrategy.Key;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
index 9fc1f1eb2..234b0f0e3 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java
@@ -4,7 +4,6 @@
 import static org.junit.Assert.assertNull;
 
 import android.graphics.Bitmap;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
index f48d297dd..4f6016cf3 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
@@ -7,20 +7,22 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
+import android.annotation.TargetApi;
+import android.os.Build;
+import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.Arrays;
-
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.DEFAULT, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 18)
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class LruArrayPoolTest {
   private static final int MAX_SIZE = 10;
-  private static final Class ARRAY_CLASS = byte[].class;
-  private static final ArrayAdapterInterface ADAPTER = new ByteArrayAdapter();
+  private static final Class<byte[]> ARRAY_CLASS = byte[].class;
+  private static final ArrayAdapterInterface<byte[]> ADAPTER = new ByteArrayAdapter();
   private LruArrayPool pool;
 
   @Before
@@ -41,8 +43,8 @@ public void testICanAddAndGetValidArray() {
     pool.put(createArray(ARRAY_CLASS, size, value), ARRAY_CLASS);
     Object array = pool.get(size, ARRAY_CLASS);
     assertNotNull(array);
-    assertTrue(ADAPTER.getArrayLength(array) >= size);
     assertTrue(array.getClass() == ARRAY_CLASS);
+    assertTrue(ADAPTER.getArrayLength((byte[]) array) >= size);
     assertTrue(((byte[]) array)[0] == (byte) 0);
   }
 
@@ -97,7 +99,8 @@ private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
     }
   }
 
-  private Object createArray(Class type, int size, int value) {
+  @SuppressWarnings("unchecked")
+  private static <T> T createArray(Class<T> type, int size, int value) {
     Object array = null;
     if (type.equals(int[].class)) {
       array = new int[size];
@@ -106,6 +109,6 @@ private Object createArray(Class type, int size, int value) {
       array = new byte[size];
       Arrays.fill((byte[]) array, (byte) value);
     }
-    return array;
+    return (T) array;
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index 14b51fedc..2b515c771 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -13,7 +13,11 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,12 +26,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowBitmap;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LruBitmapPoolTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
index c56ff320e..2242dcf03 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategyTest.java
@@ -1,9 +1,7 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
index 79385ce31..6175eb2bf 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategyKeyTest.java
@@ -6,10 +6,8 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-import com.google.common.testing.EqualsTester;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.SizeStrategy.Key;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index a1ecd5953..29b03a1ec 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -6,7 +6,9 @@
 
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.Util;
-
+import java.io.File;
+import java.io.IOException;
+import java.security.MessageDigest;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,10 +16,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-import java.security.MessageDigest;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class DiskLruCacheWrapperTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
index 57ce35ebb..3e3451e81 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java
@@ -14,7 +14,6 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.util.LruCache;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
index 4944d2564..00ffc8295 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.engine.cache;
 
 import static com.bumptech.glide.load.engine.cache.MemoryCache.ResourceRemovedListener;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.eq;
@@ -9,23 +10,23 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.annotation.TargetApi;
 import android.content.ComponentCallbacks2;
-
+import android.os.Build;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
-
+import java.security.MessageDigest;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.security.MessageDigest;
-
 @RunWith(JUnit4.class)
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 public class LruResourceCacheTest {
   private static class TrimClearMemoryCacheHarness {
     LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource first = mock(Resource.class);
-    Resource second = mock(Resource.class);
+    Resource<?> first = mockResource();
+    Resource<?> second = mockResource();
 
     ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
 
@@ -71,7 +72,7 @@ public void testTrimMemoryUiHidden() {
   @Test
   public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
     LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource resource = mock(Resource.class);
+    Resource<?> resource = mockResource();
     when(resource.getSize()).thenReturn(200);
 
     ResourceRemovedListener listener = mock(ResourceRemovedListener.class);
@@ -85,17 +86,17 @@ public void testResourceRemovedListenerIsNotifiedWhenResourceIsRemoved() {
   @Test
   public void testSizeIsBasedOnResource() {
     LruResourceCache resourceCache = new LruResourceCache(100);
-    Resource first = getResource(50);
+    Resource<?> first = getResource(50);
     MockKey firstKey = new MockKey();
     resourceCache.put(firstKey, first);
-    Resource second = getResource(50);
+    Resource<?> second = getResource(50);
     MockKey secondKey = new MockKey();
     resourceCache.put(secondKey, second);
 
     assertTrue(resourceCache.contains(firstKey));
     assertTrue(resourceCache.contains(secondKey));
 
-    Resource third = getResource(50);
+    Resource<?> third = getResource(50);
     MockKey thirdKey = new MockKey();
     resourceCache.put(thirdKey, third);
 
@@ -104,8 +105,8 @@ public void testSizeIsBasedOnResource() {
     assertTrue(resourceCache.contains(thirdKey));
   }
 
-  private Resource getResource(int size) {
-    Resource resource = mock(Resource.class);
+  private Resource<?> getResource(int size) {
+    Resource<?> resource = mockResource();
     when(resource.getSize()).thenReturn(size);
     return resource;
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index d22bf9fa9..98c4b8371 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -4,14 +4,12 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import com.google.common.collect.Range;
-
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
-
+import com.bumptech.glide.load.engine.cache.MemorySizeCalculatorTest.LowRamActivityManager;
 import com.bumptech.glide.tests.Util;
-
+import com.google.common.collect.Range;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,10 +18,13 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowActivityManager;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 19, shadows = LowRamActivityManager.class)
 public class MemorySizeCalculatorTest {
   private MemorySizeHarness harness;
   private int initialSdkVersion;
@@ -31,6 +32,7 @@
   @Before
   public void setUp() {
     initialSdkVersion = Build.VERSION.SDK_INT;
+    Util.setSdkVersionInt(18);
     harness = new MemorySizeHarness();
   }
 
@@ -67,7 +69,7 @@ public void testDefaultMemoryCacheSizeIsLimitedByMemoryClass() {
 
     float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
 
-    assertThat((float) memoryCacheSize)
+    assertThat(memoryCacheSize)
         .isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
   }
 
@@ -136,10 +138,11 @@ public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices()
 
   @Test
   public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
-    ShadowActivityManager activityManager = Shadows.shadowOf(harness.activityManager);
+    LowRamActivityManager activityManager =
+        (LowRamActivityManager) Shadow.extract(harness.activityManager);
+    Util.setSdkVersionInt(19);
     activityManager.setMemoryClass(getLargeEnoughMemoryClass());
-
-    Util.setSdkVersionInt(10);
+    activityManager.setIsLowRam(true);
 
     int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
     assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
@@ -184,4 +187,19 @@ public int getScreenSize() {
       return pixelSize * pixelSize * bytesPerPixel;
     }
   }
+
+  @Implements(ActivityManager.class)
+  public static final class LowRamActivityManager extends ShadowActivityManager {
+
+    private boolean isLowRam;
+
+    void setIsLowRam(boolean isLowRam) {
+      this.isLowRam = isLowRam;
+    }
+
+    @Implementation
+    public boolean isLowRamDevice() {
+      return isLowRam;
+    }
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
index 738bcd951..207ccaf9b 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java
@@ -3,17 +3,15 @@
 import static org.junit.Assert.assertTrue;
 
 import com.bumptech.glide.load.Key;
-
+import java.security.MessageDigest;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class SafeKeyGeneratorTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
index 54cf63722..fa9dba251 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -2,15 +2,14 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
index 2b5d216f2..af0dce220 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -12,4 +12,13 @@ public static GlideExecutor newMainThreadExecutor() {
         GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
         true /*runAllOnMainThread*/);
   }
+
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return new GlideExecutor(0 /* corePoolSize */,
+        Integer.MAX_VALUE /* maximumPoolSize */,
+        java.util.concurrent.TimeUnit.SECONDS.toMillis(10) /* keepAliveTimeInMs */,
+        "mock-unlimited-glide-executor",
+        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
+        true /*runAllOnMainThread*/);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
index a5f045618..d00b03193 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.engine.prefill;
 
+import static com.bumptech.glide.tests.Util.anyResource;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertNotEquals;
 import static org.mockito.Matchers.any;
@@ -15,7 +16,6 @@
 
 import android.graphics.Bitmap;
 import android.os.Handler;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -23,7 +23,10 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapResource;
 import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
-
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,11 +38,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapPreFillRunnerTest {
@@ -56,7 +54,7 @@ public void setUp() {
     doAnswer(new AddBitmapPoolAnswer(addedBitmaps)).when(pool).put(any(Bitmap.class));
     when(pool.getDirty(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new CreateBitmap());
-    when(cache.put(any(Key.class), any(Resource.class)))
+    when(cache.put(any(Key.class), anyResource()))
         .thenAnswer(new AddBitmapCacheAnswer(addedBitmaps));
   }
 
@@ -131,7 +129,7 @@ public void testStopsAllocatingBitmapsUntilNextIdleCallIfAllocationsTakeLongerTh
   public void testPreFillHandlerDoesNotPostIfHasNoBitmapsToAllocate() {
     BitmapPreFillRunner handler = getHandler(new HashMap<PreFillType, Integer>());
     handler.run();
-    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyInt());
+    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyLong());
   }
 
   @Test
@@ -207,7 +205,7 @@ public void testAddsBitmapsToMemoryCacheIfMemoryCacheHasEnoughSpaceRemaining() {
 
     getHandler(allocationOrder).run();
 
-    verify(cache).put(any(Key.class), any(Resource.class));
+    verify(cache).put(any(Key.class), anyResource());
     verify(pool, never()).put(any(Bitmap.class));
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // assertThat(addedBitmaps).containsExactly(bitmap);
@@ -226,7 +224,7 @@ public void testAddsBitmapsToBitmapPoolIfMemoryCacheIsFull() {
 
     getHandler(allocationOrder).run();
 
-    verify(cache, never()).put(any(Key.class), any(Resource.class));
+    verify(cache, never()).put(any(Key.class), anyResource());
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     // verify(pool).put(eq(bitmap));
     // assertThat(addedBitmaps).containsExactly(bitmap);
@@ -245,7 +243,7 @@ public void testAddsBitmapsToPoolIfMemoryCacheIsNotFullButCannotFitBitmap() {
 
     getHandler(allocationOrder).run();
 
-    verify(cache, never()).put(any(Key.class), any(Resource.class));
+    verify(cache, never()).put(any(Key.class), anyResource());
     // TODO(b/20335397): This code was relying on Bitmap equality which Robolectric removed
     //verify(pool).put(eq(bitmap));
     //assertThat(addedBitmaps).containsExactly(bitmap);
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
index a308dae93..6349da7e1 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -11,16 +11,15 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.google.common.collect.Range;
-
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.tests.Util.CreateBitmap;
 import com.bumptech.glide.util.Util;
-
+import com.google.common.collect.Range;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,9 +29,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapPreFillerTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
index 26f2469a3..bd14089f4 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/PreFillTypeTest.java
@@ -2,10 +2,8 @@
 
 import static org.junit.Assert.assertEquals;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
-
+import com.google.common.testing.EqualsTester;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
diff --git a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
index 4df23384d..1dd269502 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java
@@ -8,10 +8,8 @@
 
 import android.content.res.AssetManager;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
index 580bc669d..e17ecc6b9 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java
@@ -9,7 +9,7 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -17,8 +17,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import java.io.IOException;
-
 @RunWith(JUnit4.class)
 public class ByteArrayLoaderTest {
 
@@ -52,7 +50,7 @@ public void testFetcherReturnsObjectReceivedFromConverter() throws IOException {
   }
 
   @Test
-  public void testFetcherRetrunsDataClassFromConverter() {
+  public void testFetcherReturnsDataClassFromConverter() {
     when(converter.getDataClass()).thenReturn(Object.class);
     assertEquals(Object.class,
         loader.buildLoadData(new byte[10], 10, 10, options).fetcher.getDataClass());
diff --git a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
index 640ed84f2..6665f0720 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -7,24 +8,21 @@
 
 import android.support.annotation.Nullable;
 import android.util.Base64;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.util.Arrays;
-
 /**
  * Tests for the {@link DataUrlLoader} class.
  */
@@ -33,6 +31,7 @@
 public class DataUrlLoaderTest {
 
   // A valid base64-encoded PNG (a small "Google" logo).
+  @SuppressWarnings("SpellCheckingInspection")
   private static final String VALID_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAALCA"
       + "YAAAAeEY8BAAADFElEQVR42mNgAAK5ig+CiiUfSmUL3mVL5r7PE8t5M1U06027eMYLMQZKQUMDE8eyxGrOJYmdDKtC"
       + "mTHkFfO/iCsUfTykUPFeASH6n1Es+3WjSM5rKQYqANbFcTmsC2OXYpWUKXw/R67ofQEhQ+5FecnfDnYxPJNmzAp35n"
@@ -51,13 +50,13 @@
   private static final String INVALID_URL_WRONG_SCHEME1 = "test";
   private static final String INVALID_URL_WRONG_SCHEME2 = "http://google.com";
   private static final String INVALID_URL_WRONG_SCHEME3 = "data:text";
-  private static final String INVALID_URL_MISSING_COMMA = "data:image/png;base64=NOTBASE64";
+  private static final String INVALID_URL_MISSING_COMMA = "data:image/png;base64=NOT_BASE64";
   private static final String INVALID_URL_WRONG_ENCODING = "data:image/png;base32,";
 
   @Mock
   private MultiModelLoaderFactory multiFactory;
-  private DataUrlLoader<Object> dataUrlLoader;
-  private DataFetcher<Object> fetcher;
+  private DataUrlLoader<InputStream> dataUrlLoader;
+  private DataFetcher<InputStream> fetcher;
   private Options options;
 
   @Before
@@ -65,7 +64,7 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
     DataUrlLoader.StreamFactory factory = new DataUrlLoader.StreamFactory();
     options = new Options();
-    dataUrlLoader = (DataUrlLoader) factory.build(RuntimeEnvironment.application, multiFactory);
+    dataUrlLoader = (DataUrlLoader<InputStream>) factory.build(multiFactory);
     fetcher = dataUrlLoader.buildLoadData(VALID_PNG, -1, -1, options).fetcher;
 
   }
@@ -89,7 +88,7 @@ public void testDecode() throws IOException {
     CallBack callback = new CallBack();
     fetcher.loadData(Priority.HIGH, callback);
     byte[] result = new byte[((ByteArrayInputStream) callback.data).available()];
-    ((ByteArrayInputStream) callback.data).read(result);
+    assertEquals(result.length, ((ByteArrayInputStream) callback.data).read(result));
     assertTrue(Arrays.equals(result, expected));
     assertNull(callback.exception);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java b/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
index 7593eaccb..2548b0e59 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java
@@ -4,15 +4,13 @@
 import static org.mockito.Mockito.mock;
 
 import com.google.common.testing.EqualsTester;
-
+import java.net.MalformedURLException;
+import java.net.URL;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.net.MalformedURLException;
-import java.net.URL;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GlideUrlTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
index 3b65bc59a..907acb6ae 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -4,12 +4,10 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import com.google.common.testing.EqualsTester;
-
 import android.support.annotation.Nullable;
-
 import com.bumptech.glide.load.model.LazyHeaders.Builder;
-
+import com.google.common.testing.EqualsTester;
+import java.util.Map;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -17,8 +15,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.Map;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LazyHeadersTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java b/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
index 0d323dfbb..041f67992 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/ModelCacheTest.java
@@ -3,7 +3,6 @@
 import static org.junit.Assert.assertEquals;
 
 import com.google.common.testing.EqualsTester;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
index 3664fcce2..b6acd775c 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -1,18 +1,17 @@
 package com.bumptech.glide.load.model;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
-
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
+import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
-
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -22,12 +21,8 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class MultiModelLoaderFactoryTest {
@@ -48,10 +43,10 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     exceptionListPool = FactoryPools.threadSafeList();
 
-    multiFactory = new MultiModelLoaderFactory(RuntimeEnvironment.application, exceptionListPool,
-            multiModelLoaderFactory);
-    when(firstFactory.build(anyContext(), eq(multiFactory))).thenReturn(firstModelLoader);
-    when(secondFactory.build(anyContext(), eq(multiFactory))).thenReturn(secondModelLoader);
+    multiFactory = new MultiModelLoaderFactory(exceptionListPool,
+        multiModelLoaderFactory);
+    when(firstFactory.build(eq(multiFactory))).thenReturn(firstModelLoader);
+    when(secondFactory.build(eq(multiFactory))).thenReturn(secondModelLoader);
   }
 
   @Test
@@ -102,11 +97,10 @@ public void testReplace_addsModelLoaderForModelAndDataClasses() {
     assertThat(modelLoader).isEqualTo(firstModelLoader);
   }
 
-  @SuppressWarnings("unchecked")
   @Test
   public void testReplace_returnsPreviouslyRegisteredFactories_withModelAndDataClasses() {
-    ModelLoaderFactory<String, String> firstOtherFactory = mock(ModelLoaderFactory.class);
-    ModelLoaderFactory<String, String> secondOtherFactory = mock(ModelLoaderFactory.class);
+    ModelLoaderFactory<String, String> firstOtherFactory = mockFactory();
+    ModelLoaderFactory<String, String> secondOtherFactory = mockFactory();
     multiFactory.append(String.class, String.class, firstOtherFactory);
     multiFactory.append(String.class, String.class, secondOtherFactory);
 
@@ -126,10 +120,9 @@ public void testReplace_removesPreviouslyRegisteredFactories_withModelAndDataCla
     assertThat(modelLoaders).containsExactly(firstModelLoader);
   }
 
-  @SuppressWarnings("unchecked")
   @Test
   public void testRemove_returnsPreviouslyRegisteredFactories_withModelAndDataClasses() {
-    ModelLoaderFactory<String, String> other = mock(ModelLoaderFactory.class);
+    ModelLoaderFactory<String, String> other = mockFactory();
     multiFactory.append(String.class, String.class, other);
     multiFactory.append(String.class, String.class, firstFactory);
 
@@ -271,16 +264,15 @@ public void testBuild_respectsPrependOrder() {
     assertThat(modelLoaders).containsExactly(third, second, first).inOrder();
   }
 
-  @SuppressWarnings("unchecked")
   private <X, Y> List<ModelLoader<X, Y>> buildModelLoaders(Class<X> modelClass,
       Class<Y> dataClass) {
-    ArgumentCaptor<List> captor = ArgumentCaptor.forClass(List.class);
+    ArgumentCaptor<List<ModelLoader<X, Y>>> captor = Util.cast(ArgumentCaptor.forClass(List.class));
     multiFactory.build(modelClass, dataClass);
     verify(multiModelLoaderFactory).build(captor.capture(), eq(exceptionListPool));
 
-    List<ModelLoader> captured = captor.getValue();
+    List<ModelLoader<X, Y>> captured = captor.getValue();
     List<ModelLoader<X, Y>> result = new ArrayList<>(captured.size());
-    for (ModelLoader modelLoader : captured) {
+    for (ModelLoader<X, Y> modelLoader : captured) {
       result.add(modelLoader);
     }
     return result;
@@ -294,12 +286,11 @@ public void testBuild_respectsPrependOrder() {
     return registerFactoryFor(modelClass, dataClass, false /*append*/);
   }
 
-  @SuppressWarnings("unchecked")
-  private <X, Y> ModelLoader<X, Y> registerFactoryFor(Class<X> modelClass, Class<Y> dataClass,
-      boolean append) {
-    ModelLoaderFactory<X, Y> factory = mock(ModelLoaderFactory.class);
-    ModelLoader<X, Y> loader = mock(ModelLoader.class);
-    when(factory.build(anyContext(), eq(multiFactory))).thenReturn(loader);
+  private <X, Y> ModelLoader<X, Y> registerFactoryFor(
+      Class<X> modelClass, Class<Y> dataClass, boolean append) {
+    ModelLoaderFactory<X, Y> factory = mockFactory();
+    @SuppressWarnings("unchecked") ModelLoader<X, Y> loader = mock(ModelLoader.class);
+    when(factory.build(eq(multiFactory))).thenReturn(loader);
     if (append) {
       multiFactory.append(modelClass, dataClass, factory);
     } else {
@@ -308,8 +299,9 @@ public void testBuild_respectsPrependOrder() {
     return loader;
   }
 
-  private static Context anyContext() {
-    return any(Context.class);
+  @SuppressWarnings("unchecked")
+  private static <X, Y> ModelLoaderFactory<X, Y> mockFactory() {
+    return mock(ModelLoaderFactory.class);
   }
 }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
index 492e029dc..a5038c23a 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -11,11 +11,9 @@
 import static org.mockito.Mockito.when;
 
 import android.net.Uri;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -44,7 +42,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     options = new Options();
 
-    loader = new ResourceLoader<>(RuntimeEnvironment.application, uriLoader);
+    loader = new ResourceLoader<>(RuntimeEnvironment.application.getResources(), uriLoader);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
index b2ca67086..3eecb3718 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/StreamEncoderTest.java
@@ -5,7 +5,9 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -14,10 +16,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamEncoderTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
index d8cd64909..42bc40545 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/StringLoaderTest.java
@@ -9,12 +9,12 @@
 import static org.mockito.Mockito.when;
 
 import android.net.Uri;
-
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.tests.Util;
-
+import java.io.File;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,9 +24,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-
 /**
  * Tests for the {@link com.bumptech.glide.load.model.StringLoader} class.
  */
diff --git a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
index 47fcd5457..846ed783c 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -2,28 +2,22 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-
+import java.io.File;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.File;
-import java.io.IOException;
-
 /**
  * Tests for the {@link UriLoader} class.
  */
@@ -43,13 +37,13 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
 
     options = new Options();
-    loader = new UriLoader<>(RuntimeEnvironment.application, factory);
+    loader = new UriLoader<>(factory);
   }
 
   @Test
   public void testHandlesFileUris() throws IOException {
     Uri fileUri = Uri.fromFile(new File("f"));
-    when(factory.build(anyContext(), eq(fileUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(fileUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(fileUri));
     assertEquals(localUriFetcher,
@@ -59,7 +53,7 @@ public void testHandlesFileUris() throws IOException {
   @Test
   public void testHandlesResourceUris() throws IOException {
     Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-    when(factory.build(anyContext(), eq(resourceUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(resourceUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(resourceUri));
     assertEquals(localUriFetcher,
@@ -69,14 +63,10 @@ public void testHandlesResourceUris() throws IOException {
   @Test
   public void testHandlesContentUris() {
     Uri contentUri = Uri.parse("content://com.bumptech.glide");
-    when(factory.build(anyContext(), eq(contentUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(contentUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(contentUri));
     assertEquals(localUriFetcher, loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE,
         options).fetcher);
   }
-
-  private static Context anyContext() {
-    return any(Context.class);
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
index 16d54a573..0c87d5f1b 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java
@@ -15,7 +15,7 @@
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
 import com.bumptech.glide.load.model.ModelLoader;
-
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -26,8 +26,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BaseGlideUrlLoaderTest {
@@ -101,9 +99,9 @@ public void testAddsNewUrlToCacheIfNotPresentInCache() {
     int width = 400;
     int height = 500;
 
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         GlideUrl glideUrl = (GlideUrl) invocationOnMock.getArguments()[3];
         assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());
         return null;
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
index 35dc69180..92efc86ce 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
@@ -7,15 +7,15 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
-
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.InputStream;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
-@RunWith(JUnit4.class)
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
 public class HttpGlideUrlLoaderTest {
   private HttpGlideUrlLoader loader;
   private GlideUrl model;
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
index 369696786..92dae6dbb 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpUriLoaderTest.java
@@ -5,11 +5,11 @@
 import static org.mockito.Mockito.verify;
 
 import android.net.Uri;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
-
+import java.io.InputStream;
+import java.net.MalformedURLException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -18,9 +18,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.InputStream;
-import java.net.MalformedURLException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class HttpUriLoaderTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
index a20a7b2db..78b851f22 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/SimpleResourceTest.java
@@ -10,12 +10,12 @@
 @RunWith(JUnit4.class)
 public class SimpleResourceTest {
   private Anything object;
-  private SimpleResource resource;
+  private SimpleResource<?> resource;
 
   @Before
   public void setUp() {
     object = new Anything();
-    resource = new SimpleResource(object);
+    resource = new SimpleResource<>(object);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
index ce38270a9..d5dc77761 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -1,37 +1,46 @@
 package com.bumptech.glide.load.resource;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 
+import android.app.Application;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
+import org.robolectric.RuntimeEnvironment;
 
 @RunWith(JUnit4.class)
 public class UnitTransformationTest {
 
+  private Application app;
+
+  @Before
+  public void setUp() {
+    app = RuntimeEnvironment.application;
+  }
+
   @Test
   public void testReturnsGivenResource() {
-    Resource resource = mock(Resource.class);
-    UnitTransformation transformation = UnitTransformation.get();
-    assertEquals(resource, transformation.transform(resource, 10, 10));
+    Resource<Object> resource = mockResource();
+    UnitTransformation<Object> transformation = UnitTransformation.get();
+    assertEquals(resource, transformation.transform(app, resource, 10, 10));
   }
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
     KeyAssertions.assertSame(UnitTransformation.get(), UnitTransformation.get());
 
-    Transformation<Object> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Object> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
     KeyAssertions.assertDifferent(UnitTransformation.get(), other);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
index 15d6e505b..c65b03707 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java
@@ -8,9 +8,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
index 78ba2efc9..b5fa17830 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.bumptech.glide.tests.Util.anyContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
@@ -9,15 +10,19 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,9 +35,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapDrawableTransformationTest {
@@ -44,32 +46,41 @@
 
   private BitmapDrawableTransformation transformation;
   private Bitmap bitmapToTransform;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
+    context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
     when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);
     when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);
-    transformation = new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool,
-        wrapped);
+    transformation = new BitmapDrawableTransformation(wrapped);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsOriginalResourceIfTransformationDoesNotTransform() {
     int outWidth = 123;
     int outHeight = 456;
-    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight)))
-        .thenAnswer(new Answer<Object>() {
+    when(wrapped.transform(
+        anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
+        .thenAnswer(new Answer<Resource<Bitmap>>() {
+          @SuppressWarnings("unchecked")
           @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            return invocation.getArguments()[0];
+          public Resource<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
+            return (Resource<Bitmap>) invocation.getArguments()[1];
           }
         });
 
-    Resource<BitmapDrawable> transformed = transformation.transform(drawableResourceToTransform,
-        outWidth, outHeight);
+    Resource<BitmapDrawable> transformed =
+        transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
 
     assertThat(transformed).isEqualTo(drawableResourceToTransform);
   }
@@ -80,13 +91,13 @@ public void testReturnsNewResourceIfTransformationDoesTransform() {
     int outHeight = 555;
 
     Bitmap transformedBitmap = Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.RGB_565);
-    Resource<Bitmap> transformedBitmapResource = mock(Resource.class);
+    Resource<Bitmap> transformedBitmapResource = Util.mockResource();
     when(transformedBitmapResource.get()).thenReturn(transformedBitmap);
-    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight)))
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
         .thenReturn(transformedBitmapResource);
 
     Resource<BitmapDrawable> transformed =
-        transformation.transform(drawableResourceToTransform, outWidth, outHeight);
+        transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
 
     assertThat(transformed.get().getBitmap()).isEqualTo(transformedBitmap);
   }
@@ -95,16 +106,16 @@ public void testReturnsNewResourceIfTransformationDoesTransform() {
   public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
     int outWidth = 332;
     int outHeight = 111;
-    Resource<Bitmap> transformed = mock(Resource.class);
+    Resource<Bitmap> transformed = Util.mockResource();
     when(transformed.get())
         .thenReturn(Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.ARGB_8888));
-    when(wrapped.transform(any(Resource.class), anyInt(), anyInt()))
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), anyInt(), anyInt()))
         .thenReturn(transformed);
 
-    transformation.transform(drawableResourceToTransform, outWidth, outHeight);
-    ArgumentCaptor<Resource> captor = ArgumentCaptor.forClass(Resource.class);
+    transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
+    ArgumentCaptor<Resource<Bitmap>> captor = Util.cast(ArgumentCaptor.forClass(Resource.class));
 
-    verify(wrapped).transform(captor.capture(), eq(outWidth), eq(outHeight));
+    verify(wrapped).transform(anyContext(), captor.capture(), eq(outWidth), eq(outHeight));
 
     assertThat(captor.getValue().get()).isEqualTo(bitmapToTransform);
   }
@@ -113,13 +124,11 @@ public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("wrapped")).when(wrapped)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(transformation,
-        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, wrapped));
+    KeyAssertions.assertSame(transformation, new BitmapDrawableTransformation(wrapped));
 
-    Transformation<Bitmap> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation,
-        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, other));
+    KeyAssertions.assertDifferent(transformation, new BitmapDrawableTransformation(other));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 60e3e3db7..876a2bdef 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -1,18 +1,20 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-
+import android.os.Build;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.util.ByteBufferUtil;
-
+import java.io.File;
+import java.io.IOException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -21,16 +23,9 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-import java.io.File;
-import java.io.IOException;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = {
-    BitmapEncoderTest.AlphaShadowBitmap.class })
+@Config(manifest = Config.NONE, sdk = 18)
 public class BitmapEncoderTest {
   private EncoderHarness harness;
 
@@ -62,6 +57,7 @@ public void testBitmapIsEncodedWithGivenQuality() throws IOException {
   }
 
   @Test
+  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   public void testEncoderObeysNonNullCompressFormat() throws IOException {
     Bitmap.CompressFormat format = Bitmap.CompressFormat.WEBP;
     harness.setFormat(format);
@@ -107,9 +103,8 @@ private static void assertContains(String string, String expected) {
     assertThat(string).contains(expected);
   }
 
-  @SuppressWarnings("unchecked")
   private static class EncoderHarness {
-    Resource<Bitmap> resource = mock(Resource.class);
+    Resource<Bitmap> resource = mockResource();
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     Options options = new Options();
     File file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
@@ -137,21 +132,4 @@ public void tearDown() {
       file.delete();
     }
   }
-
-  @Implements(Bitmap.class)
-  public static class AlphaShadowBitmap extends ShadowBitmap {
-    private boolean hasAlpha;
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
index b6d8a8b43..cb567b21f 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java
@@ -7,10 +7,8 @@
 
 import android.graphics.Bitmap;
 import android.os.Build;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
index e53f0180a..d7d22f0c3 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -3,41 +3,52 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.target.Target;
-
+import com.bumptech.glide.tests.Util;
+import java.security.MessageDigest;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class BitmapTransformationTest {
 
   @Mock
   private BitmapPool bitmapPool;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceWhenBitmapNotTransformed() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
@@ -49,13 +60,13 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
     };
 
     Resource<Bitmap> resource = mockResource(100, 100);
-    assertEquals(resource, transformation.transform(resource, 1, 1));
+    assertEquals(resource, transformation.transform(context, resource, 1, 1));
   }
 
   @Test
   public void testReturnsNewResourceWhenBitmapTransformed() {
     final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
@@ -67,7 +78,7 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int
     };
 
     Resource<Bitmap> resource = mockResource(1, 2);
-    assertNotSame(resource, transformation.transform(resource, 100, 100));
+    assertNotSame(resource, transformation.transform(context, resource, 100, 100));
   }
 
   @Test
@@ -75,7 +86,7 @@ public void testPassesGivenArgumentsToTransform() {
     final int expectedWidth = 13;
     final int expectedHeight = 148;
     final Resource<Bitmap> resource = mockResource(223, 4123);
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
@@ -90,12 +101,12 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
       }
     };
 
-    transformation.transform(resource, expectedWidth, expectedHeight);
+    transformation.transform(context, resource, expectedWidth, expectedHeight);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidWidth() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
@@ -106,12 +117,12 @@ protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTra
         return null;
       }
     };
-    transformation.transform(mock(Resource.class), -1, 100);
+    transformation.transform(context, mockResource(1, 1), -1, 100);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidHeight() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
@@ -123,12 +134,12 @@ protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTra
       }
 
     };
-    transformation.transform(mock(Resource.class), 100, -1);
+    transformation.transform(context, mockResource(1, 1), 100, -1);
   }
 
   @Test
   public void testReturnsNullIfTransformReturnsNull() {
-    BitmapTransformation transform = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transform = new BitmapTransformation() {
 
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) {  }
@@ -141,7 +152,7 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
     };
 
     Resource<Bitmap> resource = mockResource(100, 100);
-    assertNull(transform.transform(resource, 100, 100));
+    assertNull(transform.transform(context, resource, 100, 100));
   }
 
   @Test
@@ -150,7 +161,7 @@ public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {
 
     int expectedWidth = 200;
     Resource<Bitmap> resource = mockResource(expectedWidth, 300);
-    transform.transform(resource, Target.SIZE_ORIGINAL, 500);
+    transform.transform(context, resource, Target.SIZE_ORIGINAL, 500);
 
     assertEquals(expectedWidth, transform.givenWidth);
   }
@@ -161,15 +172,14 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
 
     int expectedHeight = 500;
     Resource<Bitmap> resource = mockResource(123, expectedHeight);
-    transform.transform(resource, 444, expectedHeight);
+    transform.transform(context, resource, 444, expectedHeight);
 
     assertEquals(expectedHeight, transform.givenHeight);
   }
 
-  @SuppressWarnings("unchecked")
   private Resource<Bitmap> mockResource(int width, int height) {
     Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-    Resource<Bitmap> resource = mock(Resource.class);
+    Resource<Bitmap> resource = Util.mockResource();
     when(resource.get()).thenReturn(bitmap);
     return resource;
   }
@@ -178,10 +188,6 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
     int givenWidth;
     int givenHeight;
 
-    public SizeTrackingTransform() {
-      super(bitmapPool);
-    }
-
     @Override
     protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
         int outHeight) {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index 53359e2f7..a421660e0 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -11,26 +11,28 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class CenterCropTest {
@@ -42,6 +44,7 @@
   private int bitmapWidth;
   private int bitmapHeight;
   private Bitmap bitmap;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -53,8 +56,15 @@ public void setUp() {
 
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
+    context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+
+    centerCrop = new CenterCrop();
+  }
 
-    centerCrop = new CenterCrop(pool);
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
@@ -62,7 +72,7 @@ public void testDoesNotPutNullBitmapAcquiredFromPool() {
     reset(pool);
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class))).thenReturn(null);
 
-    centerCrop.transform(resource, 100, 100);
+    centerCrop.transform(context, resource, 100, 100);
 
     verify(pool, never()).put(any(Bitmap.class));
   }
@@ -70,21 +80,21 @@ public void testDoesNotPutNullBitmapAcquiredFromPool() {
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-        centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+        centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+    centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testDoesNotRecycleGivenResource() {
-    centerCrop.transform(resource, 50, 50);
+    centerCrop.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
@@ -93,7 +103,7 @@ public void testDoesNotRecycleGivenResource() {
   public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
     Shadows.shadowOf(bitmap).setConfig(null);
 
-    centerCrop.transform(resource, 10, 10);
+    centerCrop.transform(context, resource, 10, 10);
 
     verify(pool).get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888));
     verify(pool, never()).get(anyInt(), anyInt(), (Bitmap.Config) isNull());
@@ -110,7 +120,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsLargerThanTarge
       when(resource.get()).thenReturn(toTransform);
 
       Resource<Bitmap> result =
-          centerCrop.transform(resource, expectedWidth, expectedHeight);
+          centerCrop.transform(context, resource, expectedWidth, expectedHeight);
       Bitmap transformed = result.get();
       assertEquals(expectedWidth, transformed.getWidth());
       assertEquals(expectedHeight, transformed.getHeight());
@@ -128,7 +138,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
       when(resource.get()).thenReturn(toTransform);
 
       Resource<Bitmap> result =
-          centerCrop.transform(resource, expectedWidth, expectedHeight);
+          centerCrop.transform(context, resource, expectedWidth, expectedHeight);
       Bitmap transformed = result.get();
       assertEquals(expectedWidth, transformed.getWidth());
       assertEquals(expectedHeight, transformed.getHeight());
@@ -137,7 +147,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerCrop, new CenterCrop(pool));
+    KeyAssertions.assertSame(centerCrop, new CenterCrop());
 
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
index 3121e7701..ebb4129a8 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -8,42 +8,44 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Paint;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowCanvas;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { CenterInsideTest.DrawNothingCanvas.class })
 public class CenterInsideTest {
 
   @Mock Resource<Bitmap> resource;
   @Mock Transformation<Bitmap> transformation;
-  private BitmapPool pool;
   private CenterInside centerInside;
   private int bitmapWidth;
   private int bitmapHeight;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -53,15 +55,22 @@ public void setUp() {
     Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
     when(resource.get()).thenReturn(bitmap);
 
-    pool = new BitmapPoolAdapter();
+    context = RuntimeEnvironment.application;
+    BitmapPool pool = new BitmapPoolAdapter();
+    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+
+    centerInside = new CenterInside();
+  }
 
-    centerInside = new CenterInside(pool);
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-            centerInside.transform(resource, bitmapWidth, bitmapHeight);
+            centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
@@ -69,7 +78,7 @@ public void testReturnsGivenResourceIfMatchesSizeExactly() {
   @Test
   public void testReturnsGivenResourceIfSmallerThanTarget() {
     Resource<Bitmap> result =
-        centerInside.transform(resource, 150, 150);
+        centerInside.transform(context, resource, 150, 150);
 
     assertEquals(resource, result);
   }
@@ -77,7 +86,7 @@ public void testReturnsGivenResourceIfSmallerThanTarget() {
   @Test
   public void testReturnsNewResourceIfLargerThanTarget() {
     Resource<Bitmap> result =
-        centerInside.transform(resource, 50, 50);
+        centerInside.transform(context, resource, 50, 50);
 
     assertNotEquals(resource, result);
   }
@@ -85,21 +94,21 @@ public void testReturnsNewResourceIfLargerThanTarget() {
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    centerInside.transform(resource, bitmapWidth, bitmapHeight);
+    centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testDoesNotRecycleGivenResource() {
-    centerInside.transform(resource, 50, 50);
+    centerInside.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerInside, new CenterInside(pool));
+    KeyAssertions.assertSame(centerInside, new CenterInside());
 
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
index 6a629a101..740472103 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -5,16 +5,17 @@
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.Rect;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
-
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -36,7 +37,14 @@ public void setup() {
     MockitoAnnotations.initMocks(this);
     when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
-    circleCrop = new CircleCrop(RuntimeEnvironment.application);
+    Context context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    circleCrop = new CircleCrop();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
@@ -88,7 +96,6 @@ private void assertSamePixels(Bitmap expected, Bitmap actual) {
     }
   }
 
-  @TargetApi(12)
   private Bitmap createBitmapWithRedCircle(int width, int height) {
     int minEdge = Math.min(width, height);
     float radius = minEdge / 2f;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
new file mode 100644
index 000000000..40b9bfb7a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
@@ -0,0 +1,402 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.testutil.TestResourceUtil;
+import java.io.ByteArrayInputStream;
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.Util;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DefaultImageHeaderParserTest {
+
+  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
+      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
+          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
+
+  private ArrayPool byteArrayPool;
+
+  @Before
+  public void setUp() {
+    byteArrayPool = new LruArrayPool();
+  }
+
+  @Test
+  public void testCanParsePngType() throws IOException {
+    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
+    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParsePngWithAlpha() throws IOException {
+    for (int i = 3; i <= 6; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParsePngWithoutAlpha() throws IOException {
+    for (int i = 0; i < 3; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParseJpegType() throws IOException {
+    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseGifType() throws IOException {
+    byte[] data = new byte[] { 'G', 'I', 'F' };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
+        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithoutAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
+        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
+    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #286.
+  @Test
+  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
+    byte[] data =
+        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(-1, parser.getOrientation(is, byteArrayPool));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(-1, parser.getOrientation(byteBuffer, byteArrayPool));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownForEmptyData() throws IOException {
+    runTest(new byte[0], new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialReads() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialReadInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialSkips() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialSkipInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  @Test
+  public void testHandlesSometimesZeroSkips() throws IOException {
+    InputStream is = new ByteArrayInputStream(
+        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
+    DefaultImageHeaderParser parser =
+        new DefaultImageHeaderParser();
+    assertEquals(ImageType.PNG, parser.getType(new SometimesZeroSkipInputStream(is)));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        (byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withNonExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE)
+        (byte) 0xE5,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleButLessThanLength_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity());
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleBetweenLengthAndExpected_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity() + 2 + 1);
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  private static ByteBuffer getExifMagicNumber() {
+    ByteBuffer jpegHeaderBytes = ByteBuffer.allocate(2);
+    jpegHeaderBytes.putShort((short) DefaultImageHeaderParser.EXIF_MAGIC_NUMBER);
+    jpegHeaderBytes.position(0);
+    return jpegHeaderBytes;
+  }
+
+  private interface ParserTestCase {
+    void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+        throws IOException;
+    void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+        throws IOException;
+  }
+
+  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
+    InputStream is = new ByteArrayInputStream(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    test.run(parser, is, new LruArrayPool());
+
+    ByteBuffer buffer = ByteBuffer.wrap(data);
+    parser = new DefaultImageHeaderParser();
+    test.run(parser, buffer, new LruArrayPool());
+  }
+
+  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
+    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
+    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
+    result[result.length - 1] = (byte) bitDepth;
+    return result;
+  }
+
+  private static class SometimesZeroSkipInputStream extends FilterInputStream {
+    boolean returnZeroFlag = true;
+
+    protected SometimesZeroSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+      final long result;
+      if (returnZeroFlag) {
+        result = 0;
+      } else {
+        result = super.skip(byteCount);
+      }
+      returnZeroFlag = !returnZeroFlag;
+      return result;
+    }
+  }
+
+  private static class PartialSkipInputStream extends FilterInputStream {
+
+    protected PartialSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+        long toActuallySkip = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallySkip = 1;
+        }
+        return super.skip(toActuallySkip);
+    }
+  }
+
+  private static class PartialReadInputStream extends FilterInputStream {
+
+    protected PartialReadInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+        int toActuallyRead = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallyRead = 1;
+        }
+        return super.read(buffer, byteOffset, toActuallyRead);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
index 039dfec05..4cbfc7e49 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
@@ -8,15 +8,24 @@
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.os.Build;
 import android.util.DisplayMetrics;
-
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.DownsamplerTest.AllocationSizeBitmap;
-
+import com.bumptech.glide.tests.Util;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,12 +39,6 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowBitmap;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 19, shadows = AllocationSizeBitmap.class)
 public class DownsamplerTest {
@@ -43,6 +46,7 @@
   @Mock private ArrayPool byteArrayPool;
   private Downsampler downsampler;
   private Options options;
+  private int initialSdkVersion;
 
   @Before
   public void setUp() throws Exception {
@@ -52,7 +56,18 @@ public void setUp() throws Exception {
         RuntimeEnvironment.application.getResources().getDisplayMetrics();
     when(byteArrayPool.get(anyInt(), Matchers.eq(byte[].class)))
         .thenReturn(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
-    downsampler = new Downsampler(displayMetrics, bitmapPool, byteArrayPool);
+
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
+    downsampler = new Downsampler(parsers, displayMetrics, bitmapPool, byteArrayPool);
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
   }
 
   @Test
@@ -153,9 +168,34 @@ public void testCalculateScaling_withNone() {
     runScaleTest(87, 78, 100, 100, strategy, 87, 78);
   }
 
+  // BitmapFactory does not support downsampling wbmp files on platforms <=M. See b/27305903.
+  @Test
+  public void testCalculateScaling_withWbmp() {
+    Util.setSdkVersionInt(23);
+    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
+    BitmapFactory.Options options = new BitmapFactory.Options();
+
+    options.outMimeType = "image/vnd.wap.wbmp";
+    runScaleTest(100, 100, 100, 100, strategy, 100, 100, options);
+    runScaleTest(200, 200, 100, 100, strategy, 100, 100, options);
+    runScaleTest(400, 400, 100, 100, strategy, 100, 100, options);
+    runScaleTest(300, 300, 100, 100, strategy, 100, 100, options);
+    runScaleTest(799, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(800, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(801, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(100, 800, 100, 100, strategy, 13, 100, options);
+    runScaleTest(87, 78, 100, 100, strategy, 100, 90, options);
+  }
+
   private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
       int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight) {
-    BitmapFactory.Options options = new BitmapFactory.Options();
+    runScaleTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy, expectedWidth,
+        expectedHeight, new BitmapFactory.Options());
+  }
+
+  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
+      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight,
+      BitmapFactory.Options options) {
     Downsampler.calculateScaling(strategy, 0, sourceWidth, sourceHeight, targetWidth, targetHeight,
         options);
     assertSize(sourceWidth, sourceHeight, expectedWidth, expectedHeight, options);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
index a140022d8..65b073205 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -7,42 +7,44 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Paint;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowCanvas;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { FitCenterTest.DrawNothingCanvas.class })
 public class FitCenterTest {
 
   @Mock Resource<Bitmap> resource;
   @Mock Transformation<Bitmap> transformation;
-  private BitmapPool pool;
   private FitCenter fitCenter;
   private int bitmapWidth;
   private int bitmapHeight;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -52,36 +54,44 @@ public void setUp() {
     Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
     when(resource.get()).thenReturn(bitmap);
 
-    pool = new BitmapPoolAdapter();
+    BitmapPool pool = new BitmapPoolAdapter();
+    context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
+
+
+    fitCenter = new FitCenter();
+  }
 
-    fitCenter = new FitCenter(pool);
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-        fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+        fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+    fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testDoesNotRecycleGivenResource() {
-    fitCenter.transform(resource, 50, 50);
+    fitCenter.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(fitCenter, new FitCenter(pool));
+    KeyAssertions.assertSame(fitCenter, new FitCenter());
 
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
deleted file mode 100644
index ff4c32ff4..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ /dev/null
@@ -1,256 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-import com.bumptech.glide.testutil.TestResourceUtil;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.util.Util;
-
-import java.io.ByteArrayInputStream;
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ImageHeaderParserTest {
-
-  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
-      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
-          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
-
-  private ArrayPool byteArrayPool;
-
-  @Before
-  public void setUp() {
-    byteArrayPool = new LruArrayPool();
-  }
-
-  @Test
-  public void testCanParsePngType() throws IOException {
-    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
-    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.PNG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParsePngWithAlpha() throws IOException {
-    for (int i = 3; i <= 6; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG_A, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParsePngWithoutAlpha() throws IOException {
-    for (int i = 0; i < 3; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParseJpegType() throws IOException {
-    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.JPEG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseGifType() throws IOException {
-    byte[] data = new byte[] { 'G', 'I', 'F' };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.GIF, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseWebpWithAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
-        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.WEBP_A, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseWebpWithoutAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
-        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.WEBP, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
-    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #286.
-  @Test
-  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
-    byte[] data =
-        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(-1, parser.getOrientation());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownForEmptyData() throws IOException {
-    runTest(new byte[0], new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialReads() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialSkips() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  @Test
-  public void testHandlesSometimesZeroSkips() throws IOException {
-    InputStream is = new ByteArrayInputStream(
-        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
-    ImageHeaderParser parser =
-        new ImageHeaderParser(new SometimesZeroSkipInputStream(is), byteArrayPool);
-    assertEquals(ImageType.PNG, parser.getType());
-  }
-
-  private interface ParserTestCase {
-    void run(ImageHeaderParser parser) throws IOException;
-  }
-
-  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
-    InputStream is = new ByteArrayInputStream(data);
-    ImageHeaderParser parser = new ImageHeaderParser(is, new LruArrayPool());
-    test.run(parser);
-
-    ByteBuffer buffer = ByteBuffer.wrap(data);
-    parser = new ImageHeaderParser(buffer, new LruArrayPool());
-    test.run(parser);
-  }
-
-  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
-    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
-    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
-    result[result.length - 1] = (byte) bitDepth;
-    return result;
-  }
-
-  private static class SometimesZeroSkipInputStream extends FilterInputStream {
-    boolean returnZeroFlag = true;
-
-    protected SometimesZeroSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-      final long result;
-      if (returnZeroFlag) {
-        result = 0;
-      } else {
-        result = super.skip(byteCount);
-      }
-      returnZeroFlag = !returnZeroFlag;
-      return result;
-    }
-  }
-
-  private static class PartialSkipInputStream extends FilterInputStream {
-
-    protected PartialSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-        long toActuallySkip = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallySkip = 1;
-        }
-        return super.skip(toActuallySkip);
-    }
-  }
-
-  private static class PartialReadInputStream extends FilterInputStream {
-
-    protected PartialReadInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
-        int toActuallyRead = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallyRead = 1;
-        }
-        return super.read(buffer, byteOffset, toActuallyRead);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
index f9b3e6452..3260f51ae 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java
@@ -9,18 +9,16 @@
 
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RecyclableBufferedInputStreamTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index 24bd56cad..ae6264663 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -12,18 +12,13 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.google.common.collect.Range;
-
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.Matrix;
 import android.media.ExifInterface;
-import android.os.Build;
-
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.util.Preconditions;
-
+import com.google.common.collect.Range;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -36,7 +31,6 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowBitmap;
 
-@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = {
     TransformationUtilsTest.AlphaShadowBitmap.class })
@@ -356,7 +350,7 @@ public void testRotateImage() {
     assertTrue(toRotate == zero);
 
     Bitmap ninety = TransformationUtils.rotateImage(toRotate, 90);
-    assertTrue(Shadows.shadowOf(ninety).getDescription().contains("rotate=90.0"));
+    assertThat(Shadows.shadowOf(ninety).getDescription()).contains("rotate=90.0");
     assertEquals(toRotate.getWidth(), toRotate.getHeight());
   }
 
@@ -445,8 +439,6 @@ public void testInitializeMatrixSetsRotateOnRotation() {
   @Implements(Bitmap.class)
   public static class AlphaShadowBitmap extends ShadowBitmap {
 
-    private boolean hasAlpha;
-
     @Implementation
     public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       // Robolectric doesn't match the framework behavior with null configs, so we have to do so
@@ -454,15 +446,5 @@ public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       Preconditions.checkNotNull("Config must not be null");
       return ShadowBitmap.createBitmap(width, height, config);
     }
-
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
index b1716d3ac..4b034d2fc 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
@@ -10,11 +10,11 @@
 import android.graphics.Bitmap;
 import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
+import java.io.FileDescriptor;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,9 +23,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.FileDescriptor;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class VideoBitmapDecoderTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
index f95f8bd10..6537c6d43 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java
@@ -9,9 +9,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.drawable.Drawable;
-
 import com.bumptech.glide.load.resource.gif.GifDrawable;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
index 508316e05..b1b5f3130 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/file/FileDecoderTest.java
@@ -4,15 +4,13 @@
 
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-
+import java.io.File;
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-import java.io.IOException;
-
 @RunWith(JUnit4.class)
 public class FileDecoderTest {
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
index 1cfb5408b..6cc0c5775 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/file/FileResourceTest.java
@@ -2,13 +2,12 @@
 
 import static org.junit.Assert.assertEquals;
 
+import java.io.File;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-
 @RunWith(JUnit4.class)
 public class FileResourceTest {
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index 257e50e75..8c78f1de1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -12,11 +12,16 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.tests.GlideShadowLooper;
-
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,9 +32,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class ByteBufferGifDecoderTest {
@@ -58,10 +60,14 @@ public void setUp() {
         eq(gifHeader), isA(ByteBuffer.class), anyInt()))
         .thenReturn(gifDecoder);
 
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
     options = new Options();
     decoder =
         new ByteBufferGifDecoder(
             RuntimeEnvironment.application,
+            parsers,
             bitmapPool,
             new LruArrayPool(ARRAY_POOL_SIZE_BYTES),
             parserPool,
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index d838b7efa..3d764e22d 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -22,14 +22,14 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.gif.GifDrawableTest.BitmapTrackingShadowCanvas;
 import com.bumptech.glide.tests.GlideShadowLooper;
 import com.bumptech.glide.tests.Util;
-
+import java.util.HashSet;
+import java.util.Set;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -41,12 +41,9 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowCanvas;
 
-import java.util.HashSet;
-import java.util.Set;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18,
     shadows = { GlideShadowLooper.class, BitmapTrackingShadowCanvas.class })
@@ -77,7 +74,7 @@ public void setUp() {
     frameWidth = 120;
     frameHeight = 450;
     firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
-    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);
+    drawable = new GifDrawable(frameLoader, bitmapPool, paint);
     when(frameLoader.getWidth()).thenReturn(frameWidth);
     when(frameLoader.getHeight()).thenReturn(frameHeight);
     when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);
@@ -97,14 +94,14 @@ public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
     drawable.draw(canvas);
 
     BitmapTrackingShadowCanvas shadowCanvas =
-        (BitmapTrackingShadowCanvas) ShadowExtractor.extract(canvas);
+        (BitmapTrackingShadowCanvas) Shadow.extract(canvas);
     assertThat(shadowCanvas.getDrawnBitmaps()).containsExactly(firstFrame);
   }
 
   @Test
   public void testDoesDrawCurrentFrameIfOneIsAvailable() {
     Canvas canvas = mock(Canvas.class);
-    Bitmap currentFrame = Bitmap.createBitmap(100123, 123141, Bitmap.Config.ARGB_4444);
+    Bitmap currentFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     when(frameLoader.getCurrentFrame()).thenReturn(currentFrame);
 
     drawable.draw(canvas);
@@ -201,7 +198,7 @@ public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfHasNoCallback()
   }
 
   @Test
-  public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+  public void testStopsWhenCurrentFrameFinishesIfHasNoCallback() {
     drawable.setIsRunning(true);
     drawable.setCallback(null);
     drawable.onFrameReady();
@@ -210,18 +207,7 @@ public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneyc
   }
 
   @Test
-  public void testDoesNotStopWhenCurrentFrameFinishesIfHasNoCallbackAndIsPreHoneycomb() {
-    Util.setSdkVersionInt(10);
-
-    drawable.setIsRunning(true);
-    drawable.setCallback(null);
-    drawable.onFrameReady();
-
-    assertTrue(drawable.isRunning());
-  }
-
-  @Test
-  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallback() {
     drawable.setIsRunning(true);
     drawable.setCallback(null);
     drawable.onFrameReady();
@@ -372,7 +358,7 @@ public void testLoopsASingleTimeIfLoopCountIsSetToOne() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -388,6 +374,7 @@ public void testLoopsForeverIfLoopCountIsSetToLoopForever() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
   }
 
   @Test
@@ -403,7 +390,7 @@ public void testLoopsOnceIfLoopCountIsSetToOneWithThreeFrames() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -419,7 +406,7 @@ public void testLoopsThreeTimesIfLoopCountIsSetToThree() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -432,6 +419,7 @@ public void testCallingStartResetsLoopCounter() {
     drawable.onFrameReady();
     when(frameLoader.getCurrentIndex()).thenReturn(1);
     drawable.onFrameReady();
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     drawable.start();
 
@@ -442,7 +430,7 @@ public void testCallingStartResetsLoopCounter() {
 
     // 4 onFrameReady(), 2 start()
     verify(cb, times(4 + 2)).invalidateDrawable(eq(drawable));
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -456,6 +444,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     drawable.start();
 
     runLoops(initialLoopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     final int newLoopCount = 2;
 
@@ -467,6 +456,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     int numStarts = 2;
     int expectedFrames = (initialLoopCount + newLoopCount) * frameCount + numStarts;
     verify(cb, times(expectedFrames)).invalidateDrawable(eq(drawable));
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test(expected = IllegalArgumentException.class)
@@ -475,7 +465,7 @@ public void testThrowsIfGivenLoopCountLessThanZeroAndNotInfinite() {
   }
 
   @Test
-  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
+  public void testUsesDecoderTotalLoopCountIfLoopCountIsLoopIntrinsic() {
     final int frameCount = 3;
     final int loopCount = 2;
     when(frameLoader.getLoopCount()).thenReturn(loopCount);
@@ -487,8 +477,26 @@ public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
+  @Test
+  public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsForever() {
+    final int frameCount = 3;
+    final int loopCount = 40;
+    when(frameLoader.getLoopCount()).thenReturn(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER);
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
+  }
+
+
   @Test
   public void testDoesNotDrawFrameAfterRecycle() {
     Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
@@ -543,6 +551,7 @@ public void testSetColorFilterSetsColorFilterOnPaint() {
 
   @Test
   public void testReturnsCurrentTransformationInGetFrameTransformation() {
+    @SuppressWarnings("unchecked")
     Transformation<Bitmap> newTransformation = mock(Transformation.class);
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     drawable.setFrameTransformation(newTransformation, bitmap);
@@ -564,6 +573,8 @@ private void runLoops(int loopCount, int frameCount) {
     for (int loop = 0; loop < loopCount; loop++) {
       for (int frame = 0; frame < frameCount; frame++) {
         when(frameLoader.getCurrentIndex()).thenReturn(frame);
+        assertTrue("drawable should be started before calling drawable.onFrameReady()",
+            drawable.isRunning());
         drawable.onFrameReady();
       }
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
index 120ad07a1..f73dc91a5 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static com.bumptech.glide.tests.Util.mockResource;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
@@ -8,44 +10,55 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.content.Context;
 import android.graphics.Bitmap;
-
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
-
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifDrawableTransformationTest {
   @Mock Transformation<Bitmap> wrapped;
   @Mock BitmapPool bitmapPool;
 
-  GifDrawableTransformation transformation;
+  private GifDrawableTransformation transformation;
+  private Context context;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    transformation = new GifDrawableTransformation(wrapped, bitmapPool);
+    context = RuntimeEnvironment.application;
+
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    transformation = new GifDrawableTransformation(wrapped);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
+  @SuppressWarnings("unchecked")
   public void testSetsTransformationAsFrameTransformation() {
-    Resource<GifDrawable> resource = mock(Resource.class);
+    Resource<GifDrawable> resource = mockResource();
     GifDrawable gifDrawable = mock(GifDrawable.class);
     Transformation<Bitmap> unitTransformation = UnitTransformation.get();
     when(gifDrawable.getFrameTransformation()).thenReturn(unitTransformation);
@@ -59,11 +72,12 @@ public void testSetsTransformationAsFrameTransformation() {
     final int width = 123;
     final int height = 456;
     Bitmap expectedBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-    Resource<Bitmap> expectedResource = mock(Resource.class);
+    Resource<Bitmap> expectedResource = mockResource();
     when(expectedResource.get()).thenReturn(expectedBitmap);
-    when(wrapped.transform(isA(Resource.class), anyInt(), anyInt())).thenReturn(expectedResource);
+    when(wrapped.transform(any(Context.class), Util.<Bitmap>anyResource(), anyInt(), anyInt()))
+        .thenReturn(expectedResource);
 
-    transformation.transform(resource, width, height);
+    transformation.transform(context, resource, width, height);
 
     verify(gifDrawable).setFrameTransformation(isA(Transformation.class), eq(expectedBitmap));
   }
@@ -72,11 +86,11 @@ public void testSetsTransformationAsFrameTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("first")).when(wrapped)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped, bitmapPool));
+    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped));
 
-    Transformation<Bitmap> other = mock(Transformation.class);
+    @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other, bitmapPool));
+    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 759a88013..0ad477634 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -13,25 +13,26 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.google.common.testing.EqualsTester;
-
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Message;
-
+import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.DelayTarget;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.FrameCallback;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
-
+import com.google.common.testing.EqualsTester;
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -42,9 +43,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.nio.ByteBuffer;
-import java.util.UUID;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifFrameLoaderTest {
@@ -71,8 +69,29 @@ public void setUp() {
 
     requestBuilder = mock(RequestBuilder.class, new ReturnsSelfAnswer());
 
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder, handler,
-        requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(handler);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @NonNull
+  private GifFrameLoader createGifFrameLoader(Handler handler) {
+    Glide glide = getGlideSingleton();
+    return new GifFrameLoader(
+        glide.getBitmapPool(),
+        requestManager,
+        gifDecoder,
+        handler,
+        requestBuilder,
+        transformation,
+        firstFrame);
+  }
+
+  private static Glide getGlideSingleton() {
+    return Glide.get(RuntimeEnvironment.application);
   }
 
   @SuppressWarnings("unchecked")
@@ -100,7 +119,7 @@ public void testReturnsSizeFromGifDecoderAndCurrentFrame() {
   public void testStartGetsNextFrameIfNotStartedAndWithNoLoadPending() {
     loader.subscribe(callback);
 
-    verify(requestBuilder).into(isA(Target.class));
+    verify(requestBuilder).into(aTarget());
   }
 
   @Test
@@ -109,8 +128,8 @@ public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingL
 
     InOrder order = inOrder(gifDecoder, requestBuilder);
     order.verify(gifDecoder).advance();
-    order.verify(requestBuilder).apply(isA(BaseRequestOptions.class));
-    order.verify(requestBuilder).into(isA(Target.class));
+    order.verify(requestBuilder).apply(isA(RequestOptions.class));
+    order.verify(requestBuilder).into(aTarget());
   }
 
   @Test
@@ -133,14 +152,14 @@ public void testStartDoesNotStartIfAlreadyRunning() {
     loader.subscribe(callback);
     loader.subscribe(mock(FrameCallback.class));
 
-    verify(requestBuilder, times(1)).into(isA(Target.class));
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
   public void testGetNextFrameDoesNotStartLoadIfLoaderIsNotRunning() {
     loader.onFrameReady(mock(DelayTarget.class));
 
-    verify(requestBuilder, never()).into(isA(Target.class));
+    verify(requestBuilder, never()).into(aTarget());
   }
 
   @Test
@@ -149,7 +168,7 @@ public void testGetNextFrameDoesNotStartLoadIfLoadIsInProgress() {
     loader.unsubscribe(callback);
     loader.subscribe(callback);
 
-    verify(requestBuilder, times(1)).into(isA(Target.class));
+    verify(requestBuilder, times(1)).into(aTarget());
   }
 
   @Test
@@ -160,7 +179,7 @@ public void testGetNextFrameDoesStartLoadIfRestartedAndNoLoadIsInProgress() {
     loader.onFrameReady(mock(DelayTarget.class));
     loader.subscribe(callback);
 
-    verify(requestBuilder, times(2)).into(isA(Target.class));
+    verify(requestBuilder, times(2)).into(aTarget());
   }
 
   @Test
@@ -168,14 +187,13 @@ public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
     loader.subscribe(callback);
     loader.onFrameReady(mock(DelayTarget.class));
 
-    verify(requestBuilder, times(2)).into(isA(Target.class));
+    verify(requestBuilder, times(2)).into(aTarget());
   }
 
   @Test
   public void testOnFrameReadyClearsPreviousFrame() {
     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -192,9 +210,8 @@ public void testOnFrameReadyClearsPreviousFrame() {
 
   @Test
   public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
-     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager,
-        gifDecoder, null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null.
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -229,9 +246,8 @@ public void testDelayTargetSetsResourceOnResourceReady() {
 
   @Test
   public void testClearsCompletedLoadOnFrameReadyIfCleared() {
-    // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null;
+    loader = createGifFrameLoader(null);
     loader.clear();
     DelayTarget delayTarget = mock(DelayTarget.class);
     Request request = mock(Request.class);
@@ -262,4 +278,9 @@ public void testFrameSignatureEquality() {
         new GifFrameLoader.FrameSignature(first))
         .addEqualityGroup(new GifFrameLoader.FrameSignature()).testEquals();
   }
+
+  @SuppressWarnings("unchecked")
+  private static Target<Bitmap> aTarget() {
+    return isA(Target.class);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
index 2a4c28460..18c379433 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java
@@ -6,19 +6,16 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
+import java.io.IOException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class GifFrameResourceDecoderTest {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index c87378fe9..f6d4eba4c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -2,10 +2,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,10 +20,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class StreamGifDecoderTest {
@@ -32,7 +34,10 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
-    decoder = new StreamGifDecoder(byteBufferDecoder, new LruArrayPool());
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
+    decoder = new StreamGifDecoder(parsers, byteBufferDecoder, new LruArrayPool());
     options = new Options();
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index 0631bd73f..9d8e2b1b1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -1,14 +1,12 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.engine.Resource;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -55,13 +53,12 @@ public void testBitmapResourceIsRecycled() {
     verify(harness.bitmapResource).recycle();
   }
 
-  @SuppressWarnings("unchecked")
   private static class BitmapBytesTranscoderHarness {
     Bitmap.CompressFormat compressFormat = Bitmap.CompressFormat.JPEG;
     int quality = 100;
     final String description = "TestDescription";
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
-    Resource<Bitmap> bitmapResource = mock(Resource.class);
+    Resource<Bitmap> bitmapResource = mockResource();
 
     public BitmapBytesTranscoderHarness() {
       when(bitmapResource.get()).thenReturn(bitmap);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
index cb975b03f..62689518a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,7 +30,7 @@ public void setUp() {
   @Test
   public void testReturnsBitmapDrawableResourceContainingGivenBitmap() {
     Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    Resource<Bitmap> resource = mock(Resource.class);
+    Resource<Bitmap> resource = mockResource();
     when(resource.get()).thenReturn(expected);
 
     Resource<BitmapDrawable> transcoded = transcoder.transcode(resource);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
index 70e2a185a..1f6d4fd8f 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -1,30 +1,28 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertArrayEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
-
+import java.nio.ByteBuffer;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.nio.ByteBuffer;
-
 @RunWith(JUnit4.class)
 public class GifDrawableBytesTranscoderTest {
   private GifDrawableBytesTranscoder transcoder;
   private GifDrawable gifDrawable;
   private Resource<GifDrawable> resource;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
     gifDrawable = mock(GifDrawable.class);
-    resource = mock(Resource.class);
+    resource = mockResource();
     when(resource.get()).thenReturn(gifDrawable);
     transcoder = new GifDrawableBytesTranscoder();
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
index d3d024977..28db86bbe 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistryTest.java
@@ -4,13 +4,12 @@
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.Mockito.mock;
 
+import java.io.File;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.File;
-
 @RunWith(JUnit4.class)
 public class TranscoderRegistryTest {
   private TranscoderRegistry factories;
@@ -27,7 +26,8 @@ public void testReturnsUnitDecoderIfClassesAreIdentical() {
 
   @Test
   public void testCanRegisterAndRetrieveResourceTranscoder() {
-    ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
+    @SuppressWarnings("unchecked")
+    ResourceTranscoder<File, String> transcoder = mock(ResourceTranscoder.class);
     factories.register(File.class, String.class, transcoder);
 
     assertEquals(transcoder, factories.get(File.class, String.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
index 19a33cfb9..a1d8eb507 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
@@ -1,10 +1,9 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
 
 import com.bumptech.glide.load.engine.Resource;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -14,7 +13,7 @@
 
   @Test
   public void testReturnsTheGivenResource() {
-    Resource resource = mock(Resource.class);
+    Resource<Object> resource = mockResource();
     ResourceTranscoder<Object, Object> unitTranscoder = UnitTranscoder.get();
 
     assertEquals(resource, unitTranscoder.transcode(resource));
diff --git a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
index 44ac8726f..32fa7111b 100644
--- a/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java
@@ -12,7 +12,7 @@
 import android.content.Intent;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
-
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,8 +24,6 @@
 import org.robolectric.shadows.ShadowConnectivityManager;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class DefaultConnectivityMonitorTest {
diff --git a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java b/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
index b1feae1f1..570026f5d 100644
--- a/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
+++ b/library/src/test/java/com/bumptech/glide/manager/Issue117Activity.java
@@ -1,6 +1,10 @@
 package com.bumptech.glide.manager;
 
+import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
+
+import android.annotation.TargetApi;
 import android.content.Context;
+import android.os.Build;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
@@ -11,20 +15,19 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 
 /**
  * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117.
  */
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 class Issue117Activity extends FragmentActivity {
   @Override
   protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     ViewPager viewPager = new ViewPager(this);
     viewPager.setId(View.generateViewId());
-    setContentView(viewPager, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
-        ViewGroup.LayoutParams.MATCH_PARENT));
+    setContentView(viewPager, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
     viewPager.setAdapter(new Issue117Adapter(getSupportFragmentManager()));
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java b/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
index bcc1f9bea..df8bce1ae 100644
--- a/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/LifecycleTest.java
@@ -4,15 +4,14 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LifecycleTest {
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 1d863c384..3e3372e8e 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -9,17 +9,15 @@
 
 import android.app.Activity;
 import android.support.v4.app.FragmentActivity;
-
 import com.bumptech.glide.RequestManager;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
@@ -167,7 +165,7 @@ private void runTest(TestCase testCase) {
 
     ActivityFragmentLifecycle getFragmentLifecycle();
 
-    ActivityController getController();
+    ActivityController<?> getController();
 
     void onLowMemory();
 
@@ -218,7 +216,7 @@ public ActivityFragmentLifecycle getFragmentLifecycle() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return controller;
     }
 
@@ -276,7 +274,7 @@ public ActivityFragmentLifecycle getFragmentLifecycle() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return supportController;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index 0dd3828d3..97884942a 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -9,6 +9,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.ContextWrapper;
@@ -16,12 +17,10 @@
 import android.os.Looper;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
-
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
 import com.bumptech.glide.tests.Util;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -31,8 +30,8 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
@@ -44,7 +43,7 @@
 
   @Before
   public void setUp() {
-    retriever = new RequestManagerRetriever();
+    retriever = new RequestManagerRetriever(null /*factory*/);
 
     harnesses =
         new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };
@@ -205,7 +204,7 @@ public void testThrowsIfFragmentNotAttached() {
     retriever.get(fragment);
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfSupportFragmentNotAttached() {
     Fragment fragment = new Fragment();
     retriever.get(fragment);
@@ -213,14 +212,14 @@ public void testThrowsIfSupportFragmentNotAttached() {
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfActivityDestroyed() {
-    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RetrieverHarness harness = new DefaultRetrieverHarness();
     harness.getController().pause().stop().destroy();
     harness.doGet();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfFragmentActivityDestroyed() {
-    SupportRetrieverHarness harness = new SupportRetrieverHarness();
+    RetrieverHarness harness = new SupportRetrieverHarness();
     harness.getController().pause().stop().destroy();
     harness.doGet();
   }
@@ -232,7 +231,7 @@ public void testThrowsIfGivenNullContext() {
 
   @Test
   public void testChecksIfContextIsFragmentActivity() {
-    SupportRetrieverHarness harness = new SupportRetrieverHarness();
+    RetrieverHarness harness = new SupportRetrieverHarness();
     RequestManager requestManager = harness.doGet();
 
     assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
@@ -240,7 +239,7 @@ public void testChecksIfContextIsFragmentActivity() {
 
   @Test
   public void testChecksIfContextIsActivity() {
-    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RetrieverHarness harness = new DefaultRetrieverHarness();
     RequestManager requestManager = harness.doGet();
 
     assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
@@ -248,9 +247,9 @@ public void testChecksIfContextIsActivity() {
 
   @Test
   public void testHandlesContextWrappersForActivities() {
-    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
+    RetrieverHarness harness = new DefaultRetrieverHarness();
     RequestManager requestManager = harness.doGet();
-    ContextWrapper contextWrapper = new ContextWrapper((Context) harness.getController().get());
+    ContextWrapper contextWrapper = new ContextWrapper(harness.getController().get());
 
     assertEquals(requestManager, retriever.get(contextWrapper));
   }
@@ -306,16 +305,7 @@ public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
   }
 
   @Test
-  public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
-    Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
-    Activity activity = mock(Activity.class);
-    when(activity.getApplicationContext()).thenReturn(RuntimeEnvironment.application);
-    when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());
-
-    assertNotNull(retriever.get(activity));
-  }
-
-  @Test
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -326,19 +316,7 @@ public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
   }
 
   @Test
-  public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
-    Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
-    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
-    android.app.Fragment fragment = new android.app.Fragment();
-
-    activity.getFragmentManager().beginTransaction().add(fragment, "test").commit();
-    android.app.Fragment spyFragment = Mockito.spy(fragment);
-    when(spyFragment.isDetached()).thenThrow(new NoSuchMethodError());
-
-    assertNotNull(retriever.get(spyFragment));
-  }
-
-  @Test
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
     Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
@@ -352,14 +330,13 @@ public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
   }
 
   private interface RetrieverHarness {
+    ActivityController<?> getController();
 
-    public ActivityController getController();
-
-    public RequestManager doGet();
+    RequestManager doGet();
 
-    public boolean hasFragmentWithTag(String tag);
+    boolean hasFragmentWithTag(String tag);
 
-    public void addFragmentWithTag(String tag, RequestManager manager);
+    void addFragmentWithTag(String tag, RequestManager manager);
   }
 
   public class DefaultRetrieverHarness implements RetrieverHarness {
@@ -378,7 +355,7 @@ public DefaultRetrieverHarness() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return controller;
     }
 
@@ -421,7 +398,7 @@ public SupportRetrieverHarness() {
     }
 
     @Override
-    public ActivityController getController() {
+    public ActivityController<?> getController() {
       return controller;
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
index 3ee515868..889cd2ba2 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java
@@ -11,7 +11,6 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.request.Request;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
index ab71f9d20..3c7648274 100644
--- a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
+++ b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -9,10 +9,9 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.os.Bundle;
-
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -21,10 +20,9 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.List;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("deprecation")
 public class ManifestParserTest {
   private static final String MODULE_VALUE = "GlideModule";
 
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index fb73a052b..cc3c11cd0 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -13,9 +13,11 @@
 import static org.mockito.Mockito.verify;
 
 import android.os.Handler;
-
 import com.bumptech.glide.request.target.SizeReadyCallback;
-
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,11 +26,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class RequestFutureTargetTest {
@@ -79,17 +76,17 @@ public void testReturnsTrueFromCancelIfNotYetDone() {
   }
 
   @Test
-  public void testClearsRequestOnMainThreadIfNotYetDoneOnCancel() {
+  public void cancel_withMayInterruptIfRunningTrueAndNotFinishedRequest_clearsFutureOnMainThread() {
     future.cancel(true);
 
     verify(handler).post(eq(future));
   }
 
   @Test
-  public void testClearsOnMainThreadWhenClearCalled() {
+  public void cancel_withInterruptFalseAndNotFinishedRequest_doesNotclearFutureOnMainThread() {
     future.cancel(false);
 
-    verify(handler).post(eq(future));
+    verify(handler, never()).post(eq(future));
   }
 
   @Test
@@ -207,12 +204,20 @@ public void testThrowsExceptionIfGetCalledOnMainThread()
     future.get();
   }
 
+  @Test
+  public void testGetSucceedsOnMainThreadIfDone()
+      throws ExecutionException, InterruptedException {
+    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+    future.onResourceReady(new Object(), null);
+    future.get();
+  }
+
   @Test(expected = InterruptedException.class)
   public void testThrowsInterruptedExceptionIfThreadInterruptedWhenDoneWaiting()
       throws InterruptedException, ExecutionException {
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         Thread.currentThread().interrupt();
         return null;
       }
@@ -224,9 +229,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test(expected = ExecutionException.class)
   public void testThrowsExecutionExceptionIfLoadFailsWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         future.onLoadFailed(null);
         return null;
       }
@@ -237,9 +242,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
   @Test(expected = CancellationException.class)
   public void testThrowsCancellationExceptionIfCancelledWhileWaiting()
       throws ExecutionException, InterruptedException {
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         future.cancel(false);
         return null;
       }
@@ -289,9 +294,9 @@ public void testDoesNotNotifyAllOnSecondCancel() {
   public void testReturnsResourceIfReceivedWhileWaiting()
       throws ExecutionException, InterruptedException {
     final Object expected = new Object();
-    doAnswer(new Answer() {
+    doAnswer(new Answer<Void>() {
       @Override
-      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
         future.onResourceReady(expected, null);
         return null;
       }
diff --git a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
rename to library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
index dad0d87eb..23233e174 100644
--- a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -3,29 +3,26 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import android.graphics.Bitmap;
-
 import com.bumptech.glide.load.Transformation;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
-public class BaseRequestOptionsTest {
+public class RequestOptionsTest {
 
-  private TestOptions options;
+  private RequestOptions options;
   @Mock private Transformation<Bitmap> transformation;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    options = new TestOptions();
+    options = new RequestOptions();
   }
 
   @Test
@@ -45,7 +42,7 @@ public void testIsTransformationAllowed_byDefault_isTrue() {
 
   @Test
   public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
-    TestOptions other = new TestOptions();
+    RequestOptions other = new RequestOptions();
     other.transform(Bitmap.class, transformation);
     options.apply(other);
     assertThat(options.isTransformationSet()).isTrue();
@@ -71,17 +68,17 @@ public void testIsTransformationRequired_afterDontTransform_isFalse() {
 
   @Test
   public void testApplyingDontTransform_overridesTransformations() {
-    options.transform(RuntimeEnvironment.application, transformation);
+    options.transform(transformation);
     options.dontTransform();
     assertThat(options.isTransformationSet()).isFalse();
     assertThat(options.isTransformationRequired()).isFalse();
     assertThat(options.getTransformations()).isEmpty();
   }
 
-  @Test
+@Test
   public void testApplyingTransformation_overridesDontTransform() {
     options.dontTransform();
-    options.transform(RuntimeEnvironment.application, transformation);
+    options.transform(transformation);
 
     assertThat(options.isTransformationAllowed()).isTrue();
     assertThat(options.isTransformationRequired()).isTrue();
@@ -90,8 +87,8 @@ public void testApplyingTransformation_overridesDontTransform() {
 
   @Test
   public void testApplyingOptions_withDontTransform_overridesTransformations() {
-    options.transform(RuntimeEnvironment.application, transformation);
-    TestOptions other = new TestOptions();
+    options.transform(transformation);
+    RequestOptions other = new RequestOptions();
     other.dontTransform();
 
     options.apply(other);
@@ -105,8 +102,8 @@ public void testApplyingOptions_withDontTransform_overridesTransformations() {
   @Test
   public void testApplyingOptions_withTransformation_overridesDontTransform() {
     options.dontTransform();
-    TestOptions other = new TestOptions();
-    other.transform(RuntimeEnvironment.application, transformation);
+    RequestOptions other = new RequestOptions();
+    other.transform(transformation);
 
     options.apply(other);
 
@@ -119,7 +116,7 @@ public void testApplyingOptions_withTransformation_overridesDontTransform() {
   @Test
   public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
     options.dontTransform();
-    options.apply(new TestOptions());
+    options.apply(new RequestOptions());
 
     assertThat(options.isTransformationAllowed()).isFalse();
     assertThat(options.isTransformationRequired()).isFalse();
@@ -128,15 +125,11 @@ public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform()
 
   @Test
   public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
-    options.transform(RuntimeEnvironment.application, transformation);
-    options.apply(new TestOptions());
+    options.transform(transformation);
+    options.apply(new RequestOptions());
 
     assertThat(options.isTransformationAllowed()).isTrue();
     assertThat(options.isTransformationRequired()).isTrue();
     assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
   }
-
-  private static class TestOptions extends BaseRequestOptions<TestOptions> {
-    // Empty.
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 43af5105f..c0e60f63c 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request;
 
 import static com.bumptech.glide.tests.Util.isADataSource;
+import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -19,7 +20,6 @@
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
-
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -34,7 +34,10 @@
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.request.transition.TransitionFactory;
-
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -43,13 +46,9 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("rawtypes")
 public class SingleRequestTest {
   private RequestHarness harness;
 
@@ -57,24 +56,27 @@
    * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
    * Both are in the middle of the hierarchy having multiple descendants and ancestors.
    */
-  @SuppressWarnings("unchecked")
   private static class RequestHarness {
     Engine engine = mock(Engine.class);
     Number model = 123456;
+    @SuppressWarnings("unchecked")
     Target<List> target = mock(Target.class);
-    Resource<List> resource = mock(Resource.class);
+    Resource<List> resource = mockResource();
     RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
     Drawable placeholderDrawable = null;
     Drawable errorDrawable = null;
     Drawable fallbackDrawable = null;
+    @SuppressWarnings("unchecked")
     RequestListener<List> requestListener = mock(RequestListener.class);
+    @SuppressWarnings("unchecked")
     TransitionFactory<List> factory = mock(TransitionFactory.class);
     int overrideWidth = -1;
     int overrideHeight = -1;
-    List result = new ArrayList();
+    List<?> result = new ArrayList<>();
     GlideContext glideContext = mock(GlideContext.class);
     Key signature = mock(Key.class);
     Priority priority = Priority.HIGH;
+    boolean useUnlimitedSourceGeneratorsPool = false;
 
     Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();
 
@@ -91,7 +93,8 @@ public RequestHarness() {
         .fallback(fallbackDrawable)
         .override(overrideWidth, overrideHeight)
         .priority(priority)
-        .signature(signature);
+        .signature(signature)
+        .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
       return SingleRequest
           .obtain(glideContext, model, List.class, requestOptions, overrideWidth, overrideHeight,
               priority, target, requestListener, requestCoordinator, engine, factory);
@@ -275,7 +278,7 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class));
+            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
   }
 
   @Test
@@ -294,7 +297,7 @@ public void testEngineLoadCancelledOnCancel() {
        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
           eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
           eq(harness.transformations), anyBoolean(), any(Options.class),
-          anyBoolean(), any(ResourceCallback.class)))
+          anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenReturn(loadStatus);
 
     SingleRequest<List> request = harness.getRequest();
@@ -538,7 +541,8 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class)))
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class)))
         .thenAnswer(new Answer<Object>() {
           @Override
           public Object answer(InvocationOnMock invocation) throws Throwable {
@@ -652,7 +656,8 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
   @Test
@@ -674,7 +679,7 @@ public void testCanReRunCancelledRequests() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class)))
+            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenAnswer(new CallResourceCallback(harness.resource));
     SingleRequest<List> request = harness.getRequest();
 
@@ -703,9 +708,48 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+
+  @Test
+  public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    harness.useUnlimitedSourceGeneratorsPool = true;
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.engine)
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), eq(Boolean.TRUE), anyBoolean(),
+            any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testCallsSourceExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    harness.useUnlimitedSourceGeneratorsPool = false;
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.engine)
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), eq(Boolean.FALSE), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
+  // TODO do we want to move these to Util?
   @SuppressWarnings("unchecked")
   private static <T> Transition<T> mockTransition() {
     return mock(Transition.class);
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index da94c9799..4ec3ed752 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -10,7 +10,6 @@
 import android.content.ComponentName;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,7 +18,7 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowAppWidgetManager;
 
 @RunWith(RobolectricTestRunner.class)
@@ -32,7 +31,7 @@
 
   @Before
   public void setUp() {
-    shadowManager = (UpdateShadowAppWidgetManager) ShadowExtractor
+    shadowManager = (UpdateShadowAppWidgetManager) Shadow
         .extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
     viewId = 1234;
     views = mock(RemoteViews.class);
diff --git a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
index 7689e0d9a..31e0bb5c6 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/BitmapImageViewTargetTest.java
@@ -5,7 +5,6 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
index 238151560..d0967ce08 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java
@@ -8,7 +8,6 @@
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -41,7 +40,7 @@ public void testReturnsTargetForBitmapDrawables() {
     BitmapDrawable drawable = new BitmapDrawable(RuntimeEnvironment.application.getResources(),
         Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));
 
-    Target target = factory.buildTarget(view, BitmapDrawable.class);
+    Target<BitmapDrawable> target = factory.buildTarget(view, BitmapDrawable.class);
     target.onResourceReady(drawable, null);
     assertThat(target).isInstanceOf(DrawableImageViewTarget.class);
   }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
index c734c8baf..eeb0b1fcf 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java
@@ -12,9 +12,7 @@
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.widget.ImageView;
-
 import com.bumptech.glide.request.transition.Transition;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -74,7 +72,7 @@ public void testSetsDrawableOnLoadCleared() {
 
   @Test
   public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
-    Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(any(Drawable.class), eq(target))).thenReturn(false);
     Drawable resource = new ColorDrawable(Color.GRAY);
     target.onResourceReady(resource, animation);
@@ -85,7 +83,7 @@ public void testSetsDrawableOnViewInOnResourceReadyWhenAnimationReturnsFalse() {
   @Test
   public void testDoesNotSetDrawableOnViewInOnResourceReadyWhenAnimationReturnsTrue() {
     Drawable resource = new ColorDrawable(Color.RED);
-    Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
     when(animation.transition(eq(resource), eq(target))).thenReturn(true);
     target.onResourceReady(resource, animation);
 
@@ -97,7 +95,7 @@ public void testProvidesCurrentPlaceholderToAnimationIfPresent() {
     Drawable placeholder = new ColorDrawable(Color.BLACK);
     view.setImageDrawable(placeholder);
 
-    Transition<Drawable> animation = mock(Transition.class);
+    @SuppressWarnings("unchecked") Transition<Drawable> animation = mock(Transition.class);
 
     target.onResourceReady(new ColorDrawable(Color.GREEN), animation);
 
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index 38d60fe05..eae33c7e4 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -10,7 +10,6 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.widget.RemoteViews;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,7 +18,7 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowNotificationManager;
 
 @RunWith(RobolectricTestRunner.class)
@@ -38,7 +37,7 @@
   public void setUp() {
     NotificationManager notificationManager = (NotificationManager) RuntimeEnvironment.application
         .getSystemService(Context.NOTIFICATION_SERVICE);
-    shadowManager = (UpdateShadowNotificationManager) ShadowExtractor.extract(notificationManager);
+    shadowManager = (UpdateShadowNotificationManager) Shadow.extract(notificationManager);
 
     remoteViews = mock(RemoteViews.class);
     viewId = 123;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
index 5a6674534..e5e397f41 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/PreloadTargetTest.java
@@ -6,7 +6,6 @@
 
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.request.Request;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
index 4ceda7c64..14e1362f7 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/SimpleTargetTest.java
@@ -3,7 +3,6 @@
 import static org.mockito.Mockito.mock;
 
 import com.bumptech.glide.request.transition.Transition;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index 3debccfcd..a31adc29c 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -13,50 +13,56 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.content.Context;
 import android.graphics.drawable.Drawable;
+import android.os.Build;
 import android.view.View;
 import android.view.ViewTreeObserver;
-import android.view.WindowManager;
-
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
-
+import com.bumptech.glide.tests.Util;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
-import org.robolectric.shadows.ShadowDisplay;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowView;
-import org.robolectric.shadows.ShadowViewTreeObserver;
-
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { ViewTargetTest.SizedShadowView.class,
+@Config(manifest = Config.NONE, sdk = 19, shadows = { ViewTargetTest.SizedShadowView.class,
     ViewTargetTest.PreDrawShadowViewTreeObserver.class })
 public class ViewTargetTest {
   private View view;
-  private ViewTarget target;
+  private ViewTarget<View, Object> target;
   private SizedShadowView shadowView;
   private PreDrawShadowViewTreeObserver shadowObserver;
+  @Mock private SizeReadyCallback cb;
+  @Mock private Request request;
+  private int sdkVersion;
 
   @Before
   public void setUp() {
+    sdkVersion = Build.VERSION.SDK_INT;
+    MockitoAnnotations.initMocks(this);
     view = new View(RuntimeEnvironment.application);
     target = new TestViewTarget(view);
 
-    shadowView = (SizedShadowView) ShadowExtractor.extract(view);
-    shadowObserver =
-        (PreDrawShadowViewTreeObserver) ShadowExtractor.extract(view.getViewTreeObserver());
+    shadowView = Shadow.extract(view);
+    shadowObserver = Shadow.extract(view.getViewTreeObserver());
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(sdkVersion);
   }
 
   @Test
@@ -77,8 +83,6 @@ public void testThrowsIfViewTagIsNotRequestObject() {
 
   @Test
   public void testCanSetAndRetrieveRequest() {
-    Request request = mock(Request.class);
-
     target.setRequest(request);
 
     assertEquals(request, target.getRequest());
@@ -86,8 +90,6 @@ public void testCanSetAndRetrieveRequest() {
 
   @Test
   public void testRetrievesRequestFromPreviousTargetForView() {
-    Request request = mock(Request.class);
-
     target.setRequest(request);
 
     ViewTarget<View, Object> second = new TestViewTarget(view);
@@ -98,10 +100,11 @@ public void testRetrievesRequestFromPreviousTargetForView() {
   @Test
   public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
     int dimens = 333;
-    shadowView.setWidth(dimens);
-    shadowView.setHeight(dimens);
+    shadowView
+        .setWidth(dimens)
+        .setHeight(dimens)
+        .setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb).onSizeReady(eq(dimens), eq(dimens));
@@ -112,117 +115,84 @@ public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet()
     int dimens = 444;
     LayoutParams layoutParams = new LayoutParams(dimens, dimens);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb).onSizeReady(eq(dimens), eq(dimens));
   }
 
-  private void setDisplayDimens(Integer width, Integer height) {
-    WindowManager windowManager =
-        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
-    ShadowDisplay shadowDisplay = Shadows.shadowOf(windowManager.getDefaultDisplay());
-    if (width != null) {
-      shadowDisplay.setWidth(width);
-    }
-
-    if (height != null) {
-      shadowDisplay.setHeight(height);
-    }
-  }
-
-  private void setDisplayWidth(int width) {
-    setDisplayDimens(width, null);
-  }
-
-  private void setDisplayHeight(int height) {
-    setDisplayDimens(null, height);
-  }
-
   @Test
-  public void testBothParamsWrapContent() {
+  public void getSize_withBothWrapContent_returnsSizeOriginal() {
     LayoutParams layoutParams =
         new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
 
-    int width = 123;
-    int height = 456;
-    setDisplayDimens(width, height);
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
-    verify(cb).onSizeReady(eq(width), eq(height));
+    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
 
   @Test
-  public void testWrapContentWidthWithValidHeight() {
-    int displayWidth = 500;
-    setDisplayWidth(displayWidth);
-
+  public void getSize_withWrapContentWidthAndValidHeight_usesSizeOriginalWidthValidHeight() {
     int height = 100;
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
     view.setLayoutParams(params);
+    shadowView.setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
-    verify(cb).onSizeReady(eq(displayWidth), eq(height));
+    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
   }
 
   @Test
-  public void testWrapContentHeightWithValidWidth() {
-    int displayHeight = 700;
-    setDisplayHeight(displayHeight);
+  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndSizeOriginalHeight() {
     int width = 100;
     LayoutParams params = new LayoutParams(width, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
+    shadowView.setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
-    verify(cb).onSizeReady(eq(width), eq(displayHeight));
+    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
   }
 
   @Test
-  public void testWrapContentWidthWithMatchParentHeight() {
-    int displayWidth = 1234;
-    setDisplayWidth(displayWidth);
-
+  public void getSize_withWrapContentWidthAndMatchParentHeight_usesSizeOriginalWidthAndHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
     view.setLayoutParams(params);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int height = 32;
-    shadowView.setHeight(height);
+    shadowView
+        .setHeight(height)
+        .setIsLaidOut(true);
 
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(eq(displayWidth), eq(height));
+    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
   }
 
   @Test
-  public void testWrapContentHeightWithMatchParentWidth() {
-    int displayHeight = 5812;
-    setDisplayHeight(displayHeight);
-
+  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndSizeOriginalHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int width = 32;
-    shadowView.setWidth(width);
+    shadowView
+        .setWidth(width)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(eq(width), eq(displayHeight));
+    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
   }
 
   @Test
@@ -230,15 +200,16 @@ public void testMatchParentWidthAndHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
     view.setLayoutParams(params);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int width = 32;
     int height = 45;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -246,13 +217,14 @@ public void testMatchParentWidthAndHeight() {
 
   @Test
   public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     int width = 12;
     int height = 32;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -267,8 +239,10 @@ public void testSizeCallbacksAreCalledInOrderPreDraw() {
     }
 
     int width = 100, height = 111;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     InOrder order = inOrder((Object[]) cbs);
@@ -279,11 +253,11 @@ public void testSizeCallbacksAreCalledInOrderPreDraw() {
 
   @Test
   public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
     target.getSize(cb);
 
     view.setLayoutParams(new LayoutParams(100, 100));
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
@@ -304,6 +278,7 @@ public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest
     target.getSize(cb1);
 
     view.setLayoutParams(new LayoutParams(100, 100));
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     assertThat(shadowObserver.getPreDrawListeners()).hasSize(0);
@@ -320,7 +295,6 @@ public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest
 
   @Test
   public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
     shadowObserver.fireOnPreDrawListeners();
 
@@ -330,13 +304,13 @@ public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
 
   @Test
   public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     int width = 689;
     int height = 354;
     LayoutParams layoutParams = new LayoutParams(width, height);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -344,11 +318,11 @@ public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutP
 
   @Test
   public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     LayoutParams layoutParams = new LayoutParams(1234, 4123);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
     shadowObserver.fireOnPreDrawListeners();
 
@@ -366,6 +340,7 @@ public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
     int height = 875;
     LayoutParams layoutParams = new LayoutParams(width, height);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
     shadowObserver.fireOnPreDrawListeners();
 
@@ -375,13 +350,13 @@ public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
 
   @Test
   public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     int width = 1;
     int height = 2;
     LayoutParams layoutParams = new LayoutParams(width, height);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.setIsAlive(false);
     shadowObserver.fireOnPreDrawListeners();
 
@@ -393,8 +368,81 @@ public void testThrowsIfGivenNullView() {
     new TestViewTarget(null);
   }
 
+  @Test
+  public void testDecreasesDimensionsByViewPadding() {
+    view.setLayoutParams(new LayoutParams(100, 100));
+    view.setPadding(25, 25, 25, 25);
+    shadowView.setIsLaidOut(true);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(50, 50);
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_notLaidOut_doesNotCallSizeReady() {
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_notLaidOut_doesCallSizeReady() {
+    shadowView
+        .setLayoutParams(new LayoutParams(10, 10))
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_zeroWidthHeight_notLaidOut_doesNotCallSizeReady() {
+    shadowView
+        .setLayoutParams(new LayoutParams(0, 0))
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_doesNotCallSizeReady() {
+    Util.setSdkVersionInt(18);
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(true);
+
+    view.setPadding(50, 50, 50, 50);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
   @Implements(ViewTreeObserver.class)
-  public static class PreDrawShadowViewTreeObserver extends ShadowViewTreeObserver {
+  public static class PreDrawShadowViewTreeObserver {
     private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
     private boolean isAlive = true;
 
@@ -442,13 +490,33 @@ public void fireOnPreDrawListeners() {
   public static class SizedShadowView extends ShadowView {
     private int width;
     private int height;
+    private LayoutParams layoutParams;
+    private boolean isLaidOut;
+    private boolean isLayoutRequested;
 
-    public void setWidth(int width) {
+    public SizedShadowView setWidth(int width) {
       this.width = width;
+      return this;
     }
 
-    public void setHeight(int height) {
+    public SizedShadowView setHeight(int height) {
       this.height = height;
+      return this;
+    }
+
+    public SizedShadowView setLayoutParams(LayoutParams layoutParams) {
+      this.layoutParams = layoutParams;
+      return this;
+    }
+
+    public SizedShadowView setIsLaidOut(boolean isLaidOut) {
+      this.isLaidOut = isLaidOut;
+      return this;
+    }
+
+    @Implementation
+    public void requestLayout() {
+      isLayoutRequested = true;
     }
 
     @Implementation
@@ -460,6 +528,21 @@ public int getWidth() {
     public int getHeight() {
       return height;
     }
+
+    @Implementation
+    public boolean isLaidOut() {
+      return isLaidOut;
+    }
+
+    @Implementation
+    public boolean isLayoutRequested() {
+      return isLayoutRequested;
+    }
+
+    @Implementation
+    public LayoutParams getLayoutParams() {
+      return layoutParams;
+    }
   }
 
   private static class TestViewTarget extends ViewTarget<View, Object> {
@@ -479,7 +562,7 @@ public void onLoadFailed(Drawable errorDrawable) {
     }
 
     @Override
-    public void onResourceReady(Object resource, Transition transition) {
+    public void onResourceReady(Object resource, Transition<? super Object> transition) {
 
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
index 5bc27b14a..98d37cb3d 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
@@ -5,9 +5,7 @@
 import static org.mockito.Mockito.mock;
 
 import android.graphics.drawable.Drawable;
-
 import com.bumptech.glide.load.DataSource;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,7 +22,8 @@
   @Before
   public void setUp() {
     ViewAnimationFactory<Drawable> viewAnimationFactory = mock(ViewAnimationFactory.class);
-    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/);
+    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/,
+        false /*isCrossFadeEnabled*/);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index 78861713d..6ade60e8b 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -14,7 +14,6 @@
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -73,7 +72,7 @@ public void testReturnsTrueIfSetsTransitionDrawable() {
     Transition<Drawable> defaultAnimation = mock(Transition.class);
     int duration = 200;
     DrawableCrossFadeTransition animation =
-        new DrawableCrossFadeTransition(defaultAnimation, duration);
+        new DrawableCrossFadeTransition(defaultAnimation, duration, true /*isCrossFadeEnabled*/);
   }
 }
 
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
index 54ebaff3c..bdfef1c41 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewAnimationTest.java
@@ -11,7 +11,6 @@
 import android.content.Context;
 import android.view.animation.Animation;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
index 52f429f4e..2b50c15d8 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyAnimationTest.java
@@ -11,7 +11,6 @@
 
 import android.view.View;
 import android.widget.ImageView;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
index 2d680b57e..831a9d047 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewPropertyViewTransitionAnimationFactoryTest.java
@@ -5,7 +5,6 @@
 import static org.mockito.Mockito.mock;
 
 import com.bumptech.glide.load.DataSource;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
index d7f433788..6f1cb4ec5 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/ViewTransitionAnimationFactoryTest.java
@@ -11,9 +11,7 @@
 import android.content.Context;
 import android.view.View;
 import android.view.animation.Animation;
-
 import com.bumptech.glide.load.DataSource;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,12 +23,12 @@
 @Config(manifest = Config.NONE)
 public class ViewTransitionAnimationFactoryTest {
   private ViewTransition.ViewTransitionAnimationFactory viewTransitionAnimationFactory;
-  private ViewAnimationFactory factory;
+  private ViewAnimationFactory<Object> factory;
 
   @Before
   public void setUp() {
     viewTransitionAnimationFactory = mock(ViewTransition.ViewTransitionAnimationFactory.class);
-    factory = new ViewAnimationFactory(viewTransitionAnimationFactory);
+    factory = new ViewAnimationFactory<>(viewTransitionAnimationFactory);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 79f8e961c..95eaca505 100644
--- a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -5,18 +5,16 @@
 
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
-
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ExifTest {
@@ -31,7 +29,7 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
     InputStream is = null;
     try {
       is = open(filePrefix + "_" + expectedOrientation + ".jpg");
-      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),
+      assertEquals(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool),
           expectedOrientation);
     } catch (IOException e) {
       throw new RuntimeException(e);
@@ -54,7 +52,7 @@ public void setUp() {
   @Test
   public void testIssue387() throws IOException {
     InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
+    assertThat(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool)).isEqualTo(6);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
index 3d444fd17..7a55e9990 100644
--- a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
+++ b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
@@ -4,7 +4,8 @@
 
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.KeyAssertions;
-
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -12,9 +13,6 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ApplicationVersionSignatureTest {
diff --git a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
index 46b41c9ba..7f465fb23 100644
--- a/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
+++ b/library/src/test/java/com/bumptech/glide/signature/MediaStoreSignatureTest.java
@@ -1,14 +1,12 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.tests.KeyAssertions;
-
+import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(JUnit4.class)
 public class MediaStoreSignatureTest {
 
diff --git a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
index 2012092af..21570323c 100644
--- a/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
+++ b/library/src/test/java/com/bumptech/glide/signature/ObjectKeyTest.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.tests.KeyAssertions;
-
+import java.security.NoSuchAlgorithmException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.security.NoSuchAlgorithmException;
-
 @RunWith(JUnit4.class)
 public class ObjectKeyTest {
 
diff --git a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
index 61e476548..326096bad 100644
--- a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
+++ b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
@@ -3,13 +3,11 @@
 import android.content.ContentResolver;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
-
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-
 import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
 
 @Implements(ContentResolver.class)
 public class ContentResolverShadow {
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
index f0ed18b27..ddd9d06b8 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
+++ b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLog.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.tests;
 
 import android.util.Log;
-
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowLog;
diff --git a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
index c41e4a6f7..7b94a888c 100644
--- a/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
+++ b/library/src/test/java/com/bumptech/glide/tests/GlideShadowLooper.java
@@ -4,7 +4,6 @@
 
 import android.os.Looper;
 import android.os.MessageQueue;
-
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowLooper;
diff --git a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
index 80d7dc3a9..5ee17790a 100644
--- a/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
+++ b/library/src/test/java/com/bumptech/glide/tests/KeyAssertions.java
@@ -2,10 +2,8 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.google.common.testing.EqualsTester;
-
 import com.bumptech.glide.load.Key;
-
+import com.google.common.testing.EqualsTester;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/src/test/java/com/bumptech/glide/tests/Util.java
index ab333bec8..e80796ba2 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/src/test/java/com/bumptech/glide/tests/Util.java
@@ -4,18 +4,14 @@
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.RETURNS_DEFAULTS;
+import static org.mockito.Mockito.mock;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Build;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.engine.Resource;
-
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.util.ReflectionHelpers;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -23,22 +19,54 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.security.MessageDigest;
+import org.mockito.ArgumentCaptor;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.util.ReflectionHelpers;
 
 // FIXME move to testutil module
 public class Util {
 
-  public static String getExpectedClassId(Class clazz) {
+  public static String getExpectedClassId(Class<?> clazz) {
     return clazz.getSimpleName() + "." + clazz.getPackage().getName();
   }
 
+  /**
+   * Gives the proper generic type to the {@link ArgumentCaptor}.
+   * Only useful when the captor's {@code T} is also a generic type.
+   * Without this it's really ugly to have a properly typed captor object.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> ArgumentCaptor<T> cast(ArgumentCaptor<?> captor) {
+    return (ArgumentCaptor<T>) captor;
+  }
+
   public static DataSource isADataSource() {
     return isA(DataSource.class);
   }
 
-  public static Resource<?> anyResource() {
+  public static Context anyContext() {
+    return any(Context.class);
+  }
+
+  /**
+   * Creates a Mockito argument matcher to be used in verify.
+   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> Resource<T> anyResource() {
     return any(Resource.class);
   }
 
+  /**
+   * Creates a Mockito mock object.
+   * It returns a generic typed {@link Resource} to prevent unchecked warnings.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> Resource<T> mockResource() {
+    return mock(Resource.class);
+  }
+
   public static boolean isWindows() {
     return System.getProperty("os.name").startsWith("Windows");
   }
diff --git a/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java b/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
index 4eb221597..007e5a26b 100644
--- a/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
@@ -2,15 +2,14 @@
 
 import static org.junit.Assert.assertEquals;
 
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
diff --git a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
index 84d01d0b0..848321fe1 100644
--- a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -6,6 +6,9 @@
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.when;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,9 +17,6 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class ContentLengthInputStreamTest {
@@ -72,7 +72,7 @@ public void testAvailable_handlesReadValueOfZero() throws IOException {
     when(wrapped.read()).thenReturn(0);
 
     assertThat(is.read()).isEqualTo(0);
-    assertThat(is.available()).isEqualTo(contentLength);
+    assertThat(is.available()).isEqualTo(contentLength - 1);
   }
 
   @Test
@@ -131,4 +131,27 @@ public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow(
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
     is.read(new byte[10], 0, 0);
   }
+
+  @Test
+  public void testRead_readWithZeroes_doesNotThrow() throws IOException {
+    ByteArrayInputStream inner = new ByteArrayInputStream(new byte[] {0, 0, 0});
+    InputStream is = ContentLengthInputStream.obtain(inner, 3);
+
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(-1);
+  }
+
+  @Test
+  public void testRead_readWithHighValues_doesNotThrow() throws IOException {
+    ByteArrayInputStream inner =
+        new ByteArrayInputStream(new byte[] {(byte) 0xF0, (byte) 0xA0, (byte) 0xFF});
+    InputStream is = ContentLengthInputStream.obtain(inner, 3);
+
+    assertThat(is.read()).isEqualTo(0xF0);
+    assertThat(is.read()).isEqualTo(0xA0);
+    assertThat(is.read()).isEqualTo(0xFF);
+    assertThat(is.read()).isEqualTo(-1);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
index 8a07d5a27..913432b92 100644
--- a/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java
@@ -12,17 +12,15 @@
 import static org.mockito.Mockito.when;
 
 import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
-
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.SocketTimeoutException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.SocketTimeoutException;
-
 @RunWith(JUnit4.class)
 public class ExceptionCatchingInputStreamTest {
 
diff --git a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
index 16d5d0187..1e18b4203 100644
--- a/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java
@@ -3,14 +3,13 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
 public class MarkEnforcingInputStreamTest {
diff --git a/library/src/test/java/com/bumptech/glide/util/UtilTest.java b/library/src/test/java/com/bumptech/glide/util/UtilTest.java
index 64f89ff8a..92d16e95b 100644
--- a/library/src/test/java/com/bumptech/glide/util/UtilTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/UtilTest.java
@@ -3,7 +3,6 @@
 import static org.junit.Assert.assertEquals;
 
 import android.graphics.Bitmap;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
diff --git a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
index 81ed47525..014cdaa19 100644
--- a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
@@ -5,7 +5,6 @@
 
 import android.view.View;
 import android.view.ViewGroup;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -47,6 +46,7 @@ public void testDoesNotObtainSizeFromViewOnceSizeIsSet() {
     int height = 456;
     provider.onSizeReady(width, height);
     view.setLayoutParams(new ViewGroup.LayoutParams(1, 1));
+    view.layout(0, 0, 1, 1);
 
     provider.setView(view);
 
@@ -59,6 +59,7 @@ public void testCanObtainFixedSizeFromView() {
     int width = 123;
     int height = 456;
     view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+    view.layout(0, 0, width, height);
 
     provider.setView(view);
 
@@ -82,6 +83,7 @@ public void testCanObtainSizeFromViewWhenGivenViewInConstructor() {
     int width = 100;
     int height = 200;
     view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+    view.layout(0, 0, width, height);
 
     provider = new ViewPreloadSizeProvider<>(view);
 
diff --git a/samples/contacturi/build.gradle b/samples/contacturi/build.gradle
new file mode 100644
index 000000000..dccc94939
--- /dev/null
+++ b/samples/contacturi/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'com.android.application'
+
+dependencies {
+    compile project(':library')
+    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    defaultConfig {
+        applicationId 'com.bumptech.glide.samples.contacturi'
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionCode 1
+        versionName '1.0'
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+task run(type: Exec, dependsOn: 'installDebug') {
+    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.contacturi/.MainActivity'
+}
diff --git a/samples/contacturi/src/main/AndroidManifest.xml b/samples/contacturi/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..ecfd4c859
--- /dev/null
+++ b/samples/contacturi/src/main/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.bumptech.glide.samples.contacturi" >
+
+    <uses-permission android:name="android.permission.READ_CONTACTS" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@android:drawable/sym_def_app_icon"
+        android:label="@string/app_name"
+        android:theme="@style/Theme.AppCompat" >
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
new file mode 100644
index 000000000..4fe9526c4
--- /dev/null
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -0,0 +1,91 @@
+package com.bumptech.glide.samples.contacturi;
+
+import static android.os.Build.VERSION;
+import static android.os.Build.VERSION_CODES;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.ContentUris;
+import android.content.Intent;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract.Contacts;
+import android.view.View;
+import android.widget.ImageView;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * An activity that demonstrates loading photos using
+ * {@link com.bumptech.glide.load.data.StreamLocalUriFetcher content uris} through Glide.
+ * It works by making the user to choose a contact when presses a button,
+ * and after he chooses a contact with photo,
+ * We try to load both a high res image and thumbnail image of that contact with various Uris.
+ */
+public class MainActivity extends Activity {
+  private static final int REQUEST_CONTACT = 1;
+
+  private ImageView imageViewContact;
+  private ImageView imageViewLookup;
+  private ImageView imageViewPhoto;
+  private ImageView imageViewDisplayPhoto;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+
+    imageViewContact = (ImageView) findViewById(R.id.image_contact);
+    imageViewLookup = (ImageView) findViewById(R.id.image_lookup);
+    imageViewPhoto = (ImageView) findViewById(R.id.image_photo);
+    imageViewDisplayPhoto = (ImageView) findViewById(R.id.image_display_photo);
+
+    findViewById(R.id.button_pick_contact).setOnClickListener(new View.OnClickListener() {
+      @Override
+      public void onClick(View v) {
+        Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
+        startActivityForResult(intent, REQUEST_CONTACT);
+      }
+    });
+  }
+
+  @Override
+  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+    if (requestCode == REQUEST_CONTACT && resultCode == RESULT_OK) {
+      final Cursor cursor = getContentResolver().query(data.getData(), null, null, null, null);
+      try {
+        if (cursor != null && cursor.moveToFirst()) {
+          final long contactId = cursor.getLong(cursor.getColumnIndex(Contacts._ID));
+          showContact(contactId);
+        }
+      } finally {
+        if (cursor != null) {
+          cursor.close();
+        }
+      }
+      return;
+    }
+    super.onActivityResult(requestCode, resultCode, data);
+  }
+
+  @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
+  private void showContact(long id) {
+    RequestOptions originalSize = new RequestOptions().override(Target.SIZE_ORIGINAL);
+
+    Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI, id);
+    Glide.with(this).load(contactUri).apply(originalSize).into(imageViewContact);
+
+    Uri lookupUri = Contacts.getLookupUri(getContentResolver(), contactUri);
+    Glide.with(this).load(lookupUri).apply(originalSize).into(imageViewLookup);
+
+    Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
+    Glide.with(this).load(photoUri).apply(originalSize).into(imageViewPhoto);
+
+    if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
+      Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
+      Glide.with(this).load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
+    }
+  }
+}
diff --git a/samples/contacturi/src/main/res/layout/activity_main.xml b/samples/contacturi/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..fe9510388
--- /dev/null
+++ b/samples/contacturi/src/main/res/layout/activity_main.xml
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:fitsSystemWindows="true"
+        android:padding="@dimen/activity_horizontal_margin"
+        tools:context="com.bumptech.glide.samples.contacturi.MainActivity">
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+        <Button
+                android:id="@+id/button_pick_contact"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/pick_contact"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_contact"/>
+        <ImageView
+                android:id="@+id/image_contact"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_contact"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_lookup"/>
+        <ImageView
+                android:id="@+id/image_lookup"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_lookup"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_photo"/>
+        <ImageView
+                android:id="@+id/image_photo"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_photo"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_display_photo"/>
+        <ImageView
+                android:id="@+id/image_display_photo"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_display_photo"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/samples/contacturi/src/main/res/values/dimens.xml b/samples/contacturi/src/main/res/values/dimens.xml
new file mode 100644
index 000000000..47c822467
--- /dev/null
+++ b/samples/contacturi/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/samples/contacturi/src/main/res/values/strings.xml b/samples/contacturi/src/main/res/values/strings.xml
new file mode 100644
index 000000000..63bdff591
--- /dev/null
+++ b/samples/contacturi/src/main/res/values/strings.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">ContactUri Sample</string>
+    <string name="pick_contact">Pick Contact</string>
+    <string name="image_contact">Image based on contact Uri, best size on latest Android</string>
+    <string name="image_lookup">Image based on lookup Uri, same as contact Uri</string>
+    <string name="image_photo">Image based on photo Uri, thumbnail sized, usually 96x96px</string>
+    <string name="image_display_photo">Image based on display photo Uri, possibly 512x512px</string>
+</resources>
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index aec235f5e..a0233b7a8 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -5,6 +5,8 @@ dependencies {
     compile(project(':integration:recyclerview')) {
         transitive = false
     }
+    annotationProcessor project(':annotation:compiler')
+
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
     compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
@@ -17,11 +19,11 @@ android {
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.flickr'
-        minSdkVersion 11
+        minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
         versionCode 1
-        versionName '1.0.0'
+        versionName '1.0'
     }
 
     compileOptions {
diff --git a/samples/flickr/src/main/AndroidManifest.xml b/samples/flickr/src/main/AndroidManifest.xml
index 1a6e4a6ff..9be7824f6 100644
--- a/samples/flickr/src/main/AndroidManifest.xml
+++ b/samples/flickr/src/main/AndroidManifest.xml
@@ -6,9 +6,6 @@
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
-    <uses-sdk android:minSdkVersion="10"
-      android:targetSdkVersion="22" />
-
     <application
         android:label="@string/app_name"
         android:icon="@android:drawable/sym_def_app_icon"
@@ -27,10 +24,5 @@
         </activity>
 
         <activity android:name=".FullscreenActivity"/>
-
-        <meta-data
-            android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
-            android:value="GlideModule"/>
     </application>
-
 </manifest>
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
index e965d395e..cae1eaf14 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -1,25 +1,25 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import com.bumptech.glide.samples.flickr.api.Photo;
-
 import java.io.InputStream;
 
 /**
- * {@link com.bumptech.glide.module.GlideModule} for the Flickr sample app.
+ * Register {@link FlickrModelLoader} for the Flickr sample app.
  */
-public class FlickrGlideModule implements GlideModule {
+@GlideModule
+public class FlickrGlideModule extends AppGlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
+  public void registerComponents(Context context, Registry registry) {
+    registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
   }
 
+  // Disable manifest parsing to avoid adding similar modules twice.
   @Override
-  public void registerComponents(Context context, Registry registry) {
-    registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
+  public boolean isManifestParsingEnabled() {
+    return false;
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index 708f68e3a..cf7ea32c0 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
@@ -11,7 +9,6 @@
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
-
 import java.io.InputStream;
 import java.util.List;
 
@@ -29,8 +26,7 @@
     private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
 
     @Override
-    public ModelLoader<Photo, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Photo, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new FlickrModelLoader(multiFactory.build(GlideUrl.class, InputStream.class),
           modelCache);
     }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index 7bbcb4d81..1b237163e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -16,7 +16,6 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.Priority;
@@ -26,7 +25,6 @@
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.FixedPreloadSizeProvider;
-
 import java.util.Collections;
 import java.util.List;
 
@@ -71,13 +69,12 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
     fullRequest = Glide.with(this)
         .asDrawable()
         .transition(withNoTransition())
-        .apply(centerCropTransform(getActivity()));
+        .apply(centerCropTransform());
 
     thumbnailRequest = Glide.with(this)
         .asDrawable()
         .transition(withNoTransition())
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
-            .centerCrop(getActivity())
+        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA).centerCrop()
             .override(Api.SQUARE_THUMB_SIZE));
 
     preloadRequest =
@@ -208,7 +205,7 @@ public int getItemCount() {
     }
 
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
       return preloadRequest.load(item);
     }
   }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index 8c4496714..15f3e56fc 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -17,7 +17,6 @@
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.TextView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
@@ -27,7 +26,6 @@
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
-
 import java.util.Collections;
 import java.util.List;
 
@@ -82,7 +80,7 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
     final RequestManager requestManager = Glide.with(this);
     fullRequest = requestManager
         .asDrawable()
-        .apply(centerCropTransform(getActivity())
+        .apply(centerCropTransform()
             .placeholder(new ColorDrawable(Color.GRAY)));
 
     thumbRequest = requestManager
@@ -176,7 +174,7 @@ public int getItemCount() {
     }
 
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Photo item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
       return fullRequest.thumbnail(thumbRequest.load(item)).load(item);
     }
   }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index 163c9d220..e29dd3f9d 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -23,7 +23,6 @@
 import android.view.ViewGroup;
 import android.widget.SearchView;
 import android.widget.TextView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
 import com.bumptech.glide.request.FutureTarget;
@@ -32,7 +31,6 @@
 import com.bumptech.glide.samples.flickr.api.Query;
 import com.bumptech.glide.samples.flickr.api.RecentQuery;
 import com.bumptech.glide.samples.flickr.api.SearchQuery;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collections;
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index ab474658f..b2ab22e31 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.samples.flickr;
 
-
 import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
 
 import android.content.Context;
@@ -8,7 +7,6 @@
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
@@ -31,9 +29,6 @@ protected void onCreate(Bundle savedInstanceState) {
     ImageView fullscreenView = (ImageView) findViewById(R.id.fullscreen_view);
     Photo photo = getIntent().getParcelableExtra(ARG_PHOTO);
 
-    Glide.with(this)
-        .load(photo)
-        .apply(fitCenterTransform(this))
-        .into(fullscreenView);
+    Glide.with(this).load(photo).apply(fitCenterTransform()).into(fullscreenView);
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
index b91230272..19776b359 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/PhotoViewer.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
 import com.bumptech.glide.samples.flickr.api.Photo;
-
 import java.util.List;
 
 /**
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
index 1560cf82e..5988e6bf8 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.os.Build;
+import android.support.v7.widget.AppCompatImageView;
 import android.util.AttributeSet;
 import android.widget.ImageView;
 
 /**
  * An always square {@link ImageView}.
  */
-public final class SquareImageView extends ImageView {
+public final class SquareImageView extends AppCompatImageView {
 
   public SquareImageView(Context context) {
     super(context);
@@ -23,11 +22,6 @@ public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
   }
 
-  @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-  public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-    super(context, attrs, defStyleAttr, defStyleRes);
-  }
-
   @Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     super.onMeasure(widthMeasureSpec, widthMeasureSpec);
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
index e31424079..4ef7f0bde 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java
@@ -2,14 +2,12 @@
 
 import android.content.Context;
 import android.util.SparseArray;
-
 import com.android.volley.DefaultRetryPolicy;
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
 import com.android.volley.toolbox.StringRequest;
 import com.android.volley.toolbox.Volley;
 import com.bumptech.glide.util.LruCache;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
index cdc081bf3..5bd75a67c 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/FlickrQueryResponseListener.java
@@ -2,11 +2,9 @@
 
 import com.android.volley.Response;
 import com.android.volley.VolleyError;
-
-import org.json.JSONException;
-
 import java.util.Collection;
 import java.util.List;
+import org.json.JSONException;
 
 /**
  * Handles photo list responses and errors from Flickr API calls.
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
index 42570507e..8ff5f5b9a 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
@@ -2,7 +2,6 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-
 import org.json.JSONException;
 import org.json.JSONObject;
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
index 50522b63e..8345e0392 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/PhotoJsonStringParser.java
@@ -1,12 +1,11 @@
 package com.bumptech.glide.samples.flickr.api;
 
+import java.util.ArrayList;
+import java.util.List;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * Parses a list of {@link Photo} objects from a Flickr API response string containing JSON data.
  */
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index 30b337cf4..9f1cce8bc 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -7,18 +7,19 @@ dependencies {
     }
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
     compileSdkVersion COMPILE_SDK_VERSION as int
-    buildToolsVersion BUILD_TOOLS_VERSION
+    buildToolsVersion BUILD_TOOLS_VERSION as String
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.gallery'
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
-        versionName "1.0"
+        versionName '1.0'
     }
 
     compileOptions {
diff --git a/samples/gallery/src/main/AndroidManifest.xml b/samples/gallery/src/main/AndroidManifest.xml
index 7a38c3fb1..41c16f292 100644
--- a/samples/gallery/src/main/AndroidManifest.xml
+++ b/samples/gallery/src/main/AndroidManifest.xml
@@ -4,10 +4,6 @@
 
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
 
-  <uses-sdk
-        android:minSdkVersion="10"
-        android:targetSdkVersion="22" />
-
   <application
           android:label="@string/app_name"
           android:icon="@android:drawable/sym_def_app_icon"
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
index 35e1376fd..472c96a0e 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -9,11 +9,9 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
-
 import java.util.List;
 
 /**
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index 4c7c3e509..fc8e0315a 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -2,7 +2,6 @@
 
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.MemoryCategory;
 
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
index e8d2bb95c..efe2366d5 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MediaStoreDataLoader.java
@@ -6,7 +6,6 @@
 import android.net.Uri;
 import android.provider.MediaStore;
 import android.support.v4.content.AsyncTaskLoader;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 1b26904ad..16d5171c7 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -1,13 +1,10 @@
 package com.bumptech.glide.samples.gallery;
 
-import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
 import android.support.v7.widget.RecyclerView;
 import android.view.Display;
 import android.view.LayoutInflater;
@@ -16,20 +13,19 @@
 import android.view.ViewTreeObserver;
 import android.view.WindowManager;
 import android.widget.ImageView;
-
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.signature.MediaStoreSignature;
-
 import java.util.Collections;
 import java.util.List;
 
 /**
  * Displays {@link com.bumptech.glide.samples.gallery.MediaStoreData} in a recycler view.
  */
-class RecyclerAdapter extends RecyclerView.Adapter
+class RecyclerAdapter extends RecyclerView.Adapter<RecyclerAdapter.ListViewHolder>
     implements ListPreloader.PreloadSizeProvider<MediaStoreData>,
     ListPreloader.PreloadModelProvider<MediaStoreData> {
 
@@ -41,19 +37,17 @@
 
   RecyclerAdapter(Context context, List<MediaStoreData> data, RequestManager requestManager) {
     this.data = data;
-    requestBuilder = requestManager
-        .asDrawable()
-        .apply(fitCenterTransform(context));
+    requestBuilder = requestManager.asDrawable().apply(RequestOptions.fitCenterTransform());
 
     setHasStableIds(true);
 
-    screenWidth = getWidth(context);
+    screenWidth = getScreenWidth(context);
   }
 
   @Override
-  public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
-    final View view = LayoutInflater.from(viewGroup.getContext())
-        .inflate(R.layout.recycler_item, viewGroup, false);
+  public ListViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
+    LayoutInflater inflater = LayoutInflater.from(viewGroup.getContext());
+    final View view = inflater.inflate(R.layout.recycler_item, viewGroup, false);
     view.getLayoutParams().width = screenWidth;
 
     if (actualDimensions == null) {
@@ -73,11 +67,9 @@ public boolean onPreDraw() {
   }
 
   @Override
-  public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {
+  public void onBindViewHolder(ListViewHolder viewHolder, int position) {
     MediaStoreData current = data.get(position);
 
-    final ListViewHolder vh = (ListViewHolder) viewHolder;
-
     Key signature =
         new MediaStoreSignature(current.mimeType, current.dateModified, current.orientation);
 
@@ -85,7 +77,7 @@ public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {
         .clone()
         .apply(signatureOf(signature))
         .load(current.uri)
-        .into(vh.image);
+        .into(viewHolder.image);
   }
 
   @Override
@@ -109,7 +101,7 @@ public int getItemViewType(int position) {
   }
 
   @Override
-  public RequestBuilder getPreloadRequestBuilder(MediaStoreData item) {
+  public RequestBuilder<Drawable> getPreloadRequestBuilder(MediaStoreData item) {
     MediaStoreSignature signature =
         new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
     return requestBuilder
@@ -124,21 +116,13 @@ public RequestBuilder getPreloadRequestBuilder(MediaStoreData item) {
   }
 
   // Display#getSize(Point)
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
   @SuppressWarnings("deprecation")
-  private static int getWidth(Context context) {
+  private static int getScreenWidth(Context context) {
     WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
     Display display = wm.getDefaultDisplay();
-
-    final int result;
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
-      Point size = new Point();
-      display.getSize(size);
-      result = size.x;
-    } else {
-      result = display.getWidth();
-    }
-    return result;
+    Point size = new Point();
+    display.getSize(size);
+    return size.x;
   }
 
   /**
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index 54054fe42..e2931ad27 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -5,8 +5,9 @@ dependencies {
     compile(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile 'com.google.code.gson:gson:2.3'
+    compile 'com.google.code.gson:gson:2.4'
     compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
@@ -15,10 +16,10 @@ android {
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.giphy'
-        minSdkVersion 14
+        minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
-        versionName '1.0.0'
+        versionName '1.0'
     }
 
     compileOptions {
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index 4fa0d5d60..8d3ac29ac 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -4,9 +4,6 @@
 
     <uses-permission android:name="android.permission.INTERNET"/>
 
-    <uses-sdk android:minSdkVersion="14"
-      android:targetSdkVersion="22" />
-
     <application
         android:allowBackup="true"
         android:icon="@android:drawable/sym_def_app_icon"
@@ -23,10 +20,5 @@
             </intent-filter>
         </activity>
         <activity android:name=".FullscreenActivity"/>
-
-        <meta-data
-            android:name="com.bumptech.glide.samples.giphy.GiphyGlideModule"
-            android:value="GlideModule"/>
     </application>
-
 </manifest>
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
index b7c0de95a..921dc0db6 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java
@@ -1,11 +1,9 @@
 package com.bumptech.glide.samples.giphy;
 
-import com.google.gson.Gson;
-
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
-
+import com.google.gson.Gson;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -26,7 +24,7 @@
   private static final String TRENDING_PATH = "v1/gifs/trending";
   private final Handler bgHandler;
   private final Handler mainHandler;
-  private final HashSet<Monitor> monitors = new HashSet<Monitor>();
+  private final HashSet<Monitor> monitors = new HashSet<>();
 
   private static String signUrl(String url) {
     return url + "&api_key=" + BETA_KEY;
@@ -154,7 +152,7 @@ public String toString() {
    */
   public static class GifResult {
     public String id;
-    // Page url not gif url
+    // Page url not GIF url
     public String url;
     public GifUrlSet images;
 
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
index 47ef06e8e..fd796461e 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
@@ -2,8 +2,6 @@
 
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
 
-import com.google.gson.Gson;
-
 import android.app.Activity;
 import android.content.ClipData;
 import android.content.ClipboardManager;
@@ -14,7 +12,6 @@
 import android.os.Bundle;
 import android.view.View;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.DataSource;
@@ -22,6 +19,7 @@
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.request.RequestListener;
 import com.bumptech.glide.request.target.Target;
+import com.google.gson.Gson;
 
 /**
  * An {@link android.app.Activity} for displaying full size original GIFs.
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
index 7bc9bab9c..999600314 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -1,24 +1,24 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.content.Context;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
-
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import java.io.InputStream;
 
 /**
- * {@link com.bumptech.glide.module.GlideModule} implementation for the Giphy sample app.
+ * Configures Glide for the Giphy sample app.
  */
-public class GiphyGlideModule implements GlideModule {
+@GlideModule
+public class GiphyGlideModule extends AppGlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
+  public void registerComponents(Context context, Registry registry) {
+    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
   }
 
+  // Disable manifest parsing to avoid adding similar modules twice.
   @Override
-  public void registerComponents(Context context, Registry registry) {
-    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
+  public boolean isManifestParsingEnabled() {
+    return false;
   }
 }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index 3d27c6fe7..184e976ea 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -1,15 +1,12 @@
 package com.bumptech.glide.samples.giphy;
 
-import android.content.Context;
 import android.text.TextUtils;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import com.bumptech.glide.load.model.stream.BaseGlideUrlLoader;
-
 import java.io.InputStream;
 
 /**
@@ -31,8 +28,7 @@ public boolean handles(Api.GifResult model) {
 
 
     @Override
-    public ModelLoader<Api.GifResult, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index 80e9f4fed..3321f9ab7 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -12,13 +12,11 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.util.ViewPreloadSizeProvider;
-
 import java.util.Collections;
 import java.util.List;
 
@@ -145,7 +143,7 @@ public int getItemCount() {
     }
 
     @Override
-    public RequestBuilder getPreloadRequestBuilder(Api.GifResult item) {
+    public RequestBuilder<Drawable> getPreloadRequestBuilder(Api.GifResult item) {
       return requestBuilder.load(item);
     }
   }
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index 58a4e9f06..e244935ea 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -2,6 +2,7 @@ apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':library')
+    annotationProcessor project(':annotation:compiler')
     compile 'com.caverock:androidsvg:1.2.1'
 }
 
diff --git a/samples/svg/src/main/AndroidManifest.xml b/samples/svg/src/main/AndroidManifest.xml
index 218bbe4b5..7328e723d 100644
--- a/samples/svg/src/main/AndroidManifest.xml
+++ b/samples/svg/src/main/AndroidManifest.xml
@@ -4,17 +4,10 @@
 
     <uses-permission android:name="android.permission.INTERNET"/>
 
-    <uses-sdk
-            android:minSdkVersion="10"
-            android:targetSdkVersion="22" />
-
     <application
         android:allowBackup="true"
         android:icon="@android:drawable/sym_def_app_icon"
         android:label="@string/app_name">
-        <meta-data
-            android:name="com.bumptech.glide.samples.svg.SvgModule"
-            android:value="GlideModule"/>
         <activity
             android:name=".MainActivity"
             android:label="@string/app_name">
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
index b3cfcbfe0..372fbefb6 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -2,26 +2,26 @@
 
 import android.content.Context;
 import android.graphics.drawable.PictureDrawable;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import com.caverock.androidsvg.SVG;
-
 import java.io.InputStream;
 
 /**
  * Module for the SVG sample app.
  */
-public class SvgModule implements GlideModule {
-  @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
-  }
-
+@GlideModule
+public class SvgModule extends AppGlideModule {
   @Override
   public void registerComponents(Context context, Registry registry) {
     registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
         .append(InputStream.class, SVG.class, new SvgDecoder());
   }
+
+  // Disable manifest parsing to avoid adding similar modules twice.
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return false;
+  }
 }
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
index c3b4aa003..a28a21b7c 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
@@ -1,10 +1,7 @@
 package com.bumptech.glide.samples.svg;
 
-import android.annotation.TargetApi;
 import android.graphics.drawable.PictureDrawable;
-import android.os.Build;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.RequestListener;
@@ -16,16 +13,13 @@
  * {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on
  * a hardware backed {@link android.graphics.Canvas Canvas}.
  */
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class SvgSoftwareLayerSetter implements RequestListener<PictureDrawable> {
 
   @Override
   public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawable> target,
       boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
-    }
+    view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
     return false;
   }
 
@@ -33,9 +27,7 @@ public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawab
   public boolean onResourceReady(PictureDrawable resource, Object model,
       Target<PictureDrawable> target, DataSource dataSource, boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
-    }
+    view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
     return false;
   }
 }
diff --git a/scripts/update_javadocs.sh b/scripts/update_javadocs.sh
new file mode 100755
index 000000000..a8646613b
--- /dev/null
+++ b/scripts/update_javadocs.sh
@@ -0,0 +1,54 @@
+#!/bin/bash
+set -e
+set -o pipefail
+
+TEMP_DIR="/tmp/tmp_glide_javadoc"
+JAVADOC_GH_PAGES_DIR="javadocs"
+
+if [[ -z "$1" ]]; 
+then
+  echo "You must supply a target version"
+  echo "Usage ./scripts/update_javadocs.sh <400>"
+  exit 1
+fi
+
+if [[ $(git status -uno --porcelain) ]];
+then 
+  echo "One or more changes, commit or revert first."
+  git status -uno --porcelain
+  exit 1
+fi
+
+if [ -e "$JAVADOC_GH_PAGES_DIR" ];
+then 
+  echo "javadocs directory exists locally, remove first."
+  exit 1
+fi
+
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; 
+then 
+  echo "Origin and master are not up to date"
+  git rev-list master...origin/master --pretty
+  exit 1
+fi
+if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]]; 
+then 
+  echo "Origin and gh-pages are not up to date"
+  git rev-list gh-pages...origin/gh-pages --pretty
+  exit 1
+fi
+
+git checkout master
+GIT_COMMIT_SHA="$(git rev-parse HEAD)"   
+./gradlew clean releaseJavadocJar javadoc
+rm -rf $TEMP_DIR
+cp -r glide/build/docs/javadoc $TEMP_DIR
+git checkout gh-pages
+rm -rf "${JAVADOC_GH_PAGES_DIR}/${1}"
+cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$1
+rm -rf $TEMP_DIR
+git add "${JAVADOC_GH_PAGES_DIR}/$1" 
+git commit -m "Update javadocs for version $1" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
+echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${1} and committed"
+git log -1 --pretty=%B
+echo "Ready to push"
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index a27f1999b..c35434caa 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -122,7 +122,7 @@ afterEvaluate { project ->
             it.buildType.name.equalsIgnoreCase('release')
         }
 
-        task androidJavadocs(type: Javadoc, dependsOn: compileReleaseJava) {
+        task androidJavadocs(type: Javadoc, dependsOn: compileReleaseJavaWithJavac) {
             source = releaseVariants.collect { it.javaCompile.source }
             classpath = files(releaseVariants.collect { files(it.javaCompile.classpath.files,
                     project.android.bootClasspath) })
@@ -148,8 +148,8 @@ afterEvaluate { project ->
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
-        task androidLibraryJar(type: Jar, dependsOn: compileReleaseJava /* == variant.javaCompile */) {
-            from compileReleaseJava.destinationDir
+        task androidLibraryJar(type: Jar, dependsOn: compileReleaseJavaWithJavac /* == variant.javaCompile */) {
+            from compileReleaseJavaWithJavac.destinationDir
             exclude '**/R.class'
             exclude '**/BuildConfig.class'
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
diff --git a/settings.gradle b/settings.gradle
index 5239ec3ec..650b0e229 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,7 +1,9 @@
 exec {
-  commandLine "git", "submodule", "update", "--init", "--recursive"
+    commandLine "git", "submodule", "update", "--init", "--recursive"
 }
 include ':library'
+include ':annotation'
+include ':annotation:compiler'
 include ':glide'
 include ':third_party:gif_decoder'
 include ':third_party:disklrucache'
@@ -9,6 +11,7 @@ include ':samples:flickr'
 include ':samples:giphy'
 include ':samples:svg'
 include ':samples:gallery'
+include ':samples:contacturi'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
index d311d940f..54f7cbaf9 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestResourceUtil.java
@@ -17,7 +17,7 @@ private TestResourceUtil() {
    * @param subPath   The sub-path under androidTest/resources where the desired resource is
    *                  located. Should not be prefixed with a '/'
    */
-  public static InputStream openResource(Class testClass, String subPath) {
+  public static InputStream openResource(Class<?> testClass, String subPath) {
     return testClass.getResourceAsStream("/" + subPath);
   }
 }
diff --git a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
index 2d4ab7b5b..9c93de9e5 100644
--- a/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
+++ b/testutil/src/main/java/com/bumptech/glide/testutil/TestUtil.java
@@ -14,7 +14,7 @@ private TestUtil() {
     // Utility class.
   }
 
-  public static byte[] resourceToBytes(Class testClass, String resourceName) throws IOException {
+  public static byte[] resourceToBytes(Class<?> testClass, String resourceName) throws IOException {
     return isToBytes(TestResourceUtil.openResource(testClass, resourceName));
   }
 
@@ -33,7 +33,7 @@ private TestUtil() {
   }
 
   public static String isToString(InputStream is) throws IOException {
-    return new String(isToBytes(is));
+    return new String(isToBytes(is), "utf-8");
   }
 
   public static void assertStreamOf(String expected, InputStream result) throws IOException {
diff --git a/third_party/disklrucache b/third_party/disklrucache
index 743de2592..273f119c6 160000
--- a/third_party/disklrucache
+++ b/third_party/disklrucache
@@ -1 +1 @@
-Subproject commit 743de259274020cdef3de809b8537c0775043c8a
+Subproject commit 273f119c607eb55da0627ebb4a0c1b0d1a15b2dc
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index bd5aa45e0..16e6d54fb 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.library'
-apply plugin: 'org.robolectric'
 
 dependencies {
     compile "com.android.support:support-annotations:${SUPPORT_V4_VERSION}"
diff --git a/third_party/gif_decoder/gradle.properties b/third_party/gif_decoder/gradle.properties
index 75215b58f..9ada85d40 100644
--- a/third_party/gif_decoder/gradle.properties
+++ b/third_party/gif_decoder/gradle.properties
@@ -1,10 +1,4 @@
-POM_NAME=Glide Gif Decoder Library
+POM_NAME=Glide GIF Decoder Library
 POM_ARTIFACT_ID=gifdecoder
 POM_PACKAGING=aar
-
-VERSION_NAME=1.0.0-SNAPSHOT
-VERSION_MAJOR=1
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=Implementation of GifDecoder that is more memory efficient to animate for Android devices.
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index bab7cd168..257cd98f0 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -1,141 +1,33 @@
 package com.bumptech.glide.gifdecoder;
 
-/**
- * Copyright (c) 2013 Xcellent Creations, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.os.Build;
+import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.util.Log;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.io.InputStream;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.util.Arrays;
 
 /**
- * Reads frame data from a GIF image source and decodes it into individual frames for animation
- * purposes.  Image data can be read from either and InputStream source or a byte[].
- *
- * <p>This class is optimized for running animations with the frames, there are no methods to get
- * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
- * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
- * in the animation sequence.
- *
- * <p>The animation must be manually moved forward using {@link #advance()} before requesting the
- * next frame.  This method must also be called before you request the first frame or an error
- * will occur.
- *
- * <p>Implementation adapted from sample code published in Lyons. (2004). <em>Java for
- * Programmers</em>, republished under the MIT Open Source License
+ * Shared interface for GIF decoders.
  */
-public class GifDecoder {
-  private static final String TAG = GifDecoder.class.getSimpleName();
-
-  /**
-   * File read status: No errors.
-   */
-  public static final int STATUS_OK = 0;
-  /**
-   * File read status: Error decoding file (may be partially decoded).
-   */
-  public static final int STATUS_FORMAT_ERROR = 1;
-  /**
-   * File read status: Unable to open source.
-   */
-  public static final int STATUS_OPEN_ERROR = 2;
-  /**
-   * Unable to fully decode the current frame.
-   */
-  public static final int STATUS_PARTIAL_DECODE = 3;
-  /**
-   * max decoder pixel stack size.
-   */
-  private static final int MAX_STACK_SIZE = 4096;
-
-  /**
-   * GIF Disposal Method meaning take no action.
-   */
-  private static final int DISPOSAL_UNSPECIFIED = 0;
-  /**
-   * GIF Disposal Method meaning leave canvas from previous frame.
-   */
-  private static final int DISPOSAL_NONE = 1;
-  /**
-   * GIF Disposal Method meaning clear canvas to background color.
-   */
-  private static final int DISPOSAL_BACKGROUND = 2;
-  /**
-   * GIF Disposal Method meaning clear canvas to frame before last.
-   */
-  private static final int DISPOSAL_PREVIOUS = 3;
-
-  private static final int NULL_CODE = -1;
-
-  private static final int INITIAL_FRAME_POINTER = -1;
-
-  private static final int BYTES_PER_INTEGER = 4;
-
-  // Global File Header values and parsing flags.
-  // Active color table.
-  private int[] act;
-
-  // Raw GIF data from input source.
-  private ByteBuffer rawData;
-
-  // Raw data read working array.
-  private byte[] block;
-
-  // Temporary buffer for block reading. Reads 16k chunks from the native buffer for processing,
-  // to greatly reduce JNI overhead.
-  private static final int WORK_BUFFER_SIZE = 16384;
-  @Nullable private byte[] workBuffer;
-  private int workBufferSize = 0;
-  private int workBufferPosition = 0;
-
-  private GifHeaderParser parser;
+public interface GifDecoder {
+  /** File read status: No errors. */
+  int STATUS_OK = 0;
+  /** File read status: Error decoding file (may be partially decoded). */
+  int STATUS_FORMAT_ERROR = 1;
+  /** File read status: Unable to open source. */
+  int STATUS_OPEN_ERROR = 2;
+  /** Unable to fully decode the current frame. */
+  int STATUS_PARTIAL_DECODE = 3;
+  /** The total iteration count which means repeat forever. */
+  int TOTAL_ITERATION_COUNT_FOREVER = 0;
 
-  // LZW decoder working arrays.
-  private short[] prefix;
-  private byte[] suffix;
-  private byte[] pixelStack;
-  private byte[] mainPixels;
-  private int[] mainScratch;
-
-  private int framePointer;
-  private GifHeader header;
-  private BitmapProvider bitmapProvider;
-  private Bitmap previousImage;
-  private boolean savePrevious;
-  private int status;
-  private int sampleSize;
-  private int downsampledHeight;
-  private int downsampledWidth;
-  private boolean isFirstFrameTransparent;
+  /** Android Lint annotation for status codes that can be used with a GIF decoder. */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(value = {STATUS_OK, STATUS_FORMAT_ERROR, STATUS_OPEN_ERROR, STATUS_PARTIAL_DECODE})
+  @interface GifDecodeStatus {
+  }
 
   /**
    * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs
@@ -172,43 +64,20 @@
 
     /**
      * Returns an int array used for decoding/generating the frame bitmaps.
-     * @param size
      */
     int[] obtainIntArray(int size);
 
     /**
      * Release the given array back to the pool.
-     * @param array
      */
     void release(int[] array);
   }
 
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
-    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
-  }
-
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
-      int sampleSize) {
-    this(provider);
-    setData(gifHeader, rawData, sampleSize);
-  }
-
-  public GifDecoder(BitmapProvider provider) {
-    this.bitmapProvider = provider;
-    header = new GifHeader();
-  }
-
-  public int getWidth() {
-    return header.width;
-  }
+  int getWidth();
 
-  public int getHeight() {
-    return header.height;
-  }
+  int getHeight();
 
-  public ByteBuffer getData() {
-    return rawData;
-  }
+  ByteBuffer getData();
 
   /**
    * Returns the current status of the decoder.
@@ -217,16 +86,13 @@ public ByteBuffer getData() {
    * was decoded successfully and/or completely. Format and open failures persist across frames.
    * </p>
    */
-  public int getStatus() {
-    return status;
-  }
+  @GifDecodeStatus
+  int getStatus();
 
   /**
    * Move the animation frame counter forward.
    */
-  public void advance() {
-    framePointer = (framePointer + 1) % header.frameCount;
-  }
+  void advance();
 
   /**
    * Gets display duration for specified frame.
@@ -234,134 +100,95 @@ public void advance() {
    * @param n int index of frame.
    * @return delay in milliseconds.
    */
-  public int getDelay(int n) {
-    int delay = -1;
-    if ((n >= 0) && (n < header.frameCount)) {
-      delay = header.frames.get(n).delay;
-    }
-    return delay;
-  }
+  int getDelay(int n);
 
   /**
    * Gets display duration for the upcoming frame in ms.
    */
-  public int getNextDelay() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      return 0;
-    }
-
-    return getDelay(framePointer);
-  }
+  int getNextDelay();
 
   /**
    * Gets the number of frames read from file.
    *
    * @return frame count.
    */
-  public int getFrameCount() {
-    return header.frameCount;
-  }
+  int getFrameCount();
 
   /**
    * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
    *
    * @return frame index.
    */
-  public int getCurrentFrameIndex() {
-    return framePointer;
-  }
+  int getCurrentFrameIndex();
 
   /**
    * Resets the frame pointer to before the 0th frame, as if we'd never used this decoder to
    * decode any frames.
    */
-  public void resetFrameIndex() {
-    framePointer = INITIAL_FRAME_POINTER;
-  }
+  void resetFrameIndex();
 
   /**
-   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
+   * Gets the "Netscape" loop count, if any. A count of 0 means repeat indefinitely.
    *
-   * @return iteration count if one was specified, else 1.
+   * @deprecated Use {@link #getNetscapeLoopCount()} instead.
+   *             This method cannot distinguish whether the loop count is 1 or doesn't exist.
+   * @return loop count if one was specified, else 1.
    */
-  public int getLoopCount() {
-    return header.loopCount;
-  }
+  @Deprecated
+  int getLoopCount();
+
+  /**
+   * Gets the "Netscape" loop count, if any.
+   * A count of 0 ({@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <br>
+   * Use {@link #getTotalIterationCount()}
+   * to know how many times the animation sequence should be displayed.
+   *
+   * @return loop count if one was specified,
+   *         else -1 ({@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}).
+   */
+  int getNetscapeLoopCount();
+
+  /**
+   * Gets the total count
+   * which represents how many times the animation sequence should be displayed.
+   * A count of 0 ({@link #TOTAL_ITERATION_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <p>
+   *     The total count is calculated as follows by using {@link #getNetscapeLoopCount()}.
+   *     This behavior is the same as most web browsers.
+   *     <table border='1'>
+   *         <tr class='tableSubHeadingColor'><th>{@code getNetscapeLoopCount()}</th>
+   *             <th>The total count</th></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}</td>
+   *             <td>{@link #TOTAL_ITERATION_COUNT_FOREVER}</td></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}</td>
+   *             <td>{@code 1}</td></tr>
+   *         <tr><td>{@code n (n > 0)}</td>
+   *             <td>{@code n + 1}</td></tr>
+   *     </table>
+   * </p>
+   *
+   * @see <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=592735#c5">Discussion about
+   *      the iteration count of animated GIFs (Chromium Issue 592735)</a>
+   *
+   * @return total iteration count calculated from "Netscape" loop count.
+   */
+  int getTotalIterationCount();
 
   /**
    * Returns an estimated byte size for this decoder based on the data provided to {@link
    * #setData(GifHeader, byte[])}, as well as internal buffers.
    */
-  public int getByteSize() {
-    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
-  }
+  int getByteSize();
 
   /**
    * Get the next frame in the animation sequence.
    *
    * @return Bitmap representation of frame.
    */
-  public synchronized Bitmap getNextFrame() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
-            + framePointer);
-      }
-      status = STATUS_FORMAT_ERROR;
-    }
-    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unable to decode frame, status=" + status);
-      }
-      return null;
-    }
-    status = STATUS_OK;
-
-    GifFrame currentFrame = header.frames.get(framePointer);
-    GifFrame previousFrame = null;
-    int previousIndex = framePointer - 1;
-    if (previousIndex >= 0) {
-      previousFrame = header.frames.get(previousIndex);
-    }
-
-    final int savedBgColor = header.bgColor;
-
-    // Set the appropriate color table.
-    if (currentFrame.lct == null) {
-      act = header.gct;
-    } else {
-      act = currentFrame.lct;
-      if (header.bgIndex == currentFrame.transIndex) {
-        header.bgColor = 0;
-      }
-    }
-
-    int save = 0;
-    if (currentFrame.transparency) {
-      save = act[currentFrame.transIndex];
-      // Set transparent color if specified.
-      act[currentFrame.transIndex] = 0;
-    }
-    if (act == null) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "No Valid Color Table");
-      }
-      // No color table defined.
-      status = STATUS_FORMAT_ERROR;
-      return null;
-    }
-
-    // Transfer pixel data to image.
-    Bitmap result = setPixels(currentFrame, previousFrame);
-
-    // Reset the transparent pixel in the color table
-    if (currentFrame.transparency) {
-      act[currentFrame.transIndex] = save;
-    }
-    header.bgColor = savedBgColor;
-
-    return result;
-  }
+  Bitmap getNextFrame();
 
   /**
    * Reads GIF image from stream.
@@ -369,108 +196,16 @@ public synchronized Bitmap getNextFrame() {
    * @param is containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public int read(InputStream is, int contentLength) {
-    if (is != null) {
-      try {
-        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
-        int nRead;
-        byte[] data = new byte[16384];
-        while ((nRead = is.read(data, 0, data.length)) != -1) {
-          buffer.write(data, 0, nRead);
-        }
-        buffer.flush();
-
-        read(buffer.toByteArray());
-      } catch (IOException e) {
-        Log.w(TAG, "Error reading data from stream", e);
-      }
-    } else {
-      status = STATUS_OPEN_ERROR;
-    }
-
-    try {
-      if (is != null) {
-        is.close();
-      }
-    } catch (IOException e) {
-      Log.w(TAG, "Error closing stream", e);
-    }
-
-    return status;
-  }
+  @GifDecodeStatus
+  int read(InputStream is, int contentLength);
 
-  public void clear() {
-    header = null;
-    if (mainPixels != null) {
-      bitmapProvider.release(mainPixels);
-    }
-    if (mainScratch != null) {
-      bitmapProvider.release(mainScratch);
-    }
-    if (previousImage != null) {
-      bitmapProvider.release(previousImage);
-    }
-    previousImage = null;
-    rawData = null;
-    isFirstFrameTransparent = false;
-    if (block != null) {
-      bitmapProvider.release(block);
-    }
-    if (workBuffer != null) {
-      bitmapProvider.release(workBuffer);
-    }
-  }
-
-  public synchronized void setData(GifHeader header, byte[] data) {
-    setData(header, ByteBuffer.wrap(data));
-  }
-
-  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
-    setData(header, buffer, 1);
-  }
-
-  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
-    if (sampleSize <= 0) {
-      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
-    }
-    // Make sure sample size is a power of 2.
-    sampleSize = Integer.highestOneBit(sampleSize);
-    this.status = STATUS_OK;
-    this.header = header;
-    isFirstFrameTransparent = false;
-    framePointer = INITIAL_FRAME_POINTER;
-    // Initialize the raw data buffer.
-    rawData = buffer.asReadOnlyBuffer();
-    rawData.position(0);
-    rawData.order(ByteOrder.LITTLE_ENDIAN);
+  void clear();
 
-    // No point in specially saving an old frame if we're never going to use it.
-    savePrevious = false;
-    for (GifFrame frame : header.frames) {
-      if (frame.dispose == DISPOSAL_PREVIOUS) {
-        savePrevious = true;
-        break;
-      }
-    }
+  void setData(GifHeader header, byte[] data);
 
-    this.sampleSize = sampleSize;
-    // Now that we know the size, init scratch arrays.
-    // TODO: Find a way to avoid this entirely or at least downsample it
-    // (either should be possible).
-    mainPixels = bitmapProvider.obtainByteArray(header.width * header.height);
-    mainScratch =
-        bitmapProvider.obtainIntArray((header.width / sampleSize) * (header.height / sampleSize));
-    downsampledWidth = header.width / sampleSize;
-    downsampledHeight = header.height / sampleSize;
-  }
+  void setData(GifHeader header, ByteBuffer buffer);
 
-  private GifHeaderParser getHeaderParser() {
-    if (parser == null) {
-      parser = new GifHeaderParser();
-    }
-    return parser;
-  }
+  void setData(GifHeader header, ByteBuffer buffer, int sampleSize);
 
   /**
    * Reads GIF image from byte array.
@@ -478,385 +213,7 @@ private GifHeaderParser getHeaderParser() {
    * @param data containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public synchronized int read(byte[] data) {
-    this.header = getHeaderParser().setData(data).parseHeader();
-    if (data != null) {
-      setData(header, data);
-    }
-
-    return status;
-  }
-
-  /**
-   * Creates new frame image from current data (and previous frames as specified by their
-   * disposition codes).
-   */
-  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
-    // Final location of blended pixels.
-    final int[] dest = mainScratch;
-
-    // clear all pixels when meet first frame
-    if (previousFrame == null) {
-      Arrays.fill(dest, 0);
-    }
-
-    // fill in starting image contents based on last image's dispose code
-    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
-      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
-      // mainScratch and therefore so will our dest array.
-      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
-        // Start with a canvas filled with the background color
-        int c = 0;
-        if (!currentFrame.transparency) {
-          c = header.bgColor;
-        } else if (framePointer == 0) {
-          // TODO: We should check and see if all individual pixels are replaced. If they are, the
-          // first frame isn't actually transparent. For now, it's simpler and safer to assume
-          // drawing a transparent background means the GIF contains transparency.
-          isFirstFrameTransparent = true;
-        }
-        Arrays.fill(dest, c);
-      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
-        // Start with the previous frame
-        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-            downsampledHeight);
-      }
-    }
-
-    // Decode pixels for this frame into the global pixels[] scratch.
-    decodeBitmapData(currentFrame);
-
-    int downsampledIH = currentFrame.ih / sampleSize;
-    int downsampledIY = currentFrame.iy / sampleSize;
-    int downsampledIW = currentFrame.iw / sampleSize;
-    int downsampledIX = currentFrame.ix / sampleSize;
-    // Copy each source line to the appropriate place in the destination.
-    int pass = 1;
-    int inc = 8;
-    int iline = 0;
-    boolean isFirstFrame = framePointer == 0;
-    for (int i = 0; i < downsampledIH; i++) {
-      int line = i;
-      if (currentFrame.interlace) {
-        if (iline >= downsampledIH) {
-          pass++;
-          switch (pass) {
-            case 2:
-              iline = 4;
-              break;
-            case 3:
-              iline = 2;
-              inc = 4;
-              break;
-            case 4:
-              iline = 1;
-              inc = 2;
-              break;
-            default:
-              break;
-          }
-        }
-        line = iline;
-        iline += inc;
-      }
-      line += downsampledIY;
-      if (line < downsampledHeight) {
-        int k = line * downsampledWidth;
-        // Start of line in dest.
-        int dx = k + downsampledIX;
-        // End of dest line.
-        int dlim = dx + downsampledIW;
-        if (k + downsampledWidth < dlim) {
-          // Past dest edge.
-          dlim = k + downsampledWidth;
-        }
-        // Start of line in source.
-        int sx = i * sampleSize * currentFrame.iw;
-        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
-        while (dx < dlim) {
-          // Map color and insert in destination.
-          int averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
-          if (averageColor != 0) {
-            dest[dx] = averageColor;
-          } else if (!isFirstFrameTransparent && isFirstFrame) {
-            isFirstFrameTransparent = true;
-          }
-          sx += sampleSize;
-          dx++;
-        }
-      }
-    }
-
-    // Copy pixels into previous image
-    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
-        || currentFrame.dispose == DISPOSAL_NONE)) {
-      if (previousImage == null) {
-        previousImage = getNextBitmap();
-      }
-      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-          downsampledHeight);
-    }
-
-    // Set pixels for current image.
-    Bitmap result = getNextBitmap();
-    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
-    return result;
-  }
-
-  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
-      int currentFrameIw) {
-    int alphaSum = 0;
-    int redSum = 0;
-    int greenSum = 0;
-    int blueSum = 0;
-
-    int totalAdded = 0;
-    // Find the pixels in the current row.
-    for (int i = positionInMainPixels;
-        i < positionInMainPixels + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    // Find the pixels in the next row.
-    for (int i = positionInMainPixels + currentFrameIw;
-        i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    if (totalAdded == 0) {
-      return 0;
-    } else {
-      return ((alphaSum / totalAdded) << 24)
-          | ((redSum / totalAdded) << 16)
-          | ((greenSum / totalAdded) << 8)
-          | (blueSum / totalAdded);
-     }
-  }
-
-  /**
-   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
-   */
-  private void decodeBitmapData(GifFrame frame) {
-    workBufferSize = 0;
-    workBufferPosition = 0;
-    if (frame != null) {
-      // Jump to the frame start position.
-      rawData.position(frame.bufferFrameStart);
-    }
-
-    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
-    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
-        i, datum,
-        dataSize, first, top, bi, pi;
-
-    if (mainPixels == null || mainPixels.length < npix) {
-      // Allocate new pixel array.
-      mainPixels = bitmapProvider.obtainByteArray(npix);
-    }
-    if (prefix == null) {
-      prefix = new short[MAX_STACK_SIZE];
-    }
-    if (suffix == null) {
-      suffix = new byte[MAX_STACK_SIZE];
-    }
-    if (pixelStack == null) {
-      pixelStack = new byte[MAX_STACK_SIZE + 1];
-    }
-
-    // Initialize GIF data stream decoder.
-    dataSize = readByte();
-    clear = 1 << dataSize;
-    endOfInformation = clear + 1;
-    available = clear + 2;
-    oldCode = NULL_CODE;
-    codeSize = dataSize + 1;
-    codeMask = (1 << codeSize) - 1;
-    for (code = 0; code < clear; code++) {
-      // XXX ArrayIndexOutOfBoundsException.
-      prefix[code] = 0;
-      suffix[code] = (byte) code;
-    }
-
-    // Decode GIF pixel stream.
-    datum = bits = count = first = top = pi = bi = 0;
-    for (i = 0; i < npix; ) {
-      // Load bytes until there are enough bits for a code.
-      if (count == 0) {
-        // Read a new data block.
-        count = readBlock();
-        if (count <= 0) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-        bi = 0;
-      }
-
-      datum += (((int) block[bi]) & 0xff) << bits;
-      bits += 8;
-      bi++;
-      count--;
-
-      while (bits >= codeSize) {
-        // Get the next code.
-        code = datum & codeMask;
-        datum >>= codeSize;
-        bits -= codeSize;
-
-        // Interpret the code.
-        if (code == clear) {
-          // Reset decoder.
-          codeSize = dataSize + 1;
-          codeMask = (1 << codeSize) - 1;
-          available = clear + 2;
-          oldCode = NULL_CODE;
-          continue;
-        }
-
-        if (code > available) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-
-        if (code == endOfInformation) {
-          break;
-        }
-
-        if (oldCode == NULL_CODE) {
-          pixelStack[top++] = suffix[code];
-          oldCode = code;
-          first = code;
-          continue;
-        }
-        inCode = code;
-        if (code >= available) {
-          pixelStack[top++] = (byte) first;
-          code = oldCode;
-        }
-        while (code >= clear) {
-          pixelStack[top++] = suffix[code];
-          code = prefix[code];
-        }
-        first = ((int) suffix[code]) & 0xff;
-        pixelStack[top++] = (byte) first;
-
-        // Add a new string to the string table.
-        if (available < MAX_STACK_SIZE) {
-          prefix[available] = (short) oldCode;
-          suffix[available] = (byte) first;
-          available++;
-          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-            codeSize++;
-            codeMask += available;
-          }
-        }
-        oldCode = inCode;
-
-        while (top > 0) {
-          // Pop a pixel off the pixel stack.
-          mainPixels[pi++] = pixelStack[--top];
-          i++;
-        }
-      }
-    }
-
-    // Clear missing pixels.
-    for (i = pi; i < npix; i++) {
-      mainPixels[i] = 0;
-    }
-  }
-
-  /**
-   * Reads the next chunk for the intermediate work buffer.
-   */
-  private void readChunkIfNeeded() {
-    if (workBufferSize > workBufferPosition) {
-      return;
-    }
-    if (workBuffer == null) {
-      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
-    }
-    workBufferPosition = 0;
-    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
-    rawData.get(workBuffer, 0, workBufferSize);
-  }
-
-  /**
-   * Reads a single byte from the input stream.
-   */
-  private int readByte() {
-    try {
-      readChunkIfNeeded();
-      return workBuffer[workBufferPosition++] & 0xFF;
-    } catch (Exception e) {
-      status = STATUS_FORMAT_ERROR;
-      return 0;
-    }
-  }
-
-  /**
-   * Reads next variable length block from input.
-   *
-   * @return number of bytes stored in "buffer".
-   */
-  private int readBlock() {
-    int blockSize = readByte();
-    if (blockSize > 0) {
-      try {
-        if (block == null) {
-          block = bitmapProvider.obtainByteArray(255);
-        }
-        final int remaining = workBufferSize - workBufferPosition;
-        if (remaining >= blockSize) {
-          // Block can be read from the current work buffer.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
-          workBufferPosition += blockSize;
-        } else if (rawData.remaining() + remaining >= blockSize) {
-          // Block can be read in two passes.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
-          workBufferPosition = workBufferSize;
-          readChunkIfNeeded();
-          final int secondHalfRemaining = blockSize - remaining;
-          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
-          workBufferPosition += secondHalfRemaining;
-        } else {
-          status = STATUS_FORMAT_ERROR;
-        }
-      } catch (Exception e) {
-        Log.w(TAG, "Error Reading Block", e);
-        status = STATUS_FORMAT_ERROR;
-      }
-    }
-    return blockSize;
-  }
-
-  private Bitmap getNextBitmap() {
-    Bitmap.Config config = isFirstFrameTransparent
-        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
-    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
-    setAlpha(result);
-    return result;
-  }
+  @GifDecodeStatus
+  int read(byte[] data);
 
-  @TargetApi(12)
-  private static void setAlpha(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= 12) {
-      bitmap.setHasAlpha(true);
-    }
-  }
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
index 6da8c9e40..0a26cb756 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java
@@ -1,9 +1,57 @@
 package com.bumptech.glide.gifdecoder;
 
+import android.support.annotation.ColorInt;
+import android.support.annotation.IntDef;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
 /**
  * Inner model class housing metadata for each frame.
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 class GifFrame {
+  /**
+   * GIF Disposal Method meaning take no action.
+   * <p><b>GIF89a</b>: <i>No disposal specified.
+   * The decoder is not required to take any action.</i></p>
+   */
+  public static final int DISPOSAL_UNSPECIFIED = 0;
+  /**
+   * GIF Disposal Method meaning leave canvas from previous frame.
+   * <p><b>GIF89a</b>: <i>Do not dispose.
+   * The graphic is to be left in place.</i></p>
+   */
+  public static final int DISPOSAL_NONE = 1;
+  /**
+   * GIF Disposal Method meaning clear canvas to background color.
+   * <p><b>GIF89a</b>: <i>Restore to background color.
+   * The area used by the graphic must be restored to the background color.</i></p>
+   */
+  public static final int DISPOSAL_BACKGROUND = 2;
+  /**
+   * GIF Disposal Method meaning clear canvas to frame before last.
+   * <p><b>GIF89a</b>: <i>Restore to previous.
+   * The decoder is required to restore the area overwritten by the graphic
+   * with what was there prior to rendering the graphic.</i></p>
+   */
+  public static final int DISPOSAL_PREVIOUS = 3;
+
+  /**
+   * <p><b>GIF89a</b>:
+   * <i>Indicates the way in which the graphic is to be treated after being displayed.</i></p>
+   * Disposal methods 0-3 are defined, 4-7 are reserved for future use.
+   *
+   * @see #DISPOSAL_UNSPECIFIED
+   * @see #DISPOSAL_NONE
+   * @see #DISPOSAL_BACKGROUND
+   * @see #DISPOSAL_PREVIOUS
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(value = {DISPOSAL_UNSPECIFIED, DISPOSAL_NONE, DISPOSAL_BACKGROUND, DISPOSAL_PREVIOUS})
+  @interface GifDisposalMethod {
+  }
+
   int ix, iy, iw, ih;
   /**
    * Control Flag.
@@ -16,13 +64,14 @@
   /**
    * Disposal Method.
    */
+  @GifDisposalMethod
   int dispose;
   /**
    * Transparency Index.
    */
   int transIndex;
   /**
-   * Delay, in ms, to next frame.
+   * Delay, in milliseconds, to next frame.
    */
   int delay;
   /**
@@ -32,5 +81,6 @@
   /**
    * Local Color Table.
    */
+  @ColorInt
   int[] lct;
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index 5b57212ec..d43f7cca7 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.gifdecoder;
 
+import android.support.annotation.ColorInt;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -8,34 +9,46 @@
  * metadata like width and height that can be used to decode each individual frame of the GIF. Can
  * be shared by one or more {@link com.bumptech.glide.gifdecoder.GifDecoder}s to play the same
  * animated GIF in multiple views.
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 public class GifHeader {
 
+  /** The "Netscape" loop count which means loop forever. */
+  public static final int NETSCAPE_LOOP_COUNT_FOREVER = 0;
+  /** Indicates that this header has no "Netscape" loop count. */
+  public static final int NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST = -1;
+
+  @ColorInt
   int[] gct = null;
+  @GifDecoder.GifDecodeStatus
   int status = GifDecoder.STATUS_OK;
   int frameCount = 0;
 
   GifFrame currentFrame;
-  List<GifFrame> frames = new ArrayList<GifFrame>();
-  // Logical screen size.
-  // Full image width.
+  List<GifFrame> frames = new ArrayList<>();
+  /** Logical screen size: Full image width. */
   int width;
-  // Full image height.
+  /** Logical screen size: Full image height. */
   int height;
 
   // 1 : global color table flag.
   boolean gctFlag;
-  // 2-4 : color resolution.
-  // 5 : gct sort flag.
-  // 6-8 : gct size.
+  /**
+   * Size of Global Color Table.
+   * The value is already computed to be a regular number, this field doesn't store the exponent.
+   */
   int gctSize;
-  // Background color index.
+  /** Background color index into the Global/Local color table. */
   int bgIndex;
-  // Pixel aspect ratio.
+  /**
+   * Pixel aspect ratio.
+   * Factor used to compute an approximation of the aspect ratio of the pixel in the original image.
+   */
   int pixelAspect;
-  //TODO: this is set both during reading the header and while decoding frames...
+  @ColorInt
   int bgColor;
-  int loopCount;
+  int loopCount = NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
 
   public int getHeight() {
     return height;
@@ -52,6 +65,7 @@ public int getNumFrames() {
   /**
    * Global status code of GIF data parsing.
    */
+  @GifDecoder.GifDecodeStatus
   public int getStatus() {
     return status;
   }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index 3a0a16bb7..05662c04e 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -1,9 +1,10 @@
 package com.bumptech.glide.gifdecoder;
 
 import static com.bumptech.glide.gifdecoder.GifDecoder.STATUS_FORMAT_ERROR;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_NONE;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
 
 import android.util.Log;
-
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -11,15 +12,112 @@
 
 /**
  * A class responsible for creating {@link com.bumptech.glide.gifdecoder.GifHeader}s from data
- * representing animated gifs.
+ * representing animated GIFs.
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
  */
 public class GifHeaderParser {
   public static final String TAG = "GifHeaderParser";
 
-  // The minimum frame delay in hundredths of a second.
+  private static final int MASK_INT_LOWEST_BYTE = 0x000000FF;
+
+  /** Identifies the beginning of an Image Descriptor. */
+  private static final int IMAGE_SEPARATOR = 0x2C;
+  /** Identifies the beginning of an extension block. */
+  private static final int EXTENSION_INTRODUCER = 0x21;
+  /** This block is a single-field block indicating the end of the GIF Data Stream. */
+  private static final int TRAILER = 0x3B;
+  // Possible labels that identify the current extension block.
+  private static final int LABEL_GRAPHIC_CONTROL_EXTENSION = 0xF9;
+  private static final int LABEL_APPLICATION_EXTENSION = 0xFF;
+  private static final int LABEL_COMMENT_EXTENSION = 0xFE;
+  private static final int LABEL_PLAIN_TEXT_EXTENSION = 0x01;
+
+  // Graphic Control Extension packed field masks
+
+  private static final int GCE_MASK_RESERVED_BITS = 0b11100000;
+  /**
+   * Mask (bits 4-2) to extract Disposal Method of the current frame.
+   *
+   * @see GifFrame.GifDisposalMethod possible values
+   */
+  private static final int GCE_MASK_DISPOSAL_METHOD = 0b00011100;
+  /**
+   * Shift so the Disposal Method extracted from the packed value is on the least significant bit.
+   */
+  private static final int GCE_DISPOSAL_METHOD_SHIFT = 2;
+  private static final int GCE_MASK_USER_INPUT_FLAG = 0b00000010;
+  /**
+   * Mask (bit 0) to extract Transparent Color Flag of the current frame.
+   * <p><b>GIF89a</b>: <i>Indicates whether a transparency index is given
+   * in the Transparent Index field.</i></p>
+   * Possible values are:<ul>
+   * <li>0 - Transparent Index is not given.</li>
+   * <li>1 - Transparent Index is given.</li>
+   * </ul>
+   */
+  private static final int GCE_MASK_TRANSPARENT_COLOR_FLAG = 0b00000001;
+
+  // Image Descriptor packed field masks (describing Local Color Table)
+
+  /**
+   * Mask (bit 7) to extract Local Color Table Flag of the current image.
+   * <p><b>GIF89a</b>: <i>Indicates the presence of a Local Color Table
+   * immediately following this Image Descriptor.</i></p>
+   */
+  private static final int DESCRIPTOR_MASK_LCT_FLAG = 0b10000000;
+  /**
+   * Mask (bit 6) to extract Interlace Flag of the current image.
+   * <p><b>GIF89a</b>: <i>Indicates if the image is interlaced.
+   * An image is interlaced in a four-pass interlace pattern.</i></p>
+   * Possible values are:<ul>
+   * <li>0 - Image is not interlaced.</li>
+   * <li>1 - Image is interlaced.</li>
+   * </ul>
+   */
+  private static final int DESCRIPTOR_MASK_INTERLACE_FLAG = 0b01000000;
+  private static final int DESCRIPTOR_MASK_SORT_FLAG = 0b00100000;
+  private static final int DESCRIPTOR_MASK_RESERVED = 0b00011000;
+  /**
+   * Mask (bits 2-0) to extract Size of the Local Color Table of the current image.
+   * <p><b>GIF89a</b>: <i>If the Local Color Table Flag is set to 1, the value in this
+   * field is used to calculate the number of bytes contained in the Local Color Table.
+   * To determine that actual size of the color table, raise 2 to [the value of the field + 1].
+   * This value should be 0 if there is no Local Color Table specified.</i></p>
+   */
+  private static final int DESCRIPTOR_MASK_LCT_SIZE = 0b00000111;
+
+  // Logical Screen Descriptor packed field masks (describing Global Color Table)
+
+  /**
+   * Mask (bit 7) to extract Global Color Table Flag of the current image.
+   * <p><b>GIF89a</b>: <i>Indicates the presence of a Global Color Table
+   * immediately following this Image Descriptor.</i></p>
+   * Possible values are:<ul>
+   * <li>0 - No Global Color Table follows, the Background Color Index field is meaningless.</li>
+   * <li>1 - A Global Color Table will immediately follow,
+   * the Background Color Index field is meaningful.</li>
+   * </ul>
+   */
+  private static final int LSD_MASK_GCT_FLAG = 0b10000000;
+  private static final int LSD_MASK_COLOR_RESOLUTION = 0b01110000;
+  private static final int LSD_MASK_SORT_FLAG = 0b00001000;
+  /**
+   * Mask (bits 2-0) to extract Size of the Global Color Table of the current image.
+   * <p><b>GIF89a</b>: <i>If the Global Color Table Flag is set to 1, the value in this
+   * field is used to calculate the number of bytes contained in the Global Color Table.
+   * To determine that actual size of the color table, raise 2 to [the value of the field + 1].
+   * Even if there is no Global Color Table specified, set this field according to the above
+   * formula so that decoders can choose the best graphics mode to display the stream in.</i></p>
+   */
+  private static final int LSD_MASK_GCT_SIZE = 0b00000111;
+
+  /** The minimum frame delay in hundredths of a second. */
   static final int MIN_FRAME_DELAY = 2;
-  // The default frame delay in hundredths of a second for GIFs with frame delays less than the
-  // minimum.
+  /**
+   * The default frame delay in hundredths of a second.
+   * This is used for GIFs with frame delays less than the minimum.
+   */
   static final int DEFAULT_FRAME_DELAY = 10;
 
   private static final int MAX_BLOCK_SIZE = 256;
@@ -81,7 +179,7 @@ public GifHeader parseHeader() {
 
   /**
    * Determines if the GIF is animated by trying to read in the first 2 frames
-   * This method reparses the data even if the header has already been read.
+   * This method re-parses the data even if the header has already been read.
    */
   public boolean isAnimated() {
     readHeader();
@@ -107,30 +205,25 @@ private void readContents(int maxFrames) {
     while (!(done || err() || header.frameCount > maxFrames)) {
       int code = read();
       switch (code) {
-        // Image separator.
-        case 0x2C:
-          // The graphics control extension is optional, but will always come first if it exists.
-          // If one did
-          // exist, there will be a non-null current frame which we should use. However if one
-          // did not exist,
-          // the current frame will be null and we must create it here. See issue #134.
+        case IMAGE_SEPARATOR:
+          // The Graphic Control Extension is optional, but will always come first if it exists.
+          // If one did exist, there will be a non-null current frame which we should use.
+          // However if one did not exist, the current frame will be null
+          // and we must create it here. See issue #134.
           if (header.currentFrame == null) {
             header.currentFrame = new GifFrame();
           }
           readBitmap();
           break;
-        // Extension.
-        case 0x21:
-          code = read();
-          switch (code) {
-            // Graphics control extension.
-            case 0xf9:
+        case EXTENSION_INTRODUCER:
+          int extensionLabel = read();
+          switch (extensionLabel) {
+            case LABEL_GRAPHIC_CONTROL_EXTENSION:
               // Start a new frame.
               header.currentFrame = new GifFrame();
               readGraphicControlExt();
               break;
-            // Application extension.
-            case 0xff:
+            case LABEL_APPLICATION_EXTENSION:
               readBlock();
               String app = "";
               for (int i = 0; i < 11; i++) {
@@ -143,24 +236,22 @@ private void readContents(int maxFrames) {
                 skip();
               }
               break;
-            // Comment extension.
-            case 0xfe:
+            case LABEL_COMMENT_EXTENSION:
               skip();
               break;
-            // Plain text extension.
-            case 0x01:
+            case LABEL_PLAIN_TEXT_EXTENSION:
               skip();
               break;
-            // Uninteresting extension.
             default:
+              // Uninteresting extension.
               skip();
           }
           break;
-        // Terminator.
-        case 0x3b:
+        case TRAILER:
+          // This block is a single-field block indicating the end of the GIF Data Stream.
           done = true;
           break;
-        // Bad byte, but keep going and see what happens break;
+        // Bad byte, but keep going and see what happens
         case 0x00:
         default:
           header.status = STATUS_FORMAT_ERROR;
@@ -169,20 +260,31 @@ private void readContents(int maxFrames) {
   }
 
   /**
-   * Reads Graphics Control Extension values.
+   * Reads Graphic Control Extension values.
    */
   private void readGraphicControlExt() {
     // Block size.
     read();
-    // Packed fields.
+    /*
+     * Graphic Control Extension packed field:
+     *      7 6 5 4 3 2 1 0
+     *     +---------------+
+     *  1  |     |     | | |
+     *
+     * Reserved                    3 Bits
+     * Disposal Method             3 Bits
+     * User Input Flag             1 Bit
+     * Transparent Color Flag      1 Bit
+     */
     int packed = read();
     // Disposal method.
-    header.currentFrame.dispose = (packed & 0x1c) >> 2;
-    if (header.currentFrame.dispose == 0) {
+    //noinspection WrongConstant field has to be extracted from packed value
+    header.currentFrame.dispose = (packed & GCE_MASK_DISPOSAL_METHOD) >> GCE_DISPOSAL_METHOD_SHIFT;
+    if (header.currentFrame.dispose == DISPOSAL_UNSPECIFIED) {
       // Elect to keep old image if discretionary.
-      header.currentFrame.dispose = 1;
+      header.currentFrame.dispose = DISPOSAL_NONE;
     }
-    header.currentFrame.transparency = (packed & 1) != 0;
+    header.currentFrame.transparency = (packed & GCE_MASK_TRANSPARENT_COLOR_FLAG) != 0;
     // Delay in milliseconds.
     int delayInHundredthsOfASecond = readShort();
     // TODO: consider allowing -1 to indicate show forever.
@@ -206,16 +308,23 @@ private void readBitmap() {
     header.currentFrame.iw = readShort();
     header.currentFrame.ih = readShort();
 
+    /*
+     * Image Descriptor packed field:
+     *     7 6 5 4 3 2 1 0
+     *    +---------------+
+     * 9  | | | |   |     |
+     *
+     * Local Color Table Flag     1 Bit
+     * Interlace Flag             1 Bit
+     * Sort Flag                  1 Bit
+     * Reserved                   2 Bits
+     * Size of Local Color Table  3 Bits
+     */
     int packed = read();
-    // 1 - local color table flag interlace
-    boolean lctFlag = (packed & 0x80) != 0;
-    int lctSize = (int) Math.pow(2, (packed & 0x07) + 1);
-    // 3 - sort flag
-    // 4-5 - reserved lctSize = 2 << (packed & 7); // 6-8 - local color
-    // table size
-    header.currentFrame.interlace = (packed & 0x40) != 0;
+    boolean lctFlag = (packed & DESCRIPTOR_MASK_LCT_FLAG) != 0;
+    int lctSize = (int) Math.pow(2, (packed & DESCRIPTOR_MASK_LCT_SIZE) + 1);
+    header.currentFrame.interlace = (packed & DESCRIPTOR_MASK_INTERLACE_FLAG) != 0;
     if (lctFlag) {
-      // Read table.
       header.currentFrame.lct = readColorTable(lctSize);
     } else {
       // No local color table.
@@ -245,8 +354,8 @@ private void readNetscapeExt() {
       readBlock();
       if (block[0] == 1) {
         // Loop count sub-block.
-        int b1 = ((int) block[1]) & 0xff;
-        int b2 = ((int) block[2]) & 0xff;
+        int b1 = ((int) block[1]) & MASK_INT_LOWEST_BYTE;
+        int b2 = ((int) block[2]) & MASK_INT_LOWEST_BYTE;
         header.loopCount = (b2 << 8) | b1;
       }
     } while ((blockSize > 0) && !err());
@@ -279,14 +388,20 @@ private void readLSD() {
     // Logical screen size.
     header.width = readShort();
     header.height = readShort();
-    // Packed fields
+    /*
+     * Logical Screen Descriptor packed field:
+     *      7 6 5 4 3 2 1 0
+     *     +---------------+
+     *  4  | |     | |     |
+     *
+     * Global Color Table Flag     1 Bit
+     * Color Resolution            3 Bits
+     * Sort Flag                   1 Bit
+     * Size of Global Color Table  3 Bits
+     */
     int packed = read();
-    // 1 : global color table flag.
-    header.gctFlag = (packed & 0x80) != 0;
-    // 2-4 : color resolution.
-    // 5 : gct sort flag.
-    // 6-8 : gct size.
-    header.gctSize = 2 << (packed & 7);
+    header.gctFlag = (packed & LSD_MASK_GCT_FLAG) != 0;
+    header.gctSize = (int) Math.pow(2, (packed & LSD_MASK_GCT_SIZE) + 1);
     // Background color index.
     header.bgIndex = read();
     // Pixel aspect ratio
@@ -296,13 +411,13 @@ private void readLSD() {
   /**
    * Reads color table as 256 RGB integer values.
    *
-   * @param ncolors int number of colors to read.
+   * @param nColors int number of colors to read.
    * @return int array containing 256 colors (packed ARGB with full alpha).
    */
-  private int[] readColorTable(int ncolors) {
-    int nbytes = 3 * ncolors;
+  private int[] readColorTable(int nColors) {
+    int nBytes = 3 * nColors;
     int[] tab = null;
-    byte[] c = new byte[nbytes];
+    byte[] c = new byte[nBytes];
 
     try {
       rawData.get(c);
@@ -312,11 +427,11 @@ private void readLSD() {
       tab = new int[MAX_BLOCK_SIZE];
       int i = 0;
       int j = 0;
-      while (i < ncolors) {
-        int r = ((int) c[j++]) & 0xff;
-        int g = ((int) c[j++]) & 0xff;
-        int b = ((int) c[j++]) & 0xff;
-        tab[i++] = 0xff000000 | (r << 16) | (g << 8) | b;
+      while (i < nColors) {
+        int r = ((int) c[j++]) & MASK_INT_LOWEST_BYTE;
+        int g = ((int) c[j++]) & MASK_INT_LOWEST_BYTE;
+        int b = ((int) c[j++]) & MASK_INT_LOWEST_BYTE;
+        tab[i++] = 0xFF000000 | (r << 16) | (g << 8) | b;
       }
     } catch (BufferUnderflowException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -345,7 +460,8 @@ private void skip() {
     int blockSize;
     do {
       blockSize = read();
-      rawData.position(rawData.position() + blockSize);
+      int newPosition = Math.min(rawData.position() + blockSize, rawData.limit());
+      rawData.position(newPosition);
     } while (blockSize > 0);
   }
 
@@ -381,13 +497,13 @@ private int readBlock() {
    * Reads a single byte from the input stream.
    */
   private int read() {
-    int curByte = 0;
+    int currByte = 0;
     try {
-      curByte = rawData.get() & 0xFF;
+      currByte = rawData.get() & MASK_INT_LOWEST_BYTE;
     } catch (Exception e) {
       header.status = STATUS_FORMAT_ERROR;
     }
-    return curByte;
+    return currByte;
   }
 
   /**
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
new file mode 100644
index 000000000..80825fb09
--- /dev/null
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -0,0 +1,786 @@
+package com.bumptech.glide.gifdecoder;
+
+/*
+ * Copyright (c) 2013 Xcellent Creations, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_BACKGROUND;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_NONE;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_PREVIOUS;
+import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
+
+import android.graphics.Bitmap;
+import android.support.annotation.ColorInt;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+/**
+ * Reads frame data from a GIF image source and decodes it into individual frames for animation
+ * purposes.  Image data can be read from either and InputStream source or a byte[].
+ *
+ * <p>This class is optimized for running animations with the frames, there are no methods to get
+ * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
+ * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
+ * in the animation sequence.
+ *
+ * <p>The animation must be manually moved forward using {@link #advance()} before requesting the
+ * next frame.  This method must also be called before you request the first frame or an error
+ * will occur.
+ *
+ * <p>Implementation adapted from sample code published in Lyons. (2004). <em>Java for
+ * Programmers</em>, republished under the MIT Open Source License
+ *
+ * @see <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF 89a Specification</a>
+ */
+public class StandardGifDecoder implements GifDecoder {
+  private static final String TAG = StandardGifDecoder.class.getSimpleName();
+
+  /** Maximum pixel stack size for decoding LZW compressed data. */
+  private static final int MAX_STACK_SIZE = 4 * 1024;
+
+  private static final int NULL_CODE = -1;
+
+  private static final int INITIAL_FRAME_POINTER = -1;
+
+  private static final int BYTES_PER_INTEGER = Integer.SIZE / 8;
+
+  private static final int MASK_INT_LOWEST_BYTE = 0x000000FF;
+
+  @ColorInt
+  private static final int COLOR_TRANSPARENT_BLACK = 0x00000000;
+
+  // Global File Header values and parsing flags.
+  /**
+   * Active color table.
+   * Maximum size is 256, see GifHeaderParser.readColorTable
+   */
+  @ColorInt
+  private int[] act;
+  /** Private color table that can be modified if needed. */
+  @ColorInt
+  private final int[] pct = new int[256];
+
+  /** Raw GIF data from input source. */
+  private ByteBuffer rawData;
+
+  /** Raw data read working array. */
+  private byte[] block;
+
+  private static final int WORK_BUFFER_SIZE = 16 * 1024;
+  /**
+   * Temporary buffer for block reading.
+   * Reads 16k chunks from the native buffer for processing, to greatly reduce JNI overhead.
+   */
+  @Nullable private byte[] workBuffer;
+  private int workBufferSize = 0;
+  private int workBufferPosition = 0;
+
+  private GifHeaderParser parser;
+
+  // LZW decoder working arrays.
+  private short[] prefix;
+  private byte[] suffix;
+  private byte[] pixelStack;
+  private byte[] mainPixels;
+  @ColorInt
+  private int[] mainScratch;
+
+  private int framePointer;
+  private GifHeader header;
+  private GifDecoder.BitmapProvider bitmapProvider;
+  private Bitmap previousImage;
+  private boolean savePrevious;
+  @GifDecodeStatus
+  private int status;
+  private int sampleSize;
+  private int downsampledHeight;
+  private int downsampledWidth;
+  private boolean isFirstFrameTransparent;
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
+    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
+  }
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
+      int sampleSize) {
+    this(provider);
+    setData(gifHeader, rawData, sampleSize);
+  }
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider) {
+    this.bitmapProvider = provider;
+    header = new GifHeader();
+  }
+
+  @Override
+  public int getWidth() {
+    return header.width;
+  }
+
+  @Override
+  public int getHeight() {
+    return header.height;
+  }
+
+  @Override
+  public ByteBuffer getData() {
+    return rawData;
+  }
+
+  @Override
+  public int getStatus() {
+    return status;
+  }
+
+  @Override
+  public void advance() {
+    framePointer = (framePointer + 1) % header.frameCount;
+  }
+
+  @Override
+  public int getDelay(int n) {
+    int delay = -1;
+    if ((n >= 0) && (n < header.frameCount)) {
+      delay = header.frames.get(n).delay;
+    }
+    return delay;
+  }
+
+  @Override
+  public int getNextDelay() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      return 0;
+    }
+
+    return getDelay(framePointer);
+  }
+
+  @Override
+  public int getFrameCount() {
+    return header.frameCount;
+  }
+
+  @Override
+  public int getCurrentFrameIndex() {
+    return framePointer;
+  }
+
+  @Override
+  public void resetFrameIndex() {
+    framePointer = INITIAL_FRAME_POINTER;
+  }
+
+  @Override
+  public int getLoopCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
+    return header.loopCount;
+  }
+
+  @Override
+  public int getNetscapeLoopCount() {
+    return header.loopCount;
+  }
+
+  @Override
+  public int getTotalIterationCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_FOREVER) {
+      return TOTAL_ITERATION_COUNT_FOREVER;
+    }
+    return header.loopCount + 1;
+  }
+
+  @Override
+  public int getByteSize() {
+    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
+  }
+
+  @Override
+  public synchronized Bitmap getNextFrame() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to decode frame"
+            + ", frameCount=" + header.frameCount
+            + ", framePointer=" + framePointer
+        );
+      }
+      status = STATUS_FORMAT_ERROR;
+    }
+    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to decode frame, status=" + status);
+      }
+      return null;
+    }
+    status = STATUS_OK;
+
+    GifFrame currentFrame = header.frames.get(framePointer);
+    GifFrame previousFrame = null;
+    int previousIndex = framePointer - 1;
+    if (previousIndex >= 0) {
+      previousFrame = header.frames.get(previousIndex);
+    }
+
+    // Set the appropriate color table.
+    act = currentFrame.lct != null ? currentFrame.lct : header.gct;
+    if (act == null) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "No valid color table found for frame #" + framePointer);
+      }
+      // No color table defined.
+      status = STATUS_FORMAT_ERROR;
+      return null;
+    }
+
+    // Reset the transparent pixel in the color table
+    if (currentFrame.transparency) {
+      // Prepare local copy of color table ("pct = act"), see #1068
+      System.arraycopy(act, 0, pct, 0, act.length);
+      // Forget about act reference from shared header object, use copied version
+      act = pct;
+      // Set transparent color if specified.
+      act[currentFrame.transIndex] = COLOR_TRANSPARENT_BLACK;
+    }
+
+    // Transfer pixel data to image.
+    return setPixels(currentFrame, previousFrame);
+  }
+
+  @Override
+  public int read(InputStream is, int contentLength) {
+    if (is != null) {
+      try {
+        int capacity = (contentLength > 0) ? (contentLength + 4 * 1024) : 16 * 1024;
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
+        int nRead;
+        byte[] data = new byte[16 * 1024];
+        while ((nRead = is.read(data, 0, data.length)) != -1) {
+          buffer.write(data, 0, nRead);
+        }
+        buffer.flush();
+
+        read(buffer.toByteArray());
+      } catch (IOException e) {
+        Log.w(TAG, "Error reading data from stream", e);
+      }
+    } else {
+      status = STATUS_OPEN_ERROR;
+    }
+
+    try {
+      if (is != null) {
+        is.close();
+      }
+    } catch (IOException e) {
+      Log.w(TAG, "Error closing stream", e);
+    }
+
+    return status;
+  }
+
+  @Override
+  public void clear() {
+    header = null;
+    if (mainPixels != null) {
+      bitmapProvider.release(mainPixels);
+    }
+    if (mainScratch != null) {
+      bitmapProvider.release(mainScratch);
+    }
+    if (previousImage != null) {
+      bitmapProvider.release(previousImage);
+    }
+    previousImage = null;
+    rawData = null;
+    isFirstFrameTransparent = false;
+    if (block != null) {
+      bitmapProvider.release(block);
+    }
+    if (workBuffer != null) {
+      bitmapProvider.release(workBuffer);
+    }
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, byte[] data) {
+    setData(header, ByteBuffer.wrap(data));
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
+    setData(header, buffer, 1);
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
+    if (sampleSize <= 0) {
+      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
+    }
+    // Make sure sample size is a power of 2.
+    sampleSize = Integer.highestOneBit(sampleSize);
+    this.status = STATUS_OK;
+    this.header = header;
+    isFirstFrameTransparent = false;
+    framePointer = INITIAL_FRAME_POINTER;
+    // Initialize the raw data buffer.
+    rawData = buffer.asReadOnlyBuffer();
+    rawData.position(0);
+    rawData.order(ByteOrder.LITTLE_ENDIAN);
+
+    // No point in specially saving an old frame if we're never going to use it.
+    savePrevious = false;
+    for (GifFrame frame : header.frames) {
+      if (frame.dispose == DISPOSAL_PREVIOUS) {
+        savePrevious = true;
+        break;
+      }
+    }
+
+    this.sampleSize = sampleSize;
+    downsampledWidth = header.width / sampleSize;
+    downsampledHeight = header.height / sampleSize;
+    // Now that we know the size, init scratch arrays.
+    // TODO Find a way to avoid this entirely or at least downsample it (either should be possible).
+    mainPixels = bitmapProvider.obtainByteArray(header.width * header.height);
+    mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);
+  }
+
+  private GifHeaderParser getHeaderParser() {
+    if (parser == null) {
+      parser = new GifHeaderParser();
+    }
+    return parser;
+  }
+
+  @Override
+  @GifDecodeStatus
+  public synchronized int read(byte[] data) {
+    this.header = getHeaderParser().setData(data).parseHeader();
+    if (data != null) {
+      setData(header, data);
+    }
+
+    return status;
+  }
+
+  /**
+   * Creates new frame image from current data (and previous frames as specified by their
+   * disposition codes).
+   */
+  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
+    // Final location of blended pixels.
+    final int[] dest = mainScratch;
+
+    // clear all pixels when meet first frame
+    if (previousFrame == null) {
+      Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);
+    }
+
+    // fill in starting image contents based on last image's dispose code
+    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
+      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
+      // mainScratch and therefore so will our dest array.
+      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
+        // Start with a canvas filled with the background color
+        @ColorInt int c = COLOR_TRANSPARENT_BLACK;
+        if (!currentFrame.transparency) {
+          c = header.bgColor;
+          if (currentFrame.lct != null && header.bgIndex == currentFrame.transIndex) {
+            c = COLOR_TRANSPARENT_BLACK;
+          }
+        } else if (framePointer == 0) {
+          // TODO: We should check and see if all individual pixels are replaced. If they are, the
+          // first frame isn't actually transparent. For now, it's simpler and safer to assume
+          // drawing a transparent background means the GIF contains transparency.
+          isFirstFrameTransparent = true;
+        }
+        // The area used by the graphic must be restored to the background color.
+        int downsampledIH = previousFrame.ih / sampleSize;
+        int downsampledIY = previousFrame.iy / sampleSize;
+        int downsampledIW = previousFrame.iw / sampleSize;
+        int downsampledIX = previousFrame.ix / sampleSize;
+        int topLeft = downsampledIY * downsampledWidth + downsampledIX;
+        int bottomLeft = topLeft + downsampledIH * downsampledWidth;
+        for (int left = topLeft; left < bottomLeft; left += downsampledWidth) {
+          int right = left + downsampledIW;
+          for (int pointer = left; pointer < right; pointer++) {
+            dest[pointer] = c;
+          }
+        }
+      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
+        // Start with the previous frame
+        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+            downsampledHeight);
+      }
+    }
+
+    // Decode pixels for this frame into the global pixels[] scratch.
+    decodeBitmapData(currentFrame);
+
+    int downsampledIH = currentFrame.ih / sampleSize;
+    int downsampledIY = currentFrame.iy / sampleSize;
+    int downsampledIW = currentFrame.iw / sampleSize;
+    int downsampledIX = currentFrame.ix / sampleSize;
+    // Copy each source line to the appropriate place in the destination.
+    int pass = 1;
+    int inc = 8;
+    int iline = 0;
+    boolean isFirstFrame = framePointer == 0;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i;
+      if (currentFrame.interlace) {
+        if (iline >= downsampledIH) {
+          pass++;
+          switch (pass) {
+            case 2:
+              iline = 4;
+              break;
+            case 3:
+              iline = 2;
+              inc = 4;
+              break;
+            case 4:
+              iline = 1;
+              inc = 2;
+              break;
+            default:
+              break;
+          }
+        }
+        line = iline;
+        iline += inc;
+      }
+      line += downsampledIY;
+      if (line < downsampledHeight) {
+        int k = line * downsampledWidth;
+        // Start of line in dest.
+        int dx = k + downsampledIX;
+        // End of dest line.
+        int dlim = dx + downsampledIW;
+        if (k + downsampledWidth < dlim) {
+          // Past dest edge.
+          dlim = k + downsampledWidth;
+        }
+        // Start of line in source.
+        int sx = i * sampleSize * currentFrame.iw;
+        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+        while (dx < dlim) {
+          // Map color and insert in destination.
+          @ColorInt int averageColor;
+          if (sampleSize == 1) {
+            int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;
+            averageColor = act[currentColorIndex];
+          } else {
+            // TODO: This is substantially slower (up to 50ms per frame) than just grabbing the
+            // current color index above, even with a sample size of 1.
+            averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+          }
+          if (averageColor != COLOR_TRANSPARENT_BLACK) {
+            dest[dx] = averageColor;
+          } else if (!isFirstFrameTransparent && isFirstFrame) {
+            isFirstFrameTransparent = true;
+          }
+          sx += sampleSize;
+          dx++;
+        }
+      }
+    }
+
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
+
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  @ColorInt
+  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
+      int currentFrameIw) {
+    int alphaSum = 0;
+    int redSum = 0;
+    int greenSum = 0;
+    int blueSum = 0;
+
+    int totalAdded = 0;
+    // Find the pixels in the current row.
+    for (int i = positionInMainPixels;
+         i < positionInMainPixels + sampleSize && i < mainPixels.length
+             && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & MASK_INT_LOWEST_BYTE;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & MASK_INT_LOWEST_BYTE;
+        redSum += currentColor >> 16 & MASK_INT_LOWEST_BYTE;
+        greenSum += currentColor >> 8 & MASK_INT_LOWEST_BYTE;
+        blueSum += currentColor & MASK_INT_LOWEST_BYTE;
+        totalAdded++;
+      }
+    }
+    // Find the pixels in the next row.
+    for (int i = positionInMainPixels + currentFrameIw;
+         i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
+             && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & MASK_INT_LOWEST_BYTE;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & MASK_INT_LOWEST_BYTE;
+        redSum += currentColor >> 16 & MASK_INT_LOWEST_BYTE;
+        greenSum += currentColor >> 8 & MASK_INT_LOWEST_BYTE;
+        blueSum += currentColor & MASK_INT_LOWEST_BYTE;
+        totalAdded++;
+      }
+    }
+    if (totalAdded == 0) {
+      return COLOR_TRANSPARENT_BLACK;
+    } else {
+      return ((alphaSum / totalAdded) << 24)
+          | ((redSum / totalAdded) << 16)
+          | ((greenSum / totalAdded) << 8)
+          | (blueSum / totalAdded);
+    }
+  }
+
+  /**
+   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
+   */
+  private void decodeBitmapData(GifFrame frame) {
+    workBufferSize = 0;
+    workBufferPosition = 0;
+    if (frame != null) {
+      // Jump to the frame start position.
+      rawData.position(frame.bufferFrameStart);
+    }
+
+    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
+    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
+        i, datum, dataSize, first, top, bi, pi;
+
+    if (mainPixels == null || mainPixels.length < npix) {
+      // Allocate new pixel array.
+      mainPixels = bitmapProvider.obtainByteArray(npix);
+    }
+    if (prefix == null) {
+      prefix = new short[MAX_STACK_SIZE];
+    }
+    if (suffix == null) {
+      suffix = new byte[MAX_STACK_SIZE];
+    }
+    if (pixelStack == null) {
+      pixelStack = new byte[MAX_STACK_SIZE + 1];
+    }
+
+    // Initialize GIF data stream decoder.
+    dataSize = readByte();
+    clear = 1 << dataSize;
+    endOfInformation = clear + 1;
+    available = clear + 2;
+    oldCode = NULL_CODE;
+    codeSize = dataSize + 1;
+    codeMask = (1 << codeSize) - 1;
+    for (code = 0; code < clear; code++) {
+      // XXX ArrayIndexOutOfBoundsException.
+      prefix[code] = 0;
+      suffix[code] = (byte) code;
+    }
+
+    // Decode GIF pixel stream.
+    datum = bits = count = first = top = pi = bi = 0;
+    for (i = 0; i < npix; ) {
+      // Load bytes until there are enough bits for a code.
+      if (count == 0) {
+        // Read a new data block.
+        count = readBlock();
+        if (count <= 0) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
+        }
+        bi = 0;
+      }
+
+      datum += (((int) block[bi]) & MASK_INT_LOWEST_BYTE) << bits;
+      bits += 8;
+      bi++;
+      count--;
+
+      while (bits >= codeSize) {
+        // Get the next code.
+        code = datum & codeMask;
+        datum >>= codeSize;
+        bits -= codeSize;
+
+        // Interpret the code.
+        if (code == clear) {
+          // Reset decoder.
+          codeSize = dataSize + 1;
+          codeMask = (1 << codeSize) - 1;
+          available = clear + 2;
+          oldCode = NULL_CODE;
+          continue;
+        }
+
+        if (code > available) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
+        }
+
+        if (code == endOfInformation) {
+          break;
+        }
+
+        if (oldCode == NULL_CODE) {
+          pixelStack[top++] = suffix[code];
+          oldCode = code;
+          first = code;
+          continue;
+        }
+        inCode = code;
+        if (code >= available) {
+          pixelStack[top++] = (byte) first;
+          code = oldCode;
+        }
+        while (code >= clear) {
+          pixelStack[top++] = suffix[code];
+          code = prefix[code];
+        }
+        first = ((int) suffix[code]) & MASK_INT_LOWEST_BYTE;
+        pixelStack[top++] = (byte) first;
+
+        // Add a new string to the string table.
+        if (available < MAX_STACK_SIZE) {
+          prefix[available] = (short) oldCode;
+          suffix[available] = (byte) first;
+          available++;
+          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
+            codeSize++;
+            codeMask += available;
+          }
+        }
+        oldCode = inCode;
+
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi++] = pixelStack[--top];
+          i++;
+        }
+      }
+    }
+
+    // Clear missing pixels.
+    for (i = pi; i < npix; i++) {
+      mainPixels[i] = COLOR_TRANSPARENT_BLACK;
+    }
+  }
+
+  /**
+   * Reads the next chunk for the intermediate work buffer.
+   */
+  private void readChunkIfNeeded() {
+    if (workBufferSize > workBufferPosition) {
+      return;
+    }
+    if (workBuffer == null) {
+      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
+    }
+    workBufferPosition = 0;
+    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
+    rawData.get(workBuffer, 0, workBufferSize);
+  }
+
+  /**
+   * Reads a single byte from the input stream.
+   */
+  private int readByte() {
+    try {
+      readChunkIfNeeded();
+      return workBuffer[workBufferPosition++] & MASK_INT_LOWEST_BYTE;
+    } catch (Exception e) {
+      status = STATUS_FORMAT_ERROR;
+      return 0;
+    }
+  }
+
+  /**
+   * Reads next variable length block from input.
+   *
+   * @return number of bytes stored in "buffer".
+   */
+  private int readBlock() {
+    int blockSize = readByte();
+    if (blockSize > 0) {
+      try {
+        if (block == null) {
+          block = bitmapProvider.obtainByteArray(255);
+        }
+        final int remaining = workBufferSize - workBufferPosition;
+        if (remaining >= blockSize) {
+          // Block can be read from the current work buffer.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
+          workBufferPosition += blockSize;
+        } else if (rawData.remaining() + remaining >= blockSize) {
+          // Block can be read in two passes.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
+          workBufferPosition = workBufferSize;
+          readChunkIfNeeded();
+          final int secondHalfRemaining = blockSize - remaining;
+          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
+          workBufferPosition += secondHalfRemaining;
+        } else {
+          status = STATUS_FORMAT_ERROR;
+        }
+      } catch (Exception e) {
+        Log.w(TAG, "Error Reading Block", e);
+        status = STATUS_FORMAT_ERROR;
+      }
+    }
+    return blockSize;
+  }
+
+  private Bitmap getNextBitmap() {
+    Bitmap.Config config = isFirstFrameTransparent
+        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
+    result.setHasAlpha(true);
+    return result;
+  }
+}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 9b1b600b0..13a581303 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -7,9 +7,9 @@
 
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
-
 import com.bumptech.glide.testutil.TestUtil;
-
+import java.io.IOException;
+import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -20,9 +20,6 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowBitmap;
 
-import java.io.IOException;
-import java.util.Arrays;
-
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
  */
@@ -43,7 +40,7 @@ public void testCanDecodeFramesFromTestGif() throws IOException {
     GifHeaderParser headerParser = new GifHeaderParser();
     headerParser.setData(data);
     GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(header, data);
     decoder.advance();
     Bitmap bitmap = decoder.getNextFrame();
@@ -56,17 +53,47 @@ public void testFrameIndexStartsAtNegativeOne() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
 
+  @Test
+  public void testTotalIterationCountIsOneIfNetscapeLoopCountDoesntExist() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(1, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsForeverIfNetscapeLoopCountIsForever() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_FOREVER;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsTwoIfNetscapeLoopCountIsOne() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = 1;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(2, decoder.getTotalIterationCount());
+  }
+
   @Test
   public void testAdvanceIncrementsFrameIndex() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     assertEquals(0, decoder.getCurrentFrameIndex());
@@ -77,7 +104,7 @@ public void testAdvanceWrapsIndexBackToZero() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 2;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -90,7 +117,7 @@ public void testSettingDataResetsFramePointer() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -108,7 +135,7 @@ public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalBackgroun
     GifHeaderParser headerParser = new GifHeaderParser();
     headerParser.setData(data);
     GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(header, data);
     decoder.advance();
     Bitmap firstFrame = decoder.getNextFrame();
@@ -127,7 +154,7 @@ public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalNone() th
     GifHeaderParser headerParser = new GifHeaderParser();
     headerParser.setData(data);
     GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(header, data);
     decoder.advance();
     Bitmap firstFrame = decoder.getNextFrame();
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index 22f2e5c78..55dfa41a4 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -8,16 +8,14 @@
 
 import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;
 import com.bumptech.glide.testutil.TestUtil;
-
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.GifHeaderParser}.
  */
@@ -67,6 +65,58 @@ public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOEx
     assertEquals(GifDecoder.STATUS_OK, header.status);
   }
 
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIsZero() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_0.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_FOREVER, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_1() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_1.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(1, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x0F()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_255.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(255, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x10()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_256.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(256, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0xFF()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_65535.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(65535, header.loopCount);
+  }
+
+  @Test
+  public void testLoopCountReturnsMinusOneWithoutNetscapeIterationCount()
+          throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_without_netscape_iteration.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST, header.loopCount);
+  }
+
   @Test
   public void testCanReadImageDescriptorWithoutGraphicalExtension() {
     final int lzwMinCodeSize = 2;
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
index 680f49d09..f09e8596e 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
@@ -2,13 +2,12 @@
 
 import static org.junit.Assert.assertArrayEquals;
 
+import java.nio.ByteBuffer;
+import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.test.GifBytesTestUtil}.
  */
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif
new file mode 100644
index 000000000..3dd7c1cb6
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif
new file mode 100644
index 000000000..480dc8c64
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif
new file mode 100644
index 000000000..62a489ea2
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif
new file mode 100644
index 000000000..c0443cd42
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif
new file mode 100644
index 000000000..b976157c3
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif
new file mode 100644
index 000000000..f67b1b6bf
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif differ
diff --git a/third_party/gif_encoder/README.third_party b/third_party/gif_encoder/README.third_party
index 981a8a04d..40fafebcb 100644
--- a/third_party/gif_encoder/README.third_party
+++ b/third_party/gif_encoder/README.third_party
@@ -4,7 +4,7 @@ License: Notice
 License File: LICENSE
 
 Description:
-Android port of a gif encoder.
+Android port of a GIF encoder.
 
 See also:
 http://members.ozemail.com.au/~dekker/NEUQUANT.HTML
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index e08a214f7..7bb25acab 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -5,7 +5,6 @@
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.util.Log;
-
 import java.io.BufferedOutputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -191,7 +190,7 @@ public boolean addFrame(Bitmap im, int x, int y) {
             getImagePixels(); // convert to correct format if necessary
             analyzePixels(); // build color table & map pixels
             if (firstFrame) {
-                writeLSD(); // logical screen descriptior
+                writeLSD(); // logical screen descriptor
                 writePalette(); // global color table
                 if (repeat >= 0) {
                     // use NS app extension to indicate reps
@@ -222,7 +221,7 @@ public boolean finish() {
         boolean ok = true;
         started = false;
         try {
-            out.write(0x3b); // gif trailer
+            out.write(0x3b); // GIF trailer
             out.flush();
             if (closeStream) {
                 out.close();
