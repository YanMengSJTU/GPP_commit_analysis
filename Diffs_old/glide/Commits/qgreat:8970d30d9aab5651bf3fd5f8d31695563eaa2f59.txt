diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index f7cfe9fca..a3d2b4e8e 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -229,6 +229,11 @@ private static void initializeGlide(@NonNull Context context) {
     initializeGlide(context, new GlideBuilder());
   }
 
+  /**
+   * 初始化Glide相关配置
+   * @param context
+   * @param builder
+   */
   @SuppressWarnings("deprecation")
   private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
     Context applicationContext = context.getApplicationContext();
@@ -273,6 +278,7 @@ private static void initializeGlide(@NonNull Context context, @NonNull GlideBuil
     if (annotationGeneratedModule != null) {
       annotationGeneratedModule.applyOptions(applicationContext, builder);
     }
+    //新建 Glide
     Glide glide = builder.build(applicationContext);
     for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       try {
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index d1c5d8816..0cb51167a 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -467,6 +467,11 @@ GlideBuilder setEngine(Engine engine) {
     return this;
   }
 
+  /**
+   * 初始化requestManagerRetriever，Executor，Calculator，memoryCache等等
+   * @param context
+   * @return
+   */
   @NonNull
   Glide build(@NonNull Context context) {
     if (sourceExecutor == null) {
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index b6c580555..46958d9be 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -91,6 +91,13 @@ public synchronized RequestOptions getDefaultRequestOptions() {
     return (TransitionOptions<?, T>) result;
   }
 
+  /**
+   * 创建一个target对象
+   * @param imageView
+   * @param transcodeClass
+   * @param <X>
+   * @return
+   */
   @NonNull
   public <X> ViewTarget<ImageView, X> buildImageViewTarget(
       @NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 5e89d0815..5e0b008f0 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -1,9 +1,5 @@
 package com.bumptech.glide;
 
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
-import static com.bumptech.glide.request.RequestOptions.signatureOf;
-import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
-
 import android.annotation.SuppressLint;
 import android.content.Context;
 import android.graphics.Bitmap;
@@ -15,6 +11,7 @@
 import android.support.annotation.Nullable;
 import android.support.annotation.RawRes;
 import android.widget.ImageView;
+
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.request.BaseRequestOptions;
@@ -35,1049 +32,1069 @@
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
+
 import java.io.File;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Executor;
 
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
+import static com.bumptech.glide.request.RequestOptions.signatureOf;
+import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
+
 /**
  * A generic class that can handle setting options and staring loads for generic resource types.
  *
  * @param <TranscodeType> The type of resource that will be delivered to the
- * {@link com.bumptech.glide.request.target.Target}.
+ *                        {@link com.bumptech.glide.request.target.Target}.
  */
 // Public API.
 @SuppressWarnings({"unused", "WeakerAccess"})
 public class RequestBuilder<TranscodeType> extends BaseRequestOptions<RequestBuilder<TranscodeType>>
-    implements Cloneable,
-    ModelTypes<RequestBuilder<TranscodeType>> {
-  // Used in generated subclasses
-  protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
-      new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
-          .skipMemoryCache(true);
-
-  private final Context context;
-  private final RequestManager requestManager;
-  private final Class<TranscodeType> transcodeClass;
-  private final Glide glide;
-  private final GlideContext glideContext;
-
-  @NonNull
-  @SuppressWarnings("unchecked")
-  private TransitionOptions<?, ? super TranscodeType> transitionOptions;
-
-  @Nullable private Object model;
-  // model may occasionally be null, so to enforce that load() was called, put a boolean rather
-  // than relying on model not to be null.
-  @Nullable private List<RequestListener<TranscodeType>> requestListeners;
-  @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
-  @Nullable private RequestBuilder<TranscodeType> errorBuilder;
-  @Nullable private Float thumbSizeMultiplier;
-  private boolean isDefaultTransitionOptionsSet = true;
-  private boolean isModelSet;
-  private boolean isThumbnailBuilt;
-
-  // We only override the method to change the return type, not the functionality.
-  @SuppressLint("CheckResult")
-  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
-  protected RequestBuilder(
-      @NonNull Glide glide,
-      RequestManager requestManager,
-      Class<TranscodeType> transcodeClass,
-      Context context) {
-    this.glide = glide;
-    this.requestManager = requestManager;
-    this.transcodeClass = transcodeClass;
-    this.context = context;
-    this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
-    this.glideContext = glide.getGlideContext();
-
-    initRequestListeners(requestManager.getDefaultRequestListeners());
-    apply(requestManager.getDefaultRequestOptions());
-  }
-
-  @SuppressLint("CheckResult")
-  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
-  protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
-    this(other.glide, other.requestManager, transcodeClass, other.context);
-    model = other.model;
-    isModelSet = other.isModelSet;
-
-    // This is safe because it will always mutate, no one else has access to the object.
-    apply(other);
-  }
-
-  // Casting from Object to a specific type is always safe.
-  @SuppressWarnings("unchecked")
-  // addListener always returns the same instance.
-  @SuppressLint("CheckResult")
-  private void initRequestListeners(List<RequestListener<Object>> requestListeners) {
-    for (RequestListener<Object> listener : requestListeners) {
-      addListener((RequestListener<TranscodeType>) listener);
-    }
-  }
-
-  /**
-   * Applies the given options to the request.
-   *
-   * <p>As with {@link RequestOptions#apply(BaseRequestOptions)}, {@code #apply} only replaces those
-   * values that are explicitly set in the given {@link RequestOptions} object. If you need to
-   * completely reset all previously set options, create a new {@code RequestBuilder} instead of
-   * using this method.
-   *
-   * @see RequestOptions#apply(BaseRequestOptions)
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
-    Preconditions.checkNotNull(requestOptions);
-    return super.apply(requestOptions);
-  }
-
-  /**
-   * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
-   * this load completes.
-   *
-   * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
-   * previously.
-   *
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<TranscodeType> transition(
-      @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
-    this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
-    isDefaultTransitionOptionsSet = false;
-    return this;
-  }
-
-  /**
-   * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single
-   * instance of an exception handler per type of request (usually activity/fragment) rather than
-   * pass one in per request to avoid some redundant object allocation.
-   *
-   * <p>Subsequent calls to this method will replace previously set listeners. To set multiple
-   * listeners, use {@link #addListener} instead.
-   *
-   * @param requestListener The request listener to use.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> listener(
-      @Nullable RequestListener<TranscodeType> requestListener) {
-    this.requestListeners = null;
-    return addListener(requestListener);
-  }
-
-  /**
-   * Adds a {@link RequestListener}. If called multiple times, all passed
-   * {@link RequestListener listeners} will be called in order.
-   *
-   * @param requestListener The request listener to use. If {@code null}, this method is a noop.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  public RequestBuilder<TranscodeType> addListener(
-      @Nullable RequestListener<TranscodeType> requestListener) {
-    if (requestListener != null) {
-      if (this.requestListeners == null) {
-        this.requestListeners = new ArrayList<>();
-      }
-      this.requestListeners.add(requestListener);
-    }
-    return this;
-  }
-
-  /**
-   * Sets a {@link RequestBuilder} that is built and run if the load started by this
-   * {@link RequestBuilder} fails.
-   *
-   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
-   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
-   *
-   * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
-   * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
-   *
-   * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
-   * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
-   * Options like priority, override widths and heights and transitions must be applied
-   * independently to the error builder.
-   *
-   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
-   * if it's set on this {@link RequestBuilder} via
-   * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
-   * {@link RequestOptions#fallback(int)}.
-   *
-   * @return This {@link RequestBuilder}.
-   */
-  @NonNull
-  public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
-    this.errorBuilder = errorBuilder;
-    return this;
-  }
-
-  /**
-   * Loads and displays the resource retrieved by the given thumbnail request if it finishes before
-   * this request. Best used for loading thumbnail resources that are smaller and will be loaded
-   * more quickly than the full size resource. There are no guarantees about the order in which the
-   * requests will actually finish. However, if the thumb request completes after the full request,
-   * the thumb resource will never replace the full resource.
-   *
-   * <p>Recursive calls to thumbnail are supported.
-   *
-   * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
-   * {@link #thumbnail(RequestBuilder[])}.
-   *
-   * @see #thumbnail(float)
-   * @see #thumbnail(RequestBuilder[])
-   *
-   * @param thumbnailRequest The request to use to load the thumbnail.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> thumbnail(
-      @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
-    this.thumbnailBuilder = thumbnailRequest;
-
-    return this;
-  }
-
-  /**
-   * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
-   * loaded as thumbnails in the given priority order.
-   *
-   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
-   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
-   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
-   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
-   *
-   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
-   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
-   * {@link #thumbnail(RequestBuilder)} with {@code null}.
-   *
-   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
-   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
-   * chain.
-   *
-   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
-   * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
-   *
-   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
-   * {@link #thumbnail(float)} and this method.
-   *
-   * @see #thumbnail(float)
-   * @see #thumbnail(RequestBuilder)
-   *
-   * @return This request builder.
-   */
-  @SuppressWarnings({"CheckResult", "unchecked"})
-  @NonNull
-  @CheckResult
-  public RequestBuilder<TranscodeType> thumbnail(
-      @Nullable RequestBuilder<TranscodeType>... thumbnails) {
-    if (thumbnails == null || thumbnails.length == 0) {
-      return thumbnail((RequestBuilder<TranscodeType>) null);
-    }
-
-    RequestBuilder<TranscodeType> previous = null;
-
-    // Start with the lowest priority thumbnail so that we can safely handle mutations if
-    // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
-    // Starting with the highest priority thumbnail would prevent us from assigning the result of
-    // thumbnail because the mutated request wouldn't be used in the next iteration.
-    for (int i = thumbnails.length - 1; i >= 0; i--) {
-      RequestBuilder<TranscodeType> current = thumbnails[i];
-      // Ignore null thumbnails.
-      if (current == null) {
-        continue;
-      }
-
-      if (previous == null) {
-        // If we don't yet have our first non-null request, set it and continue.
-        previous = current;
-      } else {
-        // Otherwise make our next lowest priority request the thumbnail of our current request.
-        previous = current.thumbnail(previous);
-      }
-    }
-    return thumbnail(previous);
-  }
-
-  /**
-   * Loads a resource in an identical manner to this request except with the dimensions of the
-   * target multiplied by the given size multiplier. If the thumbnail load completes before the full
-   * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
-   * load, the thumbnail will not be shown.
-   *
-   * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
-   * {@link ImageView}) must be able to scale the thumbnail appropriately. See
-   * {@link android.widget.ImageView.ScaleType}.
-   *
-   * <p>Almost all options will be copied from the original load, including the {@link
-   * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
-   * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
-   * {@link #listener(RequestListener)} will only be used on the full size load and will not be
-   * copied for the thumbnail load.
-   *
-   * <p>Recursive calls to thumbnail are supported.
-   *
-   * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
-   *  and {@link #thumbnail(RequestBuilder)}.
-   *
-   * @see #thumbnail(RequestBuilder)
-   * @see #thumbnail(RequestBuilder[])
-   *
-   * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
-   *                       the thumbnail.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-    }
-    this.thumbSizeMultiplier = sizeMultiplier;
-
-    return this;
-  }
-
-  /**
-   * Sets the specific model to load data for.
-   *
-   * @param model The model to load data for, or null.
-   * @return This request builder.
-   */
-  @NonNull
-  @CheckResult
-  @SuppressWarnings("unchecked")
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Object model) {
-    return loadGeneric(model);
-  }
-
-  @NonNull
-  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
-    this.model = model;
-    isModelSet = true;
-    return this;
-  }
-  /**
-   * Returns an object to load the given {@link Bitmap}.
-   *
-   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
-   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
-   * not supported by Glide by default, consider registering a custom
-   * {@link com.bumptech.glide.load.model.ModelLoader} or
-   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
-   *
-   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
-   * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
-   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
-   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
-   *
-   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
-   * compared.
-   *
-   * @see #load(Object)
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
-    return loadGeneric(bitmap)
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
-  }
-
-  /**
-   * Returns a request builder to load the given {@link Drawable}.
-   *
-   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
-   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
-   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
-   * {@link com.bumptech.glide.load.model.ModelLoader} or
-   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
-   *
-   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
-   * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
-   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
-   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
-   *
-   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
-   * compared.
-   *
-   * @see #load(Object)
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
-    return loadGeneric(drawable)
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
-  }
-
-  /**
-   * Returns a request builder to load the given {@link java.lang.String}.
-   *
-   * <p> Note - this method caches data using only the given String as the cache key. If the data is
-   * a Uri outside of your control, or you otherwise expect the data represented by the given String
-   * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create that identifies the data currently at the given String that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
-   * </p>
-   *
-   * @see #load(Object)
-   *
-   * @param string A file path, or a uri or url handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
-   */
-  @NonNull
-  @Override
-  @CheckResult
-  public RequestBuilder<TranscodeType> load(@Nullable String string) {
-    return loadGeneric(string);
-  }
-
-  /**
-   * Returns a request builder to load the given {@link Uri}.
-   *
-   * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
-   * represented by Uris from some content providers may change without the Uri changing, which
-   * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
-   * mixin a signature you create based on the data at the given Uri that will invalidate the cache
-   * if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate. </p>
-   *
-   * @see #load(Object)
-   *
-   * @param uri The Uri representing the image. Must be of a type handled by
-   * {@link com.bumptech.glide.load.model.UriLoader}.
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
-    return loadGeneric(uri);
-  }
-
-  /**
-   * Returns a request builder to load the given {@link File}.
-   *
-   * <p>Note - this method caches data for Files using only the file path itself as the cache key.
-   * The data in the File can change so using this method can lead to displaying stale data. If you
-   * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
-   * to mixin a signature you create that identifies the data currently in the File that will
-   * invalidate the cache if that data changes. Alternatively, using
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
-   * appropriate.
-   *
-   * @see #load(Object)
-   *
-   * @param file The File containing the image
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable File file) {
-    return loadGeneric(file);
-  }
-
-  /**
-   * Returns a request builder that uses the
-   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
-   * {@link Integer} to load the image represented by the given {@link Integer} resource id.
-   * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
-   *
-   * <p>By default this method adds a version code based signature to the cache key used to cache
-   * this resource in Glide. This signature is sufficient to guarantee that end users will see the
-   * most up to date versions of your Drawables, but during development if you do not increment your
-   * version code before each install and you replace a Drawable with different data without
-   * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
-   * during development, and re-enabling the default
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
-   *
-   * <p>This method will load non-{@link android.graphics.Bitmap} resources like
-   * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
-   * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
-   * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
-   * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
-   * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
-   * load failures if a {@link Drawable} can't be transformed, use the optional transformation
-   * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
-   *
-   * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
-   * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
-   * caution for non-{@link Bitmap} {@link Drawable}s.
-   *
-   * @see #load(Integer)
-   * @see com.bumptech.glide.signature.ApplicationVersionSignature
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
-    return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
-  }
-
-  /**
-   * Returns a request builder to load the given {@link URL}.
-   *
-   * @param url The URL representing the image.
-   * @see #load(Object)
-   * @deprecated The {@link java.net.URL} class has
-   * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
-   * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
-   */
-  @Deprecated
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable URL url) {
-    return loadGeneric(url);
-  }
-
-  /**
-   * Returns a request to load the given byte array.
-   *
-   * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
-   *
-   * @param model the data to load.
-   * @see #load(Object)
-   */
-  @NonNull
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
-    RequestBuilder<TranscodeType> result = loadGeneric(model);
-    if (!result.isDiskCacheStrategySet()) {
-        result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
-    }
-    if (!result.isSkipMemoryCacheSet()) {
-      result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
-    }
-    return result;
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   */
-  @SuppressWarnings({
-      "unchecked",
-      // we don't want to throw to be user friendly
-      "PMD.CloneThrowsCloneNotSupportedException"
-  })
-  @CheckResult
-  @Override
-  public RequestBuilder<TranscodeType> clone() {
-    RequestBuilder<TranscodeType> result = super.clone();
-    result.transitionOptions = result.transitionOptions.clone();
-    return result;
-  }
-
-  /**
-   * Set the target the resource will be loaded into.
-   *
-   * @param target The target to load the resource into.
-   * @return The given target.
-   * @see RequestManager#clear(Target)
-   */
-  @NonNull
-  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
-    return into(target, /*targetListener=*/ null, Executors.mainThreadExecutor());
-  }
-
-  @NonNull
-  @Synthetic
-  <Y extends Target<TranscodeType>> Y into(
-      @NonNull Y target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      Executor callbackExecutor) {
-    return into(target, targetListener, /*options=*/ this, callbackExecutor);
-  }
-
-  private <Y extends Target<TranscodeType>> Y into(
-      @NonNull Y target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      BaseRequestOptions<?> options,
-      Executor callbackExecutor) {
-    Preconditions.checkNotNull(target);
-    if (!isModelSet) {
-      throw new IllegalArgumentException("You must call #load() before calling #into()");
-    }
-
-    Request request = buildRequest(target, targetListener, options, callbackExecutor);
-
-    Request previous = target.getRequest();
-    if (request.isEquivalentTo(previous)
-        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
-      request.recycle();
-      // If the request is completed, beginning again will ensure the result is re-delivered,
-      // triggering RequestListeners and Targets. If the request is failed, beginning again will
-      // restart the request, giving it another chance to complete. If the request is already
-      // running, we can let it continue running without interruption.
-      if (!Preconditions.checkNotNull(previous).isRunning()) {
-        // Use the previous request rather than the new one to allow for optimizations like skipping
-        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
-        // that are done in the individual Request.
-        previous.begin();
-      }
-      return target;
-    }
-
-    requestManager.clear(target);
-    target.setRequest(request);
-    requestManager.track(target, request);
-
-    return target;
-  }
-
-  // If the caller is using skipMemoryCache and the previous request is finished, calling begin on
-  // the previous request will complete from memory because it will just use the resource that had
-  // already been loaded. If the previous request isn't complete, we can wait for it to finish
-  // because the previous request must also be using skipMemoryCache for the requests to be
-  // equivalent. See #2663 for additional context.
-  private boolean isSkipMemoryCacheWithCompletePreviousRequest(
-      BaseRequestOptions<?> options, Request previous) {
-    return !options.isMemoryCacheable() && previous.isComplete();
-  }
-
-  /**
-   * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
-   * the view, and frees any resources Glide may have previously loaded into the view so they may be
-   * reused.
-   *
-   * @see RequestManager#clear(Target)
-   *
-   * @param view The view to cancel previous loads for and load the new resource into.
-   * @return The
-   * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
-   */
-  @NonNull
-  public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
-    Util.assertMainThread();
-    Preconditions.checkNotNull(view);
-
-    BaseRequestOptions<?> requestOptions = this;
-    if (!requestOptions.isTransformationSet()
-        && requestOptions.isTransformationAllowed()
-        && view.getScaleType() != null) {
-      // Clone in this method so that if we use this RequestBuilder to load into a View and then
-      // into a different target, we don't retain the transformation applied based on the previous
-      // View's scale type.
-      switch (view.getScaleType()) {
-        case CENTER_CROP:
-          requestOptions = requestOptions.clone().optionalCenterCrop();
-          break;
-        case CENTER_INSIDE:
-          requestOptions = requestOptions.clone().optionalCenterInside();
-          break;
-        case FIT_CENTER:
-        case FIT_START:
-        case FIT_END:
-          requestOptions = requestOptions.clone().optionalFitCenter();
-          break;
-        case FIT_XY:
-          requestOptions = requestOptions.clone().optionalCenterInside();
-          break;
-        case CENTER:
-        case MATRIX:
-        default:
-          // Do nothing.
-      }
-    }
-
-    return into(
-        glideContext.buildImageViewTarget(view, transcodeClass),
-        /*targetListener=*/ null,
-        requestOptions,
-        Executors.mainThreadExecutor());
-  }
-
-  /**
-   * Returns a future that can be used to do a blocking get on a background thread.
-   *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
-   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   * @see RequestManager#clear(Target)
-   *
-   * @deprecated Use {@link #submit(int, int)} instead.
-   */
-  @Deprecated
-  public FutureTarget<TranscodeType> into(int width, int height) {
-    return submit(width, height);
-  }
-
-  /**
-   * Returns a future that can be used to do a blocking get on a background thread.
-   *
-   * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
-   * since the width and height will be overridden by values passed to {@link
-   * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
-   * with override values are applied, or whenever you want to retrieve the image in its original
-   * size.
-   *
-   * @see #submit(int, int)
-   * @see #into(Target)
-   */
-  @NonNull
-  public FutureTarget<TranscodeType> submit() {
-    return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
-  }
-
-  /**
-   * Returns a future that can be used to do a blocking get on a background thread.
-   *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
-   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   */
-  @NonNull
-  public FutureTarget<TranscodeType> submit(int width, int height) {
-    final RequestFutureTarget<TranscodeType> target = new RequestFutureTarget<>(width, height);
-    return into(target, target, Executors.directExecutor());
-  }
-
-  /**
-   * Preloads the resource into the cache using the given width and height.
-   *
-   * <p> Pre-loading is useful for making sure that resources you are going to to want in the near
-   * future are available quickly. </p>
-   *
-   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
-   *               previously called.
-   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
-   *               overridden by
-   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
-   *               previously called).
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}.
-   * @see com.bumptech.glide.ListPreloader
-   */
-  @NonNull
-  public Target<TranscodeType> preload(int width, int height) {
-    final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
-    return into(target);
-  }
-
-  /**
-   * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and
-   * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as
-   * the width and height.
-   *
-   * @return A {@link Target} that can be used to cancel the load via
-   * {@link RequestManager#clear(Target)}
-   * @see #preload(int, int)
-   */
-  @NonNull
-  public Target<TranscodeType> preload() {
-    return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
-  }
-
-  /**
-   * Loads the original unmodified data into the cache and calls the given Target with the cache
-   * File.
-   *
-   * @param target The Target that will receive the cache File when the load completes
-   * @param <Y>    The type of Target.
-   * @return The given Target.
-   *
-   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
-   */
-  @Deprecated
-  @CheckResult
-  public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
-    return getDownloadOnlyRequest().into(target);
-  }
-
-  /**
-   * Loads the original unmodified data into the cache and returns a
-   * {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the
-   * data.
-   *
-   * @param width  The width in pixels to use to fetch the data.
-   * @param height The height in pixels to use to fetch the data.
-   * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
-   * containing the data.
-   *
-   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #submit(int, int)}.
-   */
-  @Deprecated
-  @CheckResult
-  public FutureTarget<File> downloadOnly(int width, int height) {
-    return getDownloadOnlyRequest().submit(width, height);
-  }
-
-  @NonNull
-  @CheckResult
-  protected RequestBuilder<File> getDownloadOnlyRequest() {
-    return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
-  }
-
-  @NonNull
-  private Priority getThumbnailPriority(@NonNull Priority current) {
-    switch (current) {
-      case LOW:
-        return Priority.NORMAL;
-      case NORMAL:
-        return Priority.HIGH;
-      case HIGH:
-      case IMMEDIATE:
-        return Priority.IMMEDIATE;
-      default:
-        throw new IllegalArgumentException("unknown priority: " + getPriority());
-    }
-  }
-
-  private Request buildRequest(
-      Target<TranscodeType> target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      BaseRequestOptions<?> requestOptions,
-      Executor callbackExecutor) {
-    return buildRequestRecursive(
-        target,
-        targetListener,
-        /*parentCoordinator=*/ null,
-        transitionOptions,
-        requestOptions.getPriority(),
-        requestOptions.getOverrideWidth(),
-        requestOptions.getOverrideHeight(),
-        requestOptions,
-        callbackExecutor);
-  }
-
-  private Request buildRequestRecursive(
-      Target<TranscodeType> target,
-      @Nullable RequestListener<TranscodeType> targetListener,
-      @Nullable RequestCoordinator parentCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority,
-      int overrideWidth,
-      int overrideHeight,
-      BaseRequestOptions<?> requestOptions,
-      Executor callbackExecutor) {
-
-    // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
-    ErrorRequestCoordinator errorRequestCoordinator = null;
-    if (errorBuilder != null) {
-      errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
-      parentCoordinator = errorRequestCoordinator;
-    }
-
-    Request mainRequest =
-        buildThumbnailRequestRecursive(
-            target,
-            targetListener,
-            parentCoordinator,
-            transitionOptions,
-            priority,
-            overrideWidth,
-            overrideHeight,
-            requestOptions,
-            callbackExecutor);
-
-    if (errorRequestCoordinator == null) {
-      return mainRequest;
-    }
-
-    int errorOverrideWidth = errorBuilder.getOverrideWidth();
-    int errorOverrideHeight = errorBuilder.getOverrideHeight();
-    if (Util.isValidDimensions(overrideWidth, overrideHeight)
-        && !errorBuilder.isValidOverride()) {
-      errorOverrideWidth = requestOptions.getOverrideWidth();
-      errorOverrideHeight = requestOptions.getOverrideHeight();
-    }
-
-    Request errorRequest =
-        errorBuilder.buildRequestRecursive(
-            target,
-            targetListener,
-            errorRequestCoordinator,
-            errorBuilder.transitionOptions,
-            errorBuilder.getPriority(),
-            errorOverrideWidth,
-            errorOverrideHeight,
-            errorBuilder,
-            callbackExecutor);
-    errorRequestCoordinator.setRequests(mainRequest, errorRequest);
-    return errorRequestCoordinator;
-  }
-
-  private Request buildThumbnailRequestRecursive(
-      Target<TranscodeType> target,
-      RequestListener<TranscodeType> targetListener,
-      @Nullable RequestCoordinator parentCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority,
-      int overrideWidth,
-      int overrideHeight,
-      BaseRequestOptions<?> requestOptions,
-      Executor callbackExecutor) {
-    if (thumbnailBuilder != null) {
-      // Recursive case: contains a potentially recursive thumbnail request builder.
-      if (isThumbnailBuilt) {
-        throw new IllegalStateException("You cannot use a request as both the main request and a "
-            + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
-      }
-
-      TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
-          thumbnailBuilder.transitionOptions;
-
-      // Apply our transition by default to thumbnail requests but avoid overriding custom options
-      // that may have been applied on the thumbnail request explicitly.
-      if (thumbnailBuilder.isDefaultTransitionOptionsSet) {
-        thumbTransitionOptions = transitionOptions;
-      }
-
-      Priority thumbPriority = thumbnailBuilder.isPrioritySet()
-          ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);
-
-      int thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();
-      int thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();
-      if (Util.isValidDimensions(overrideWidth, overrideHeight)
-          && !thumbnailBuilder.isValidOverride()) {
-        thumbOverrideWidth = requestOptions.getOverrideWidth();
-        thumbOverrideHeight = requestOptions.getOverrideHeight();
-      }
-
-      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest =
-          obtainRequest(
-              target,
-              targetListener,
-              requestOptions,
-              coordinator,
-              transitionOptions,
-              priority,
-              overrideWidth,
-              overrideHeight,
-              callbackExecutor);
-      isThumbnailBuilt = true;
-      // Recursively generate thumbnail requests.
-      Request thumbRequest =
-          thumbnailBuilder.buildRequestRecursive(
-              target,
-              targetListener,
-              coordinator,
-              thumbTransitionOptions,
-              thumbPriority,
-              thumbOverrideWidth,
-              thumbOverrideHeight,
-              thumbnailBuilder,
-              callbackExecutor);
-      isThumbnailBuilt = false;
-      coordinator.setRequests(fullRequest, thumbRequest);
-      return coordinator;
-    } else if (thumbSizeMultiplier != null) {
-      // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
-      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
-      Request fullRequest =
-          obtainRequest(
-              target,
-              targetListener,
-              requestOptions,
-              coordinator,
-              transitionOptions,
-              priority,
-              overrideWidth,
-              overrideHeight,
-              callbackExecutor);
-      BaseRequestOptions<?> thumbnailOptions =
-          requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);
-
-      Request thumbnailRequest =
-          obtainRequest(
-              target,
-              targetListener,
-              thumbnailOptions,
-              coordinator,
-              transitionOptions,
-              getThumbnailPriority(priority),
-              overrideWidth,
-              overrideHeight,
-              callbackExecutor);
-
-      coordinator.setRequests(fullRequest, thumbnailRequest);
-      return coordinator;
-    } else {
-      // Base case: no thumbnail.
-      return obtainRequest(
-          target,
-          targetListener,
-          requestOptions,
-          parentCoordinator,
-          transitionOptions,
-          priority,
-          overrideWidth,
-          overrideHeight,
-          callbackExecutor);
-    }
-  }
-
-  private Request obtainRequest(
-      Target<TranscodeType> target,
-      RequestListener<TranscodeType> targetListener,
-      BaseRequestOptions<?> requestOptions,
-      RequestCoordinator requestCoordinator,
-      TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority,
-      int overrideWidth,
-      int overrideHeight,
-      Executor callbackExecutor) {
-    return SingleRequest.obtain(
-        context,
-        glideContext,
-        model,
-        transcodeClass,
-        requestOptions,
-        overrideWidth,
-        overrideHeight,
-        priority,
-        target,
-        targetListener,
-        requestListeners,
-        requestCoordinator,
-        glideContext.getEngine(),
-        transitionOptions.getTransitionFactory(),
-        callbackExecutor);
-  }
+		implements Cloneable,
+		ModelTypes<RequestBuilder<TranscodeType>> {
+	// Used in generated subclasses
+	protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
+			new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
+					.skipMemoryCache(true);
+
+	private final Context context;
+	private final RequestManager requestManager;
+	private final Class<TranscodeType> transcodeClass;
+	private final Glide glide;
+	private final GlideContext glideContext;
+
+	@NonNull
+	@SuppressWarnings("unchecked")
+	private TransitionOptions<?, ? super TranscodeType> transitionOptions;
+
+	@Nullable
+	private Object model;
+	// model may occasionally be null, so to enforce that load() was called, put a boolean rather
+	// than relying on model not to be null.
+	@Nullable
+	private List<RequestListener<TranscodeType>> requestListeners;
+	@Nullable
+	private RequestBuilder<TranscodeType> thumbnailBuilder;
+	@Nullable
+	private RequestBuilder<TranscodeType> errorBuilder;
+	@Nullable
+	private Float thumbSizeMultiplier;
+	private boolean isDefaultTransitionOptionsSet = true;
+	private boolean isModelSet;
+	private boolean isThumbnailBuilt;
+
+	// We only override the method to change the return type, not the functionality.
+	@SuppressLint("CheckResult")
+	@SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+	protected RequestBuilder(
+			@NonNull Glide glide,
+			RequestManager requestManager,
+			Class<TranscodeType> transcodeClass,
+			Context context) {
+		this.glide = glide;
+		this.requestManager = requestManager;
+		this.transcodeClass = transcodeClass;
+		this.context = context;
+		this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
+		this.glideContext = glide.getGlideContext();
+
+		initRequestListeners(requestManager.getDefaultRequestListeners());
+		apply(requestManager.getDefaultRequestOptions());
+	}
+
+	@SuppressLint("CheckResult")
+	@SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
+	protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+		this(other.glide, other.requestManager, transcodeClass, other.context);
+		model = other.model;
+		isModelSet = other.isModelSet;
+
+		// This is safe because it will always mutate, no one else has access to the object.
+		apply(other);
+	}
+
+	// Casting from Object to a specific type is always safe.
+	@SuppressWarnings("unchecked")
+	// addListener always returns the same instance.
+	@SuppressLint("CheckResult")
+	private void initRequestListeners(List<RequestListener<Object>> requestListeners) {
+		for (RequestListener<Object> listener : requestListeners) {
+			addListener((RequestListener<TranscodeType>) listener);
+		}
+	}
+
+	/**
+	 * Applies the given options to the request.
+	 *
+	 * <p>As with {@link RequestOptions#apply(BaseRequestOptions)}, {@code #apply} only replaces those
+	 * values that are explicitly set in the given {@link RequestOptions} object. If you need to
+	 * completely reset all previously set options, create a new {@code RequestBuilder} instead of
+	 * using this method.
+	 *
+	 * @return This request builder.
+	 * @see RequestOptions#apply(BaseRequestOptions)
+	 */
+	@NonNull
+	@CheckResult
+	@Override
+	public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
+		Preconditions.checkNotNull(requestOptions);
+		return super.apply(requestOptions);
+	}
+
+	/**
+	 * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
+	 * this load completes.
+	 *
+	 * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
+	 * previously.
+	 *
+	 * @return This request builder.
+	 */
+	@NonNull
+	@CheckResult
+	public RequestBuilder<TranscodeType> transition(
+			@NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
+		this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
+		isDefaultTransitionOptionsSet = false;
+		return this;
+	}
+
+	/**
+	 * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single
+	 * instance of an exception handler per type of request (usually activity/fragment) rather than
+	 * pass one in per request to avoid some redundant object allocation.
+	 *
+	 * <p>Subsequent calls to this method will replace previously set listeners. To set multiple
+	 * listeners, use {@link #addListener} instead.
+	 *
+	 * @param requestListener The request listener to use.
+	 * @return This request builder.
+	 */
+	@NonNull
+	@CheckResult
+	@SuppressWarnings("unchecked")
+	public RequestBuilder<TranscodeType> listener(
+			@Nullable RequestListener<TranscodeType> requestListener) {
+		this.requestListeners = null;
+		return addListener(requestListener);
+	}
+
+	/**
+	 * Adds a {@link RequestListener}. If called multiple times, all passed
+	 * {@link RequestListener listeners} will be called in order.
+	 *
+	 * @param requestListener The request listener to use. If {@code null}, this method is a noop.
+	 * @return This request builder.
+	 */
+	@NonNull
+	@CheckResult
+	public RequestBuilder<TranscodeType> addListener(
+			@Nullable RequestListener<TranscodeType> requestListener) {
+		if (requestListener != null) {
+			if (this.requestListeners == null) {
+				this.requestListeners = new ArrayList<>();
+			}
+			this.requestListeners.add(requestListener);
+		}
+		return this;
+	}
+
+	/**
+	 * Sets a {@link RequestBuilder} that is built and run if the load started by this
+	 * {@link RequestBuilder} fails.
+	 *
+	 * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error
+	 * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails.
+	 *
+	 * <p>Recursive calls to this method as well as calls to {@link #thumbnail(float)} and
+	 * {@link #thumbnail(RequestBuilder)} are supported for the given error {@link RequestBuilder}.
+	 *
+	 * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from
+	 * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}.
+	 * Options like priority, override widths and heights and transitions must be applied
+	 * independently to the error builder.
+	 *
+	 * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable
+	 * if it's set on this {@link RequestBuilder} via
+	 * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or
+	 * {@link RequestOptions#fallback(int)}.
+	 *
+	 * @return This {@link RequestBuilder}.
+	 */
+	@NonNull
+	public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {
+		this.errorBuilder = errorBuilder;
+		return this;
+	}
+
+	/**
+	 * Loads and displays the resource retrieved by the given thumbnail request if it finishes before
+	 * this request. Best used for loading thumbnail resources that are smaller and will be loaded
+	 * more quickly than the full size resource. There are no guarantees about the order in which the
+	 * requests will actually finish. However, if the thumb request completes after the full request,
+	 * the thumb resource will never replace the full resource.
+	 *
+	 * <p>Recursive calls to thumbnail are supported.
+	 *
+	 * <p>Overrides any previous calls to this method, {@link #thumbnail(float)} and
+	 * {@link #thumbnail(RequestBuilder[])}.
+	 *
+	 * @param thumbnailRequest The request to use to load the thumbnail.
+	 * @return This request builder.
+	 * @see #thumbnail(float)
+	 * @see #thumbnail(RequestBuilder[])
+	 */
+	@NonNull
+	@CheckResult
+	@SuppressWarnings("unchecked")
+	public RequestBuilder<TranscodeType> thumbnail(
+			@Nullable RequestBuilder<TranscodeType> thumbnailRequest) {
+		this.thumbnailBuilder = thumbnailRequest;
+
+		return this;
+	}
+
+	/**
+	 * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
+	 * loaded as thumbnails in the given priority order.
+	 *
+	 * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
+	 * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
+	 * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
+	 * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
+	 *
+	 * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
+	 * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
+	 * {@link #thumbnail(RequestBuilder)} with {@code null}.
+	 *
+	 * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
+	 * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
+	 * chain.
+	 *
+	 * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
+	 * calls to this method or {@link #thumbnail(RequestBuilder)} methods overridden.
+	 *
+	 * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
+	 * {@link #thumbnail(float)} and this method.
+	 *
+	 * @return This request builder.
+	 * @see #thumbnail(float)
+	 * @see #thumbnail(RequestBuilder)
+	 */
+	@SuppressWarnings({"CheckResult", "unchecked"})
+	@NonNull
+	@CheckResult
+	public RequestBuilder<TranscodeType> thumbnail(
+			@Nullable RequestBuilder<TranscodeType>... thumbnails) {
+		if (thumbnails == null || thumbnails.length == 0) {
+			return thumbnail((RequestBuilder<TranscodeType>) null);
+		}
+
+		RequestBuilder<TranscodeType> previous = null;
+
+		// Start with the lowest priority thumbnail so that we can safely handle mutations if
+		// autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
+		// Starting with the highest priority thumbnail would prevent us from assigning the result of
+		// thumbnail because the mutated request wouldn't be used in the next iteration.
+		for (int i = thumbnails.length - 1; i >= 0; i--) {
+			RequestBuilder<TranscodeType> current = thumbnails[i];
+			// Ignore null thumbnails.
+			if (current == null) {
+				continue;
+			}
+
+			if (previous == null) {
+				// If we don't yet have our first non-null request, set it and continue.
+				previous = current;
+			} else {
+				// Otherwise make our next lowest priority request the thumbnail of our current request.
+				previous = current.thumbnail(previous);
+			}
+		}
+		return thumbnail(previous);
+	}
+
+	/**
+	 * Loads a resource in an identical manner to this request except with the dimensions of the
+	 * target multiplied by the given size multiplier. If the thumbnail load completes before the full
+	 * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
+	 * load, the thumbnail will not be shown.
+	 *
+	 * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
+	 * {@link ImageView}) must be able to scale the thumbnail appropriately. See
+	 * {@link android.widget.ImageView.ScaleType}.
+	 *
+	 * <p>Almost all options will be copied from the original load, including the {@link
+	 * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
+	 * and {@link com.bumptech.glide.load.Transformation}s. However,
+	 * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
+	 * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
+	 * {@link #listener(RequestListener)} will only be used on the full size load and will not be
+	 * copied for the thumbnail load.
+	 *
+	 * <p>Recursive calls to thumbnail are supported.
+	 *
+	 * <p>Overrides any previous calls to this method, {@link #thumbnail(RequestBuilder[])},
+	 * and {@link #thumbnail(RequestBuilder)}.
+	 *
+	 * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
+	 *                       the thumbnail.
+	 * @return This request builder.
+	 * @see #thumbnail(RequestBuilder)
+	 * @see #thumbnail(RequestBuilder[])
+	 */
+	@NonNull
+	@CheckResult
+	@SuppressWarnings("unchecked")
+	public RequestBuilder<TranscodeType> thumbnail(float sizeMultiplier) {
+		if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+			throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+		}
+		this.thumbSizeMultiplier = sizeMultiplier;
+
+		return this;
+	}
+
+	/**
+	 * Sets the specific model to load data for.
+	 *
+	 * @param model The model to load data for, or null.
+	 * @return This request builder.
+	 */
+	@NonNull
+	@CheckResult
+	@SuppressWarnings("unchecked")
+	@Override
+	public RequestBuilder<TranscodeType> load(@Nullable Object model) {
+		return loadGeneric(model);
+	}
+
+	@NonNull
+	private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
+		this.model = model;
+		isModelSet = true;
+		return this;
+	}
+
+	/**
+	 * Returns an object to load the given {@link Bitmap}.
+	 *
+	 * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
+	 * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
+	 * not supported by Glide by default, consider registering a custom
+	 * {@link com.bumptech.glide.load.model.ModelLoader} or
+	 * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+	 *
+	 * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+	 * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+	 * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+	 * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+	 *
+	 * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
+	 * compared.
+	 *
+	 * @see #load(Object)
+	 */
+	@NonNull
+	@CheckResult
+	@Override
+	public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
+		return loadGeneric(bitmap)
+				.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+	}
+
+	/**
+	 * Returns a request builder to load the given {@link Drawable}.
+	 *
+	 * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass
+	 * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain
+	 * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom
+	 * {@link com.bumptech.glide.load.model.ModelLoader} or
+	 * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
+	 *
+	 * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+	 * {@link #apply(BaseRequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+	 * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+	 * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
+	 *
+	 * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
+	 * compared.
+	 *
+	 * @see #load(Object)
+	 */
+	@NonNull
+	@CheckResult
+	@Override
+	public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
+		return loadGeneric(drawable)
+				.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+	}
+
+	/**
+	 * Returns a request builder to load the given {@link java.lang.String}.
+	 *
+	 * <p> Note - this method caches data using only the given String as the cache key. If the data is
+	 * a Uri outside of your control, or you otherwise expect the data represented by the given String
+	 * to change without the String identifier changing, Consider using
+	 * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
+	 * mixin a signature you create that identifies the data currently at the given String that will
+	 * invalidate the cache if that data changes. Alternatively, using
+	 * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+	 * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
+	 * appropriate.
+	 * </p>
+	 *
+	 * @param string A file path, or a uri or url handled by
+	 *               {@link com.bumptech.glide.load.model.UriLoader}.
+	 * @see #load(Object)
+	 */
+	@NonNull
+	@Override
+	@CheckResult
+	public RequestBuilder<TranscodeType> load(@Nullable String string) {
+		return loadGeneric(string);
+	}
+
+	/**
+	 * Returns a request builder to load the given {@link Uri}.
+	 *
+	 * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
+	 * represented by Uris from some content providers may change without the Uri changing, which
+	 * means using this method can lead to displaying stale data. Consider using
+	 * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
+	 * mixin a signature you create based on the data at the given Uri that will invalidate the cache
+	 * if that data changes. Alternatively, using
+	 * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+	 * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
+	 * appropriate. </p>
+	 *
+	 * @param uri The Uri representing the image. Must be of a type handled by
+	 *            {@link com.bumptech.glide.load.model.UriLoader}.
+	 * @see #load(Object)
+	 */
+	@NonNull
+	@CheckResult
+	@Override
+	public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
+		return loadGeneric(uri);
+	}
+
+	/**
+	 * Returns a request builder to load the given {@link File}.
+	 *
+	 * <p>Note - this method caches data for Files using only the file path itself as the cache key.
+	 * The data in the File can change so using this method can lead to displaying stale data. If you
+	 * expect the data in the File to change, Consider using
+	 * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
+	 * to mixin a signature you create that identifies the data currently in the File that will
+	 * invalidate the cache if that data changes. Alternatively, using
+	 * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
+	 * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
+	 * appropriate.
+	 *
+	 * @param file The File containing the image
+	 * @see #load(Object)
+	 */
+	@NonNull
+	@CheckResult
+	@Override
+	public RequestBuilder<TranscodeType> load(@Nullable File file) {
+		return loadGeneric(file);
+	}
+
+	/**
+	 * Returns a request builder that uses the
+	 * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
+	 * {@link Integer} to load the image represented by the given {@link Integer} resource id.
+	 * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
+	 *
+	 * <p>By default this method adds a version code based signature to the cache key used to cache
+	 * this resource in Glide. This signature is sufficient to guarantee that end users will see the
+	 * most up to date versions of your Drawables, but during development if you do not increment your
+	 * version code before each install and you replace a Drawable with different data without
+	 * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
+	 * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
+	 * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
+	 * during development, and re-enabling the default
+	 * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+	 *
+	 * <p>This method will load non-{@link android.graphics.Bitmap} resources like
+	 * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply
+	 * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting
+	 * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide
+	 * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be
+	 * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid
+	 * load failures if a {@link Drawable} can't be transformed, use the optional transformation
+	 * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}.
+	 *
+	 * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this
+	 * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with
+	 * caution for non-{@link Bitmap} {@link Drawable}s.
+	 *
+	 * @see #load(Integer)
+	 * @see com.bumptech.glide.signature.ApplicationVersionSignature
+	 */
+	@NonNull
+	@CheckResult
+	@Override
+	public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
+		return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
+	}
+
+	/**
+	 * Returns a request builder to load the given {@link URL}.
+	 *
+	 * @param url The URL representing the image.
+	 * @see #load(Object)
+	 * @deprecated The {@link java.net.URL} class has
+	 * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
+	 * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
+	 */
+	@Deprecated
+	@CheckResult
+	@Override
+	public RequestBuilder<TranscodeType> load(@Nullable URL url) {
+		return loadGeneric(url);
+	}
+
+	/**
+	 * Returns a request to load the given byte array.
+	 *
+	 * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
+	 *
+	 * @param model the data to load.
+	 * @see #load(Object)
+	 */
+	@NonNull
+	@CheckResult
+	@Override
+	public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
+		RequestBuilder<TranscodeType> result = loadGeneric(model);
+		if (!result.isDiskCacheStrategySet()) {
+			result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+		}
+		if (!result.isSkipMemoryCacheSet()) {
+			result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+		}
+		return result;
+	}
+
+	/**
+	 * Returns a copy of this request builder with all of the options put so far on this builder.
+	 *
+	 * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+	 * changes to one builder will not affect the other builder. However, in addition to immutable
+	 * arguments, the current model is not copied copied so changes to the model will affect both
+	 * builders. </p>
+	 */
+	@SuppressWarnings({
+			"unchecked",
+			// we don't want to throw to be user friendly
+			"PMD.CloneThrowsCloneNotSupportedException"
+	})
+	@CheckResult
+	@Override
+	public RequestBuilder<TranscodeType> clone() {
+		RequestBuilder<TranscodeType> result = super.clone();
+		result.transitionOptions = result.transitionOptions.clone();
+		return result;
+	}
+
+	/**
+	 * Set the target the resource will be loaded into.
+	 *
+	 * @param target The target to load the resource into.
+	 * @return The given target.
+	 * @see RequestManager#clear(Target)
+	 */
+	@NonNull
+	public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
+		return into(target, /*targetListener=*/ null, Executors.mainThreadExecutor());
+	}
+
+	@NonNull
+	@Synthetic
+	<Y extends Target<TranscodeType>> Y into(
+			@NonNull Y target,
+			@Nullable RequestListener<TranscodeType> targetListener,
+			Executor callbackExecutor) {
+		return into(target, targetListener, /*options=*/ this, callbackExecutor);
+	}
+
+	private <Y extends Target<TranscodeType>> Y into(
+			@NonNull Y target,
+			@Nullable RequestListener<TranscodeType> targetListener,
+			BaseRequestOptions<?> options,
+			Executor callbackExecutor) {
+		Preconditions.checkNotNull(target);
+		if (!isModelSet) {
+			throw new IllegalArgumentException("You must call #load() before calling #into()");
+		}
+
+		Request request = buildRequest(target, targetListener, options, callbackExecutor);
+//		这里首先会通过target对象获取request对象，然后清除之前的request对象，回收request对象，
+//		然后重新构建一个新的request对象，并且给这个target设置request对象，这其实就是好比listView
+//		加载图片时候给图片设置tag，防止图片错位问题，这里requestTracker.runRequest这个方法是执行这个请求。
+		Request previous = target.getRequest();
+		if (request.isEquivalentTo(previous)
+				&& !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
+			request.recycle();
+			// If the request is completed, beginning again will ensure the result is re-delivered,
+			// triggering RequestListeners and Targets. If the request is failed, beginning again will
+			// restart the request, giving it another chance to complete. If the request is already
+			// running, we can let it continue running without interruption.
+			if (!Preconditions.checkNotNull(previous).isRunning()) {
+				// Use the previous request rather than the new one to allow for optimizations like skipping
+				// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
+				// that are done in the individual Request.
+				previous.begin();
+			}
+			return target;
+		}
+
+		requestManager.clear(target);
+		target.setRequest(request);
+		//RequestTracker类用于跟踪、取消和重新启动进程中、已完成和失败请求
+		//执行请求
+		requestManager.track(target, request);
+
+		return target;
+	}
+
+	// If the caller is using skipMemoryCache and the previous request is finished, calling begin on
+	// the previous request will complete from memory because it will just use the resource that had
+	// already been loaded. If the previous request isn't complete, we can wait for it to finish
+	// because the previous request must also be using skipMemoryCache for the requests to be
+	// equivalent. See #2663 for additional context.
+	private boolean isSkipMemoryCacheWithCompletePreviousRequest(
+			BaseRequestOptions<?> options, Request previous) {
+		return !options.isMemoryCacheable() && previous.isComplete();
+	}
+
+	/**
+	 * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
+	 * the view, and frees any resources Glide may have previously loaded into the view so they may be
+	 * reused.
+	 *
+	 * @param view The view to cancel previous loads for and load the new resource into.
+	 * @return The
+	 * {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
+	 * @see RequestManager#clear(Target)
+	 */
+	@NonNull
+	public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
+		Util.assertMainThread();//断言是不是在主线程 因为ui更新操作在主线程
+		Preconditions.checkNotNull(view);
+
+		BaseRequestOptions<?> requestOptions = this;
+		if (!requestOptions.isTransformationSet()
+				&& requestOptions.isTransformationAllowed()
+				&& view.getScaleType() != null) {
+			// Clone in this method so that if we use this RequestBuilder to load into a View and then
+			// into a different target, we don't retain the transformation applied based on the previous
+			// View's scale type.
+			switch (view.getScaleType()) {
+				// XXX: xml里的scaleType的实际效果
+				case CENTER_CROP:
+					requestOptions = requestOptions.clone().optionalCenterCrop();
+					break;
+				case CENTER_INSIDE:
+					requestOptions = requestOptions.clone().optionalCenterInside();
+					break;
+				case FIT_CENTER://这三种都是一个效果
+				case FIT_START:
+				case FIT_END:
+					requestOptions = requestOptions.clone().optionalFitCenter();
+					break;
+				case FIT_XY:
+					requestOptions = requestOptions.clone().optionalCenterInside();
+					break;
+				case CENTER:
+				case MATRIX:
+				default:
+					// Do nothing.
+			}
+		}
+
+		return into(
+				glideContext.buildImageViewTarget(view, transcodeClass),
+				/*targetListener=*/ null,
+				requestOptions,
+				Executors.mainThreadExecutor());
+	}
+
+	/**
+	 * Returns a future that can be used to do a blocking get on a background thread.
+	 *
+	 * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+	 *               overridden by
+	 *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+	 *               previously called.
+	 * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+	 *               overridden by
+	 *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+	 *               previously called).
+	 * @see RequestManager#clear(Target)
+	 * @deprecated Use {@link #submit(int, int)} instead.
+	 */
+	@Deprecated
+	public FutureTarget<TranscodeType> into(int width, int height) {
+		return submit(width, height);
+	}
+
+	/**
+	 * Returns a future that can be used to do a blocking get on a background thread.
+	 *
+	 * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,
+	 * since the width and height will be overridden by values passed to {@link
+	 * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}
+	 * with override values are applied, or whenever you want to retrieve the image in its original
+	 * size.
+	 *
+	 * @see #submit(int, int)
+	 * @see #into(Target)
+	 */
+	@NonNull
+	public FutureTarget<TranscodeType> submit() {
+		return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+	}
+
+	/**
+	 * Returns a future that can be used to do a blocking get on a background thread.
+	 *
+	 * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+	 *               overridden by
+	 *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+	 *               previously called.
+	 * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+	 *               overridden by
+	 *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+	 *               previously called).
+	 */
+	@NonNull
+	public FutureTarget<TranscodeType> submit(int width, int height) {
+		final RequestFutureTarget<TranscodeType> target = new RequestFutureTarget<>(width, height);
+		return into(target, target, Executors.directExecutor());
+	}
+
+	/**
+	 * Preloads the resource into the cache using the given width and height.
+	 *
+	 * <p> Pre-loading is useful for making sure that resources you are going to to want in the near
+	 * future are available quickly. </p>
+	 *
+	 * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+	 *               overridden by
+	 *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
+	 *               previously called.
+	 * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
+	 *               overridden by
+	 *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
+	 *               previously called).
+	 * @return A {@link Target} that can be used to cancel the load via
+	 * {@link RequestManager#clear(Target)}.
+	 * @see com.bumptech.glide.ListPreloader
+	 */
+	@NonNull
+	public Target<TranscodeType> preload(int width, int height) {
+		final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(requestManager, width, height);
+		return into(target);
+	}
+
+	/**
+	 * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and
+	 * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as
+	 * the width and height.
+	 *
+	 * @return A {@link Target} that can be used to cancel the load via
+	 * {@link RequestManager#clear(Target)}
+	 * @see #preload(int, int)
+	 */
+	@NonNull
+	public Target<TranscodeType> preload() {
+		return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+	}
+
+	/**
+	 * Loads the original unmodified data into the cache and calls the given Target with the cache
+	 * File.
+	 *
+	 * @param target The Target that will receive the cache File when the load completes
+	 * @param <Y>    The type of Target.
+	 * @return The given Target.
+	 * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
+	 */
+	@Deprecated
+	@CheckResult
+	public <Y extends Target<File>> Y downloadOnly(@NonNull Y target) {
+		return getDownloadOnlyRequest().into(target);
+	}
+
+	/**
+	 * Loads the original unmodified data into the cache and returns a
+	 * {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the
+	 * data.
+	 *
+	 * @param width  The width in pixels to use to fetch the data.
+	 * @param height The height in pixels to use to fetch the data.
+	 * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File
+	 * containing the data.
+	 * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #submit(int, int)}.
+	 */
+	@Deprecated
+	@CheckResult
+	public FutureTarget<File> downloadOnly(int width, int height) {
+		return getDownloadOnlyRequest().submit(width, height);
+	}
+
+	@NonNull
+	@CheckResult
+	protected RequestBuilder<File> getDownloadOnlyRequest() {
+		return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+	}
+
+	@NonNull
+	private Priority getThumbnailPriority(@NonNull Priority current) {
+		switch (current) {
+			case LOW:
+				return Priority.NORMAL;
+			case NORMAL:
+				return Priority.HIGH;
+			case HIGH:
+			case IMMEDIATE:
+				return Priority.IMMEDIATE;
+			default:
+				throw new IllegalArgumentException("unknown priority: " + getPriority());
+		}
+	}
+
+	private Request buildRequest(
+			Target<TranscodeType> target,
+			@Nullable RequestListener<TranscodeType> targetListener,
+			BaseRequestOptions<?> requestOptions,
+			Executor callbackExecutor) {
+		return buildRequestRecursive(
+				target,
+				targetListener,
+				/*parentCoordinator=*/ null,
+				transitionOptions,
+				requestOptions.getPriority(),
+				requestOptions.getOverrideWidth(),
+				requestOptions.getOverrideHeight(),
+				requestOptions,
+				callbackExecutor);
+	}
+
+	private Request buildRequestRecursive(
+			Target<TranscodeType> target,
+			@Nullable RequestListener<TranscodeType> targetListener,
+			@Nullable RequestCoordinator parentCoordinator,
+			TransitionOptions<?, ? super TranscodeType> transitionOptions,
+			Priority priority,
+			int overrideWidth,
+			int overrideHeight,
+			BaseRequestOptions<?> requestOptions,
+			Executor callbackExecutor) {
+
+		// Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.
+		ErrorRequestCoordinator errorRequestCoordinator = null;
+		if (errorBuilder != null) {
+			errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
+			parentCoordinator = errorRequestCoordinator;
+		}
+
+		Request mainRequest =
+				buildThumbnailRequestRecursive(
+						target,
+						targetListener,
+						parentCoordinator,
+						transitionOptions,
+						priority,
+						overrideWidth,
+						overrideHeight,
+						requestOptions,
+						callbackExecutor);
+
+		if (errorRequestCoordinator == null) {
+			return mainRequest;
+		}
+
+		int errorOverrideWidth = errorBuilder.getOverrideWidth();
+		int errorOverrideHeight = errorBuilder.getOverrideHeight();
+		if (Util.isValidDimensions(overrideWidth, overrideHeight)
+				&& !errorBuilder.isValidOverride()) {
+			errorOverrideWidth = requestOptions.getOverrideWidth();
+			errorOverrideHeight = requestOptions.getOverrideHeight();
+		}
+
+		Request errorRequest =
+				errorBuilder.buildRequestRecursive(
+						target,
+						targetListener,
+						errorRequestCoordinator,
+						errorBuilder.transitionOptions,
+						errorBuilder.getPriority(),
+						errorOverrideWidth,
+						errorOverrideHeight,
+						errorBuilder,
+						callbackExecutor);
+		errorRequestCoordinator.setRequests(mainRequest, errorRequest);
+		return errorRequestCoordinator;
+	}
+
+	/**
+	 * @param target
+	 * @param targetListener
+	 * @param parentCoordinator
+	 * @param transitionOptions
+	 * @param priority
+	 * @param overrideWidth
+	 * @param overrideHeight
+	 * @param requestOptions
+	 * @param callbackExecutor
+	 * @return
+	 * buildRequestRecursive方法前面一大部分主要是如果glide调用了override，
+	 *  就调用这个类的override方法，以及缩略图的处理，最终还是调用的obtainRequest方法
+	 */
+	private Request buildThumbnailRequestRecursive(
+			Target<TranscodeType> target,
+			RequestListener<TranscodeType> targetListener,
+			@Nullable RequestCoordinator parentCoordinator,
+			TransitionOptions<?, ? super TranscodeType> transitionOptions,
+			Priority priority,
+			int overrideWidth,
+			int overrideHeight,
+			BaseRequestOptions<?> requestOptions,
+			Executor callbackExecutor) {
+		if (thumbnailBuilder != null) {
+			// Recursive case: contains a potentially recursive thumbnail request builder.
+			if (isThumbnailBuilt) {
+				throw new IllegalStateException("You cannot use a request as both the main request and a "
+						+ "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
+			}
+
+			TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
+					thumbnailBuilder.transitionOptions;
+
+			// Apply our transition by default to thumbnail requests but avoid overriding custom options
+			// that may have been applied on the thumbnail request explicitly.
+			if (thumbnailBuilder.isDefaultTransitionOptionsSet) {
+				thumbTransitionOptions = transitionOptions;
+			}
+
+			Priority thumbPriority = thumbnailBuilder.isPrioritySet()
+					? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);
+
+			int thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();
+			int thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();
+			if (Util.isValidDimensions(overrideWidth, overrideHeight)
+					&& !thumbnailBuilder.isValidOverride()) {
+				thumbOverrideWidth = requestOptions.getOverrideWidth();
+				thumbOverrideHeight = requestOptions.getOverrideHeight();
+			}
+
+			ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
+			Request fullRequest =
+					obtainRequest(
+							target,
+							targetListener,
+							requestOptions,
+							coordinator,
+							transitionOptions,
+							priority,
+							overrideWidth,
+							overrideHeight,
+							callbackExecutor);
+			isThumbnailBuilt = true;
+			// Recursively generate thumbnail requests.
+			Request thumbRequest =
+					thumbnailBuilder.buildRequestRecursive(
+							target,
+							targetListener,
+							coordinator,
+							thumbTransitionOptions,
+							thumbPriority,
+							thumbOverrideWidth,
+							thumbOverrideHeight,
+							thumbnailBuilder,
+							callbackExecutor);
+			isThumbnailBuilt = false;
+			coordinator.setRequests(fullRequest, thumbRequest);
+			return coordinator;
+		} else if (thumbSizeMultiplier != null) {
+			// Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
+			ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
+			Request fullRequest =
+					obtainRequest(
+							target,
+							targetListener,
+							requestOptions,
+							coordinator,
+							transitionOptions,
+							priority,
+							overrideWidth,
+							overrideHeight,
+							callbackExecutor);
+			BaseRequestOptions<?> thumbnailOptions =
+					requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);
+
+			Request thumbnailRequest =
+					obtainRequest(
+							target,
+							targetListener,
+							thumbnailOptions,
+							coordinator,
+							transitionOptions,
+							getThumbnailPriority(priority),
+							overrideWidth,
+							overrideHeight,
+							callbackExecutor);
+
+			coordinator.setRequests(fullRequest, thumbnailRequest);
+			return coordinator;
+		} else {
+			// Base case: no thumbnail.
+			return obtainRequest(
+					target,
+					targetListener,
+					requestOptions,
+					parentCoordinator,
+					transitionOptions,
+					priority,
+					overrideWidth,
+					overrideHeight,
+					callbackExecutor);
+		}
+	}
+
+	private Request obtainRequest(
+			Target<TranscodeType> target,
+			RequestListener<TranscodeType> targetListener,
+			BaseRequestOptions<?> requestOptions,
+			RequestCoordinator requestCoordinator,
+			TransitionOptions<?, ? super TranscodeType> transitionOptions,
+			Priority priority,
+			int overrideWidth,
+			int overrideHeight,
+			Executor callbackExecutor) {
+		return SingleRequest.obtain(
+				context,
+				glideContext,
+				model,
+				transcodeClass,
+				requestOptions,
+				overrideWidth,
+				overrideHeight,
+				priority,
+				target,
+				targetListener,
+				requestListeners,
+				requestCoordinator,
+				glideContext.getEngine(),
+				transitionOptions.getTransitionFactory(),
+				callbackExecutor);
+	}
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
index 16e548732..f0dd4f79e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -22,8 +22,8 @@
   private final Executor monitorClearedResourcesExecutor;
   @VisibleForTesting
   final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
+  //  大概就是用来跟踪弱引用（或者软引用、虚引用）是否被 gc 的。
   private final ReferenceQueue<EngineResource<?>> resourceReferenceQueue = new ReferenceQueue<>();
-
   private ResourceListener listener;
 
   private volatile boolean isShutdown;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
index 59f39bd00..c8c6ec254 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java
@@ -12,7 +12,7 @@
  * {@link com.bumptech.glide.load.ResourceEncoder} and the given data or
  * {@link com.bumptech.glide.load.engine.Resource}.
  *
- * @param <DataType> The type of data that will be encoded (InputStream, ByteBuffer,
+ * @param <DataType> The type of data that will be cencoded (InputStream, ByteBuffer,
  *                  Resource<Bitmap> etc).
  */
 class DataCacheWriter<DataType> implements DiskCache.Writer {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 054d875b5..fe9656102 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -4,6 +4,7 @@
 import android.support.annotation.NonNull;
 import android.support.v4.util.Pools;
 import android.util.Log;
+
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.Registry;
@@ -22,11 +23,12 @@
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.GlideTrace;
 import com.bumptech.glide.util.pool.StateVerifier;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
-/**
+/**负责 解压，从 缓存或初始来源  应用转化
  * A class responsible for decoding resources either from cached data or from the original source
  * and applying transformations and transcodes.
  *
@@ -36,713 +38,732 @@
  *            resource.
  */
 class DecodeJob<R> implements DataFetcherGenerator.FetcherReadyCallback,
-    Runnable,
-    Comparable<DecodeJob<?>>,
-    Poolable {
-  private static final String TAG = "DecodeJob";
-
-  private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
-  private final List<Throwable> throwables = new ArrayList<>();
-  private final StateVerifier stateVerifier = StateVerifier.newInstance();
-  private final DiskCacheProvider diskCacheProvider;
-  private final Pools.Pool<DecodeJob<?>> pool;
-  private final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
-  private final ReleaseManager releaseManager = new ReleaseManager();
-
-  private GlideContext glideContext;
-  private Key signature;
-  private Priority priority;
-  private EngineKey loadKey;
-  private int width;
-  private int height;
-  private DiskCacheStrategy diskCacheStrategy;
-  private Options options;
-  private Callback<R> callback;
-  private int order;
-  private Stage stage;
-  private RunReason runReason;
-  private long startFetchTime;
-  private boolean onlyRetrieveFromCache;
-  private Object model;
-
-  private Thread currentThread;
-  private Key currentSourceKey;
-  private Key currentAttemptingKey;
-  private Object currentData;
-  private DataSource currentDataSource;
-  private DataFetcher<?> currentFetcher;
-
-  private volatile DataFetcherGenerator currentGenerator;
-  private volatile boolean isCallbackNotified;
-  private volatile boolean isCancelled;
-
-  DecodeJob(DiskCacheProvider diskCacheProvider, Pools.Pool<DecodeJob<?>> pool) {
-    this.diskCacheProvider = diskCacheProvider;
-    this.pool = pool;
-  }
-
-  DecodeJob<R> init(
-      GlideContext glideContext,
-      Object model,
-      EngineKey loadKey,
-      Key signature,
-      int width,
-      int height,
-      Class<?> resourceClass,
-      Class<R> transcodeClass,
-      Priority priority,
-      DiskCacheStrategy diskCacheStrategy,
-      Map<Class<?>, Transformation<?>> transformations,
-      boolean isTransformationRequired,
-      boolean isScaleOnlyOrNoTransform,
-      boolean onlyRetrieveFromCache,
-      Options options,
-      Callback<R> callback,
-      int order) {
-    decodeHelper.init(
-        glideContext,
-        model,
-        signature,
-        width,
-        height,
-        diskCacheStrategy,
-        resourceClass,
-        transcodeClass,
-        priority,
-        options,
-        transformations,
-        isTransformationRequired,
-        isScaleOnlyOrNoTransform,
-        diskCacheProvider);
-    this.glideContext = glideContext;
-    this.signature = signature;
-    this.priority = priority;
-    this.loadKey = loadKey;
-    this.width = width;
-    this.height = height;
-    this.diskCacheStrategy = diskCacheStrategy;
-    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
-    this.options = options;
-    this.callback = callback;
-    this.order = order;
-    this.runReason = RunReason.INITIALIZE;
-    this.model = model;
-    return this;
-  }
-
-  /**
-   * Returns true if this job will attempt to decode a resource from the disk cache, and false if it
-   * will always decode from source.
-   */
-  boolean willDecodeFromCache() {
-    Stage firstStage = getNextStage(Stage.INITIALIZE);
-    return firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE;
-  }
-
-  /**
-   * Called when this object is no longer in use externally.
-   *
-   * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run} is
-   *                           neither in progress nor will ever be called again.
-   */
-  void release(boolean isRemovedFromQueue) {
-    if (releaseManager.release(isRemovedFromQueue)) {
-      releaseInternal();
-    }
-  }
-
-  /**
-   * Called when we've finished encoding (either because the encode process is complete, or because
-   * we don't have anything to encode).
-   */
-  private void onEncodeComplete() {
-    if (releaseManager.onEncodeComplete()) {
-      releaseInternal();
-    }
-  }
-
-  /**
-   * Called when the load has failed due to a an error or a series of errors.
-   */
-  private void onLoadFailed() {
-    if (releaseManager.onFailed()) {
-      releaseInternal();
-    }
-  }
-
-  private void releaseInternal() {
-    releaseManager.reset();
-    deferredEncodeManager.clear();
-    decodeHelper.clear();
-    isCallbackNotified = false;
-    glideContext = null;
-    signature = null;
-    options = null;
-    priority = null;
-    loadKey = null;
-    callback = null;
-    stage = null;
-    currentGenerator = null;
-    currentThread = null;
-    currentSourceKey = null;
-    currentData = null;
-    currentDataSource = null;
-    currentFetcher = null;
-    startFetchTime = 0L;
-    isCancelled = false;
-    model = null;
-    throwables.clear();
-    pool.release(this);
-  }
-
-  @Override
-  public int compareTo(@NonNull DecodeJob<?> other) {
-    int result = getPriority() - other.getPriority();
-    if (result == 0) {
-      result = order - other.order;
-    }
-    return result;
-  }
-
-  private int getPriority() {
-    return priority.ordinal();
-  }
-
-  public void cancel() {
-    isCancelled = true;
-    DataFetcherGenerator local = currentGenerator;
-    if (local != null) {
-      local.cancel();
-    }
-  }
-
-  // We need to rethrow only CallbackException, but not other types of Throwables.
-  @SuppressWarnings("PMD.AvoidRethrowingException")
-  @Override
-  public void run() {
-    // This should be much more fine grained, but since Java's thread pool implementation silently
-    // swallows all otherwise fatal exceptions, this will at least make it obvious to developers
-    // that something is failing.
-    GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);
-    // Methods in the try statement can invalidate currentFetcher, so set a local variable here to
-    // ensure that the fetcher is cleaned up either way.
-    DataFetcher<?> localFetcher = currentFetcher;
-    try {
-      if (isCancelled) {
-        notifyFailed();
-        return;
-      }
-      // 主要就是在它里面执行的
-      runWrapped();
-    } catch (CallbackException e) {
-      // If a callback not controlled by Glide throws an exception, we should avoid the Glide
-      // specific debug logic below.
-      throw e;
-    } catch (Throwable t) {
-      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our
-      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We
-      // are however ensuring that our callbacks are always notified when a load fails. Without this
-      // notification, uncaught throwables never notify the corresponding callbacks, which can cause
-      // loads to silently hang forever, a case that's especially bad for users using Futures on
-      // background threads.
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "DecodeJob threw unexpectedly"
-            + ", isCancelled: " + isCancelled
-            + ", stage: " + stage, t);
-      }
-      // When we're encoding we've already notified our callback and it isn't safe to do so again.
-      if (stage != Stage.ENCODE) {
-        throwables.add(t);
-        notifyFailed();
-      }
-      if (!isCancelled) {
-        throw t;
-      }
-      throw t;
-    } finally {
-      // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call
-      // close in all cases anyway.
-      if (localFetcher != null) {
-        localFetcher.cleanup();
-      }
-      GlideTrace.endSection();
-    }
-  }
-
-  private void runWrapped() {
-    switch (runReason) {
-      case INITIALIZE:
-        stage = getNextStage(Stage.INITIALIZE);
-        currentGenerator = getNextGenerator();
-        runGenerators();
-        break;
-      case SWITCH_TO_SOURCE_SERVICE:
-        runGenerators();
-        break;
-      case DECODE_DATA:
-        decodeFromRetrievedData();
-        break;
-      default:
-        throw new IllegalStateException("Unrecognized run reason: " + runReason);
-    }
-  }
-
-  private DataFetcherGenerator getNextGenerator() {
-    switch (stage) {
-      case RESOURCE_CACHE:
-        return new ResourceCacheGenerator(decodeHelper, this);
-      case DATA_CACHE:
-        return new DataCacheGenerator(decodeHelper, this);
-      case SOURCE:
-        return new SourceGenerator(decodeHelper, this);
-      case FINISHED:
-        return null;
-      default:
-        throw new IllegalStateException("Unrecognized stage: " + stage);
-    }
-  }
-
-  private void runGenerators() {
-    currentThread = Thread.currentThread();
-    startFetchTime = LogTime.getLogTime();
-    boolean isStarted = false;
-    // currentGenerator就是SourceGenerator对象
-   //   runGenerators最重要的就是执行了currentGenerator的startNext方法，这里将会真正的去加载网络资源：
-    while (!isCancelled && currentGenerator != null
-        && !(isStarted = currentGenerator.startNext())) {
-      stage = getNextStage(stage);
-      currentGenerator = getNextGenerator();
-
-      if (stage == Stage.SOURCE) {
-        reschedule();
-        return;
-      }
-    }
-    // We've run out of stages and generators, give up.
-    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {
-      notifyFailed();
-    }
-
-    // Otherwise a generator started a new load and we expect to be called back in
-    // onDataFetcherReady.
-  }
-
-  private void notifyFailed() {
-    setNotifiedOrThrow();
-    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));
-    callback.onLoadFailed(e);
-    onLoadFailed();
-  }
-
-  private void notifyComplete(Resource<R> resource, DataSource dataSource) {
-    setNotifiedOrThrow();
-    callback.onResourceReady(resource, dataSource);
-  }
-
-  private void setNotifiedOrThrow() {
-    stateVerifier.throwIfRecycled();
-    if (isCallbackNotified) {
-      Throwable lastThrown = throwables.isEmpty() ? null : throwables.get(throwables.size() - 1);
-      throw new IllegalStateException("Already notified", lastThrown);
-    }
-    isCallbackNotified = true;
-  }
-
-  private Stage getNextStage(Stage current) {
-    switch (current) {
-      case INITIALIZE:
-        return diskCacheStrategy.decodeCachedResource()
-            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
-      case RESOURCE_CACHE:
-        return diskCacheStrategy.decodeCachedData()
-            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
-      case DATA_CACHE:
-        // Skip loading from source if the user opted to only retrieve the resource from cache.
-        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
-      case SOURCE:
-      case FINISHED:
-        return Stage.FINISHED;
-      default:
-        throw new IllegalArgumentException("Unrecognized stage: " + current);
-    }
-  }
-
-  @Override
-  public void reschedule() {
-    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
-    callback.reschedule(this);
-  }
-
-  @Override
-  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
-      DataSource dataSource, Key attemptedKey) {
-    this.currentSourceKey = sourceKey;
-    this.currentData = data;
-    this.currentFetcher = fetcher;
-    this.currentDataSource = dataSource;
-    this.currentAttemptingKey = attemptedKey;
-    if (Thread.currentThread() != currentThread) {
-      runReason = RunReason.DECODE_DATA;
-      callback.reschedule(this);
-    } else {
-      GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");
-      try {
-        decodeFromRetrievedData();
-      } finally {
-        GlideTrace.endSection();
-      }
-    }
-  }
-
-  @Override
-  public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
-      DataSource dataSource) {
-    fetcher.cleanup();
-    GlideException exception = new GlideException("Fetching data failed", e);
-    exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
-    throwables.add(exception);
-    if (Thread.currentThread() != currentThread) {
-      runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
-      callback.reschedule(this);
-    } else {
-      runGenerators();
-    }
-  }
-
-  private void decodeFromRetrievedData() {
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      logWithTimeAndKey("Retrieved data", startFetchTime,
-          "data: " + currentData
-              + ", cache key: " + currentSourceKey
-              + ", fetcher: " + currentFetcher);
-    }
-    Resource<R> resource = null;
-    try {
+		Runnable,
+		Comparable<DecodeJob<?>>,
+		Poolable {
+	private static final String TAG = "DecodeJob";
+
+	private final DecodeHelper<R> decodeHelper = new DecodeHelper<>();
+	private final List<Throwable> throwables = new ArrayList<>();
+	private final StateVerifier stateVerifier = StateVerifier.newInstance();
+	private final DiskCacheProvider diskCacheProvider;
+	private final Pools.Pool<DecodeJob<?>> pool;
+	private final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();
+	private final ReleaseManager releaseManager = new ReleaseManager();
+
+	private GlideContext glideContext;
+	private Key signature;
+	private Priority priority;
+	private EngineKey loadKey;
+	private int width;
+	private int height;
+	private DiskCacheStrategy diskCacheStrategy;
+	private Options options;
+	private Callback<R> callback;
+	private int order;
+	private Stage stage;
+	private RunReason runReason;
+	private long startFetchTime;
+	private boolean onlyRetrieveFromCache;
+	private Object model;
+
+	private Thread currentThread;
+	private Key currentSourceKey;
+	private Key currentAttemptingKey;
+	private Object currentData;
+	private DataSource currentDataSource;
+	private DataFetcher<?> currentFetcher;
+
+	private volatile DataFetcherGenerator currentGenerator;
+	private volatile boolean isCallbackNotified;
+	private volatile boolean isCancelled;
+
+	DecodeJob(DiskCacheProvider diskCacheProvider, Pools.Pool<DecodeJob<?>> pool) {
+		this.diskCacheProvider = diskCacheProvider;
+		this.pool = pool;
+	}
+
+	DecodeJob<R> init(
+			GlideContext glideContext,
+			Object model,
+			EngineKey loadKey,
+			Key signature,
+			int width,
+			int height,
+			Class<?> resourceClass,
+			Class<R> transcodeClass,
+			Priority priority,
+			DiskCacheStrategy diskCacheStrategy,
+			Map<Class<?>, Transformation<?>> transformations,
+			boolean isTransformationRequired,
+			boolean isScaleOnlyOrNoTransform,
+			boolean onlyRetrieveFromCache,
+			Options options,
+			Callback<R> callback,
+			int order) {
+		decodeHelper.init(
+				glideContext,
+				model,
+				signature,
+				width,
+				height,
+				diskCacheStrategy,
+				resourceClass,
+				transcodeClass,
+				priority,
+				options,
+				transformations,
+				isTransformationRequired,
+				isScaleOnlyOrNoTransform,
+				diskCacheProvider);
+		this.glideContext = glideContext;
+		this.signature = signature;
+		this.priority = priority;
+		this.loadKey = loadKey;
+		this.width = width;
+		this.height = height;
+		this.diskCacheStrategy = diskCacheStrategy;
+		this.onlyRetrieveFromCache = onlyRetrieveFromCache;
+		this.options = options;
+		this.callback = callback;
+		this.order = order;
+		this.runReason = RunReason.INITIALIZE;
+		this.model = model;
+		return this;
+	}
+
+	/**
+	 * Returns true if this job will attempt to decode a resource from the disk cache, and false if it
+	 * will always decode from source.
+	 */
+	boolean willDecodeFromCache() {
+		Stage firstStage = getNextStage(Stage.INITIALIZE);
+		return firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE;
+	}
+
+	/**
+	 * Called when this object is no longer in use externally.
+	 *
+	 * @param isRemovedFromQueue {@code true} if we've been removed from the queue and {@link #run} is
+	 *                           neither in progress nor will ever be called again.
+	 */
+	void release(boolean isRemovedFromQueue) {
+		if (releaseManager.release(isRemovedFromQueue)) {
+			releaseInternal();
+		}
+	}
+
+	/**
+	 * Called when we've finished encoding (either because the encode process is complete, or because
+	 * we don't have anything to encode).
+	 */
+	private void onEncodeComplete() {
+		if (releaseManager.onEncodeComplete()) {
+			releaseInternal();
+		}
+	}
+
+	/**
+	 * Called when the load has failed due to a an error or a series of errors.
+	 */
+	private void onLoadFailed() {
+		if (releaseManager.onFailed()) {
+			releaseInternal();
+		}
+	}
+
+	private void releaseInternal() {
+		releaseManager.reset();
+		deferredEncodeManager.clear();
+		decodeHelper.clear();
+		isCallbackNotified = false;
+		glideContext = null;
+		signature = null;
+		options = null;
+		priority = null;
+		loadKey = null;
+		callback = null;
+		stage = null;
+		currentGenerator = null;
+		currentThread = null;
+		currentSourceKey = null;
+		currentData = null;
+		currentDataSource = null;
+		currentFetcher = null;
+		startFetchTime = 0L;
+		isCancelled = false;
+		model = null;
+		throwables.clear();
+		pool.release(this);
+	}
+
+	@Override
+	public int compareTo(@NonNull DecodeJob<?> other) {
+		int result = getPriority() - other.getPriority();
+		if (result == 0) {
+			result = order - other.order;
+		}
+		return result;
+	}
+
+	private int getPriority() {
+		return priority.ordinal();
+	}
+
+	public void cancel() {
+		isCancelled = true;
+		DataFetcherGenerator local = currentGenerator;
+		if (local != null) {
+			local.cancel();
+		}
+	}
+
+	// We need to rethrow only CallbackException, but not other types of Throwables.
+	@SuppressWarnings("PMD.AvoidRethrowingException")
+	@Override
+	public void run() {
+		// This should be much more fine grained, but since Java's thread pool implementation silently
+		// swallows all otherwise fatal exceptions, this will at least make it obvious to developers
+		// that something is failing.
+		GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);
+		// Methods in the try statement can invalidate currentFetcher, so set a local variable here to
+		// ensure that the fetcher is cleaned up either way.
+		DataFetcher<?> localFetcher = currentFetcher;
+		try {
+			if (isCancelled) {
+				notifyFailed();
+				return;
+			}
+			// 主要就是在它里面执行的
+			runWrapped();
+		} catch (CallbackException e) {
+			// If a callback not controlled by Glide throws an exception, we should avoid the Glide
+			// specific debug logic below.
+			throw e;
+		} catch (Throwable t) {
+			// Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our
+			// usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We
+			// are however ensuring that our callbacks are always notified when a load fails. Without this
+			// notification, uncaught throwables never notify the corresponding callbacks, which can cause
+			// loads to silently hang forever, a case that's especially bad for users using Futures on
+			// background threads.
+			if (Log.isLoggable(TAG, Log.DEBUG)) {
+				Log.d(TAG, "DecodeJob threw unexpectedly"
+						+ ", isCancelled: " + isCancelled
+						+ ", stage: " + stage, t);
+			}
+			// When we're encoding we've already notified our callback and it isn't safe to do so again.
+			if (stage != Stage.ENCODE) {
+				throwables.add(t);
+				notifyFailed();
+			}
+			if (!isCancelled) {
+				throw t;
+			}
+			throw t;
+		} finally {
+			// Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call
+			// close in all cases anyway.
+			if (localFetcher != null) {
+				localFetcher.cleanup();
+			}
+			GlideTrace.endSection();
+		}
+	}
+
+	private void runWrapped() {
+		switch (runReason) {
+			case INITIALIZE:
+				stage = getNextStage(Stage.INITIALIZE);
+				currentGenerator = getNextGenerator();
+				runGenerators();
+				break;
+			case SWITCH_TO_SOURCE_SERVICE:
+				runGenerators();
+				break;
+			case DECODE_DATA:
+				decodeFromRetrievedData();
+				break;
+			default:
+				throw new IllegalStateException("Unrecognized run reason: " + runReason);
+		}
+	}
+
+	private DataFetcherGenerator getNextGenerator() {
+		switch (stage) {
+			case RESOURCE_CACHE:
+				return new ResourceCacheGenerator(decodeHelper, this);
+			case DATA_CACHE:
+				return new DataCacheGenerator(decodeHelper, this);
+			case SOURCE:
+				return new SourceGenerator(decodeHelper, this);
+			case FINISHED:
+				return null;
+			default:
+				throw new IllegalStateException("Unrecognized stage: " + stage);
+		}
+	}
+
+	private void runGenerators() {
+		currentThread = Thread.currentThread();
+		startFetchTime = LogTime.getLogTime();
+		boolean isStarted = false;
+		// currentGenerator就是SourceGenerator对象
+		//   runGenerators最重要的就是执行了currentGenerator的startNext方法，这里将会真正的去加载网络资源：
+		while (!isCancelled && currentGenerator != null
+				&& !(isStarted = currentGenerator.startNext())) {
+			stage = getNextStage(stage);
+			currentGenerator = getNextGenerator();
+
+			if (stage == Stage.SOURCE) {
+				reschedule();
+				return;
+			}
+		}
+		// We've run out of stages and generators, give up.
+		if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {
+			notifyFailed();
+		}
+
+		// Otherwise a generator started a new load and we expect to be called back in
+		// onDataFetcherReady.
+	}
+
+	private void notifyFailed() {
+		setNotifiedOrThrow();
+		GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));
+		callback.onLoadFailed(e);
+		onLoadFailed();
+	}
+
+	private void notifyComplete(Resource<R> resource, DataSource dataSource) {
+		setNotifiedOrThrow();
+		callback.onResourceReady(resource, dataSource);
+	}
+
+	private void setNotifiedOrThrow() {
+		stateVerifier.throwIfRecycled();
+		if (isCallbackNotified) {
+			Throwable lastThrown = throwables.isEmpty() ? null : throwables.get(throwables.size() - 1);
+			throw new IllegalStateException("Already notified", lastThrown);
+		}
+		isCallbackNotified = true;
+	}
+
+	private Stage getNextStage(Stage current) {
+		switch (current) {
+			case INITIALIZE:
+				return diskCacheStrategy.decodeCachedResource()
+						? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
+			case RESOURCE_CACHE:
+				return diskCacheStrategy.decodeCachedData()
+						? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
+			case DATA_CACHE:
+				// Skip loading from source if the user opted to only retrieve the resource from cache.
+				return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
+			case SOURCE:
+			case FINISHED:
+				return Stage.FINISHED;
+			default:
+				throw new IllegalArgumentException("Unrecognized stage: " + current);
+		}
+	}
+
+	@Override
+	public void reschedule() {
+		runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
+		callback.reschedule(this);
+	}
+
+	@Override
+	public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
+								   DataSource dataSource, Key attemptedKey) {
+		this.currentSourceKey = sourceKey;
+		this.currentData = data;
+		this.currentFetcher = fetcher;
+		this.currentDataSource = dataSource;
+		this.currentAttemptingKey = attemptedKey;
+		if (Thread.currentThread() != currentThread) {
+			runReason = RunReason.DECODE_DATA;
+			callback.reschedule(this);
+		} else {
+			GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");
+			try {
+				decodeFromRetrievedData();
+			} finally {
+				GlideTrace.endSection();
+			}
+		}
+	}
+
+	@Override
+	public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
+									DataSource dataSource) {
+		fetcher.cleanup();
+		GlideException exception = new GlideException("Fetching data failed", e);
+		exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
+		throwables.add(exception);
+		if (Thread.currentThread() != currentThread) {
+			runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
+			callback.reschedule(this);
+		} else {
+			runGenerators();
+		}
+	}
+
+	private void decodeFromRetrievedData() {
+		if (Log.isLoggable(TAG, Log.VERBOSE)) {
+			logWithTimeAndKey("Retrieved data", startFetchTime,
+					"data: " + currentData
+							+ ", cache key: " + currentSourceKey
+							+ ", fetcher: " + currentFetcher);
+		}
+		Resource<R> resource = null;
+		try {
 //      首先创建一个Resource类型的变量，通过decodeFromData方法把输入流解码并返回给resource，
 //      由此可也看出，解码主要是在decodeFromData方法中：
-      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
-    } catch (GlideException e) {
-      e.setLoggingDetails(currentAttemptingKey, currentDataSource);
-      throwables.add(e);
-    }
-    if (resource != null) {
-      notifyEncodeAndRelease(resource, currentDataSource);
-    } else {
-      runGenerators();
-    }
-  }
-
-  private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {
-    if (resource instanceof Initializable) {
-      ((Initializable) resource).initialize();
-    }
-
-    Resource<R> result = resource;
-    LockedResource<R> lockedResource = null;
-    if (deferredEncodeManager.hasResourceToEncode()) {
-      lockedResource = LockedResource.obtain(resource);
-      result = lockedResource;
-    }
-
-    notifyComplete(result, dataSource);
-
-    stage = Stage.ENCODE;
-    try {
-      if (deferredEncodeManager.hasResourceToEncode()) {
-        deferredEncodeManager.encode(diskCacheProvider, options);
-      }
-    } finally {
-      if (lockedResource != null) {
-        lockedResource.unlock();
-      }
-    }
-    // Call onEncodeComplete outside the finally block so that it's not called if the encode process
-    // throws.
-    onEncodeComplete();
-  }
-
-  private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
-      DataSource dataSource) throws GlideException {
-    try {
-      if (data == null) {
-        return null;
-      }
-      long startTime = LogTime.getLogTime();
-      Resource<R> result = decodeFromFetcher(data, dataSource);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        logWithTimeAndKey("Decoded result " + result, startTime);
-      }
-      return result;
-    } finally {
+			resource = decodeFromData(currentFetcher, currentData, currentDataSource);
+		} catch (GlideException e) {
+			e.setLoggingDetails(currentAttemptingKey, currentDataSource);
+			throwables.add(e);
+		}
+		if (resource != null) {
+			notifyEncodeAndRelease(resource, currentDataSource);
+		} else {
+			runGenerators();
+		}
+	}
+
+	private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {
+		if (resource instanceof Initializable) {
+			((Initializable) resource).initialize();
+		}
+
+		Resource<R> result = resource;
+		LockedResource<R> lockedResource = null;
+		if (deferredEncodeManager.hasResourceToEncode()) {
+			lockedResource = LockedResource.obtain(resource);
+			result = lockedResource;
+		}
+
+		notifyComplete(result, dataSource);
+
+		stage = Stage.ENCODE;
+		try {
+			if (deferredEncodeManager.hasResourceToEncode()) {
+				deferredEncodeManager.encode(diskCacheProvider, options);
+			}
+		} finally {
+			if (lockedResource != null) {
+				lockedResource.unlock();
+			}
+		}
+		// Call onEncodeComplete outside the finally block so that it's not called if the encode process
+		// throws.
+		onEncodeComplete();
+	}
+
+	private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
+											  DataSource dataSource) throws GlideException {
+		try {
+			if (data == null) {
+				return null;
+			}
+			long startTime = LogTime.getLogTime();
+			Resource<R> result = decodeFromFetcher(data, dataSource);
+			if (Log.isLoggable(TAG, Log.VERBOSE)) {
+				logWithTimeAndKey("Decoded result " + result, startTime);
+			}
+			return result;
+		} finally {
 //      在这里已经体现loadData.fetcher这个fetcher的用意，主要是去关闭输入流和HttpUrlConnection的。
-      fetcher.cleanup();
-    }
-  }
-
-  @SuppressWarnings("unchecked")
-  private <Data> Resource<R> decodeFromFetcher(Data data, DataSource dataSource)
-      throws GlideException {
-    LoadPath<Data, ?, R> path = decodeHelper.getLoadPath((Class<Data>) data.getClass());
-    return runLoadPath(data, dataSource, path);
-  }
-
-  @NonNull
-  private Options getOptionsWithHardwareConfig(DataSource dataSource) {
-    Options options = this.options;
-    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
-      return options;
-    }
-
-    boolean isHardwareConfigSafe =
-        dataSource == DataSource.RESOURCE_DISK_CACHE || decodeHelper.isScaleOnlyOrNoTransform();
-    Boolean isHardwareConfigAllowed = options.get(Downsampler.ALLOW_HARDWARE_CONFIG);
-
-    // If allow hardware config is defined, we can use it if it's set to false or if it's safe to
-    // use the hardware config for the request.
-    if (isHardwareConfigAllowed != null && (!isHardwareConfigAllowed || isHardwareConfigSafe)) {
-      return options;
-    }
-
-    // If allow hardware config is undefined or is set to true but it's unsafe for us to use the
-    // hardware config for this request, we need to override the config.
-    options = new Options();
-    options.putAll(this.options);
-    options.set(Downsampler.ALLOW_HARDWARE_CONFIG, isHardwareConfigSafe);
-
-    return options;
-  }
-
-  private <Data, ResourceType> Resource<R> runLoadPath(Data data, DataSource dataSource,
-      LoadPath<Data, ResourceType, R> path) throws GlideException {
-    Options options = getOptionsWithHardwareConfig(dataSource);
-    DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);
-    try {
-      // ResourceType in DecodeCallback below is required for compilation to work with gradle.
-      return path.load(
-          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));
-    } finally {
-      rewinder.cleanup();
-    }
-  }
-
-  private void logWithTimeAndKey(String message, long startTime) {
-    logWithTimeAndKey(message, startTime, null /*extraArgs*/);
-  }
-
-  private void logWithTimeAndKey(String message, long startTime, String extraArgs) {
-    Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + ", load key: " + loadKey
-        + (extraArgs != null ? ", " + extraArgs : "") + ", thread: "
-        + Thread.currentThread().getName());
-  }
-
-  @NonNull
-  @Override
-  public StateVerifier getVerifier() {
-    return stateVerifier;
-  }
-
-  @Synthetic
-  @NonNull
-  <Z> Resource<Z> onResourceDecoded(DataSource dataSource,
-      @NonNull Resource<Z> decoded) {
-    @SuppressWarnings("unchecked")
-    Class<Z> resourceSubClass = (Class<Z>) decoded.get().getClass();
-    Transformation<Z> appliedTransformation = null;
-    Resource<Z> transformed = decoded;
-    if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
-      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
-      transformed = appliedTransformation.transform(glideContext, decoded, width, height);
-    }
-    // TODO: Make this the responsibility of the Transformation.
-    if (!decoded.equals(transformed)) {
-      decoded.recycle();
-    }
-
-    final EncodeStrategy encodeStrategy;
-    final ResourceEncoder<Z> encoder;
-    if (decodeHelper.isResourceEncoderAvailable(transformed)) {
-      encoder = decodeHelper.getResultEncoder(transformed);
-      encodeStrategy = encoder.getEncodeStrategy(options);
-    } else {
-      encoder = null;
-      encodeStrategy = EncodeStrategy.NONE;
-    }
-
-    Resource<Z> result = transformed;
-    boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
-    if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
-        encodeStrategy)) {
-      if (encoder == null) {
-        throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
-      }
-      final Key key;
-      switch (encodeStrategy) {
-        case SOURCE:
-          key = new DataCacheKey(currentSourceKey, signature);
-          break;
-        case TRANSFORMED:
-          key =
-              new ResourceCacheKey(
-                  decodeHelper.getArrayPool(),
-                  currentSourceKey,
-                  signature,
-                  width,
-                  height,
-                  appliedTransformation,
-                  resourceSubClass,
-                  options);
-          break;
-        default:
-          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
-      }
-
-      LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
-      deferredEncodeManager.init(key, encoder, lockedResult);
-      result = lockedResult;
-    }
-    return result;
-  }
-
-  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
-
-    private final DataSource dataSource;
-
-    @Synthetic
-    DecodeCallback(DataSource dataSource) {
-      this.dataSource = dataSource;
-    }
-
-    @NonNull
-    @Override
-    public Resource<Z> onResourceDecoded(@NonNull Resource<Z> decoded) {
-      return DecodeJob.this.onResourceDecoded(dataSource, decoded);
-    }
-  }
-
-  /**
-   * Responsible for indicating when it is safe for the job to be cleared and returned to the pool.
-   */
-  private static class ReleaseManager {
-    private boolean isReleased;
-    private boolean isEncodeComplete;
-    private boolean isFailed;
-
-    @Synthetic
-    ReleaseManager() { }
-
-    synchronized boolean release(boolean isRemovedFromQueue) {
-      isReleased = true;
-      return isComplete(isRemovedFromQueue);
-    }
-
-    synchronized boolean onEncodeComplete() {
-      isEncodeComplete = true;
-      return isComplete(false /*isRemovedFromQueue*/);
-    }
-
-    synchronized boolean onFailed() {
-      isFailed = true;
-      return isComplete(false /*isRemovedFromQueue*/);
-    }
-
-    synchronized void reset() {
-      isEncodeComplete = false;
-      isReleased = false;
-      isFailed = false;
-    }
-
-    private boolean isComplete(boolean isRemovedFromQueue) {
-      return (isFailed || isRemovedFromQueue || isEncodeComplete) && isReleased;
-    }
-  }
-
-  /**
-   * Allows transformed resources to be encoded after the transcoded result is already delivered to
-   * requestors.
-   */
-  private static class DeferredEncodeManager<Z> {
-    private Key key;
-    private ResourceEncoder<Z> encoder;
-    private LockedResource<Z> toEncode;
-
-    @Synthetic
-    DeferredEncodeManager() { }
-
-    // We just need the encoder and resource type to match, which this will enforce.
-    @SuppressWarnings("unchecked")
-    <X> void init(Key key, ResourceEncoder<X> encoder, LockedResource<X> toEncode) {
-      this.key = key;
-      this.encoder = (ResourceEncoder<Z>) encoder;
-      this.toEncode = (LockedResource<Z>) toEncode;
-    }
-
-    void encode(DiskCacheProvider diskCacheProvider, Options options) {
-      GlideTrace.beginSection("DecodeJob.encode");
-      try {
-        diskCacheProvider.getDiskCache().put(key,
-            new DataCacheWriter<>(encoder, toEncode, options));
-      } finally {
-        toEncode.unlock();
-        GlideTrace.endSection();
-      }
-    }
-
-    boolean hasResourceToEncode() {
-      return toEncode != null;
-    }
-
-    void clear() {
-      key = null;
-      encoder = null;
-      toEncode = null;
-    }
-  }
-
-  interface Callback<R> {
-
-    void onResourceReady(Resource<R> resource, DataSource dataSource);
-
-    void onLoadFailed(GlideException e);
-
-    void reschedule(DecodeJob<?> job);
-  }
-
-  interface DiskCacheProvider {
-    DiskCache getDiskCache();
-  }
-
-  /**
-   * Why we're being executed again.
-   */
-  private enum RunReason {
-    /** The first time we've been submitted. */
-    INITIALIZE,
-    /**
-     * We want to switch from the disk cache service to the source executor.
-     */
-    SWITCH_TO_SOURCE_SERVICE,
-    /**
-     * We retrieved some data on a thread we don't own and want to switch back to our thread to
-     * process the data.
-     */
-    DECODE_DATA,
-  }
-
-  /**
-   * Where we're trying to decode data from.
-   */
-  private enum Stage {
-    /** The initial stage. */
-    INITIALIZE,
-    /** Decode from a cached resource. */
-    RESOURCE_CACHE,
-    /** Decode from cached source data. */
-    DATA_CACHE,
-    /** Decode from retrieved source. */
-    SOURCE,
-    /** Encoding transformed resources after a successful load. */
-    ENCODE,
-    /** No more viable stages. */
-    FINISHED,
-  }
+			fetcher.cleanup();
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	private <Data> Resource<R> decodeFromFetcher(Data data, DataSource dataSource)
+			throws GlideException {
+		LoadPath<Data, ?, R> path = decodeHelper.getLoadPath((Class<Data>) data.getClass());
+		return runLoadPath(data, dataSource, path);
+	}
+
+	@NonNull
+	private Options getOptionsWithHardwareConfig(DataSource dataSource) {
+		Options options = this.options;
+		if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+			return options;
+		}
+
+		boolean isHardwareConfigSafe =
+				dataSource == DataSource.RESOURCE_DISK_CACHE || decodeHelper.isScaleOnlyOrNoTransform();
+		Boolean isHardwareConfigAllowed = options.get(Downsampler.ALLOW_HARDWARE_CONFIG);
+
+		// If allow hardware config is defined, we can use it if it's set to false or if it's safe to
+		// use the hardware config for the request.
+		if (isHardwareConfigAllowed != null && (!isHardwareConfigAllowed || isHardwareConfigSafe)) {
+			return options;
+		}
+
+		// If allow hardware config is undefined or is set to true but it's unsafe for us to use the
+		// hardware config for this request, we need to override the config.
+		options = new Options();
+		options.putAll(this.options);
+		options.set(Downsampler.ALLOW_HARDWARE_CONFIG, isHardwareConfigSafe);
+
+		return options;
+	}
+
+	private <Data, ResourceType> Resource<R> runLoadPath(Data data, DataSource dataSource,
+														 LoadPath<Data, ResourceType, R> path) throws GlideException {
+		Options options = getOptionsWithHardwareConfig(dataSource);
+		DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);
+		try {
+			// ResourceType in DecodeCallback below is required for compilation to work with gradle.
+			return path.load(
+					rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));
+		} finally {
+			rewinder.cleanup();
+		}
+	}
+
+	private void logWithTimeAndKey(String message, long startTime) {
+		logWithTimeAndKey(message, startTime, null /*extraArgs*/);
+	}
+
+	private void logWithTimeAndKey(String message, long startTime, String extraArgs) {
+		Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + ", load key: " + loadKey
+				+ (extraArgs != null ? ", " + extraArgs : "") + ", thread: "
+				+ Thread.currentThread().getName());
+	}
+
+	@NonNull
+	@Override
+	public StateVerifier getVerifier() {
+		return stateVerifier;
+	}
+
+	@Synthetic
+	@NonNull
+	<Z> Resource<Z> onResourceDecoded(DataSource dataSource,
+									  @NonNull Resource<Z> decoded) {
+		@SuppressWarnings("unchecked")
+		Class<Z> resourceSubClass = (Class<Z>) decoded.get().getClass();
+		Transformation<Z> appliedTransformation = null;
+		Resource<Z> transformed = decoded;
+		if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
+			appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
+			transformed = appliedTransformation.transform(glideContext, decoded, width, height);
+		}
+		// TODO: Make this the responsibility of the Transformation.
+		if (!decoded.equals(transformed)) {
+			decoded.recycle();
+		}
+
+		final EncodeStrategy encodeStrategy;
+		final ResourceEncoder<Z> encoder;
+		if (decodeHelper.isResourceEncoderAvailable(transformed)) {
+			encoder = decodeHelper.getResultEncoder(transformed);
+			encodeStrategy = encoder.getEncodeStrategy(options);
+		} else {
+			encoder = null;
+			encodeStrategy = EncodeStrategy.NONE;
+		}
+
+		Resource<Z> result = transformed;
+		boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
+		if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
+				encodeStrategy)) {
+			if (encoder == null) {
+				throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
+			}
+			final Key key;
+			switch (encodeStrategy) {
+				// 原始的
+				case SOURCE:
+					key = new DataCacheKey(currentSourceKey, signature);
+					break;
+				// 转换过的
+				case TRANSFORMED:
+					key =
+							new ResourceCacheKey(
+									decodeHelper.getArrayPool(),
+									currentSourceKey,
+									signature,
+									width,
+									height,
+									appliedTransformation,
+									resourceSubClass,
+									options);
+					break;
+				default:
+					throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
+			}
+
+			LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
+			deferredEncodeManager.init(key, encoder, lockedResult);
+			result = lockedResult;
+		}
+		return result;
+	}
+
+	private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
+
+		private final DataSource dataSource;
+
+		@Synthetic
+		DecodeCallback(DataSource dataSource) {
+			this.dataSource = dataSource;
+		}
+
+		@NonNull
+		@Override
+		public Resource<Z> onResourceDecoded(@NonNull Resource<Z> decoded) {
+			return DecodeJob.this.onResourceDecoded(dataSource, decoded);
+		}
+	}
+
+	/**
+	 * Responsible for indicating when it is safe for the job to be cleared and returned to the pool.
+	 */
+	private static class ReleaseManager {
+		private boolean isReleased;
+		private boolean isEncodeComplete;
+		private boolean isFailed;
+
+		@Synthetic
+		ReleaseManager() {
+		}
+
+		synchronized boolean release(boolean isRemovedFromQueue) {
+			isReleased = true;
+			return isComplete(isRemovedFromQueue);
+		}
+
+		synchronized boolean onEncodeComplete() {
+			isEncodeComplete = true;
+			return isComplete(false /*isRemovedFromQueue*/);
+		}
+
+		synchronized boolean onFailed() {
+			isFailed = true;
+			return isComplete(false /*isRemovedFromQueue*/);
+		}
+
+		synchronized void reset() {
+			isEncodeComplete = false;
+			isReleased = false;
+			isFailed = false;
+		}
+
+		private boolean isComplete(boolean isRemovedFromQueue) {
+			return (isFailed || isRemovedFromQueue || isEncodeComplete) && isReleased;
+		}
+	}
+
+	/**
+	 * Allows transformed resources to be encoded after the transcoded result is already delivered to
+	 * requestors.
+	 */
+	private static class DeferredEncodeManager<Z> {
+		private Key key;
+		private ResourceEncoder<Z> encoder;
+		private LockedResource<Z> toEncode;
+
+		@Synthetic
+		DeferredEncodeManager() {
+		}
+
+		// We just need the encoder and resource type to match, which this will enforce.
+		@SuppressWarnings("unchecked")
+		<X> void init(Key key, ResourceEncoder<X> encoder, LockedResource<X> toEncode) {
+			this.key = key;
+			this.encoder = (ResourceEncoder<Z>) encoder;
+			this.toEncode = (LockedResource<Z>) toEncode;
+		}
+
+		void encode(DiskCacheProvider diskCacheProvider, Options options) {
+			GlideTrace.beginSection("DecodeJob.encode");
+			// 保存缓存进disk
+			try {
+				diskCacheProvider.getDiskCache().put(key,
+						new DataCacheWriter<>(encoder, toEncode, options));
+			} finally {
+				toEncode.unlock();
+				GlideTrace.endSection();
+			}
+		}
+
+		boolean hasResourceToEncode() {
+			return toEncode != null;
+		}
+
+		void clear() {
+			key = null;
+			encoder = null;
+			toEncode = null;
+		}
+	}
+
+	interface Callback<R> {
+
+		void onResourceReady(Resource<R> resource, DataSource dataSource);
+
+		void onLoadFailed(GlideException e);
+
+		void reschedule(DecodeJob<?> job);
+	}
+
+	interface DiskCacheProvider {
+		DiskCache getDiskCache();
+	}
+
+	/**
+	 * Why we're being executed again.
+	 */
+	private enum RunReason {
+		/**
+		 * The first time we've been submitted.
+		 */
+		INITIALIZE,
+		/**
+		 * We want to switch from the disk cache service to the source executor.
+		 */
+		SWITCH_TO_SOURCE_SERVICE,
+		/**
+		 * We retrieved some data on a thread we don't own and want to switch back to our thread to
+		 * process the data.
+		 */
+		DECODE_DATA,
+	}
+
+	/**
+	 * Where we're trying to decode data from.
+	 */
+	private enum Stage {
+		/**
+		 * The initial stage.
+		 */
+		INITIALIZE,
+		/**
+		 * Decode from a cached resource.
+		 */
+		RESOURCE_CACHE,
+		/**
+		 * Decode from cached source data.
+		 */
+		DATA_CACHE,
+		/**
+		 * Decode from retrieved source.
+		 */
+		SOURCE,
+		/**
+		 * Encoding transformed resources after a successful load.
+		 */
+		ENCODE,
+		/**
+		 * No more viable stages.
+		 */
+		FINISHED,
+	}
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index bdfce652a..e15eca16e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -182,6 +182,7 @@ public Engine(
 //从弱引用 获取
 //		根据创建的key对象分别调用loadFromCache和loadFromActiveResources方法来从内存中查
 //		找是否有缓存资源，如果有，则回调cb.onResourceReady来直接设置图片了。
+		//是第一级缓存，表示当前正在活动中的资源。
 		EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
 		if (active != null) {
 			cb.onResourceReady(active, DataSource.MEMORY_CACHE);
@@ -199,11 +200,7 @@ public Engine(
 			}
 			return null;
 		}
-//
-//④：分别使用engineJobFactory和decodeJobFactory构建EngineJob和DecodeJob对象，这两个对象是真正的加载资源的两个重要类，
-// EngineJob对象负责开启线程去加载资源，并且加载得资源后转换到主线程并进行回调；DecodeJob是真正的执行者，它就是去网络
-// 加载资源的地方，EngineJob开启线程，
-//		真正执行的是DecodeJob，DecodeJob之后完毕之后叫道EngineJob去分发回调。这就是这两个类的关系。
+
 		EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
 		if (current != null) {
 			current.addCallback(cb, callbackExecutor);
@@ -212,7 +209,7 @@ public Engine(
 			}
 			return new LoadStatus(cb, current);
 		}
-//		EngineJob和DecodeJob的构建是基本一致的，我们看看比较复杂的DecodeJob的构建：在build方法中，首先通过pool来创建
+//		EngineJob和DecodeJob的构建是基本一致的，比较复杂的DecodeJob的构建：在build方法中，首先通过pool来创建
 // 一个DecodeJob对象，然后调用DecodeJob对象的init方法进行初始化，在初始化中值得注意的是调用了decodeHelper
 // 对象的init方法。decodeHelper方法是DecodeJob的重要辅助类，后面我们会详细的接触它。
 		EngineJob<R> engineJob =
@@ -245,6 +242,10 @@ public Engine(
 		jobs.put(key, engineJob);
 //上面也提到回调，这里先cb添加到engineJob.addCallback();中，然后调用EngineJob的start方法来开启线程。
 		engineJob.addCallback(cb, callbackExecutor);
+// ④：分别使用engineJobFactory和decodeJobFactory构建EngineJob和DecodeJob对象，这两个对象是真正的加载资源的两个重要类，
+// EngineJob对象负责开启线程去加载资源，并且加载得资源后转换到主线程并进行回调；DecodeJob是真正的执行者，它就是去网络
+// 加载资源的地方，EngineJob开启线程，
+// 真正执行的是DecodeJob，DecodeJob之后完毕之后叫道EngineJob去分发回调。这就是这两个类的关系。
 		engineJob.start(decodeJob);
 
 		if (VERBOSE_IS_LOGGABLE) {
@@ -335,6 +336,7 @@ public synchronized void onResourceReleased(Key cacheKey, EngineResource<?> reso
 		if (resource.isMemoryCacheable()) {
 			cache.put(cacheKey, resource);
 		} else {
+			//bitmapPool.put(drawable.getBitmap()); 回收是放进bitmapPool中，因为弱引用，随时被回收
 			resourceRecycler.recycle(resource);
 		}
 	}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 0a1846c95..b642d0be0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -3,6 +3,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.support.v4.util.Pools;
+
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
@@ -13,6 +14,7 @@
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -124,6 +126,7 @@
     return this;
   }
 
+  // XXX: 开启线程执行图片加载 
   public synchronized void start(DecodeJob<R> decodeJob) {
     this.decodeJob = decodeJob;
     GlideExecutor executor = decodeJob.willDecodeFromCache()
@@ -200,7 +203,6 @@ void cancel() {
     if (isDone()) {
       return;
     }
-
     isCancelled = true;
     decodeJob.cancel();
     engineJobListener.onEngineJobCancelled(this, key);
@@ -278,7 +280,6 @@ synchronized void decrementPendingCallbacks() {
       if (engineResource != null) {
         engineResource.release();
       }
-
       release();
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/manager/LifecycleListener.java b/library/src/main/java/com/bumptech/glide/manager/LifecycleListener.java
index 0a546f418..81d9e6cbb 100644
--- a/library/src/main/java/com/bumptech/glide/manager/LifecycleListener.java
+++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleListener.java
@@ -4,6 +4,7 @@
  * An interface for listener to {@link android.app.Fragment} and {@link android.app.Activity}
  * lifecycle events.
  */
+// XXX: requestManager有继承的 
 public interface LifecycleListener {
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index a8260fa81..b9e749db8 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -21,10 +21,12 @@
 import android.support.v4.util.ArrayMap;
 import android.util.Log;
 import android.view.View;
+
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
+
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
@@ -34,461 +36,474 @@
  * retrieving existing ones from activities and fragment.
  */
 public class RequestManagerRetriever implements Handler.Callback {
-  @VisibleForTesting
-  static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
-  private static final String TAG = "RMRetriever";
-
-  private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
-  private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
-
-  // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
-  // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
-  private static final String FRAGMENT_INDEX_KEY = "key";
-
-  /**
-   * The top application level RequestManager.
-   */
-  private volatile RequestManager applicationManager;
-
-  /**
-   * Pending adds for RequestManagerFragments.
-   */
-  @SuppressWarnings("deprecation")
-  @VisibleForTesting
-  final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
-      new HashMap<>();
-
-  /**
-   * Pending adds for SupportRequestManagerFragments.
-   */
-  @VisibleForTesting
-  final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
-      new HashMap<>();
-
-  /**
-   * Main thread handler to handle cleaning up pending fragment maps.
-   */
-  private final Handler handler;
-  private final RequestManagerFactory factory;
-
-  // Objects used to find Fragments and Activities containing views.
-  private final ArrayMap<View, Fragment> tempViewToSupportFragment = new ArrayMap<>();
-  private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
-  private final Bundle tempBundle = new Bundle();
-
-  public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
-    this.factory = factory != null ? factory : DEFAULT_FACTORY;
-    handler = new Handler(Looper.getMainLooper(), this /* Callback */);
-  }
-
-  @NonNull
-  private RequestManager getApplicationManager(@NonNull Context context) {
-    // Either an application context or we're on a background thread.
-    if (applicationManager == null) {
-      synchronized (this) {
-        if (applicationManager == null) {
-          // Normally pause/resume is taken care of by the fragment we add to the fragment or
-          // activity. However, in this case since the manager attached to the application will not
-          // receive lifecycle events, we must force the manager to start resumed using
-          // ApplicationLifecycle.
-
-          // TODO(b/27524013): Factor out this Glide.get() call.
-          Glide glide = Glide.get(context.getApplicationContext());
-          applicationManager =
-              factory.build(
-                  glide,
-                  new ApplicationLifecycle(),
-                  new EmptyRequestManagerTreeNode(),
-                  context.getApplicationContext());
-        }
-      }
-    }
-
-    return applicationManager;
-  }
-
-  @NonNull
-  public RequestManager get(@NonNull Context context) {
-    if (context == null) {
-      throw new IllegalArgumentException("You cannot start a load on a null Context");
-    } else if (Util.isOnMainThread() && !(context instanceof Application)) {
-      if (context instanceof FragmentActivity) {
-        return get((FragmentActivity) context);
-      } else if (context instanceof Activity) {
-        return get((Activity) context);
-      } else if (context instanceof ContextWrapper) {
-        return get(((ContextWrapper) context).getBaseContext());
-      }
-    }
-
-    return getApplicationManager(context);
-  }
-
-  @NonNull
-  public RequestManager get(@NonNull FragmentActivity activity) {
-    if (Util.isOnBackgroundThread()) {
-      return get(activity.getApplicationContext());
-    } else {
-      assertNotDestroyed(activity);
-      FragmentManager fm = activity.getSupportFragmentManager();
-      return supportFragmentGet(
-          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
-    }
-  }
-
-  @NonNull
-  public RequestManager get(@NonNull Fragment fragment) {
-    Preconditions.checkNotNull(fragment.getActivity(),
-          "You cannot start a load on a fragment before it is attached or after it is destroyed");
-    if (Util.isOnBackgroundThread()) {
-      return get(fragment.getActivity().getApplicationContext());
-    } else {
-      FragmentManager fm = fragment.getChildFragmentManager();
-      return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
-    }
-  }
-
-  @SuppressWarnings("deprecation")
-  @NonNull
-  public RequestManager get(@NonNull Activity activity) {
-    if (Util.isOnBackgroundThread()) {
-      return get(activity.getApplicationContext());
-    } else {
-      assertNotDestroyed(activity);
-      android.app.FragmentManager fm = activity.getFragmentManager();
-      return fragmentGet(
-          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
-    }
-  }
-
-  @SuppressWarnings("deprecation")
-  @NonNull
-  public RequestManager get(@NonNull View view) {
-    if (Util.isOnBackgroundThread()) {
-      return get(view.getContext().getApplicationContext());
-    }
-
-    Preconditions.checkNotNull(view);
-    Preconditions.checkNotNull(view.getContext(),
-        "Unable to obtain a request manager for a view without a Context");
-    Activity activity = findActivity(view.getContext());
-    // The view might be somewhere else, like a service.
-    if (activity == null) {
-      return get(view.getContext().getApplicationContext());
-    }
-
-    // Support Fragments.
-    // Although the user might have non-support Fragments attached to FragmentActivity, searching
-    // for non-support Fragments is so expensive pre O and that should be rare enough that we
-    // prefer to just fall back to the Activity directly.
-    if (activity instanceof FragmentActivity) {
-      Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
-      return fragment != null ? get(fragment) : get(activity);
-    }
-
-    // Standard Fragments.
-    android.app.Fragment fragment = findFragment(view, activity);
-    if (fragment == null) {
-      return get(activity);
-    }
-    return get(fragment);
-  }
-
-  private static void findAllSupportFragmentsWithViews(
-      @Nullable Collection<Fragment> topLevelFragments,
-      @NonNull Map<View, Fragment> result) {
-    if (topLevelFragments == null) {
-      return;
-    }
-    for (Fragment fragment : topLevelFragments) {
-      // getFragment()s in the support FragmentManager may contain null values, see #1991.
-      if (fragment == null || fragment.getView() == null) {
-        continue;
-      }
-      result.put(fragment.getView(), fragment);
-      findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);
-    }
-  }
-
-  @Nullable
-  private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {
-    tempViewToSupportFragment.clear();
-    findAllSupportFragmentsWithViews(
-        activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
-    Fragment result = null;
-    View activityRoot = activity.findViewById(android.R.id.content);
-    View current = target;
-    while (!current.equals(activityRoot)) {
-      result = tempViewToSupportFragment.get(current);
-      if (result != null) {
-        break;
-      }
-      if (current.getParent() instanceof View) {
-        current = (View) current.getParent();
-      } else {
-        break;
-      }
-    }
-
-    tempViewToSupportFragment.clear();
-    return result;
-  }
-
-  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
-  @Deprecated
-  @Nullable
-  private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) {
-    tempViewToFragment.clear();
-    findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
-
-    android.app.Fragment result = null;
-
-    View activityRoot = activity.findViewById(android.R.id.content);
-    View current = target;
-    while (!current.equals(activityRoot)) {
-      result = tempViewToFragment.get(current);
-      if (result != null) {
-        break;
-      }
-      if (current.getParent() instanceof View) {
-        current = (View) current.getParent();
-      } else {
-        break;
-      }
-    }
-    tempViewToFragment.clear();
-    return result;
-  }
-
-  // TODO: Consider using an accessor class in the support library package to more directly retrieve
-  // non-support Fragments.
-  @SuppressWarnings("deprecation")
-  @Deprecated
-  @TargetApi(Build.VERSION_CODES.O)
-  private void findAllFragmentsWithViews(
-      @NonNull android.app.FragmentManager fragmentManager,
-      @NonNull ArrayMap<View, android.app.Fragment> result) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-      for (android.app.Fragment fragment : fragmentManager.getFragments()) {
-        if (fragment.getView() != null) {
-          result.put(fragment.getView(), fragment);
-          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
-        }
-      }
-    } else {
-      findAllFragmentsWithViewsPreO(fragmentManager, result);
-    }
-  }
-
-  @SuppressWarnings("deprecation")
-  @Deprecated
-  private void findAllFragmentsWithViewsPreO(
-      @NonNull android.app.FragmentManager fragmentManager,
-      @NonNull ArrayMap<View, android.app.Fragment> result) {
-    int index = 0;
-    while (true) {
-      tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
-      android.app.Fragment fragment = null;
-      try {
-        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_INDEX_KEY);
-      } catch (Exception e) {
-        // This generates log spam from FragmentManager anyway.
-      }
-      if (fragment == null) {
-        break;
-      }
-      if (fragment.getView() != null) {
-        result.put(fragment.getView(), fragment);
-        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) {
-          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
-        }
-      }
-    }
-  }
-
-  @Nullable
-  private Activity findActivity(@NonNull Context context) {
-    if (context instanceof Activity) {
-      return (Activity) context;
-    } else if (context instanceof ContextWrapper) {
-      return findActivity(((ContextWrapper) context).getBaseContext());
-    } else {
-      return null;
-    }
-  }
-
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  private static void assertNotDestroyed(@NonNull Activity activity) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
-      throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
-    }
-  }
-
-  @SuppressWarnings("deprecation")
-  @Deprecated
-  @NonNull
-  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-  public RequestManager get(@NonNull android.app.Fragment fragment) {
-    if (fragment.getActivity() == null) {
-      throw new IllegalArgumentException(
-          "You cannot start a load on a fragment before it is attached");
-    }
-    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
-      return get(fragment.getActivity().getApplicationContext());
-    } else {
-      android.app.FragmentManager fm = fragment.getChildFragmentManager();
-      return fragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
-    }
-  }
-
-  @SuppressWarnings("deprecation")
-  @Deprecated
-  @NonNull
-  RequestManagerFragment getRequestManagerFragment(Activity activity) {
-    return getRequestManagerFragment(
-        activity.getFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
-  }
-
-  @SuppressWarnings("deprecation")
-  @NonNull
-  private RequestManagerFragment getRequestManagerFragment(
-      @NonNull final android.app.FragmentManager fm,
-      @Nullable android.app.Fragment parentHint,
-      boolean isParentVisible) {
-    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
-    if (current == null) {
-      current = pendingRequestManagerFragments.get(fm);
-      if (current == null) {
-        current = new RequestManagerFragment();
-        current.setParentFragmentHint(parentHint);
-        if (isParentVisible) {
-          current.getGlideLifecycle().onStart();
-        }
-        pendingRequestManagerFragments.put(fm, current);
-        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
-        handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
-      }
-    }
-    return current;
-  }
-
-  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
-  @Deprecated
-  @NonNull
-  private RequestManager fragmentGet(@NonNull Context context,
-      @NonNull android.app.FragmentManager fm,
-      @Nullable android.app.Fragment parentHint,
-      boolean isParentVisible) {
-    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);
-    RequestManager requestManager = current.getRequestManager();
-    if (requestManager == null) {
-      // TODO(b/27524013): Factor out this Glide.get() call.
-      Glide glide = Glide.get(context);
-      requestManager =
-          factory.build(
-              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
-      current.setRequestManager(requestManager);
-    }
-    return requestManager;
-  }
-
-  @NonNull
-  SupportRequestManagerFragment getSupportRequestManagerFragment(FragmentActivity activity) {
-    return getSupportRequestManagerFragment(
-        activity.getSupportFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
-  }
-
-  private static boolean isActivityVisible(Activity activity) {
-    // This is a poor heuristic, but it's about all we have. We'd rather err on the side of visible
-    // and start requests than on the side of invisible and ignore valid requests.
-    return !activity.isFinishing();
-  }
-
-  @NonNull
-  private SupportRequestManagerFragment getSupportRequestManagerFragment(
-      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {
-    SupportRequestManagerFragment current =
-        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
-    if (current == null) {
-      current = pendingSupportRequestManagerFragments.get(fm);
-      if (current == null) {
-        current = new SupportRequestManagerFragment();
-        current.setParentFragmentHint(parentHint);
-        if (isParentVisible) {
-          current.getGlideLifecycle().onStart();
-        }
-        pendingSupportRequestManagerFragments.put(fm, current);
-        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
-        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
-      }
-    }
-    return current;
-  }
-
-  @NonNull
-  private RequestManager supportFragmentGet(
-      @NonNull Context context,
-      @NonNull FragmentManager fm,
-      @Nullable Fragment parentHint,
-      boolean isParentVisible) {
-    SupportRequestManagerFragment current =
-        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);
-    RequestManager requestManager = current.getRequestManager();
-    if (requestManager == null) {
-      // TODO(b/27524013): Factor out this Glide.get() call.
-      Glide glide = Glide.get(context);
-      requestManager =
-          factory.build(
-              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
-      current.setRequestManager(requestManager);
-    }
-    return requestManager;
-  }
-
-  @Override
-  public boolean handleMessage(Message message) {
-    boolean handled = true;
-    Object removed = null;
-    Object key = null;
-    switch (message.what) {
-      case ID_REMOVE_FRAGMENT_MANAGER:
-        android.app.FragmentManager fm = (android.app.FragmentManager) message.obj;
-        key = fm;
-        removed = pendingRequestManagerFragments.remove(fm);
-        break;
-      case ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:
-        FragmentManager supportFm = (FragmentManager) message.obj;
-        key = supportFm;
-        removed = pendingSupportRequestManagerFragments.remove(supportFm);
-        break;
-      default:
-        handled = false;
-        break;
-    }
-    if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
-      Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
-    }
-    return handled;
-  }
-
-  /**
-   * Used internally to create {@link RequestManager}s.
-   */
-  public interface RequestManagerFactory {
-    @NonNull
-    RequestManager build(
-        @NonNull Glide glide,
-        @NonNull Lifecycle lifecycle,
-        @NonNull RequestManagerTreeNode requestManagerTreeNode,
-        @NonNull Context context);
-  }
-
-  private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
-    @NonNull
-    @Override
-    public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
-        @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) {
-      return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
-    }
-  };
+	@VisibleForTesting
+	static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
+	private static final String TAG = "RMRetriever";
+
+	private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
+	private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
+
+	// Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
+	// allow us to iterate over and retrieve all active Fragments in a FragmentManager.
+	private static final String FRAGMENT_INDEX_KEY = "key";
+
+	/**
+	 * The top application level RequestManager.
+	 */
+	private volatile RequestManager applicationManager;
+
+	/**
+	 * Pending adds for RequestManagerFragments.
+	 */
+	@SuppressWarnings("deprecation")
+	@VisibleForTesting
+	final Map<android.app.FragmentManager, RequestManagerFragment> pendingRequestManagerFragments =
+			new HashMap<>();
+
+	/**
+	 * Pending adds for SupportRequestManagerFragments.
+	 */
+	@VisibleForTesting
+	final Map<FragmentManager, SupportRequestManagerFragment> pendingSupportRequestManagerFragments =
+			new HashMap<>();
+
+	/**
+	 * Main thread handler to handle cleaning up pending fragment maps.
+	 */
+	private final Handler handler;
+	private final RequestManagerFactory factory;
+
+	// Objects used to find Fragments and Activities containing views.
+	private final ArrayMap<View, Fragment> tempViewToSupportFragment = new ArrayMap<>();
+	private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
+	private final Bundle tempBundle = new Bundle();
+
+	public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
+		this.factory = factory != null ? factory : DEFAULT_FACTORY;
+		handler = new Handler(Looper.getMainLooper(), this /* Callback */);
+	}
+
+	@NonNull
+	private RequestManager getApplicationManager(@NonNull Context context) {
+		// Either an application context or we're on a background thread.
+		if (applicationManager == null) {
+			synchronized (this) {
+				if (applicationManager == null) {
+					// Normally pause/resume is taken care of by the fragment we add to the fragment or
+					// activity. However, in this case since the manager attached to the application will not
+					// receive lifecycle events, we must force the manager to start resumed using
+					// ApplicationLifecycle.
+
+					// TODO(b/27524013): Factor out this Glide.get() call.
+					Glide glide = Glide.get(context.getApplicationContext());
+					applicationManager =
+							factory.build(
+									glide,
+									new ApplicationLifecycle(),
+									new EmptyRequestManagerTreeNode(),
+									context.getApplicationContext());
+				}
+			}
+		}
+
+		return applicationManager;
+	}
+
+	@NonNull
+	public RequestManager get(@NonNull Context context) {
+		if (context == null) {
+			throw new IllegalArgumentException("You cannot start a load on a null Context");
+		} else if (Util.isOnMainThread() && !(context instanceof Application)) {
+			if (context instanceof FragmentActivity) {
+				return get((FragmentActivity) context);
+			} else if (context instanceof Activity) {
+				return get((Activity) context);
+			} else if (context instanceof ContextWrapper) {
+				return get(((ContextWrapper) context).getBaseContext());
+			}
+		}
+
+		return getApplicationManager(context);
+	}
+
+	@NonNull
+	public RequestManager get(@NonNull FragmentActivity activity) {
+		if (Util.isOnBackgroundThread()) {
+			return get(activity.getApplicationContext());
+		} else {
+			assertNotDestroyed(activity);
+			FragmentManager fm = activity.getSupportFragmentManager();
+			return supportFragmentGet(
+					activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
+		}
+	}
+
+	@NonNull
+	public RequestManager get(@NonNull Fragment fragment) {
+		Preconditions.checkNotNull(fragment.getActivity(),
+				"You cannot start a load on a fragment before it is attached or after it is destroyed");
+		if (Util.isOnBackgroundThread()) {
+			return get(fragment.getActivity().getApplicationContext());
+		} else {
+			FragmentManager fm = fragment.getChildFragmentManager();
+			return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	@NonNull
+	public RequestManager get(@NonNull Activity activity) {
+		if (Util.isOnBackgroundThread()) {
+			return get(activity.getApplicationContext());
+		} else {
+			assertNotDestroyed(activity);
+			// XXX: 没有界面的fragment来负责生命周期
+			android.app.FragmentManager fm = activity.getFragmentManager();
+			return fragmentGet(
+					activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	@NonNull
+	public RequestManager get(@NonNull View view) {
+		if (Util.isOnBackgroundThread()) {
+			return get(view.getContext().getApplicationContext());
+		}
+
+		Preconditions.checkNotNull(view);
+		Preconditions.checkNotNull(view.getContext(),
+				"Unable to obtain a request manager for a view without a Context");
+		Activity activity = findActivity(view.getContext());
+		// The view might be somewhere else, like a service.
+		if (activity == null) {
+			return get(view.getContext().getApplicationContext());
+		}
+
+		// Support Fragments.
+		// Although the user might have non-support Fragments attached to FragmentActivity, searching
+		// for non-support Fragments is so expensive pre O and that should be rare enough that we
+		// prefer to just fall back to the Activity directly.
+		if (activity instanceof FragmentActivity) {
+			Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
+			return fragment != null ? get(fragment) : get(activity);
+		}
+
+		// Standard Fragments.
+		android.app.Fragment fragment = findFragment(view, activity);
+		if (fragment == null) {
+			return get(activity);
+		}
+		return get(fragment);
+	}
+
+	private static void findAllSupportFragmentsWithViews(
+			@Nullable Collection<Fragment> topLevelFragments,
+			@NonNull Map<View, Fragment> result) {
+		if (topLevelFragments == null) {
+			return;
+		}
+		for (Fragment fragment : topLevelFragments) {
+			// getFragment()s in the support FragmentManager may contain null values, see #1991.
+			if (fragment == null || fragment.getView() == null) {
+				continue;
+			}
+			result.put(fragment.getView(), fragment);
+			findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);
+		}
+	}
+
+	@Nullable
+	private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {
+		tempViewToSupportFragment.clear();
+		findAllSupportFragmentsWithViews(
+				activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
+		Fragment result = null;
+		View activityRoot = activity.findViewById(android.R.id.content);
+		View current = target;
+		while (!current.equals(activityRoot)) {
+			result = tempViewToSupportFragment.get(current);
+			if (result != null) {
+				break;
+			}
+			if (current.getParent() instanceof View) {
+				current = (View) current.getParent();
+			} else {
+				break;
+			}
+		}
+
+		tempViewToSupportFragment.clear();
+		return result;
+	}
+
+	@SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+	@Deprecated
+	@Nullable
+	private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) {
+		tempViewToFragment.clear();
+		findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
+
+		android.app.Fragment result = null;
+
+		View activityRoot = activity.findViewById(android.R.id.content);
+		View current = target;
+		while (!current.equals(activityRoot)) {
+			result = tempViewToFragment.get(current);
+			if (result != null) {
+				break;
+			}
+			if (current.getParent() instanceof View) {
+				current = (View) current.getParent();
+			} else {
+				break;
+			}
+		}
+		tempViewToFragment.clear();
+		return result;
+	}
+
+	// TODO: Consider using an accessor class in the support library package to more directly retrieve
+	// non-support Fragments.
+	@SuppressWarnings("deprecation")
+	@Deprecated
+	@TargetApi(Build.VERSION_CODES.O)
+	private void findAllFragmentsWithViews(
+			@NonNull android.app.FragmentManager fragmentManager,
+			@NonNull ArrayMap<View, android.app.Fragment> result) {
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+			for (android.app.Fragment fragment : fragmentManager.getFragments()) {
+				if (fragment.getView() != null) {
+					result.put(fragment.getView(), fragment);
+					findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+				}
+			}
+		} else {
+			findAllFragmentsWithViewsPreO(fragmentManager, result);
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	@Deprecated
+	private void findAllFragmentsWithViewsPreO(
+			@NonNull android.app.FragmentManager fragmentManager,
+			@NonNull ArrayMap<View, android.app.Fragment> result) {
+		int index = 0;
+		while (true) {
+			tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
+			android.app.Fragment fragment = null;
+			try {
+				fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_INDEX_KEY);
+			} catch (Exception e) {
+				// This generates log spam from FragmentManager anyway.
+			}
+			if (fragment == null) {
+				break;
+			}
+			if (fragment.getView() != null) {
+				result.put(fragment.getView(), fragment);
+				if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) {
+					findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+				}
+			}
+		}
+	}
+
+	@Nullable
+	private Activity findActivity(@NonNull Context context) {
+		if (context instanceof Activity) {
+			return (Activity) context;
+		} else if (context instanceof ContextWrapper) {
+			return findActivity(((ContextWrapper) context).getBaseContext());
+		} else {
+			return null;
+		}
+	}
+
+	@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+	private static void assertNotDestroyed(@NonNull Activity activity) {
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {
+			throw new IllegalArgumentException("You cannot start a load for a destroyed activity");
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	@Deprecated
+	@NonNull
+	@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+	public RequestManager get(@NonNull android.app.Fragment fragment) {
+		if (fragment.getActivity() == null) {
+			throw new IllegalArgumentException(
+					"You cannot start a load on a fragment before it is attached");
+		}
+		if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
+			return get(fragment.getActivity().getApplicationContext());
+		} else {
+			android.app.FragmentManager fm = fragment.getChildFragmentManager();
+			return fragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	@Deprecated
+	@NonNull
+	RequestManagerFragment getRequestManagerFragment(Activity activity) {
+		return getRequestManagerFragment(
+				activity.getFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
+	}
+
+	@SuppressWarnings("deprecation")
+	@NonNull
+	private RequestManagerFragment getRequestManagerFragment(
+			@NonNull final android.app.FragmentManager fm,
+			@Nullable android.app.Fragment parentHint,
+			boolean isParentVisible) {
+		RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
+		if (current == null) {
+			current = pendingRequestManagerFragments.get(fm);
+			if (current == null) {
+				current = new RequestManagerFragment();
+				current.setParentFragmentHint(parentHint);
+				if (isParentVisible) {
+					current.getGlideLifecycle().onStart();
+				}
+				pendingRequestManagerFragments.put(fm, current);
+				fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
+				handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
+			}
+		}
+		return current;
+	}
+
+	/**
+	 * 通过getRequestManagerFragment创建一个没有UI界面的fragment，通过这个fragment获取RequestManager对象
+	 *
+	 * @param context
+	 * @param fm
+	 * @param parentHint
+	 * @param isParentVisible
+	 * @return
+	 */
+	@SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"})
+	@Deprecated
+	@NonNull
+	private RequestManager fragmentGet(@NonNull Context context,
+									   @NonNull android.app.FragmentManager fm,
+									   @Nullable android.app.Fragment parentHint,
+									   boolean isParentVisible) {
+		RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);
+		RequestManager requestManager = current.getRequestManager();
+		if (requestManager == null) {
+			// TODO(b/27524013): Factor out this Glide.get() call.
+			Glide glide = Glide.get(context);
+			// XXX: 通过这个fragment的Lifecycle去确定requestManager的生命周期
+//      当前fragment绑定RequestManager对象，glide是无法知道activity生命周期的，所以
+//      这里添加了一个没有UI界面的fragment来监听Activity的生命周期，这样设计很巧妙。
+			requestManager =
+					factory.build(
+							glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
+			current.setRequestManager(requestManager);
+		}
+		return requestManager;
+	}
+
+	@NonNull
+	SupportRequestManagerFragment getSupportRequestManagerFragment(FragmentActivity activity) {
+		return getSupportRequestManagerFragment(
+				activity.getSupportFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));
+	}
+
+	private static boolean isActivityVisible(Activity activity) {
+		// This is a poor heuristic, but it's about all we have. We'd rather err on the side of visible
+		// and start requests than on the side of invisible and ignore valid requests.
+		return !activity.isFinishing();
+	}
+
+	@NonNull
+	private SupportRequestManagerFragment getSupportRequestManagerFragment(
+			@NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {
+		SupportRequestManagerFragment current =
+				(SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
+		if (current == null) {
+			current = pendingSupportRequestManagerFragments.get(fm);
+			if (current == null) {
+				current = new SupportRequestManagerFragment();
+				current.setParentFragmentHint(parentHint);
+				if (isParentVisible) {
+					current.getGlideLifecycle().onStart();
+				}
+				pendingSupportRequestManagerFragments.put(fm, current);
+				fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
+				handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
+			}
+		}
+		return current;
+	}
+
+	@NonNull
+	private RequestManager supportFragmentGet(
+			@NonNull Context context,
+			@NonNull FragmentManager fm,
+			@Nullable Fragment parentHint,
+			boolean isParentVisible) {
+		SupportRequestManagerFragment current =
+				getSupportRequestManagerFragment(fm, parentHint, isParentVisible);
+		RequestManager requestManager = current.getRequestManager();
+		if (requestManager == null) {
+			// TODO(b/27524013): Factor out this Glide.get() call.
+			Glide glide = Glide.get(context);
+			requestManager =
+					factory.build(
+							glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
+			current.setRequestManager(requestManager);
+		}
+		return requestManager;
+	}
+
+	@Override
+	public boolean handleMessage(Message message) {
+		boolean handled = true;
+		Object removed = null;
+		Object key = null;
+		switch (message.what) {
+			case ID_REMOVE_FRAGMENT_MANAGER:
+				android.app.FragmentManager fm = (android.app.FragmentManager) message.obj;
+				key = fm;
+				removed = pendingRequestManagerFragments.remove(fm);
+				break;
+			case ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:
+				FragmentManager supportFm = (FragmentManager) message.obj;
+				key = supportFm;
+				removed = pendingSupportRequestManagerFragments.remove(supportFm);
+				break;
+			default:
+				handled = false;
+				break;
+		}
+		if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
+			Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
+		}
+		return handled;
+	}
+
+	/**
+	 * Used internally to create {@link RequestManager}s.
+	 */
+	public interface RequestManagerFactory {
+		@NonNull
+		RequestManager build(
+				@NonNull Glide glide,
+				@NonNull Lifecycle lifecycle,
+				@NonNull RequestManagerTreeNode requestManagerTreeNode,
+				@NonNull Context context);
+	}
+
+	private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
+		@NonNull
+		@Override
+		public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,
+									@NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) {
+			return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);
+		}
+	};
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 97567671b..4f8c2e6d8 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -41,6 +41,7 @@
   public void runRequest(@NonNull Request request) {
     requests.add(request);
     if (!isPaused) {
+      //如果是加载状态，就调用request.begin()方法
       request.begin();
     } else {
       request.clear();
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 03d3b34cc..59a75a3f2 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -9,6 +9,7 @@
 import android.support.annotation.Nullable;
 import android.support.v4.util.Pools;
 import android.util.Log;
+
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -25,6 +26,7 @@
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
 import com.bumptech.glide.util.pool.StateVerifier;
+
 import java.util.List;
 import java.util.concurrent.Executor;
 
@@ -35,634 +37,647 @@
  * @param <R> The type of the resource that will be transcoded from the loaded resource.
  */
 public final class SingleRequest<R> implements Request,
-    SizeReadyCallback,
-    ResourceCallback,
-    FactoryPools.Poolable {
-  /** Tag for logging internal events, not generally suitable for public use. */
-  private static final String TAG = "Request";
-  /** Tag for logging externally useful events (request completion, timing etc). */
-  private static final String GLIDE_TAG = "Glide";
-  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.threadSafe(150,
-      new FactoryPools.Factory<SingleRequest<?>>() {
-        @Override
-        public SingleRequest<?> create() {
-          return new SingleRequest<Object>();
-        }
-      });
-  private boolean isCallingCallbacks;
-
-  private static final boolean IS_VERBOSE_LOGGABLE =
-      Log.isLoggable(TAG, Log.VERBOSE);
-
-  private enum Status {
-    /**
-     * Created but not yet running.
-     */
-    PENDING,
-    /**
-     * In the process of fetching media.
-     */
-    RUNNING,
-    /**
-     * Waiting for a callback given to the Target to be called to determine target dimensions.
-     */
-    WAITING_FOR_SIZE,
-    /**
-     * Finished loading media successfully.
-     */
-    COMPLETE,
-    /**
-     * Failed to load media, may be restarted.
-     */
-    FAILED,
-    /**
-     * Cleared by the user with a placeholder set, may be restarted.
-     */
-    CLEARED,
-  }
-
-  @Nullable
-  private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
-  private final StateVerifier stateVerifier = StateVerifier.newInstance();
-
-  @Nullable
-  private RequestListener<R> targetListener;
-  private RequestCoordinator requestCoordinator;
-  private Context context;
-  private GlideContext glideContext;
-  @Nullable
-  private Object model;
-  private Class<R> transcodeClass;
-  private BaseRequestOptions<?> requestOptions;
-  private int overrideWidth;
-  private int overrideHeight;
-  private Priority priority;
-  private Target<R> target;
-  @Nullable private List<RequestListener<R>> requestListeners;
-  private Engine engine;
-  private TransitionFactory<? super R> animationFactory;
-  private Executor callbackExecutor;
-  private Resource<R> resource;
-  private Engine.LoadStatus loadStatus;
-  private long startTime;
-  @GuardedBy("this")
-  private Status status;
-  private Drawable errorDrawable;
-  private Drawable placeholderDrawable;
-  private Drawable fallbackDrawable;
-  private int width;
-  private int height;
-  @Nullable
-  private RuntimeException requestOrigin;
-
-  public static <R> SingleRequest<R> obtain(
-      Context context,
-      GlideContext glideContext,
-      Object model,
-      Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
-      int overrideWidth,
-      int overrideHeight,
-      Priority priority,
-      Target<R> target,
-      RequestListener<R> targetListener,
-      @Nullable List<RequestListener<R>> requestListeners,
-      RequestCoordinator requestCoordinator,
-      Engine engine,
-      TransitionFactory<? super R> animationFactory,
-      Executor callbackExecutor) {
-    @SuppressWarnings("unchecked") SingleRequest<R> request =
-        (SingleRequest<R>) POOL.acquire();
-    if (request == null) {
-      request = new SingleRequest<>();
-    }
-    request.init(
-        context,
-        glideContext,
-        model,
-        transcodeClass,
-        requestOptions,
-        overrideWidth,
-        overrideHeight,
-        priority,
-        target,
-        targetListener,
-        requestListeners,
-        requestCoordinator,
-        engine,
-        animationFactory,
-        callbackExecutor);
-    return request;
-  }
-
-  @SuppressWarnings("WeakerAccess")
-  @Synthetic
-  SingleRequest() {
-    // just create, instances are reused with recycle/init
-  }
-
-  private synchronized void init(
-      Context context,
-      GlideContext glideContext,
-      Object model,
-      Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
-      int overrideWidth,
-      int overrideHeight,
-      Priority priority,
-      Target<R> target,
-      RequestListener<R> targetListener,
-      @Nullable List<RequestListener<R>> requestListeners,
-      RequestCoordinator requestCoordinator,
-      Engine engine,
-      TransitionFactory<? super R> animationFactory,
-      Executor callbackExecutor) {
-    this.context = context;
-    this.glideContext = glideContext;
-    this.model = model;
-    this.transcodeClass = transcodeClass;
-    this.requestOptions = requestOptions;
-    this.overrideWidth = overrideWidth;
-    this.overrideHeight = overrideHeight;
-    this.priority = priority;
-    this.target = target;
-    this.targetListener = targetListener;
-    this.requestListeners = requestListeners;
-    this.requestCoordinator = requestCoordinator;
-    this.engine = engine;
-    this.animationFactory = animationFactory;
-    this.callbackExecutor = callbackExecutor;
-    status = Status.PENDING;
-
-    if (requestOrigin == null && glideContext.isLoggingRequestOriginsEnabled()) {
-      requestOrigin = new RuntimeException("Glide request origin trace");
-    }
-  }
-
-  @NonNull
-  @Override
-  public StateVerifier getVerifier() {
-    return stateVerifier;
-  }
-
-  @Override
-  public synchronized void recycle() {
-    assertNotCallingCallbacks();
-    context = null;
-    glideContext = null;
-    model = null;
-    transcodeClass = null;
-    requestOptions = null;
-    overrideWidth = -1;
-    overrideHeight = -1;
-    target = null;
-    requestListeners = null;
-    targetListener = null;
-    requestCoordinator = null;
-    animationFactory = null;
-    loadStatus = null;
-    errorDrawable = null;
-    placeholderDrawable = null;
-    fallbackDrawable = null;
-    width = -1;
-    height = -1;
-    requestOrigin = null;
-    POOL.release(this);
-  }
-
-  @Override
-  public synchronized void begin() {
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    startTime = LogTime.getLogTime();
-    if (model == null) {
-      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
-        width = overrideWidth;
-        height = overrideHeight;
-      }
-      // Only log at more verbose log levels if the user has set a fallback drawable, because
-      // fallback Drawables indicate the user expects null models occasionally.
-      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
-      onLoadFailed(new GlideException("Received null model"), logLevel);
-      return;
-    }
-
-    if (status == Status.RUNNING) {
-      throw new IllegalArgumentException("Cannot restart a running request");
-    }
-
-    // If we're restarted after we're complete (usually via something like a notifyDataSetChanged
-    // that starts an identical request into the same Target or View), we can simply use the
-    // resource and size we retrieved the last time around and skip obtaining a new size, starting a
-    // new load etc. This does mean that users who want to restart a load because they expect that
-    // the view size has changed will need to explicitly clear the View or Target before starting
-    // the new load.
-    if (status == Status.COMPLETE) {
-      onResourceReady(resource, DataSource.MEMORY_CACHE);
-      return;
-    }
-
-    // Restarts for requests that are neither complete nor running can be treated as new requests
-    // and can run again from the beginning.
-
-    status = Status.WAITING_FOR_SIZE;
-    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
-      onSizeReady(overrideWidth, overrideHeight);
-    } else {
-      target.getSize(this);
-    }
-
-    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
-        && canNotifyStatusChanged()) {
-      target.onLoadStarted(getPlaceholderDrawable());
-    }
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("finished run method in " + LogTime.getElapsedMillis(startTime));
-    }
-  }
-
-  /**
-   * Cancels the current load but does not release any resources held by the request and continues
-   * to display the loaded resource if the load completed before the call to cancel.
-   *
-   * <p> Cancelled requests can be restarted with a subsequent call to {@link #begin()}. </p>
-   *
-   * @see #clear()
-   */
-  private void cancel() {
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    target.removeCallback(this);
-    if (loadStatus != null) {
-      loadStatus.cancel();
-      loadStatus = null;
-    }
-  }
-
-  // Avoids difficult to understand errors like #2413.
-  private void assertNotCallingCallbacks() {
-    if (isCallingCallbacks) {
-      throw new IllegalStateException("You can't start or clear loads in RequestListener or"
-          + " Target callbacks. If you're trying to start a fallback request when a load fails, use"
-          + " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
-          + " clear() calls to the main thread using a Handler instead.");
-    }
-  }
-
-  /**
-   * Cancels the current load if it is in progress, clears any resources held onto by the request
-   * and replaces the loaded resource if the load completed with the placeholder.
-   *
-   * <p>Cleared requests can be restarted with a subsequent call to {@link #begin()}
-   *
-   * @see #cancel()
-   */
-  @Override
-  public synchronized void clear() {
-    assertNotCallingCallbacks();
-    stateVerifier.throwIfRecycled();
-    if (status == Status.CLEARED) {
-      return;
-    }
-    cancel();
-    // Resource must be released before canNotifyStatusChanged is called.
-    if (resource != null) {
-      releaseResource(resource);
-    }
-    if (canNotifyCleared()) {
-      target.onLoadCleared(getPlaceholderDrawable());
-    }
-
-    status = Status.CLEARED;
-  }
-
-  private void releaseResource(Resource<?> resource) {
-    engine.release(resource);
-    this.resource = null;
-  }
-
-  @Override
-  public synchronized boolean isRunning() {
-    return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
-  }
-
-  @Override
-  public synchronized boolean isComplete() {
-    return status == Status.COMPLETE;
-  }
-
-  @Override
-  public synchronized boolean isResourceSet() {
-    return isComplete();
-  }
-
-  @Override
-  public synchronized boolean isCleared() {
-    return status == Status.CLEARED;
-  }
-
-  @Override
-  public synchronized boolean isFailed() {
-    return status == Status.FAILED;
-  }
-
-  private Drawable getErrorDrawable() {
-    if (errorDrawable == null) {
-      errorDrawable = requestOptions.getErrorPlaceholder();
-      if (errorDrawable == null && requestOptions.getErrorId() > 0) {
-        errorDrawable = loadDrawable(requestOptions.getErrorId());
-      }
-    }
-    return errorDrawable;
-  }
-
-  private Drawable getPlaceholderDrawable() {
-     if (placeholderDrawable == null) {
-      placeholderDrawable = requestOptions.getPlaceholderDrawable();
-      if (placeholderDrawable == null && requestOptions.getPlaceholderId() > 0) {
-        placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());
-      }
-    }
-    return placeholderDrawable;
-  }
-
-  private Drawable getFallbackDrawable() {
-    if (fallbackDrawable == null) {
-      fallbackDrawable = requestOptions.getFallbackDrawable();
-      if (fallbackDrawable == null && requestOptions.getFallbackId() > 0) {
-        fallbackDrawable = loadDrawable(requestOptions.getFallbackId());
-      }
-    }
-    return fallbackDrawable;
-  }
-
-  private Drawable loadDrawable(@DrawableRes int resourceId) {
-    Theme theme = requestOptions.getTheme() != null
-        ? requestOptions.getTheme() : context.getTheme();
-    return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
-  }
-
-  private synchronized void setErrorPlaceholder() {
-    if (!canNotifyStatusChanged()) {
-      return;
-    }
-
-    Drawable error = null;
-    if (model == null) {
-      error = getFallbackDrawable();
-    }
-    // Either the model isn't null, or there was no fallback drawable set.
-    if (error == null) {
-      error = getErrorDrawable();
-    }
-    // The model isn't null, no fallback drawable was set or no error drawable was set.
-    if (error == null) {
-      error = getPlaceholderDrawable();
-    }
-    target.onLoadFailed(error);
-  }
-
-  /**
-   * A callback method that should never be invoked directly.
-   */
-  @Override
-  public synchronized void onSizeReady(int width, int height) {
-    stateVerifier.throwIfRecycled();
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
-    }
-    if (status != Status.WAITING_FOR_SIZE) {
-      return;
-    }
-    status = Status.RUNNING;
-
-    float sizeMultiplier = requestOptions.getSizeMultiplier();
-    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
-    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
-
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
-    }
-    loadStatus =
-        engine.load(
-            glideContext,
-            model,
-            requestOptions.getSignature(),
-            this.width,
-            this.height,
-            requestOptions.getResourceClass(),
-            transcodeClass,
-            priority,
-            requestOptions.getDiskCacheStrategy(),
-            requestOptions.getTransformations(),
-            requestOptions.isTransformationRequired(),
-            requestOptions.isScaleOnlyOrNoTransform(),
-            requestOptions.getOptions(),
-            requestOptions.isMemoryCacheable(),
-            requestOptions.getUseUnlimitedSourceGeneratorsPool(),
-            requestOptions.getUseAnimationPool(),
-            requestOptions.getOnlyRetrieveFromCache(),
-            this,
-            callbackExecutor);
-
-    // This is a hack that's only useful for testing right now where loads complete synchronously
-    // even though under any executor running on any thread but the main thread, the load would
-    // have completed asynchronously.
-    if (status != Status.RUNNING) {
-      loadStatus = null;
-    }
-    if (IS_VERBOSE_LOGGABLE) {
-      logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
-    }
-  }
-
-  private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
-    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
-  }
-
-  private boolean canSetResource() {
-    return requestCoordinator == null || requestCoordinator.canSetImage(this);
-  }
-
-  private boolean canNotifyCleared() {
-    return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
-  }
-
-  private boolean canNotifyStatusChanged() {
-    return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
-  }
-
-  private boolean isFirstReadyResource() {
-    return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
-  }
-
-  private void notifyLoadSuccess() {
-    if (requestCoordinator != null) {
-      requestCoordinator.onRequestSuccess(this);
-    }
-  }
-
-  private void notifyLoadFailed() {
-    if (requestCoordinator != null) {
-      requestCoordinator.onRequestFailed(this);
-    }
-  }
-
-  /** A callback method that should never be invoked directly. */
-  @SuppressWarnings("unchecked")
-  @Override
-  public synchronized void onResourceReady(Resource<?> resource, DataSource dataSource) {
-    stateVerifier.throwIfRecycled();
-    loadStatus = null;
-    if (resource == null) {
-      GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
-          + "object of " + transcodeClass + " inside, but instead got null.");
-      onLoadFailed(exception);
-      return;
-    }
-
-    Object received = resource.get();
-    if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
-      releaseResource(resource);
-      GlideException exception = new GlideException("Expected to receive an object of "
-          + transcodeClass + " but instead" + " got "
-          + (received != null ? received.getClass() : "") + "{" + received + "} inside" + " "
-          + "Resource{" + resource + "}."
-          + (received != null ? "" : " " + "To indicate failure return a null Resource "
-          + "object, rather than a Resource object containing null data."));
-      onLoadFailed(exception);
-      return;
-    }
-
-    if (!canSetResource()) {
-      releaseResource(resource);
-      // We can't put the status to complete before asking canSetResource().
-      status = Status.COMPLETE;
-      return;
-    }
-
-    onResourceReady((Resource<R>) resource, (R) received, dataSource);
-  }
-
-  /**
-   * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
-   *
-   * @param resource original {@link Resource}, never <code>null</code>
-   * @param result object returned by {@link Resource#get()}, checked for type and never <code>null
-   *     </code>
-   */
-  private synchronized void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
-    // We must call isFirstReadyResource before setting status.
-    boolean isFirstResource = isFirstReadyResource();
-    status = Status.COMPLETE;
-    this.resource = resource;
-
-    if (glideContext.getLogLevel() <= Log.DEBUG) {
-      Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
-          + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
-          + LogTime.getElapsedMillis(startTime) + " ms");
-    }
-
-    isCallingCallbacks = true;
-    try {
-      boolean anyListenerHandledUpdatingTarget = false;
-      if (requestListeners != null) {
-        for (RequestListener<R> listener : requestListeners) {
-          anyListenerHandledUpdatingTarget |=
-              listener.onResourceReady(result, model, target, dataSource, isFirstResource);
-        }
-      }
-      anyListenerHandledUpdatingTarget |=
-          targetListener != null
-              && targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);
-
-      if (!anyListenerHandledUpdatingTarget) {
-        Transition<? super R> animation =
-            animationFactory.build(dataSource, isFirstResource);
-        target.onResourceReady(result, animation);
-      }
-    } finally {
-      isCallingCallbacks = false;
-    }
-
-    notifyLoadSuccess();
-  }
-
-  /** A callback method that should never be invoked directly. */
-  @Override
-  public synchronized void onLoadFailed(GlideException e) {
-    onLoadFailed(e, Log.WARN);
-  }
-
-  private synchronized void onLoadFailed(GlideException e, int maxLogLevel) {
-    stateVerifier.throwIfRecycled();
-    e.setOrigin(requestOrigin);
-    int logLevel = glideContext.getLogLevel();
-    if (logLevel <= maxLogLevel) {
-      Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
-      if (logLevel <= Log.INFO) {
-        e.logRootCauses(GLIDE_TAG);
-      }
-    }
-
-    loadStatus = null;
-    status = Status.FAILED;
-
-    isCallingCallbacks = true;
-    try {
-      //TODO: what if this is a thumbnail request?
-      boolean anyListenerHandledUpdatingTarget = false;
-      if (requestListeners != null) {
-        for (RequestListener<R> listener : requestListeners) {
-          anyListenerHandledUpdatingTarget |=
-              listener.onLoadFailed(e, model, target, isFirstReadyResource());
-        }
-      }
-      anyListenerHandledUpdatingTarget |=
-          targetListener != null
-              && targetListener.onLoadFailed(e, model, target, isFirstReadyResource());
-
-      if (!anyListenerHandledUpdatingTarget) {
-        setErrorPlaceholder();
-      }
-    } finally {
-      isCallingCallbacks = false;
-    }
-
-    notifyLoadFailed();
-  }
-
-  @SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
-  @Override
-  public synchronized boolean isEquivalentTo(Request o) {
-    if (o instanceof SingleRequest) {
-      SingleRequest<?> that = (SingleRequest<?>) o;
-      synchronized (that) {
-        return overrideWidth == that.overrideWidth
-            && overrideHeight == that.overrideHeight
-            && Util.bothModelsNullEquivalentOrEquals(model, that.model)
-            && transcodeClass.equals(that.transcodeClass)
-            && requestOptions.equals(that.requestOptions)
-            && priority == that.priority
-            // We do not want to require that RequestListeners implement equals/hashcode, so we
-            // don't compare them using equals(). We can however, at least assert that the same
-            // amount of request listeners are present in both requests.
-            && listenerCountEquals(that);
-      }
-    }
-    return false;
-  }
-
-  @SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
-  private synchronized boolean listenerCountEquals(SingleRequest<?> other) {
-    synchronized (other) {
-      int firstListenerCount = requestListeners == null ? 0 : requestListeners.size();
-      int secondListenerCount = other.requestListeners == null ? 0 : other.requestListeners.size();
-      return firstListenerCount == secondListenerCount;
-    }
-  }
-
-  private void logV(String message) {
-    Log.v(TAG, message + " this: " + tag);
-  }
+		SizeReadyCallback,
+		ResourceCallback,
+		FactoryPools.Poolable {
+	/**
+	 * Tag for logging internal events, not generally suitable for public use.
+	 */
+	private static final String TAG = "Request";
+	/**
+	 * Tag for logging externally useful events (request completion, timing etc).
+	 */
+	private static final String GLIDE_TAG = "Glide";
+	private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.threadSafe(150,
+			new FactoryPools.Factory<SingleRequest<?>>() {
+				@Override
+				public SingleRequest<?> create() {
+					return new SingleRequest<Object>();
+				}
+			});
+	private boolean isCallingCallbacks;
+
+	private static final boolean IS_VERBOSE_LOGGABLE =
+			Log.isLoggable(TAG, Log.VERBOSE);
+
+	private enum Status {
+		/**
+		 * Created but not yet running.
+		 */
+		PENDING,
+		/**
+		 * In the process of fetching media.
+		 */
+		RUNNING,
+		/**
+		 * Waiting for a callback given to the Target to be called to determine target dimensions.
+		 */
+		WAITING_FOR_SIZE,
+		/**
+		 * Finished loading media successfully.
+		 */
+		COMPLETE,
+		/**
+		 * Failed to load media, may be restarted.
+		 */
+		FAILED,
+		/**
+		 * Cleared by the user with a placeholder set, may be restarted.
+		 */
+		CLEARED,
+	}
+
+	@Nullable
+	private final String tag = IS_VERBOSE_LOGGABLE ? String.valueOf(super.hashCode()) : null;
+	private final StateVerifier stateVerifier = StateVerifier.newInstance();
+
+	@Nullable
+	private RequestListener<R> targetListener;
+	private RequestCoordinator requestCoordinator;
+	private Context context;
+	private GlideContext glideContext;
+	@Nullable
+	private Object model;
+	private Class<R> transcodeClass;
+	private BaseRequestOptions<?> requestOptions;
+	private int overrideWidth;
+	private int overrideHeight;
+	private Priority priority;
+	private Target<R> target;
+	@Nullable
+	private List<RequestListener<R>> requestListeners;
+	private Engine engine;
+	private TransitionFactory<? super R> animationFactory;
+	private Executor callbackExecutor;
+	private Resource<R> resource;
+	private Engine.LoadStatus loadStatus;
+	private long startTime;
+	@GuardedBy("this")
+	private Status status;
+	private Drawable errorDrawable;
+	private Drawable placeholderDrawable;
+	private Drawable fallbackDrawable;
+	private int width;
+	private int height;
+	@Nullable
+	private RuntimeException requestOrigin;
+
+	public static <R> SingleRequest<R> obtain(
+			Context context,
+			GlideContext glideContext,
+			Object model,
+			Class<R> transcodeClass,
+			BaseRequestOptions<?> requestOptions,
+			int overrideWidth,
+			int overrideHeight,
+			Priority priority,
+			Target<R> target,
+			RequestListener<R> targetListener,
+			@Nullable List<RequestListener<R>> requestListeners,
+			RequestCoordinator requestCoordinator,
+			Engine engine,
+			TransitionFactory<? super R> animationFactory,
+			Executor callbackExecutor) {
+		@SuppressWarnings("unchecked") SingleRequest<R> request =
+				(SingleRequest<R>) POOL.acquire();
+		if (request == null) {
+			request = new SingleRequest<>();
+		}
+		request.init(
+				context,
+				glideContext,
+				model,
+				transcodeClass,
+				requestOptions,
+				overrideWidth,
+				overrideHeight,
+				priority,
+				target,
+				targetListener,
+				requestListeners,
+				requestCoordinator,
+				engine,
+				animationFactory,
+				callbackExecutor);
+		return request;
+	}
+
+	@SuppressWarnings("WeakerAccess")
+	@Synthetic
+	SingleRequest() {
+		// just create, instances are reused with recycle/init
+	}
+
+	private synchronized void init(
+			Context context,
+			GlideContext glideContext,
+			Object model,
+			Class<R> transcodeClass,
+			BaseRequestOptions<?> requestOptions,
+			int overrideWidth,
+			int overrideHeight,
+			Priority priority,
+			Target<R> target,
+			RequestListener<R> targetListener,
+			@Nullable List<RequestListener<R>> requestListeners,
+			RequestCoordinator requestCoordinator,
+			Engine engine,
+			TransitionFactory<? super R> animationFactory,
+			Executor callbackExecutor) {
+		this.context = context;
+		this.glideContext = glideContext;
+		this.model = model;
+		this.transcodeClass = transcodeClass;
+		this.requestOptions = requestOptions;
+		this.overrideWidth = overrideWidth;
+		this.overrideHeight = overrideHeight;
+		this.priority = priority;
+		this.target = target;
+		this.targetListener = targetListener;
+		this.requestListeners = requestListeners;
+		this.requestCoordinator = requestCoordinator;
+		this.engine = engine;
+		this.animationFactory = animationFactory;
+		this.callbackExecutor = callbackExecutor;
+		status = Status.PENDING;
+
+		if (requestOrigin == null && glideContext.isLoggingRequestOriginsEnabled()) {
+			requestOrigin = new RuntimeException("Glide request origin trace");
+		}
+	}
+
+	@NonNull
+	@Override
+	public StateVerifier getVerifier() {
+		return stateVerifier;
+	}
+
+	@Override
+	public synchronized void recycle() {
+		assertNotCallingCallbacks();
+		context = null;
+		glideContext = null;
+		model = null;
+		transcodeClass = null;
+		requestOptions = null;
+		overrideWidth = -1;
+		overrideHeight = -1;
+		target = null;
+		requestListeners = null;
+		targetListener = null;
+		requestCoordinator = null;
+		animationFactory = null;
+		loadStatus = null;
+		errorDrawable = null;
+		placeholderDrawable = null;
+		fallbackDrawable = null;
+		width = -1;
+		height = -1;
+		requestOrigin = null;
+		POOL.release(this);
+	}
+
+	@Override
+	public synchronized void begin() {
+		assertNotCallingCallbacks();
+		stateVerifier.throwIfRecycled();
+		startTime = LogTime.getLogTime();
+		if (model == null) {
+			if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+				width = overrideWidth;
+				height = overrideHeight;
+			}
+			// Only log at more verbose log levels if the user has set a fallback drawable, because
+			// fallback Drawables indicate the user expects null models occasionally.
+			int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
+			onLoadFailed(new GlideException("Received null model"), logLevel);
+			return;
+		}
+
+		if (status == Status.RUNNING) {
+			throw new IllegalArgumentException("Cannot restart a running request");
+		}
+
+		// If we're restarted after we're complete (usually via something like a notifyDataSetChanged
+		// that starts an identical request into the same Target or View), we can simply use the
+		// resource and size we retrieved the last time around and skip obtaining a new size, starting a
+		// new load etc. This does mean that users who want to restart a load because they expect that
+		// the view size has changed will need to explicitly clear the View or Target before starting
+		// the new load.
+		if (status == Status.COMPLETE) {
+			onResourceReady(resource, DataSource.MEMORY_CACHE);
+			return;
+		}
+
+		// Restarts for requests that are neither complete nor running can be treated as new requests
+		// and can run again from the beginning.
+
+		status = Status.WAITING_FOR_SIZE;
+		//如果glide调用了override方法，则调用onSizeReady方法 ,
+		//如果尺寸可用
+		if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+			onSizeReady(overrideWidth, overrideHeight);
+		} else {
+			target.getSize(this);
+		}
+		//如果图片没有加载完成，并且图片不是加载失败状态，就给这个target设置默认占位图。
+		if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
+				&& canNotifyStatusChanged()) {
+			target.onLoadStarted(getPlaceholderDrawable());
+		}
+		if (IS_VERBOSE_LOGGABLE) {
+			logV("finished run method in " + LogTime.getElapsedMillis(startTime));
+		}
+	}
+
+	/**
+	 * Cancels the current load but does not release any resources held by the request and continues
+	 * to display the loaded resource if the load completed before the call to cancel.
+	 *
+	 * <p> Cancelled requests can be restarted with a subsequent call to {@link #begin()}. </p>
+	 *
+	 * @see #clear()
+	 */
+	private void cancel() {
+		assertNotCallingCallbacks();
+		stateVerifier.throwIfRecycled();
+		target.removeCallback(this);
+		if (loadStatus != null) {
+			loadStatus.cancel();
+			loadStatus = null;
+		}
+	}
+
+	// Avoids difficult to understand errors like #2413.
+	private void assertNotCallingCallbacks() {
+		if (isCallingCallbacks) {
+			throw new IllegalStateException("You can't start or clear loads in RequestListener or"
+					+ " Target callbacks. If you're trying to start a fallback request when a load fails, use"
+					+ " RequestBuilder#error(RequestBuilder). Otherwise consider posting your into() or"
+					+ " clear() calls to the main thread using a Handler instead.");
+		}
+	}
+
+	/**
+	 * Cancels the current load if it is in progress, clears any resources held onto by the request
+	 * and replaces the loaded resource if the load completed with the placeholder.
+	 *
+	 * <p>Cleared requests can be restarted with a subsequent call to {@link #begin()}
+	 *
+	 * @see #cancel()
+	 */
+	@Override
+	public synchronized void clear() {
+		assertNotCallingCallbacks();
+		stateVerifier.throwIfRecycled();
+		if (status == Status.CLEARED) {
+			return;
+		}
+		cancel();
+		// Resource must be released before canNotifyStatusChanged is called.
+		if (resource != null) {
+			releaseResource(resource);
+		}
+		if (canNotifyCleared()) {
+			target.onLoadCleared(getPlaceholderDrawable());
+		}
+
+		status = Status.CLEARED;
+	}
+
+	private void releaseResource(Resource<?> resource) {
+		engine.release(resource);
+		this.resource = null;
+	}
+
+	@Override
+	public synchronized boolean isRunning() {
+		return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
+	}
+
+	@Override
+	public synchronized boolean isComplete() {
+		return status == Status.COMPLETE;
+	}
+
+	@Override
+	public synchronized boolean isResourceSet() {
+		return isComplete();
+	}
+
+	@Override
+	public synchronized boolean isCleared() {
+		return status == Status.CLEARED;
+	}
+
+	@Override
+	public synchronized boolean isFailed() {
+		return status == Status.FAILED;
+	}
+
+	private Drawable getErrorDrawable() {
+		if (errorDrawable == null) {
+			errorDrawable = requestOptions.getErrorPlaceholder();
+			if (errorDrawable == null && requestOptions.getErrorId() > 0) {
+				errorDrawable = loadDrawable(requestOptions.getErrorId());
+			}
+		}
+		return errorDrawable;
+	}
+
+	private Drawable getPlaceholderDrawable() {
+		if (placeholderDrawable == null) {
+			placeholderDrawable = requestOptions.getPlaceholderDrawable();
+			if (placeholderDrawable == null && requestOptions.getPlaceholderId() > 0) {
+				placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());
+			}
+		}
+		return placeholderDrawable;
+	}
+
+	private Drawable getFallbackDrawable() {
+		if (fallbackDrawable == null) {
+			fallbackDrawable = requestOptions.getFallbackDrawable();
+			if (fallbackDrawable == null && requestOptions.getFallbackId() > 0) {
+				fallbackDrawable = loadDrawable(requestOptions.getFallbackId());
+			}
+		}
+		return fallbackDrawable;
+	}
+
+	private Drawable loadDrawable(@DrawableRes int resourceId) {
+		Theme theme = requestOptions.getTheme() != null
+				? requestOptions.getTheme() : context.getTheme();
+		return DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);
+	}
+
+	private synchronized void setErrorPlaceholder() {
+		if (!canNotifyStatusChanged()) {
+			return;
+		}
+
+		Drawable error = null;
+		if (model == null) {
+			error = getFallbackDrawable();
+		}
+		// Either the model isn't null, or there was no fallback drawable set.
+		if (error == null) {
+			error = getErrorDrawable();
+		}
+		// The model isn't null, no fallback drawable was set or no error drawable was set.
+		if (error == null) {
+			error = getPlaceholderDrawable();
+		}
+		target.onLoadFailed(error);
+	}
+
+	/**
+	 * A callback method that should never be invoked directly.
+	 */
+	@Override
+	public synchronized void onSizeReady(int width, int height) {
+		// XXX: 总要入口函数
+		stateVerifier.throwIfRecycled();
+		if (IS_VERBOSE_LOGGABLE) {
+			logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
+		}
+		if (status != Status.WAITING_FOR_SIZE) {
+			return;
+		}
+		status = Status.RUNNING;
+
+		float sizeMultiplier = requestOptions.getSizeMultiplier();
+		this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
+		this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
+
+		if (IS_VERBOSE_LOGGABLE) {
+			logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
+		}
+		//Engine类： 负责启动负载并管理活动和缓存的资源类
+		loadStatus =
+				engine.load(
+						glideContext,
+						model,
+						requestOptions.getSignature(),
+						this.width,
+						this.height,
+						requestOptions.getResourceClass(),
+						transcodeClass,
+						priority,
+						requestOptions.getDiskCacheStrategy(),
+						requestOptions.getTransformations(),
+						requestOptions.isTransformationRequired(),
+						requestOptions.isScaleOnlyOrNoTransform(),
+						requestOptions.getOptions(),
+						requestOptions.isMemoryCacheable(),
+						requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+						requestOptions.getUseAnimationPool(),
+						requestOptions.getOnlyRetrieveFromCache(),
+						this,
+						callbackExecutor);
+
+		// This is a hack that's only useful for testing right now where loads complete synchronously
+		// even though under any executor running on any thread but the main thread, the load would
+		// have completed asynchronously.
+		if (status != Status.RUNNING) {
+			loadStatus = null;
+		}
+		if (IS_VERBOSE_LOGGABLE) {
+			logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
+		}
+	}
+
+	private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
+		return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
+	}
+
+	private boolean canSetResource() {
+		return requestCoordinator == null || requestCoordinator.canSetImage(this);
+	}
+
+	private boolean canNotifyCleared() {
+		return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
+	}
+
+	private boolean canNotifyStatusChanged() {
+		return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
+	}
+
+	private boolean isFirstReadyResource() {
+		return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
+	}
+
+	private void notifyLoadSuccess() {
+		if (requestCoordinator != null) {
+			requestCoordinator.onRequestSuccess(this);
+		}
+	}
+
+	private void notifyLoadFailed() {
+		if (requestCoordinator != null) {
+			requestCoordinator.onRequestFailed(this);
+		}
+	}
+
+	/**
+	 * A callback method that should never be invoked directly.
+	 */
+	@SuppressWarnings("unchecked")
+	@Override
+	public synchronized void onResourceReady(Resource<?> resource, DataSource dataSource) {
+		stateVerifier.throwIfRecycled();
+		loadStatus = null;
+		if (resource == null) {
+			GlideException exception = new GlideException("Expected to receive a Resource<R> with an "
+					+ "object of " + transcodeClass + " inside, but instead got null.");
+			onLoadFailed(exception);
+			return;
+		}
+
+		Object received = resource.get();
+		if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
+			releaseResource(resource);
+			GlideException exception = new GlideException("Expected to receive an object of "
+					+ transcodeClass + " but instead" + " got "
+					+ (received != null ? received.getClass() : "") + "{" + received + "} inside" + " "
+					+ "Resource{" + resource + "}."
+					+ (received != null ? "" : " " + "To indicate failure return a null Resource "
+					+ "object, rather than a Resource object containing null data."));
+			onLoadFailed(exception);
+			return;
+		}
+
+		if (!canSetResource()) {
+			releaseResource(resource);
+			// We can't put the status to complete before asking canSetResource().
+			status = Status.COMPLETE;
+			return;
+		}
+
+		onResourceReady((Resource<R>) resource, (R) received, dataSource);
+	}
+
+	/**
+	 * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.
+	 *
+	 * @param resource original {@link Resource}, never <code>null</code>
+	 * @param result   object returned by {@link Resource#get()}, checked for type and never <code>null
+	 *                 </code>
+	 */
+	private synchronized void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
+		// We must call isFirstReadyResource before setting status.
+		boolean isFirstResource = isFirstReadyResource();
+		status = Status.COMPLETE;
+		this.resource = resource;
+
+		if (glideContext.getLogLevel() <= Log.DEBUG) {
+			Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
+					+ dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
+					+ LogTime.getElapsedMillis(startTime) + " ms");
+		}
+
+		isCallingCallbacks = true;
+		try {
+			boolean anyListenerHandledUpdatingTarget = false;
+			if (requestListeners != null) {
+				for (RequestListener<R> listener : requestListeners) {
+					anyListenerHandledUpdatingTarget |=
+							listener.onResourceReady(result, model, target, dataSource, isFirstResource);
+				}
+			}
+			anyListenerHandledUpdatingTarget |=
+					targetListener != null
+							&& targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);
+
+			if (!anyListenerHandledUpdatingTarget) {
+				Transition<? super R> animation =
+						animationFactory.build(dataSource, isFirstResource);
+				target.onResourceReady(result, animation);
+			}
+		} finally {
+			isCallingCallbacks = false;
+		}
+
+		notifyLoadSuccess();
+	}
+
+	/**
+	 * A callback method that should never be invoked directly.
+	 */
+	@Override
+	public synchronized void onLoadFailed(GlideException e) {
+		onLoadFailed(e, Log.WARN);
+	}
+
+	private synchronized void onLoadFailed(GlideException e, int maxLogLevel) {
+		stateVerifier.throwIfRecycled();
+		e.setOrigin(requestOrigin);
+		int logLevel = glideContext.getLogLevel();
+		if (logLevel <= maxLogLevel) {
+			Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
+			if (logLevel <= Log.INFO) {
+				e.logRootCauses(GLIDE_TAG);
+			}
+		}
+
+		loadStatus = null;
+		status = Status.FAILED;
+
+		isCallingCallbacks = true;
+		try {
+			//TODO: what if this is a thumbnail request?
+			boolean anyListenerHandledUpdatingTarget = false;
+			if (requestListeners != null) {
+				for (RequestListener<R> listener : requestListeners) {
+					anyListenerHandledUpdatingTarget |=
+							listener.onLoadFailed(e, model, target, isFirstReadyResource());
+				}
+			}
+			anyListenerHandledUpdatingTarget |=
+					targetListener != null
+							&& targetListener.onLoadFailed(e, model, target, isFirstReadyResource());
+
+			if (!anyListenerHandledUpdatingTarget) {
+				setErrorPlaceholder();
+			}
+		} finally {
+			isCallingCallbacks = false;
+		}
+
+		notifyLoadFailed();
+	}
+
+	@SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
+	@Override
+	public synchronized boolean isEquivalentTo(Request o) {
+		if (o instanceof SingleRequest) {
+			SingleRequest<?> that = (SingleRequest<?>) o;
+			synchronized (that) {
+				return overrideWidth == that.overrideWidth
+						&& overrideHeight == that.overrideHeight
+						&& Util.bothModelsNullEquivalentOrEquals(model, that.model)
+						&& transcodeClass.equals(that.transcodeClass)
+						&& requestOptions.equals(that.requestOptions)
+						&& priority == that.priority
+						// We do not want to require that RequestListeners implement equals/hashcode, so we
+						// don't compare them using equals(). We can however, at least assert that the same
+						// amount of request listeners are present in both requests.
+						&& listenerCountEquals(that);
+			}
+		}
+		return false;
+	}
+
+	@SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
+	private synchronized boolean listenerCountEquals(SingleRequest<?> other) {
+		synchronized (other) {
+			int firstListenerCount = requestListeners == null ? 0 : requestListeners.size();
+			int secondListenerCount = other.requestListeners == null ? 0 : other.requestListeners.size();
+			return firstListenerCount == secondListenerCount;
+		}
+	}
+
+	private void logV(String message) {
+		Log.v(TAG, message + " this: " + tag);
+	}
 }
