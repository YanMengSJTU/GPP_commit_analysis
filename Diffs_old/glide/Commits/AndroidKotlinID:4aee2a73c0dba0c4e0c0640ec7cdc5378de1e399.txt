diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
index baa0f2ba2..842566324 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -2,9 +2,13 @@
 
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.annotation.GlideType;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -14,6 +18,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic.Kind;
 
 /**
  * Validates that classes annotated with {@link com.bumptech.glide.annotation.GlideExtension}
@@ -24,6 +29,8 @@
  * for an Application.
  */
 final class GlideExtensionValidator {
+  private static final String FULLY_QUALIFIED_NON_NULL_CLASS_NAME =
+      "android.support.annotation.NonNull";
 
   private final ProcessingEnvironment processingEnvironment;
   private final ProcessorUtil processorUtil;
@@ -73,6 +80,7 @@ private void validateGlideOption(ExecutableElement executableElement) {
   }
 
   private void validateNewGlideOption(ExecutableElement executableElement) {
+    validateNewGlideOptionAnnotations(executableElement);
     validateGlideOptionParameters(executableElement);
     TypeMirror returnType = executableElement.getReturnType();
     if (!isRequestOptions(returnType)) {
@@ -84,6 +92,10 @@ private void validateNewGlideOption(ExecutableElement executableElement) {
     validateGlideOptionOverride(executableElement);
   }
 
+  private void validateNewGlideOptionAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
   private void validateDeprecatedGlideOption(ExecutableElement executableElement) {
     validateStaticVoid(executableElement, GlideOption.class);
     validateGlideOptionParameters(executableElement);
@@ -171,6 +183,7 @@ private void validateGlideType(ExecutableElement executableElement) {
 
   private void validateNewGlideType(ExecutableElement executableElement) {
     TypeMirror returnType = executableElement.getReturnType();
+    validateNewGlideTypeAnnotations(executableElement);
     if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {
       String expectedClassName = getGlideTypeValue(executableElement);
       throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<"
@@ -227,6 +240,30 @@ private static void validateGlideTypeParameters(ExecutableElement executableElem
     }
   }
 
+  private void validateNewGlideTypeAnnotations(ExecutableElement executableElement) {
+    validateAnnotatedNonNull(executableElement);
+  }
+
+  private void validateAnnotatedNonNull(ExecutableElement executableElement) {
+    Set<String> annotationNames =
+        FluentIterable.from(executableElement.getAnnotationMirrors())
+            .transform(new Function<AnnotationMirror, String>() {
+              @Override
+              public String apply(AnnotationMirror input) {
+                return input.getAnnotationType().asElement().toString();
+              }
+            })
+            .toSet();
+    if (!annotationNames.contains(FULLY_QUALIFIED_NON_NULL_CLASS_NAME)) {
+      processingEnvironment.getMessager().printMessage(
+          Kind.WARNING,
+          executableElement.getEnclosingElement() + "#" + executableElement.getSimpleName()
+              + " is missing the " + FULLY_QUALIFIED_NON_NULL_CLASS_NAME + " annotation,"
+              + " please add it to ensure that your extension methods are always returning non-null"
+              + " values");
+    }
+  }
+
   private static void validateStatic(ExecutableElement executableElement, Class<?> clazz) {
     if (!executableElement.getModifiers().contains(Modifier.STATIC)) {
       throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must be static");
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
index 2f1a20b50..ce342fb7f 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -60,6 +60,8 @@
       "com.bumptech.glide.manager.RequestManagerTreeNode";
   private static final ClassName CHECK_RESULT_CLASS_NAME =
       ClassName.get("android.support.annotation", "CheckResult");
+  private static final ClassName NON_NULL_CLASS_NAME =
+      ClassName.get("android.support.annotation", "NonNull");
   private static final ClassName CONTEXT_CLASS_NAME =
       ClassName.get("android.content", "Context");
 
@@ -270,6 +272,8 @@ private MethodSpec generateAdditionalRequestManagerMethodLegacy(
         .addModifiers(Modifier.PUBLIC)
         .returns(parameterizedTypeName)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build())
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
         .addStatement(
             "$T requestBuilder = this.as($T.class)", parameterizedTypeName, returnTypeClassName)
         .addStatement("$T.$N(requestBuilder)",
@@ -290,6 +294,8 @@ private MethodSpec generateAdditionalRequestManagerMethodNew(
         .addModifiers(Modifier.PUBLIC)
         .returns(parameterizedTypeName)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build())
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
         .addStatement(
             "return ($T) $T.$N(this.as($T.class))",
             parameterizedTypeName,
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
index 6fcb003f0..678602230 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -78,6 +78,8 @@
       REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
   private static final ClassName CHECK_RESULT_CLASS_NAME =
       ClassName.get("android.support.annotation", "CheckResult");
+  private static final ClassName NON_NULL_CLASS_NAME =
+      ClassName.get("android.support.annotation", "NonNull");
 
   private final ProcessingEnvironment processingEnvironment;
   private final ClassName requestOptionsName;
@@ -298,6 +300,8 @@ public String apply(VariableElement input) {
     code = new StringBuilder(code.substring(0, code.length() - 2));
     code.append(")");
     builder.addStatement(code.toString(), args.toArray(new Object[0]));
+
+    builder.addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build());
     builder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
 
     List<MethodAndStaticVar> result = new ArrayList<>();
@@ -370,6 +374,7 @@ public String apply(VariableElement input) {
     builder.addStatement(code.toString(), args.toArray(new Object[0]));
 
     builder.addStatement("return this");
+    builder.addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build());
     builder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
 
     List<MethodAndStaticVar> result = new ArrayList<>();
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
index 37610ab1a..9f408b7e2 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
@@ -244,12 +244,14 @@ public void compilation_withRequestOptionsReturnValue_succeeds() {
             JavaFileObjects.forSourceLines(
                 "Extension",
                 "package com.bumptech.glide.test;",
+                "import android.support.annotation.NonNull;",
                 "import com.bumptech.glide.annotation.GlideExtension;",
                 "import com.bumptech.glide.annotation.GlideOption;",
                 "import com.bumptech.glide.request.RequestOptions;",
                 "@GlideExtension",
                 "public class Extension {",
                 "  private Extension() {}",
+                "  @NonNull",
                 "  @GlideOption",
                 "  public static RequestOptions doSomething(RequestOptions options) {",
                 "    return options;",
@@ -268,16 +270,44 @@ public void compilation_withNonRequestOptionsReturnValue_fails() {
             JavaFileObjects.forSourceLines(
                 "Extension",
                 "package com.bumptech.glide.test;",
+                "import android.support.annotation.NonNull;",
                 "import com.bumptech.glide.annotation.GlideExtension;",
                 "import com.bumptech.glide.annotation.GlideOption;",
                 "import com.bumptech.glide.request.RequestOptions;",
                 "@GlideExtension",
                 "public class Extension {",
                 "  private Extension() {}",
+                "  @NonNull",
                 "  @GlideOption",
                 "  public static Object doSomething(RequestOptions options) {",
                 "    return options;",
                 "  }",
                 "}"));
   }
+
+  @Test
+  public void compilation_withMissingNonNullAnnotation_warns() {
+    Compilation compilation = javac()
+        .withProcessors(new GlideAnnotationProcessor())
+        .compile(
+            emptyAppModule(),
+            JavaFileObjects.forSourceLines(
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideOption;",
+                "import com.bumptech.glide.request.RequestOptions;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideOption",
+                "  public static RequestOptions doSomething(RequestOptions options) {",
+                "    return options;",
+                "  }",
+                "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#doSomething");
+  }
 }
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
index e73b67288..f3672822d 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
@@ -170,7 +170,7 @@ public void compilation_withAnnotatedStaticMethod_overridingExistingType_fails()
 
   @Test
   public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_succeeds() {
-     Compilation compilation =
+    Compilation compilation =
         javac()
             .withProcessors(new GlideAnnotationProcessor())
             .compile(
@@ -178,12 +178,14 @@ public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_succee
                 JavaFileObjects.forSourceLines(
                     "Extension",
                     "package com.bumptech.glide.test;",
+                    "import android.support.annotation.NonNull;",
                     "import com.bumptech.glide.RequestBuilder;",
                     "import com.bumptech.glide.annotation.GlideExtension;",
                     "import com.bumptech.glide.annotation.GlideType;",
                     "@GlideExtension",
                     "public class Extension {",
                     "  private Extension() {}",
+                    "  @NonNull",
                     "  @GlideType(Number.class)",
                     "  public static RequestBuilder<Number> asNumber(",
                     "      RequestBuilder<Number> builder) {",
@@ -233,21 +235,21 @@ public void compilation_withAnnotatedStaticMethod_returningBuilderWithIncorrectT
         .compile(
             emptyAppModule(),
             JavaFileObjects.forSourceLines(
-                 "Extension",
-                 "package com.bumptech.glide.test;",
-                 "import com.bumptech.glide.RequestBuilder;",
-                 "import com.bumptech.glide.annotation.GlideExtension;",
-                 "import com.bumptech.glide.annotation.GlideType;",
-                 "@GlideExtension",
-                 "public class Extension {",
-                 "  private Extension() {}",
-                 "  @GlideType(Number.class)",
-                 "  public static RequestBuilder<Object> asNumber(",
-                 "      RequestBuilder<Object> builder) {",
-                 "    return builder;",
-                 "  }",
-                 "}"));
-   }
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static RequestBuilder<Object> asNumber(",
+                "      RequestBuilder<Object> builder) {",
+                "    return builder;",
+                "  }",
+                "}"));
+  }
 
   @Test
   public void compilation_withAnnotatedStaticMethod_returningBuilder_andMultipleParams_fails() {
@@ -261,20 +263,20 @@ public void compilation_withAnnotatedStaticMethod_returningBuilder_andMultiplePa
         .compile(
             emptyAppModule(),
             JavaFileObjects.forSourceLines(
-                 "Extension",
-                 "package com.bumptech.glide.test;",
-                 "import com.bumptech.glide.RequestBuilder;",
-                 "import com.bumptech.glide.annotation.GlideExtension;",
-                 "import com.bumptech.glide.annotation.GlideType;",
-                 "@GlideExtension",
-                 "public class Extension {",
-                 "  private Extension() {}",
-                 "  @GlideType(Number.class)",
-                 "  public static RequestBuilder<Number> asNumber(",
-                 "      RequestBuilder<Number> builder, Object arg1) {",
-                 "    return builder;",
-                 "  }",
-                 "}"));
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static RequestBuilder<Number> asNumber(",
+                "      RequestBuilder<Number> builder, Object arg1) {",
+                "    return builder;",
+                "  }",
+                "}"));
   }
 
   @Test
@@ -287,19 +289,47 @@ public void compilation_withAnnotatedStaticMethod_returningBuilder_nonBuilderPar
         .compile(
             emptyAppModule(),
             JavaFileObjects.forSourceLines(
-                 "Extension",
-                 "package com.bumptech.glide.test;",
-                 "import com.bumptech.glide.RequestBuilder;",
-                 "import com.bumptech.glide.annotation.GlideExtension;",
-                 "import com.bumptech.glide.annotation.GlideType;",
-                 "@GlideExtension",
-                 "public class Extension {",
-                 "  private Extension() {}",
-                 "  @GlideType(Number.class)",
-                 "  public static RequestBuilder<Number> asNumber(",
-                 "      Object arg) {",
-                 "    return null;",
-                 "  }",
-                 "}"));
-   }
+                "Extension",
+                "package com.bumptech.glide.test;",
+                "import com.bumptech.glide.RequestBuilder;",
+                "import com.bumptech.glide.annotation.GlideExtension;",
+                "import com.bumptech.glide.annotation.GlideType;",
+                "@GlideExtension",
+                "public class Extension {",
+                "  private Extension() {}",
+                "  @GlideType(Number.class)",
+                "  public static RequestBuilder<Number> asNumber(",
+                "      Object arg) {",
+                "    return null;",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_missingNonNull_warns() {
+    Compilation compilation =
+        javac()
+            .withProcessors(new GlideAnnotationProcessor())
+            .compile(
+                emptyAppModule(),
+                JavaFileObjects.forSourceLines(
+                    "Extension",
+                    "package com.bumptech.glide.test;",
+                    "import com.bumptech.glide.RequestBuilder;",
+                    "import com.bumptech.glide.annotation.GlideExtension;",
+                    "import com.bumptech.glide.annotation.GlideType;",
+                    "@GlideExtension",
+                    "public class Extension {",
+                    "  private Extension() {}",
+                    "  @GlideType(Number.class)",
+                    "  public static RequestBuilder<Number> asNumber(",
+                    "      RequestBuilder<Number> builder) {",
+                    "    return builder;",
+                    "  }",
+                    "}"));
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningCount(1);
+    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
+    assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#asNumber");
+  }
 }
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
index e1b1e04f5..05cf8447b 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/Extension.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.test;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.request.RequestOptions;
@@ -11,6 +12,7 @@ private Extension() {
     // Utility class.
   }
 
+  @NonNull
   @GlideOption(memoizeStaticMethod = true)
   public static RequestOptions test(RequestOptions requestOptions) {
     return requestOptions.centerCrop();
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
index b721e7f9d..a516bf99b 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -596,6 +596,7 @@ public final GlideOptions autoClone() {
   /**
    * @see Extension#test(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions test() {
     return (GlideOptions) Extension.test(this);
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
index 5533857e5..11f06c689 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -651,6 +651,7 @@
   /**
    * @see GlideOptions#test()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> test() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
index 862baa126..b11fe757f 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/Extension.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.test;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.request.RequestOptions;
@@ -11,6 +12,7 @@ private Extension() {
     // Utility class.
   }
 
+  @NonNull
   @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
   public static RequestOptions centerCrop(RequestOptions requestOptions) {
     return requestOptions.centerCrop();
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
index 9ece405f4..c18eb00da 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -589,6 +589,7 @@ public final GlideOptions autoClone() {
    * @see RequestOptions#centerCrop()
    */
   @Override
+  @NonNull
   @CheckResult
   public GlideOptions centerCrop() {
     return (GlideOptions) Extension.centerCrop(super.centerCrop());
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
index 3e559893c..aaa4680a8 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -637,6 +637,7 @@
   /**
    * @see GlideOptions#centerCrop()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> centerCrop() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
index 714c287e5..a0be8a2c3 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/Extension.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.test;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.request.RequestOptions;
@@ -11,6 +12,7 @@ private Extension() {
     // Utility class.
   }
 
+  @NonNull
   @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
   public static RequestOptions override(RequestOptions requestOptions, int width, int height) {
     return requestOptions
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
index ef9428d20..34d14a62b 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java
@@ -580,6 +580,7 @@ public final GlideOptions autoClone() {
    * @see RequestOptions#override(int, int)
    */
   @Override
+  @NonNull
   @CheckResult
   public GlideOptions override(int width, int height) {
     return (GlideOptions) Extension.override(super.override(width, height), width, height);
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
index cac11bc08..c6014fb45 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java
@@ -637,6 +637,7 @@
   /**
    * @see GlideOptions#override(int, int)
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> override(int width, int height) {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
index ec436d765..78d91590f 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/Extension.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.test;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.request.RequestOptions;
@@ -11,6 +12,7 @@ private Extension() {
     // Utility class.
   }
 
+  @NonNull
   @GlideOption(override = GlideOption.OVERRIDE_REPLACE)
   public static RequestOptions centerCrop(RequestOptions requestOptions) {
     return requestOptions.centerCrop();
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
index 1ecca0318..8c4ead00e 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -587,6 +587,7 @@ public final GlideOptions autoClone() {
   /**
    * @see Extension#centerCrop(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions centerCrop() {
     return (GlideOptions) Extension.centerCrop(this);
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
index 3e559893c..aaa4680a8 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -637,6 +637,7 @@
   /**
    * @see GlideOptions#centerCrop()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> centerCrop() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
index 904c55a1c..69db3bc0f 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/Extension.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.test;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.request.RequestOptions;
@@ -11,6 +12,7 @@ private Extension() {
     // Utility class.
   }
 
+  @NonNull
   @GlideOption(skipStaticMethod = true)
   public static RequestOptions test(RequestOptions requestOptions) {
     return requestOptions.centerCrop();
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
index a82df71e5..a15e5a13e 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -594,6 +594,7 @@ public final GlideOptions autoClone() {
   /**
    * @see Extension#test(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions test() {
     return (GlideOptions) Extension.test(this);
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
index 5533857e5..11f06c689 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -651,6 +651,7 @@
   /**
    * @see GlideOptions#test()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> test() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
index aa124c142..9e05dde64 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/Extension.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.test;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.request.RequestOptions;
@@ -11,6 +12,7 @@ private Extension() {
     // Utility class.
   }
 
+  @NonNull
   @GlideOption(staticMethodName = "testSomething")
   public static RequestOptions test(RequestOptions requestOptions) {
     return requestOptions.centerCrop();
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
index 7a1516c66..5fb88e94f 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -594,6 +594,7 @@ public final GlideOptions autoClone() {
   /**
    * @see Extension#test(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions test() {
     return (GlideOptions) Extension.test(this);
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
index 5533857e5..11f06c689 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -651,6 +651,7 @@
   /**
    * @see GlideOptions#test()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> test() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
index 8f6de0051..9884bcefb 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/ExtensionWithOption.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.test;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.request.RequestOptions;
@@ -11,6 +12,7 @@ private ExtensionWithOption() {
     // Utility class.
   }
 
+  @NonNull
   @GlideOption
   public static RequestOptions squareThumb(RequestOptions requestOptions) {
     return requestOptions.centerCrop();
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
index 0faea6521..a801496a4 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideOptions.java
@@ -594,6 +594,7 @@ public final GlideOptions autoClone() {
   /**
    * @see ExtensionWithOption#squareThumb(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions squareThumb() {
     return (GlideOptions) ExtensionWithOption.squareThumb(this);
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
index f461c8ad2..35c73d0d7 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithOptionTest/GlideRequest.java
@@ -651,6 +651,7 @@
   /**
    * @see GlideOptions#squareThumb()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> squareThumb() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
index 6761e6d56..1d58e6ff0 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.test;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideType;
@@ -11,6 +12,7 @@ private ExtensionWithType() {
     // Utility class.
   }
 
+  @NonNull
   @GlideType(Number.class)
   public static RequestBuilder<Number> asNumber(RequestBuilder<Number> builder) {
     return builder;
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
index ac9063d4c..758f3b7a7 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
@@ -46,6 +46,8 @@ public GlideRequests(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode tr
   /**
    * @see ExtensionWithType#asNumber(RequestBuilder)
    */
+  @NonNull
+  @CheckResult
   public GlideRequest<Number> asNumber() {
     return (GlideRequest<Number>) ExtensionWithType.asNumber(this.as(Number.class));
   }
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
index e63a8c636..e217989a0 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java
@@ -596,6 +596,7 @@ public final GlideOptions autoClone() {
   /**
    * @see Extension#test(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions test() {
     if (isAutoCloneEnabled()) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
index 5533857e5..11f06c689 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java
@@ -651,6 +651,7 @@
   /**
    * @see GlideOptions#test()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> test() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
index 0922d8cf3..7e59eb54f 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideOptions.java
@@ -589,6 +589,7 @@ public final GlideOptions autoClone() {
    * @see RequestOptions#centerCrop()
    */
   @Override
+  @NonNull
   @CheckResult
   public GlideOptions centerCrop() {
     if (isAutoCloneEnabled()) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
index 3e559893c..aaa4680a8 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideExtend/GlideRequest.java
@@ -637,6 +637,7 @@
   /**
    * @see GlideOptions#centerCrop()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> centerCrop() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
index 2be07d97e..83af4bee9 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideOptions.java
@@ -587,6 +587,7 @@ public final GlideOptions autoClone() {
   /**
    * @see Extension#centerCrop(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions centerCrop() {
     if (isAutoCloneEnabled()) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
index 3e559893c..aaa4680a8 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/OverrideReplace/GlideRequest.java
@@ -637,6 +637,7 @@
   /**
    * @see GlideOptions#centerCrop()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> centerCrop() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
index f360cefae..b63941369 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java
@@ -594,6 +594,7 @@ public final GlideOptions autoClone() {
   /**
    * @see Extension#test(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions test() {
     if (isAutoCloneEnabled()) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
index 5533857e5..11f06c689 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/SkipStaticMethod/GlideRequest.java
@@ -651,6 +651,7 @@
   /**
    * @see GlideOptions#test()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> test() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
index fc9293a65..79b4838ec 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideOptions.java
@@ -594,6 +594,7 @@ public final GlideOptions autoClone() {
   /**
    * @see Extension#test(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions test() {
     if (isAutoCloneEnabled()) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
index 5533857e5..11f06c689 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionOptionsTest/StaticMethodName/GlideRequest.java
@@ -651,6 +651,7 @@
   /**
    * @see GlideOptions#test()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> test() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java
index b3c4406a4..7caa63811 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideOptions.java
@@ -594,6 +594,7 @@ public final GlideOptions autoClone() {
   /**
    * @see ExtensionWithOption#squareThumb(RequestOptions)
    */
+  @NonNull
   @CheckResult
   public GlideOptions squareThumb() {
     if (isAutoCloneEnabled()) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java
index f461c8ad2..35c73d0d7 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithOptionTest/GlideRequest.java
@@ -651,6 +651,7 @@
   /**
    * @see GlideOptions#squareThumb()
    */
+  @NonNull
   @CheckResult
   public GlideRequest<TranscodeType> squareThumb() {
     if (getMutableOptions() instanceof GlideOptions) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
index 2bde90dd4..15582a2c0 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
@@ -46,6 +46,8 @@ public GlideRequests(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode tr
   /**
    * @see ExtensionWithType#asInteger(RequestBuilder)
    */
+  @NonNull
+  @CheckResult
   public GlideRequest<Number> asInteger() {
     GlideRequest<Number> requestBuilder = this.as(Number.class);
     ExtensionWithType.asInteger(requestBuilder);
diff --git a/build.gradle b/build.gradle
index ac4c7b560..cd7f96d79 100644
--- a/build.gradle
+++ b/build.gradle
@@ -110,7 +110,8 @@ subprojects { project ->
     task violations(type: ViolationsTask) {
         minSeverity 'INFO'
         detailLevel 'VERBOSE'
-        maxViolations 0
+        maxViolations = 0
+        diffMaxViolations = 0
 
         // Formats are listed here: https://github.com/tomasbjerre/violations-lib
         def dir = projectDir.absolutePath;
diff --git a/gradle.properties b/gradle.properties
index 54f32e840..0a2a2ece5 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -32,11 +32,11 @@ JSR_305_VERSION=3.0.2
 AUTO_SERVICE_VERSION=1.0-rc3
 JAVAPOET_VERSION=1.9.0
 
-PMD_VERSION=5.8.1
+PMD_VERSION=6.0.0
 FINDBUGS_VERSION=3.0.0
 ERROR_PRONE_VERSION=2.1.4-SNAPSHOT
 ERROR_PRONE_PLUGIN_VERSION=0.0.13
-VIOLATIONS_PLUGIN_VERSION=1.3
+VIOLATIONS_PLUGIN_VERSION=1.8
 
 COMPILE_SDK_VERSION=27
 TARGET_SDK_VERSION=27
diff --git a/library/build.gradle b/library/build.gradle
index 8672d9ddb..4fa288a7f 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -22,7 +22,7 @@ dependencies {
     testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
 
     if (project.plugins.hasPlugin('net.ltgt.errorprone')) {
-       errorprone "com.google.errorprone:error_prone_core:${ERROR_PRONE_VERSION}"
+        errorprone "com.google.errorprone:error_prone_core:${ERROR_PRONE_VERSION}"
     }
 }
 
@@ -74,13 +74,9 @@ afterEvaluate {
 
         classes = fileTree("${project.buildDir}/intermediates/classes/debug/")
         source android.sourceSets.main.java.srcDirs
-        classpath = project.configurations.compile
-        classpath += files(android.bootClasspath)
+        classpath = files()
         doFirst {
-            it.classpath +=
-                    files(project.android.libraryVariants.collect {
-                        it.javaCompile.classpath.files
-                    })
+            classpath += classPathForQuality()
         }
         effort = 'max'
         excludeFilter = file("findbugs-exclude.xml")
@@ -111,6 +107,15 @@ afterEvaluate {
         ruleSets = []
         ruleSetFiles = files('pmd-ruleset.xml')
         source android.sourceSets.main.java.srcDirs
+        classpath = files()
+        classpath += files("${project.buildDir}/intermediates/classes/debug/")
+        doFirst {
+            classpath += classPathForQuality()
+        }
+
+        //TODO enable this once new Gradle containing this flag is out
+        //see https://github.com/gradle/gradle/pull/3125#issuecomment-352442432
+        //incrementalAnalysis = true
 
         // Failures are caught and printed by the violations plugin.
         ignoreFailures = true
@@ -124,4 +129,12 @@ afterEvaluate {
     check.dependsOn('pmd')
 }
 
+def classPathForQuality() {
+    return files(
+            android.bootClasspath,
+            project.configurations.compile,
+            project.android.libraryVariants.collect { it.javaCompile.classpath }
+    )
+}
+
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/library/pmd-ruleset.xml b/library/pmd-ruleset.xml
index da8c961e3..8297a5c09 100644
--- a/library/pmd-ruleset.xml
+++ b/library/pmd-ruleset.xml
@@ -5,64 +5,166 @@
 
     <description>Check for flaws in Glide's codebase.</description>
 
-    <rule ref="rulesets/java/basic.xml">
+    <rule ref="category/java/errorprone.xml">
         <exclude name="AvoidBranchingStatementAsLastInLoop"/>
+        <!-- Not using beans. -->
+        <exclude name="BeanMembersShouldSerialize" />
+        <!-- wat -->
+        <exclude name="AvoidFieldNameMatchingTypeName" />
+        <!-- This is identifying trivial cases that are clearly correct. -->
+        <exclude name="DataflowAnomalyAnalysis" />
+        <!-- Used regularly for object pooling. -->
+        <exclude name="NullAssignment" />
+        <!-- This can make the code easier to read and avoid duplicated logic in some cases. -->
+        <exclude name="AssignmentInOperand" />
+        <!-- I don't think this is confusing. -->
+        <exclude name="AvoidFieldNameMatchingMethodName" />
+        <!-- There are enough cases where this makes sense (typically related to logic around the number of items in a collection) that a blanket ban doesn't seem like a good idea. -->
+        <exclude name="AvoidLiteralsInIfCondition" />
+        <!-- It's clear that this is bad, but we have a number of cases where it makes sense and a blanket ban is irritating. -->
+        <exclude name="AvoidCatchingThrowable" />
     </rule>
-    <rule ref="rulesets/java/braces.xml"/>
-    <rule ref="rulesets/java/strings.xml"/>
-    <rule ref="rulesets/java/strings.xml/AvoidDuplicateLiterals">
-        <properties>
-            <property name="skipAnnotations" value="true" />
-        </properties>
+    <rule ref="category/java/errorprone.xml/AvoidDuplicateLiterals">
+      <properties>
+        <property name="skipAnnotations" value="true" />
+      </properties>
+    </rule>
+    <rule ref="category/java/codestyle.xml">
+      <!-- Abstract classes don't need to have Abstract in the name -->
+      <exclude name="AbstractNaming" />
+      <!-- Who cares? -->
+      <exclude name="AtLeastOneConstructor" />
+      <!-- Don't need to annotate package private methods. -->
+      <exclude name="DefaultPackage" />
+      <exclude name="CommentDefaultAccessModifier" />
+      <!-- Optionally implemented default empty methods are fine. -->
+      <exclude name="EmptyMethodInAbstractClassShouldBeAbstract" />
+      <!-- Why make generics less clear by using shorter names? -->
+      <exclude name="GenericsNaming" />
+      <!-- No need to enforce final if it's not necessary. -->
+      <exclude name="MethodArgumentCouldBeFinal" />
+      <exclude name="LocalVariableCouldBeFinal" />
+      <!-- This isn't always the easiest way to read a method. -->
+      <exclude name="OnlyOneReturn" />
+      <!-- Obfuscated code is best code? -->
+      <exclude name="LongVariable" />
+      <!-- This is not always true. -->
+      <exclude name="ShortClassName" />
+      <!-- A good idea but we have tons of violations. FIXME. -->
+      <exclude name="ShortMethodName" />
+      <exclude name="ShortVariable" />
+      <!-- We don't use in and out to mean modified or not modified by the method, it's useful to match framework methods. -->
+      <exclude name="AvoidPrefixingMethodParameters" />
+      <!-- No idea what this is supposed to accomplish. -->
+      <exclude name="AvoidFinalLocalVariable" />
+      <!-- These are often useful for clarity and explicitly suggested by Google's code style. -->
+      <exclude name="UselessParentheses" />
+      <!-- Theoretically this might be reasonable but the number of imports probably varies from class to class and this doesn't seem worth the overhead to maintain. -->
+      <exclude name="TooManyStaticImports" />
+      <!-- Lots of existing violations, not clear that the overhead is worthwhile though there are some cases where we definitely need to call super. FIXME. -->
+      <exclude name="CallSuperInConstructor" />
+      <!-- This is a reasonable idea, but in practice often the != null case is the expected case and it makes sense for it to come first. -->
+      <exclude name="ConfusingTernary" />
+    </rule>
+    <rule ref="category/java/performance.xml" >
+      <!-- Android may not behave the same as java VMs, using short can be clearer when working with binary data. -->
+      <exclude name="AvoidUsingShortType" />
+      <!-- The suggsted alternatives are not available until Glide's minsdk level is 26+ -->
+      <exclude name="AvoidFileStream" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml" >
+      <!-- Catches any method, test or not, that has the name "tearDown". -->
+      <exclude name="JUnit4TestShouldUseAfterAnnotation" />
+      <!-- This is a good idea, but in practice it's often somewhat clearer than defining a temporary variable and we do it all over the place. -->
+      <exclude name="AvoidReassigningParameters" />
+      <!-- This ignores imports used by javadocs and is worse than the existing checkstyle check. -->
+      <exclude name="UnusedImports" />
+    </rule>
+    <rule ref="category/java/bestpractices.xml/OneDeclarationPerLine">
+      <properties>
+        <property name="strictMode" value="true" />
+        <!-- Allow `for (int i = 0, size = list.size(); i < size; i++) {`
+             Somewhat clearer to set size along with the index. -->
+        <property name="violationSuppressXPath"
+                  value="self::LocalVariableDeclaration
+                           [parent::ForInit]
+                           [Type/PrimitiveType[@Image = 'int']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='i']
+                             and VariableDeclarator/VariableDeclaratorId[@Image='size']
+                           ]
+                        " />
+      </properties>
+    </rule>
+    <rule ref="category/java/bestpractices.xml/AccessorMethodGeneration"
+      message="Avoid autogenerated methods to access private fields and methods of inner / outer classes.
+                       Use @Synthetic to flag members made more visible than necessary to prevent accessors.">
+      <properties>
+        <!-- Ignore references to `private static final * * = <literal>`
+             Suppress via XPath: current node (access that generates the accessor) is .
+             Check if there exists a FieldDeclaration (private static final)
+             which has a VariableInitializer with a Literal
+             and the name (@Image) of the declaration is the same as the accessed member.
+             TODO calculated constants are false positive https://github.com/pmd/pmd/issues/808
+        -->
+        <property name="violationSuppressXPath" value="
+                .[@Image =
+                    //FieldDeclaration[@Private = 'true' and @Static='true' and @Final='true']
+                    /VariableDeclarator[
+                        VariableInitializer/Expression/PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Literal
+                    ]/VariableDeclaratorId/@Image
+                 ]" />
+      </properties>
     </rule>
-    <rule ref="rulesets/java/unusedcode.xml"/>
 
-    <rule ref="rulesets/java/design.xml">
-        <exclude name="ConfusingTernary"/>
-        <exclude name="EmptyMethodInAbstractClassShouldBeAbstract"/>
-        <exclude name="AvoidSynchronizedAtMethodLevel"/>
+    <rule ref="category/java/design.xml">
+        <exclude name="GodClass" />
+        <!-- No idea how you reasonably define this. -->
+        <exclude name="ExcessiveImports" />
+        <exclude name="CouplingBetweenObjects" />
+        <exclude name="TooManyMethods" />
+        <exclude name="LawOfDemeter" />
+        <exclude name="NcssCount" />
+        <exclude name="ExcessiveParameterList" />
+        <exclude name="TooManyFields" />
+        <!-- We don't define any packages to use with this rule. -->
+        <exclude name="LoosePackageCoupling" />
+        <!-- Throwing other types of exceptions doesn't seem to add much to clarify. -->
+        <exclude name="AvoidThrowingRawExceptionTypes" />
+        <exclude name="AvoidThrowingNullPointerException" />
+        <!-- TODO: explore these further. -->
+        <exclude name="CyclomaticComplexity" />
+        <exclude name="NPathComplexity" />
+        <exclude name="ExcessiveMethodLength" />
+        <exclude name="ExcessiveClassLength" />
+        <exclude name="ExcessivePublicCount" />
+        <!-- This is redundant, also caught with AvoidCatchingNPEs. -->
+        <exclude name="AvoidCatchingGenericException" />
+    </rule>
 
+    <rule ref="category/java/multithreading.xml">
+        <exclude name="AvoidSynchronizedAtMethodLevel"/>
         <!-- This check breaks on double checked locking which is safe in Java 6/7 -->
         <exclude name="NonThreadSafeSingleton"/>
-
-        <!-- TODO: Fix these -->
-        <exclude name="AvoidReassigningParameters"/>
-        <exclude name="GodClass"/>
+        <!-- Used frequently in the singleton pattern. -->
+        <exclude name="AvoidUsingVolatile" />
+        <!-- No reason to do this by default. -->
+        <exclude name="UseConcurrentHashMap" />
+        <exclude name="DoNotUseThreads" />
     </rule>
 
-    <rule ref="rulesets/java/design.xml/AccessorMethodGeneration"
-          message="Avoid autogenerated methods to access private fields and methods of inner / outer classes.
-                   Use @Synthetic to flag members made more visible than necessary to prevent accessors.">
-        <properties>
-            <!-- Ignore references to `private static final * * = <literal>`
-                 Suppress via XPath: current node (access that generates the accessor) is .
-                 Check if there exists a FieldDeclaration (private static final)
-                 which has a VariableInitializer with a Literal
-                 and the name (@Image) of the declaration is the same as the accessed member.
-                 TODO calculated constants are false positive https://github.com/pmd/pmd/issues/808
-            -->
-            <property name="violationSuppressXPath" value="
-            .[@Image =
-                //FieldDeclaration[@Private = 'true' and @Static='true' and @Final='true']
-                /VariableDeclarator[
-                    VariableInitializer/Expression/PrimaryExpression[not(PrimarySuffix)]/PrimaryPrefix/Literal
-                ]/VariableDeclaratorId/@Image
-             ]" />
-        </properties>
-    </rule>
-
-    <rule ref="rulesets/java/empty.xml/EmptyCatchBlock" message="Commented blocks are ok">
+    <rule ref="category/java/errorprone.xml/EmptyCatchBlock" message="Commented blocks are ok">
         <properties>
             <property name="allowCommentedBlocks" value="true"/>
         </properties>
     </rule>
 
-    <!-- Configures check to avoid violation when @Synthetic annotation is present. -->
-    <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor">
-        <properties>
-            <property name="violationSuppressXPath"
-                      value="../Annotation/MarkerAnnotation/Name[@Image='Synthetic']" />
-        </properties>
+
+  <!-- Configures check to avoid violation when @Synthetic annotation is present. -->
+    <rule ref="category/java/documentation.xml/UncommentedEmptyConstructor">
+      <properties>
+        <property name="violationSuppressXPath"
+          value="../Annotation/MarkerAnnotation/Name[@Image='Synthetic']" />
+      </properties>
     </rule>
 
 </ruleset>
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 5d2535aa0..1677b1ff2 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -577,6 +577,7 @@ GlideContext getGlideContext() {
    * {@link com.bumptech.glide.load.engine.prefill.PreFillType.Builder Builders} representing
    * individual sizes and configurations of {@link android.graphics.Bitmap}s to be pre-filled.
    */
+  @SuppressWarnings("unused") // Public API
   public void preFillBitmapPool(@NonNull PreFillType.Builder... bitmapAttributeBuilders) {
     bitmapPreFiller.preFill(bitmapAttributeBuilders);
   }
@@ -644,6 +645,7 @@ public RequestManagerRetriever getRequestManagerRetriever() {
    *
    * @return the previous MemoryCategory used by Glide.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   public MemoryCategory setMemoryCategory(@NonNull MemoryCategory memoryCategory) {
     // Engine asserts this anyway when removing resources, fail faster and consistently
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index b30952d12..a6f5835f8 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -224,6 +224,8 @@ private void cancelAll() {
   private static final class PreloadTargetQueue {
     private final Queue<PreloadTarget> queue;
 
+    // The loop is short and the only point is to create the objects.
+    @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
     PreloadTargetQueue(int size) {
       queue = Util.createQueue(size);
 
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index fff7cd135..cce4a8692 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -511,8 +511,11 @@ public Registry register(@NonNull ImageHeaderParser parser) {
             decoderRegistry.getDecoders(dataClass, registeredResourceClass);
         ResourceTranscoder<TResource, Transcode> transcoder =
             transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);
-        decodePaths.add(new DecodePath<>(dataClass, registeredResourceClass,
-            registeredTranscodeClass, decoders, transcoder, throwableListPool));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        DecodePath<Data, TResource, Transcode> path =
+            new DecodePath<>(dataClass, registeredResourceClass, registeredTranscodeClass,
+                decoders, transcoder, throwableListPool);
+        decodePaths.add(path);
       }
     }
     return decodePaths;
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index ec4d145cd..44ecdfe91 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -546,7 +546,11 @@ protected RequestOptions getMutableOptions() {
    * arguments, the current model is not copied copied so changes to the model will affect both
    * builders. </p>
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      "unchecked",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @CheckResult
   @Override
   public RequestBuilder<TranscodeType> clone() {
diff --git a/library/src/main/java/com/bumptech/glide/TransitionOptions.java b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
index 99eda46dd..ce2cfe469 100644
--- a/library/src/main/java/com/bumptech/glide/TransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java
@@ -71,9 +71,16 @@ public final CHILD transition(
     return self();
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      // cast to CHILD is safe given the generic argument represents the object's runtime class
+      "unchecked",
+      // CHILD is the correct class name.
+      "PMD.CloneMethodReturnTypeMustMatchClassName",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @Override
-  protected final CHILD clone() {
+  public final CHILD clone() {
     try {
       return (CHILD) super.clone();
     } catch (CloneNotSupportedException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index 18e710188..aaac6cd68 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -18,7 +18,7 @@
   @SafeVarargs
   @SuppressWarnings("varargs")
   public MultiTransformation(Transformation<T>... transformations) {
-    if (transformations.length < 1) {
+    if (transformations.length == 0) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index d150608b4..e8f914b6e 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -27,6 +27,10 @@
   @VisibleForTesting
   static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
       new DefaultHttpUrlConnectionFactory();
+  /**
+   * Returned when a connection error prevented us from receiving an http error.
+   */
+  private static final int INVALID_STATUS_CODE = -1;
 
   private final GlideUrl glideUrl;
   private final int timeout;
@@ -51,23 +55,19 @@ public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
   public void loadData(@NonNull Priority priority,
       @NonNull DataCallback<? super InputStream> callback) {
     long startTime = LogTime.getLogTime();
-    final InputStream result;
     try {
-      result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
-          glideUrl.getHeaders());
+      InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
+      callback.onDataReady(result);
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Failed to load data for url", e);
       }
       callback.onLoadFailed(e);
-      return;
-    }
-
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime)
-          + " ms and loaded " + result);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-    callback.onDataReady(result);
   }
 
   private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
@@ -108,9 +108,9 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
       return null;
     }
     final int statusCode = urlConnection.getResponseCode();
-    if (statusCode / 100 == 2) {
+    if (isHttpOk(statusCode)) {
       return getStreamForSuccessfulRequest(urlConnection);
-    } else if (statusCode / 100 == 3) {
+    } else if (isHttpRedirect(statusCode)) {
       String redirectUrlString = urlConnection.getHeaderField("Location");
       if (TextUtils.isEmpty(redirectUrlString)) {
         throw new HttpException("Received empty or null redirect url");
@@ -120,13 +120,23 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
       // to disconnecting the url connection below. See #2352.
       cleanup();
       return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
-    } else if (statusCode == -1) {
+    } else if (statusCode == INVALID_STATUS_CODE) {
       throw new HttpException(statusCode);
     } else {
       throw new HttpException(urlConnection.getResponseMessage(), statusCode);
     }
   }
 
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpOk(int statusCode) {
+    return statusCode / 100 == 2;
+  }
+
+  // Referencing constants is less clear than a simple static method.
+  private static boolean isHttpRedirect(int statusCode) {
+    return statusCode / 100 == 3;
+  }
+
   private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
       throws IOException {
     if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index 323f02e17..7749477ac 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -3,6 +3,8 @@
 import android.content.ContentResolver;
 import android.database.Cursor;
 import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
 import com.bumptech.glide.load.ImageHeaderParser;
@@ -24,13 +26,13 @@
   private final ContentResolver contentResolver;
   private final List<ImageHeaderParser> parsers;
 
-  public ThumbnailStreamOpener(
+  ThumbnailStreamOpener(
       List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
       ContentResolver contentResolver) {
     this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
-  public ThumbnailStreamOpener(
+  ThumbnailStreamOpener(
       List<ImageHeaderParser> parsers,
       FileService service,
       ThumbnailQuery query,
@@ -43,13 +45,13 @@ public ThumbnailStreamOpener(
     this.parsers = parsers;
   }
 
-  public int getOrientation(Uri uri) {
+  int getOrientation(Uri uri) {
     InputStream is = null;
     try {
       is = contentResolver.openInputStream(uri);
       return ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
-      // openInputStream can throw NPEs.
-    } catch (IOException | NullPointerException e) {
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") IOException | NullPointerException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Failed to open uri: " + uri, e);
       }
@@ -66,37 +68,43 @@ public int getOrientation(Uri uri) {
   }
 
   public InputStream open(Uri uri) throws FileNotFoundException {
-    Uri thumbnailUri = null;
-    InputStream inputStream = null;
+    String path = getPath(uri);
+    if (TextUtils.isEmpty(path)) {
+      return null;
+    }
+
+    File file = service.get(path);
+    if (!isValid(file)) {
+      return null;
+    }
+
+    Uri thumbnailUri = Uri.fromFile(file);
+    try {
+      return contentResolver.openInputStream(thumbnailUri);
+      // PMD.AvoidCatchingNPE framework method openInputStream can throw NPEs.
+    } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
+      throw (FileNotFoundException)
+          new FileNotFoundException("NPE opening uri: " + uri + " -> " + thumbnailUri).initCause(e);
+    }
+  }
 
+  @Nullable
+  private String getPath(@NonNull Uri uri) {
     final Cursor cursor = query.query(uri);
     try {
-      if (cursor == null || !cursor.moveToFirst()) {
+      if (cursor != null && cursor.moveToFirst()) {
+        return cursor.getString(0);
+      } else {
         return null;
       }
-      String path = cursor.getString(0);
-      if (TextUtils.isEmpty(path)) {
-        return null;
-      }
-
-      File file = service.get(path);
-      if (service.exists(file) && service.length(file) > 0) {
-        thumbnailUri = Uri.fromFile(file);
-      }
     } finally {
       if (cursor != null) {
         cursor.close();
       }
     }
-    if (thumbnailUri != null) {
-      try {
-        inputStream = contentResolver.openInputStream(thumbnailUri);
-        // openInputStream can throw NPEs.
-      } catch (NullPointerException e) {
-        throw (FileNotFoundException)
-          new FileNotFoundException("NPE opening uri: " + thumbnailUri).initCause(e);
-      }
-    }
-    return inputStream;
+  }
+
+  private boolean isValid(File file) {
+    return service.exists(file) && 0 < service.length(file);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
index 19671164c..5ccbf7b7f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -38,8 +38,11 @@ public boolean handleMessage(Message msg) {
 
   private ResourceListener listener;
 
-  // Lazily instantiate to avoid exceptions if Glide is initialized on a background thread. See
-  // #295.
+  /**
+   * Lazily instantiate to avoid exceptions if Glide is initialized on a background thread.
+   *
+   * @see <a href="https://github.com/bumptech/glide/issues/295">#295</a>
+   */
   @Nullable
   private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
   @Nullable
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
index 0972f30ad..bc19d18eb 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java
@@ -51,6 +51,9 @@ public boolean startNext() {
       }
 
       Key sourceId = cacheKeys.get(sourceIdIndex);
+      // PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times
+      // and the actions it performs are much more expensive than a single allocation.
+      @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
       Key originalKey = new DataCacheKey(sourceId, helper.getSignature());
       cacheFile = helper.getDiskCache().get(originalKey);
       if (cacheFile != null) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 3bccb0f29..bdbd83fb6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -235,10 +235,14 @@ public Engine(
     return new LoadStatus(cb, engineJob);
   }
 
+  // TODO(#2776): Remove this suppression.
+  @SuppressWarnings("PMD.UnusedPrivateMethod")
   private static void logWithTimeAndKey(String log, long startTime, Key key) {
     Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);
   }
 
+  // TODO(#2776): Remove this suppression.
+  @SuppressWarnings("PMD.UnusedPrivateMethod")
   @Nullable
   private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
     if (!isMemoryCacheable) {
@@ -252,6 +256,8 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     return active;
   }
 
+  // TODO(#2776): Remove this suppression.
+  @SuppressWarnings("PMD.UnusedPrivateMethod")
   private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
     if (!isMemoryCacheable) {
       return null;
@@ -265,7 +271,6 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
     return cached;
   }
 
-  @SuppressWarnings("unchecked")
   private EngineResource<?> getEngineResourceFromCache(Key key) {
     Resource<?> cached = cache.remove(key);
 
@@ -394,8 +399,9 @@ public DiskCache getDiskCache() {
   @VisibleForTesting
   static class DecodeJobFactory {
     @Synthetic final DecodeJob.DiskCacheProvider diskCacheProvider;
-    @Synthetic final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<DecodeJob<?>>() {
+    @Synthetic final Pools.Pool<DecodeJob<?>> pool =
+        FactoryPools.simple(JOB_POOL_SIZE,
+            new FactoryPools.Factory<DecodeJob<?>>() {
           @Override
           public DecodeJob<?> create() {
             return new DecodeJob<>(diskCacheProvider, pool);
@@ -453,19 +459,21 @@ public DiskCache getDiskCache() {
     @Synthetic final GlideExecutor sourceUnlimitedExecutor;
     @Synthetic final GlideExecutor animationExecutor;
     @Synthetic final EngineJobListener listener;
-    @Synthetic final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
-        new FactoryPools.Factory<EngineJob<?>>() {
-          @Override
-          public EngineJob<?> create() {
-            return new EngineJob<>(
-                diskCacheExecutor,
-                sourceExecutor,
-                sourceUnlimitedExecutor,
-                animationExecutor,
-                listener,
-                pool);
-          }
-        });
+    @Synthetic final Pools.Pool<EngineJob<?>> pool =
+        FactoryPools.simple(
+            JOB_POOL_SIZE,
+            new FactoryPools.Factory<EngineJob<?>>() {
+              @Override
+              public EngineJob<?> create() {
+                return new EngineJob<>(
+                    diskCacheExecutor,
+                    sourceExecutor,
+                    sourceUnlimitedExecutor,
+                    animationExecutor,
+                    listener,
+                    pool);
+              }
+            });
 
     EngineJobFactory(
         GlideExecutor diskCacheExecutor,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
index ec15b8da4..fd50d328a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java
@@ -75,7 +75,6 @@ public LoadPath(Class<Data> dataClass, Class<ResourceType> resourceClass,
 
   @Override
   public String toString() {
-    return "LoadPath{" + "decodePaths="
-        + Arrays.toString(decodePaths.toArray(new DecodePath<?, ?, ?>[decodePaths.size()])) + '}';
+    return "LoadPath{" + "decodePaths=" + Arrays.toString(decodePaths.toArray()) + '}';
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index 537da858a..c30722bf8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -20,7 +20,7 @@
   private final FetcherReadyCallback cb;
   private final DecodeHelper<?> helper;
 
-  private int sourceIdIndex = 0;
+  private int sourceIdIndex;
   private int resourceClassIndex = -1;
   private Key sourceKey;
   private List<ModelLoader<File, ?>> modelLoaders;
@@ -57,9 +57,11 @@ public boolean startNext() {
       Key sourceId = sourceIds.get(sourceIdIndex);
       Class<?> resourceClass = resourceClasses.get(resourceClassIndex);
       Transformation<?> transformation = helper.getTransformation(resourceClass);
-
+      // PMD.AvoidInstantiatingObjectsInLoops Each iteration is comparatively expensive anyway,
+      // we only run until the first one succeeds, the loop runs for only a limited
+      // number of iterations on the order of 10-20 in the worst case.
       currentKey =
-          new ResourceCacheKey(
+          new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops
               helper.getArrayPool(),
               sourceId,
               helper.getSignature(),
@@ -70,7 +72,7 @@ public boolean startNext() {
               helper.getOptions());
       cacheFile = helper.getDiskCache().get(currentKey);
       if (cacheFile != null) {
-        this.sourceKey = sourceId;
+        sourceKey = sourceId;
         modelLoaders = helper.getModelLoaders(cacheFile);
         modelLoaderIndex = 0;
       }
@@ -80,9 +82,8 @@ public boolean startNext() {
     boolean started = false;
     while (!started && hasNextModelLoader()) {
       ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
-      loadData =
-          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),
-              helper.getOptions());
+      loadData = modelLoader.buildLoadData(cacheFile,
+          helper.getWidth(), helper.getHeight(), helper.getOptions());
       if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
         started = true;
         loadData.fetcher.loadData(helper.getPriority(), this);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
index a5b89f53d..5536b75db 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java
@@ -7,7 +7,7 @@
 import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
-import java.util.TreeMap;
+import java.util.NavigableMap;
 
 /**
  * A strategy for reusing bitmaps that relies on
@@ -16,11 +16,11 @@
  * <p> Requires {@link Build.VERSION_CODES#KITKAT KitKat} or higher. </p>
  */
 @RequiresApi(Build.VERSION_CODES.KITKAT)
-class SizeStrategy implements LruPoolStrategy {
+final class SizeStrategy implements LruPoolStrategy {
   private static final int MAX_SIZE_MULTIPLE = 8;
   private final KeyPool keyPool = new KeyPool();
   private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<>();
-  private final TreeMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
+  private final NavigableMap<Integer, Integer> sortedSizes = new PrettyPrintTreeMap<>();
 
   @Override
   public void put(Bitmap bitmap) {
@@ -102,11 +102,11 @@ private static String getBitmapString(Bitmap bitmap) {
     return getBitmapString(size);
   }
 
-  @Synthetic
-  static String getBitmapString(int size) {
+  @Synthetic static String getBitmapString(int size) {
     return "[" + size + "]";
   }
 
+  // Non-final for mocking.
   @VisibleForTesting
   static class KeyPool extends BaseKeyPool<Key> {
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index 364f84289..2cedfe0b2 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -22,7 +22,7 @@
 
   private static final int APP_VERSION = 1;
   private static final int VALUE_COUNT = 1;
-  private static DiskLruCacheWrapper wrapper = null;
+  private static DiskLruCacheWrapper wrapper;
 
   private final SafeKeyGenerator safeKeyGenerator;
   private final File directory;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
index 34272a47d..a8c5d641c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java
@@ -123,7 +123,12 @@ boolean allocate() {
       // Don't over fill the memory cache to avoid evicting useful resources, but make sure it's
       // not empty so that we use all available space.
       if (getFreeMemoryCacheBytes() >= bitmapSize) {
-        memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));
+        // We could probably make UniqueKey just always return false from equals,
+        // but the allocation of the Key is not nearly as expensive as the allocation of the Bitmap,
+        // so it's probably not worth it.
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        Key uniqueKey = new UniqueKey();
+        memoryCache.put(uniqueKey, BitmapResource.obtain(bitmap, bitmapPool));
       } else {
         bitmapPool.put(bitmap);
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 42b17bf23..bb8213fc1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -20,8 +20,7 @@
 public class ByteArrayLoader<Data> implements ModelLoader<byte[], Data> {
   private final Converter<Data> converter;
 
-  // Public API.
-  @SuppressWarnings("WeakerAccess")
+  @SuppressWarnings("WeakerAccess") // Public API
   public ByteArrayLoader(Converter<Data> converter) {
     this.converter = converter;
   }
@@ -39,10 +38,12 @@ public boolean handles(@NonNull byte[] model) {
 
   /**
    * Converts between a byte array a desired model class.
+   *
    * @param <Data> The type of data to convert to.
    */
   public interface Converter<Data> {
     Data convert(byte[] model);
+
     Class<Data> getDataClass();
   }
 
@@ -50,6 +51,12 @@ public boolean handles(@NonNull byte[] model) {
     private final byte[] model;
     private final Converter<Data> converter;
 
+    /**
+     * @param model We really ought to copy the model, but doing so can be hugely expensive and/or
+     *              lead to OOMs. In practice it's unlikely that users would pass an array into
+     *              Glide and then mutate it.
+     */
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
     Fetcher(byte[] model, Converter<Data> converter) {
       this.model = model;
       this.converter = converter;
@@ -92,7 +99,7 @@ public DataSource getDataSource() {
 
     @NonNull
     @Override
-    public ModelLoader<byte[], ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
         @Override
         public ByteBuffer convert(byte[] model) {
@@ -119,7 +126,7 @@ public void teardown() {
 
     @NonNull
     @Override
-    public ModelLoader<byte[], InputStream> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], InputStream> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<InputStream>() {
         @Override
         public InputStream convert(byte[] model) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index 213c25ce1..c56d04b08 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -37,7 +37,7 @@ public boolean handles(@NonNull File file) {
 
     @NonNull
     @Override
-    public ModelLoader<File, ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<File, ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new ByteBufferFileLoader();
     }
 
@@ -47,7 +47,7 @@ public void teardown() {
     }
   }
 
-  private static class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
+  private static final class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
 
     private final File file;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
index 6865bb818..b5bddccaf 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -152,12 +152,13 @@ public void close(InputStream inputStream) throws IOException {
 
     @NonNull
     @Override
-    public final ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, InputStream> build(
+        @NonNull MultiModelLoaderFactory multiFactory) {
       return new DataUrlLoader<>(opener);
     }
 
     @Override
-    public final void teardown() {
+    public void teardown() {
       // Do nothing.
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index f56f8bd58..e4f0d9178 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -52,7 +52,7 @@ public boolean handles(@NonNull File model) {
     Class<Data> getDataClass();
   }
 
-  private static class FileFetcher<Data> implements DataFetcher<Data> {
+  private static final class FileFetcher<Data> implements DataFetcher<Data> {
     private final File file;
     private final FileOpener<Data> opener;
     private Data data;
@@ -118,7 +118,7 @@ public Factory(FileOpener<Data> opener) {
 
     @NonNull
     @Override
-    public final ModelLoader<File, Data> build(MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<File, Data> build(@NonNull MultiModelLoaderFactory multiFactory) {
       return new FileLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 3dbae2a51..e7f446ca5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import java.util.ArrayList;
@@ -42,28 +43,32 @@
     Map<String, String> combinedHeaders = new HashMap<>();
 
     for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-      StringBuilder sb = new StringBuilder();
-      List<LazyHeaderFactory> factories = entry.getValue();
-      int size = factories.size();
-      for (int i = 0; i < size; i++) {
-        LazyHeaderFactory factory = factories.get(i);
-        String header = factory.buildHeader();
-        if (!TextUtils.isEmpty(header)) {
-          sb.append(header);
-          if (i != factories.size() - 1) {
-            sb.append(',');
-          }
-        }
-      }
-      String values = sb.toString();
+      String values = buildHeaderValue(entry.getValue());
       if (!TextUtils.isEmpty(values)) {
-        combinedHeaders.put(entry.getKey(), sb.toString());
+        combinedHeaders.put(entry.getKey(), values);
       }
     }
 
     return combinedHeaders;
   }
 
+  @NonNull
+  private String buildHeaderValue(@NonNull List<LazyHeaderFactory> factories) {
+    StringBuilder sb = new StringBuilder();
+    int size = factories.size();
+    for (int i = 0; i < size; i++) {
+      LazyHeaderFactory factory = factories.get(i);
+      String header = factory.buildHeader();
+      if (!TextUtils.isEmpty(header)) {
+        sb.append(header);
+        if (i != factories.size() - 1) {
+          sb.append(',');
+        }
+      }
+    }
+    return sb.toString();
+  }
+
   @Override
   public String toString() {
     return "LazyHeaders{"
@@ -96,8 +101,6 @@ public int hashCode() {
    * {@link #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)}
    * would usually append an additional value. </p>
    */
-   // PMD doesn't like the necessary static block to initialize DEFAULT_HEADERS.
-  @SuppressWarnings({"PMD.FieldDeclarationsShouldBeAtStartOfClass", "WeakerAccess"})
   public static final class Builder {
     private static final String USER_AGENT_HEADER = "User-Agent";
     private static final String DEFAULT_USER_AGENT = getSanitizedUserAgent();
@@ -128,7 +131,6 @@ public int hashCode() {
      * (i.e. an OAuth token). </p>
      *
      * @see #addHeader(String, LazyHeaderFactory)
-
      */
     public Builder addHeader(String key, String value) {
       return addHeader(key, new StringHeaderFactory(value));
@@ -163,8 +165,7 @@ public Builder addHeader(String key, LazyHeaderFactory factory) {
      * <p> Use {@link #setHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O
      * (i.e. an OAuth token). </p>
      */
-    // Public API.
-    @SuppressWarnings("UnusedReturnValue")
+    @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"}) // Public API
     public Builder setHeader(String key, String value) {
       return setHeader(key, value == null ? null : new StringHeaderFactory(value));
     }
@@ -217,10 +218,11 @@ public LazyHeaders build() {
     }
 
     private Map<String, List<LazyHeaderFactory>> copyHeaders() {
-      Map<String, List<LazyHeaderFactory>> result =
-          new HashMap<>(headers.size());
+      Map<String, List<LazyHeaderFactory>> result = new HashMap<>(headers.size());
       for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) {
-        result.put(entry.getKey(), new ArrayList<>(entry.getValue()));
+        @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+        List<LazyHeaderFactory> valueCopy = new ArrayList<>(entry.getValue());
+        result.put(entry.getKey(), valueCopy);
       }
       return result;
     }
@@ -228,7 +230,7 @@ public LazyHeaders build() {
     /**
      * Ensures that the default header will pass OkHttp3's checks for header values.
      *
-     * <p>See #2331.
+     * @see <a href="https://github.com/bumptech/glide/issues/2331">#2331</a>
      */
     @VisibleForTesting
     static String getSanitizedUserAgent() {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index 684dc76b0..443304fcc 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -68,8 +68,7 @@ public boolean handles(@NonNull Model model) {
 
   @Override
   public String toString() {
-    return "MultiModelLoader{" + "modelLoaders=" + Arrays
-        .toString(modelLoaders.toArray(new ModelLoader<?, ?>[modelLoaders.size()])) + '}';
+    return "MultiModelLoader{" + "modelLoaders=" + Arrays.toString(modelLoaders.toArray()) + '}';
   }
 
   static class MultiFetcher<Data> implements DataFetcher<Data>, DataCallback<Data> {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index 9ce67c102..16bb6cfde 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -42,7 +42,8 @@ private static Uri parseUri(String model) {
     Uri uri;
     if (TextUtils.isEmpty(model)) {
       return null;
-    } else if (model.startsWith("/")) {
+    // See https://pmd.github.io/pmd-6.0.0/pmd_rules_java_performance.html#simplifystartswith
+    } else if (model.charAt(0) == '/') {
       uri = toFileUri(model);
     } else {
       uri = Uri.parse(model);
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index 4ca9dd16a..670e86986 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -25,6 +25,8 @@
   /**
    * @deprecated Use {@link #getInstance()} instead.
    */
+  // Need constructor to document deprecation, will be removed, when constructor is privatized.
+  @SuppressWarnings({"PMD.UnnecessaryConstructor", "DeprecatedIsStillUsed"})
   @Deprecated
   public UnitModelLoader() {
     // Intentionally empty.
@@ -84,7 +86,7 @@ public DataSource getDataSource() {
    *
    * @param <Model> The type of model that will also be returned as decodable data.
    */
-  // PMD seems to be just wrong here, maybe confused by getInstance in UnitModelLoader.
+  // PMD.SingleMethodSingleton false positive: https://github.com/pmd/pmd/issues/816
   @SuppressWarnings("PMD.SingleMethodSingleton")
   public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
     @SuppressWarnings("deprecation")
@@ -96,6 +98,8 @@ public DataSource getDataSource() {
     }
 
     /** @deprecated Use {@link #getInstance()} instead. */
+    // Need constructor to document deprecation, will be removed, when constructor is privatized.
+    @SuppressWarnings("PMD.UnnecessaryConstructor")
     @Deprecated
     public Factory() {
       // Intentionally empty.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
index 68c606f00..20c765776 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java
@@ -11,6 +11,7 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -69,7 +70,9 @@ protected BaseGlideUrlLoader(ModelLoader<GlideUrl, InputStream> concreteLoader,
     }
   }
 
-  private static List<Key> getAlternateKeys(List<String> alternateUrls) {
+  // Creating a limited number of objects as the sole purpose of the loop.
+  @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")
+  private static List<Key> getAlternateKeys(Collection<String> alternateUrls) {
     List<Key> result = new ArrayList<>(alternateUrls.size());
     for (String alternate : alternateUrls) {
       result.add(new GlideUrl(alternate));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index 6a64cf121..a2252613b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -79,7 +79,7 @@ public int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws
   }
 
   private ImageType getType(Reader reader) throws IOException {
-    int firstTwoBytes = reader.getUInt16();
+    final int firstTwoBytes = reader.getUInt16();
 
     // JPEG.
     if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
@@ -208,10 +208,8 @@ private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
    * {@code -1} if no exif segment is found.
    */
   private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
-    short segmentId, segmentType;
-    int segmentLength;
     while (true) {
-      segmentId = reader.getUInt8();
+      short segmentId = reader.getUInt8();
       if (segmentId != SEGMENT_START_ID) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Unknown segmentId=" + segmentId);
@@ -219,8 +217,7 @@ private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
         return -1;
       }
 
-      segmentType = reader.getUInt8();
-
+      short segmentType = reader.getUInt8();
       if (segmentType == SEGMENT_SOS) {
         return -1;
       } else if (segmentType == MARKER_EOI) {
@@ -231,8 +228,7 @@ private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
       }
 
       // Segment length includes bytes for segment length.
-      segmentLength = reader.getUInt16() - 2;
-
+      int segmentLength = reader.getUInt16() - 2;
       if (segmentType != EXIF_SEGMENT_TYPE) {
         long skipped = reader.skip(segmentLength);
         if (skipped != segmentLength) {
@@ -274,19 +270,16 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
 
     int firstIfdOffset = segmentData.getInt32(headerOffsetSize + 4) + headerOffsetSize;
     int tagCount = segmentData.getInt16(firstIfdOffset);
-
-    int tagOffset, tagType, formatCode, componentCount;
     for (int i = 0; i < tagCount; i++) {
-      tagOffset = calcTagOffset(firstIfdOffset, i);
-      tagType = segmentData.getInt16(tagOffset);
+      final int tagOffset = calcTagOffset(firstIfdOffset, i);
 
+      final int tagType = segmentData.getInt16(tagOffset);
       // We only want orientation.
       if (tagType != ORIENTATION_TAG_TYPE) {
         continue;
       }
 
-      formatCode = segmentData.getInt16(tagOffset + 2);
-
+      final int formatCode = segmentData.getInt16(tagOffset + 2);
       // 12 is max format code.
       if (formatCode < 1 || formatCode > 12) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -295,8 +288,7 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
         continue;
       }
 
-      componentCount = segmentData.getInt32(tagOffset + 4);
-
+      final int componentCount = segmentData.getInt32(tagOffset + 4);
       if (componentCount < 0) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Negative tiff component count");
@@ -310,7 +302,6 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       final int byteCount = componentCount + BYTES_PER_FORMAT[formatCode];
-
       if (byteCount > 4) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Got byte count > 4, not orientation, continuing, formatCode=" + formatCode);
@@ -319,7 +310,6 @@ private static int parseExifSegment(RandomAccessReader segmentData) {
       }
 
       final int tagValueOffset = tagOffset + 8;
-
       if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
index 9275e3429..dee51f7a2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
@@ -69,6 +69,7 @@ public DrawableTransformation(Transformation<Bitmap> wrapped, boolean isRequired
     }
   }
 
+  // It's clearer to cast the result in a separate line from obtaining it.
   @SuppressWarnings({"unchecked", "PMD.UnnecessaryLocalBeforeReturn"})
   private Resource<Drawable> newDrawableResource(
       Context context, Resource<Bitmap> transformed) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
index 0a041908d..aa21f9ce9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java
@@ -368,15 +368,15 @@ public synchronized void reset() throws IOException {
    */
   @Override
   public synchronized long skip(long byteCount) throws IOException {
+    if (byteCount < 1) {
+      return 0;
+    }
     // Use local refs since buf and in may be invalidated by an unsynchronized close()
     byte[] localBuf = buf;
-    InputStream localIn = in;
     if (localBuf == null) {
       throw streamClosed();
     }
-    if (byteCount < 1) {
-      return 0;
-    }
+    InputStream localIn = in;
     if (localIn == null) {
       throw streamClosed();
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 16e61a0d6..8978e818c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -121,13 +121,16 @@ public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     }
     // From ImageView/Bitmap.createScaledBitmap.
     final float scale;
-    float dx = 0, dy = 0;
+    final float dx;
+    final float dy;
     Matrix m = new Matrix();
     if (inBitmap.getWidth() * height > width * inBitmap.getHeight()) {
       scale = (float) height / (float) inBitmap.getHeight();
       dx = (width - inBitmap.getWidth() * scale) * 0.5f;
+      dy = 0;
     } else {
       scale = (float) width / (float) inBitmap.getWidth();
+      dx = 0;
       dy = (height - inBitmap.getHeight() * scale) * 0.5f;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
index 6b8fde35e..88068855d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/BytesResource.java
@@ -20,8 +20,18 @@ public BytesResource(byte[] bytes) {
     return byte[].class;
   }
 
+  /**
+   * In most cases it will only be retrieved once (see linked methods).
+   *
+   * @return the same array every time, do not mutate the contents. Not a copy returned, because
+   * copying the array can be prohibitively expensive and/or lead to OOMs.
+   * @see com.bumptech.glide.load.ResourceEncoder
+   * @see com.bumptech.glide.load.resource.transcode.ResourceTranscoder
+   * @see com.bumptech.glide.request.SingleRequest#onResourceReady
+   */
   @NonNull
   @Override
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
   public byte[] get() {
     return bytes;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index 6781b922a..dbab1827c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -92,34 +92,36 @@ public GifDrawableResource decode(@NonNull ByteBuffer source, int width, int hei
   private GifDrawableResource decode(
       ByteBuffer byteBuffer, int width, int height, GifHeaderParser parser, Options options) {
     long startTime = LogTime.getLogTime();
-    final GifHeader header = parser.parseHeader();
-    if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
-      // If we couldn't decode the GIF, we will end up with a frame count of 0.
-      return null;
-    }
+    try {
+      final GifHeader header = parser.parseHeader();
+      if (header.getNumFrames() <= 0 || header.getStatus() != GifDecoder.STATUS_OK) {
+        // If we couldn't decode the GIF, we will end up with a frame count of 0.
+        return null;
+      }
 
-    Bitmap.Config config = options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565
-        ? Bitmap.Config.RGB_565 : Bitmap.Config.ARGB_8888;
+      Bitmap.Config config = options.get(GifOptions.DECODE_FORMAT) == DecodeFormat.PREFER_RGB_565
+          ? Bitmap.Config.RGB_565 : Bitmap.Config.ARGB_8888;
 
-    int sampleSize = getSampleSize(header, width, height);
-    GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
-    gifDecoder.setDefaultBitmapConfig(config);
-    gifDecoder.advance();
-    Bitmap firstFrame = gifDecoder.getNextFrame();
-    if (firstFrame == null) {
-      return null;
-    }
+      int sampleSize = getSampleSize(header, width, height);
+      GifDecoder gifDecoder = gifDecoderFactory.build(provider, header, byteBuffer, sampleSize);
+      gifDecoder.setDefaultBitmapConfig(config);
+      gifDecoder.advance();
+      Bitmap firstFrame = gifDecoder.getNextFrame();
+      if (firstFrame == null) {
+        return null;
+      }
 
-    Transformation<Bitmap> unitTransformation = UnitTransformation.get();
+      Transformation<Bitmap> unitTransformation = UnitTransformation.get();
 
-    GifDrawable gifDrawable =
-        new GifDrawable(context, gifDecoder, unitTransformation, width, height, firstFrame);
+      GifDrawable gifDrawable =
+          new GifDrawable(context, gifDecoder, unitTransformation, width, height, firstFrame);
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
+      return new GifDrawableResource(gifDrawable);
+    } finally {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Decoded GIF from stream in " + LogTime.getElapsedMillis(startTime));
+      }
     }
-
-    return new GifDrawableResource(gifDrawable);
   }
 
   private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targetHeight) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index bee286b77..c46775bd2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -37,9 +37,9 @@
   @SuppressWarnings("WeakerAccess") @Synthetic final RequestManager requestManager;
   private final BitmapPool bitmapPool;
 
-  private boolean isRunning = false;
-  private boolean isLoadPending = false;
-  private boolean startFromFirstFrame = false;
+  private boolean isRunning;
+  private boolean isLoadPending;
+  private boolean startFromFirstFrame;
   private RequestBuilder<Bitmap> requestBuilder;
   private DelayTarget current;
   private boolean isCleared;
@@ -111,10 +111,10 @@ void subscribe(FrameCallback frameCallback) {
     if (isCleared) {
       throw new IllegalStateException("Cannot subscribe to a cleared frame loader");
     }
-    boolean start = callbacks.isEmpty();
     if (callbacks.contains(frameCallback)) {
       throw new IllegalStateException("Cannot subscribe twice in a row");
     }
+    boolean start = callbacks.isEmpty();
     callbacks.add(frameCallback);
     if (start) {
       start();
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 9bf9b5205..3dc929ef2 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -810,7 +810,11 @@ public RequestOptions signature(@NonNull Key signature) {
    * <p> Even if this object was locked, the cloned object returned from this method will not be
    * locked. </p>
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({
+      "unchecked",
+      // we don't want to throw to be user friendly
+      "PMD.CloneThrowsCloneNotSupportedException"
+  })
   @CheckResult
   @Override
   public RequestOptions clone() {
@@ -1647,14 +1651,20 @@ private boolean isSet(int flag) {
     return isSet(fields, flag);
   }
 
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
   public final boolean getUseUnlimitedSourceGeneratorsPool() {
     return useUnlimitedSourceGeneratorsPool;
   }
 
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
   public final boolean getUseAnimationPool() {
     return useAnimationPool;
   }
 
+  // get is just as clear.
+  @SuppressWarnings("PMD.BooleanGetMethodName")
   public final boolean getOnlyRetrieveFromCache() {
     return onlyRetrieveFromCache;
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index be500d87c..635b6b5d0 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -43,8 +43,8 @@
  */
 public abstract class ViewTarget<T extends View, Z> extends BaseTarget<Z> {
   private static final String TAG = "ViewTarget";
-  private static boolean isTagUsedAtLeastOnce = false;
-  @Nullable private static Integer tagId = null;
+  private static boolean isTagUsedAtLeastOnce;
+  @Nullable private static Integer tagId;
 
   protected final T view;
   private final SizeDeterminer sizeDeterminer;
@@ -74,8 +74,7 @@ public ViewTarget(@NonNull T view) {
    *
    * @deprecated Use {@link #waitForLayout()} instead.
    */
-  // Public API.
-  @SuppressWarnings("WeakerAccess")
+  @SuppressWarnings("WeakerAccess") // Public API
   @Deprecated
   public ViewTarget(@NonNull T view, boolean waitForLayout) {
     this(view);
@@ -161,7 +160,7 @@ public void onViewDetachedFromWindow(View v) {
    * still be used instead of the {@link View}'s dimensions even if this method is called. This
    * parameter is a fallback only.
    */
-  @SuppressWarnings("WeakerAccess")
+  @SuppressWarnings("WeakerAccess") // Public API
   @NonNull
   public final ViewTarget<T, Z> waitForLayout() {
     sizeDeterminer.waitForLayout = true;
diff --git a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
index 2bcd360c0..21d86931d 100644
--- a/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java
@@ -4,18 +4,21 @@
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.annotation.VisibleForTesting;
+import android.util.Log;
 import com.bumptech.glide.load.Key;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * A utility class for obtaining a {@link com.bumptech.glide.load.Key} signature containing the
  * application version name using {@link android.content.pm.PackageInfo#versionCode}.
  */
 public final class ApplicationVersionSignature {
-  private static final ConcurrentHashMap<String, Key> PACKAGE_NAME_TO_KEY =
-      new ConcurrentHashMap<>();
+  private static final String TAG = "AppVersionSignature";
+  private static final ConcurrentMap<String, Key> PACKAGE_NAME_TO_KEY = new ConcurrentHashMap<>();
 
   /**
    * Returns the signature {@link com.bumptech.glide.load.Key} for version code of the Application
@@ -44,20 +47,30 @@ static void reset() {
 
   @NonNull
   private static Key obtainVersionSignature(@NonNull Context context) {
-    PackageInfo pInfo = null;
-    try {
-      pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
-    } catch (PackageManager.NameNotFoundException e) {
-      // Should never happen.
-      e.printStackTrace();
-    }
-    final String versionCode;
-    if (pInfo != null) {
-      versionCode = String.valueOf(pInfo.versionCode);
+    PackageInfo packageInfo = getPackageInfo(context);
+    String versionCode = getVersionCode(packageInfo);
+    return new ObjectKey(versionCode);
+  }
+
+  @NonNull
+  private static String getVersionCode(@Nullable PackageInfo packageInfo) {
+    String versionCode;
+    if (packageInfo != null) {
+      versionCode = String.valueOf(packageInfo.versionCode);
     } else {
       versionCode = UUID.randomUUID().toString();
     }
-    return new ObjectKey(versionCode);
+    return versionCode;
+  }
+
+  @Nullable
+  private static PackageInfo getPackageInfo(@NonNull Context context) {
+    try {
+      return context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+    } catch (PackageManager.NameNotFoundException e) {
+      Log.e(TAG, "Cannot resolve info for" + context.getPackageName(), e);
+      return null;
+    }
   }
 
   private ApplicationVersionSignature() {
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index e1b73aa34..8f0bee837 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -15,8 +15,7 @@
 /**
  * Utilities for interacting with {@link java.nio.ByteBuffer}s.
  */
-// Public API.
-@SuppressWarnings({"unused", "WeakerAccess"})
+@SuppressWarnings({"unused", "WeakerAccess"}) // Public API
 public final class ByteBufferUtil {
   // 16 Kb
   private static final int BUFFER_SIZE = 16384;
@@ -167,6 +166,8 @@ private static SafeArray getSafeArray(@NonNull ByteBuffer byteBuffer) {
     @Synthetic final int limit;
     @Synthetic final byte[] data;
 
+    // PMD.ArrayIsStoredDirectly Copying would be prohibitively expensive and/or lead to OOMs.
+    @SuppressWarnings("PMD.ArrayIsStoredDirectly")
     SafeArray(@NonNull byte[] data, int offset, int limit) {
       this.data = data;
       this.offset = offset;
@@ -207,7 +208,7 @@ public boolean markSupported() {
     }
 
     @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+    public int read(@NonNull byte[] buffer, int byteOffset, int byteCount) throws IOException {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
index 92daaf11b..08b7ed3ba 100644
--- a/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/FixedPreloadSizeProvider.java
@@ -25,6 +25,9 @@ public FixedPreloadSizeProvider(int width, int height) {
 
   @Nullable
   @Override
+  // It's better to take on the risk that callers may mutate the array when there isn't any reason
+  // for them to do so than it the performance overhead of copying the array with every call.
+  @SuppressWarnings("PMD.MethodReturnsInternalArray")
   public int[] getPreloadSize(@NonNull T item, int adapterPosition, int itemPosition) {
     return size;
   }
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index 5f7402aea..a2cd7d822 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -15,10 +15,10 @@
  * @param <Y> The type of the values.
  */
 public class LruCache<T, Y> {
-  private final LinkedHashMap<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
+  private final Map<T, Y> cache = new LinkedHashMap<>(100, 0.75f, true);
   private final long initialMaxSize;
   private long maxSize;
-  private long currentSize = 0;
+  private long currentSize;
 
   /**
    * Constructor for LruCache.
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 7e294e2c7..b5cae5cba 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -81,7 +81,7 @@ public static int getBitmapByteSize(@NonNull Bitmap bitmap) {
       // Workaround for KitKat initial release NPE in Bitmap, fixed in MR1. See issue #148.
       try {
         return bitmap.getAllocationByteCount();
-      } catch (NullPointerException e) {
+      } catch (@SuppressWarnings("PMD.AvoidCatchingNPE") NullPointerException e) {
         // Do nothing.
       }
     }
diff --git a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
index 2757c0873..0d2c90bb8 100644
--- a/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
+++ b/library/src/test/java/com/bumptech/glide/signature/ApplicationVersionSignatureTest.java
@@ -1,8 +1,11 @@
 package com.bumptech.glide.signature;
 
 import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import android.content.Context;
+import android.content.pm.PackageManager.NameNotFoundException;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.tests.KeyTester;
 import java.io.UnsupportedEncodingException;
@@ -12,6 +15,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Answers;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -51,4 +55,29 @@ public void testKeyForSignatureIsTheSameAcrossCallsInTheSamePackage()
             "5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9")
         .test();
   }
+
+  @Test
+  public void testUnresolvablePackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0))
+        .thenThrow(new NameNotFoundException("test"));
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
+
+  @Test
+  public void testMissingPackageInfo() throws NameNotFoundException {
+    Context context = mock(Context.class, Answers.RETURNS_DEEP_STUBS.get());
+    String packageName = "my.package";
+    when(context.getPackageName()).thenReturn(packageName);
+    when(context.getPackageManager().getPackageInfo(packageName, 0)).thenReturn(null);
+
+    Key key = ApplicationVersionSignature.obtain(context);
+
+    assertNotNull(key);
+  }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
index 1037ad205..1a5346d09 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
 import com.bumptech.glide.request.RequestOptions;
@@ -9,7 +10,7 @@
  * Extension methods for the Flickr sample's generated API.
  */
 // Required by Glide's annotation processor.
-@SuppressWarnings("WeakerAccess")
+@SuppressWarnings({"WeakerAccess", "unused"})
 @GlideExtension
 public final class FlickrGlideExtension {
 
@@ -17,20 +18,15 @@ private FlickrGlideExtension() {
     // Utility class.
   }
 
+  @NonNull
   @GlideOption
   public static RequestOptions squareThumb(RequestOptions requestOptions) {
-    return requestOptions
-        .centerCrop();
+    return requestOptions.centerCrop();
   }
 
+  @NonNull
   @GlideOption
   public static RequestOptions squareMiniThumb(RequestOptions requestOptions) {
     return requestOptions.centerCrop().override(Api.SQUARE_THUMB_SIZE);
   }
-
-  @GlideOption(override = GlideOption.OVERRIDE_EXTEND)
-  public static RequestOptions centerCrop(RequestOptions options) {
-    return options;
-    // Empty.
-  }
 }
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index 485c8191d..f224a53a9 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -5,7 +5,7 @@ dependencies {
     implementation(project(':integration:recyclerview')) {
         transitive = false
     }
-    implementation 'com.google.code.gson:gson:2.8.0'
+    implementation 'com.google.code.gson:gson:2.8.2'
     implementation "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
     implementation "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
