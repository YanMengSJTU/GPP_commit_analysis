diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 4ef954d7e..20a2be95a 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -648,6 +648,11 @@ public void clearMemory() {
   public void trimMemory(int level) {
     // Engine asserts this anyway when removing resources, fail faster and consistently
     Util.assertMainThread();
+    // Request managers need to be trimmed before the caches and pools, in order for the latter to
+    // have the most benefit.
+    for (RequestManager manager : managers) {
+      manager.onTrimMemory(level);
+    }
     // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.trimMemory(level);
     bitmapPool.trimMemory(level);
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index a33e2b9ec..cd6b528c5 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -4,7 +4,9 @@
 import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
 
+import android.content.ComponentCallbacks2;
 import android.content.Context;
+import android.content.res.Configuration;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
@@ -54,7 +56,8 @@
  * @see Glide#with(androidx.fragment.app.Fragment)
  * @see Glide#with(Context)
  */
-public class RequestManager implements LifecycleListener, ModelTypes<RequestBuilder<Drawable>> {
+public class RequestManager
+    implements ComponentCallbacks2, LifecycleListener, ModelTypes<RequestBuilder<Drawable>> {
   private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
   private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
   private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
@@ -93,6 +96,8 @@ public void run() {
   @GuardedBy("this")
   private RequestOptions requestOptions;
 
+  private boolean pauseAllRequestsOnTrimMemoryModerate;
+
   public RequestManager(
       @NonNull Glide glide,
       @NonNull Lifecycle lifecycle,
@@ -221,6 +226,14 @@ public RequestManager addDefaultRequestListener(RequestListener<Object> requestL
     return this;
   }
 
+  /**
+   * If {@code true} then clear all in-progress and completed requests when the platform sends
+   * {@code onTrimMemory} with level = {@code TRIM_MEMORY_MODERATE}.
+   */
+  public void setPauseAllRequestsOnTrimMemoryModerate(boolean pauseAllOnTrim) {
+    pauseAllRequestsOnTrimMemoryModerate = pauseAllOnTrim;
+  }
+
   /**
    * Returns true if loads for this {@link RequestManager} are currently paused.
    *
@@ -265,6 +278,22 @@ public synchronized void pauseAllRequests() {
     requestTracker.pauseAllRequests();
   }
 
+  /**
+   * Performs {@link #pauseAllRequests()} recursively for all managers that are contextually
+   * descendant to this manager based on the Activity/Fragment hierarchy.
+   *
+   * <p>Similar to {@link #pauseRequestsRecursive()} with the exception that it also clears
+   * resources of completed loads.
+   */
+  // Public API.
+  @SuppressWarnings({"WeakerAccess", "unused"})
+  public synchronized void pauseAllRequestsRecursive() {
+    pauseAllRequests();
+    for (RequestManager requestManager : treeNode.getDescendants()) {
+      requestManager.pauseAllRequests();
+    }
+  }
+
   /**
    * Performs {@link #pauseRequests()} recursively for all managers that are contextually descendant
    * to this manager based on the Activity/Fragment hierarchy:
@@ -663,6 +692,21 @@ public synchronized String toString() {
     return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
   }
 
+  @Override
+  public void onTrimMemory(int level) {
+    if (level == TRIM_MEMORY_MODERATE && pauseAllRequestsOnTrimMemoryModerate) {
+      pauseAllRequestsRecursive();
+    }
+  }
+
+  @Override
+  public void onLowMemory() {
+    // Nothing to add conditionally. See Glide#onTrimMemory for unconditional behavior.
+  }
+
+  @Override
+  public void onConfigurationChanged(Configuration newConfig) {}
+
   private class RequestManagerConnectivityListener
       implements ConnectivityMonitor.ConnectivityListener {
     @GuardedBy("RequestManager.this")
diff --git a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
index ad9cb2efc..144bd6324 100644
--- a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
@@ -15,7 +15,7 @@
    * android.graphics.Bitmap.Config#ARGB_8888} for {@link android.graphics.Bitmap#getConfig()} when
    * possible.
    *
-   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use {@link
+   * <p>On Android O+, this format will use ARGB_8888 only when it's not possible to use {@link
    * android.graphics.Bitmap.Config#HARDWARE}. More information is available about hardware Bitmaps
    * here: https://goo.gl/tn2A6k. If you need to disable hardware Bitmaps for a particular request,
    * use {@link com.bumptech.glide.request.RequestOptions#disallowHardwareConfig()}.
@@ -34,7 +34,7 @@
    * alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for {@link
    * android.graphics.Bitmap#getConfig()}.
    *
-   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use {@link
+   * <p>On Android O+, this format will use ARGB_8888 only when it's not possible to use {@link
    * android.graphics.Bitmap.Config#HARDWARE}.
    */
   PREFER_RGB_565;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index e99f55dc8..89d4b725e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -383,16 +383,20 @@ public StateVerifier getVerifier() {
   private class CallLoadFailed implements Runnable {
 
     private final ResourceCallback cb;
+    private final Object lock;
 
     CallLoadFailed(ResourceCallback cb) {
       this.cb = cb;
+      // The lock may be reset if the callback is removed while our Runnable is pending, so memoize
+      // it here. We're assuming that the lock is never re-used.
+      this.lock = Preconditions.checkNotNull(cb.getLock());
     }
 
     @Override
     public void run() {
       // Make sure we always acquire the request lock, then the EngineJob lock to avoid deadlock
       // (b/136032534).
-      synchronized (cb) {
+      synchronized (lock) {
         synchronized (EngineJob.this) {
           if (cbs.contains(cb)) {
             callCallbackOnLoadFailed(cb);
@@ -407,16 +411,20 @@ public void run() {
   private class CallResourceReady implements Runnable {
 
     private final ResourceCallback cb;
+    private final Object lock;
 
     CallResourceReady(ResourceCallback cb) {
       this.cb = cb;
+      // The lock may be reset if the callback is removed while our Runnable is pending, so memoize
+      // it here. We're assuming that the lock is never re-used.
+      this.lock = Preconditions.checkNotNull(cb.getLock());
     }
 
     @Override
     public void run() {
       // Make sure we always acquire the request lock, then the EngineJob lock to avoid deadlock
       // (b/136032534).
-      synchronized (cb) {
+      synchronized (lock) {
         synchronized (EngineJob.this) {
           if (cbs.contains(cb)) {
             // Acquire for this particular callback.
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index a1b835a0a..da1a99a37 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -215,7 +215,7 @@ public static GlideExecutor newUnlimitedSourceExecutor() {
   }
 
   /**
-   * Returns a new cached thread pool that defaults to either one or two threads depending on the
+   * Returns a new fixed thread pool that defaults to either one or two threads depending on the
    * number of available cores to use when loading frames of animations.
    */
   public static GlideExecutor newAnimationExecutor() {
@@ -231,7 +231,7 @@ public static GlideExecutor newAnimationExecutor() {
   }
 
   /**
-   * Returns a new cached thread pool with the given thread count and {@link
+   * Returns a new fixed thread pool with the given thread count and {@link
    * UncaughtThrowableStrategy} to use when loading frames of animations.
    */
   // Public API.
@@ -240,9 +240,9 @@ public static GlideExecutor newAnimationExecutor(
       int threadCount, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
     return new GlideExecutor(
         new ThreadPoolExecutor(
-            0 /* corePoolSize */,
             threadCount,
-            KEEP_ALIVE_TIME_MS,
+            threadCount,
+            0,
             TimeUnit.MILLISECONDS,
             new PriorityBlockingQueue<Runnable>(),
             new DefaultThreadFactory(ANIMATION_EXECUTOR_NAME, uncaughtThrowableStrategy, true)));
diff --git a/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java b/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java
index ed1ec1063..e1ed01992 100644
--- a/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java
+++ b/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java
@@ -23,4 +23,7 @@
    * @param e a non-null {@link GlideException}.
    */
   void onLoadFailed(GlideException e);
+
+  /** Returns the lock to use when notifying individual requests. */
+  Object getLock();
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index f5fb9f2d4..8cc16585e 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -21,6 +21,7 @@
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.request.transition.TransitionFactory;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import com.bumptech.glide.util.pool.FactoryPools;
@@ -229,7 +230,7 @@ private void init(
       Engine engine,
       TransitionFactory<? super R> animationFactory,
       Executor callbackExecutor) {
-    this.requestLock = requestLock;
+    this.requestLock = Preconditions.checkNotNull(requestLock);
     synchronized (this.requestLock) {
       this.context = context;
       this.glideContext = glideContext;
@@ -716,6 +717,12 @@ public void onLoadFailed(GlideException e) {
     onLoadFailed(e, Log.WARN);
   }
 
+  @Override
+  public Object getLock() {
+    stateVerifier.throwIfRecycled();
+    return requestLock;
+  }
+
   private void onLoadFailed(GlideException e, int maxLogLevel) {
     stateVerifier.throwIfRecycled();
     synchronized (requestLock) {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 3b49a220c..c4c687e49 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -188,7 +188,7 @@ public void testRemovingAllCallbacksCancelsRunner() {
   @Test
   public void removingSomeCallbacksDoesNotCancelRunner() {
     EngineJob<Object> job = harness.getJob();
-    job.addCallback(mock(ResourceCallback.class), Executors.directExecutor());
+    job.addCallback(mockResourceCallback(), Executors.directExecutor());
     job.removeCallback(harness.cb);
 
     assertFalse(job.isCancelled());
@@ -261,8 +261,8 @@ public void testDoesNotAcquireOnceForMemoryCacheIfNotCacheable() {
   @Test
   public void testNotifiesNewCallbackOfResourceIfCallbackIsAddedDuringOnResourceReady() {
     final EngineJob<Object> job = harness.getJob();
-    final ResourceCallback existingCallback = mock(ResourceCallback.class);
-    final ResourceCallback newCallback = mock(ResourceCallback.class);
+    final ResourceCallback existingCallback = mockResourceCallback();
+    final ResourceCallback newCallback = mockResourceCallback();
 
     doAnswer(
             new Answer<Void>() {
@@ -286,8 +286,8 @@ public Void answer(InvocationOnMock invocationOnMock) {
   public void testNotifiesNewCallbackOfExceptionIfCallbackIsAddedDuringOnException() {
     harness = new EngineJobHarness();
     final EngineJob<Object> job = harness.getJob();
-    final ResourceCallback existingCallback = mock(ResourceCallback.class);
-    final ResourceCallback newCallback = mock(ResourceCallback.class);
+    final ResourceCallback existingCallback = mockResourceCallback();
+    final ResourceCallback newCallback = mockResourceCallback();
 
     doAnswer(
             new Answer<Void>() {
@@ -311,7 +311,7 @@ public Void answer(InvocationOnMock invocationOnMock) {
   @Test
   public void testRemovingCallbackDuringOnResourceReadyIsIgnoredIfCallbackHasAlreadyBeenCalled() {
     final EngineJob<Object> job = harness.getJob();
-    final ResourceCallback cb = mock(ResourceCallback.class);
+    final ResourceCallback cb = mockResourceCallback();
 
     doAnswer(
             new Answer<Void>() {
@@ -335,7 +335,7 @@ public Void answer(InvocationOnMock invocationOnMock) {
   public void testRemovingCallbackDuringOnExceptionIsIgnoredIfCallbackHasAlreadyBeenCalled() {
     harness = new EngineJobHarness();
     final EngineJob<Object> job = harness.getJob();
-    final ResourceCallback cb = mock(ResourceCallback.class);
+    final ResourceCallback cb = mockResourceCallback();
 
     doAnswer(
             new Answer<Void>() {
@@ -360,7 +360,7 @@ public Void answer(InvocationOnMock invocationOnMock) {
   public void
       testRemovingCallbackDuringOnResourceReadyPreventsCallbackFromBeingCalledIfNotYetCalled() {
     final EngineJob<Object> job = harness.getJob();
-    final ResourceCallback notYetCalled = mock(ResourceCallback.class);
+    final ResourceCallback notYetCalled = mockResourceCallback();
 
     doAnswer(
             new Answer<Void>() {
@@ -384,7 +384,7 @@ public Void answer(InvocationOnMock invocationOnMock) {
   public void
       testRemovingCallbackDuringOnResourceReadyPreventsResourceFromBeingAcquiredForCallback() {
     final EngineJob<Object> job = harness.getJob();
-    final ResourceCallback notYetCalled = mock(ResourceCallback.class);
+    final ResourceCallback notYetCalled = mockResourceCallback();
 
     doAnswer(
             new Answer<Void>() {
@@ -410,8 +410,8 @@ public Void answer(InvocationOnMock invocationOnMock) {
   public void testRemovingCallbackDuringOnExceptionPreventsCallbackFromBeingCalledIfNotYetCalled() {
     harness = new EngineJobHarness();
     final EngineJob<Object> job = harness.getJob();
-    final ResourceCallback called = mock(ResourceCallback.class);
-    final ResourceCallback notYetCalled = mock(ResourceCallback.class);
+    final ResourceCallback called = mockResourceCallback();
+    final ResourceCallback notYetCalled = mockResourceCallback();
 
     doAnswer(
             new Answer<Void>() {
@@ -482,6 +482,12 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
     verify(harness.decodeJob).run();
   }
 
+  private static ResourceCallback mockResourceCallback() {
+    ResourceCallback result = mock(ResourceCallback.class);
+    when(result.getLock()).thenReturn(result);
+    return result;
+  }
+
   @SuppressWarnings("unchecked")
   private static class MultiCbHarness {
     final Key key = mock(Key.class);
@@ -524,7 +530,7 @@ public MultiCbHarness() {
           useAnimationPool,
           onlyRetrieveFromCache);
       for (int i = 0; i < numCbs; i++) {
-        cbs.add(mock(ResourceCallback.class));
+        cbs.add(mockResourceCallback());
       }
       for (ResourceCallback cb : cbs) {
         job.addCallback(cb, Executors.directExecutor());
@@ -537,7 +543,7 @@ public MultiCbHarness() {
     final EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
     final Key key = mock(Key.class);
     final Handler mainHandler = new Handler();
-    final ResourceCallback cb = mock(ResourceCallback.class);
+    final ResourceCallback cb = mockResourceCallback();
     final Resource<Object> resource = mockResource();
     final EngineResource<Object> engineResource = mock(EngineResource.class);
     final EngineJobListener engineJobListener = mock(EngineJobListener.class);
