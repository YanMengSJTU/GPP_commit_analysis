diff --git a/.travis.yml b/.travis.yml
index e3dc14645..a16977739 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,10 +3,8 @@ android:
   components:
   - tools
   - platform-tools
-  - build-tools-25.0.2
-  - android-25
-  - extra-android-m2repository
-  - extra-android-support
+  - build-tools-26.0.1
+  - android-26
 
   licenses:
   - 'android-sdk-license.*'
@@ -16,7 +14,7 @@ jdk:
 
 sudo: false
 
-script: 'travis_retry ./gradlew build'
+script: 'travis_retry ./gradlew build --parallel'
 
 after_success:
 - scripts/travis-sonatype-publish.sh
@@ -24,7 +22,10 @@ after_success:
 
 before_cache:
   - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock
+  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
 cache:
   directories:
     - $HOME/.gradle/caches/
     - $HOME/.gradle/wrapper/
+    - $HOME/.android/build-cache
+
diff --git a/README.md b/README.md
index 42b2d5802..b2e7f345b 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
 Glide
 =====
 
-[![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
-[Report an issue with Glide][5]
+[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide) [![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
+| [View Glide's documentation][20] | [简体中文文档][22] | [Report an issue with Glide][5]
 
 Glide is a fast and efficient open source media management and image loading framework for Android that wraps media
 decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.
@@ -24,12 +24,13 @@ Or use Gradle:
 
 ```gradle
 repositories {
-  mavenCentral() // jcenter() works as well because it pulls from Maven Central
+  mavenCentral()
+  maven { url 'https://maven.google.com' }
 }
 
 dependencies {
-  compile 'com.github.bumptech.glide:glide:3.7.0'
-  compile 'com.android.support:support-v4:19.1.0'
+  compile 'com.github.bumptech.glide:glide:4.1.1'
+  annotationProcessor 'com.github.bumptech.glide:compiler:4.1.1'
 }
 ```
 
@@ -39,13 +40,19 @@ Or Maven:
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>glide</artifactId>
-  <version>3.7.0</version>
+  <version>4.1.1</version>
 </dependency>
 <dependency>
   <groupId>com.google.android</groupId>
   <artifactId>support-v4</artifactId>
   <version>r7</version>
 </dependency>
+<dependency>
+  <groupId>com.github.bumptech.glide</groupId>
+  <artifactId>compiler</artifactId>
+  <version>4.1.1</version>
+  <optional>true</optional>
+</dependency>
 ```
 
 For info on using the bleeding edge, see the [Snapshots][17] wiki page.
@@ -56,6 +63,7 @@ Depending on your ProGuard (DexGuard) config and usage, you may need to include
 
 ```pro
 -keep public class * implements com.bumptech.glide.module.GlideModule
+-keep public class * extends com.bumptech.glide.AppGlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
   **[] $VALUES;
   public *;
@@ -67,9 +75,11 @@ Depending on your ProGuard (DexGuard) config and usage, you may need to include
 
 How do I use Glide?
 -------------------
-Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [javadocs][3].
+Check out the [documentation][20] for pages on a variety of topics, and see the [javadocs][3].
 
-Simple use cases will look something like this:
+For Glide v3, see the [wiki][2].
+
+Simple use cases with Glide's [generated API][21] will look something like this:
 
 ```java
 // For a simple view:
@@ -77,7 +87,7 @@ Simple use cases will look something like this:
   ...
   ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
 
-  Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
+  GlideApp.with(this).load("http://goo.gl/gEgYUd").into(imageView);
 }
 
 // For a simple image list:
@@ -91,12 +101,11 @@ Simple use cases will look something like this:
 
   String url = myUrls.get(position);
 
-  Glide
+  GlideApp
     .with(myFragment)
     .load(url)
     .centerCrop()
     .placeholder(R.drawable.loading_spinner)
-    .crossFade()
     .into(myImageView);
 
   return myImageView;
@@ -105,15 +114,17 @@ Simple use cases will look something like this:
 
 Status
 ------
-[*Version 3* on the `3.0` branch][14] is a stable public release used in multiple open source projects at Google including in the Android Camera
-app and in the 2014 Google IO app. *Version 4* is currently under development on the `master` branch.
+Version 4 is now released and stable. Updates are currently released at least monthly with new features and bug fixes.
 
 Comments/bugs/questions/pull requests are always welcome! Please read [CONTRIBUTING.md][5] on how to report issues.
 
 Compatibility
 -------------
 
- * **Android SDK**: Glide requires a minimum API level of 10.
+ * **Minimum Android SDK**: Glide requires a minimum API level of 14.
+ * **Compile Android SDK**: Glide requires you to compile against API 26.
+
+ If you need to support older versions, consider staying on [Glide v3][14], which works on API 10, but not actively maintained.
  * **OkHttp 2.x**: there are optional dependencies available called `okhttp-integration`, see [Integration Libraries][12] wiki page.
  * **OkHttp 3.x**: there are optional dependencies available called `okhttp3-integration`, see [Integration Libraries][12] wiki page.
  * **Volley**: there are optional dependencies available called `volley-integration`, see [Integration Libraries][12] wiki page.
@@ -136,12 +147,13 @@ variable is pointing at the SDK or add a `local.properties` file in the root pro
 
 Samples
 -------
-Follow the steps in the [Build](#build) section to setup the project and then:
+Follow the steps in the [Build](#build) section to set up the project and then:
 
 ```shell
 ./gradlew :samples:flickr:run
 ./gradlew :samples:giphy:run
 ./gradlew :samples:svg:run
+./gradlew :samples:contacturi:run
 ```
 You may also find precompiled APKs on the [releases page][1].
 
@@ -188,7 +200,7 @@ This is not an official Google product.
 
 [1]: https://github.com/bumptech/glide/releases
 [2]: https://github.com/bumptech/glide/wiki
-[3]: http://bumptech.github.io/glide/javadocs/latest/index.html
+[3]: http://bumptech.github.io/glide/ref/javadocs.html
 [4]: https://www.jetbrains.com/idea/download/
 [5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
@@ -205,3 +217,6 @@ This is not an official Google product.
 [17]: https://github.com/bumptech/glide/wiki/Snapshots
 [18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
 [19]: https://github.com/wasabeef/glide-transformations
+[20]: http://bumptech.github.io/glide/
+[21]: http://bumptech.github.io/glide/doc/generatedapi.html
+[22]: https://muyangmin.github.io/glide-docs-cn/
\ No newline at end of file
diff --git a/annotation/compiler/build.gradle b/annotation/compiler/build.gradle
index 0b51f2584..656534bf7 100644
--- a/annotation/compiler/build.gradle
+++ b/annotation/compiler/build.gradle
@@ -1,17 +1,80 @@
 import org.gradle.internal.jvm.Jvm
+import proguard.gradle.ProGuardTask
 
 apply plugin: 'java'
 
+configurations {
+    // adapted from https://android.googlesource.com/platform/frameworks/testing/+/976c423/espresso/espresso-lib/build.gradle
+    // compileOnly dependencies will be repackaged, see rules in jarjar ant task below
+    jarjar 
+}
+
 dependencies {
-    compile 'com.squareup:javapoet:1.8.0'
-    compile 'com.google.auto.service:auto-service:1.0-rc3'
-    compile 'com.google.code.findbugs:jsr305:3.0.1'
+    // from https://code.google.com/archive/p/jarjar/downloads
+    jarjar files('libs/jarjar-1.4.jar')
+
+    compileOnly 'com.squareup:javapoet:1.9.0'
+    compileOnly 'com.google.auto.service:auto-service:1.0-rc3'
+    compileOnly 'com.google.code.findbugs:jsr305:3.0.1'
+
     compile project(':annotation')
     // This is to support com.sun.tootls.javac.util.List, currently used in RootModuleGenerator.
     compile files(Jvm.current().getToolsJar())
+}
+
+def repackagedJar = file("$buildDir/intermediates/repackaged.jar")
+def proguardedJar = file("$buildDir/intermediates/proguarded.jar")
+
+task compiledJar(type: Jar, dependsOn: classes) {
+    from sourceSets.main.output
+}
+
+// Repackage compileOnly dependencies to avoid namespace collisions.
+task jarjar(dependsOn: [tasks.compiledJar, configurations.compileOnly]) {
+    // Set up inputs and outputs to only rebuild when necessary (code change, dependency change).
+    inputs.file compiledJar
+    inputs.files configurations.compileOnly
+    outputs.file repackagedJar
+
+    doFirst {
+        ant {
+            taskdef name: 'jarjar',
+                    classname: 'com.tonicsystems.jarjar.JarJarTask',
+                    classpath: configurations.jarjar.asPath
+
+            jarjar(jarfile: repackagedJar) {
+                configurations.compileOnly.resolve().each {
+                    zipfileset(src: it.absolutePath, excludes: [
+                        'META-INF/maven/**',
+                        'META-INF/services/javax.annotation.processing.Processor'
+                    ].join(','))
+                }
+                zipfileset(src: tasks.jar.archivePath)
+                def repackageIntoGlide = 'com.bumptech.glide.repackaged.@0'
+                rule result: repackageIntoGlide, pattern: 'com.squareup.javapoet.**'
+                rule result: repackageIntoGlide, pattern: 'com.google.auto.**'
+                rule result: repackageIntoGlide, pattern: 'com.google.common.**'
+                rule result: repackageIntoGlide, pattern: 'com.google.thirdparty.publicsuffix.**'
+            }
+        }
+    }
+}
+
+// Proguard repackaged dependencies to reduce the binary size.
+task proguard(type: ProGuardTask, dependsOn: tasks.jarjar) {
+    configuration 'proguard.pro'
+
+    injars repackagedJar
+    outjars proguardedJar
+
+    libraryjars files(configurations.compile.collect())
+    libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
+}
 
-    testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile 'com.google.testing.compile:compile-testing:0.10'
+// Create the standard jar artifact based on our repackaged and proguarded jar.
+jar {
+    dependsOn proguard
+    from zipTree(proguardedJar)
 }
 
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/annotation/compiler/libs/jarjar-1.4.jar b/annotation/compiler/libs/jarjar-1.4.jar
new file mode 100644
index 000000000..68b9db9aa
Binary files /dev/null and b/annotation/compiler/libs/jarjar-1.4.jar differ
diff --git a/annotation/compiler/proguard.pro b/annotation/compiler/proguard.pro
new file mode 100644
index 000000000..d40c8f599
--- /dev/null
+++ b/annotation/compiler/proguard.pro
@@ -0,0 +1,22 @@
+-verbose
+# Use ProGuard only to get rid of unused classes
+-dontobfuscate
+-dontoptimize
+-keepattributes *
+-keep class !com.bumptech.glide.repackaged.**,com.bumptech.glide.**
+
+# Keep the entry point to this library, see META-INF\services\javax.annotation.processing.Processor
+-keep class com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor
+
+
+# "duplicate definition of library class"
+-dontnote sun.applet.**
+# "duplicate definition of library class"
+-dontnote sun.tools.jar.**
+# Reflective accesses in com.google.common.util.concurrent.* and some others
+-dontnote com.bumptech.glide.repackaged.com.google.common.**
+# com.google.common.collect.* and some others (….common.*.*)
+-dontwarn com.google.j2objc.annotations.Weak
+# com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$ClassValueValidator
+-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+#-dontwarn **
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
index 6e45b850a..3e62fb816 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
@@ -181,6 +181,7 @@ private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClas
             .addModifiers(Modifier.PUBLIC)
             .addAnnotation(Override.class)
             .addParameter(ClassName.get("android.content", "Context"), "context")
+            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide")
             .addParameter(ClassName.get("com.bumptech.glide", "Registry"), "registry");
 
     for (String glideModule : libraryGlideModuleClassNames) {
@@ -189,10 +190,10 @@ private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClas
       }
       ClassName moduleClassName = ClassName.bestGuess(glideModule);
       registerComponents.addStatement(
-          "new $T().registerComponents(context, registry)", moduleClassName);
+          "new $T().registerComponents(context, glide, registry)", moduleClassName);
     }
     // Order matters here. The AppGlideModule must be called last.
-    registerComponents.addStatement("appGlideModule.registerComponents(context, registry)");
+    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");
     return registerComponents.build();
   }
 
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
index b636ddbb6..17f64f327 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
@@ -17,7 +17,7 @@
  * Runs the final steps of Glide's annotation process and generates the combined
  * {@link AppGlideModule}, {@link com.bumptech.glide.Glide},
  * {@link com.bumptech.glide.RequestManager}, and
- * {@link com.bumptech.glide.request.BaseRequestOptions} classes.
+ * {@link com.bumptech.glide.request.RequestOptions} classes.
  */
 final class AppModuleProcessor {
   private static final String COMPILER_PACKAGE_NAME =
@@ -83,12 +83,9 @@ boolean maybeWriteAppModule() {
     // in a project.
     String generatedCodePackageName = appModule.getEnclosingElement().toString();
 
-    TypeSpec generatedRequestOptions = null;
-    if (!indexedClassNames.extensions.isEmpty()) {
-      generatedRequestOptions =
+    TypeSpec generatedRequestOptions =
           requestOptionsGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);
       writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
-    }
 
     TypeSpec generatedRequestBuilder =
         requestBuilderGenerator.generate(generatedCodePackageName, generatedRequestOptions);
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
index 6991716ab..9046219e2 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
@@ -37,7 +37,7 @@
  *     initialized.
  *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -
  *   <ul>
- *     <li>A {@link com.bumptech.glide.request.BaseRequestOptions} implementation that contains
+ *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains
  *     static versions of all builder methods in the base class and both static and instance
  *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
  *     <li>If one or more methods in one or more
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
index 545be7b46..488c5578f 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -60,7 +60,7 @@ private static void validateExtendsRequestOptions(ExecutableElement executableEl
     VariableElement first = executableElement.getParameters().get(0);
     TypeMirror expected = first.asType();
     if (!expected.toString().equals(
-        "com.bumptech.glide.request.BaseRequestOptions<?>")) {
+        "com.bumptech.glide.request.RequestOptions")) {
       throw new IllegalArgumentException("@GlideOption methods must take a"
           + " RequestOptions object as their first parameter, but given: " + expected);
     }
@@ -70,7 +70,7 @@ private static void validateExtendsRequestManager(ExecutableElement executableEl
     validateStaticVoid(executableElement, GlideType.class);
     if (executableElement.getParameters().size() != 1) {
       throw new IllegalArgumentException("@GlideType methods must take a"
-          + " BaseRequestOptions object as their first and only parameter, found multiple for: "
+          + " RequestOptions object as their first and only parameter, found multiple for: "
       + executableElement.getEnclosingElement() + "#" + executableElement);
     }
 
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
index 1f54c7667..99805e9b0 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
@@ -4,6 +4,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
@@ -11,6 +12,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -74,6 +76,14 @@
   private static final String REQUEST_MANAGER_QUALIFIED_NAME =
       "com.bumptech.glide.RequestManager";
 
+  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME =
+      "android.support.annotation.VisibleForTesting";
+
+  private static final String SUPPRESS_LINT_PACKAGE_NAME =
+      "android.annotation";
+  private static final String SUPPRESS_LINT_CLASS_NAME =
+      "SuppressLint";
+
   private final ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
   private final TypeElement glideType;
@@ -145,6 +155,24 @@ public ParameterSpec apply(VariableElement input) {
                   }
             }));
 
+    TypeElement visibleForTestingType =
+        processingEnv
+            .getElementUtils()
+            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+
+      // Suppress a lint warning if we're overriding a VisibleForTesting method.
+      // See #1977.
+      if (mirror.getAnnotationType().asElement().equals(visibleForTestingType)) {
+        builder.addAnnotation(
+            AnnotationSpec.builder(
+                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME))
+                .addMember("value", "$S", "VisibleForTests")
+                .build());
+      }
+    }
+
     boolean returnsValue = element != null;
     if (returnsValue) {
       builder.returns(ClassName.get(element));
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
index dd41a6ec2..5229afc21 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -139,9 +139,9 @@ CodeBlock generateSeeMethodJavadoc(ExecutableElement method) {
     // Use the simple name of the containing type instead of just the containing type's TypeMirror
     // so that we avoid appending <CHILD> or other type arguments to the class and breaking
     // Javadoc's linking.
-    // With this we get @see BaseRequestOptions#methodName().
+    // With this we get @see RequestOptions#methodName().
     // With just ClassName.get(element.getEnclosingElement().asType()), we get:
-    // @see BaseRequestOptions<CHILD>#methodName().
+    // @see RequestOptions<CHILD>#methodName().
     return generateSeeMethodJavadoc(getJavadocSafeName(method.getEnclosingElement()),
         method.getSimpleName().toString(), method.getParameters());
   }
@@ -210,7 +210,7 @@ private CodeBlock generateSeeMethodJavadocInternal(
    * Returns a safe String to use in a Javadoc that will function in a link.
    *
    * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>}
-   * in {@literal BaseRequestOptions<T>} for example).
+   * in {@literal RequestOptions<T>} for example).
    */
   private TypeName getJavadocSafeName(Element element) {
     Types typeUtils = processingEnv.getTypeUtils();
@@ -247,6 +247,13 @@ void infoLog(String toLog) {
         .toList();
   }
 
+  List<ExecutableElement> findStaticMethodsReturning(TypeElement clazz, TypeElement returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.STATIC))
+        .transform(new ToMethod())
+        .toList();
+  }
+
   List<ExecutableElement> findStaticMethods(TypeElement clazz) {
     return FluentIterable.from(clazz.getEnclosedElements())
         .filter(new FilterPublicMethods((TypeMirror) null /*returnType*/, MethodType.STATIC))
@@ -345,7 +352,7 @@ private boolean isReturnValueTypeMatching(
         method.getReturnType(), expectedReturnType);
   }
 
-  private final class ToMethod implements Function<Element, ExecutableElement> {
+  private static final class ToMethod implements Function<Element, ExecutableElement> {
 
     @Nullable
     @Override
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
index 903e6c5ec..372d5b005 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -24,17 +24,17 @@
 import java.util.List;
 import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /**
  * Generates a {@link com.bumptech.glide.RequestBuilder} subclass containing all methods from
- * the base class, all methods from {@link com.bumptech.glide.request.BaseRequestOptions} and all
+ * the base class, all methods from {@link com.bumptech.glide.request.RequestOptions} and all
  * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated
  * classes.
  *
@@ -69,7 +69,7 @@
  *   }
  *
  *   /**
- *    * {@literal @see} BaseRequestOptions#sizeMultiplier(float)
+ *    * {@literal @see} RequestOptions#sizeMultiplier(float)
  *    *\/
  *   public GlideRequest<TranscodeType> sizeMultiplier(float sizeMultiplier) {
  *     this.requestOptions = getMutableOptions().sizeMultiplier(sizeMultiplier);
@@ -82,10 +82,10 @@
  * </pre>
  */
 final class RequestBuilderGenerator {
-  private static final String BASE_REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
-  private static final String BASE_REQUEST_OPTIONS_SIMPLE_NAME = "BaseRequestOptions";
-  private static final String BASE_REQUEST_OPTIONS_QUALIFIED_NAME =
-      BASE_REQUEST_OPTIONS_PACKAGE_NAME + "." + BASE_REQUEST_OPTIONS_SIMPLE_NAME;
+  private static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  private static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
 
   private static final String REQUEST_BUILDER_PACKAGE_NAME = "com.bumptech.glide";
   private static final String REQUEST_BUILDER_SIMPLE_NAME = "RequestBuilder";
@@ -100,16 +100,18 @@
    * e.g. RequestBuilder<TranscodeType>
    */
   private static final String TRANSCODE_TYPE_NAME = "TranscodeType";
-  /** A set of method names to avoid overriding from BaseRequestOptions. */
+  /** A set of method names to avoid overriding from RequestOptions. */
   private static final ImmutableSet<String> EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS =
       ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");
+  private static final ClassName CHECK_RESULT_CLASS_NAME =
+      ClassName.get("android.support.annotation", "CheckResult");
 
   private final ProcessingEnvironment processingEnv;
   private final ProcessorUtil processorUtil;
   private ClassName generatedRequestBuilderClassName;
   private final TypeVariableName transcodeTypeName;
   private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;
-  private final TypeElement baseRequestOptionsType;
+  private final TypeElement requestOptionsType;
   private final TypeElement requestBuilderType;
   private ClassName requestOptionsClassName;
 
@@ -122,8 +124,8 @@
 
     transcodeTypeName = TypeVariableName.get(TRANSCODE_TYPE_NAME);
 
-    baseRequestOptionsType = processingEnv.getElementUtils().getTypeElement(
-        BASE_REQUEST_OPTIONS_QUALIFIED_NAME);
+    requestOptionsType = processingEnv.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
   }
 
   TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {
@@ -139,7 +141,7 @@ TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedO
       requestOptionsClassName =
           ClassName.get(
               RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,
-              RequestBuilderGenerator.BASE_REQUEST_OPTIONS_SIMPLE_NAME);
+              RequestBuilderGenerator.REQUEST_OPTIONS_SIMPLE_NAME);
     }
 
     ParameterizedTypeName requestBuilderOfTranscodeType =
@@ -150,26 +152,26 @@ TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedO
     return TypeSpec.classBuilder(GENERATED_REQUEST_BUILDER_SIMPLE_NAME)
         .addJavadoc("Contains all public methods from {@link $T}, all options from\n",
             requestBuilderType)
-        .addJavadoc("{@link $T} and all generated options from\n", baseRequestOptionsType)
+        .addJavadoc("{@link $T} and all generated options from\n", requestOptionsType)
         .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class)
         .addJavadoc("{@link $T} annotated classes.\n", GlideExtension.class)
         .addJavadoc("\n")
         .addJavadoc("<p>Generated code, do not modify.\n")
         .addJavadoc("\n")
         .addJavadoc("@see $T\n", requestBuilderType)
-        .addJavadoc("@see $T\n", baseRequestOptionsType)
+        .addJavadoc("@see $T\n", requestOptionsType)
         .addAnnotation(
             AnnotationSpec.builder(SuppressWarnings.class)
                 .addMember("value", "$S", "unused")
                 .addMember("value", "$S", "deprecation")
                 .build())
-        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addModifiers(Modifier.PUBLIC)
         .addTypeVariable(transcodeTypeName)
         .superclass(requestBuilderOfTranscodeType)
+        .addSuperinterface(Cloneable.class)
         .addMethods(generateConstructors())
         .addMethod(generateDownloadOnlyRequestMethod())
         .addMethods(generateGeneratedRequestOptionsEquivalents(generatedOptions))
-        .addMethods(generateBaseRequestOptionsEquivalents())
         .addMethods(generateRequestBuilderOverrides())
         .build();
   }
@@ -205,7 +207,7 @@ private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOver
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    return MethodSpec.overriding(methodToOverride)
+    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride)
         .returns(generatedRequestBuilderOfType)
         .addCode(CodeBlock.builder()
             .add("return ($T) super.$N(",
@@ -219,79 +221,13 @@ public String apply(VariableElement input) {
                 })
                 .join(Joiner.on(", ")))
             .add(");\n")
-            .build())
-        .build();
-  }
+            .build());
 
-  /**
-   * Generates methods with equivalent names and arguments to those in
-   * {@link com.bumptech.glide.request.BaseRequestOptions} that modify the internal request options
-   * object and return our generated {@link com.bumptech.glide.RequestBuilder} subclass.
-   *
-   * <p>Equivalents methods are only generated for public and non-static methods that return {@link
-   * com.bumptech.glide.request.BaseRequestOptions}.
-   *
-   * <p>Certain methods are excluded because they either overlap or don't make sense on a request
-   * builder (see {@link #EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS}.
-   */
-  private List<MethodSpec> generateBaseRequestOptionsEquivalents() {
-    return FluentIterable.from(
-        processorUtil.findInstanceMethodsReturning(baseRequestOptionsType, baseRequestOptionsType))
-        .filter(new Predicate<ExecutableElement>() {
-          @Override
-          public boolean apply(ExecutableElement input) {
-            return !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(
-                input.getSimpleName().toString());
-          }
-        })
-        .transform(new Function<ExecutableElement, MethodSpec>() {
-          @Override
-          public MethodSpec apply(ExecutableElement input) {
-            return generateBaseRequestOptionEquivalent(input);
-          }
-        })
-        .toList();
-  }
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      builder.addAnnotation(AnnotationSpec.get(mirror));
+    }
 
-  /**
-   * Generates a particular method equivalent to a method in
-   * {@link com.bumptech.glide.request.BaseRequestOptions}.
-   */
-  private MethodSpec generateBaseRequestOptionEquivalent(ExecutableElement methodToOverride) {
-    return MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
-        .addModifiers(Modifier.PUBLIC)
-        .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
-        .addTypeVariables(Lists.transform(methodToOverride.getTypeParameters(),
-            new Function<TypeParameterElement, TypeVariableName>() {
-              @Override
-              public TypeVariableName apply(TypeParameterElement input) {
-                return TypeVariableName.get(input.getSimpleName().toString());
-              }
-            }))
-        .addParameters(Lists.transform(methodToOverride.getParameters(),
-            new Function<VariableElement, ParameterSpec>() {
-              @Override
-            public ParameterSpec apply(VariableElement input) {
-              return ParameterSpec.get(input);
-            }
-          }))
-        .returns(generatedRequestBuilderOfTranscodeType)
-        .addCode(CodeBlock.builder()
-            .add("this.requestOptions = getMutableOptions()")
-            .add(".$N(", methodToOverride.getSimpleName().toString())
-            .add(FluentIterable
-                .from(methodToOverride.getParameters())
-                .transform(new Function<VariableElement, String>() {
-                  @Override
-                  public String apply(VariableElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })
-                .join(Joiner.on(", ")))
-            .add(");\n")
-            .build())
-        .addStatement("return this")
-        .build();
+    return builder.build();
   }
 
   /**
@@ -331,15 +267,10 @@ public MethodSpec apply(MethodSpec input) {
    * methods that override other methods to avoid duplicates.
    */
   private boolean isUsefulGeneratedRequestOption(MethodSpec requestOptionMethod) {
-    return requestOptionMethod.hasModifier(Modifier.PUBLIC)
+    return
+        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionMethod.name)
+        && requestOptionMethod.hasModifier(Modifier.PUBLIC)
         && !requestOptionMethod.hasModifier(Modifier.STATIC)
-        && !Lists.transform(requestOptionMethod.annotations,
-        new Function<AnnotationSpec, String>() {
-          @Override
-          public String apply(AnnotationSpec input) {
-            return input.type.toString();
-          }
-        }).contains(Override.class.getCanonicalName())
         && requestOptionMethod.returnType.toString()
             .equals(requestOptionsClassName.toString());
   }
@@ -362,10 +293,28 @@ public String apply(ParameterSpec input) {
         .add(");\n")
         .build();
 
-    return MethodSpec.methodBuilder(requestOptionMethod.name)
+    MethodSpec.Builder result = MethodSpec.methodBuilder(requestOptionMethod.name)
         .addJavadoc(
             processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod))
         .addModifiers(Modifier.PUBLIC)
+        .varargs(requestOptionMethod.varargs)
+        .addAnnotations(
+            FluentIterable.from(requestOptionMethod.annotations)
+                .filter(new Predicate<AnnotationSpec>() {
+                  @Override
+                  public boolean apply(AnnotationSpec input) {
+                    return !input.type.equals(TypeName.get(Override.class))
+                        // SafeVarargs can only be applied to final methods. GlideRequest is
+                        // non-final to allow for mocking.
+                        && !input.type.equals(TypeName.get(SafeVarargs.class))
+                        // @CheckResult isn't applicable for RequestBuilder because there is no
+                        // autoClone() in RequestBuilder.
+                        && !input.type.equals(CHECK_RESULT_CLASS_NAME);
+                  }
+                })
+                .toList()
+        )
+        .addTypeVariables(requestOptionMethod.typeVariables)
         .addParameters(requestOptionMethod.parameters)
         .returns(generatedRequestBuilderOfTranscodeType)
         .beginControlFlow(
@@ -378,8 +327,18 @@ public String apply(ParameterSpec input) {
             requestOptionsClassName))
         .addCode(callRequestOptionsMethod)
         .endControlFlow()
-        .addStatement("return this")
-        .build();
+        .addStatement("return this");
+
+    if (requestOptionMethod.annotations.contains(
+        AnnotationSpec.builder(SafeVarargs.class).build())) {
+      result.addAnnotation(
+          AnnotationSpec.builder(SuppressWarnings.class)
+              .addMember("value", "$S", "unchecked")
+              .addMember("value", "$S", "varargs")
+              .build());
+    }
+
+    return result.build();
   }
 
   private List<MethodSpec> generateConstructors() {
@@ -418,6 +377,7 @@ private MethodSpec generateDownloadOnlyRequestMethod() {
         = ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
     return MethodSpec.methodBuilder("getDownloadOnlyRequest")
         .addAnnotation(Override.class)
+        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build())
         .returns(generatedRequestBuilderOfFile)
         .addModifiers(Modifier.PROTECTED)
         .addStatement("return new $T<>($T.class, $N).apply($N)",
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
index adeda9f17..1c20fe858 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -108,7 +108,7 @@ TypeSpec generate(
             AnnotationSpec.builder(SuppressWarnings.class)
                 .addMember("value", "$S", "deprecation")
                 .build())
-         .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+         .addModifiers(Modifier.PUBLIC)
          .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
          .addMethod(generateCallSuperConstructor())
          .addMethods(generateAdditionalRequestManagerMethods(glideExtensions))
@@ -170,10 +170,7 @@ private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec re
           @Override
           public boolean apply(ExecutableElement input) {
             // Skip the <T> as(Class<T>) method.
-            return !input.getSimpleName().toString().equals("as")
-                || input.getParameters().size() != 1
-                || !processingEnv.getTypeUtils().isAssignable(
-                    input.getParameters().get(0).asType(), rawClassType);
+            return !input.getSimpleName().toString().equals("as");
           }
         })
         .transform(new Function<ExecutableElement, MethodSpec>() {
@@ -251,7 +248,7 @@ private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement exte
   }
 
   /**
-   * The {@link com.bumptech.glide.request.BaseRequestOptions} subclass should always be our
+   * The {@link com.bumptech.glide.request.RequestOptions} subclass should always be our
    * generated subclass type to avoid inadvertent errors where a different subclass is applied that
    * accidentally wipes out some logic in overidden methods in our generated subclass.
    */
@@ -263,9 +260,9 @@ private MethodSpec generateOverrideSetRequestOptions(
     }
 
     Elements elementUtils = processingEnv.getElementUtils();
-    TypeElement baseRequestOptionsType =
+    TypeElement requestOptionsType =
             elementUtils.getTypeElement(
-                RequestOptionsGenerator.BASE_REQUEST_OPTIONS_QUALIFIED_NAME);
+                RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
     TypeElement androidNonNullType =
             elementUtils.getTypeElement("android.support.annotation.NonNull");
 
@@ -281,7 +278,7 @@ private MethodSpec generateOverrideSetRequestOptions(
         .addAnnotation(Override.class)
         .addModifiers(Modifier.PROTECTED)
         .addParameter(
-            ParameterSpec.builder(ClassName.get(baseRequestOptionsType), parameterName)
+            ParameterSpec.builder(ClassName.get(requestOptionsType), parameterName)
                 .addAnnotation(ClassName.get(androidNonNullType))
                 .build())
         .beginControlFlow("if ($N instanceof $L)",
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
index 9d86b91e3..209b7715b 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -5,7 +5,14 @@
 
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
 import com.google.common.base.Strings;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -13,7 +20,6 @@
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
@@ -22,6 +28,7 @@
 import java.util.Set;
 import javax.annotation.Nullable;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -31,7 +38,7 @@
 import javax.lang.model.element.VariableElement;
 
 /**
- * Generates a new implementation of {@link com.bumptech.glide.request.BaseRequestOptions}
+ * Generates a new implementation of {@link com.bumptech.glide.request.RequestOptions}
  * containing static versions of methods included in the base class and static and instance versions
  * of all methods annotated with {@link GlideOption} in classes annotated with
  * {@link GlideExtension}.
@@ -39,18 +46,15 @@
  * <p>The generated class looks something like this:
  * <pre>
  * <code>
- * public final class GlideOptions
- *     extends com.bumptech.glide.request.BaseRequestOptions<com.bumptech.glide.GlideOptions> {
- *   public static com.bumptech.glide.GlideOptions sizeMultiplierOf(float sizeMultiplier) {
- *     return new com.bumptech.glide.GlideOptions().sizeMultiplier(sizeMultiplier);
- *   }
+ * public final class GlideOptions extends com.bumptech.glide.request.RequestOptions {
  *
- *   public static com.bumptech.glide.GlideOptions useUnlimitedSourceGeneratorsPoolOf(
- *       boolean flag) {
- *     return new com.bumptech.glide.GlideOptions().useUnlimitedSourceGeneratorsPool(flag);
+ *   public static com.google.android.apps.photos.glide.GlideOptions signatureOf(
+ *       com.bumptech.glide.load.Key arg0) {
+ *     return new com.google.android.apps.photos.glide.GlideOptions()
+ *         .apply(com.bumptech.glide.request.RequestOptions.signatureOf(arg0));
  *   }
  *
- *   ... // The rest of the static versions of methods from BaseRequestOptions go here.
+ *   ... // The rest of the static versions of methods from RequestOptions go here.
  *
  *   // Now on to methods generated from an extension:
  *   public com.bumptech.glide.GlideOptions dontAnimate() {
@@ -58,7 +62,7 @@
  *     return this;
  *   }
  *
- *   public static com.bumptech.glide.GlideOptions noAnimate() {
+ *   public static com.bumptech.glide.GlideOptions noAnimation() {
  *     return new com.bumptech.glide.GlideOptions().dontAnimate();
  *   }
  * }
@@ -68,16 +72,16 @@
  */
 final class RequestOptionsGenerator {
   private static final String GENERATED_REQUEST_OPTIONS_SIMPLE_NAME = "GlideOptions";
-  private static final String BASE_REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
-  private static final String BASE_REQUEST_OPTIONS_SIMPLE_NAME = "BaseRequestOptions";
-  static final String BASE_REQUEST_OPTIONS_QUALIFIED_NAME =
-      BASE_REQUEST_OPTIONS_PACKAGE_NAME + "." + BASE_REQUEST_OPTIONS_SIMPLE_NAME;
-
   static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
+  private static final ClassName CHECK_RESULT_CLASS_NAME =
+      ClassName.get("android.support.annotation", "CheckResult");
 
   private final ProcessingEnvironment processingEnvironment;
-  private final ClassName baseRequestOptionsName;
-  private final TypeElement baseRequestOptionsType;
+  private final ClassName requestOptionsName;
+  private final TypeElement requestOptionsType;
   private final ProcessorUtil processorUtil;
   private ClassName glideOptionsName;
   private int nextStaticFieldUniqueId;
@@ -87,25 +91,46 @@
     this.processingEnvironment = processingEnvironment;
     this.processorUtil = processorUtil;
 
-    baseRequestOptionsName = ClassName.get(BASE_REQUEST_OPTIONS_PACKAGE_NAME,
-        BASE_REQUEST_OPTIONS_SIMPLE_NAME);
+    requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME,
+        REQUEST_OPTIONS_SIMPLE_NAME);
 
-    baseRequestOptionsType = processingEnvironment.getElementUtils().getTypeElement(
-        BASE_REQUEST_OPTIONS_QUALIFIED_NAME);
+    requestOptionsType = processingEnvironment.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
   }
 
   TypeSpec generate(String generatedCodePackageName, Set<String> glideExtensionClassNames) {
     glideOptionsName =
         ClassName.get(generatedCodePackageName, GENERATED_REQUEST_OPTIONS_SIMPLE_NAME);
 
-    ParameterizedTypeName baseRequestOptionsOfGlideOptions = ParameterizedTypeName
-        .get(baseRequestOptionsName, glideOptionsName);
-
-    List<MethodAndStaticVar> staticEquivalents = generateStaticEquivalentsForBaseRequestOptions();
     List<MethodAndStaticVar> methodsForExtensions =
         generateMethodsForExtensions(glideExtensionClassNames);
-    List<MethodAndStaticVar> allMethodsAndStaticVars
-        = new ArrayList<>(staticEquivalents);
+
+    Set<MethodSignature> extensionMethodSignatures = ImmutableSet.copyOf(
+        Iterables.transform(methodsForExtensions,
+            new Function<MethodAndStaticVar, MethodSignature>() {
+              @Nullable
+              @Override
+              public MethodSignature apply(MethodAndStaticVar f) {
+                return new MethodSignature(f.method);
+              }
+            }));
+
+    List<MethodAndStaticVar> staticOverrides = generateStaticMethodOverridesForRequestOptions();
+    List<MethodSpec> instanceOverrides = generateInstanceMethodOverridesForRequestOptions();
+
+    List<MethodAndStaticVar> allMethodsAndStaticVars = new ArrayList<>();
+    for (MethodAndStaticVar item : staticOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(item.method))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(item);
+    }
+    for (MethodSpec methodSpec : instanceOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(methodSpec))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(new MethodAndStaticVar(methodSpec));
+    }
     allMethodsAndStaticVars.addAll(methodsForExtensions);
 
     TypeSpec.Builder classBuilder = TypeSpec.classBuilder(GENERATED_REQUEST_OPTIONS_SIMPLE_NAME)
@@ -116,7 +141,8 @@ TypeSpec generate(String generatedCodePackageName, Set<String> glideExtensionCla
         .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
         .addModifiers(Modifier.FINAL)
         .addModifiers(Modifier.PUBLIC)
-        .superclass(baseRequestOptionsOfGlideOptions);
+        .addSuperinterface(Cloneable.class)
+        .superclass(requestOptionsName);
 
     for (MethodAndStaticVar methodAndStaticVar : allMethodsAndStaticVars) {
       if (methodAndStaticVar.method != null) {
@@ -134,7 +160,7 @@ private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
         .add("Automatically generated from {@link $T} annotated classes.\n",
             GlideExtension.class)
         .add("\n")
-        .add("@see $T\n", baseRequestOptionsName);
+        .add("@see $T\n", requestOptionsName);
 
     for (String glideExtensionClass : glideExtensionClassNames) {
       builder.add("@see $T\n", ClassName.bestGuess(glideExtensionClass));
@@ -150,25 +176,65 @@ private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
 
     List<MethodAndStaticVar> result = new ArrayList<>(requestOptionExtensionMethods.size());
     for (ExecutableElement requestOptionsExtensionMethod : requestOptionExtensionMethods) {
-      result.addAll(generateMethodForRequestOptionsExtension(requestOptionsExtensionMethod));
+      result.addAll(generateMethodsForRequestOptionsExtension(requestOptionsExtensionMethod));
     }
 
     return result;
   }
 
+  private List<MethodSpec> generateInstanceMethodOverridesForRequestOptions() {
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestOptionsType, requestOptionsType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestOptionOverride(input);
+          }
+        });
+  }
 
-  private List<MethodAndStaticVar> generateMethodForRequestOptionsExtension(
+  private MethodSpec generateRequestOptionOverride(ExecutableElement methodToOverride) {
+    MethodSpec.Builder result = MethodSpec.overriding(methodToOverride)
+        .returns(glideOptionsName)
+        .addModifiers(Modifier.FINAL)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(", glideOptionsName, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build());
+
+    if (methodToOverride.getSimpleName().toString().equals("transforms")) {
+      result.addAnnotation(
+          AnnotationSpec.builder(SafeVarargs.class)
+              .build());
+    }
+
+    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
+      result.addAnnotation(AnnotationSpec.get(mirror));
+    }
+
+    return result.build();
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtension(
       ExecutableElement element) {
-    boolean isOverridingBaseRequestOptionsMethod = isMethodInBaseRequestOptions(element);
+    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);
     int overrideType = getOverrideType(element);
-    if (isOverridingBaseRequestOptionsMethod && overrideType == OVERRIDE_NONE) {
+    if (isOverridingRequestOptionsMethod && overrideType == OVERRIDE_NONE) {
       throw new IllegalArgumentException("Accidentally attempting to override a method in"
-          + " BaseRequestOptions. Add an 'override' value in the @GlideOption annotation"
+          + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
           + " if this is intentional. Offending method: "
           + element.getEnclosingElement() + "#" + element);
-    } else if (!isOverridingBaseRequestOptionsMethod && overrideType != OVERRIDE_NONE) {
+    } else if (!isOverridingRequestOptionsMethod && overrideType != OVERRIDE_NONE) {
       throw new IllegalArgumentException("Requested to override an existing method in"
-          + " BaseRequestOptions, but no such method was found. Offending method: "
+          + " RequestOptions, but no such method was found. Offending method: "
           + element.getEnclosingElement() + "#" + element);
     }
     String methodName = element.getSimpleName().toString();
@@ -177,27 +243,34 @@ private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
         .returns(glideOptionsName);
 
-    // The 0th element is expected to be a BaseRequestOptions object.
+    // The 0th element is expected to be a RequestOptions object.
     List<? extends VariableElement> parameters =
         element.getParameters().subList(1, element.getParameters().size());
 
-    // Add the correct super() call.
-    if (overrideType == OVERRIDE_EXTEND) {
-      String callSuper = "super.$L(";
-      List<Object> args = new ArrayList<>();
-      args.add(element.getSimpleName().toString());
-      if (!parameters.isEmpty()) {
-        for (VariableElement variable : parameters) {
-          callSuper += "$L, ";
-          args.add(variable.getSimpleName().toString());
-        }
-        callSuper = callSuper.substring(0, callSuper.length() - 2);
+    // Generates the String and list of arguments to pass in when calling this method or super.
+    // IE centerCrop(context) creates methodLiterals="%L" and methodArgs=[centerCrop, context].
+    List<Object> methodArgs = new ArrayList<>();
+    methodArgs.add(element.getSimpleName().toString());
+    String methodLiterals = "";
+    if (!parameters.isEmpty()) {
+      for (VariableElement variable : parameters) {
+        methodLiterals += "$L, ";
+        methodArgs.add(variable.getSimpleName().toString());
       }
-      callSuper += ")";
+      methodLiterals = methodLiterals.substring(0, methodLiterals.length() - 2);
+    }
+
+    builder.beginControlFlow("if (isAutoCloneEnabled())")
+        .addStatement(
+            "return clone().$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
+        .endControlFlow();
 
-      builder.addStatement(callSuper, args.toArray(new Object[0]))
+    // Add the correct super() call.
+    if (overrideType == OVERRIDE_EXTEND) {
+      String callSuper = "super.$L(" + methodLiterals + ")";
+      builder.addStatement(callSuper, methodArgs.toArray(new Object[0]))
           .addJavadoc(processorUtil.generateSeeMethodJavadoc(
-              baseRequestOptionsName, methodName, parameters))
+              requestOptionsName, methodName, parameters))
           .addAnnotation(Override.class);
     }
 
@@ -205,7 +278,7 @@ private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
       builder.addParameter(getParameterSpec(variable));
     }
 
-    // Adds: <AnnotatedClass>.<thisMethodName>(BaseRequestOptions<?>, <arg1>, <arg2>, <argN>);
+    // Adds: <AnnotatedClass>.<thisMethodName>(RequestOptions<?>, <arg1>, <arg2>, <argN>);
     List<Object> args = new ArrayList<>();
     String code = "$T.$L($L, ";
     args.add(ClassName.get(element.getEnclosingElement().asType()));
@@ -224,26 +297,137 @@ private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
     builder.addStatement("return this");
 
     List<MethodAndStaticVar> result = new ArrayList<>();
+
+    builder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
+
     result.add(new MethodAndStaticVar(builder.build()));
-    if (!isOverridingBaseRequestOptionsMethod) {
-      result.add(generateStaticMethodEquivalent(element, true /*ignoreFirst*/));
-    }
+    result.add(generateStaticMethodEquivalentForExtensionMethod(element));
 
     return result;
   }
 
-  private List<MethodAndStaticVar> generateStaticEquivalentsForBaseRequestOptions() {
-    List<ExecutableElement> instanceMethodsThatReturnBaseRequestOptions =
-        processorUtil.findInstanceMethodsReturning(baseRequestOptionsType, baseRequestOptionsType);
+  private List<MethodAndStaticVar> generateStaticMethodOverridesForRequestOptions() {
+    List<ExecutableElement> staticMethodsThatReturnRequestOptions =
+        processorUtil.findStaticMethodsReturning(requestOptionsType, requestOptionsType);
     List<MethodAndStaticVar> staticMethods = new ArrayList<>();
-    for (ExecutableElement element : instanceMethodsThatReturnBaseRequestOptions) {
-      staticMethods.add(generateStaticMethodEquivalent(element, false /*ignoreFirst*/));
+    for (ExecutableElement element : staticMethodsThatReturnRequestOptions) {
+      if (element.getAnnotation(Deprecated.class) != null) {
+        continue;
+      }
+      staticMethods.add(generateStaticMethodEquivalentForRequestOptionsStaticMethod(element));
     }
     return staticMethods;
   }
 
-  private MethodAndStaticVar generateStaticMethodEquivalent(ExecutableElement instanceMethod,
-      boolean ignoreFirst) {
+  /**
+   * This method is a bit of a hack, but it lets us tie the static version of a method with the
+   * instance version. In turn that lets us call the instance versions on the generated subclass,
+   * instead of just delegating to the RequestOptions static methods. Using the instance methods
+   * on the generated subclass allows our static methods to properly call code that overrides
+   * an existing method in RequestOptions.
+   *
+   * <p>The string names here just map between the static methods in
+   * {@link com.bumptech.glide.request.RequestOptions} and the instance methods they call.
+   */
+  private static String getInstanceMethodNameFromStaticMethodName(String staticMethodName) {
+    String equivalentInstanceMethodName;
+    if ("bitmapTransform".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "transform";
+    } else if ("decodeTypeOf".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "decode";
+    } else if (staticMethodName.endsWith("Transform")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 9);
+    } else if (staticMethodName.endsWith("Of")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 2);
+    } else if ("noTransformation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontTransform";
+    } else if ("noAnimation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontAnimate";
+    } else if (staticMethodName.equals("option")) {
+      equivalentInstanceMethodName = "set";
+    } else {
+      throw new IllegalArgumentException("Unrecognized static method name: " + staticMethodName);
+    }
+    return equivalentInstanceMethodName;
+  }
+
+  private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStaticMethod(
+      ExecutableElement staticMethod) {
+    boolean memoize = memoizeStaticMethodFromArguments(staticMethod);
+    String staticMethodName = staticMethod.getSimpleName().toString();
+
+    String equivalentInstanceMethodName =
+        getInstanceMethodNameFromStaticMethodName(staticMethodName);
+
+    MethodSpec.Builder methodSpecBuilder =
+        MethodSpec.methodBuilder(staticMethodName)
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
+        .returns(glideOptionsName);
+
+    List<? extends VariableElement> parameters = staticMethod.getParameters();
+    String createNewOptionAndCall = "new $T().$N(";
+    if (!parameters.isEmpty()) {
+      for (VariableElement parameter : parameters) {
+        methodSpecBuilder.addParameter(getParameterSpec(parameter));
+        createNewOptionAndCall += parameter.getSimpleName().toString();
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall += ".getApplicationContext()";
+        }
+        createNewOptionAndCall += ", ";
+      }
+      createNewOptionAndCall =
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
+    }
+    createNewOptionAndCall += ")";
+
+    FieldSpec requiredStaticField = null;
+    if (memoize) {
+      // Generates code that looks like:
+      // if (GlideOptions.<methodName> == null) {
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
+      // }
+
+      // Mix in an incrementing unique id to handle method overloading.
+      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
+          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+          .build();
+      methodSpecBuilder.beginControlFlow(
+          "if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName, staticVariableName, glideOptionsName, equivalentInstanceMethodName,
+              "autoClone()")
+          .endControlFlow()
+          .addStatement("return $T.$N", glideOptionsName, staticVariableName);
+    } else {
+      // Generates code that looks like:
+      // return new GlideOptions().<methodName>()
+      methodSpecBuilder.addStatement(
+          "return " + createNewOptionAndCall, glideOptionsName, equivalentInstanceMethodName);
+    }
+
+    List<? extends TypeParameterElement> typeParameters = staticMethod.getTypeParameters();
+    for (TypeParameterElement typeParameterElement : typeParameters) {
+      methodSpecBuilder.addTypeVariable(
+          TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
+    }
+
+    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
+
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
+  }
+
+  private static boolean memoizeStaticMethodFromArguments(ExecutableElement staticMethod) {
+    return staticMethod.getParameters().isEmpty()
+        || (staticMethod.getParameters().size() == 1
+        && staticMethod.getParameters().get(0).getSimpleName().toString()
+        .equals("android.content.Context"));
+  }
+
+  private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
+      ExecutableElement instanceMethod) {
     boolean skipStaticMethod = skipStaticMethod(instanceMethod);
     if (skipStaticMethod) {
       return new MethodAndStaticVar();
@@ -257,7 +441,7 @@ private MethodAndStaticVar generateStaticMethodEquivalent(ExecutableElement inst
         staticMethodName = instanceMethodName + "Of";
       }
     }
-    boolean memoize = memoizeStaticMethod(instanceMethod);
+    boolean memoize = memoizeStaticMethodFromAnnotation(instanceMethod);
 
     MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
         .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
@@ -265,14 +449,16 @@ private MethodAndStaticVar generateStaticMethodEquivalent(ExecutableElement inst
         .returns(glideOptionsName);
 
     List<? extends VariableElement> parameters = instanceMethod.getParameters();
-    if (ignoreFirst) {
-      if (parameters.isEmpty()) {
-        throw new IllegalArgumentException(
-            "Expected non-empty parameters for: " + instanceMethod);
-      }
-      // Remove is not supported.
-      parameters = parameters.subList(1, parameters.size());
+
+    // Always remove the first parameter because it's always RequestOptions in extensions. The
+    // actual method we want to generate will pass the RequestOptions in to the extension method,
+    // but should not itself require a RequestOptions object to be passed in.
+    if (parameters.isEmpty()) {
+      throw new IllegalArgumentException(
+          "Expected non-empty parameters for: " + instanceMethod);
     }
+    // Remove is not supported.
+    parameters = parameters.subList(1, parameters.size());
 
     String createNewOptionAndCall = "new $T().$L(";
     if (!parameters.isEmpty()) {
@@ -293,7 +479,7 @@ private MethodAndStaticVar generateStaticMethodEquivalent(ExecutableElement inst
     FieldSpec requiredStaticField = null;
     if (memoize) {
       // if (GlideOptions.<methodName> == null) {
-      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoLock()
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
       // }
 
       // Mix in an incrementing unique id to handle method overloading.
@@ -320,6 +506,8 @@ private MethodAndStaticVar generateStaticMethodEquivalent(ExecutableElement inst
           TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
     }
 
+    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());
+
     return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
   }
 
@@ -328,13 +516,13 @@ private boolean isAndroidContext(VariableElement variableElement) {
     return element.toString().equals("android.content.Context");
   }
 
-  private boolean isMethodInBaseRequestOptions(ExecutableElement toFind) {
+  private boolean isMethodInRequestOptions(ExecutableElement toFind) {
     // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
     // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
     // first type.
     List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
     String toFindSimpleName = toFind.getSimpleName().toString();
-    for (Element element : baseRequestOptionsType.getEnclosedElements()) {
+    for (Element element : requestOptionsType.getEnclosedElements()) {
       if (element.getKind() != ElementKind.METHOD) {
         continue;
       }
@@ -382,7 +570,7 @@ private static String getStaticMethodName(ExecutableElement element) {
     return Strings.emptyToNull(result);
   }
 
-  private static boolean memoizeStaticMethod(ExecutableElement element) {
+  private static boolean memoizeStaticMethodFromAnnotation(ExecutableElement element) {
     GlideOption glideOption =
         element.getAnnotation(GlideOption.class);
     return glideOption != null && glideOption.memoizeStaticMethod();
@@ -413,4 +601,43 @@ private static boolean skipStaticMethod(ExecutableElement element) {
       this.staticField = staticField;
     }
   }
+
+  private static final class MethodSignature {
+    private final TypeName returnType;
+    private final List<TypeName> parameterTypes;
+    private final Set<Modifier> modifiers;
+    private final String name;
+
+    MethodSignature(MethodSpec spec) {
+      name = spec.name;
+      modifiers = spec.modifiers;
+      returnType = spec.returnType;
+      parameterTypes =
+          Lists.transform(spec.parameters, new Function<ParameterSpec, TypeName>() {
+            @Nullable
+            @Override
+            public TypeName apply(ParameterSpec parameterSpec) {
+              return parameterSpec.type;
+
+            }
+          });
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof MethodSignature) {
+        MethodSignature other = (MethodSignature) o;
+        return name.equals(other.name)
+            && returnType.equals(other.returnType)
+            && parameterTypes.equals(other.parameterTypes)
+            && modifiers.equals(other.modifiers);
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hashCode(name, returnType, parameterTypes, modifiers);
+    }
+  }
 }
diff --git a/annotation/gradle.properties b/annotation/gradle.properties
index d43789528..ab55616cf 100644
--- a/annotation/gradle.properties
+++ b/annotation/gradle.properties
@@ -2,4 +2,3 @@ POM_NAME=Glide Annotations
 POM_ARTIFACT_ID=annotations
 POM_PACKAGING=jar
 POM_DESCRIPTION=A set of annotations for configuring Glide.
-GROUP=com.github.bumptech.glide.annotation
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
index 690b8f727..679eb8bce 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -6,7 +6,7 @@
 import java.lang.annotation.Target;
 
 /**
- * Identifies AppGlideModules and ChildeGlideModules for Glide's annotation processor to merge at
+ * Identifies AppGlideModules and LibraryGlideModules for Glide's annotation processor to merge at
  * compile time.
  *
  * <p>Replaces <meta-data /> tags in AndroidManifest.xml.
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
index 6a9bb4ff4..50bfbecb0 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
@@ -7,10 +7,10 @@
 
 /**
  * Identifies methods in {@link GlideExtension} annotated classes that extend
- * {@link com.bumptech.glide.request.BaseRequestOptions}.
+ * {@link com.bumptech.glide.request.RequestOptions}.
  *
  * <p>All annotated methods will be added to a single
- * {@link com.bumptech.glide.request.BaseRequestOptions} implementation generated per application.
+ * {@link com.bumptech.glide.request.RequestOptions} implementation generated per application.
  * Overlapping method names in different extensions may cause errors at compile time.
  *
  * <p>Static equivalents of annotated methods will also be generated.
@@ -51,7 +51,7 @@
 
   /**
    * {@code true} to indicate that it's safe to statically memoize the result of this method using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#autoClone()}.
+   * {@link com.bumptech.glide.request.RequestOptions#autoClone()}.
    *
    * <p>This method should only be used for no-arg methods where there's only a single possible
    * value.
@@ -66,7 +66,7 @@
    * <p>By default static methods are generated for all methods annotated with
    * {@link GlideOption}. These static factory methods allow for a cleaner API when used
    * with {@link com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
-   * simply creates a new {@link com.bumptech.glide.request.BaseRequestOptions} object, calls the
+   * simply creates a new {@link com.bumptech.glide.request.RequestOptions} object, calls the
    * instance version of the method on it and returns it. For example:
    * <pre>
    * <code>
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
index 45de3e37e..f0c19a599 100644
--- a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
@@ -22,7 +22,7 @@
  * with {@link GlideExtension}.
  *
  * <p>Methods annotated with GlideType must have a single parameter. The type of the
- * single parameter must be {@link com.bumptech.glide.request.BaseRequestOptions}, with a type
+ * single parameter must be {@link com.bumptech.glide.request.RequestOptions}, with a type
  * matching the value of {@link #value()}.
  */
 @Target(ElementType.METHOD)
@@ -33,7 +33,7 @@
   /**
    * A Resource class name, like GifDrawable.class, Bitmap.class etc.
    *
-   * <p>Must match the type of the {@link com.bumptech.glide.request.BaseRequestOptions} parameter.
+   * <p>Must match the type of the {@link com.bumptech.glide.request.RequestOptions} parameter.
    */
   Class<?> value();
 }
diff --git a/build.gradle b/build.gradle
index de9f3c9d1..3d157c29f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -34,6 +34,9 @@ subprojects { project ->
         maven {
             url "https://oss.sonatype.org/content/repositories/snapshots"
         }
+        maven {
+            url "https://maven.google.com"
+        }
     }
 
     apply plugin: 'checkstyle'
@@ -67,14 +70,10 @@ subprojects { project ->
             options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
         }
     }
-
-    // We generate a combined javadoc, no need to create javadocs for each library independently.
-    if (!project.name.equals('glide')) {
-        tasks.withType(Javadoc).all { enabled = false }
-    }
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.9'
-    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
+    gradleVersion = '4.1'
+    distributionType = Wrapper.DistributionType.ALL
 }
+
diff --git a/checkstyle.xml b/checkstyle.xml
index b5285c17f..ec3f4a74d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -69,7 +69,10 @@
         <module name="StaticVariableName" />
         <module name="TypeName" />
 
-        <module name="TrailingComment" />
+        <!-- Allow common trailing comments used to describe suppressions -->
+        <module name="TrailingComment">
+          <property name="legalComment" value="Public API" />
+        </module>
 
         <!-- Checks for imports. -->
         <!-- See http://checkstyle.sourceforge.net/config_imports.html -->
@@ -124,7 +127,9 @@
 
         <!-- Checks for blocks. -->
         <!-- See http://checkstyle.sourceforge.net/config_blocks.html -->
-        <module name="AvoidNestedBlocks" />
+        <module name="AvoidNestedBlocks">
+          <property name="allowInSwitchCase" value="true" />
+        </module>
         <module name="EmptyBlock" >
             <property name="option" value="text"/>
         </module>
diff --git a/glide/build.gradle b/glide/build.gradle
index 4e8216ad8..8a1ac2bff 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -16,7 +16,8 @@ static def getAndroidPathsForJavadoc() {
             ':integration:okhttp',
             ':integration:okhttp3',
             ':integration:volley',
-            ':integration:gifencoder'
+            ':integration:gifencoder',
+            ':integration:recyclerview'
     ]
 }
 
diff --git a/gradle.properties b/gradle.properties
index 609cc1234..52718a675 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,9 +1,9 @@
 org.gradle.daemon=true
 org.gradle.configureondemand=true
 
-VERSION_NAME=4.0.0-SNAPSHOT
+VERSION_NAME=4.2.0-SNAPSHOT
 VERSION_MAJOR=4
-VERSION_MINOR=0
+VERSION_MINOR=2
 VERSION_PATCH=0
 GROUP=com.github.bumptech.glide
 
@@ -15,11 +15,11 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
-SUPPORT_V4_VERSION=25.3.1
-SUPPORT_V7_VERSION=25.3.1
+ANDROID_SUPPORT_VERSION=26.0.2
 VOLLEY_VERSION=1.0.0
-OK_HTTP_VERSION=3.0.1
+OK_HTTP_VERSION=3.9.0
 ANDROID_GRADLE_VERSION=2.3.0
+DAGGER_VERSION=2.11
 
 COVERALLS_GRADLE_VERSION=2.4.0
 JUNIT_VERSION=4.12
@@ -31,9 +31,9 @@ TRUTH_VERSION=0.26
 FINDBUGS_VERSION=3.0.0
 JACOCO_VERSION=0.7.1.201405082137
 
-COMPILE_SDK_VERSION=25
-BUILD_TOOLS_VERSION=25.0.2
-TARGET_SDK_VERSION=25
+COMPILE_SDK_VERSION=26
+BUILD_TOOLS_VERSION=26.0.1
+TARGET_SDK_VERSION=26
 MIN_SDK_VERSION=14
 
-org.gradle.jvmargs=-Xmx2048M
\ No newline at end of file
+org.gradle.jvmargs=-Xmx2048M
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 941144813..7a3265ee9 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 06cc66097..bf1b63c34 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Fri Mar 31 22:27:21 PDT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
diff --git a/gradlew b/gradlew
index 9d82f7891..cccdd3d51 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >/dev/null
-APP_HOME="`pwd -P`"
-cd "$SAVED" >/dev/null
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -150,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
index aec99730b..e95643d6a 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,10 +46,9 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index 7219f4ffa..3ef29e0f6 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -8,7 +8,7 @@ dependencies {
     testCompile "junit:junit:${JUNIT_VERSION}"
     testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index c01164e2e..dcce0013f 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -5,6 +5,7 @@ dependencies {
     annotationProcessor project(':annotation:compiler')
 
     compile "com.squareup.okhttp:okhttp:2.7.1"
+    compile "com.android.support:support-annotations:{$ANDROID_SUPPORT_VERSION}"
 }
 
 android {
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index 9301703b6..36a47491f 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.module.GlideModule;
 import java.io.InputStream;
 
 /**
@@ -19,14 +19,14 @@
  * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule.
  */
 @Deprecated
-public class OkHttpGlideModule implements GlideModule {
+public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
     // Do nothing.
   }
 
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
   }
 }
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
index 5a46639f9..bc81dabc0 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -14,11 +15,14 @@
  * <p>For Applications that depend on this library and include an
  * {@link AppGlideModule} and Glide's annotation processor, this class
  * will be automatically included.
+ *
+ * @deprecated Prefer the okhttp3 version instead.
  */
 @GlideModule
+@Deprecated
 public class OkHttpLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
   }
 }
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 2b1f90a78..936f95f81 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -1,8 +1,10 @@
 package com.bumptech.glide.integration.okhttp;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.HttpException;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
@@ -57,10 +59,10 @@ public void onResponse(Response response) throws IOException {
         if (response.isSuccessful()) {
           long contentLength = responseBody.contentLength();
           stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
-        } else if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
+          callback.onDataReady(stream);
+        } else {
+          callback.onLoadFailed(new HttpException(response.message(), response.code()));
         }
-        callback.onDataReady(stream);
       }
     });
   }
@@ -88,11 +90,13 @@ public void cancel() {
     // TODO: call cancel on the client when this method is called on a background thread. See #257
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.REMOTE;
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
index 59a222795..5290c6a42 100644
--- a/integration/okhttp3/build.gradle
+++ b/integration/okhttp3/build.gradle
@@ -5,6 +5,7 @@ dependencies {
     annotationProcessor project(':annotation:compiler')
 
     compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
index 1c05bf678..60517251f 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.module.GlideModule;
 import java.io.InputStream;
 
 /**
@@ -20,14 +20,14 @@
  * annotations.
  */
 @Deprecated
-public class OkHttpGlideModule implements GlideModule {
+public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
     // Do nothing.
   }
 
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
   }
 }
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
index 911b5acac..74eace9eb 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -18,7 +19,7 @@
 @GlideModule
 public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
   }
 }
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
index 61adb97b1..a0b0faaef 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -1,8 +1,11 @@
 package com.bumptech.glide.integration.okhttp3;
 
+import android.os.Build;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.HttpException;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.util.ContentLengthInputStream;
@@ -18,13 +21,15 @@
 /**
  * Fetches an {@link InputStream} using the okhttp library.
  */
-public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
+public class OkHttpStreamFetcher implements DataFetcher<InputStream>,
+ okhttp3.Callback {
   private static final String TAG = "OkHttpFetcher";
   private final Call.Factory client;
   private final GlideUrl url;
   @Synthetic InputStream stream;
   @Synthetic ResponseBody responseBody;
   private volatile Call call;
+  private DataCallback<? super InputStream> callback;
 
   public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
     this.client = client;
@@ -39,29 +44,45 @@ public void loadData(Priority priority, final DataCallback<? super InputStream>
       requestBuilder.addHeader(key, headerEntry.getValue());
     }
     Request request = requestBuilder.build();
+    this.callback = callback;
 
     call = client.newCall(request);
-    call.enqueue(new okhttp3.Callback() {
-      @Override
-      public void onFailure(Call call, IOException e) {
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "OkHttp failed to obtain result", e);
-        }
-        callback.onLoadFailed(e);
+    if (Build.VERSION.SDK_INT != Build.VERSION_CODES.O) {
+      call.enqueue(this);
+    } else {
+      try {
+        // Calling execute instead of enqueue is a workaround for #2355, where okhttp throws a
+        // ClassCastException on O.
+        onResponse(call, call.execute());
+      } catch (IOException e) {
+        onFailure(call, e);
+      } catch (ClassCastException e) {
+        // It's not clear that this catch is necessary, the error may only occur even on O if
+        // enqueue is used.
+        onFailure(call, new IOException("Workaround for framework bug on O", e));
       }
+    }
+  }
 
-      @Override
-      public void onResponse(Call call, Response response) throws IOException {
-        responseBody = response.body();
-        if (response.isSuccessful()) {
-          long contentLength = responseBody.contentLength();
-          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
-        } else if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
-        }
-        callback.onDataReady(stream);
-      }
-    });
+  @Override
+  public void onFailure(Call call, IOException e) {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "OkHttp failed to obtain result", e);
+    }
+
+    callback.onLoadFailed(e);
+  }
+
+  @Override
+  public void onResponse(Call call, Response response) throws IOException {
+    responseBody = response.body();
+    if (response.isSuccessful()) {
+      long contentLength = responseBody.contentLength();
+      stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
+      callback.onDataReady(stream);
+    } else {
+      callback.onLoadFailed(new HttpException(response.message(), response.code()));
+    }
   }
 
   @Override
@@ -76,6 +97,7 @@ public void cleanup() {
     if (responseBody != null) {
       responseBody.close();
     }
+    callback = null;
   }
 
   @Override
@@ -86,11 +108,13 @@ public void cancel() {
     }
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.REMOTE;
diff --git a/integration/recyclerview/build.gradle b/integration/recyclerview/build.gradle
index 498808a55..24eb09e46 100644
--- a/integration/recyclerview/build.gradle
+++ b/integration/recyclerview/build.gradle
@@ -2,8 +2,8 @@ apply plugin: 'com.android.library'
 
 dependencies {
     compile project(':library')
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    provided "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index 8f04a9b1a..b4c5a53ff 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -3,6 +3,7 @@ apply plugin: 'com.android.library'
 dependencies {
     compile project(':library')
     compile "com.android.volley:volley:${VOLLEY_VERSION}"
+    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 
     testCompile project(":testutil")
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
index 669e7b732..52899e89a 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -1,10 +1,10 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
-import com.bumptech.glide.module.GlideModule;
 import java.io.InputStream;
 
 /**
@@ -19,14 +19,15 @@
  * @deprecated Replaced with {@link VolleyLibraryGlideModule}.
  */
 @Deprecated
-public class VolleyGlideModule implements GlideModule {
+@SuppressWarnings("deprecation")
+public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
     // Do nothing.
   }
 
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
   }
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
index 22f12df4e..6fa56468c 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.integration.volley;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -20,7 +21,7 @@
 @GlideModule
 public class VolleyLibraryGlideModule extends LibraryGlideModule {
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
   }
 }
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
index f0b4340fa..3a4e17415 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.volley;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.android.volley.AuthFailureError;
 import com.android.volley.NetworkResponse;
@@ -67,11 +68,13 @@ public void cancel() {
     }
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.REMOTE;
diff --git a/library/build.gradle b/library/build.gradle
index bcef2c2bb..52b79d6af 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -19,8 +19,8 @@ dependencies {
     compile project(':third_party:gif_decoder')
     compile project(':third_party:disklrucache')
     compile project(':annotation')
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-
+    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
+    provided "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
     testCompile project(':testutil')
     testCompile 'com.google.guava:guava-testlib:18.0'
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
@@ -28,7 +28,7 @@ dependencies {
     testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
     testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
 }
 
 android.testOptions.unitTests.all {
@@ -66,6 +66,10 @@ android {
 }
 
 afterEvaluate {
+    if (tasks.findByName("assembleDebug") == null) {
+        return
+    }
+
     task findbugs(type: FindBugs, dependsOn: assembleDebug) {
 
         description 'Run findbugs'
@@ -111,9 +115,9 @@ afterEvaluate {
 
     check.dependsOn('pmd')
 
-   task jacocoTestReport(type: JacocoReport, dependsOn: testDebugUnitTest) {
-       def coverageSourceDirs = ['src/main/java']
-       group = "Reporting"
+    task jacocoTestReport(type: JacocoReport, dependsOn: testDebugUnitTest) {
+        def coverageSourceDirs = ['src/main/java']
+        group = "Reporting"
         description = "Generate Jacoco coverage reports"
 
         classDirectories = fileTree(
diff --git a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
index 1c852b961..853990ec2 100644
--- a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
@@ -7,11 +7,11 @@
 import java.util.Set;
 
 /**
- * A temporary interface to allow {@link AppGlideModule}s to exclude
- * {@link com.bumptech.glide.annotation.GlideModule}s to ease the migration from
- * {@link com.bumptech.glide.annotation.GlideModule}s to Glide's annotation processing system.
+ * Allows {@link AppGlideModule}s to exclude {@link com.bumptech.glide.annotation.GlideModule}s to
+ * ease the migration from {@link com.bumptech.glide.annotation.GlideModule}s to Glide's annotation
+ * processing system and optionally provides a
+ * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} impl.
  */
-@Deprecated
 abstract class GeneratedAppGlideModule extends AppGlideModule {
   /**
    * This method can be removed when manifest parsing is no longer supported.
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index a6ef96c89..096c5643a 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -80,6 +80,7 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 /**
@@ -92,6 +93,7 @@
   private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
   private static final String TAG = "Glide";
   private static volatile Glide glide;
+  private static volatile boolean isInitializing;
 
   private final Engine engine;
   private final BitmapPool bitmapPool;
@@ -151,7 +153,7 @@ public static Glide get(Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
-          initGlide(context);
+          checkAndInitializeGlide(context);
         }
       }
     }
@@ -159,18 +161,30 @@ public static Glide get(Context context) {
     return glide;
   }
 
+  private static void checkAndInitializeGlide(Context context) {
+    // In the thread running initGlide(), one or more classes may call Glide.get(context).
+    // Without this check, those calls could trigger infinite recursion.
+    if (isInitializing) {
+      throw new IllegalStateException("You cannot call Glide.get() in registerComponents(),"
+          + " use the provided Glide instance instead");
+    }
+    isInitializing = true;
+    initializeGlide(context);
+    isInitializing = false;
+  }
+
   @VisibleForTesting
-  public static void init(Glide glide) {
+  public static synchronized void init(Glide glide) {
     Glide.glide = glide;
   }
 
   @VisibleForTesting
-  public static void tearDown() {
+  public static synchronized void tearDown() {
     glide = null;
   }
 
   @SuppressWarnings("deprecation")
-  private static void initGlide(Context context) {
+  private static void initializeGlide(Context context) {
     Context applicationContext = context.getApplicationContext();
 
     GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
@@ -212,17 +226,19 @@ private static void initGlide(Context context) {
     if (annotationGeneratedModule != null) {
       annotationGeneratedModule.applyOptions(applicationContext, builder);
     }
-    glide = builder.build(applicationContext);
+    Glide glide = builder.build(applicationContext);
     for (GlideModule module : manifestModules) {
-      module.registerComponents(applicationContext, glide.registry);
+      module.registerComponents(applicationContext, glide, glide.registry);
     }
     if (annotationGeneratedModule != null) {
-      annotationGeneratedModule.registerComponents(applicationContext, glide.registry);
+      annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
     }
+    context.getApplicationContext().registerComponentCallbacks(glide);
+    Glide.glide = glide;
   }
 
   @Nullable
-  @SuppressWarnings({"unchecked", "deprecation"})
+  @SuppressWarnings({"unchecked", "deprecation", "TryWithIdenticalCatches"})
   private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
     GeneratedAppGlideModule result = null;
     try {
@@ -241,6 +257,7 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
       throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
           + " If you've manually implemented this class, remove your implementation. The Annotation"
           + " processor will generate a correct implementation.", e);
+      // These exceptions can't be squashed across all versions of Android.
     } catch (IllegalAccessException e) {
       throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
           + " If you've manually implemented this class, remove your implementation. The Annotation"
@@ -259,7 +276,8 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
       RequestManagerRetriever requestManagerRetriever,
       ConnectivityMonitorFactory connectivityMonitorFactory,
       int logLevel,
-      RequestOptions defaultRequestOptions) {
+      RequestOptions defaultRequestOptions,
+      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
@@ -280,39 +298,44 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
     ByteBufferGifDecoder byteBufferGifDecoder =
         new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
 
-    registry.register(ByteBuffer.class, new ByteBufferEncoder())
-        .register(InputStream.class, new StreamEncoder(arrayPool))
+    registry
+        .append(ByteBuffer.class, new ByteBufferEncoder())
+        .append(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
-        .append(ByteBuffer.class, Bitmap.class,
+        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class,
             new ByteBufferBitmapDecoder(downsampler))
-        .append(InputStream.class, Bitmap.class,
+        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class,
             new StreamBitmapDecoder(downsampler, arrayPool))
-        .append(ParcelFileDescriptor.class, Bitmap.class, new VideoBitmapDecoder(bitmapPool))
-        .register(Bitmap.class, new BitmapEncoder())
+        .append(Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class,
+            new VideoBitmapDecoder(bitmapPool))
+        .append(Bitmap.class, new BitmapEncoder())
         /* GlideBitmapDrawables */
-        .append(ByteBuffer.class, BitmapDrawable.class,
+        .append(Registry.BUCKET_BITMAP_DRAWABLE, ByteBuffer.class, BitmapDrawable.class,
             new BitmapDrawableDecoder<>(resources, bitmapPool,
                 new ByteBufferBitmapDecoder(downsampler)))
-        .append(InputStream.class, BitmapDrawable.class,
+        .append(Registry.BUCKET_BITMAP_DRAWABLE, InputStream.class, BitmapDrawable.class,
             new BitmapDrawableDecoder<>(resources, bitmapPool,
                 new StreamBitmapDecoder(downsampler, arrayPool)))
-        .append(ParcelFileDescriptor.class, BitmapDrawable.class,
+        .append(Registry.BUCKET_BITMAP_DRAWABLE, ParcelFileDescriptor.class, BitmapDrawable.class,
             new BitmapDrawableDecoder<>(resources, bitmapPool, new VideoBitmapDecoder(bitmapPool)))
-        .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
+        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
         /* GIFs */
-        .prepend(InputStream.class, GifDrawable.class,
+        .append(Registry.BUCKET_GIF, InputStream.class, GifDrawable.class,
             new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
-        .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
-        .register(GifDrawable.class, new GifDrawableEncoder())
+        .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
+        .append(GifDrawable.class, new GifDrawableEncoder())
         /* GIF Frames */
+        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
         .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
-        .append(GifDecoder.class, Bitmap.class, new GifFrameResourceDecoder(bitmapPool))
+        .append(Registry.BUCKET_BITMAP, GifDecoder.class, Bitmap.class,
+            new GifFrameResourceDecoder(bitmapPool))
         /* Files */
         .register(new ByteBufferRewinder.Factory())
         .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory())
         .append(File.class, InputStream.class, new FileLoader.StreamFactory())
         .append(File.class, File.class, new FileDecoder())
         .append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory())
+        // Compilation with Gradle requires the type to be specified for UnitModelLoader here.
         .append(File.class, File.class, new UnitModelLoader.Factory<File>())
         /* Models */
         .register(new InputStreamRewinder.Factory(arrayPool))
@@ -356,8 +379,10 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
 
     ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
-    glideContext = new GlideContext(context, registry, imageViewTargetFactory,
-        defaultRequestOptions, engine, this, logLevel);
+    glideContext =
+        new GlideContext(
+            context, registry, imageViewTargetFactory, defaultRequestOptions,
+            defaultTransitionOptions, engine, logLevel);
   }
 
   /**
@@ -467,6 +492,7 @@ public void trimMemory(int level) {
    *     This method should always be called on a background thread, since it is a blocking call.
    * </p>
    */
+  @SuppressWarnings("unused") // Public API
   public void clearDiskCache() {
     Util.assertBackgroundThread();
     engine.clearDiskCache();
@@ -507,6 +533,7 @@ private static RequestManagerRetriever getRetriever(@Nullable Context context) {
     // Context could be null for other reasons (ie the user passes in null), but in practice it will
     // only occur due to errors with the Fragment lifecycle.
     Preconditions.checkNotNull(
+        context,
         "You cannot start a load on a not yet attached View or a  Fragment where getActivity() "
             + "returns null (which usually occurs when getActivity() is called before the Fragment "
             + "is attached or after the Fragment is destroyed).");
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 2b27e2175..e77742fcb 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -1,12 +1,15 @@
 package com.bumptech.glide;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.v4.util.ArrayMap;
 import android.util.Log;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
@@ -20,11 +23,13 @@
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;
 import com.bumptech.glide.request.RequestOptions;
+import java.util.Map;
 
 /**
  * A builder class for setting default structural classes for Glide to use.
  */
 public final class GlideBuilder {
+  private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions = new ArrayMap<>();
   private Engine engine;
   private BitmapPool bitmapPool;
   private ArrayPool arrayPool;
@@ -146,7 +151,7 @@ public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
    * <p>Applying additional options with {@link
-   * RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions)} will override defaults
+   * RequestBuilder#apply(RequestOptions)} will override defaults
    * set here.
    *
    * @param requestOptions The options to use by default.
@@ -157,6 +162,28 @@ public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
     return this;
   }
 
+  /**
+   * Sets the default {@link TransitionOptions} to use when starting a request that will load a
+   * resource with the given {@link Class}.
+   *
+   * <p>It's preferable but not required for the requested resource class to match the resource
+   * class applied here as long as the resource class applied here is assignable from the requested
+   * resource class. For example you can set a default transition for
+   * {@link android.graphics.drawable.Drawable} and that default transition will be used if you
+   * subsequently start requests for specific {@link android.graphics.drawable.Drawable} types like
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} or
+   * {@link android.graphics.drawable.BitmapDrawable}. Specific types are always preferred so if you
+   * register a default transition for both {@link android.graphics.drawable.Drawable} and
+   * {@link android.graphics.drawable.BitmapDrawable} and then start a request for
+   * {@link android.graphics.drawable.BitmapDrawable}s, the transition you registered for
+   * {@link android.graphics.drawable.BitmapDrawable}s will be used.
+   */
+  public <T> GlideBuilder setDefaultTransitionOptions(
+      @NonNull Class<T> clazz, @Nullable TransitionOptions<?, T> options) {
+    defaultTransitionOptions.put(clazz, options);
+    return this;
+  }
+
   /**
    * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all
    * the default decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link
@@ -172,7 +199,7 @@ public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {
    */
   @Deprecated
   public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
-    defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));
+    defaultRequestOptions = defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));
     return this;
   }
 
@@ -282,7 +309,11 @@ public Glide build(Context context) {
 
     if (bitmapPool == null) {
       int size = memorySizeCalculator.getBitmapPoolSize();
-      bitmapPool = new LruBitmapPool(size);
+      if (size > 0) {
+        bitmapPool = new LruBitmapPool(size);
+      } else {
+        bitmapPool = new BitmapPoolAdapter();
+      }
     }
 
     if (arrayPool == null) {
@@ -314,6 +345,7 @@ public Glide build(Context context) {
         requestManagerRetriever,
         connectivityMonitorFactory,
         logLevel,
-        defaultRequestOptions.lock());
+        defaultRequestOptions.lock(),
+        defaultTransitionOptions);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/GlideContext.java b/library/src/main/java/com/bumptech/glide/GlideContext.java
index ebf5f06fd..1e0aa58ab 100644
--- a/library/src/main/java/com/bumptech/glide/GlideContext.java
+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java
@@ -1,42 +1,48 @@
 package com.bumptech.glide;
 
 import android.annotation.TargetApi;
-import android.content.ComponentCallbacks2;
 import android.content.Context;
 import android.content.ContextWrapper;
-import android.content.res.Configuration;
 import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
 import android.widget.ImageView;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
 import com.bumptech.glide.request.target.Target;
+import java.util.Map;
+import java.util.Map.Entry;
 
 /**
  * Global context for all loads in Glide containing and exposing the various registries and classes
  * required to load resources.
  */
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-public class GlideContext extends ContextWrapper implements ComponentCallbacks2 {
+public class GlideContext extends ContextWrapper {
+  @VisibleForTesting
+  static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =
+      new GenericTransitionOptions<Object>();
   private final Handler mainHandler;
   private final Registry registry;
   private final ImageViewTargetFactory imageViewTargetFactory;
   private final RequestOptions defaultRequestOptions;
+  private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions;
   private final Engine engine;
-  private final ComponentCallbacks2 componentCallbacks;
   private final int logLevel;
 
   public GlideContext(Context context, Registry registry,
       ImageViewTargetFactory imageViewTargetFactory, RequestOptions defaultRequestOptions,
-      Engine engine, ComponentCallbacks2 componentCallbacks, int logLevel) {
+      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions, Engine engine,
+      int logLevel) {
     super(context.getApplicationContext());
     this.registry = registry;
     this.imageViewTargetFactory = imageViewTargetFactory;
     this.defaultRequestOptions = defaultRequestOptions;
+    this.defaultTransitionOptions = defaultTransitionOptions;
     this.engine = engine;
-    this.componentCallbacks = componentCallbacks;
     this.logLevel = logLevel;
 
     mainHandler = new Handler(Looper.getMainLooper());
@@ -46,6 +52,23 @@ public RequestOptions getDefaultRequestOptions() {
     return defaultRequestOptions;
   }
 
+  @SuppressWarnings("unchecked")
+  @NonNull
+  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
+    TransitionOptions<?, ?> result = defaultTransitionOptions.get(transcodeClass);
+    if (result == null) {
+      for (Entry<Class<?>, TransitionOptions<?, ?>> value : defaultTransitionOptions.entrySet()) {
+        if (value.getKey().isAssignableFrom(transcodeClass)) {
+          result = value.getValue();
+        }
+      }
+    }
+    if (result == null) {
+      result = DEFAULT_TRANSITION_OPTIONS;
+    }
+    return (TransitionOptions<?, T>) result;
+  }
+
   public <X> Target<X> buildImageViewTarget(ImageView imageView, Class<X> transcodeClass) {
     return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
   }
@@ -65,19 +88,4 @@ public Registry getRegistry() {
   public int getLogLevel() {
     return logLevel;
   }
-
-  @Override
-  public void onTrimMemory(int level) {
-    componentCallbacks.onTrimMemory(level);
-  }
-
-  @Override
-  public void onConfigurationChanged(Configuration newConfig) {
-    componentCallbacks.onConfigurationChanged(newConfig);
-  }
-
-  @Override
-  public void onLowMemory() {
-    componentCallbacks.onLowMemory();
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index ddaae41d7..7aaa9d370 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.widget.AbsListView;
 import com.bumptech.glide.request.target.BaseTarget;
@@ -24,7 +25,6 @@
  * @param <T> The type of the model being displayed in the list.
  */
 public class ListPreloader<T> implements AbsListView.OnScrollListener {
-
   private final int maxPreload;
   private final PreloadTargetQueue preloadTargetQueue;
   private final RequestManager requestManager;
@@ -47,24 +47,44 @@
   public interface PreloadModelProvider<U> {
 
     /**
-     * Returns a non null list of all models that need to be loaded for the list to display adapter
-     * items in positions between {@code start} and {@code end}.
+     * Returns a {@link List} of models that need to be loaded for the list to display adapter items
+     * in positions between {@code start} and {@code end}.
+     *
+     * <p>A list of any size can be returned so there can be multiple models per adapter position.
      *
-     * <p> A list of any size can be returned so there can be multiple models per adapter position.
-     * </p>
+     * <p>Every model returned by this method is expected to produce a valid {@link RequestBuilder}
+     * in {@link #getPreloadRequestBuilder(Object)}. If that's not possible for any set of models,
+     * avoid including them in the {@link List} returned by this method.
+     *
+     * <p>Although it's acceptable for the returned {@link List} to contain {@code null} models,
+     * it's best to filter them from the list instead of adding {@code null} to avoid unnecessary
+     * logic and expanding the size of the {@link List}
      *
      * @param position The adapter position.
      */
+    @NonNull
     List<U> getPreloadItems(int position);
 
     /**
-     * Returns a non null {@link RequestBuilder} for a given item. Must exactly match the request
-     * used to load the resource in the list.
+     * Returns a {@link RequestBuilder} for a given item on which
+     * {@link RequestBuilder#load(Object)}} has been called or {@code null} if no valid load can be
+     * started.
+     *
+     * <p>For the preloader to be effective, the {@link RequestBuilder} returned here must use
+     * exactly the same size and set of options as the {@link RequestBuilder} used when the ``View``
+     * is bound. You may need to specify a size in both places to ensure that the width and height
+     * match exactly. If so, you can use
+     * {@link com.bumptech.glide.request.RequestOptions#override(int, int)} to do so.
      *
-     * <p> The target and context will be provided by the preloader. </p>
+     * <p>The target and context will be provided by the preloader.
+     *
+     * <p>If {@link RequestBuilder#load(Object)} is not called by this method, the preloader will
+     * trigger a {@link RuntimeException}. If you don't want to load a particular item or position,
+     * filter it from the list returned by {@link #getPreloadItems(int)}.
      *
      * @param item The model to load.
      */
+    @Nullable
     RequestBuilder getPreloadRequestBuilder(U item);
   }
 
@@ -80,8 +100,9 @@
      * Returns the size of the view in the list where the resources will be displayed in pixels in
      * the format [x, y], or {@code null} if no size is currently available.
      *
-     * <p> Note - The dimensions returned here must precisely match those of the view in the list.
-     * </p>
+     * <p>Note - The dimensions returned here must precisely match those of the view in the list.
+     *
+     * <p>If this method returns {@code null}, then no request will be started for the given item.
      *
      * @param item A model
      */
@@ -175,13 +196,22 @@ private void preloadAdapterPosition(List<T> items, int position, boolean isIncre
   }
 
   @SuppressWarnings("unchecked")
-  private void preloadItem(T item, int position, int i) {
-    final int[] dimensions = this.preloadDimensionProvider.getPreloadSize(item, position, i);
-    if (dimensions != null) {
-      RequestBuilder<Object> preloadRequestBuilder =
-          this.preloadModelProvider.getPreloadRequestBuilder(item);
-      preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
+  private void preloadItem(@Nullable T item, int position, int perItemPosition) {
+    if (item == null) {
+      return;
     }
+    int[] dimensions =
+        preloadDimensionProvider.getPreloadSize(item, position, perItemPosition);
+    if (dimensions == null) {
+      return;
+    }
+    RequestBuilder<Object> preloadRequestBuilder =
+        preloadModelProvider.getPreloadRequestBuilder(item);
+    if (preloadRequestBuilder == null) {
+      return;
+    }
+
+    preloadRequestBuilder.into(preloadTargetQueue.next(dimensions[0], dimensions[1]));
   }
 
   private void cancelAll() {
@@ -193,7 +223,7 @@ private void cancelAll() {
   private static final class PreloadTargetQueue {
     private final Queue<PreloadTarget> queue;
 
-    public PreloadTargetQueue(int size) {
+    PreloadTargetQueue(int size) {
       queue = Util.createQueue(size);
 
       for (int i = 0; i < size; i++) {
@@ -210,7 +240,7 @@ public PreloadTarget next(int width, int height) {
     }
   }
 
-  private static class PreloadTarget extends BaseTarget<Object> {
+  private static final class PreloadTarget extends BaseTarget<Object> {
     @Synthetic int photoHeight;
     @Synthetic int photoWidth;
 
@@ -226,5 +256,10 @@ public void onResourceReady(Object resource, Transition<? super Object> transiti
     public void getSize(SizeReadyCallback cb) {
       cb.onSizeReady(photoWidth, photoHeight);
     }
+
+    @Override
+    public void removeCallback(SizeReadyCallback cb) {
+      // Do nothing because we don't retain references to SizeReadyCallbacks.
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index 7468be5be..97ef93a87 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -3,6 +3,7 @@
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.load.Encoder;
 import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.data.DataRewinder;
@@ -23,13 +24,21 @@
 import com.bumptech.glide.provider.ResourceEncoderRegistry;
 import com.bumptech.glide.util.pool.FactoryPools;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 /**
- * Manages component registration.
+ * Manages component registration to extend or replace Glide's default loading, decoding, and
+ * encoding logic.
  */
 public class Registry {
+  public static final String BUCKET_GIF = "Gif";
+  public static final String BUCKET_BITMAP = "Bitmap";
+  public static final String BUCKET_BITMAP_DRAWABLE = "BitmapDrawable";
+  private static final String BUCKET_PREPEND_ALL = "legacy_prepend_all";
+  private static final String BUCKET_APPEND_ALL = "legacy_append";
+
   private final ModelLoaderRegistry modelLoaderRegistry;
   private final EncoderRegistry encoderRegistry;
   private final ResourceDecoderRegistry decoderRegistry;
@@ -51,62 +60,323 @@ public Registry() {
     this.dataRewinderRegistry = new DataRewinderRegistry();
     this.transcoderRegistry = new TranscoderRegistry();
     this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();
+    setResourceDecoderBucketPriorityList(
+        Arrays.asList(BUCKET_GIF, BUCKET_BITMAP, BUCKET_BITMAP_DRAWABLE));
   }
 
+  /**
+   * Registers the given {@link Encoder} for the given data class (InputStream, FileDescriptor etc).
+   *
+   * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
+   * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
+   * {@link Encoder} being used for
+   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
+   * {@link java.io.FileInputStream} and any other subclass.
+   *
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
+   * {@link Encoder} that is registered first will be used.
+   *
+   * @deprecated Use the equivalent {@link #append(Class, Class, ModelLoaderFactory)} method
+   * instead.
+   */
+  @Deprecated
   public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
-    encoderRegistry.add(dataClass, encoder);
+    return append(dataClass, encoder);
+  }
+
+  /**
+   * Appends the given {@link Encoder} onto the list of available {@link Encoder}s so that it is
+   * attempted after all earlier and default {@link Encoder}s for the given data class.
+   *
+   * <p>The {@link Encoder} will be used both for the exact data class and any subtypes. For
+   * example, registering an {@link Encoder} for {@link java.io.InputStream} will result in the
+   * {@link Encoder} being used for
+   * {@link android.content.res.AssetFileDescriptor.AutoCloseInputStream},
+   * {@link java.io.FileInputStream} and any other subclass.
+   *
+   * <p>If multiple {@link Encoder}s are registered for the same type or super type, the
+   * {@link Encoder} that is registered first will be used.
+   *
+   * @see #prepend(Class, Encoder)
+   */
+  public <Data> Registry append(Class<Data> dataClass, Encoder<Data> encoder) {
+    encoderRegistry.append(dataClass, encoder);
+    return this;
+  }
+
+  /**
+   * Prepends the given {@link Encoder} into the list of available {@link Encoder}s
+   * so that it is attempted before all later and default {@link Encoder}s for the given
+   * data class.
+   *
+   * <p>This method allows you to replace the default {@link Encoder} because it ensures
+   * the registered {@link Encoder} will run first. If multiple {@link Encoder}s are registered for
+   * the same type or super type, the {@link Encoder} that is registered first will be used.
+   *
+   * @see #append(Class, Encoder)
+   */
+  public <Data> Registry prepend(Class<Data> dataClass, Encoder<Data> encoder) {
+    encoderRegistry.prepend(dataClass, encoder);
+    return this;
+  }
+
+  /**
+   * Appends the given {@link ResourceDecoder} onto the list of all available
+   * {@link ResourceDecoder}s allowing it to be used if all earlier and default
+   * {@link ResourceDecoder}s for the given types fail (or there are none).
+   *
+   * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
+   * that your {@link ResourceDecoder} gets the chance to run before an existing
+   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
+   * best for new types of resources and data or as a way to add an additional fallback decoder
+   * for an existing type of data.
+   *
+   * @see #append(String, Class, Class, ResourceDecoder)
+   * @see #prepend(Class, Class, ResourceDecoder)
+   *
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  public <Data, TResource> Registry append(
+      Class<Data> dataClass,
+      Class<TResource> resourceClass,
+      ResourceDecoder<Data, TResource> decoder) {
+    append(BUCKET_APPEND_ALL, dataClass, resourceClass, decoder);
     return this;
   }
 
-  public <Data, TResource> Registry append(Class<Data> dataClass, Class<TResource> resourceClass,
+  /**
+   * Appends the given {@link ResourceDecoder} onto the list of available {@link ResourceDecoder}s
+   * in this bucket, allowing it to be used if all earlier and default {@link ResourceDecoder}s for
+   * the given types in this bucket fail (or there are none).
+   *
+   * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure
+   * that your {@link ResourceDecoder} gets the chance to run before an existing
+   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is
+   * best for new types of resources and data or as a way to add an additional fallback decoder
+   * for an existing type of data.
+   *
+   * @see #prepend(String, Class, Class, ResourceDecoder)
+   * @see #setResourceDecoderBucketPriorityList(List)
+   *
+   * @param bucket The bucket identifier to add this decoder to.
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  public <Data, TResource> Registry append(
+      String bucket,
+      Class<Data> dataClass,
+      Class<TResource> resourceClass,
       ResourceDecoder<Data, TResource> decoder) {
-    decoderRegistry.append(decoder, dataClass, resourceClass);
+    decoderRegistry.append(bucket, decoder, dataClass, resourceClass);
     return this;
   }
 
-  public <Data, TResource> Registry prepend(Class<Data> dataClass, Class<TResource> resourceClass,
+  /**
+   * Prepends the given {@link ResourceDecoder} into the list of all available
+   * {@link ResourceDecoder}s so that it is attempted before all later and default
+   * {@link ResourceDecoder}s for the given types.
+   *
+   * <p>This method allows you to replace the default {@link ResourceDecoder} because it ensures
+   * the registered {@link ResourceDecoder} will run first. You can use the
+   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
+   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
+   * types of data.
+   *
+   * @see #prepend(String, Class, Class, ResourceDecoder)
+   * @see #append(Class, Class, ResourceDecoder)
+   *
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  public <Data, TResource> Registry prepend(
+      Class<Data> dataClass,
+      Class<TResource> resourceClass,
       ResourceDecoder<Data, TResource> decoder) {
-    decoderRegistry.prepend(decoder, dataClass, resourceClass);
+    prepend(BUCKET_PREPEND_ALL, dataClass, resourceClass, decoder);
     return this;
   }
 
-  public <TResource> Registry register(Class<TResource> resourceClass,
-      ResourceEncoder<TResource> encoder) {
-    resourceEncoderRegistry.add(resourceClass, encoder);
+  /**
+   * Prepends the given {@link ResourceDecoder} into the list of available {@link ResourceDecoder}s
+   * in the same bucket so that it is attempted before all later and default
+   * {@link ResourceDecoder}s for the given types in that bucket.
+   *
+   * <p>This method allows you to replace the default {@link ResourceDecoder} for this bucket
+   * because it ensures the registered {@link ResourceDecoder} will run first. You can use the
+   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default
+   * {@link ResourceDecoder}s if you only want to change the default functionality for certain
+   * types of data.
+   *
+   * @see #append(String, Class, Class, ResourceDecoder)
+   * @see #setResourceDecoderBucketPriorityList(List)
+   *
+   * @param bucket The bucket identifier to add this decoder to.
+   * @param dataClass The data that will be decoded from
+   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc).
+   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
+   * @param decoder The {@link ResourceDecoder} to register.
+   */
+  public <Data, TResource> Registry prepend(
+      String bucket,
+      Class<Data> dataClass,
+      Class<TResource> resourceClass,
+      ResourceDecoder<Data, TResource> decoder) {
+    decoderRegistry.prepend(bucket, decoder, dataClass, resourceClass);
     return this;
   }
 
+  /**
+   * Overrides the default ordering of resource decoder buckets. You may also add custom buckets
+   * which are identified as a unique string. Glide will attempt to decode using decoders in the
+   * highest priority bucket before moving on to the next one.
+   *
+   * <p>The default order is [{@link #BUCKET_GIF}, {@link #BUCKET_BITMAP},
+   * {@link #BUCKET_BITMAP_DRAWABLE}].
+   *
+   * <p>When registering decoders, you can use these buckets to specify the ordering relative only
+   * to other decoders in that bucket.
+   * @see #append(String, Class, Class, ResourceDecoder)
+   * @see #prepend(String, Class, Class, ResourceDecoder)
+   *
+   * @param buckets The list of bucket identifiers in order from highest priority to least priority.
+   */
+  // Final to avoid a PMD error.
+  public final Registry setResourceDecoderBucketPriorityList(List<String> buckets) {
+    List<String> modifiedBuckets = new ArrayList<>(buckets);
+    modifiedBuckets.add(0, BUCKET_PREPEND_ALL);
+    modifiedBuckets.add(BUCKET_APPEND_ALL);
+    decoderRegistry.setBucketPriorityList(modifiedBuckets);
+    return this;
+  }
+
+  /**
+   * Appends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted after all earlier and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
+   * For example, registering an {@link ResourceEncoder} for
+   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
+   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   *
+   * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
+   * {@link ResourceEncoder} that is registered first will be used.
+   *
+   * @deprecated Use the equivalent {@link #append(Class, ResourceEncoder)} method instead.
+   */
+  @Deprecated
+  public <TResource> Registry register(
+      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+    return append(resourceClass, encoder);
+  }
+
+  /**
+   * Appends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted after all earlier and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>The {@link ResourceEncoder} will be used both for the exact resource class and any subtypes.
+   * For example, registering an {@link ResourceEncoder} for
+   * {@link android.graphics.drawable.Drawable} (not recommended) will result in the
+   * {@link ResourceEncoder} being used for {@link android.graphics.drawable.BitmapDrawable} and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} and any other subclass.
+   *
+   * <p>If multiple {@link ResourceEncoder}s are registered for the same type or super type, the
+   * {@link ResourceEncoder} that is registered first will be used.
+   *
+   * @see #prepend(Class, ResourceEncoder)
+   */
+  public <TResource> Registry append(
+      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+    resourceEncoderRegistry.append(resourceClass, encoder);
+    return this;
+  }
+
+  /**
+   * Prepends the given {@link ResourceEncoder} into the list of available {@link ResourceEncoder}s
+   * so that it is attempted before all later and default {@link ResourceEncoder}s for the given
+   * data type.
+   *
+   * <p>This method allows you to replace the default {@link ResourceEncoder} because it ensures
+   * the registered {@link ResourceEncoder} will run first. If multiple {@link ResourceEncoder}s are
+   * registered for the same type or super type, the {@link ResourceEncoder} that is registered
+   * first will be used.
+   *
+   * @see #append(Class, ResourceEncoder)
+   */
+  public <TResource> Registry prepend(
+      Class<TResource> resourceClass, ResourceEncoder<TResource> encoder) {
+    resourceEncoderRegistry.prepend(resourceClass, encoder);
+    return this;
+  }
+
+  /**
+   * Registers a new {@link com.bumptech.glide.load.data.DataRewinder.Factory} to handle a
+   * non-default data type that can be rewind to allow for efficient reads of file headers.
+   */
   public Registry register(DataRewinder.Factory factory) {
     dataRewinderRegistry.register(factory);
     return this;
   }
 
+  /**
+   * Registers the given {@link ResourceTranscoder} to convert from the given resource {@link Class}
+   * to the given transcode {@link Class}.
+   *
+   * @param resourceClass The class that will be transcoded from (e.g.
+   * {@link android.graphics.Bitmap}).
+   * @param transcodeClass The class that will be transcoded to (e.g.
+   * {@link android.graphics.drawable.BitmapDrawable}).
+   * @param transcoder The {@link ResourceTranscoder} to register.
+   */
   public <TResource, Transcode> Registry register(Class<TResource> resourceClass,
       Class<Transcode> transcodeClass, ResourceTranscoder<TResource, Transcode> transcoder) {
     transcoderRegistry.register(resourceClass, transcodeClass, transcoder);
     return this;
   }
 
+  /**
+   * Registers a new {@link ImageHeaderParser} that can obtain some basic metadata from an image
+   * header (orientation, type etc).
+   */
   public Registry register(ImageHeaderParser parser) {
     imageHeaderParserRegistry.add(parser);
     return this;
   }
 
   /**
-   * Use the given factory to build a {@link com.bumptech.glide.load.model.ModelLoader} for models
-   * of the given class. Generally the best use of this method is to replace one of the default
-   * factories or add an implementation for other similar low level models. Any factory replaced by
-   * the given factory will have its {@link ModelLoaderFactory#teardown()}} method called.
+   * Appends a new {@link ModelLoaderFactory} onto the end of the existing set so that the
+   * constructed {@link ModelLoader} will be tried after all default and previously registered
+   * {@link ModelLoader}s for the given model and data classes.
+   *
+   * <p>If you're attempting to replace an existing {@link ModelLoader}, use
+   * {@link #prepend(Class, Class, ModelLoaderFactory)}. This method is best for new types of models
+   * and/or data or as a way to add an additional fallback loader for an existing type of
+   * model/data.
    *
-   * <p> Note - If a factory already exists for the given class, it will be replaced. If that
-   * factory is not being used for any other model class, {@link ModelLoaderFactory#teardown()} will
-   * be called. </p>
+   * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
+   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
+   * entire request fail.
    *
-   * <p> Note - The factory must not be an anonymous inner class of an Activity or another object
-   * that cannot be retained statically. </p>
+   * @see #prepend(Class, Class, ModelLoaderFactory)
+   * @see #replace(Class, Class, ModelLoaderFactory)
    *
-   * @param modelClass The model class.
-   * @param dataClass  the data class.
+   * @param modelClass The model class (e.g. URL, file path).
+   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
+   * {@link java.io.FileDescriptor}).
    */
   public <Model, Data> Registry append(Class<Model> modelClass, Class<Data> dataClass,
       ModelLoaderFactory<Model, Data> factory) {
@@ -114,12 +384,58 @@ public Registry register(ImageHeaderParser parser) {
     return this;
   }
 
+  /**
+   * Prepends a new {@link ModelLoaderFactory} onto the beginning of the existing set so that the
+   * constructed {@link ModelLoader} will be tried before all default and previously registered
+   * {@link ModelLoader}s for the given model and data classes.
+   *
+   * <p>If you're attempting to add additional functionality or add a backup that should run only
+   * after the default {@link ModelLoader}s run, use
+   * {@link #append(Class, Class, ModelLoaderFactory)}. This method is best for adding an additional
+   * case to Glide's existing functionality that should run first. This method will still run
+   * Glide's default {@link ModelLoader}s if the prepended {@link ModelLoader}s fail.
+   *
+   * <p>If multiple {@link ModelLoaderFactory}s are registered for the same model and/or data
+   * classes, the {@link ModelLoader}s they produce will be attempted in the order the
+   * {@link ModelLoaderFactory}s were registered. Only if all {@link ModelLoader}s fail will the
+   * entire request fail.
+   *
+   * @see #append(Class, Class, ModelLoaderFactory)
+   * @see #replace(Class, Class, ModelLoaderFactory)
+   *
+   * @param modelClass The model class (e.g. URL, file path).
+   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
+   * {@link java.io.FileDescriptor}).
+   */
   public <Model, Data> Registry prepend(Class<Model> modelClass, Class<Data> dataClass,
       ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.prepend(modelClass, dataClass, factory);
     return this;
   }
 
+  /**
+   * Removes all default and previously registered {@link ModelLoaderFactory}s for the given data
+   * and model class and replaces all of them with the single {@link ModelLoader} provided.
+   *
+   * <p>If you're attempting to add additional functionality or add a backup that should run only
+   * after the default {@link ModelLoader}s run, use
+   * {@link #append(Class, Class, ModelLoaderFactory)}. This method should be used only when you
+   * want to ensure that Glide's default {@link ModelLoader}s do not run.
+   *
+   * <p>One good use case for this method is when you want to replace Glide's default networking
+   * library with your OkHttp, Volley, or your own implementation. Using
+   * {@link #prepend(Class, Class, ModelLoaderFactory)} or
+   * {@link #append(Class, Class, ModelLoaderFactory)} may still allow Glide's default networking
+   * library to run in some cases. Using this method will ensure that only your networking library
+   * will run and that the request will fail otherwise.
+   *
+   * @see #prepend(Class, Class, ModelLoaderFactory)
+   * @see #append(Class, Class, ModelLoaderFactory)
+   *
+   * @param modelClass The model class (e.g. URL, file path).
+   * @param dataClass  the data class (e.g. {@link java.io.InputStream},
+   * {@link java.io.FileDescriptor}).
+   */
   public <Model, Data> Registry replace(Class<Model> modelClass, Class<Data> dataClass,
       ModelLoaderFactory<Model, Data> factory) {
     modelLoaderRegistry.replace(modelClass, dataClass, factory);
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 04ff0d80a..55b044f0a 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -3,11 +3,11 @@
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
 
 import android.net.Uri;
+import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.widget.ImageView;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestCoordinator;
@@ -33,23 +33,22 @@
  * {@link com.bumptech.glide.request.target.Target}.
  */
 public class RequestBuilder<TranscodeType> implements Cloneable {
-  private static final TransitionOptions<?, ?> DEFAULT_ANIMATION_OPTIONS =
-      new GenericTransitionOptions<Object>();
   // Used in generated subclasses
-  protected static final BaseRequestOptions<?> DOWNLOAD_ONLY_OPTIONS =
+  protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
   private final GlideContext context;
   private final RequestManager requestManager;
   private final Class<TranscodeType> transcodeClass;
-  private final BaseRequestOptions<?> defaultRequestOptions;
+  private final RequestOptions defaultRequestOptions;
   private final Glide glide;
 
-  @NonNull protected BaseRequestOptions<?> requestOptions;
+  @NonNull protected RequestOptions requestOptions;
+
+  @NonNull
   @SuppressWarnings("unchecked")
-  private TransitionOptions<?, ? super TranscodeType> transitionOptions =
-      (TransitionOptions<?, ? super TranscodeType>) DEFAULT_ANIMATION_OPTIONS;
+  private TransitionOptions<?, ? super TranscodeType> transitionOptions;
 
   @Nullable private Object model;
   // model may occasionally be null, so to enforce that load() was called, put a boolean rather
@@ -57,6 +56,7 @@
   @Nullable private RequestListener<TranscodeType> requestListener;
   @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;
   @Nullable private Float thumbSizeMultiplier;
+  private boolean isDefaultTransitionOptionsSet = true;
   private boolean isModelSet;
   private boolean isThumbnailBuilt;
 
@@ -67,6 +67,7 @@ protected RequestBuilder(Glide glide, RequestManager requestManager,
     this.context = glide.getGlideContext();
     this.transcodeClass = transcodeClass;
     this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
+    this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);
     this.requestOptions = defaultRequestOptions;
   }
 
@@ -81,16 +82,16 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    * Applies the given options to the request, options set or unset in the given options will
    * replace those previously set in options in this class.
    *
-   * @see BaseRequestOptions#apply(BaseRequestOptions)
+   * @see RequestOptions#apply(RequestOptions)
    * @return This request builder.
    */
-  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
+  public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
     Preconditions.checkNotNull(requestOptions);
     this.requestOptions = getMutableOptions().apply(requestOptions);
     return this;
   }
 
-  protected BaseRequestOptions<?> getMutableOptions() {
+  protected RequestOptions getMutableOptions() {
     return defaultRequestOptions == this.requestOptions
         ? this.requestOptions.clone() : this.requestOptions;
   }
@@ -107,6 +108,7 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
   public RequestBuilder<TranscodeType> transition(
       @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
     this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
+    isDefaultTransitionOptionsSet = false;
     return this;
   }
 
@@ -160,8 +162,8 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    * <p> Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
    * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.BaseRequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.BaseRequestOptions#error(int)}, and
+   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
+   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
    * {@link #listener(RequestListener)} will only be used on the full size load and will not be
    * copied for the thumbnail load. </p>
    *
@@ -207,11 +209,11 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    * <p> Note - this method caches data using only the given String as the cache key. If the data is
    * a Uri outside of your control, or you otherwise expect the data represented by the given String
    * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create that identifies the data currently at the given String that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
    * </p>
    *
@@ -230,11 +232,11 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
    * represented by Uris from some content providers may change without the Uri changing, which
    * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create based on the data at the given Uri that will invalidate the cache
    * if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate. </p>
    *
    * @see #load(Object)
@@ -252,11 +254,11 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    * <p> Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
    * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)}
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
    * to mixin a signature you create that identifies the data currently in the File that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
    * </p>
    *
@@ -280,7 +282,7 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    * version code before each install and you replace a Drawable with different data without
    * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
    * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link BaseRequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
+   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
    * during development, and re-enabling the default
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds. </p>
    *
@@ -328,6 +330,7 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    * builders. </p>
    */
   @SuppressWarnings("unchecked")
+  @CheckResult
   @Override
   public RequestBuilder<TranscodeType> clone() {
     try {
@@ -348,26 +351,40 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    * @see RequestManager#clear(Target)
    */
   public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
+    return into(target, getMutableOptions());
+  }
+
+  private <Y extends Target<TranscodeType>> Y into(@NonNull Y target, RequestOptions options) {
     Util.assertMainThread();
     Preconditions.checkNotNull(target);
     if (!isModelSet) {
       throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
 
-    Request previous = target.getRequest();
+    options = options.autoClone();
+    Request request = buildRequest(target, options);
 
-    if (previous != null) {
-      requestManager.clear(target);
+    Request previous = target.getRequest();
+    if (request.isEquivalentTo(previous)) {
+      request.recycle();
+      // If the request is completed, beginning again will ensure the result is re-delivered,
+      // triggering RequestListeners and Targets. If the request is failed, beginning again will
+      // restart the request, giving it another chance to complete. If the request is already
+      // running, we can let it continue running without interruption.
+      if (!Preconditions.checkNotNull(previous).isRunning()) {
+        previous.begin();
+      }
+      return target;
     }
 
-    requestOptions.lock();
-    Request request = buildRequest(target);
+    requestManager.clear(target);
     target.setRequest(request);
     requestManager.track(target, request);
 
     return target;
   }
 
+
   /**
    * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into
    * the view, and frees any resources Glide may have previously loaded into the view so they may be
@@ -383,26 +400,27 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
     Util.assertMainThread();
     Preconditions.checkNotNull(view);
 
+    RequestOptions requestOptions = this.requestOptions;
     if (!requestOptions.isTransformationSet()
         && requestOptions.isTransformationAllowed()
         && view.getScaleType() != null) {
-      if (requestOptions.isLocked()) {
-        requestOptions = requestOptions.clone();
-      }
+      // Clone in this method so that if we use this RequestBuilder to load into a View and then
+      // into a different target, we don't retain the transformation applied based on the previous
+      // View's scale type.
       switch (view.getScaleType()) {
         case CENTER_CROP:
-          requestOptions.optionalCenterCrop();
+          requestOptions = requestOptions.clone().optionalCenterCrop();
           break;
         case CENTER_INSIDE:
-          requestOptions.optionalCenterInside();
+          requestOptions = requestOptions.clone().optionalCenterInside();
           break;
         case FIT_CENTER:
         case FIT_START:
         case FIT_END:
-          requestOptions.optionalFitCenter();
+          requestOptions = requestOptions.clone().optionalFitCenter();
           break;
         case FIT_XY:
-          requestOptions.optionalCenterInside();
+          requestOptions = requestOptions.clone().optionalCenterInside();
           break;
         case CENTER:
         case MATRIX:
@@ -411,7 +429,7 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
       }
     }
 
-    return into(context.buildImageViewTarget(view, transcodeClass));
+    return into(context.buildImageViewTarget(view, transcodeClass), requestOptions);
   }
 
   /**
@@ -419,11 +437,11 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    * @see RequestManager#clear(Target)
    *
@@ -455,11 +473,11 @@ protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?>
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    */
   public FutureTarget<TranscodeType> submit(int width, int height) {
@@ -490,11 +508,11 @@ public void run() {
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    * @return A {@link Target} that can be used to cancel the load via
    * {@link RequestManager#clear(Target)}.
@@ -529,6 +547,7 @@ public void run() {
    * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}.
    */
   @Deprecated
+  @CheckResult
   public <Y extends Target<File>> Y downloadOnly(Y target) {
     return getDownloadOnlyRequest().into(target);
   }
@@ -546,10 +565,12 @@ public void run() {
    * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}.
    */
   @Deprecated
+  @CheckResult
   public FutureTarget<File> downloadOnly(int width, int height) {
     return getDownloadOnlyRequest().submit(width, height);
   }
 
+  @CheckResult
   protected RequestBuilder<File> getDownloadOnlyRequest() {
     return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
   }
@@ -568,15 +589,15 @@ private Priority getThumbnailPriority(Priority current) {
     }
   }
 
-  private Request buildRequest(Target<TranscodeType> target) {
+  private Request buildRequest(Target<TranscodeType> target, RequestOptions requestOptions) {
     return buildRequestRecursive(target, null, transitionOptions, requestOptions.getPriority(),
-        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight());
+        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight(), requestOptions);
   }
 
   private Request buildRequestRecursive(Target<TranscodeType> target,
       @Nullable ThumbnailRequestCoordinator parentCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions,
-      Priority priority, int overrideWidth, int overrideHeight) {
+      Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) {
     if (thumbnailBuilder != null) {
       // Recursive case: contains a potentially recursive thumbnail request builder.
       if (isThumbnailBuilt) {
@@ -586,7 +607,10 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
 
       TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
           thumbnailBuilder.transitionOptions;
-      if (DEFAULT_ANIMATION_OPTIONS.equals(thumbTransitionOptions)) {
+
+      // Apply our transition by default to thumbnail requests but avoid overriding custom options
+      // that may have been applied on the thumbnail request explicitly.
+      if (thumbnailBuilder.isDefaultTransitionOptionsSet) {
         thumbTransitionOptions = transitionOptions;
       }
 
@@ -606,8 +630,15 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
           transitionOptions, priority, overrideWidth, overrideHeight);
       isThumbnailBuilt = true;
       // Recursively generate thumbnail requests.
-      Request thumbRequest = thumbnailBuilder.buildRequestRecursive(target, coordinator,
-          thumbTransitionOptions, thumbPriority, thumbOverrideWidth, thumbOverrideHeight);
+      Request thumbRequest =
+          thumbnailBuilder.buildRequestRecursive(
+              target,
+              coordinator,
+              thumbTransitionOptions,
+              thumbPriority,
+              thumbOverrideWidth,
+              thumbOverrideHeight,
+              thumbnailBuilder.requestOptions);
       isThumbnailBuilt = false;
       coordinator.setRequests(fullRequest, thumbRequest);
       return coordinator;
@@ -616,7 +647,7 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
       Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,
           priority, overrideWidth, overrideHeight);
-      BaseRequestOptions<?> thumbnailOptions = requestOptions.clone()
+      RequestOptions thumbnailOptions = requestOptions.clone()
           .sizeMultiplier(thumbSizeMultiplier);
 
       Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,
@@ -632,11 +663,9 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
   }
 
   private Request obtainRequest(Target<TranscodeType> target,
-      BaseRequestOptions<?> requestOptions, RequestCoordinator requestCoordinator,
+      RequestOptions requestOptions, RequestCoordinator requestCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,
       int overrideWidth, int overrideHeight) {
-    requestOptions.lock();
-
     return SingleRequest.obtain(
         context,
         model,
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 1082c1582..8275cee2c 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -13,7 +13,6 @@
 import android.support.annotation.Nullable;
 import android.view.View;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
@@ -22,7 +21,6 @@
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.manager.TargetTracker;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
@@ -66,7 +64,7 @@ public void run() {
   private final ConnectivityMonitor connectivityMonitor;
 
   @NonNull
-  private BaseRequestOptions<?> requestOptions;
+  private RequestOptions requestOptions;
 
   public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
     this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory());
@@ -106,12 +104,12 @@ public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode t
     glide.registerRequestManager(this);
   }
 
-  protected void setRequestOptions(@NonNull BaseRequestOptions<?> toSet) {
-    this.requestOptions = toSet.clone().autoClone();
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    requestOptions = toSet.clone().autoClone();
   }
 
-  private void updateRequestOptions(BaseRequestOptions<?> toUpdate) {
-    this.requestOptions.apply(toUpdate);
+  private void updateRequestOptions(RequestOptions toUpdate) {
+    requestOptions = requestOptions.apply(toUpdate);
   }
 
   /**
@@ -128,7 +126,7 @@ private void updateRequestOptions(BaseRequestOptions<?> toUpdate) {
    *
    * <p>The modified options will only be applied to loads started after this method is called.
    *
-   * @see RequestBuilder#apply(BaseRequestOptions)
+   * @see RequestBuilder#apply(RequestOptions)
    *
    * @return This request manager.
    */
@@ -161,16 +159,24 @@ public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
 
   /**
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
+   *
+   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
+   * externally.
    */
+  @Deprecated
   public void onTrimMemory(int level) {
-    glide.getGlideContext().onTrimMemory(level);
+    glide.onTrimMemory(level);
   }
 
   /**
    * @see android.content.ComponentCallbacks2#onLowMemory()
+   *
+   * @deprecated This method is called automatically by Glide's internals and shouldn't be called
+   * externally.
    */
+  @Deprecated
   public void onLowMemory() {
-    glide.getGlideContext().onLowMemory();
+    glide.onLowMemory();
   }
 
   /**
@@ -287,8 +293,7 @@ public void onDestroy() {
    * @return A new request builder for loading a {@link android.graphics.Bitmap}
    */
   public RequestBuilder<Bitmap> asBitmap() {
-    return as(Bitmap.class).transition(new GenericTransitionOptions<Bitmap>())
-            .apply(DECODE_TYPE_BITMAP);
+    return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
   }
 
   /**
@@ -305,7 +310,7 @@ public void onDestroy() {
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
    */
   public RequestBuilder<GifDrawable> asGif() {
-    return as(GifDrawable.class).transition(new DrawableTransitionOptions()).apply(DECODE_TYPE_GIF);
+    return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
   }
 
   /**
@@ -319,7 +324,7 @@ public void onDestroy() {
    * @return A new request builder for loading a {@link Drawable}.
    */
   public RequestBuilder<Drawable> asDrawable() {
-    return as(Drawable.class).transition(new DrawableTransitionOptions());
+    return as(Drawable.class);
   }
 
   /**
@@ -449,10 +454,15 @@ void track(Target<?> target, Request request) {
     requestTracker.runRequest(request);
   }
 
-  BaseRequestOptions<?> getDefaultRequestOptions() {
+  RequestOptions getDefaultRequestOptions() {
     return requestOptions;
   }
 
+  @NonNull
+  <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {
+    return glide.getGlideContext().getDefaultTransitionOptions(transcodeClass);
+  }
+
   @Override
   public String toString() {
     return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";
diff --git a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
index 118d407dd..4837ec515 100644
--- a/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java
@@ -15,24 +15,41 @@
    * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
    * {@link android.graphics.Bitmap#getConfig()} when possible.
    *
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
+   * {@link android.graphics.Bitmap.Config#HARDWARE}.
+   *
    * <p> GIF images decoded by {@link android.graphics.BitmapFactory} currently use an internal
    * hidden format that is returned as null from {@link android.graphics.Bitmap#getConfig()}. Since
    * we cannot force {@link android.graphics.BitmapFactory} to always return our desired config,
-   * this setting is a preference, not a promise.</p>
+   * this setting is a preference, not a promise.
    */
   PREFER_ARGB_8888,
 
+  /**
+   * Identical to {@link #PREFER_ARGB_8888} but prevents Glide from using {@link
+   * android.graphics.Bitmap.Config#HARDWARE} on Android O+.
+   *
+   * @deprecated If you must disable hardware bitmaps, set
+   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false
+   * instead.
+   */
+  @Deprecated
+  PREFER_ARGB_8888_DISALLOW_HARDWARE,
+
   /**
    * Bitmaps decoded from image formats that support and/or use alpha (some types of PNGs, GIFs etc)
    * should return {@link android.graphics.Bitmap.Config#ARGB_8888} for
    * {@link android.graphics.Bitmap#getConfig()}. Bitmaps decoded from formats that don't support or
    * use alpha should return {@link android.graphics.Bitmap.Config#RGB_565} for
    * {@link android.graphics.Bitmap#getConfig()}.
+   *
+   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use
+   * {@link android.graphics.Bitmap.Config#HARDWARE}.
    */
   PREFER_RGB_565;
 
   /**
    * The default value for DecodeFormat.
    */
-  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;
+  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index 659dad412..3d5c96e0f 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -13,6 +13,8 @@
  * obfuscation) is an easy way to implement
  * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly.
  *
+ * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()}.
+ *
  * @param <T> The type of the resource being transformed.
  */
 public interface Transformation<T> extends Key {
@@ -52,4 +54,18 @@
    * @return The transformed resource.
    */
   Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight);
+
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and
+   * {@link #hashCode()}.
+   */
+  @Override
+  boolean equals(Object o);
+
+  /**
+   * For caching to work correctly, implementations <em>must</em> implement this method and
+   * {@link #equals(Object)}.
+   */
+  @Override
+  int hashCode();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
index 7a379c792..366a9ad3d 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.data;
 
 import android.content.res.AssetManager;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -54,6 +55,7 @@ public void cancel() {
     // Do nothing.
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
index 29f9e4cc9..9889eaf06 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -21,12 +22,13 @@
 public interface DataFetcher<T> {
 
   /**
-   * Callback that should be called when data has been loaded and is available, or when the load
+   * Callback that must be called when data has been loaded and is available, or when the load
    * fails.
    *
    * @param <T> The type of data that will be loaded.
    */
   interface DataCallback<T> {
+
     /**
      * Called with the loaded data if the load succeeded, or with {@code null} if the load failed.
      */
@@ -41,18 +43,24 @@
   }
 
   /**
-   * Synchronously fetch data from which a resource can be decoded.
+   * Fetch data from which a resource can be decoded.
+   *
+   * <p> This will always be called on background thread so it is safe to perform long running tasks
+   * here. Any third party libraries called must be thread safe (or move the work to another thread)
+   * since this method will be called from a thread in a
+   * {@link java.util.concurrent.ExecutorService}
+   * that may have more than one background thread. </p>
+   *
+   * You <b>MUST</b> use the {@link DataCallback} once the request is complete.
    *
-   * <p> This will always be called on
-   * background thread so it is safe to perform long running tasks here. Any third party libraries
-   * called must be thread safe since this method will be called from a thread in a {@link
-   * java.util.concurrent.ExecutorService} that may have more than one background thread. </p>
+   * You are free to move the fetch work to another thread and call the callback from there.
    *
    * <p> This method will only be called when the corresponding resource is not in the cache. </p>
    *
    * <p> Note - this method will be run on a background thread so blocking I/O is safe. </p>
    *
    * @param priority The priority with which the request should be completed.
+   * @param callback The callback to use when the request is complete
    * @see #cleanup() where the data retuned will be cleaned up
    */
   void loadData(Priority priority, DataCallback<? super T> callback);
@@ -84,10 +92,12 @@
   /**
    * Returns the class of the data this fetcher will attempt to obtain.
    */
+  @NonNull
   Class<T> getDataClass();
 
   /**
    * Returns the {@link com.bumptech.glide.load.DataSource} this fetcher will return data from.
    */
+  @NonNull
   DataSource getDataSource();
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
index 893efb440..176f206d9 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java
@@ -2,6 +2,7 @@
 
 import android.content.res.AssetManager;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import java.io.IOException;
 
 /**
@@ -23,6 +24,7 @@ protected void close(ParcelFileDescriptor data) throws IOException {
     data.close();
   }
 
+  @NonNull
   @Override
   public Class<ParcelFileDescriptor> getDataClass() {
     return ParcelFileDescriptor.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 7d3492701..2a159b92b 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -4,6 +4,7 @@
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
@@ -30,6 +31,7 @@ protected void close(ParcelFileDescriptor data) throws IOException {
     data.close();
   }
 
+  @NonNull
   @Override
   public Class<ParcelFileDescriptor> getDataClass() {
     return ParcelFileDescriptor.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index e441bef2a..6989129cc 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data;
 
+import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import android.util.Log;
 import com.bumptech.glide.Priority;
@@ -99,6 +100,8 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
 
     // Connect explicitly to avoid errors in decoders if connection fails.
     urlConnection.connect();
+    // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.
+    stream = urlConnection.getInputStream();
     if (isCancelled) {
       return null;
     }
@@ -111,6 +114,9 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
         throw new HttpException("Received empty or null redirect url");
       }
       URL redirectUrl = new URL(url, redirectUrlString);
+      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition
+      // to disconnecting the url connection below. See #2352.
+      cleanup();
       return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
     } else if (statusCode == -1) {
       throw new HttpException(statusCode);
@@ -145,6 +151,7 @@ public void cleanup() {
     if (urlConnection != null) {
       urlConnection.disconnect();
     }
+    urlConnection = null;
   }
 
   @Override
@@ -154,11 +161,13 @@ public void cancel() {
     isCancelled = true;
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.REMOTE;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index 0f6488260..81d12b054 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -2,6 +2,7 @@
 
 import android.content.ContentResolver;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -64,6 +65,7 @@ public void cancel() {
     // Do nothing.
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
index 00879955f..aaad13214 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.data;
 
 import android.content.res.AssetManager;
+import android.support.annotation.NonNull;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -22,6 +23,7 @@ protected void close(InputStream data) throws IOException {
     data.close();
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index fe0eed476..cb4cb966b 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -6,6 +6,7 @@
 import android.net.Uri;
 import android.os.Build;
 import android.provider.ContactsContract;
+import android.support.annotation.NonNull;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -31,6 +32,11 @@
    * (e.g. content://com.android.contacts/5/display_photo)
    */
   private static final int ID_CONTACTS_PHOTO = 4;
+  /**
+   * Uri for optimized search of phones by number
+   * (e.g. content://com.android.contacts/phone_lookup/232323232
+   */
+  private static final int ID_LOOKUP_BY_PHONE = 5;
   /**
    * Match the incoming Uri for special cases which we can handle nicely.
    */
@@ -43,6 +49,7 @@
     URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_CONTACTS_THUMBNAIL);
     URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACTS_CONTACT);
     URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/display_photo", ID_CONTACTS_PHOTO);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "phone_lookup/*", ID_LOOKUP_BY_PHONE);
   }
 
   public StreamLocalUriFetcher(ContentResolver resolver, Uri uri) {
@@ -66,6 +73,7 @@ private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver
       case ID_CONTACTS_CONTACT:
         return openContactPhotoInputStream(contentResolver, uri);
       case ID_CONTACTS_LOOKUP:
+      case ID_LOOKUP_BY_PHONE:
         // If it was a Lookup uri then resolve it first, then continue loading the contact uri.
         uri = ContactsContract.Contacts.lookupContact(contentResolver, uri);
         if (uri == null) {
@@ -91,6 +99,7 @@ protected void close(InputStream data) throws IOException {
     data.close();
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index f7f7db337..64fcec28f 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -5,6 +5,7 @@
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.MediaStore;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.Priority;
@@ -96,11 +97,13 @@ public void cancel() {
     // Do nothing.
   }
 
+  @NonNull
   @Override
   public Class<InputStream> getDataClass() {
     return InputStream.class;
   }
 
+  @NonNull
   @Override
   public DataSource getDataSource() {
     return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index bbd9504ed..5c6529ff0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -37,6 +37,7 @@
   private Priority priority;
   private DiskCacheStrategy diskCacheStrategy;
   private boolean isTransformationRequired;
+  private boolean isScaleOnlyOrNoTransform;
 
   @SuppressWarnings("unchecked")
   <R> DecodeHelper<R> init(
@@ -52,6 +53,7 @@
       Options options,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean isScaleOnlyOrNoTransform,
       DecodeJob.DiskCacheProvider diskCacheProvider) {
     this.glideContext = glideContext;
     this.model = model;
@@ -66,6 +68,7 @@
     this.options = options;
     this.transformations = transformations;
     this.isTransformationRequired = isTransformationRequired;
+    this.isScaleOnlyOrNoTransform = isScaleOnlyOrNoTransform;
 
     return (DecodeHelper<R>) this;
   }
@@ -132,6 +135,10 @@ boolean hasLoadPath(Class<?> dataClass) {
     return glideContext.getRegistry().getLoadPath(dataClass, resourceClass, transcodeClass);
   }
 
+  boolean isScaleOnlyOrNoTransform() {
+    return isScaleOnlyOrNoTransform;
+  }
+
   @SuppressWarnings("unchecked")
   <Z> Transformation<Z> getTransformation(Class<Z> resourceClass) {
     Transformation<Z> result = (Transformation<Z>) transformations.get(resourceClass);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index 8b2abacef..d1eb3619b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.engine;
 
+import android.os.Build;
+import android.support.v4.os.TraceCompat;
 import android.support.v4.util.Pools;
 import android.util.Log;
 import com.bumptech.glide.GlideContext;
@@ -14,7 +16,9 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.DataRewinder;
 import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.util.LogTime;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
@@ -89,6 +93,7 @@
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean isScaleOnlyOrNoTransform,
       boolean onlyRetrieveFromCache,
       Options options,
       Callback<R> callback,
@@ -106,6 +111,7 @@
         options,
         transformations,
         isTransformationRequired,
+        isScaleOnlyOrNoTransform,
         diskCacheProvider);
     this.glideContext = glideContext;
     this.signature = signature;
@@ -212,6 +218,10 @@ public void run() {
     // This should be much more fine grained, but since Java's thread pool implementation silently
     // swallows all otherwise fatal exceptions, this will at least make it obvious to developers
     // that something is failing.
+    TraceCompat.beginSection("DecodeJob#run");
+    // Methods in the try statement can invalidate currentFetcher, so set a local variable here to
+    // ensure that the fetcher is cleaned up either way.
+    DataFetcher<?> localFetcher = currentFetcher;
     try {
       if (isCancelled) {
         notifyFailed();
@@ -231,6 +241,14 @@ public void run() {
       if (!isCancelled) {
         throw e;
       }
+    } finally {
+      Preconditions.checkArgument(
+          localFetcher == null || currentFetcher == null || localFetcher.equals(currentFetcher),
+          "Fetchers don't match!, old: " + localFetcher + " new: " + currentFetcher);
+      if (localFetcher != null) {
+        localFetcher.cleanup();
+      }
+      TraceCompat.endSection();
     }
   }
 
@@ -347,7 +365,12 @@ public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetche
       runReason = RunReason.DECODE_DATA;
       callback.reschedule(this);
     } else {
-      decodeFromRetrievedData();
+      TraceCompat.beginSection("DecodeJob.decodeFromRetrievedData");
+      try {
+        decodeFromRetrievedData();
+      } finally {
+        TraceCompat.endSection();
+      }
     }
   }
 
@@ -438,12 +461,33 @@ private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource)
     return runLoadPath(data, dataSource, path);
   }
 
+  private Options getOptionsWithHardwareConfig(DataSource dataSource) {
+    Options options = this.options;
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+      return options;
+    }
+
+    if (options.get(Downsampler.ALLOW_HARDWARE_CONFIG) != null) {
+      return options;
+    }
+
+    if (dataSource == DataSource.RESOURCE_DISK_CACHE
+        || decodeHelper.isScaleOnlyOrNoTransform()) {
+      options = new Options();
+      options.putAll(this.options);
+      options.set(Downsampler.ALLOW_HARDWARE_CONFIG, true);
+    }
+    return options;
+  }
+
   private <Data, ResourceType> Resource<R> runLoadPath(Data data, DataSource dataSource,
       LoadPath<Data, ResourceType, R> path) throws GlideException {
+    Options options = getOptionsWithHardwareConfig(dataSource);
     DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);
     try {
-      return path.load(rewinder, options, width, height,
-          new DecodeCallback<ResourceType>(dataSource));
+      // ResourceType in DecodeCallback below is required for compilation to work with gradle.
+      return path.load(
+          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));
     } finally {
       rewinder.cleanup();
     }
@@ -585,11 +629,13 @@ private boolean isComplete(boolean isRemovedFromQueue) {
     }
 
     void encode(DiskCacheProvider diskCacheProvider, Options options) {
+      TraceCompat.beginSection("DecodeJob.encode");
       try {
         diskCacheProvider.getDiskCache().put(key,
             new DataCacheWriter<>(encoder, toEncode, options));
       } finally {
         toEncode.unlock();
+        TraceCompat.endSection();
       }
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
index 6198bc5f0..e74320bf0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java
@@ -42,7 +42,7 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
       Options options, DecodeCallback<ResourceType> callback) throws GlideException {
     Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);
     Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);
-    return transcoder.transcode(transformed);
+    return transcoder.transcode(transformed, options);
   }
 
   private Resource<ResourceType> decodeResource(DataRewinder<DataType> rewinder, int width,
@@ -66,7 +66,9 @@ public DecodePath(Class<DataType> dataClass, Class<ResourceType> resourceClass,
           data = rewinder.rewindAndGet();
           result = decoder.decode(data, width, height, options);
         }
-      } catch (IOException e) {
+        // Some decoders throw unexpectedly. If they do, we shouldn't fail the entire load path, but
+        // instead log and continue. See #2406 for an example.
+      } catch (IOException | RuntimeException e) {
         if (Log.isLoggable(TAG, Log.VERBOSE)) {
           Log.v(TAG, "Failed to decode data for " + decoder, e);
         }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 1dc070d50..315d4cf11 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -151,6 +151,7 @@ public Engine(MemoryCache memoryCache,
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean isScaleOnlyOrNoTransform,
       Options options,
       boolean isMemoryCacheable,
       boolean useUnlimitedSourceExecutorPool,
@@ -204,6 +205,7 @@ public Engine(MemoryCache memoryCache,
         diskCacheStrategy,
         transformations,
         isTransformationRequired,
+        isScaleOnlyOrNoTransform,
         onlyRetrieveFromCache,
         options,
         engineJob);
@@ -420,6 +422,7 @@ public boolean queueIdle() {
         DiskCacheStrategy diskCacheStrategy,
         Map<Class<?>, Transformation<?>> transformations,
         boolean isTransformationRequired,
+        boolean isScaleOnlyOrNoTransform,
         boolean onlyRetrieveFromCache,
         Options options,
         DecodeJob.Callback<R> callback) {
@@ -437,6 +440,7 @@ public boolean queueIdle() {
           diskCacheStrategy,
           transformations,
           isTransformationRequired,
+          isScaleOnlyOrNoTransform,
           onlyRetrieveFromCache,
           options,
           callback,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 6c193eafc..3517092ac 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -148,14 +148,9 @@ void cancel() {
 
     isCancelled = true;
     decodeJob.cancel();
-    boolean isPendingJobRemoved = diskCacheExecutor.remove(decodeJob)
-        || sourceExecutor.remove(decodeJob)
-        || sourceUnlimitedExecutor.remove(decodeJob);
+    // TODO: Consider trying to remove jobs that have never been run before from executor queues.
+    // Removing jobs that have run before can break things. See #1996.
     listener.onEngineJobCancelled(this, key);
-
-    if (isPendingJobRemoved) {
-      release(true /*isRemovedFromQueue*/);
-    }
   }
 
   // Exposed for testing.
@@ -239,11 +234,9 @@ public void onLoadFailed(GlideException e) {
 
   @Override
   public void reschedule(DecodeJob<?> job) {
-    if (isCancelled) {
-      MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();
-    } else {
-      getActiveSourceExecutor().execute(job);
-    }
+    // Even if the job is cancelled here, it still needs to be scheduled so that it can clean itself
+    // up.
+    getActiveSourceExecutor().execute(job);
   }
 
   @Synthetic
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index 4dca3166a..f932aac27 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -88,7 +88,6 @@ public Throwable fillInStackTrace() {
    * complete stack traces.
    */
   public void logRootCauses(String tag) {
-    Log.e(tag, getClass() + ": " + getMessage());
     List<Exception> causes = getRootCauses();
     for (int i = 0, size = causes.size(); i < size; i++) {
       Log.i(tag, "Root cause (" + (i + 1) + " of " + size + ")", causes.get(i));
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 2cf9c0f37..88150031d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -142,8 +142,23 @@ public Bitmap getDirty(int width, int height, Bitmap.Config config) {
     return result;
   }
 
+  @TargetApi(Build.VERSION_CODES.O)
+  private static void assertNotHardwareConfig(Bitmap.Config config) {
+    // Avoid short circuiting on sdk int since it breaks on some versions of Android.
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+      return;
+    }
+
+    if (config == Bitmap.Config.HARDWARE) {
+      throw new IllegalArgumentException("Cannot create a mutable Bitmap with config: " + config
+          + ". Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your RequestOptions"
+          + " and/or in GlideBuilder.setDefaultRequestOptions");
+    }
+  }
+
   @Nullable
   private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {
+    assertNotHardwareConfig(config);
     // Config will be null for non public config types, which can lead to transformations naively
     // passing in null as the requested config here. See issue #194.
     final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG);
@@ -245,12 +260,19 @@ private static LruPoolStrategy getDefaultStrategy() {
     return strategy;
   }
 
+  @TargetApi(Build.VERSION_CODES.O)
   private static Set<Bitmap.Config> getDefaultAllowedConfigs() {
     Set<Bitmap.Config> configs = new HashSet<>();
     configs.addAll(Arrays.asList(Bitmap.Config.values()));
-    if (Build.VERSION.SDK_INT >= 19) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java
+      // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured
+      // and are suitable for re-use.
       configs.add(null);
     }
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      configs.remove(Bitmap.Config.HARDWARE);
+    }
     return Collections.unmodifiableSet(configs);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
index 13318a8fc..d11f0f02a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.engine.cache;
 
-import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayDeque;
@@ -19,16 +18,16 @@
  *  0, the lock can safely be removed from the map. </p>
  */
 final class DiskCacheWriteLocker {
-  private final Map<Key, WriteLock> locks = new HashMap<>();
+  private final Map<String, WriteLock> locks = new HashMap<>();
   private final WriteLockPool writeLockPool = new WriteLockPool();
 
-  void acquire(Key key) {
+  void acquire(String safeKey) {
     WriteLock writeLock;
     synchronized (this) {
-      writeLock = locks.get(key);
+      writeLock = locks.get(safeKey);
       if (writeLock == null) {
         writeLock = writeLockPool.obtain();
-        locks.put(key, writeLock);
+        locks.put(safeKey, writeLock);
       }
       writeLock.interestedThreads++;
     }
@@ -36,24 +35,24 @@ void acquire(Key key) {
     writeLock.lock.lock();
   }
 
-  void release(Key key) {
+  void release(String safeKey) {
     WriteLock writeLock;
     synchronized (this) {
-      writeLock = Preconditions.checkNotNull(locks.get(key));
+      writeLock = Preconditions.checkNotNull(locks.get(safeKey));
       if (writeLock.interestedThreads < 1) {
         throw new IllegalStateException("Cannot release a lock that is not held"
-            + ", key: " + key
+            + ", safeKey: " + safeKey
             + ", interestedThreads: " + writeLock.interestedThreads);
       }
 
       writeLock.interestedThreads--;
       if (writeLock.interestedThreads == 0) {
-        WriteLock removed = locks.remove(key);
+        WriteLock removed = locks.remove(safeKey);
         if (!removed.equals(writeLock)) {
           throw new IllegalStateException("Removed the wrong lock"
               + ", expected to remove: " + writeLock
               + ", but actually removed: " + removed
-              + ", key: " + key);
+              + ", safeKey: " + safeKey);
         }
         writeLockPool.offer(removed);
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index c0e6f5269..8cd104d02 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -88,9 +88,9 @@ public File get(Key key) {
   public void put(Key key, Writer writer) {
     // We want to make sure that puts block so that data is available when put completes. We may
     // actually not write any data if we find that data is written by the time we acquire the lock.
-    writeLocker.acquire(key);
+    String safeKey = safeKeyGenerator.getSafeKey(key);
+    writeLocker.acquire(safeKey);
     try {
-      String safeKey = safeKeyGenerator.getSafeKey(key);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "Put: Obtained: " + safeKey + " for for Key: " + key);
       }
@@ -121,7 +121,7 @@ public void put(Key key, Writer writer) {
         }
       }
     } finally {
-      writeLocker.release(key);
+      writeLocker.release(safeKey);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 7e0bb505e..4489744e2 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -28,30 +28,34 @@
     int getHeightPixels();
   }
 
-  MemorySizeCalculator(Context context, ActivityManager activityManager,
-      ScreenDimensions screenDimensions, float memoryCacheScreens, float bitmapPoolScreens,
-      int targetArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
-    this.context = context;
+  // Package private to avoid PMD warning.
+  MemorySizeCalculator(MemorySizeCalculator.Builder builder) {
+    this.context = builder.context;
+
     arrayPoolSize =
-        isLowMemoryDevice(activityManager)
-            ? targetArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
-            : targetArrayPoolSize;
-    final int maxSize = getMaxSize(activityManager, maxSizeMultiplier, lowMemoryMaxSizeMultiplier);
+        isLowMemoryDevice(builder.activityManager)
+            ? builder.arrayPoolSizeBytes / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
+            : builder.arrayPoolSizeBytes;
+    int maxSize =
+        getMaxSize(
+            builder.activityManager, builder.maxSizeMultiplier, builder.lowMemoryMaxSizeMultiplier);
+
+    int widthPixels = builder.screenDimensions.getWidthPixels();
+    int heightPixels = builder.screenDimensions.getHeightPixels();
+    int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;
 
-    final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()
-        * BYTES_PER_ARGB_8888_PIXEL;
+    int targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);
 
-    int targetPoolSize = Math.round(screenSize * bitmapPoolScreens);
-    int targetMemoryCacheSize = Math.round(screenSize * memoryCacheScreens);
+    int targetMemoryCacheSize = Math.round(screenSize * builder.memoryCacheScreens);
     int availableSize = maxSize - arrayPoolSize;
 
-    if (targetMemoryCacheSize + targetPoolSize <= availableSize) {
+    if (targetMemoryCacheSize + targetBitmapPoolSize <= availableSize) {
       memoryCacheSize = targetMemoryCacheSize;
-      bitmapPoolSize = targetPoolSize;
+      bitmapPoolSize = targetBitmapPoolSize;
     } else {
-      float part = availableSize / (bitmapPoolScreens + memoryCacheScreens);
-      memoryCacheSize = Math.round(part * memoryCacheScreens);
-      bitmapPoolSize = Math.round(part * bitmapPoolScreens);
+      float part = availableSize / (builder.bitmapPoolScreens + builder.memoryCacheScreens);
+      memoryCacheSize = Math.round(part * builder.memoryCacheScreens);
+      bitmapPoolSize = Math.round(part * builder.bitmapPoolScreens);
     }
 
     if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -65,13 +69,13 @@
               + ", byte array size: "
               + toMb(arrayPoolSize)
               + ", memory class limited? "
-              + (targetMemoryCacheSize + targetPoolSize > maxSize)
+              + (targetMemoryCacheSize + targetBitmapPoolSize > maxSize)
               + ", max size: "
               + toMb(maxSize)
               + ", memoryClass: "
-              + activityManager.getMemoryClass()
+              + builder.activityManager.getMemoryClass()
               + ", isLowMemoryDevice: "
-              + isLowMemoryDevice(activityManager));
+              + isLowMemoryDevice(builder.activityManager));
     }
   }
 
@@ -125,7 +129,15 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
   public static final class Builder {
     // Visible for testing.
     static final int MEMORY_CACHE_TARGET_SCREENS = 2;
-    static final int BITMAP_POOL_TARGET_SCREENS = 4;
+
+    /**
+     * On Android O+, we use {@link android.graphics.Bitmap.Config#HARDWARE} for all reasonably
+     * sized images unless we're creating thumbnails for the first time. As a result, the Bitmap
+     * pool is much less important on O than it was on previous versions.
+     */
+    static final int BITMAP_POOL_TARGET_SCREENS =
+        Build.VERSION.SDK_INT < Build.VERSION_CODES.O ? 4 : 1;
+
     static final float MAX_SIZE_MULTIPLIER = 0.4f;
     static final float LOW_MEMORY_MAX_SIZE_MULTIPLIER = 0.33f;
     // 4MB.
@@ -149,6 +161,14 @@ public Builder(Context context) {
           (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
       screenDimensions =
           new DisplayMetricsScreenDimensions(context.getResources().getDisplayMetrics());
+
+      // On Android O+ Bitmaps are allocated natively, ART is much more efficient at managing
+      // garbage and we rely heavily on HARDWARE Bitmaps, making Bitmap re-use much less important.
+      // We prefer to preserve RAM on these devices and take the small performance hit of not
+      // re-using Bitmaps and textures when loading very small images or generating thumbnails.
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && isLowMemoryDevice(activityManager)) {
+        bitmapPoolScreens = 0;
+      }
     }
 
     /**
@@ -230,10 +250,8 @@ Builder setScreenDimensions(ScreenDimensions screenDimensions) {
     }
 
     public MemorySizeCalculator build() {
-      return new MemorySizeCalculator(context, activityManager, screenDimensions,
-          memoryCacheScreens, bitmapPoolScreens, arrayPoolSizeBytes, maxSizeMultiplier,
-          lowMemoryMaxSizeMultiplier);
-      }
+      return new MemorySizeCalculator(this);
+    }
   }
 
   private static final class DisplayMetricsScreenDimensions implements ScreenDimensions {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index b79e11178..d80ff2059 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -71,6 +71,24 @@ public static GlideExecutor newDiskCacheExecutor() {
         DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);
   }
 
+  /**
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
+   * prefix, and a custom
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
+   * uncaught throwable strategy.
+   *
+   * <p>Disk cache executors do not allow network operations on their threads.
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
+   */
+  public static GlideExecutor newDiskCacheExecutor(
+          UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+                                DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);
+  }
+
   /**
    * Returns a new fixed thread pool with the given thread count, thread name prefix,
    * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
@@ -103,6 +121,25 @@ public static GlideExecutor newSourceExecutor() {
         UncaughtThrowableStrategy.DEFAULT);
   }
 
+  /**
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
+   * prefix, and a custom
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}
+   * uncaught throwable strategy.
+   *
+   * <p>Source executors allow network operations on their threads.
+   *
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
+   */
+  public static GlideExecutor newSourceExecutor(
+          UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+                                DEFAULT_DISK_CACHE_EXECUTOR_NAME, uncaughtThrowableStrategy);
+  }
+
   /**
    * Returns a new fixed thread pool with the given thread count, thread name prefix,
    * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
@@ -274,29 +311,33 @@ public boolean accept(File file, String s) {
    * A strategy for handling unexpected and uncaught {@link Throwable}s thrown by futures run on the
    * pool.
    */
-  public enum UncaughtThrowableStrategy {
+  public interface UncaughtThrowableStrategy {
     /**
      * Silently catches and ignores the uncaught {@link Throwable}s.
      */
-    IGNORE,
+    UncaughtThrowableStrategy IGNORE = new UncaughtThrowableStrategy() {
+      @Override
+      public void handle(Throwable t) {
+        //ignore
+      }
+    };
     /**
      * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}.
      */
-    LOG {
+    UncaughtThrowableStrategy LOG = new UncaughtThrowableStrategy() {
       @Override
-      protected void handle(Throwable t) {
+      public void handle(Throwable t) {
         if (t != null && Log.isLoggable(TAG, Log.ERROR)) {
           Log.e(TAG, "Request threw uncaught throwable", t);
         }
       }
-    },
+    };
     /**
      * Rethrows the uncaught {@link Throwable}s to crash the app.
      */
-    THROW {
+    UncaughtThrowableStrategy THROW = new UncaughtThrowableStrategy() {
       @Override
-      protected void handle(Throwable t) {
-        super.handle(t);
+      public void handle(Throwable t) {
         if (t != null) {
           throw new RuntimeException("Request threw uncaught throwable", t);
         }
@@ -304,11 +345,9 @@ protected void handle(Throwable t) {
     };
 
     /** The default strategy, currently {@link #LOG}. */
-    public static final UncaughtThrowableStrategy DEFAULT = LOG;
+    UncaughtThrowableStrategy DEFAULT = LOG;
 
-    protected void handle(Throwable t) {
-      // Ignore.
-    }
+    void handle(Throwable t);
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index 42a5a46c1..c5caa3cc7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -30,6 +30,7 @@ public BitmapPreFiller(MemoryCache memoryCache, BitmapPool bitmapPool,
     this.defaultFormat = defaultFormat;
   }
 
+  @SuppressWarnings("deprecation")
   public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     if (current != null) {
       current.cancel();
@@ -39,7 +40,9 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
     for (int i = 0; i < bitmapAttributeBuilders.length; i++) {
       PreFillType.Builder builder = bitmapAttributeBuilders[i];
       if (builder.getConfig() == null) {
-        builder.setConfig(defaultFormat == DecodeFormat.PREFER_ARGB_8888
+        builder.setConfig(
+            defaultFormat == DecodeFormat.PREFER_ARGB_8888
+                || defaultFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
             ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
       }
       bitmapAttributes[i] = builder.build();
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 8a486cce7..60c4a9452 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -69,11 +70,13 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public Class<Data> getDataClass() {
       return converter.getDataClass();
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index cb28480a1..82a787898 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -78,11 +79,13 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public Class<ByteBuffer> getDataClass() {
       return ByteBuffer.class;
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
index 0e3297acb..4f522f4ac 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import android.util.Base64;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -90,11 +91,13 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public Class<Data> getDataClass() {
       return reader.getDataClass();
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index 104af06e4..3d6fb70c3 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -89,11 +90,13 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public Class<Data> getDataClass() {
       return opener.getDataClass();
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 31b30bb5d..5f4b4c85d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -99,9 +100,7 @@ public int hashCode() {
   @SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
   public static final class Builder {
     private static final String USER_AGENT_HEADER = "User-Agent";
-    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
-    private static final String ENCODING_HEADER = "Accept-Encoding";
-    private static final String DEFAULT_ENCODING = "identity";
+    private static final String DEFAULT_USER_AGENT = getSanitizedUserAgent();
     private static final Map<String, List<LazyHeaderFactory>> DEFAULT_HEADERS;
 
     // Set Accept-Encoding header to do our best to avoid gzip since it's both inefficient for
@@ -115,15 +114,11 @@ public int hashCode() {
             Collections.<LazyHeaderFactory>singletonList(
                 new StringHeaderFactory(DEFAULT_USER_AGENT)));
       }
-      temp.put(ENCODING_HEADER,
-          Collections.<LazyHeaderFactory>singletonList(
-              new StringHeaderFactory(DEFAULT_ENCODING)));
       DEFAULT_HEADERS = Collections.unmodifiableMap(temp);
     }
 
     private boolean copyOnModify = true;
     private Map<String, List<LazyHeaderFactory>> headers = DEFAULT_HEADERS;
-    private boolean isEncodingDefault = true;
     private boolean isUserAgentDefault = true;
 
     /**
@@ -150,8 +145,7 @@ public Builder addHeader(String key, String value) {
      * times </p>
      */
     public Builder addHeader(String key, LazyHeaderFactory factory) {
-      if ((isEncodingDefault && ENCODING_HEADER.equalsIgnoreCase(key))
-          || (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key))) {
+      if (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key)) {
         return setHeader(key, factory);
       }
 
@@ -189,9 +183,6 @@ public Builder setHeader(String key, LazyHeaderFactory factory) {
         factories.add(factory);
       }
 
-      if (isEncodingDefault && ENCODING_HEADER.equalsIgnoreCase(key)) {
-        isEncodingDefault = false;
-      }
       if (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key)) {
         isUserAgentDefault = false;
       }
@@ -231,6 +222,31 @@ public LazyHeaders build() {
       }
       return result;
     }
+
+    /**
+     * Ensures that the default header will pass OkHttp3's checks for header values.
+     *
+     * <p>See #2331.
+     */
+    @VisibleForTesting
+    static String getSanitizedUserAgent() {
+      String defaultUserAgent = System.getProperty("http.agent");
+      if (TextUtils.isEmpty(defaultUserAgent)) {
+        return defaultUserAgent;
+      }
+
+      int length = defaultUserAgent.length();
+      StringBuilder sb = new StringBuilder(defaultUserAgent.length());
+      for (int i = 0; i < length; i++) {
+        char c = defaultUserAgent.charAt(i);
+        if ((c > '\u001f' || c == '\t') && c < '\u007f') {
+          sb.append(c);
+        } else {
+          sb.append('?');
+        }
+      }
+      return sb.toString();
+    }
   }
 
   static final class StringHeaderFactory implements LazyHeaderFactory {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index 5326fd2d9..7d389f197 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -4,6 +4,7 @@
 import android.database.Cursor;
 import android.net.Uri;
 import android.provider.MediaStore;
+import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -81,11 +82,13 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @Override
     public Class<File> getDataClass() {
       return File.class;
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/model/Model.java b/library/src/main/java/com/bumptech/glide/load/model/Model.java
new file mode 100644
index 000000000..616b9f390
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/Model.java
@@ -0,0 +1,28 @@
+package com.bumptech.glide.load.model;
+
+/**
+ * An optional interface that models can implement to enhance control over Glide behaviors.
+ */
+public interface Model {
+
+    /**
+     * Returns {@code true} if this model produces the same image using the same mechanism
+     * (server, authentication, source etc) as the given model.
+     * <p>
+     * Models must also implement {@link #equals(Object other)} and {@link #hashCode()}
+     * to ensure that caching functions correctly.
+     * If this object returns {@code true} from this method for a given Model,
+     * it must also be equal to and have the same hash code as the given model.
+     * <p>
+     * However, this model may be equal to and have the same hash code as a given model
+     * but still return {@code false} from this method.
+     * This method optionally allows you to differentiate between Models that load the same image
+     * via multiple different means.
+     * For example one Model might load the image from server A and another model might load
+     * the same image from server B.
+     * The models must be equal to each other with the same hash code because they load
+     * the same image. However two requests made with the different models are not exactly the
+     * same because the way the image is loaded will differ.
+     */
+    boolean isEquivalentTo(Object other);
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
index dd8b59921..d18d12e46 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
@@ -76,6 +78,7 @@ public String toString() {
     private int currentIndex;
     private Priority priority;
     private DataCallback<? super Data> callback;
+    @Nullable
     private List<Exception> exceptions;
 
     MultiFetcher(List<DataFetcher<Data>> fetchers, Pool<List<Exception>> exceptionListPool) {
@@ -95,7 +98,9 @@ public void loadData(Priority priority, DataCallback<? super Data> callback) {
 
     @Override
     public void cleanup() {
-      exceptionListPool.release(exceptions);
+      if (exceptions != null) {
+        exceptionListPool.release(exceptions);
+      }
       exceptions = null;
       for (DataFetcher<Data> fetcher : fetchers) {
         fetcher.cleanup();
@@ -109,11 +114,13 @@ public void cancel() {
       }
     }
 
+    @NonNull
     @Override
     public Class<Data> getDataClass() {
       return fetchers.get(0).getDataClass();
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return fetchers.get(0).getDataSource();
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index 198f01bfa..8a3eca114 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -48,12 +49,14 @@ public void cancel() {
       // Do nothing.
     }
 
+    @NonNull
     @SuppressWarnings("unchecked")
     @Override
     public Class<Model> getDataClass() {
       return (Class<Model>) resource.getClass();
     }
 
+    @NonNull
     @Override
     public DataSource getDataSource() {
       return DataSource.LOCAL;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
index b4ef6c4ca..8a2fdf327 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.Bitmap;
+import android.support.v4.os.TraceCompat;
 import android.util.Log;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
@@ -51,37 +52,44 @@
   @Override
   public boolean encode(Resource<Bitmap> resource, File file, Options options) {
     final Bitmap bitmap = resource.get();
-
-    long start = LogTime.getLogTime();
     Bitmap.CompressFormat format = getFormat(bitmap, options);
-    int quality = options.get(COMPRESSION_QUALITY);
-
-    boolean success = false;
-    OutputStream os = null;
+    TraceCompat.beginSection(
+        "encode: [" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + format);
     try {
-      os = new FileOutputStream(file);
-      bitmap.compress(format, quality, os);
-      os.close();
-      success = true;
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Failed to encode Bitmap", e);
-      }
-    } finally {
-      if (os != null) {
-        try {
-          os.close();
-        } catch (IOException e) {
-          // Do nothing.
+      long start = LogTime.getLogTime();
+      int quality = options.get(COMPRESSION_QUALITY);
+
+      boolean success = false;
+      OutputStream os = null;
+      try {
+        os = new FileOutputStream(file);
+        bitmap.compress(format, quality, os);
+        os.close();
+        success = true;
+      } catch (IOException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Failed to encode Bitmap", e);
+        }
+      } finally {
+        if (os != null) {
+          try {
+            os.close();
+          } catch (IOException e) {
+            // Do nothing.
+          }
         }
       }
-    }
 
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
-      Log.v(TAG, "Compressed with type: " + format + " of size " + Util.getBitmapByteSize(bitmap)
-          + " in " + LogTime.getElapsedMillis(start));
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Compressed with type: " + format + " of size " + Util.getBitmapByteSize(bitmap)
+            + " in " + LogTime.getElapsedMillis(start)
+            + ", options format: " + options.get(COMPRESSION_FORMAT)
+            + ", hasAlpha: " + bitmap.hasAlpha());
+      }
+      return success;
+    } finally {
+      TraceCompat.endSection();
     }
-    return success;
   }
 
   private Bitmap.CompressFormat getFormat(Bitmap bitmap, Options options) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
index f24c63ce6..61900b789 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -31,15 +31,6 @@ public static BitmapTransitionOptions withCrossFade(int duration) {
     return new BitmapTransitionOptions().crossFade(duration);
   }
 
-  /**
-   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
-   *
-   * @see #crossFade(int, int)
-   */
-  public static BitmapTransitionOptions withCrossFade(int animationId, int duration) {
-    return new BitmapTransitionOptions().crossFade(animationId, duration);
-  }
-
   /**
    * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
    *
@@ -101,22 +92,6 @@ public BitmapTransitionOptions crossFade(int duration) {
     return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
 
-  /**
-   * Enables a cross fade animation between both the placeholder and the first resource and between
-   * subsequent resources (if thumbnails are used).
-   *
-   * @param animationId The id of the animation to use if no placeholder or previous resource is
-   *     set, see {@code DrawableCrossFadeFactory.Builder#setDefaultAnimationId(int)}.
-   * @param duration The duration of the cross fade, see
-   *     {@code DrawableCrossFadeFactory.Builder(int)}.
-   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
-   */
-  public BitmapTransitionOptions crossFade(int animationId, int duration) {
-    return crossFade(
-        new DrawableCrossFadeFactory.Builder(duration)
-            .setDefaultAnimationId(animationId));
-  }
-
   /**
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index e16adcc79..963348f9d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -2,6 +2,7 @@
 
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
 import android.graphics.BitmapFactory;
 import android.os.Build;
 import android.support.annotation.Nullable;
@@ -9,6 +10,7 @@
 import android.util.Log;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
@@ -16,7 +18,9 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.SampleSizeRounding;
+import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 import java.io.IOException;
@@ -34,7 +38,7 @@
  * Downsamples, decodes, and rotates images according to their exif orientation.
  */
 public final class Downsampler {
-  private static final String TAG = "Downsampler";
+  static final String TAG = "Downsampler";
   /**
    * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction
    * with the image format to determine the {@link android.graphics.Bitmap.Config} to provide to
@@ -50,7 +54,6 @@
   public static final Option<DownsampleStrategy> DOWNSAMPLE_STRATEGY =
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
           DownsampleStrategy.AT_LEAST);
-
   /**
    * Ensure that the size of the bitmap is fixed to the requested width and height of the
    * resource from the caller.  The final resource dimensions may differ from the requested
@@ -64,6 +67,27 @@
   public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
 
+  /**
+   * Indicates that it's safe or unsafe to decode {@link Bitmap}s with
+   * {@link Bitmap.Config#HARDWARE}.
+   *
+   * <p>Callers should almost never set this value to {@code true} manually. Glide will already do
+   * so when Glide believes it's safe to do (when no transformations are applied). Instead, callers
+   * can set this value to {@code false} to prevent Glide from decoding hardware bitmaps if Glide
+   * is unable to detect that hardware bitmaps are unsafe. For example, you should set this to
+   * {@code false} if you plan to draw it to a software {@link android.graphics.Canvas} or if you
+   * plan to inspect the {@link Bitmap}s pixels with {@link Bitmap#getPixel(int, int)} or
+   * {@link Bitmap#getPixels(int[], int, int, int, int, int, int)}.
+   *
+   * <p>Callers can disable hardware {@link Bitmap}s for all loads using
+   * {@link com.bumptech.glide.GlideBuilder#setDefaultRequestOptions(RequestOptions)}.
+   *
+   * <p>This option is ignored unless we're on Android O+.
+   */
+  public static final Option<Boolean> ALLOW_HARDWARE_CONFIG =
+      Option.memory(
+          "com.bumtpech.glide.load.resource.bitmap.Downsampler.AllowHardwareDecode", null);
+
   private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
   private static final String ICO_MIME_TYPE = "image/x-ico";
   private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
@@ -95,14 +119,18 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
           )
       );
   private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);
-  // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer
+  // 10MB. This is the max image header size we can handle, we preallocate a much smaller buffer
   // but will resize up to this amount if necessary.
-  private static final int MARK_POSITION = 5 * 1024 * 1024;
+  private static final int MARK_POSITION = 10 * 1024 * 1024;
+  // Defines the level of precision we get when using inDensity/inTargetDensity to calculate an
+  // arbitrary float scale factor.
+  private static final int DENSITY_PRECISION_MULTIPLIER = 1000000000;
 
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
   private final ArrayPool byteArrayPool;
   private final List<ImageHeaderParser> parsers;
+  private final HardwareConfigState hardwareConfigState = HardwareConfigState.getInstance();
 
   public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetrics,
       BitmapPool bitmapPool, ArrayPool byteArrayPool) {
@@ -158,7 +186,7 @@ public boolean handles(ByteBuffer byteBuffer) {
    * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is
    * not null.
    */
-  @SuppressWarnings("resource")
+  @SuppressWarnings({"resource", "deprecation"})
   public Resource<Bitmap> decode(InputStream is, int requestedWidth, int requestedHeight,
       Options options, DecodeCallbacks callbacks) throws IOException {
     Preconditions.checkArgument(is.markSupported(), "You must provide an InputStream that supports"
@@ -171,11 +199,16 @@ public boolean handles(ByteBuffer byteBuffer) {
     DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
     DownsampleStrategy downsampleStrategy = options.get(DOWNSAMPLE_STRATEGY);
     boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
+    boolean isHardwareConfigAllowed =
+      options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);
+    if (decodeFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE) {
+      isHardwareConfigAllowed = false;
+    }
 
     try {
       Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
-          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,
-          fixBitmapToRequestedDimensions, callbacks);
+          downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,
+          requestedHeight, fixBitmapToRequestedDimensions, callbacks);
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
@@ -185,32 +218,57 @@ public boolean handles(ByteBuffer byteBuffer) {
 
   private Bitmap decodeFromWrappedStreams(InputStream is,
       BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
-      DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,
-      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {
+      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,
+      int requestedHeight, boolean fixBitmapToRequestedDimensions,
+      DecodeCallbacks callbacks) throws IOException {
+    long startTime = LogTime.getLogTime();
 
-    int[] sourceDimensions = getDimensions(is, options, callbacks);
+    int[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool);
     int sourceWidth = sourceDimensions[0];
     int sourceHeight = sourceDimensions[1];
     String sourceMimeType = options.outMimeType;
 
+    // If we failed to obtain the image dimensions, we may end up with an incorrectly sized Bitmap,
+    // so we want to use a mutable Bitmap type. One way this can happen is if the image header is so
+    // large (10mb+) that our attempt to use inJustDecodeBounds fails and we're forced to decode the
+    // full size image.
+    if (sourceWidth == -1 || sourceHeight == -1) {
+      isHardwareConfigAllowed = false;
+    }
+
     int orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
     int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
-
-    options.inPreferredConfig = getConfig(is, decodeFormat);
-    if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
-      options.inDither = true;
-    }
+    boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);
 
     int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
     int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
 
-    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,
-        targetHeight, options);
+    ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
+
+    calculateScaling(
+        imageType,
+        is,
+        callbacks,
+        bitmapPool,
+        downsampleStrategy,
+        degreesToRotate,
+        sourceWidth,
+        sourceHeight,
+        targetWidth,
+        targetHeight,
+        options);
+    calculateConfig(
+        is,
+        decodeFormat,
+        isHardwareConfigAllowed,
+        isExifOrientationRequired,
+        options,
+        targetWidth,
+        targetHeight);
 
     boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
     // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
-    if ((options.inSampleSize == 1 || isKitKatOrGreater)
-        && shouldUsePool(is)) {
+    if ((options.inSampleSize == 1 || isKitKatOrGreater) && shouldUsePool(imageType)) {
       int expectedWidth;
       int expectedHeight;
       if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {
@@ -240,12 +298,12 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
         setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);
       }
     }
-    Bitmap downsampled = decodeStream(is, options, callbacks);
+    Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);
     callbacks.onDecodeComplete(bitmapPool, downsampled);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logDecode(sourceWidth, sourceHeight, sourceMimeType, options, downsampled,
-          requestedWidth, requestedHeight);
+          requestedWidth, requestedHeight, startTime);
     }
 
     Bitmap rotated = null;
@@ -264,9 +322,18 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
   }
 
   // Visible for testing.
-  static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesToRotate,
-      int sourceWidth, int sourceHeight, int targetWidth, int targetHeight,
-      BitmapFactory.Options options) {
+  static void calculateScaling(
+      ImageType imageType,
+      InputStream is,
+      DecodeCallbacks decodeCallbacks,
+      BitmapPool bitmapPool,
+      DownsampleStrategy downsampleStrategy,
+      int degreesToRotate,
+      int sourceWidth,
+      int sourceHeight,
+      int targetWidth,
+      int targetHeight,
+      BitmapFactory.Options options) throws IOException {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
       return;
@@ -287,7 +354,9 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
 
     if (exactScaleFactor <= 0f) {
       throw new IllegalArgumentException("Cannot scale with factor: " + exactScaleFactor
-          + " from: " + downsampleStrategy);
+          + " from: " + downsampleStrategy
+          + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
+          + ", target: [" + targetWidth + "x" + targetHeight + "]");
     }
     SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding(sourceWidth,
         sourceHeight, targetWidth, targetHeight);
@@ -295,8 +364,8 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
       throw new IllegalArgumentException("Cannot round with null rounding");
     }
 
-    int outWidth = (int) (exactScaleFactor * sourceWidth + 0.5f);
-    int outHeight = (int) (exactScaleFactor * sourceHeight + 0.5f);
+    int outWidth = round(exactScaleFactor * sourceWidth);
+    int outHeight = round(exactScaleFactor * sourceHeight);
 
     int widthScaleFactor = sourceWidth / outWidth;
     int heightScaleFactor = sourceHeight / outHeight;
@@ -318,14 +387,61 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
       }
     }
 
-    float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;
-
+    // Here we mimic framework logic for determining how inSampleSize division is rounded on various
+    // versions of Android. The logic here has been tested on emulators for Android versions 15-26.
+    // PNG - Always uses floor
+    // JPEG - Always uses ceiling
+    // Webp - Prior to N, always uses floor. At and after N, always uses round.
     options.inSampleSize = powerOfTwoSampleSize;
+    int powerOfTwoWidth;
+    int powerOfTwoHeight;
+    if (imageType == ImageType.JPEG) {
+      // libjpegturbo can downsample up to a sample size of 8. libjpegturbo uses ceiling to round.
+      // After libjpegturbo's native rounding, skia does a secondary scale using floor
+      // (integer division). Here we replicate that logic.
+      int nativeScaling = Math.min(powerOfTwoSampleSize, 8);
+      powerOfTwoWidth = (int) Math.ceil(sourceWidth / (float) nativeScaling);
+      powerOfTwoHeight = (int) Math.ceil(sourceHeight / (float) nativeScaling);
+      int secondaryScaling = powerOfTwoSampleSize / 8;
+      if (secondaryScaling > 0) {
+        powerOfTwoWidth = powerOfTwoWidth / secondaryScaling;
+        powerOfTwoHeight = powerOfTwoHeight / secondaryScaling;
+      }
+    } else if (imageType == ImageType.PNG || imageType == ImageType.PNG_A) {
+      powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
+      powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+    } else if (imageType == ImageType.WEBP || imageType == ImageType.WEBP_A) {
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+        powerOfTwoWidth = Math.round(sourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = Math.round(sourceHeight / (float) powerOfTwoSampleSize);
+      } else {
+        powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+      }
+    } else if (
+        sourceWidth % powerOfTwoSampleSize != 0 || sourceHeight % powerOfTwoSampleSize != 0) {
+      // If we're not confident the image is in one of our types, fall back to checking the
+      // dimensions again. inJustDecodeBounds decodes do obey inSampleSize.
+      int[] dimensions = getDimensions(is, options, decodeCallbacks, bitmapPool);
+      // Power of two downsampling in BitmapFactory uses a variety of random factors to determine
+      // rounding that we can't reliably replicate for all image formats. Use ceiling here to make
+      // sure that we at least provide a Bitmap that's large enough to fit the content we're going
+      // to load.
+      powerOfTwoWidth = dimensions[0];
+      powerOfTwoHeight = dimensions[1];
+    } else {
+      powerOfTwoWidth = sourceWidth / powerOfTwoSampleSize;
+      powerOfTwoHeight = sourceHeight / powerOfTwoSampleSize;
+    }
+
+    double adjustedScaleFactor = downsampleStrategy.getScaleFactor(
+        powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);
+
     // Density scaling is only supported if inBitmap is null prior to KitKat. Avoid setting
     // densities here so we calculate the final Bitmap size correctly.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-      options.inTargetDensity = (int) (1000 * adjustedScaleFactor + 0.5f);
-      options.inDensity = 1000;
+      options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor);
+      options.inDensity = DENSITY_PRECISION_MULTIPLIER;
     }
     if (isScaling(options)) {
       options.inScaled = true;
@@ -337,6 +453,7 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
       Log.v(TAG, "Calculate scaling"
           + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
           + ", target: [" + targetWidth + "x" + targetHeight + "]"
+          + ", power of two scaled: [" + powerOfTwoWidth + "x" + powerOfTwoHeight + "]"
           + ", exact scale factor: " + exactScaleFactor
           + ", power of 2 sample size: " + powerOfTwoSampleSize
           + ", adjusted scale factor: " + adjustedScaleFactor
@@ -345,31 +462,63 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
     }
   }
 
-  private boolean shouldUsePool(InputStream is) throws IOException {
+  /**
+   * BitmapFactory calculates the density scale factor as a float. This introduces some non-trivial
+   * error. This method attempts to account for that error by adjusting the inTargetDensity so that
+   * the final scale factor is as close to our target as possible.
+   */
+  private static int adjustTargetDensityForError(double adjustedScaleFactor) {
+    int targetDensity = round(DENSITY_PRECISION_MULTIPLIER * adjustedScaleFactor);
+    float scaleFactorWithError = targetDensity / (float) DENSITY_PRECISION_MULTIPLIER;
+    double difference = adjustedScaleFactor / scaleFactorWithError;
+    return round(difference * targetDensity);
+  }
+
+  // This is weird, but it matches the logic in a bunch of Android views/framework classes for
+  // rounding.
+  private static int round(double value) {
+    return (int) (value + 0.5d);
+  }
+
+  private boolean shouldUsePool(ImageType imageType) throws IOException {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       return true;
     }
 
-    try {
-      ImageHeaderParser.ImageType type = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
-      // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
-      // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
-      return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(type);
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine the image type from header", e);
-      }
-    }
-    return false;
+    // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
+    // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
+    return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(imageType);
   }
 
-  private Bitmap.Config getConfig(InputStream is, DecodeFormat format) throws IOException {
+  @SuppressWarnings("deprecation")
+  private void calculateConfig(
+      InputStream is,
+      DecodeFormat format,
+      boolean isHardwareConfigAllowed,
+      boolean isExifOrientationRequired,
+      BitmapFactory.Options optionsWithScaling,
+      int targetWidth,
+      int targetHeight)
+      throws IOException {
+
+    if (hardwareConfigState.setHardwareConfigIfAllowed(
+        targetWidth,
+        targetHeight,
+        optionsWithScaling,
+        format,
+        isHardwareConfigAllowed,
+        isExifOrientationRequired)) {
+      return;
+    }
+
     // Changing configs can cause skewing on 4.1, see issue #128.
     if (format == DecodeFormat.PREFER_ARGB_8888
+        || format == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
         || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
-      return Bitmap.Config.ARGB_8888;
+      optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888;
+      return;
     }
 
     boolean hasAlpha = false;
@@ -382,7 +531,13 @@ private boolean shouldUsePool(InputStream is) throws IOException {
       }
     }
 
-    return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    optionsWithScaling.inPreferredConfig =
+        hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    if (optionsWithScaling.inPreferredConfig == Config.RGB_565
+        || optionsWithScaling.inPreferredConfig == Config.ARGB_4444
+        || optionsWithScaling.inPreferredConfig == Config.ALPHA_8) {
+      optionsWithScaling.inDither = true;
+    }
   }
 
   /**
@@ -394,15 +549,15 @@ private boolean shouldUsePool(InputStream is) throws IOException {
    * @return an array containing the dimensions of the image in the form {width, height}.
    */
   private static int[] getDimensions(InputStream is, BitmapFactory.Options options,
-      DecodeCallbacks decodeCallbacks) throws IOException {
+      DecodeCallbacks decodeCallbacks, BitmapPool bitmapPool) throws IOException {
     options.inJustDecodeBounds = true;
-    decodeStream(is, options, decodeCallbacks);
+    decodeStream(is, options, decodeCallbacks, bitmapPool);
     options.inJustDecodeBounds = false;
     return new int[] { options.outWidth, options.outHeight };
   }
 
   private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options,
-      DecodeCallbacks callbacks) throws IOException {
+      DecodeCallbacks callbacks, BitmapPool bitmapPool) throws IOException {
     if (options.inJustDecodeBounds) {
       is.mark(MARK_POSITION);
     } else {
@@ -423,7 +578,23 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
     try {
       result = BitmapFactory.decodeStream(is, null, options);
     } catch (IllegalArgumentException e) {
-      throw newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
+      IOException bitmapAssertionException =
+          newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Failed to decode with inBitmap, trying again without Bitmap re-use",
+            bitmapAssertionException);
+      }
+      if (options.inBitmap != null) {
+        try {
+          is.reset();
+          bitmapPool.put(options.inBitmap);
+          options.inBitmap = null;
+          return decodeStream(is, options, callbacks, bitmapPool);
+        } catch (IOException resetException) {
+          throw bitmapAssertionException;
+        }
+      }
+      throw bitmapAssertionException;
     } finally {
       TransformationUtils.getBitmapDrawableLock().unlock();
     }
@@ -441,7 +612,8 @@ private static boolean isScaling(BitmapFactory.Options options) {
   }
 
   private static void logDecode(int sourceWidth, int sourceHeight, String outMimeType,
-      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight) {
+      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight,
+      long startTime) {
     Log.v(TAG, "Decoded " + getBitmapString(result)
         + " from [" + sourceWidth + "x" + sourceHeight + "] " + outMimeType
         + " with inBitmap " + getInBitmapString(options)
@@ -449,7 +621,8 @@ private static void logDecode(int sourceWidth, int sourceHeight, String outMimeT
         + ", sample size: " + options.inSampleSize
         + ", density: " + options.inDensity
         + ", target density: " + options.inTargetDensity
-        + ", thread: " + Thread.currentThread().getName());
+        + ", thread: " + Thread.currentThread().getName()
+        + ", duration: " + LogTime.getElapsedMillis(startTime));
   }
 
   private static String getInBitmapString(BitmapFactory.Options options) {
@@ -482,8 +655,16 @@ private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentExc
           + ", inBitmap: " + getInBitmapString(options), e);
   }
 
+  @SuppressWarnings("PMD.CollapsibleIfStatements")
+  @TargetApi(Build.VERSION_CODES.O)
   private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
       int height) {
+    // Avoid short circuiting, it appears to break on some devices.
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      if (options.inPreferredConfig == Config.HARDWARE) {
+        return;
+      }
+    }
     // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
     options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);
   }
@@ -508,6 +689,7 @@ private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
     }
   }
 
+  @SuppressWarnings("deprecation")
   private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.inTempStorage = null;
     decodeBitmapOptions.inDither = false;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
new file mode 100644
index 000000000..fe7c0357d
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
@@ -0,0 +1,119 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import android.util.Log;
+import com.bumptech.glide.load.DecodeFormat;
+import java.io.File;
+
+/**
+ * State and constants for interacting with {@link android.graphics.Bitmap.Config#HARDWARE} on
+ * Android O+.
+ */
+final class HardwareConfigState {
+  /**
+   * The minimum size in pixels a {@link Bitmap} must be in both dimensions to be created with the
+   * {@link Bitmap.Config#HARDWARE} configuration.
+   *
+   * <p>This is a quick check that lets us skip wasting FDs (see {@link #FD_SIZE_LIST}) on small
+   * {@link Bitmap}s with relatively low memory costs.
+   *
+   * @see #FD_SIZE_LIST
+   */
+  private static final int MIN_HARDWARE_DIMENSION = 128;
+
+  /**
+   * Allows us to check to make sure we're not exceeding the FD limit for a process with hardware
+   * {@link Bitmap}s.
+   *
+   * <p>{@link Bitmap.Config#HARDWARE} {@link Bitmap}s require two FDs (depending on the driver).
+   * Processes have an FD limit of 1024 (at least on O). With sufficiently small {@link Bitmap}s
+   * and/or a sufficiently large {@link com.bumptech.glide.load.engine.cache.MemoryCache}, we can
+   * end up with enough {@link Bitmap}s in memory that we blow through the FD limit, which causes
+   * graphics errors, Binder errors, and a variety of crashes.
+   *
+   * <p>Calling list.size() should be relatively efficient (hopefully < 1ms on average) because
+   * /proc is an in-memory FS.
+   */
+  private static final File FD_SIZE_LIST = new File("/proc/self/fd");
+
+  /**
+   * Each FD check takes 1-2ms, so to avoid overhead, only check every N decodes. 50 is more or less
+   * arbitrary.
+   */
+  private static final int MINIMUM_DECODES_BETWEEN_FD_CHECKS = 50;
+
+  /**
+   * 700 with an error of 50 Bitmaps in between at two FDs each lets us use up to 800 FDs for
+   * hardware Bitmaps.
+   */
+  private static final int MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = 700;
+
+  private volatile int decodesSinceLastFdCheck;
+  private volatile boolean isHardwareConfigAllowed = true;
+
+  private static volatile HardwareConfigState instance;
+
+  static HardwareConfigState getInstance() {
+    if (instance == null) {
+      synchronized (HardwareConfigState.class) {
+        if (instance == null) {
+          instance = new HardwareConfigState();
+        }
+      }
+    }
+    return instance;
+  }
+
+  private HardwareConfigState() {
+    // Singleton constructor.
+  }
+
+  @TargetApi(Build.VERSION_CODES.O)
+  @SuppressWarnings("deprecation")
+  boolean setHardwareConfigIfAllowed(
+      int targetWidth,
+      int targetHeight,
+      BitmapFactory.Options optionsWithScaling,
+      DecodeFormat decodeFormat,
+      boolean isHardwareConfigAllowed,
+      boolean isExifOrientationRequired) {
+    if (!isHardwareConfigAllowed
+        || Build.VERSION.SDK_INT < Build.VERSION_CODES.O
+        || decodeFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
+        || isExifOrientationRequired) {
+      return false;
+    }
+
+    boolean result =
+        targetWidth >= MIN_HARDWARE_DIMENSION
+            && targetHeight >= MIN_HARDWARE_DIMENSION
+            // Make sure to call isFdSizeBelowHardwareLimit last because it has side affects.
+            && isFdSizeBelowHardwareLimit();
+
+    if (result) {
+      optionsWithScaling.inPreferredConfig = Bitmap.Config.HARDWARE;
+      optionsWithScaling.inMutable = false;
+    }
+    return result;
+  }
+
+  private synchronized boolean isFdSizeBelowHardwareLimit() {
+    if (++decodesSinceLastFdCheck >= MINIMUM_DECODES_BETWEEN_FD_CHECKS) {
+      decodesSinceLastFdCheck = 0;
+      int currentFds = FD_SIZE_LIST.list().length;
+      isHardwareConfigAllowed = currentFds < MAXIMUM_FDS_FOR_HARDWARE_CONFIGS;
+
+      if (!isHardwareConfigAllowed && Log.isLoggable(Downsampler.TAG, Log.WARN)) {
+        Log.w(Downsampler.TAG,
+            "Excluding HARDWARE bitmap config because we're over the file descriptor limit"
+                + ", file descriptors " + currentFds
+                + ", limit " + MAXIMUM_FDS_FOR_HARDWARE_CONFIGS);
+      }
+    }
+
+    return isHardwareConfigAllowed;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index e7abbb8ab..c81ad3554 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -127,11 +127,10 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
     final float heightPercentage = height / (float) inBitmap.getHeight();
     final float minPercentage = Math.min(widthPercentage, heightPercentage);
 
-    // take the floor of the target width/height, not round. If the matrix
-    // passed into drawBitmap rounds differently, we want to slightly
-    // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
-    final int targetWidth = (int) (minPercentage * inBitmap.getWidth());
-    final int targetHeight = (int) (minPercentage * inBitmap.getHeight());
+    // Round here in case we've decoded exactly the image we want, but take the floor below to
+    // avoid a line of garbage or blank pixels in images.
+    int targetWidth = Math.round(minPercentage * inBitmap.getWidth());
+    int targetHeight = Math.round(minPercentage * inBitmap.getHeight());
 
     if (inBitmap.getWidth() == targetWidth && inBitmap.getHeight() == targetHeight) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -140,6 +139,12 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
       return inBitmap;
     }
 
+    // Take the floor of the target width/height, not round. If the matrix
+    // passed into drawBitmap rounds differently, we want to slightly
+    // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
+    targetWidth = (int) (minPercentage * inBitmap.getWidth());
+    targetHeight = (int) (minPercentage * inBitmap.getHeight());
+
     Bitmap.Config config = getSafeConfig(inBitmap);
     Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
 
@@ -172,7 +177,7 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
    * height is larger than the given dimensions
    */
   public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
-                                 int height) {
+      int height) {
     if (inBitmap.getWidth() <= width && inBitmap.getHeight() <= height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size larger or equal to input, returning input");
@@ -264,12 +269,13 @@ public static int getExifOrientationDegrees(int exifOrientation) {
    */
   public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
       int exifOrientation) {
-    final Matrix matrix = new Matrix();
-    initializeMatrixForRotation(exifOrientation, matrix);
-    if (matrix.isIdentity()) {
+    if (!isExifOrientationRequired(exifOrientation)) {
       return inBitmap;
     }
 
+    final Matrix matrix = new Matrix();
+    initializeMatrixForRotation(exifOrientation, matrix);
+
     // From Bitmap.createBitmap.
     final RectF newRect = new RectF(0, 0, inBitmap.getWidth(), inBitmap.getHeight());
     matrix.mapRect(newRect);
@@ -286,6 +292,25 @@ public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap i
     return result;
   }
 
+  /**
+   * Returns {@code true} if the given exif orientation indicates that a transformation is necessary
+   * and {@code false} otherwise.
+   */
+  public static boolean isExifOrientationRequired(int exifOrientation) {
+    switch (exifOrientation) {
+      case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
+      case ExifInterface.ORIENTATION_ROTATE_180:
+      case ExifInterface.ORIENTATION_FLIP_VERTICAL:
+      case ExifInterface.ORIENTATION_TRANSPOSE:
+      case ExifInterface.ORIENTATION_ROTATE_90:
+      case ExifInterface.ORIENTATION_TRANSVERSE:
+      case ExifInterface.ORIENTATION_ROTATE_270:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   /**
    * Crop the image to a circle and resize to the specified width/height.  The circle crop will
    * have the same width and height equal to the min-edge of the result image.
@@ -348,7 +373,7 @@ private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
 
     Bitmap argbBitmap = pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(),
         Bitmap.Config.ARGB_8888);
-    new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*pain*/);
+    new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*paint*/);
 
     // We now own this Bitmap. It's our responsibility to replace it in the pool outside this method
     // when we're finished with it.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index 98d9a0e59..7be917bf2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -101,16 +101,10 @@ public VideoBitmapDecoder(BitmapPool bitmapPool) {
 
   @Override
   public boolean handles(ParcelFileDescriptor data, Options options) {
-    MediaMetadataRetriever retriever = factory.build();
-    try {
-      retriever.setDataSource(data.getFileDescriptor());
-      return true;
-    } catch (RuntimeException e) {
-      // Throws a generic runtime exception when given invalid data.
-      return false;
-    } finally {
-      retriever.release();
-    }
+    // Calling setDataSource is expensive so avoid doing so unless we're actually called.
+    // For non-videos this isn't any cheaper, but for videos it safes the redundant call and
+    // 50-100ms.
+    return true;
   }
 
   @Override
@@ -134,6 +128,9 @@ public boolean handles(ParcelFileDescriptor data, Options options) {
       } else {
         result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
       }
+    } catch (RuntimeException e) {
+      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data.
+      throw new IOException(e);
     } finally {
       mediaMetadataRetriever.release();
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index ebf582b81..88eeeaffa 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -29,15 +29,6 @@ public static DrawableTransitionOptions withCrossFade(int duration) {
     return new DrawableTransitionOptions().crossFade(duration);
   }
 
-  /**
-   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
-   *
-   * @see #crossFade(int, int)
-   */
-  public static DrawableTransitionOptions withCrossFade(int animationId, int duration) {
-    return new DrawableTransitionOptions().crossFade(animationId, duration);
-  }
-
   /**
    * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
    *
@@ -88,22 +79,6 @@ public DrawableTransitionOptions crossFade(int duration) {
     return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
 
-  /**
-   * Enables a cross fade animation between both the placeholder and the first resource and between
-   * subsequent resources (if thumbnails are used).
-   *
-   * @param animationId The id of the animation to use if no placeholder or previous resource is
-   *     set, see {@code DrawableCrossFadeFactory.Builder#setDefaultAnimationId(int)}.
-   * @param duration The duration of the cross fade, see
-   *     {@code DrawableCrossFadeFactory.Builder(int)}
-   * @see com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
-   */
-  public DrawableTransitionOptions crossFade(int animationId, int duration) {
-    return crossFade(
-        new DrawableCrossFadeFactory.Builder(duration)
-            .setDefaultAnimationId(animationId));
-  }
-
   /**
    * Enables a cross fade animation between both the placeholder and the first resource and between
    * subsequent resources (if thumbnails are used).
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index 778bc9860..5e6f98eed 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
+import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;
+
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -324,7 +326,9 @@ public void setLoopCount(int loopCount) {
     }
 
     if (loopCount == LOOP_INTRINSIC) {
-      maxLoopCount = state.frameLoader.getLoopCount();
+      int intrinsicCount = state.frameLoader.getLoopCount();
+      maxLoopCount =
+          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;
     } else {
       maxLoopCount = loopCount;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 9c75b5508..9c51ba3ed 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -19,14 +19,13 @@
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
-import java.security.MessageDigest;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.UUID;
 
 class GifFrameLoader {
   private final GifDecoder gifDecoder;
@@ -153,7 +152,7 @@ int getFrameCount() {
   }
 
   int getLoopCount() {
-    return gifDecoder.getLoopCount();
+    return gifDecoder.getTotalIterationCount();
   }
 
   private void start() {
@@ -206,7 +205,7 @@ private void loadNextFrame() {
 
     gifDecoder.advance();
     next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);
-    requestBuilder.clone().apply(signatureOf(new FrameSignature())).load(gifDecoder).into(next);
+    requestBuilder.clone().apply(signatureOf(getFrameSignature())).load(gifDecoder).into(next);
   }
 
   private void recycleFirstFrame() {
@@ -303,36 +302,9 @@ public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transiti
                 .override(width, height));
   }
 
-  // Visible for testing.
-  static class FrameSignature implements Key {
-    private final UUID uuid;
-
-    public FrameSignature() {
-      this(UUID.randomUUID());
-    }
-
-    // VisibleForTesting.
-    FrameSignature(UUID uuid) {
-      this.uuid = uuid;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof FrameSignature) {
-        FrameSignature other = (FrameSignature) o;
-        return other.uuid.equals(uuid);
-      }
-      return false;
-    }
-
-    @Override
-    public int hashCode() {
-      return uuid.hashCode();
-    }
-
-    @Override
-    public void updateDiskCacheKey(MessageDigest messageDigest) {
-      throw new UnsupportedOperationException("Not implemented");
-    }
+  static Key getFrameSignature() {
+    // Some devices seem to have crypto bugs that throw exceptions when you create a new UUID.
+    // See #1510.
+    return new ObjectKey(Math.random());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
index 5e8419a7c..2b09adb40 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.transcode;
 
 import android.graphics.Bitmap;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
 import java.io.ByteArrayOutputStream;
@@ -25,7 +26,7 @@ public BitmapBytesTranscoder(Bitmap.CompressFormat compressFormat, int quality)
   }
 
   @Override
-  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode) {
+  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {
     ByteArrayOutputStream os = new ByteArrayOutputStream();
     toTranscode.get().compress(compressFormat, quality, os);
     toTranscode.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
index 9fbbd4c05..03642bbe4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -5,6 +5,7 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.LazyBitmapDrawableResource;
@@ -28,7 +29,7 @@ public BitmapDrawableTranscoder(Resources resources, BitmapPool bitmapPool) {
   }
 
   @Override
-  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode) {
+  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {
     return LazyBitmapDrawableResource.obtain(resources, bitmapPool, toTranscode.get());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
index 94ff7864d..0bc3c12b3 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.bytes.BytesResource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
@@ -13,7 +14,7 @@
  */
 public class GifDrawableBytesTranscoder implements ResourceTranscoder<GifDrawable, byte[]> {
   @Override
-  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode) {
+  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode, Options options) {
     GifDrawable gifData = toTranscode.get();
     ByteBuffer byteBuffer = gifData.getBuffer();
     return new BytesResource(ByteBufferUtil.toBytes(byteBuffer));
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
index ad1c55c6e..e84bd6b00 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -15,5 +16,5 @@
    *
    * @param toTranscode The resource to transcode.
    */
-  Resource<R> transcode(Resource<Z> toTranscode);
+  Resource<R> transcode(Resource<Z> toTranscode, Options options);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
index 966e11ecf..0fd6d0964 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.transcode;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -16,7 +17,7 @@
   }
 
   @Override
-  public Resource<Z> transcode(Resource<Z> toTranscode) {
+  public Resource<Z> transcode(Resource<Z> toTranscode, Options options) {
     return toTranscode;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
index ab3713962..2d6702e53 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.support.annotation.NonNull;
+import android.support.v4.content.ContextCompat;
 
 /**
  * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
@@ -11,17 +12,15 @@
  * the required permission.
  */
 public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory {
+  private static final String NETWORK_PERMISSION = "android.permission.ACCESS_NETWORK_STATE";
 
   @NonNull
   public ConnectivityMonitor build(
       @NonNull Context context,
       @NonNull ConnectivityMonitor.ConnectivityListener listener) {
-    final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
-    final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
-    if (hasPermission) {
-      return new DefaultConnectivityMonitor(context, listener);
-    } else {
-      return new NullConnectivityMonitor();
-    }
+    int permissionResult = ContextCompat.checkSelfPermission(context, NETWORK_PERMISSION);
+    boolean hasPermission = permissionResult == PackageManager.PERMISSION_GRANTED;
+    return hasPermission
+        ? new DefaultConnectivityMonitor(context, listener) : new NullConnectivityMonitor();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index af6d7f599..44dfb5979 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -54,7 +54,7 @@ public void setRequestManager(RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
-  ActivityFragmentLifecycle getLifecycle() {
+  ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
 
@@ -159,6 +159,7 @@ private void unregisterFragmentWithRoot() {
     }
   }
 
+  @SuppressWarnings("deprecation")
   @Override
   public void onAttach(Activity activity) {
     super.onAttach(activity);
@@ -197,26 +198,6 @@ public void onDestroy() {
     unregisterFragmentWithRoot();
   }
 
-  @Override
-  public void onTrimMemory(int level) {
-    super.onTrimMemory(level);
-    // If an activity is re-created, onTrimMemory may be called before a manager is ever put.
-    // See #329.
-    if (requestManager != null) {
-      requestManager.onTrimMemory(level);
-    }
-  }
-
-  @Override
-  public void onLowMemory() {
-    super.onLowMemory();
-    // If an activity is re-created, onLowMemory may be called before a manager is ever put.
-    // See #329.
-    if (requestManager != null) {
-      requestManager.onLowMemory();
-    }
-  }
-
   @Override
   public String toString() {
     return super.toString() + "{parent=" + getParentFragmentUsingHint() + "}";
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index b07a23677..8fc6bab29 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -42,7 +42,6 @@
   // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
   // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
   private static final String FRAGMENT_INDEX_KEY = "key";
-  private static final String FRAGMENT_MANAGER_GET_FRAGMENT_KEY = "i";
 
   /**
    * The top application level RequestManager.
@@ -165,10 +164,9 @@ public RequestManager get(View view) {
     // Support Fragments.
     if (activity instanceof FragmentActivity) {
       Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
-      if (fragment == null) {
-        return get(activity);
+      if (fragment != null) {
+        return get(fragment);
       }
-      return get(fragment);
     }
 
     // Standard Fragments.
@@ -186,7 +184,8 @@ private static void findAllSupportFragmentsWithViews(
       return;
     }
     for (Fragment fragment : topLevelFragments) {
-      if (fragment.getView() == null) {
+      // getFragment()s in the support FragmentManager may contain null values, see #1991.
+      if (fragment == null || fragment.getView() == null) {
         continue;
       }
       result.put(fragment.getView(), fragment);
@@ -244,14 +243,29 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
 
   // TODO: Consider using an accessor class in the support library package to more directly retrieve
   // non-support Fragments.
+  @TargetApi(Build.VERSION_CODES.O)
   private void findAllFragmentsWithViews(
       android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      for (android.app.Fragment fragment : fragmentManager.getFragments()) {
+        if (fragment.getView() != null) {
+          result.put(fragment.getView(), fragment);
+          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+        }
+      }
+    } else {
+      findAllFragmentsWithViewsPreO(fragmentManager, result);
+    }
+  }
+
+  private void findAllFragmentsWithViewsPreO(
+      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
     int index = 0;
     while (true) {
       tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
       android.app.Fragment fragment = null;
       try {
-        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_MANAGER_GET_FRAGMENT_KEY);
+        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_INDEX_KEY);
       } catch (Exception e) {
         // This generates log spam from FragmentManager anyway.
       }
@@ -323,7 +337,7 @@ private RequestManager fragmentGet(Context context, android.app.FragmentManager
       // TODO(b/27524013): Factor out this Glide.get() call.
       Glide glide = Glide.get(context);
       requestManager =
-          factory.build(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -354,7 +368,7 @@ private RequestManager supportFragmentGet(Context context, FragmentManager fm,
       // TODO(b/27524013): Factor out this Glide.get() call.
       Glide glide = Glide.get(context);
       requestManager =
-          factory.build(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 78a66c6a3..f735e3618 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -25,8 +25,7 @@
       Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());
   // A set of requests that have not completed and are queued to be run again. We use this list to
   // maintain hard references to these requests to ensure that they are not garbage collected
-  // before
-  // they start running or while they are paused. See #346.
+  // before they start running or while they are paused. See #346.
   @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
   private final List<Request> pendingRequests = new ArrayList<>();
   private boolean isPaused;
@@ -53,8 +52,12 @@ void addRequest(Request request) {
    * request was removed or {@code false} if the request was not found.
    */
   public boolean clearRemoveAndRecycle(Request request) {
-    boolean isOwnedByUs =
-        request != null && (requests.remove(request) || pendingRequests.remove(request));
+    if (request == null) {
+      return false;
+    }
+    boolean isOwnedByUs = requests.remove(request);
+    // Avoid short circuiting.
+    isOwnedByUs = pendingRequests.remove(request) || isOwnedByUs;
     if (isOwnedByUs) {
       request.clear();
       request.recycle();
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index a61b3af9b..8bf7c0ec0 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -53,7 +53,7 @@ public void setRequestManager(RequestManager requestManager) {
     this.requestManager = requestManager;
   }
 
-  ActivityFragmentLifecycle getLifecycle() {
+  ActivityFragmentLifecycle getGlideLifecycle() {
     return lifecycle;
   }
 
@@ -188,16 +188,6 @@ public void onDestroy() {
     unregisterFragmentWithRoot();
   }
 
-  @Override
-  public void onLowMemory() {
-    super.onLowMemory();
-    // If an activity is re-created, onLowMemory may be called before a manager is ever put.
-    // See #329.
-    if (requestManager != null) {
-      requestManager.onLowMemory();
-    }
-  }
-
   @Override
   public String toString() {
     return super.toString() + "{parent=" + getParentFragmentUsingHint() + "}";
diff --git a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
index f543d3729..ccf368671 100644
--- a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 
 /**
@@ -16,7 +17,7 @@
  */
 public abstract class LibraryGlideModule implements RegistersComponents {
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     // Default empty impl.
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
index 1c6d8c9b8..f87a7409a 100644
--- a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
+++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.module;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 
 /**
@@ -15,7 +16,8 @@
    * <p> This method will be called once and only once per implementation. </p>
    *
    * @param context  An Application {@link android.content.Context}.
+   * @param glide The Glide singleton that is in the process of being initialized.
    * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
    */
-  void registerComponents(Context context, Registry registry);
+  void registerComponents(Context context, Glide glide, Registry registry);
 }
diff --git a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
index 29bd3af62..1cc3bba81 100644
--- a/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/EncoderRegistry.java
@@ -7,7 +7,7 @@
 import java.util.List;
 
 /**
- * Contains an unordered list of {@link Encoder}s capable of encoding arbitrary data types.
+ * Contains an ordered list of {@link Encoder}s capable of encoding arbitrary data types.
  */
 public class EncoderRegistry {
   // TODO: This registry should probably contain a put, rather than a list.
@@ -24,10 +24,14 @@
     return null;
   }
 
-  public synchronized <T> void add(Class<T> dataClass, Encoder<T> encoder) {
+  public synchronized <T> void append(Class<T> dataClass, Encoder<T> encoder) {
     encoders.add(new Entry<>(dataClass, encoder));
   }
 
+  public synchronized <T> void prepend(Class<T> dataClass, Encoder<T> encoder) {
+    encoders.add(0, new Entry<>(dataClass, encoder));
+  }
+
   private static final class Entry<T> {
     private final Class<T> dataClass;
     @Synthetic final Encoder<T> encoder;
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
index 877114e90..b7e95fd40 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceDecoderRegistry.java
@@ -3,7 +3,9 @@
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.util.Synthetic;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Contains an ordered list of {@link ResourceDecoder}s capable of decoding arbitrary data types
@@ -11,15 +13,35 @@
  */
 @SuppressWarnings("rawtypes")
 public class ResourceDecoderRegistry {
-  private final List<Entry<?, ?>> decoders = new ArrayList<>();
+  private final List<String> bucketPriorityList = new ArrayList<>();
+  private final Map<String, List<Entry<?, ?>>> decoders = new HashMap<>();
+
+  public synchronized void setBucketPriorityList(List<String> buckets) {
+    List<String> previousBuckets = new ArrayList<>(bucketPriorityList);
+    bucketPriorityList.clear();
+    bucketPriorityList.addAll(buckets);
+    for (String previousBucket : previousBuckets) {
+      if (!buckets.contains(previousBucket)) {
+        // Keep any buckets from the previous list that aren't included here, but but them at the
+        // end.
+        bucketPriorityList.add(previousBucket);
+      }
+    }
+  }
 
   @SuppressWarnings("unchecked")
   public synchronized <T, R> List<ResourceDecoder<T, R>> getDecoders(Class<T> dataClass,
       Class<R> resourceClass) {
     List<ResourceDecoder<T, R>> result = new ArrayList<>();
-    for (Entry<?, ?> entry : decoders) {
-      if (entry.handles(dataClass, resourceClass)) {
-        result.add((ResourceDecoder<T, R>) entry.decoder);
+    for (String bucket : bucketPriorityList) {
+      List<Entry<?, ?>> entries = decoders.get(bucket);
+      if (entries == null) {
+        continue;
+      }
+      for (Entry<?, ?> entry : entries) {
+        if (entry.handles(dataClass, resourceClass)) {
+          result.add((ResourceDecoder<T, R>) entry.decoder);
+        }
       }
     }
     // TODO: cache result list.
@@ -31,22 +53,41 @@
   public synchronized <T, R> List<Class<R>> getResourceClasses(Class<T> dataClass,
       Class<R> resourceClass) {
     List<Class<R>> result = new ArrayList<>();
-    for (Entry<?, ?> entry : decoders) {
-      if (entry.handles(dataClass, resourceClass)) {
-        result.add((Class<R>) entry.resourceClass);
+    for (String bucket : bucketPriorityList) {
+      List<Entry<?, ?>> entries = decoders.get(bucket);
+      if (entries == null) {
+        continue;
+      }
+      for (Entry<?, ?> entry : entries) {
+        if (entry.handles(dataClass, resourceClass)) {
+          result.add((Class<R>) entry.resourceClass);
+        }
       }
     }
     return result;
   }
 
-  public synchronized <T, R> void append(ResourceDecoder<T, R> decoder, Class<T> dataClass,
-      Class<R> resourceClass) {
-    decoders.add(new Entry<>(dataClass, resourceClass, decoder));
+  public synchronized <T, R> void append(
+      String bucket, ResourceDecoder<T, R> decoder, Class<T> dataClass, Class<R> resourceClass) {
+    getOrAddEntryList(bucket).add(new Entry<>(dataClass, resourceClass, decoder));
   }
 
-  public synchronized <T, R> void prepend(ResourceDecoder<T, R> decoder, Class<T> dataClass,
-      Class<R> resourceClass) {
-    decoders.add(0, new Entry<>(dataClass, resourceClass, decoder));
+  public synchronized <T, R> void prepend(
+      String bucket, ResourceDecoder<T, R> decoder, Class<T> dataClass, Class<R> resourceClass) {
+    getOrAddEntryList(bucket).add(0, new Entry<>(dataClass, resourceClass, decoder));
+  }
+
+  private synchronized List<Entry<?, ?>> getOrAddEntryList(String bucket) {
+    if (!bucketPriorityList.contains(bucket)) {
+      // Add this unspecified bucket as a low priority bucket.
+      bucketPriorityList.add(bucket);
+    }
+    List<Entry<?, ?>> entries = decoders.get(bucket);
+    if (entries == null) {
+      entries = new ArrayList<>();
+      decoders.put(bucket, entries);
+    }
+    return entries;
   }
 
   private static class Entry<T, R> {
diff --git a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
index e096cc759..a0e9e32d2 100644
--- a/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java
@@ -7,17 +7,21 @@
 import java.util.List;
 
 /**
- * Contains an unordered list of {@link ResourceEncoder}s capable of encoding arbitrary resource
+ * Contains an ordered list of {@link ResourceEncoder}s capable of encoding arbitrary resource
  * types.
  */
 public class ResourceEncoderRegistry {
   // TODO: this should probably be a put.
   final List<Entry<?>> encoders = new ArrayList<>();
 
-  public synchronized <Z> void add(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+  public synchronized <Z> void append(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
     encoders.add(new Entry<>(resourceClass, encoder));
   }
 
+  public synchronized <Z> void prepend(Class<Z> resourceClass, ResourceEncoder<Z> encoder) {
+    encoders.add(0, new Entry<>(resourceClass, encoder));
+  }
+
   @SuppressWarnings("unchecked")
   @Nullable
   public synchronized <Z> ResourceEncoder<Z> get(Class<Z> resourceClass) {
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
deleted file mode 100644
index 83fc305e5..000000000
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ /dev/null
@@ -1,1167 +0,0 @@
-package com.bumptech.glide.request;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.annotation.GlideOption;
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
-import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.CenterInside;
-import com.bumptech.glide.load.resource.bitmap.CircleCrop;
-import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
-import com.bumptech.glide.load.resource.bitmap.Downsampler;
-import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
-import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
-import com.bumptech.glide.signature.EmptySignature;
-import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Contains and exposes a variety of non type specific options that can be applied to a load in
- * Glide.
- *
- * <p> If {@link #lock()} has been called, this class will throw if any further mutations are
- * attempted. To unlock, use {@link #clone()}. </p>
- *
- * @param <CHILD> The concrete and <em>final</em> subclass.
- */
-public abstract class BaseRequestOptions<CHILD extends BaseRequestOptions<CHILD>>
-    implements Cloneable {
-  private static final int UNSET = -1;
-  private static final int SIZE_MULTIPLIER = 1 << 1;
-  private static final int DISK_CACHE_STRATEGY = 1 << 2;
-  private static final int PRIORITY = 1 << 3;
-  private static final int ERROR_PLACEHOLDER = 1 << 4;
-  private static final int ERROR_ID = 1 << 5;
-  private static final int PLACEHOLDER = 1 << 6;
-  private static final int PLACEHOLDER_ID = 1 << 7;
-  private static final int IS_CACHEABLE = 1 << 8;
-  private static final int OVERRIDE = 1 << 9;
-  private static final int SIGNATURE = 1 << 10;
-  private static final int TRANSFORMATION = 1 << 11;
-  private static final int RESOURCE_CLASS = 1 << 12;
-  private static final int FALLBACK = 1 << 13;
-  private static final int FALLBACK_ID = 1 << 14;
-  private static final int THEME = 1 << 15;
-  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
-  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
-  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
-  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
-
-  private int fields;
-
-  private float sizeMultiplier = 1f;
-  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
-  private Priority priority = Priority.NORMAL;
-  private Drawable errorPlaceholder;
-  private int errorId;
-  private Drawable placeholderDrawable;
-  private int placeholderId;
-  private boolean isCacheable = true;
-  private int overrideHeight = UNSET;
-  private int overrideWidth = UNSET;
-  private Key signature = EmptySignature.obtain();
-  private boolean isTransformationRequired;
-  private boolean isTransformationAllowed = true;
-  private Drawable fallbackDrawable;
-  private int fallbackId;
-
-  private Options options = new Options();
-  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-  private Class<?> resourceClass = Object.class;
-  private boolean isLocked;
-  private Resources.Theme theme;
-  private boolean isAutoCloneEnabled;
-  private boolean useUnlimitedSourceGeneratorsPool;
-  private boolean onlyRetrieveFromCache;
-
-  /**
-   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
-   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
-   * (particularly {@link android.graphics.Bitmap}s on devices with overly dense screens.
-   *
-   * @param sizeMultiplier The multiplier to apply to the
-   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
-   *                       loading the resource.
-   * @return This request builder.
-   */
-  public final CHILD sizeMultiplier(float sizeMultiplier) {
-    if (isAutoCloneEnabled) {
-      return clone().sizeMultiplier(sizeMultiplier);
-    }
-
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-    }
-    this.sizeMultiplier = sizeMultiplier;
-    fields |= SIZE_MULTIPLIER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  public final CHILD useUnlimitedSourceGeneratorsPool(boolean flag) {
-    if (isAutoCloneEnabled) {
-      return clone().useUnlimitedSourceGeneratorsPool(flag);
-    }
-
-    this.useUnlimitedSourceGeneratorsPool = flag;
-    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * If set to true, will only load an item if found in the cache, and will not fetch from source.
-   */
-  public final CHILD onlyRetrieveFromCache(boolean flag) {
-    if (isAutoCloneEnabled) {
-      return clone().onlyRetrieveFromCache(flag);
-    }
-
-    this.onlyRetrieveFromCache = flag;
-    fields |= ONLY_RETRIEVE_FROM_CACHE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load.
-   *
-   * <p> Defaults to {@link com.bumptech.glide.load.engine.DiskCacheStrategy#AUTOMATIC}. </p>
-   *
-   * <p> For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} is
-   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
-   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#DATA} or
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}. </p>
-   *
-   * @param strategy The strategy to use.
-   * @return This request builder.
-   */
-  public final CHILD diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
-    if (isAutoCloneEnabled) {
-      return clone().diskCacheStrategy(strategy);
-    }
-    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
-    fields |= DISK_CACHE_STRATEGY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the priority for this load.
-   *
-   * @param priority A priority.
-   * @return This request builder.
-   */
-  public final CHILD priority(@NonNull Priority priority) {
-    if (isAutoCloneEnabled) {
-      return clone().priority(priority);
-    }
-
-    this.priority = Preconditions.checkNotNull(priority);
-    fields |= PRIORITY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD placeholder(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(drawable);
-    }
-
-    this.placeholderDrawable = drawable;
-    fields |= PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resource to
-   * display while a resource is loading.
-   *
-   * @param resourceId The id of the resource to use as a placeholder
-   * @return This request builder.
-   */
-  public final CHILD placeholder(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(resourceId);
-    }
-
-    this.placeholderId = resourceId;
-    fields |= PLACEHOLDER_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
-   * error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD fallback(Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(drawable);
-    }
-
-    this.fallbackDrawable = drawable;
-    fields |= FALLBACK;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
-   * the error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param resourceId The id of the resource to use as a fallback.
-   * @return This request builder.
-   */
-  public final CHILD fallback(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(resourceId);
-    }
-
-    this.fallbackId = resourceId;
-    fields |= FALLBACK_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a {@link Drawable} to display if a load fails.
-   *
-   * @param drawable The drawable to display.
-   * @return This request builder.
-   */
-  public final CHILD error(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().error(drawable);
-    }
-
-    this.errorPlaceholder = drawable;
-    fields |= ERROR_PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if a load fails.
-   *
-   * @param resourceId The id of the resource to use as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD error(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().error(resourceId);
-    }
-    this.errorId = resourceId;
-    fields |= ERROR_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
-   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
-   * {@link #fallback(Drawable)}.
-   *
-   * @param theme The theme to use when loading Drawables.
-   * @return this request builder.
-   */
-  public final CHILD theme(Resources.Theme theme) {
-    if (isAutoCloneEnabled) {
-      return clone().theme(theme);
-    }
-
-    this.theme = theme;
-    fields |= THEME;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Allows the loaded resource to skip the memory cache.
-   *
-   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
-   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
-   *
-   * @param skip True to allow the resource to skip the memory cache.
-   * @return This request builder.
-   */
-  public final CHILD skipMemoryCache(boolean skip) {
-    if (isAutoCloneEnabled) {
-      return clone().skipMemoryCache(true);
-    }
-
-    this.isCacheable = !skip;
-    fields |= IS_CACHEABLE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given values. This is useful for thumbnails, and should only be used for other cases when you
-   * need a very specific image size.
-   *
-   * @param width  The width in pixels to use to load the resource.
-   * @param height The height in pixels to use to load the resource.
-   * @return This request builder.
-   */
-  public final CHILD override(int width, int height) {
-    if (isAutoCloneEnabled) {
-      return clone().override(width, height);
-    }
-
-    this.overrideWidth = width;
-    this.overrideHeight = height;
-    fields |= OVERRIDE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given size.
-   *
-   * @see #override(int, int)
-   * @param size The width and height to use.
-   * @return This request builder.
-   */
-  public final CHILD override(int size) {
-    return override(size, size);
-  }
-
-  /**
-   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
-   * more control over when cached data is invalidated.
-   *
-   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
-   *
-   * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current
-   *                  state of the model that will be mixed in to the cache key.
-   * @return This request builder.
-   * @see com.bumptech.glide.signature.ObjectKey
-   */
-  public final CHILD signature(@NonNull Key signature) {
-    if (isAutoCloneEnabled) {
-      return clone().signature(signature);
-    }
-
-    this.signature = Preconditions.checkNotNull(signature);
-    fields |= SIGNATURE;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   *
-   * <p> Even if this object was locked, the cloned object returned from this method will not be
-   * locked. </p>
-   */
-  @GlideOption(skipStaticMethod = true)
-  @SuppressWarnings("unchecked")
-  @Override
-  public final CHILD clone() {
-    try {
-      BaseRequestOptions<CHILD> result = (BaseRequestOptions<CHILD>) super.clone();
-      result.options = new Options();
-      result.options.putAll(options);
-      result.transformations = new HashMap<>();
-      result.transformations.putAll(transformations);
-      result.isLocked = false;
-      result.isAutoCloneEnabled = false;
-      return (CHILD) result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  @GlideOption(staticMethodName = "optionOf")
-  public final <T> CHILD set(@NonNull Option<T> option, @NonNull T value) {
-    if (isAutoCloneEnabled) {
-      return clone().set(option, value);
-    }
-
-    Preconditions.checkNotNull(option);
-    Preconditions.checkNotNull(value);
-    options.set(option, value);
-    return selfOrThrowIfLocked();
-  }
-
-  @GlideOption(staticMethodName = "decodeTypeOf")
-  public final CHILD decode(@NonNull Class<?> resourceClass) {
-    if (isAutoCloneEnabled) {
-      return clone().decode(resourceClass);
-    }
-
-    this.resourceClass = Preconditions.checkNotNull(resourceClass);
-    fields |= RESOURCE_CLASS;
-    return selfOrThrowIfLocked();
-  }
-
-  public final boolean isTransformationAllowed() {
-    return isTransformationAllowed;
-  }
-
-  public final boolean isTransformationSet() {
-    return isSet(TRANSFORMATION);
-  }
-
-  public final boolean isLocked() {
-    return isLocked;
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
-   */
-  public CHILD encodeFormat(@NonNull Bitmap.CompressFormat format) {
-    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_QUALITY}.
-   */
-  public CHILD encodeQuality(int quality) {
-    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
-  }
-
-  /**
-   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
-   * {@link Downsampler}.
-   *
-   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
-   * decoded using a decoder that cannot control the format
-   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
-   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
-   * image has alpha).
-   */
-  public CHILD format(@NonNull DecodeFormat format) {
-    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the time position of the frame to extract from a video.
-   *
-   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
-   *                        Android framework implementation return a representative frame.
-   */
-  public CHILD frame(long frameTimeMicros) {
-    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
-  }
-
-  /**
-   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
-   * {@link Downsampler}.
-   */
-  public CHILD downsample(@NonNull DownsampleStrategy strategy) {
-    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerCrop(android.content.Context)
-   *
-   * @deprecated Use {@link #optionalCenterCrop()}.
-   */
-  @Deprecated
-  @GlideOption(
-      staticMethodName = "optionalCenterCropTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD optionalCenterCrop(@SuppressWarnings("unused") Context context) {
-    return optionalCenterCrop();
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerCrop()
-   */
-  @GlideOption(
-      staticMethodName = "optionalCenterCropTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD optionalCenterCrop() {
-    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>this will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalCenterCrop(android.content.Context)
-   *
-   * @deprecated Use {@link #centerCrop()}.
-   */
-  @Deprecated
-  @GlideOption(
-      staticMethodName = "centerCropTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD centerCrop(@SuppressWarnings("unused") Context context) {
-    return centerCrop();
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>this will override previous calls to {@link #dontTransform()} ()}.
-   *
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalCenterCrop()
-   */
-  @GlideOption(
-      staticMethodName = "centerCropTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD centerCrop() {
-    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #fitCenter(android.content.Context)
-   *
-   * @deprecated Use {@link #optionalFitCenter()}.
-   */
-  @Deprecated
-  @GlideOption(
-      staticMethodName = "optionalFitCenterTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD optionalFitCenter(@SuppressWarnings("unused") Context context) {
-    return optionalFitCenter();
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #fitCenter()
-   */
-  @GlideOption(
-      staticMethodName = "optionalFitCenterTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD optionalFitCenter() {
-    return optionalTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalFitCenter()
-   */
-  @GlideOption(
-      staticMethodName = "fitCenterTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD fitCenter() {
-    return transform(DownsampleStrategy.FIT_CENTER, new FitCenter());
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerInside()
-   *
-   * @deprecated Use {@link #optionalCenterInside()}
-   */
-  @Deprecated
-  @GlideOption(
-      staticMethodName = "optionalCenterInsideTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD optionalCenterInside(@SuppressWarnings("unused") Context context) {
-    return optionalCenterInside();
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerInside()
-   */
-  @GlideOption(
-      staticMethodName = "optionalCenterInsideTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD optionalCenterInside() {
-    return optionalTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalCenterInside()
-   */
-  public CHILD centerInside() {
-    return transform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link Context}.
-   * @see #optionalTransform(Context, Transformation)
-   * @see #circleCrop(Context)
-   *
-   * @deprecated use {@link #optionalCircleCrop()}.
-   */
-  @Deprecated
-  @GlideOption(
-      staticMethodName = "optionalCircleCropTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD optionalCircleCrop(@SuppressWarnings("unused") Context context) {
-    return optionalCircleCrop();
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #optionalTransform(Transformation)
-   * @see #circleCrop()
-   */
-  @GlideOption(
-      staticMethodName = "optionalCircleCropTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD optionalCircleCrop() {
-    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
-   * an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link Context}.
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterCrop(Context)
-   *
-   * @deprecated Use {@link #circleCrop()}.
-   */
-  @Deprecated
-  @GlideOption(
-      staticMethodName = "circleCropTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD circleCrop(@SuppressWarnings("unused") Context context) {
-    return circleCrop();
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
-   * an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterCrop()
-   */
-  @GlideOption(
-      staticMethodName = "circleCropTransform",
-      memoizeStaticMethod = true
-  )
-  public CHILD circleCrop() {
-    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
-  }
-
-  // calling optionalTransform() on the result of clone() requires greater access.
-  @SuppressWarnings("WeakerAccess")
-  final CHILD optionalTransform(DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return optionalTransform(transformation);
-  }
-
-  // calling transform() on the result of clone() requires greater access.
-  @SuppressWarnings("WeakerAccess")
-  final CHILD transform(DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return transform(transformation);
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #optionalTransform(com.bumptech.glide.load.Transformation)
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  @GlideOption(staticMethodName = "bitmapTransform")
-  public CHILD transform(@NonNull Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(transformation);
-    }
-
-    optionalTransform(transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context        Any {@link android.content.Context}.
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #transform(android.content.Context, com.bumptech.glide.load.Transformation)
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   *
-   * @deprecated Use {@link #optionalTransform(Transformation)}
-   */
-  @Deprecated
-  @GlideOption(staticMethodName = "optionalBitmapTransform")
-  public CHILD optionalTransform(Context context, Transformation<Bitmap> transformation) {
-    return optionalTransform(transformation);
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #transform(com.bumptech.glide.load.Transformation)
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   */
-  @GlideOption(staticMethodName = "optionalBitmapTransform")
-  public CHILD optionalTransform(Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(transformation);
-    }
-
-    optionalTransform(Bitmap.class, transformation);
-    // TODO: remove BitmapDrawable decoder and this transformation.
-    optionalTransform(BitmapDrawable.class,
-        new BitmapDrawableTransformation(transformation));
-    optionalTransform(GifDrawable.class, new GifDrawableTransformation(transformation));
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and allows unknown resource types to be ignored.
-   *
-   * <p> Users can apply different transformations for each resource class. Applying a
-   * {@link com.bumptech.glide.load.Transformation} for a resource type that already has a
-   * {@link com.bumptech.glide.load.Transformation} will override the previous call. </p>
-   *
-   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
-   * an unknown resource class will throw an exception. To allow unknown types, users must always
-   * call the optional version of each method. </p>
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   */
-  public final <T> CHILD optionalTransform(Class<T> resourceClass,
-      Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(resourceClass, transformation);
-    }
-
-    Preconditions.checkNotNull(resourceClass);
-    Preconditions.checkNotNull(transformation);
-    transformations.put(resourceClass, transformation);
-    fields |= TRANSFORMATION;
-    isTransformationAllowed = true;
-    fields |= TRANSFORMATION_ALLOWED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and throws if asked to transform an unknown resource type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public final <T> CHILD transform(Class<T> resourceClass, Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(resourceClass, transformation);
-    }
-
-    optionalTransform(resourceClass, transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Removes all applied {@link com.bumptech.glide.load.Transformation Transformations} for all
-   * resource classes and allows unknown resource types to be transformed without throwing an
-   * exception.
-   */
-  @GlideOption(
-      staticMethodName = "noTransformation",
-      memoizeStaticMethod = true
-  )
-  public final CHILD dontTransform() {
-    if (isAutoCloneEnabled) {
-      return clone().dontTransform();
-    }
-
-    transformations.clear();
-    fields &= ~TRANSFORMATION;
-    isTransformationRequired = false;
-    fields &= ~TRANSFORMATION_REQUIRED;
-    isTransformationAllowed = false;
-    fields |= TRANSFORMATION_ALLOWED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Disables resource decoders that return animated resources so any resource returned will be
-   * static.
-   *
-   * <p> To disable transitions (fades etc) use
-   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
-   */
-  public final CHILD dontAnimate() {
-    if (isAutoCloneEnabled) {
-      return clone().dontAnimate();
-    }
-
-    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
-    set(StreamGifDecoder.DISABLE_ANIMATION, true);
-    return selfOrThrowIfLocked();
-  }
-
-  @GlideOption(skipStaticMethod = true)
-  public final CHILD apply(BaseRequestOptions<?> other) {
-    if (isAutoCloneEnabled) {
-      return clone().apply(other);
-    }
-
-    if (isSet(other.fields, SIZE_MULTIPLIER)) {
-      sizeMultiplier = other.sizeMultiplier;
-    }
-    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
-      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
-    }
-    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
-      diskCacheStrategy = other.diskCacheStrategy;
-    }
-    if (isSet(other.fields, PRIORITY)) {
-      priority = other.priority;
-    }
-    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
-      errorPlaceholder = other.errorPlaceholder;
-    }
-    if (isSet(other.fields, ERROR_ID)) {
-      errorId = other.errorId;
-    }
-    if (isSet(other.fields, PLACEHOLDER)) {
-      placeholderDrawable = other.placeholderDrawable;
-    }
-    if (isSet(other.fields, PLACEHOLDER_ID)) {
-      placeholderId = other.placeholderId;
-    }
-    if (isSet(other.fields, IS_CACHEABLE)) {
-      isCacheable = other.isCacheable;
-    }
-    if (isSet(other.fields, OVERRIDE)) {
-      overrideWidth = other.overrideWidth;
-      overrideHeight = other.overrideHeight;
-    }
-    if (isSet(other.fields, SIGNATURE)) {
-      signature = other.signature;
-    }
-    if (isSet(other.fields, RESOURCE_CLASS)) {
-      resourceClass = other.resourceClass;
-    }
-    if (isSet(other.fields, FALLBACK)) {
-      fallbackDrawable = other.fallbackDrawable;
-    }
-    if (isSet(other.fields, FALLBACK_ID)) {
-      fallbackId = other.fallbackId;
-    }
-    if (isSet(other.fields, THEME)) {
-      theme = other.theme;
-    }
-    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
-      isTransformationAllowed = other.isTransformationAllowed;
-    }
-    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
-      isTransformationRequired = other.isTransformationRequired;
-    }
-    if (isSet(other.fields, TRANSFORMATION)) {
-      transformations.putAll(other.transformations);
-    }
-    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
-      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
-    }
-
-    // Applying options with dontTransform() is expected to clear our transformations.
-    if (!isTransformationAllowed) {
-      transformations.clear();
-      fields &= ~TRANSFORMATION;
-      isTransformationRequired = false;
-      fields &= ~TRANSFORMATION_REQUIRED;
-    }
-
-    fields |= other.fields;
-    options.putAll(other.options);
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Throws if any further mutations are attempted.
-   *
-   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
-   */
-  @SuppressWarnings("unchecked")
-  @GlideOption(skipStaticMethod = true)
-  public final CHILD lock() {
-    isLocked = true;
-    // This is the only place we should not check locked.
-    return (CHILD) this;
-  }
-
-  /**
-   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
-   * before the mutation resulting in all methods returning a new Object and leaving the original
-   * locked object unmodified.
-   *
-   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
-   * are mutable and are not locked.
-   */
-  public final CHILD autoClone() {
-    if (isLocked && !isAutoCloneEnabled) {
-      throw new IllegalStateException("You cannot auto lock an already locked options object"
-          + ", try clone() first");
-    }
-    isAutoCloneEnabled = true;
-    return lock();
-  }
-
-  @SuppressWarnings("unchecked")
-  private CHILD selfOrThrowIfLocked() {
-    if (isLocked) {
-      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
-    }
-    return (CHILD) this;
-  }
-
-  public final Map<Class<?>, Transformation<?>> getTransformations() {
-    return transformations;
-  }
-
-  public final boolean isTransformationRequired() {
-    return isTransformationRequired;
-  }
-
-  public final Options getOptions() {
-    return options;
-  }
-
-  public final Class<?> getResourceClass() {
-    return resourceClass;
-  }
-
-  public final DiskCacheStrategy getDiskCacheStrategy() {
-    return diskCacheStrategy;
-  }
-
-  public final Drawable getErrorPlaceholder() {
-    return errorPlaceholder;
-  }
-
-  public final int getErrorId() {
-    return errorId;
-  }
-
-  public final int getPlaceholderId() {
-    return placeholderId;
-  }
-
-  public final Drawable getPlaceholderDrawable() {
-    return placeholderDrawable;
-  }
-
-  public final int getFallbackId() {
-    return fallbackId;
-  }
-
-  public final Drawable getFallbackDrawable() {
-    return fallbackDrawable;
-  }
-
-  public final Resources.Theme getTheme() {
-    return theme;
-  }
-
-  public final boolean isMemoryCacheable() {
-    return isCacheable;
-  }
-
-  public final Key getSignature() {
-    return signature;
-  }
-
-  public final boolean isPrioritySet() {
-    return isSet(PRIORITY);
-  }
-
-  public final Priority getPriority() {
-    return priority;
-  }
-
-  public final int getOverrideWidth() {
-    return overrideWidth;
-  }
-
-  public final boolean isValidOverride() {
-    return Util.isValidDimensions(overrideWidth, overrideHeight);
-  }
-
-  public final int getOverrideHeight() {
-    return overrideHeight;
-  }
-
-  public final float getSizeMultiplier() {
-    return sizeMultiplier;
-  }
-
-  private boolean isSet(int flag) {
-    return isSet(fields, flag);
-  }
-
-  private static boolean isSet(int fields, int flag) {
-    return (fields & flag) != 0;
-  }
-
-  public final boolean getUseUnlimitedSourceGeneratorsPool() {
-    return useUnlimitedSourceGeneratorsPool;
-  }
-
-  public final boolean getOnlyRetrieveFromCache() {
-    return onlyRetrieveFromCache;
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/Request.java b/library/src/main/java/com/bumptech/glide/request/Request.java
index ffa21d02f..7427ca434 100644
--- a/library/src/main/java/com/bumptech/glide/request/Request.java
+++ b/library/src/main/java/com/bumptech/glide/request/Request.java
@@ -57,4 +57,18 @@
    * Recycles the request object and releases its resources.
    */
   void recycle();
+
+  /**
+   * Returns {@code true} if this {@link Request} is equivalent to the given {@link Request} (has
+   * all of the same options and sizes).
+   *
+   * <p>This method is identical to {@link #equals(Object)} except that it's specific to
+   * {@link Request} subclasses. We do not use {@link #equals(Object)} directly because we track
+   * {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate to
+   * have two different {@link Request} objects for two different
+   * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different
+   * method let's us selectively compare {@link Request} objects to each other when it's useful in
+   * specific scenarios.
+   */
+  boolean isEquivalentTo(Request other);
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 3280c9249..e5a1ec152 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -99,7 +99,7 @@ public synchronized boolean isCancelled() {
 
   @Override
   public synchronized boolean isDone() {
-    return isCancelled || resultReceived;
+    return isCancelled || resultReceived || loadFailed;
   }
 
   @Override
@@ -125,6 +125,11 @@ public void getSize(SizeReadyCallback cb) {
     cb.onSizeReady(width, height);
   }
 
+  @Override
+  public void removeCallback(SizeReadyCallback cb) {
+    // Do nothing because we do not retain references to SizeReadyCallbacks.
+  }
+
   /**
    * {@inheritDoc}
    */
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index 0644473d2..a6156b495 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.request;
 
+import android.graphics.drawable.Drawable;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
@@ -13,9 +14,10 @@
 public interface RequestListener<R> {
 
   /**
-   * Called when an exception occurs during a load. Will only be called if we currently want to
-   * display an image for the given model in the given target. It is recommended to create a single
-   * instance per activity/fragment rather than instantiate a new object for each call to {@code
+   * Called when an exception occurs during a load, immediately before
+   * {@link Target#onLoadFailed(Drawable)}. Will only be called if we currently want to display an
+   * image for the given model in the given target. It is recommended to create a single instance
+   * per activity/fragment rather than instantiate a new object for each call to {@code
    * Glide.load()} to avoid object churn.
    *
    * <p> It is safe to reload this or a different model or change what is displayed in the target at
@@ -31,7 +33,7 @@
    * </p>
    *
    * <p> Note - if you want to reload this or any other model after an exception, you will need to
-   * include all relevant builder calls (like centerCrop, placeholder etc). </p>
+   * include all relevant builder calls (like centerCrop, placeholder etc).
    *
    * @param e               The maybe {@code null} exception containing information about why the
    *                        request failed.
@@ -45,7 +47,7 @@ boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
       boolean isFirstResource);
 
   /**
-   * Called when a load completes successfully, immediately after {@link
+   * Called when a load completes successfully, immediately before {@link
    * Target#onResourceReady(Object, com.bumptech.glide.request.transition.Transition)}.
    *
    * @param resource          The resource that was loaded for the target.
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 6b7b06e75..a5cbcc053 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -1,46 +1,132 @@
 package com.bumptech.glide.request;
 
-import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.MultiTransformation;
 import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;
+import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
+import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CenterInside;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.FitCenter;
+import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
+import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
+import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
- * The standard concrete implementation of {@link com.bumptech.glide.request.BaseRequestOptions}.
- *
- * <p> Uses with custom types, transformations, or options can subclass and customize. {@link
- * com.bumptech.glide.request.BaseRequestOptions}. </p>
+ * Provides type independent options to customize loads with Glide.
  */
 @SuppressWarnings({"PMD.UseUtilityClass", "unused"})
-public final class RequestOptions extends BaseRequestOptions<RequestOptions> {
+public class RequestOptions implements Cloneable {
+  private static final int UNSET = -1;
+  private static final int SIZE_MULTIPLIER = 1 << 1;
+  private static final int DISK_CACHE_STRATEGY = 1 << 2;
+  private static final int PRIORITY = 1 << 3;
+  private static final int ERROR_PLACEHOLDER = 1 << 4;
+  private static final int ERROR_ID = 1 << 5;
+  private static final int PLACEHOLDER = 1 << 6;
+  private static final int PLACEHOLDER_ID = 1 << 7;
+  private static final int IS_CACHEABLE = 1 << 8;
+  private static final int OVERRIDE = 1 << 9;
+  private static final int SIGNATURE = 1 << 10;
+  private static final int TRANSFORMATION = 1 << 11;
+  private static final int RESOURCE_CLASS = 1 << 12;
+  private static final int FALLBACK = 1 << 13;
+  private static final int FALLBACK_ID = 1 << 14;
+  private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
+  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
 
+  @Nullable
   private static RequestOptions skipMemoryCacheTrueOptions;
+  @Nullable
   private static RequestOptions skipMemoryCacheFalseOptions;
+  @Nullable
   private static RequestOptions fitCenterOptions;
+  @Nullable
   private static RequestOptions centerInsideOptions;
+  @Nullable
   private static RequestOptions centerCropOptions;
+  @Nullable
   private static RequestOptions circleCropOptions;
+  @Nullable
   private static RequestOptions noTransformOptions;
+  @Nullable
   private static RequestOptions noAnimationOptions;
 
+  private int fields;
+  private float sizeMultiplier = 1f;
+  @NonNull
+  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
+  @NonNull
+  private Priority priority = Priority.NORMAL;
+  @Nullable
+  private Drawable errorPlaceholder;
+  private int errorId;
+  @Nullable
+  private Drawable placeholderDrawable;
+  private int placeholderId;
+  private boolean isCacheable = true;
+  private int overrideHeight = RequestOptions.UNSET;
+  private int overrideWidth = RequestOptions.UNSET;
+  @NonNull
+  private Key signature = EmptySignature.obtain();
+  private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
+  @Nullable
+  private Drawable fallbackDrawable;
+  private int fallbackId;
+  @NonNull
+  private Options options = new Options();
+  @NonNull
+  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+  @NonNull
+  private Class<?> resourceClass = Object.class;
+  private boolean isLocked;
+  @Nullable
+  private Resources.Theme theme;
+  private boolean isAutoCloneEnabled;
+  private boolean useUnlimitedSourceGeneratorsPool;
+  private boolean onlyRetrieveFromCache;
+  private boolean isScaleOnlyOrNoTransform = true;
+
   /**
    * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions sizeMultiplierOf(float sizeMultiplier) {
     return new RequestOptions().sizeMultiplier(sizeMultiplier);
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
+   * Returns a {@link RequestOptions} object with {@link #diskCacheStrategy(DiskCacheStrategy)} set.
    */
+  @CheckResult
   public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) {
     return new RequestOptions().diskCacheStrategy(diskCacheStrategy);
   }
@@ -48,6 +134,8 @@ public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy disk
   /**
    * Returns a {@link RequestOptions} object with {@link #priority(Priority)}} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions priorityOf(@NonNull Priority priority) {
     return new RequestOptions().priority(priority);
   }
@@ -55,6 +143,7 @@ public static RequestOptions priorityOf(@NonNull Priority priority) {
   /**
    * Returns a {@link RequestOptions} object with {@link #placeholder(Drawable)} set.
    */
+  @CheckResult
   public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
     return new RequestOptions().placeholder(placeholder);
   }
@@ -62,6 +151,7 @@ public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
   /**
    * Returns a {@link RequestOptions} object with {@link #placeholder(int)} set.
    */
+  @CheckResult
   public static RequestOptions placeholderOf(int placeholderId) {
     return new RequestOptions().placeholder(placeholderId);
   }
@@ -69,6 +159,7 @@ public static RequestOptions placeholderOf(int placeholderId) {
   /**
    * Returns a {@link RequestOptions} object with {@link #error(Drawable)} set.
    */
+  @CheckResult
   public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
     return new RequestOptions().error(errorDrawable);
   }
@@ -76,6 +167,7 @@ public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
   /**
    * Returns a {@link RequestOptions} object with {@link #error(int)}} set.
    */
+  @CheckResult
   public static RequestOptions errorOf(int errorId) {
     return new RequestOptions().error(errorId);
   }
@@ -83,6 +175,7 @@ public static RequestOptions errorOf(int errorId) {
   /**
    * Returns a {@link RequestOptions} object with {@link #skipMemoryCache(boolean)} set.
    */
+  @CheckResult
   public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
     if (skipMemoryCache) {
       if (skipMemoryCacheTrueOptions == null) {
@@ -100,6 +193,8 @@ public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
   /**
    * Returns a {@link RequestOptions} object with {@link #override(int, int)}} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions overrideOf(int width, int height) {
     return new RequestOptions().override(width, height);
   }
@@ -108,6 +203,8 @@ public static RequestOptions overrideOf(int width, int height) {
    * Returns a {@link RequestOptions} with {@link #override(int, int)} set where both the width and
    * height are the given size.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions overrideOf(int size) {
     return overrideOf(size, size);
   }
@@ -115,6 +212,7 @@ public static RequestOptions overrideOf(int size) {
   /**
    * Returns a {@link RequestOptions} object with {@link #signature} set.
    */
+  @CheckResult
   public static RequestOptions signatureOf(@NonNull Key signature) {
     return new RequestOptions().signature(signature);
   }
@@ -122,6 +220,7 @@ public static RequestOptions signatureOf(@NonNull Key signature) {
   /**
    * Returns a {@link RequestOptions} object with {@link #fitCenter()} set.
    */
+  @CheckResult
   public static RequestOptions fitCenterTransform() {
     if (fitCenterOptions == null) {
       fitCenterOptions = new RequestOptions()
@@ -134,6 +233,8 @@ public static RequestOptions fitCenterTransform() {
   /**
    * Returns a {@link RequestOptions} object with {@link #centerInside()} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions centerInsideTransform() {
     if (centerInsideOptions == null) {
       centerInsideOptions = new RequestOptions()
@@ -143,19 +244,11 @@ public static RequestOptions centerInsideTransform() {
     return centerInsideOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
-   *
-   * @deprecated Use {@link #centerCropTransform()}.
-   */
-  @Deprecated
-  public static RequestOptions centerCropTransform(Context context) {
-    return centerCropTransform();
-  }
-
   /**
    * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions centerCropTransform() {
     if (centerCropOptions == null) {
       centerCropOptions = new RequestOptions()
@@ -168,6 +261,8 @@ public static RequestOptions centerCropTransform() {
   /**
    * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions circleCropTransform() {
     if (circleCropOptions == null) {
       circleCropOptions = new RequestOptions()
@@ -177,20 +272,11 @@ public static RequestOptions circleCropTransform() {
     return circleCropOptions;
   }
 
-  /**
-   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
-   *
-   * @deprecated Use {@link #bitmapTransform(Transformation)}.
-   */
-  @Deprecated
-  public static RequestOptions bitmapTransform(
-      Context context, @NonNull Transformation<Bitmap> transformation) {
-    return bitmapTransform(transformation);
-  }
-
   /**
    * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
     return new RequestOptions().transform(transformation);
   }
@@ -198,7 +284,9 @@ public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> tra
   /**
    * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
    */
-  public static RequestOptions noTransform() {
+  @SuppressWarnings("WeakerAccess")
+  @CheckResult
+  public static RequestOptions noTransformation() {
     if (noTransformOptions == null) {
       noTransformOptions = new RequestOptions()
           .dontTransform()
@@ -211,6 +299,7 @@ public static RequestOptions noTransform() {
    * Returns a {@link RequestOptions} object with the given {@link Option} set via
    * {@link #set(Option, Object)}.
    */
+  @CheckResult
   public static <T> RequestOptions option(@NonNull Option<T> option, @NonNull T value) {
     return new RequestOptions().set(option, value);
   }
@@ -218,6 +307,7 @@ public static RequestOptions noTransform() {
   /**
    * Returns a {@link RequestOptions} object with {@link #decode(Class)} set.
    */
+  @CheckResult
   public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
     return new RequestOptions().decode(resourceClass);
   }
@@ -225,6 +315,8 @@ public static RequestOptions decodeTypeOf(@NonNull Class<?> resourceClass) {
   /**
    * Returns a {@link RequestOptions} object with {@link #format(DecodeFormat)} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions formatOf(@NonNull DecodeFormat format) {
     return new RequestOptions().format(format);
   }
@@ -232,6 +324,8 @@ public static RequestOptions formatOf(@NonNull DecodeFormat format) {
   /**
    * Returns a {@link RequestOptions} object with {@link #frame(long)} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions frameOf(long frameTimeMicros) {
     return new RequestOptions().frame(frameTimeMicros);
   }
@@ -239,14 +333,26 @@ public static RequestOptions frameOf(long frameTimeMicros) {
   /**
    * Returns a {@link RequestOptions} object with {@link #downsample(DownsampleStrategy)} set.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy) {
     return new RequestOptions().downsample(strategy);
   }
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #timeout(int)} set.
+   */
+  @CheckResult
+  public static RequestOptions timeoutOf(int timeout) {
+    return new RequestOptions().timeout(timeout);
+  }
+
   /**
    * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
    * #encodeQuality(int)} called with the given quality.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions encodeQualityOf(int quality) {
     return new RequestOptions().encodeQuality(quality);
   }
@@ -255,6 +361,8 @@ public static RequestOptions encodeQualityOf(int quality) {
    * Returns a {@link com.bumptech.glide.request.RequestOptions} with {@link
    * #encodeFormat(android.graphics.Bitmap.CompressFormat)} called with the given format.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat format) {
     return new RequestOptions().encodeFormat(format);
   }
@@ -263,6 +371,8 @@ public static RequestOptions encodeFormatOf(@NonNull Bitmap.CompressFormat forma
    * Returns a new {@link com.bumptech.glide.request.RequestOptions} with {@link #dontAnimate()}
    * called.
    */
+  @SuppressWarnings("WeakerAccess") // Public API
+  @CheckResult
   public static RequestOptions noAnimation() {
     if (noAnimationOptions == null) {
       noAnimationOptions = new RequestOptions()
@@ -271,4 +381,1129 @@ public static RequestOptions noAnimation() {
     }
     return noAnimationOptions;
   }
+
+  private static boolean isSet(int fields, int flag) {
+    return (fields & flag) != 0;
+  }
+
+  /**
+   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
+   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
+   * (particularly {@link Bitmap}s on devices with overly dense screens.
+   *
+   * @param sizeMultiplier The multiplier to apply to the
+   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
+   *                       loading the resource.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions sizeMultiplier(float sizeMultiplier) {
+    if (isAutoCloneEnabled) {
+      return clone().sizeMultiplier(sizeMultiplier);
+    }
+
+    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+    }
+    this.sizeMultiplier = sizeMultiplier;
+    fields |= SIZE_MULTIPLIER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  @CheckResult
+  public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useUnlimitedSourceGeneratorsPool(flag);
+    }
+
+    this.useUnlimitedSourceGeneratorsPool = flag;
+    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to true, will only load an item if found in the cache, and will not fetch from source.
+   */
+  @CheckResult
+  public RequestOptions onlyRetrieveFromCache(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().onlyRetrieveFromCache(flag);
+    }
+
+    this.onlyRetrieveFromCache = flag;
+    fields |= ONLY_RETRIEVE_FROM_CACHE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link DiskCacheStrategy} to use for this load.
+   *
+   * <p> Defaults to {@link DiskCacheStrategy#AUTOMATIC}. </p>
+   *
+   * <p> For most applications {@link DiskCacheStrategy#RESOURCE} is
+   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
+   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
+   * using {@link DiskCacheStrategy#DATA} or
+   * {@link DiskCacheStrategy#ALL}. </p>
+   *
+   * @param strategy The strategy to use.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    if (isAutoCloneEnabled) {
+      return clone().diskCacheStrategy(strategy);
+    }
+    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
+    fields |= DISK_CACHE_STRATEGY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the priority for this load.
+   *
+   * @param priority A priority.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions priority(@NonNull Priority priority) {
+    if (isAutoCloneEnabled) {
+      return clone().priority(priority);
+    }
+
+    this.priority = Preconditions.checkNotNull(priority);
+    fields |= PRIORITY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display while a resource is loading.
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions placeholder(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(drawable);
+    }
+
+    this.placeholderDrawable = drawable;
+    fields |= PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an Android resource id for a {@link Drawable} resource to
+   * display while a resource is loading.
+   *
+   * @param resourceId The id of the resource to use as a placeholder
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions placeholder(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(resourceId);
+    }
+
+    this.placeholderId = resourceId;
+    fields |= PLACEHOLDER_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions fallback(Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(drawable);
+    }
+
+    this.fallbackDrawable = drawable;
+    fields |= FALLBACK;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
+   * the error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param resourceId The id of the resource to use as a fallback.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions fallback(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(resourceId);
+    }
+
+    this.fallbackId = resourceId;
+    fields |= FALLBACK_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a {@link Drawable} to display if a load fails.
+   *
+   * @param drawable The drawable to display.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions error(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().error(drawable);
+    }
+
+    this.errorPlaceholder = drawable;
+    fields |= ERROR_PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if a load fails.
+   *
+   * @param resourceId The id of the resource to use as a placeholder.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions error(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().error(resourceId);
+    }
+    this.errorId = resourceId;
+    fields |= ERROR_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
+   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
+   * {@link #fallback(Drawable)}.
+   *
+   * @param theme The theme to use when loading Drawables.
+   * @return this request builder.
+   */
+  @CheckResult
+  public RequestOptions theme(Resources.Theme theme) {
+    if (isAutoCloneEnabled) {
+      return clone().theme(theme);
+    }
+
+    this.theme = theme;
+    fields |= THEME;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Allows the loaded resource to skip the memory cache.
+   *
+   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
+   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
+   *
+   * @param skip True to allow the resource to skip the memory cache.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions skipMemoryCache(boolean skip) {
+    if (isAutoCloneEnabled) {
+      return clone().skipMemoryCache(true);
+    }
+
+    this.isCacheable = !skip;
+    fields |= IS_CACHEABLE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given values. This is useful for thumbnails, and should only be used for other cases when you
+   * need a very specific image size.
+   *
+   * @param width  The width in pixels to use to load the resource.
+   * @param height The height in pixels to use to load the resource.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions override(int width, int height) {
+    if (isAutoCloneEnabled) {
+      return clone().override(width, height);
+    }
+
+    this.overrideWidth = width;
+    this.overrideHeight = height;
+    fields |= OVERRIDE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given size.
+   *
+   * @see #override(int, int)
+   * @param size The width and height to use.
+   * @return This request builder.
+   */
+  @CheckResult
+  public RequestOptions override(int size) {
+    return override(size, size);
+  }
+
+  /**
+   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
+   * more control over when cached data is invalidated.
+   *
+   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
+   *
+   * @param signature A unique non-null {@link Key} representing the current
+   *                  state of the model that will be mixed in to the cache key.
+   * @return This request builder.
+   * @see com.bumptech.glide.signature.ObjectKey
+   */
+  @CheckResult
+  public RequestOptions signature(@NonNull Key signature) {
+    if (isAutoCloneEnabled) {
+      return clone().signature(signature);
+    }
+
+    this.signature = Preconditions.checkNotNull(signature);
+    fields |= SIGNATURE;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Returns a copy of this request builder with all of the options put so far on this builder.
+   *
+   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * changes to one builder will not affect the other builder. However, in addition to immutable
+   * arguments, the current model is not copied copied so changes to the model will affect both
+   * builders. </p>
+   *
+   * <p> Even if this object was locked, the cloned object returned from this method will not be
+   * locked. </p>
+   */
+  @SuppressWarnings("unchecked")
+  @CheckResult
+  @Override
+  public RequestOptions clone() {
+    try {
+      RequestOptions result = (RequestOptions) super.clone();
+      result.options = new Options();
+      result.options.putAll(options);
+      result.transformations = new HashMap<>();
+      result.transformations.putAll(transformations);
+      result.isLocked = false;
+      result.isAutoCloneEnabled = false;
+      return result;
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @CheckResult
+  public <T> RequestOptions set(@NonNull Option<T> option, @NonNull T value) {
+    if (isAutoCloneEnabled) {
+      return clone().set(option, value);
+    }
+
+    Preconditions.checkNotNull(option);
+    Preconditions.checkNotNull(value);
+    options.set(option, value);
+    return selfOrThrowIfLocked();
+  }
+
+  @CheckResult
+  public RequestOptions decode(@NonNull Class<?> resourceClass) {
+    if (isAutoCloneEnabled) {
+      return clone().decode(resourceClass);
+    }
+
+    this.resourceClass = Preconditions.checkNotNull(resourceClass);
+    fields |= RESOURCE_CLASS;
+    return selfOrThrowIfLocked();
+  }
+
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
+  public final boolean isTransformationSet() {
+    return isSet(TRANSFORMATION);
+  }
+
+  public final boolean isLocked() {
+    return isLocked;
+  }
+
+  /**
+   * Sets the value for key
+   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
+   */
+  @CheckResult
+  public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the value for key
+   * {@link BitmapEncoder#COMPRESSION_QUALITY}.
+   */
+  @CheckResult
+  public RequestOptions encodeQuality(int quality) {
+    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
+  }
+
+  /**
+   * Sets the time position of the frame to extract from a video.
+   *
+   * <p>This is a component option specific to {@link VideoBitmapDecoder}. If the default video
+   * decoder is replaced or skipped because of your configuration, this option may be ignored.
+   *
+   * @see VideoBitmapDecoder#TARGET_FRAME
+   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
+   *                        Android framework implementation return a representative frame.
+   */
+  @CheckResult
+  public RequestOptions frame(long frameTimeMicros) {
+    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
+  }
+
+  /**
+   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
+   * {@link Downsampler}.
+   *
+   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
+   * decoded using a decoder that cannot control the format
+   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
+   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
+   * image has alpha).
+   *
+   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
+   * is replaced or skipped because of your configuration, this option may be ignored.
+   *
+   * @see Downsampler#DECODE_FORMAT
+   */
+  @CheckResult
+  public RequestOptions format(@NonNull DecodeFormat format) {
+    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Disables the use of {@link android.graphics.Bitmap.Config#HARDWARE} in {@link Downsampler} to
+   * avoid errors caused by inspecting Bitmap pixels, drawing with hardware support disabled,
+   * drawing to {@link android.graphics.Canvas}s backed by {@link Bitmap}s etc.
+   *
+   * <p>It's almost never safe to set {@link Downsampler#ALLOW_HARDWARE_CONFIG} to {@code true} so
+   * we only provide a way to disable hardware configs entirely. If no option is set for
+   * {@link Downsampler#ALLOW_HARDWARE_CONFIG}, Glide will set the value per request based on
+   * whether or not a {@link Transformation} is applied and if one is, the type of
+   * {@link Transformation} applied. Built in transformations like {@link FitCenter} and
+   * {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.CenterOutside} can safely use
+   * {@link android.graphics.Bitmap.Config#HARDWARE} because they can be entirely replaced by
+   * scaling within {@link Downsampler}. {@link Transformation}s like {@link #circleCrop()} that
+   * can't be replicated by {@link Downsampler} cannot use {@link Bitmap.Config#HARDWARE} because
+   * {@link android.graphics.Bitmap.Config#HARDWARE} cannot be drawn to
+   * {@link android.graphics.Canvas}s, which is required by most {@link Transformation}s.
+   */
+  @CheckResult
+  public RequestOptions disallowHardwareConfig() {
+    return set(Downsampler.ALLOW_HARDWARE_CONFIG, false);
+  }
+
+  /**
+   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
+   * {@link Downsampler}.
+   *
+   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder
+   * is replaced or skipped because of your configuration, this option may be ignored.
+   */
+  @CheckResult
+  public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
+  }
+
+  /**
+   * Sets the read and write timeout for the http requests used to load the image.
+   *
+   * <p>This is a component option specific to Glide's default networking library and
+   * {@link com.bumptech.glide.load.model.stream.HttpGlideUrlLoader}. If you use any other
+   * networking library including Glide's Volley or OkHttp integration libraries, this option will
+   * be ignored.
+   *
+   * @see com.bumptech.glide.load.model.stream.HttpGlideUrlLoader#TIMEOUT
+   * @param timeoutMs The read and write timeout in milliseconds.
+   */
+  @CheckResult
+  public RequestOptions timeout(int timeoutMs) {
+    return set(HttpGlideUrlLoader.TIMEOUT, timeoutMs);
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerCrop()
+   */
+  @CheckResult
+  public RequestOptions optionalCenterCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()} ()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  @CheckResult
+  public RequestOptions centerCrop() {
+    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   *
+   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
+   * image types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #fitCenter()
+   */
+  @CheckResult
+  public RequestOptions optionalFitCenter() {
+    return optionalScaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link FitCenter} and to all default types, {@link DownsampleStrategy#FIT_CENTER} to
+   * image types, and throws an exception if asked to transform an unknown
+   * type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalFitCenter()
+   */
+  @CheckResult
+  public RequestOptions fitCenter() {
+    return scaleOnlyTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types,
+   * {@link DownsampleStrategy#CENTER_INSIDE} to image types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   */
+  @CheckResult
+  public RequestOptions optionalCenterInside() {
+    return optionalScaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CenterInside} to all default types, {@link DownsampleStrategy#CENTER_INSIDE} to
+   * image types and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()} and previous calls to
+   * {@link #downsample(DownsampleStrategy)}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterInside()
+   */
+  @CheckResult
+  public RequestOptions centerInside() {
+    return scaleOnlyTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Transformation)
+   * @see #circleCrop()
+   */
+  @CheckResult
+  public RequestOptions optionalCircleCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  @CheckResult
+  public RequestOptions circleCrop() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
+  }
+
+  // calling optionalTransform() on the result of clone() requires greater access.
+  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"WeakerAccess", "CheckResult"})
+  final RequestOptions optionalTransform(DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return optionalTransform(transformation);
+  }
+
+  // calling transform() on the result of clone() requires greater access.
+  // calling downsample is guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"WeakerAccess", "CheckResult"})
+  @CheckResult
+  final RequestOptions transform(DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation);
+  }
+
+  private RequestOptions scaleOnlyTransform(
+      DownsampleStrategy strategy, Transformation<Bitmap> transformation) {
+    return scaleOnlyTransform(strategy, transformation, true /*isTransformationRequired*/);
+  }
+
+  private RequestOptions optionalScaleOnlyTransform(
+      DownsampleStrategy strategy, Transformation<Bitmap> transformation) {
+    return scaleOnlyTransform(strategy, transformation, false /*isTransformationRequired*/);
+  }
+
+  private RequestOptions scaleOnlyTransform(
+      DownsampleStrategy strategy,
+      Transformation<Bitmap> transformation,
+      boolean isTransformationRequired) {
+    RequestOptions result = isTransformationRequired
+          ? transform(strategy, transformation) : optionalTransform(strategy, transformation);
+    result.isScaleOnlyOrNoTransform = true;
+    return result;
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @CheckResult
+  public RequestOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(transformation);
+    }
+
+    optionalTransform(transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation}s in the given order for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings({"unchecked", "varargs", "CheckResult"})
+  @CheckResult
+  public RequestOptions transforms(@NonNull Transformation<Bitmap>... transformations) {
+    if (isAutoCloneEnabled) {
+      return clone().transforms(transformations);
+    }
+
+    optionalTransform(new MultiTransformation<>(transformations));
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for {@link Bitmap}s.
+   * @see #transform(Transformation)
+   * @see #transform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @CheckResult
+  public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(transformation);
+    }
+
+    optionalTransform(Bitmap.class, transformation);
+    // TODO: remove BitmapDrawable decoder and this transformation.
+    optionalTransform(BitmapDrawable.class, new BitmapDrawableTransformation(transformation));
+    optionalTransform(GifDrawable.class, new GifDrawableTransformation(transformation));
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and allows unknown resource types to be ignored.
+   *
+   * <p> Users can apply different transformations for each resource class. Applying a
+   * {@link Transformation} for a resource type that already has a
+   * {@link Transformation} will override the previous call. </p>
+   *
+   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
+   * an unknown resource class will throw an exception. To allow unknown types, users must always
+   * call the optional version of each method. </p>
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   */
+  @CheckResult
+  public <T> RequestOptions optionalTransform(Class<T> resourceClass,
+      Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(resourceClass, transformation);
+    }
+
+    Preconditions.checkNotNull(resourceClass);
+    Preconditions.checkNotNull(transformation);
+    transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
+    // Always set to false here. Known scale only transformations will call this method and then
+    // set isScaleOnlyOrNoTransform to true immediately after.
+    isScaleOnlyOrNoTransform = false;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and throws if asked to transform an unknown resource type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   * @see #optionalTransform(Class, Transformation)
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @CheckResult
+  public <T> RequestOptions transform(
+      Class<T> resourceClass, Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(resourceClass, transformation);
+    }
+
+    optionalTransform(resourceClass, transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Removes all applied {@link Transformation Transformations} for all
+   * resource classes and allows unknown resource types to be transformed without throwing an
+   * exception.
+   */
+  @CheckResult
+  public RequestOptions dontTransform() {
+    if (isAutoCloneEnabled) {
+      return clone().dontTransform();
+    }
+
+    transformations.clear();
+    fields &= ~TRANSFORMATION;
+    isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
+    isScaleOnlyOrNoTransform = true;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Disables resource decoders that return animated resources so any resource returned will be
+   * static.
+   *
+   * <p> To disable transitions (fades etc) use
+   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
+   */
+  // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
+  @SuppressWarnings("CheckResult")
+  @CheckResult
+  public RequestOptions dontAnimate() {
+    if (isAutoCloneEnabled) {
+      return clone().dontAnimate();
+    }
+
+    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
+    set(StreamGifDecoder.DISABLE_ANIMATION, true);
+    return selfOrThrowIfLocked();
+  }
+
+  @CheckResult
+  public RequestOptions apply(RequestOptions other) {
+    if (isAutoCloneEnabled) {
+      return clone().apply(other);
+    }
+
+    if (isSet(other.fields, SIZE_MULTIPLIER)) {
+      sizeMultiplier = other.sizeMultiplier;
+    }
+    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
+      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
+    }
+    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
+      diskCacheStrategy = other.diskCacheStrategy;
+    }
+    if (isSet(other.fields, PRIORITY)) {
+      priority = other.priority;
+    }
+    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
+      errorPlaceholder = other.errorPlaceholder;
+    }
+    if (isSet(other.fields, ERROR_ID)) {
+      errorId = other.errorId;
+    }
+    if (isSet(other.fields, PLACEHOLDER)) {
+      placeholderDrawable = other.placeholderDrawable;
+    }
+    if (isSet(other.fields, PLACEHOLDER_ID)) {
+      placeholderId = other.placeholderId;
+    }
+    if (isSet(other.fields, IS_CACHEABLE)) {
+      isCacheable = other.isCacheable;
+    }
+    if (isSet(other.fields, OVERRIDE)) {
+      overrideWidth = other.overrideWidth;
+      overrideHeight = other.overrideHeight;
+    }
+    if (isSet(other.fields, SIGNATURE)) {
+      signature = other.signature;
+    }
+    if (isSet(other.fields, RESOURCE_CLASS)) {
+      resourceClass = other.resourceClass;
+    }
+    if (isSet(other.fields, FALLBACK)) {
+      fallbackDrawable = other.fallbackDrawable;
+    }
+    if (isSet(other.fields, FALLBACK_ID)) {
+      fallbackId = other.fallbackId;
+    }
+    if (isSet(other.fields, THEME)) {
+      theme = other.theme;
+    }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+      isScaleOnlyOrNoTransform = other.isScaleOnlyOrNoTransform;
+    }
+    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
+      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+      isScaleOnlyOrNoTransform = true;
+    }
+
+    fields |= other.fields;
+    options.putAll(other.options);
+
+    return selfOrThrowIfLocked();
+  }
+
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof RequestOptions) {
+      RequestOptions other = (RequestOptions) o;
+      return Float.compare(other.sizeMultiplier, sizeMultiplier) == 0
+          && errorId == other.errorId
+          && Util.bothNullOrEqual(errorPlaceholder, other.errorPlaceholder)
+          && placeholderId == other.placeholderId
+          && Util.bothNullOrEqual(placeholderDrawable, other.placeholderDrawable)
+          && fallbackId == other.fallbackId
+          && Util.bothNullOrEqual(fallbackDrawable, other.fallbackDrawable)
+          && isCacheable == other.isCacheable
+          && overrideHeight == other.overrideHeight
+          && overrideWidth == other.overrideWidth
+          && isTransformationRequired == other.isTransformationRequired
+          && isTransformationAllowed == other.isTransformationAllowed
+          && useUnlimitedSourceGeneratorsPool == other.useUnlimitedSourceGeneratorsPool
+          && onlyRetrieveFromCache == other.onlyRetrieveFromCache
+          && diskCacheStrategy.equals(other.diskCacheStrategy)
+          && priority == other.priority
+          && options.equals(other.options)
+          && transformations.equals(other.transformations)
+          && resourceClass.equals(other.resourceClass)
+          && Util.bothNullOrEqual(signature, other.signature)
+          && Util.bothNullOrEqual(theme, other.theme);
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    int hashCode = Util.hashCode(sizeMultiplier);
+    hashCode = Util.hashCode(errorId, hashCode);
+    hashCode = Util.hashCode(errorPlaceholder, hashCode);
+    hashCode = Util.hashCode(placeholderId, hashCode);
+    hashCode = Util.hashCode(placeholderDrawable, hashCode);
+    hashCode = Util.hashCode(fallbackId, hashCode);
+    hashCode = Util.hashCode(fallbackDrawable, hashCode);
+    hashCode = Util.hashCode(isCacheable, hashCode);
+    hashCode = Util.hashCode(overrideHeight, hashCode);
+    hashCode = Util.hashCode(overrideWidth, hashCode);
+    hashCode = Util.hashCode(isTransformationRequired, hashCode);
+    hashCode = Util.hashCode(isTransformationAllowed, hashCode);
+    hashCode = Util.hashCode(useUnlimitedSourceGeneratorsPool, hashCode);
+    hashCode = Util.hashCode(onlyRetrieveFromCache, hashCode);
+    hashCode = Util.hashCode(diskCacheStrategy, hashCode);
+    hashCode = Util.hashCode(priority, hashCode);
+    hashCode = Util.hashCode(options, hashCode);
+    hashCode = Util.hashCode(transformations, hashCode);
+    hashCode = Util.hashCode(resourceClass, hashCode);
+    hashCode = Util.hashCode(signature, hashCode);
+    hashCode = Util.hashCode(theme, hashCode);
+    return hashCode;
+  }
+
+  /**
+   * Throws if any further mutations are attempted.
+   *
+   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
+   */
+  @SuppressWarnings("unchecked")
+  public RequestOptions lock() {
+    isLocked = true;
+    // This is the only place we should not check locked.
+    return this;
+  }
+
+  /**
+   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
+   * before the mutation resulting in all methods returning a new Object and leaving the original
+   * locked object unmodified.
+   *
+   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
+   * are mutable and are not locked.
+   */
+  public RequestOptions autoClone() {
+    if (isLocked && !isAutoCloneEnabled) {
+      throw new IllegalStateException("You cannot auto lock an already locked options object"
+          + ", try clone() first");
+    }
+    isAutoCloneEnabled = true;
+    return lock();
+  }
+
+  @SuppressWarnings("unchecked")
+  private RequestOptions selfOrThrowIfLocked() {
+    if (isLocked) {
+      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
+    }
+    return this;
+  }
+
+  protected boolean isAutoCloneEnabled() {
+    return isAutoCloneEnabled;
+  }
+
+  @NonNull
+  public final Map<Class<?>, Transformation<?>> getTransformations() {
+    return transformations;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final boolean isTransformationRequired() {
+    return isTransformationRequired;
+  }
+
+  @NonNull
+  public final Options getOptions() {
+    return options;
+  }
+
+  @NonNull
+  public final Class<?> getResourceClass() {
+    return resourceClass;
+  }
+
+  @NonNull
+  public final DiskCacheStrategy getDiskCacheStrategy() {
+    return diskCacheStrategy;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getErrorPlaceholder() {
+    return errorPlaceholder;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getErrorId() {
+    return errorId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getPlaceholderId() {
+    return placeholderId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getPlaceholderDrawable() {
+    return placeholderDrawable;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final int getFallbackId() {
+    return fallbackId;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  @Nullable
+  public final Drawable getFallbackDrawable() {
+    return fallbackDrawable;
+  }
+
+  @Nullable
+  public final Resources.Theme getTheme() {
+    return theme;
+  }
+
+  @SuppressWarnings("WeakerAccess")
+  public final boolean isMemoryCacheable() {
+    return isCacheable;
+  }
+
+  @NonNull
+  public final Key getSignature() {
+    return signature;
+  }
+
+  public final boolean isPrioritySet() {
+    return isSet(PRIORITY);
+  }
+
+  @NonNull
+  public final Priority getPriority() {
+    return priority;
+  }
+
+  public final int getOverrideWidth() {
+    return overrideWidth;
+  }
+
+  public final boolean isValidOverride() {
+    return Util.isValidDimensions(overrideWidth, overrideHeight);
+  }
+
+  public final int getOverrideHeight() {
+    return overrideHeight;
+  }
+
+  public final float getSizeMultiplier() {
+    return sizeMultiplier;
+  }
+
+  public boolean isScaleOnlyOrNoTransform() {
+    return isScaleOnlyOrNoTransform;
+  }
+
+  private boolean isSet(int flag) {
+    return isSet(fields, flag);
+  }
+
+  public final boolean getUseUnlimitedSourceGeneratorsPool() {
+    return useUnlimitedSourceGeneratorsPool;
+  }
+
+  public final boolean getOnlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 05312672e..6951e10d6 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -2,8 +2,11 @@
 
 import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.Nullable;
 import android.support.v4.content.res.ResourcesCompat;
 import android.support.v4.util.Pools;
+import android.support.v7.content.res.AppCompatResources;
 import android.util.Log;
 import com.bumptech.glide.GlideContext;
 import com.bumptech.glide.Priority;
@@ -42,6 +45,7 @@
           return new SingleRequest<Object>();
         }
       });
+  private boolean isCallingCallbacks;
 
   private enum Status {
     /**
@@ -78,14 +82,15 @@
     PAUSED,
   }
 
-  private final String tag = String.valueOf(hashCode());
+  private final String tag = String.valueOf(super.hashCode());
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
 
   private RequestCoordinator requestCoordinator;
   private GlideContext glideContext;
+  @Nullable
   private Object model;
   private Class<R> transcodeClass;
-  private BaseRequestOptions<?> requestOptions;
+  private RequestOptions requestOptions;
   private int overrideWidth;
   private int overrideHeight;
   private Priority priority;
@@ -102,12 +107,13 @@
   private Drawable fallbackDrawable;
   private int width;
   private int height;
+  private static boolean shouldCallAppCompatResources = true;
 
   public static <R> SingleRequest<R> obtain(
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
@@ -146,7 +152,7 @@ private void init(
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
@@ -177,6 +183,7 @@ public StateVerifier getVerifier() {
 
   @Override
   public void recycle() {
+    assertNotCallingCallbacks();
     glideContext = null;
     model = null;
     transcodeClass = null;
@@ -198,6 +205,7 @@ public void recycle() {
 
   @Override
   public void begin() {
+    assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
     if (model == null) {
@@ -212,6 +220,24 @@ public void begin() {
       return;
     }
 
+    if (status == Status.RUNNING) {
+      throw new IllegalArgumentException("Cannot restart a running request");
+    }
+
+    // If we're restarted after we're complete (usually via something like a notifyDataSetChanged
+    // that starts an identical request into the same Target or View), we can simply use the
+    // resource and size we retrieved the last time around and skip obtaining a new size, starting a
+    // new load etc. This does mean that users who want to restart a load because they expect that
+    // the view size has changed will need to explicitly clear the View or Target before starting
+    // the new load.
+    if (status == Status.COMPLETE) {
+      onResourceReady(resource, DataSource.MEMORY_CACHE);
+      return;
+    }
+
+    // Restarts for requests that are neither complete nor running can be treated as new requests
+    // and can run again from the beginning.
+
     status = Status.WAITING_FOR_SIZE;
     if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
       onSizeReady(overrideWidth, overrideHeight);
@@ -237,7 +263,9 @@ public void begin() {
    * @see #clear()
    */
   void cancel() {
+    assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
+    target.removeCallback(this);
     status = Status.CANCELLED;
     if (loadStatus != null) {
       loadStatus.cancel();
@@ -245,6 +273,15 @@ void cancel() {
     }
   }
 
+  // Avoids difficult to understand errors like #2413.
+  private void assertNotCallingCallbacks() {
+    if (isCallingCallbacks) {
+      throw new IllegalStateException("You can't start or clear loads in RequestListener or"
+          + " Target callbacks. If you must do so, consider posting your into() or clear() calls"
+          + " to the main thread using a Handler instead.");
+    }
+  }
+
   /**
    * Cancels the current load if it is in progress, clears any resources held onto by the request
    * and replaces the loaded resource if the load completed with the placeholder.
@@ -256,6 +293,7 @@ void cancel() {
   @Override
   public void clear() {
     Util.assertMainThread();
+    assertNotCallingCallbacks();
     if (status == Status.CLEARED) {
       return;
     }
@@ -342,7 +380,28 @@ private Drawable getFallbackDrawable() {
     return fallbackDrawable;
   }
 
-  private Drawable loadDrawable(int resourceId) {
+  private Drawable loadDrawable(@DrawableRes int resourceId) {
+    if (shouldCallAppCompatResources) {
+      return loadDrawableV7(resourceId);
+    } else {
+      return loadDrawableBase(resourceId);
+    }
+  }
+
+  /**
+   * Tries to load the drawable thanks to AppCompatResources.<br>
+   * This allows to parse VectorDrawables on legacy devices if the appcompat v7 is in the classpath.
+   */
+  private Drawable loadDrawableV7(@DrawableRes int resourceId) {
+    try {
+      return AppCompatResources.getDrawable(glideContext, resourceId);
+    } catch (NoClassDefFoundError error) {
+      shouldCallAppCompatResources = false;
+      return loadDrawableBase(resourceId);
+    }
+  }
+
+  private Drawable loadDrawableBase(@DrawableRes int resourceId) {
     Resources resources = glideContext.getResources();
     return ResourcesCompat.getDrawable(resources, resourceId, requestOptions.getTheme());
   }
@@ -352,7 +411,15 @@ private void setErrorPlaceholder() {
       return;
     }
 
-    Drawable error = model == null ? getFallbackDrawable() : getErrorDrawable();
+    Drawable error = null;
+    if (model == null) {
+      error = getFallbackDrawable();
+    }
+    // Either the model isn't null, or there was no fallback drawable set.
+    if (error == null) {
+      error = getErrorDrawable();
+    }
+    // The model isn't null, no fallback drawable was set or no error drawable was set.
     if (error == null) {
       error = getPlaceholderDrawable();
     }
@@ -392,6 +459,7 @@ public void onSizeReady(int width, int height) {
         requestOptions.getDiskCacheStrategy(),
         requestOptions.getTransformations(),
         requestOptions.isTransformationRequired(),
+        requestOptions.isScaleOnlyOrNoTransform(),
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
         requestOptions.getUseUnlimitedSourceGeneratorsPool(),
@@ -481,11 +549,16 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
           + LogTime.getElapsedMillis(startTime) + " ms");
     }
 
-    if (requestListener == null
-        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {
-      Transition<? super R> animation =
-          animationFactory.build(dataSource, isFirstResource);
-      target.onResourceReady(result, animation);
+    isCallingCallbacks = true;
+    try {
+      if (requestListener == null
+          || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {
+        Transition<? super R> animation =
+            animationFactory.build(dataSource, isFirstResource);
+        target.onResourceReady(result, animation);
+      }
+    } finally {
+      isCallingCallbacks = false;
     }
 
     notifyLoadSuccess();
@@ -511,11 +584,31 @@ private void onLoadFailed(GlideException e, int maxLogLevel) {
 
     loadStatus = null;
     status = Status.FAILED;
-    //TODO: what if this is a thumbnail request?
-    if (requestListener == null || !requestListener.onLoadFailed(e, model, target,
-        isFirstReadyResource())) {
-      setErrorPlaceholder();
+
+    isCallingCallbacks = true;
+    try {
+      //TODO: what if this is a thumbnail request?
+      if (requestListener == null
+          || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource())) {
+        setErrorPlaceholder();
+      }
+    } finally {
+      isCallingCallbacks = false;
+    }
+  }
+
+  @Override
+  public boolean isEquivalentTo(Request o) {
+    if (o instanceof SingleRequest) {
+      SingleRequest that = (SingleRequest) o;
+      return overrideWidth == that.overrideWidth
+          && overrideHeight == that.overrideHeight
+          && Util.bothModelsNullEquivalentOrEquals(model, that.model)
+          && transcodeClass.equals(that.transcodeClass)
+          && requestOptions.equals(that.requestOptions)
+          && priority == that.priority;
     }
+    return false;
   }
 
   private void logV(String message) {
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 996f41ad3..6b62270e2 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -159,4 +159,14 @@ public void recycle() {
     full.recycle();
     thumb.recycle();
   }
+
+  @Override
+  public boolean isEquivalentTo(Request o) {
+    if (o instanceof ThumbnailRequestCoordinator) {
+      ThumbnailRequestCoordinator that = (ThumbnailRequestCoordinator) o;
+      return (full == null ? that.full == null : full.isEquivalentTo(that.full))
+          && (thumb == null ? that.thumb == null : thumb.isEquivalentTo(that.thumb));
+    }
+    return false;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
index f5d978a22..a1f56e1af 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
@@ -71,6 +71,7 @@ public int getChangingConfigurations() {
     return wrapped.getChangingConfigurations();
   }
 
+  @Deprecated
   @Override
   public void setDither(boolean dither) {
     wrapped.setDither(dither);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
index 7b9f884a9..caab4ac19 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java
@@ -1,5 +1,9 @@
 package com.bumptech.glide.request.target;
 
+import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.os.Message;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.request.transition.Transition;
 
@@ -10,6 +14,17 @@
  * @param <Z> The type of resource that will be loaded into memory.
  */
 public final class PreloadTarget<Z> extends SimpleTarget<Z> {
+  private static final int MESSAGE_CLEAR = 1;
+  private static final Handler HANDLER = new Handler(Looper.getMainLooper(), new Callback() {
+    @Override
+    public boolean handleMessage(Message message) {
+      if (message.what == MESSAGE_CLEAR) {
+        ((PreloadTarget<?>) message.obj).clear();
+        return true;
+      }
+      return false;
+    }
+  });
 
   private final RequestManager requestManager;
 
@@ -31,6 +46,10 @@ private PreloadTarget(RequestManager requestManager, int width, int height) {
 
   @Override
   public void onResourceReady(Z resource, Transition<? super Z> transition) {
+    HANDLER.obtainMessage(MESSAGE_CLEAR, this).sendToTarget();
+  }
+
+  private void clear() {
     requestManager.clear(this);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index 8144e5d90..fd1baf5b7 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -64,4 +64,9 @@ public final void getSize(SizeReadyCallback cb) {
     }
     cb.onSizeReady(width, height);
   }
+
+  @Override
+  public void removeCallback(SizeReadyCallback cb) {
+    // Do nothing, we never retain a reference to the callback.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index 0488526e6..dbdbc4779 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -83,6 +83,13 @@
    */
   void getSize(SizeReadyCallback cb);
 
+  /**
+   * Removes the given callback from the pending set if it's still retained.
+   *
+   * @param cb The callback to remove.
+   */
+  void removeCallback(SizeReadyCallback cb);
+
   /**
    * Sets the current request for this target to retain, should not be called outside of Glide.
    */
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 0dd6742b7..555fc3fcb 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -1,12 +1,16 @@
 package com.bumptech.glide.request.target;
 
+import android.content.Context;
+import android.graphics.Point;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.util.Log;
+import android.view.Display;
 import android.view.View;
 import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
+import android.view.WindowManager;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
@@ -43,8 +47,12 @@
   private final SizeDeterminer sizeDeterminer;
 
   public ViewTarget(T view) {
+    this(view, false /*waitForLayout*/);
+  }
+
+  public ViewTarget(T view, boolean waitForLayout) {
     this.view = Preconditions.checkNotNull(view);
-    sizeDeterminer = new SizeDeterminer(view);
+    sizeDeterminer = new SizeDeterminer(view, waitForLayout);
   }
 
   /**
@@ -68,6 +76,11 @@ public void getSize(SizeReadyCallback cb) {
     sizeDeterminer.getSize(cb);
   }
 
+  @Override
+  public void removeCallback(SizeReadyCallback cb) {
+    sizeDeterminer.removeCallback(cb);
+  }
+
   @Override
   public void onLoadCleared(Drawable placeholder) {
     super.onLoadCleared(placeholder);
@@ -160,20 +173,43 @@ public static void setTagId(int tagId) {
       ViewTarget.tagId = tagId;
   }
 
-  private static class SizeDeterminer {
+  @VisibleForTesting
+  static final class SizeDeterminer {
     // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
     private static final int PENDING_SIZE = 0;
+    @VisibleForTesting
+    @Nullable
+    static Integer maxDisplayLength;
     private final View view;
+    private final boolean waitForLayout;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
 
     @Nullable private SizeDeterminerLayoutListener layoutListener;
 
-    SizeDeterminer(View view) {
+    SizeDeterminer(View view, boolean waitForLayout) {
       this.view = view;
+      this.waitForLayout = waitForLayout;
+    }
+
+    // Use the maximum to avoid depending on the device's current orientation.
+    private static int getMaxDisplayLength(Context context) {
+      if (maxDisplayLength == null) {
+        WindowManager windowManager =
+            (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = windowManager.getDefaultDisplay();
+        Point displayDimensions = new Point();
+        display.getSize(displayDimensions);
+        maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);
+      }
+      return maxDisplayLength;
     }
 
     private void notifyCbs(int width, int height) {
-      for (SizeReadyCallback cb : cbs) {
+      // One or more callbacks may trigger the removal of one or more additional callbacks, so we
+      // need a copy of the list to avoid a concurrent modification exception. One place this
+      // happens is when a full request completes from the in memory cache while its thumbnail is
+      // still being loaded asynchronously. See #2237.
+      for (SizeReadyCallback cb : new ArrayList<>(cbs)) {
         cb.onSizeReady(width, height);
       }
     }
@@ -214,6 +250,16 @@ void getSize(SizeReadyCallback cb) {
       }
     }
 
+    /**
+     * The callback may be called anyway if it is removed by another {@link SizeReadyCallback} or
+     * otherwise removed while we're notifying the list of callbacks.
+     *
+     * <p>See #2237.
+     */
+    void removeCallback(SizeReadyCallback cb) {
+      cbs.remove(cb);
+    }
+
     void clearCallbacksAndListener() {
       // Keep a reference to the layout listener and remove it here
       // rather than having the observer remove itself because the observer
@@ -230,22 +276,7 @@ void clearCallbacksAndListener() {
     }
 
     private boolean isViewStateAndSizeValid(int width, int height) {
-      return isViewStateValid() && isSizeValid(width) && isSizeValid(height);
-    }
-
-    private boolean isViewStateValid() {
-      // We consider the view state as valid if the view has
-      // non-null layout params and a non-zero layout width and height.
-      if (view.getLayoutParams() != null
-          && view.getLayoutParams().width > 0
-          && view.getLayoutParams().height > 0) {
-        return true;
-      }
-
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-        return view.isLaidOut();
-      }
-      return !view.isLayoutRequested();
+      return isDimensionValid(width) && isDimensionValid(height);
     }
 
     private int getTargetHeight() {
@@ -263,30 +294,62 @@ private int getTargetWidth() {
     }
 
     private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
-      int adjustedViewSize = viewSize - paddingSize;
-      if (isSizeValid(adjustedViewSize)) {
-        return adjustedViewSize;
+      if (waitForLayout && view.isLayoutRequested()) {
+        return PENDING_SIZE;
       }
 
-      if (paramSize == PENDING_SIZE) {
-        return PENDING_SIZE;
+      // We consider the View state as valid if the View has non-null layout params and a non-zero
+      // layout params width and height. This is imperfect. We're making an assumption that View
+      // parents will obey their child's layout parameters, which isn't always the case.
+      int adjustedParamSize = paramSize - paddingSize;
+      if (adjustedParamSize > 0) {
+        return adjustedParamSize;
+      }
+
+      // We also consider the View state valid if the View has a non-zero width and height. This
+      // means that the View has gone through at least one layout pass. It does not mean the Views
+      // width and height are from the current layout pass. For example, if a View is re-used in
+      // RecyclerView or ListView, this width/height may be from an old position. In some cases
+      // the dimensions of the View at the old position may be different than the dimensions of the
+      // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to
+      // change them. Nevertheless, in most cases this should be a reasonable choice.
+      int adjustedViewSize = viewSize - paddingSize;
+      if (adjustedViewSize > 0) {
+        return adjustedViewSize;
       }
 
+      // Finally we consider the view valid if the layout parameter size is set to wrap_content.
+      // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a
+      // coherent choice, it's extremely dangerous and therefore a bad default. If users want the
+      // original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content
+      // may never resolve to a real size unless we load something, we aim for a square whose length
+      // is the largest screen size. That way we're loading something and that something has some
+      // hope of being downsampled to a size that the device can support. We also log a warning that
+      // tries to explain what Glide is doing and why some alternatives are preferable.
       if (paramSize == LayoutParams.WRAP_CONTENT) {
-        return SIZE_ORIGINAL;
-      } else if (paramSize > 0) {
-        return paramSize - paddingSize;
-      } else {
-        return PENDING_SIZE;
+        if (Log.isLoggable(TAG, Log.INFO)) {
+          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of"
+              + " this device's screen dimensions. If you want to load the original image and are"
+              + " ok with the corresponding memory cost and OOMs (depending on the input size), use"
+              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set"
+              + " layout_width and layout_height to fixed dimension, or use .override() with fixed"
+              + " dimensions.");
+        }
+        return getMaxDisplayLength(view.getContext());
       }
+
+      // If the layout parameters are < padding, the view size is < padding, or the layout
+      // parameters are set to match_parent or wrap_content and no layout has occurred, we should
+      // wait for layout and repeat.
+      return PENDING_SIZE;
     }
 
-    private boolean isSizeValid(int size) {
+    private boolean isDimensionValid(int size) {
       return size > 0 || size == SIZE_ORIGINAL;
     }
 
-    private static class SizeDeterminerLayoutListener implements ViewTreeObserver
-        .OnPreDrawListener {
+    private static final class SizeDeterminerLayoutListener
+        implements ViewTreeObserver.OnPreDrawListener {
       private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
       SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index f81f5c3d0..3aeab1922 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -1,9 +1,6 @@
 package com.bumptech.glide.request.transition;
 
-import android.content.Context;
 import android.graphics.drawable.Drawable;
-import android.view.animation.AlphaAnimation;
-import android.view.animation.Animation;
 import com.bumptech.glide.load.DataSource;
 
 /**
@@ -17,66 +14,26 @@
  * the memory cache this factory produces an {@link NoTransition}.
  */
 public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
-  private final ViewAnimationFactory<Drawable> viewAnimationFactory;
   private final int duration;
   private final boolean isCrossFadeEnabled;
-  private DrawableCrossFadeTransition firstResourceTransition;
-  private DrawableCrossFadeTransition secondResourceTransition;
+  private DrawableCrossFadeTransition resourceTransition;
 
-  protected DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory,
-      int duration, boolean isCrossFadeEnabled) {
-    this.viewAnimationFactory = viewAnimationFactory;
+  protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {
     this.duration = duration;
     this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   @Override
   public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {
-    if (dataSource == DataSource.MEMORY_CACHE) {
-      return NoTransition.get();
-    } else if (isFirstResource) {
-      return getFirstResourceTransition(dataSource);
-    } else {
-      return getSecondResourceTransition(dataSource);
-    }
-  }
-
-  private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {
-      if (firstResourceTransition == null) {
-        firstResourceTransition = buildTransition(dataSource, true /*isFirstResource*/);
-      }
-      return firstResourceTransition;
+    return dataSource == DataSource.MEMORY_CACHE
+        ? NoTransition.<Drawable>get() : getResourceTransition();
   }
 
-  private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {
-      if (secondResourceTransition == null) {
-        secondResourceTransition = buildTransition(dataSource, false /*isFirstResource*/);
+  private Transition<Drawable> getResourceTransition() {
+      if (resourceTransition == null) {
+        resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);
       }
-      return secondResourceTransition;
-  }
-
-  private DrawableCrossFadeTransition buildTransition(DataSource dataSource,
-      boolean isFirstResource) {
-    Transition<Drawable> defaultAnimation =
-        viewAnimationFactory.build(dataSource, isFirstResource);
-    return new DrawableCrossFadeTransition(defaultAnimation, duration, isCrossFadeEnabled);
-  }
-
-  private static final class DefaultViewTransitionAnimationFactory implements
-      ViewTransition.ViewTransitionAnimationFactory {
-
-    private final int durationMillis;
-
-    DefaultViewTransitionAnimationFactory(int durationMillis) {
-      this.durationMillis = durationMillis;
-    }
-
-    @Override
-    public Animation build(Context context) {
-      AlphaAnimation animation = new AlphaAnimation(0f, 1f);
-      animation.setDuration(durationMillis);
-      return animation;
-    }
+      return resourceTransition;
   }
 
   /**
@@ -85,7 +42,6 @@ public Animation build(Context context) {
   public static class Builder {
     private static final int DEFAULT_DURATION_MS = 300;
     private int durationMillis;
-    private ViewAnimationFactory<Drawable> factory;
     private boolean isCrossFadeEnabled;
 
     public Builder() {
@@ -93,16 +49,10 @@ public Builder() {
     }
 
     /**
-     * @param durationMillis The duration of both the default animation when no previous Drawable
-     *     is present and the cross fade animation when a previous Drawable is present. This value
-     *     will not be used by the default animation if {@link #setDefaultAnimationId(int)},
-     *     {@link #setDefaultAnimation(Animation)}, or
-     *     {@link #setDefaultAnimationFactory(ViewAnimationFactory)} is called.
+     * @param durationMillis The duration of the cross fade animation in milliseconds.
      */
     public Builder(int durationMillis) {
       this.durationMillis = durationMillis;
-      factory = new ViewAnimationFactory<>(
-          new DefaultViewTransitionAnimationFactory(durationMillis));
     }
 
     /**
@@ -122,38 +72,8 @@ public Builder setCrossFadeEnabled(boolean isCrossFadeEnabled) {
       return this;
     }
 
-    /**
-     * Sets the resource id of the {@link Animation} to use when no previous {@link Drawable} is
-     * available to animate from.
-     *
-     * <p>Defaults to a simple fade in.
-     */
-    public Builder setDefaultAnimationId(int animationId) {
-      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animationId));
-    }
-
-    /**
-     * Sets the {@link Animation} to use when no previous {@link Drawable} is available to animate
-     * from.
-     *
-     * <p>It is not safe to use the same {@link Animation} object for multiple animations
-     * simultaneously. Always pass in a new instance to this method.
-     */
-    public Builder setDefaultAnimation(Animation animation) {
-      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animation));
-    }
-
-    /**
-     * Sets the {@link ViewAnimationFactory} to use to generate animations to animate when no
-     * previous {@link Drawable} is available to animate from.
-     */
-    public Builder setDefaultAnimationFactory(ViewAnimationFactory<Drawable> factory) {
-      this.factory = factory;
-      return this;
-    }
-
     public DrawableCrossFadeFactory build() {
-      return new DrawableCrossFadeFactory(factory, durationMillis, isCrossFadeEnabled);
+      return new DrawableCrossFadeFactory(durationMillis, isCrossFadeEnabled);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index ee1ff46e2..cfdf30b31 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.request.transition;
 
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
 
@@ -11,17 +13,10 @@
  * android.graphics.drawable.TransitionDrawable}.
  */
 public class DrawableCrossFadeTransition implements Transition<Drawable> {
-  private final Transition<Drawable> defaultAnimation;
   private final int duration;
   private final boolean isCrossFadeEnabled;
 
   /**
-   * Constructor that takes a default animation and a duration in milliseconds that the cross fade
-   * animation should last.
-   *
-   * @param defaultAnimation The {@link Transition} to use if there is no previous
-   *                         {@link Drawable} (either a placeholder or previous resource) to
-   *                         transition from.
    * @param duration The duration that the cross fade animation should run if there is something to
    *                 cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
    * @param isCrossFadeEnabled If {@code true}, animates the previous resource's alpha to 0 while
@@ -30,9 +25,8 @@
    *                         alpha at 100. See
    *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
-  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration,
+  public DrawableCrossFadeTransition(int duration,
       boolean isCrossFadeEnabled) {
-    this.defaultAnimation = defaultAnimation;
     this.duration = duration;
     this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
@@ -51,16 +45,14 @@ public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int du
   @Override
   public boolean transition(Drawable current, ViewAdapter adapter) {
     Drawable previous = adapter.getCurrentDrawable();
-    if (previous != null) {
-      TransitionDrawable transitionDrawable =
-          new TransitionDrawable(new Drawable[] { previous, current });
-      transitionDrawable.setCrossFadeEnabled(isCrossFadeEnabled);
-      transitionDrawable.startTransition(duration);
-      adapter.setDrawable(transitionDrawable);
-      return true;
-    } else {
-      defaultAnimation.transition(current, adapter);
-      return false;
+    if (previous == null) {
+      previous = new ColorDrawable(Color.TRANSPARENT);
     }
+    TransitionDrawable transitionDrawable =
+        new TransitionDrawable(new Drawable[] { previous, current });
+    transitionDrawable.setCrossFadeEnabled(isCrossFadeEnabled);
+    transitionDrawable.startTransition(duration);
+    adapter.setDrawable(transitionDrawable);
+    return true;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index 788901575..fca34c71a 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -26,9 +26,14 @@ public static ByteBuffer fromFile(File file) throws IOException {
     RandomAccessFile raf = null;
     FileChannel channel = null;
     try {
+      long fileLength = file.length();
+      // See #2240.
+      if (fileLength > Integer.MAX_VALUE) {
+        throw new IOException("File too large to map into memory");
+      }
       raf = new RandomAccessFile(file, "r");
       channel = raf.getChannel();
-      return channel.map(FileChannel.MapMode.READ_ONLY, 0, file.length()).load();
+      return channel.map(FileChannel.MapMode.READ_ONLY, 0, fileLength).load();
     } finally {
       if (channel != null) {
         try {
@@ -48,6 +53,7 @@ public static ByteBuffer fromFile(File file) throws IOException {
   }
 
   public static void toFile(ByteBuffer buffer, File file) throws IOException {
+    buffer.position(0);
     RandomAccessFile raf = null;
     FileChannel channel = null;
     try {
diff --git a/library/src/main/java/com/bumptech/glide/util/LogTime.java b/library/src/main/java/com/bumptech/glide/util/LogTime.java
index 834fc161d..344dbaa12 100644
--- a/library/src/main/java/com/bumptech/glide/util/LogTime.java
+++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java
@@ -24,7 +24,7 @@ public static long getLogTime() {
     if (Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT) {
       return SystemClock.elapsedRealtimeNanos();
     } else {
-      return System.currentTimeMillis();
+      return SystemClock.uptimeMillis();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/LruCache.java b/library/src/main/java/com/bumptech/glide/util/LruCache.java
index 0d47fd7d7..1311fa176 100644
--- a/library/src/main/java/com/bumptech/glide/util/LruCache.java
+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java
@@ -55,6 +55,13 @@ protected int getSize(Y item) {
     return 1;
   }
 
+  /**
+   * Returns the number of entries stored in cache.
+   */
+  protected synchronized int getCount() {
+    return cache.size();
+  }
+
   /**
    * A callback called whenever an item is evicted from the cache. Subclasses can override.
    *
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index ea66b1126..ed5224809 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -4,6 +4,7 @@
 import android.graphics.Bitmap;
 import android.os.Build;
 import android.os.Looper;
+import com.bumptech.glide.load.model.Model;
 import com.bumptech.glide.request.target.Target;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -15,6 +16,8 @@
  * A collection of assorted utility classes.
  */
 public final class Util {
+  private static final int HASH_MULTIPLIER = 31;
+  private static final int HASH_ACCUMULATOR = 17;
   private static final char[] HEX_CHAR_ARRAY = "0123456789abcdef".toCharArray();
   // 32 bytes from sha-256 -> 64 hex chars.
   private static final char[] SHA_256_CHARS = new char[64];
@@ -187,4 +190,43 @@ public static boolean isOnBackgroundThread() {
   public static boolean bothNullOrEqual(Object a, Object b) {
     return a == null ? b == null : a.equals(b);
   }
+
+  public static boolean bothModelsNullEquivalentOrEquals(Object a, Object b) {
+    if (a == null) {
+      return b == null;
+    }
+    if (a instanceof Model) {
+      return ((Model) a).isEquivalentTo(b);
+    }
+    return a.equals(b);
+  }
+
+  public static int hashCode(int value) {
+    return hashCode(value, HASH_ACCUMULATOR);
+  }
+
+  public static int hashCode(int value, int accumulator) {
+    return accumulator * HASH_MULTIPLIER + value;
+  }
+
+  public static int hashCode(float value) {
+    return hashCode(value, HASH_ACCUMULATOR);
+  }
+
+  public static int hashCode(float value, int accumulator) {
+    return hashCode(Float.floatToIntBits(value), accumulator);
+  }
+
+  public static int hashCode(Object object, int accumulator) {
+    return hashCode(object == null ? 0 : object.hashCode(), accumulator);
+  }
+
+  public static int hashCode(boolean value, int accumulator) {
+    return hashCode(value ? 1 : 0, accumulator);
+  }
+
+  public static int hashCode(boolean value) {
+    return hashCode(value, HASH_ACCUMULATOR);
+  }
+
 }
diff --git a/library/src/test/java/com/bumptech/glide/GlideContextTest.java b/library/src/test/java/com/bumptech/glide/GlideContextTest.java
new file mode 100644
index 000000000..199ecb38e
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/GlideContextTest.java
@@ -0,0 +1,71 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.util.Log;
+import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.ImageViewTargetFactory;
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public final class GlideContextTest {
+  private Map<Class<?>, TransitionOptions<?, ?>> transitionOptions;
+  private GlideContext context;
+
+  @Before
+  public void setUp() {
+    Application app = RuntimeEnvironment.application;
+
+    transitionOptions = new HashMap<>();
+    context = new GlideContext(app, new Registry(),
+        new ImageViewTargetFactory(), new RequestOptions(),
+        transitionOptions, mock(Engine.class), Log.DEBUG);
+  }
+
+  @Test
+  public void getDefaultTransitionOptions_withNoOptionsRegistered_returnsDefaultOptions() {
+    assertThat(context.getDefaultTransitionOptions(Object.class))
+        .isEqualTo(GlideContext.DEFAULT_TRANSITION_OPTIONS);
+  }
+
+  @Test
+  public void getDefaultTransitionOptions_withNonMatchingOptionRegistered_returnsDefaultOptions() {
+    transitionOptions.put(Bitmap.class, new GenericTransitionOptions<>());
+    assertThat(context.getDefaultTransitionOptions(Drawable.class))
+        .isEqualTo(GlideContext.DEFAULT_TRANSITION_OPTIONS);
+  }
+
+  @Test
+  public void getDefaultTransitionOptions_withMatchingOptionsRegistered_returnsMatchingOptions() {
+    GenericTransitionOptions<Object> expected = new GenericTransitionOptions<>();
+    transitionOptions.put(Bitmap.class, expected);
+    assertThat(context.getDefaultTransitionOptions(Bitmap.class))
+        .isEqualTo(expected);
+  }
+
+  @Test
+  public void getDefaultTransitionOptions_withSuperClassRegistered_returnsSuperClassOptions() {
+    DrawableTransitionOptions expected = new DrawableTransitionOptions();
+    transitionOptions.put(Drawable.class, expected);
+    assertThat(context.getDefaultTransitionOptions(BitmapDrawable.class))
+        .isEqualTo(expected);
+    assertThat(context.getDefaultTransitionOptions(GifDrawable.class))
+        .isEqualTo(expected);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index 62a086519..93f70d040 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide;
 
 import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
+import static com.bumptech.glide.request.RequestOptions.errorOf;
 import static com.bumptech.glide.request.RequestOptions.placeholderOf;
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.Matchers.anyInt;
@@ -12,6 +13,7 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
+import static org.robolectric.Shadows.shadowOf;
 
 import android.content.ContentResolver;
 import android.content.Context;
@@ -77,9 +79,9 @@
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
-import org.robolectric.res.builder.RobolectricPackageManager;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
+import org.robolectric.shadows.ShadowPackageManager;
 
 /**
  * Tests for the {@link Glide} interface and singleton.
@@ -100,7 +102,7 @@
   public void setUp() throws Exception {
     Glide.tearDown();
 
-    RobolectricPackageManager pm = RuntimeEnvironment.getRobolectricPackageManager();
+    ShadowPackageManager pm = shadowOf(RuntimeEnvironment.application.getPackageManager());
     ApplicationInfo info =
         pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
     info.metaData = new Bundle();
@@ -486,7 +488,7 @@ public void testNullModelDoesNotThrow() {
     Drawable drawable = new ColorDrawable(Color.RED);
     requestManager
         .load(null)
-        .apply(placeholderOf(drawable))
+        .apply(errorOf(drawable))
         .into(target);
 
     verify(target).onLoadFailed(eq(drawable));
@@ -522,6 +524,18 @@ public void testNullModelPrefersFallbackDrawable() {
     verify(target).onLoadFailed(eq(fallback));
   }
 
+  @Test
+  public void testNullModelResolvesToUsePlaceholder() {
+    Drawable placeholder = new ColorDrawable(Color.GREEN);
+
+    requestManager
+        .load(null)
+        .apply(placeholderOf(placeholder))
+        .into(target);
+
+    verify(target).onLoadFailed(eq(placeholder));
+  }
+
   @Test
   public void testByteData() {
     byte[] data = new byte[] { 1, 2, 3, 4, 5, 6 };
@@ -662,7 +676,7 @@ public void applyOptions(Context context, GlideBuilder builder) {
     }
 
     @Override
-    public void registerComponents(Context context, Registry registry) {
+    public void registerComponents(Context context, Glide glide, Registry registry) {
       registerMockModelLoader(GlideUrl.class, InputStream.class,
           new ByteArrayInputStream(new byte[0]), registry);
       registerMockModelLoader(File.class, InputStream.class,
diff --git a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
index f1b8b51e8..08517533e 100644
--- a/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java
@@ -8,6 +8,7 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
+import android.support.annotation.NonNull;
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import java.util.ArrayList;
@@ -45,6 +46,7 @@ public void testGetItemsIsCalledIncreasing() {
     final AtomicInteger calledCount = new AtomicInteger();
 
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         called.set(true);
@@ -75,11 +77,13 @@ public void testGetItemsIsCalledInOrderIncreasing() {
         return new int[] { 10, 10 };
       }
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects.subList(position - 11, position + 1 - 11);
       }
 
+      @NonNull
       @Override
       @SuppressWarnings("unchecked")
       public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
@@ -98,6 +102,7 @@ public void testGetItemsIsCalledDecreasing() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         // Ignore the preload caused from us starting at the end
@@ -133,6 +138,7 @@ public void testGetItemsIsCalledInOrderDecreasing() {
         return new int[] { 10, 10 };
       }
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position == 40) {
@@ -141,6 +147,7 @@ public void testGetItemsIsCalledInOrderDecreasing() {
         return objects.subList(position, position + 1);
       }
 
+      @NonNull
       @Override
       @SuppressWarnings("unchecked")
       public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
@@ -160,6 +167,7 @@ public void testGetItemsIsNeverCalledWithEndGreaterThanTotalItems() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         called.set(true);
@@ -179,6 +187,7 @@ public void testGetItemsIsNeverCalledWithStartLessThanZero() {
     final AtomicBoolean called = new AtomicBoolean(false);
     final AtomicInteger calledCount = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position >= 17) {
@@ -202,6 +211,7 @@ public void testGetItemsIsNeverCalledWithStartLessThanZero() {
   public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
     final AtomicInteger called = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         final int current = called.getAndIncrement();
@@ -222,6 +232,7 @@ public void testDontPreloadItemsRepeatedlyWhileIncreasing() {
   public void testDontPreloadItemsRepeatedlyWhileDecreasing() {
     final AtomicInteger called = new AtomicInteger();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         if (position >= 20) {
@@ -249,6 +260,7 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
       private int expectedPosition = (1 + 10) * 2;
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects;
@@ -262,6 +274,7 @@ public void testMultipleItemsForPositionIncreasing() throws NoSuchFieldException
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
+      @NonNull
       @Override
       public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         return request;
@@ -285,6 +298,7 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
       private int expectedPosition = objects.size() * 2 - 1;
 
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects;
@@ -298,6 +312,7 @@ public void testMultipleItemsForPositionDecreasing() throws NoSuchFieldException
         return itemPosition == 0 ? new int[] { 10, 11 } : new int[] { 20, 21 };
       }
 
+      @NonNull
       @Override
       public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         return request;
@@ -334,11 +349,13 @@ public void testItemsArePreloadedWithGlide() {
     objects.add(new Object());
     final HashSet<Object> loadedObjects = new HashSet<>();
     ListPreloaderAdapter preloaderAdapter = new ListPreloaderAdapter() {
+      @NonNull
       @Override
       public List<Object> getPreloadItems(int position) {
         return objects.subList(position - 11, position - 10);
       }
 
+      @NonNull
       @Override
       public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
         loadedObjects.add(item);
@@ -358,6 +375,7 @@ public void testItemsArePreloadedWithGlide() {
     public ListPreloaderAdapter() {
     }
 
+    @NonNull
     @Override
     public List<Object> getPreloadItems(int position) {
       ArrayList<Object> result = new ArrayList<>(1);
@@ -365,6 +383,7 @@ public ListPreloaderAdapter() {
       return result;
     }
 
+    @NonNull
     @Override
     @SuppressWarnings("unchecked")
     public RequestBuilder<Object> getPreloadRequestBuilder(Object item) {
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index 5ddde8936..22bab0325 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide;
 
 import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.mock;
@@ -8,7 +9,6 @@
 import static org.mockito.Mockito.when;
 
 import android.widget.ImageView;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
@@ -116,7 +116,9 @@ public void runTest() throws Exception {
         .thenReturn(mock(Target.class));
     when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
     when(requestManager.getDefaultRequestOptions())
-        .thenReturn((BaseRequestOptions) new RequestOptions());
+        .thenReturn(new RequestOptions());
+    when(requestManager.getDefaultTransitionOptions(any(Class.class)))
+        .thenReturn(new GenericTransitionOptions<>());
     return new RequestBuilder<>(glide, requestManager, Object.class)
         .load((Object) null);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index b5980ac6b..c3d818ffc 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -8,6 +8,7 @@
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.Priority;
 import java.io.Closeable;
 import java.io.FileNotFoundException;
@@ -75,6 +76,7 @@ protected void close(Closeable data) throws IOException {
       data.close();
     }
 
+    @NonNull
     @Override
     public Class<Closeable> getDataClass() {
       return Closeable.class;
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 6a5cb537c..f442d9684 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -484,6 +484,7 @@ public void runTest() throws Exception {
     boolean isMemoryCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
     boolean onlyRetrieveFromCache = false;
+    boolean isScaleOnlyOrNoTransform = true;
 
     public EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
@@ -513,6 +514,7 @@ public EngineTestHarness() {
           DiskCacheStrategy.ALL,
           transformations,
           false /*isTransformationRequired*/,
+          true,
           options,
           isMemoryCacheable,
           useUnlimitedSourceGeneratorPool,
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
index 6349da7e1..539cefa65 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java
@@ -258,6 +258,7 @@ public void testAllocationOrderRoundRobinsDifferentSizes() {
   }
 
   @Test
+  @SuppressWarnings("deprecation")
   public void testSetsConfigOnBuildersToDefaultIfNotSet() {
     PreFillType.Builder builder = mock(PreFillType.Builder.class);
     when(builder.build())
@@ -267,6 +268,7 @@ public void testSetsConfigOnBuildersToDefaultIfNotSet() {
 
     InOrder order = inOrder(builder);
     order.verify(builder).setConfig(DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888
+        || DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE
         ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
     order.verify(builder).build();
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
index 907acb6ae..b0e2d1402 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -35,6 +35,43 @@ public void tearDown() {
     }
   }
 
+  // Tests for #2331.
+  @Test
+  public void getSanitizedUserAgent_withInvalidAgent_returnsAgentWithInvalidCharactersRemoved() {
+    String invalidUserAgent =
+        "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G八核版(A8H8) Build/LRX21M)";
+    String validUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G???(A8H8) Build/LRX21M)";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, invalidUserAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(validUserAgent);
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withValidAgent_returnsUnmodifiedAgent() {
+    String validUserAgent = "Dalvik/2.1.0 (Linux; U; Android 5.0; P98 4G(A8H8) Build/LRX21M)";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, validUserAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(validUserAgent);
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withMissingAgent_returnsNull() {
+    System.clearProperty(DEFAULT_USER_AGENT_PROPERTY);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isNull();
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withEmptyStringAgent_returnsEmptyString() {
+    String userAgent = "";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, userAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(userAgent);
+  }
+
+  @Test
+  public void getSanitizedUserAgent_withWhitespace_returnsWhitespaceString() {
+    String userAgent = "  \t";
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, userAgent);
+    assertThat(LazyHeaders.Builder.getSanitizedUserAgent()).isEqualTo(userAgent);
+  }
+
   @Test
   public void testIncludesEagerHeaders() {
     Map<String, String> headers = new Builder()
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
deleted file mode 100644
index 4cbfc7e49..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ /dev/null
@@ -1,235 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.collect.Range.closed;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.Build;
-import android.util.DisplayMetrics;
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.ImageHeaderParser;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.bitmap.DownsamplerTest.AllocationSizeBitmap;
-import com.bumptech.glide.tests.Util;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Matchers;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 19, shadows = AllocationSizeBitmap.class)
-public class DownsamplerTest {
-  @Mock private BitmapPool bitmapPool;
-  @Mock private ArrayPool byteArrayPool;
-  private Downsampler downsampler;
-  private Options options;
-  private int initialSdkVersion;
-
-  @Before
-  public void setUp() throws Exception {
-    MockitoAnnotations.initMocks(this);
-    options = new Options();
-    DisplayMetrics displayMetrics =
-        RuntimeEnvironment.application.getResources().getDisplayMetrics();
-    when(byteArrayPool.get(anyInt(), Matchers.eq(byte[].class)))
-        .thenReturn(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
-
-    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
-    parsers.add(new DefaultImageHeaderParser());
-
-    downsampler = new Downsampler(parsers, displayMetrics, bitmapPool, byteArrayPool);
-
-    initialSdkVersion = Build.VERSION.SDK_INT;
-  }
-
-  @After
-  public void tearDown() {
-    Util.setSdkVersionInt(initialSdkVersion);
-  }
-
-  @Test
-  public void testAlwaysArgb8888() throws IOException {
-    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-
-    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_ARGB_8888);
-    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
-    assertEquals(Bitmap.Config.ARGB_8888, result.get().getConfig());
-  }
-
-  @Test
-  public void testPreferRgb565() throws IOException {
-    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-
-    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_RGB_565);
-    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
-    assertEquals(Bitmap.Config.RGB_565, result.get().getConfig());
-  }
-
-  @Test
-  public void testCalculateScaling_withInvalidSourceSizes_doesNotCrash() {
-    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_MOST, 0, 0);
-    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.AT_MOST, -1, -1);
-    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_LEAST, 0, 0);
-    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.CENTER_OUTSIDE, -1, -1);
-  }
-
-  @Test
-  public void testCalculateScaling_withAtMost() {
-    DownsampleStrategy strategy = DownsampleStrategy.AT_MOST;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 75, 75);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(801, 100, 100, 100, strategy, 50, 6);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  @Test
-  public void testCalculateScaling_withAtLeast() {
-    DownsampleStrategy strategy = DownsampleStrategy.AT_LEAST;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 150, 150);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  @Test
-  public void testCalculateScaling_withCenterInside() {
-    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(801, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
-    runScaleTest(87, 78, 100, 100, strategy, 100, 90);
-  }
-
-  @Test
-  public void testCalculateScaling_withCenterOutside() {
-    DownsampleStrategy strategy = DownsampleStrategy.CENTER_OUTSIDE;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 112, 100);
-  }
-
-  @Test
-  public void testCalculateScaling_withNone() {
-    DownsampleStrategy strategy = DownsampleStrategy.NONE;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 200, 200);
-    runScaleTest(400, 400, 100, 100, strategy, 400, 400);
-    runScaleTest(300, 300, 100, 100, strategy, 300, 300);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  // BitmapFactory does not support downsampling wbmp files on platforms <=M. See b/27305903.
-  @Test
-  public void testCalculateScaling_withWbmp() {
-    Util.setSdkVersionInt(23);
-    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
-    BitmapFactory.Options options = new BitmapFactory.Options();
-
-    options.outMimeType = "image/vnd.wap.wbmp";
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100, options);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100, options);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100, options);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100, options);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13, options);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13, options);
-    runScaleTest(801, 100, 100, 100, strategy, 100, 13, options);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100, options);
-    runScaleTest(87, 78, 100, 100, strategy, 100, 90, options);
-  }
-
-  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
-      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight) {
-    runScaleTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy, expectedWidth,
-        expectedHeight, new BitmapFactory.Options());
-  }
-
-  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
-      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight,
-      BitmapFactory.Options options) {
-    Downsampler.calculateScaling(strategy, 0, sourceWidth, sourceHeight, targetWidth, targetHeight,
-        options);
-    assertSize(sourceWidth, sourceHeight, expectedWidth, expectedHeight, options);
-  }
-
-  private static void assertSize(int sourceWidth, int sourceHeight, int expectedWidth,
-      int expectedHeight, BitmapFactory.Options options) {
-    float sampleSize = Math.max(1, options.inSampleSize);
-    int downsampledWidth = (int) ((sourceWidth / sampleSize) + 0.5f);
-    int downsampledHeight = (int) ((sourceHeight / sampleSize) + 0.5f);
-
-    float scaleFactor = options.inScaled && options.inTargetDensity > 0 && options.inDensity > 0
-        ? options.inTargetDensity / (float) options.inDensity : 1f;
-    int scaledWidth = (int) Math.ceil(downsampledWidth * scaleFactor);
-    int scaledHeight = (int) Math.ceil(downsampledHeight * scaleFactor);
-
-    assertThat(scaledWidth).isIn(closed(expectedWidth, expectedWidth + 1));
-    assertThat(scaledHeight).isIn(closed(expectedHeight, expectedHeight + 1));
-  }
-
-  private InputStream compressBitmap(Bitmap bitmap, Bitmap.CompressFormat compressFormat)
-      throws FileNotFoundException {
-    ByteArrayOutputStream os = new ByteArrayOutputStream();
-    bitmap.compress(compressFormat, 100, os);
-    return new ByteArrayInputStream(os.toByteArray());
-  }
-
-  // Robolectric doesn't implement getAllocationByteCount correctly.
-  @Implements(Bitmap.class)
-  public static class AllocationSizeBitmap extends ShadowBitmap {
-
-    @Implementation
-    public int getAllocationByteCount() {
-      return getWidth() * getHeight() * (getConfig() == Bitmap.Config.ARGB_8888 ? 4 : 2);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index 0a1cb5e15..f947b4cc0 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -16,9 +16,12 @@
 
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
 import android.graphics.PixelFormat;
+import android.graphics.PorterDuff.Mode;
+import android.graphics.PorterDuffColorFilter;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
@@ -358,7 +361,7 @@ public void testLoopsASingleTimeIfLoopCountIsSetToOne() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -374,6 +377,7 @@ public void testLoopsForeverIfLoopCountIsSetToLoopForever() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
   }
 
   @Test
@@ -389,7 +393,7 @@ public void testLoopsOnceIfLoopCountIsSetToOneWithThreeFrames() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -405,7 +409,7 @@ public void testLoopsThreeTimesIfLoopCountIsSetToThree() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -418,6 +422,7 @@ public void testCallingStartResetsLoopCounter() {
     drawable.onFrameReady();
     when(frameLoader.getCurrentIndex()).thenReturn(1);
     drawable.onFrameReady();
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     drawable.start();
 
@@ -428,7 +433,7 @@ public void testCallingStartResetsLoopCounter() {
 
     // 4 onFrameReady(), 2 start()
     verify(cb, times(4 + 2)).invalidateDrawable(eq(drawable));
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -442,6 +447,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     drawable.start();
 
     runLoops(initialLoopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     final int newLoopCount = 2;
 
@@ -453,6 +459,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     int numStarts = 2;
     int expectedFrames = (initialLoopCount + newLoopCount) * frameCount + numStarts;
     verify(cb, times(expectedFrames)).invalidateDrawable(eq(drawable));
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test(expected = IllegalArgumentException.class)
@@ -461,7 +468,7 @@ public void testThrowsIfGivenLoopCountLessThanZeroAndNotInfinite() {
   }
 
   @Test
-  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
+  public void testUsesDecoderTotalLoopCountIfLoopCountIsLoopIntrinsic() {
     final int frameCount = 3;
     final int loopCount = 2;
     when(frameLoader.getLoopCount()).thenReturn(loopCount);
@@ -473,8 +480,26 @@ public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
+  }
+
+  @Test
+  public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsForever() {
+    final int frameCount = 3;
+    final int loopCount = 40;
+    when(frameLoader.getLoopCount()).thenReturn(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER);
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
   }
 
+
   @Test
   public void testDoesNotDrawFrameAfterRecycle() {
     Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
@@ -522,7 +547,7 @@ public void testSetAlphaSetsAlphaOnPaint() {
 
   @Test
   public void testSetColorFilterSetsColorFilterOnPaint() {
-    ColorFilter colorFilter = new ColorFilter();
+    ColorFilter colorFilter = new PorterDuffColorFilter(Color.RED, Mode.ADD);
     drawable.setColorFilter(colorFilter);
     verify(paint).setColorFilter(eq(colorFilter));
   }
@@ -551,6 +576,8 @@ private void runLoops(int loopCount, int frameCount) {
     for (int loop = 0; loop < loopCount; loop++) {
       for (int frame = 0; frame < frameCount; frame++) {
         when(frameLoader.getCurrentIndex()).thenReturn(frame);
+        assertTrue("drawable should be started before calling drawable.onFrameReady()",
+            drawable.isRunning());
         drawable.onFrameReady();
       }
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 0c70d91f7..d6db3458b 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -24,15 +24,12 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.DelayTarget;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.FrameCallback;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
-import com.google.common.testing.EqualsTester;
 import java.nio.ByteBuffer;
-import java.util.UUID;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -129,7 +126,7 @@ public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingL
 
     InOrder order = inOrder(gifDecoder, requestBuilder);
     order.verify(gifDecoder).advance();
-    order.verify(requestBuilder).apply(isA(BaseRequestOptions.class));
+    order.verify(requestBuilder).apply(isA(RequestOptions.class));
     order.verify(requestBuilder).into(aTarget());
   }
 
@@ -272,14 +269,6 @@ public void testClearsCompletedLoadOnFrameReadyIfCleared() {
     assertNull(loader.getCurrentFrame());
   }
 
-  @Test
-  public void testFrameSignatureEquality() {
-    UUID first = UUID.randomUUID();
-    new EqualsTester().addEqualityGroup(new GifFrameLoader.FrameSignature(first),
-        new GifFrameLoader.FrameSignature(first))
-        .addEqualityGroup(new GifFrameLoader.FrameSignature()).testEquals();
-  }
-
   @SuppressWarnings("unchecked")
   private static Target<Bitmap> aTarget() {
     return isA(Target.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
index 9d8e2b1b1..b4379c750 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java
@@ -6,6 +6,7 @@
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import org.junit.Before;
 import org.junit.Test;
@@ -59,6 +60,7 @@ public void testBitmapResourceIsRecycled() {
     final String description = "TestDescription";
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);
     Resource<Bitmap> bitmapResource = mockResource();
+    Options options = new Options();
 
     public BitmapBytesTranscoderHarness() {
       when(bitmapResource.get()).thenReturn(bitmap);
@@ -67,7 +69,7 @@ public BitmapBytesTranscoderHarness() {
 
     public String getTranscodedDescription() {
       BitmapBytesTranscoder transcoder = new BitmapBytesTranscoder(compressFormat, quality);
-      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource);
+      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource, options);
 
       return new String(bytesResource.get());
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
index 62689518a..0707a342a 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
@@ -7,6 +7,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import org.junit.Before;
@@ -33,7 +34,7 @@ public void testReturnsBitmapDrawableResourceContainingGivenBitmap() {
     Resource<Bitmap> resource = mockResource();
     when(resource.get()).thenReturn(expected);
 
-    Resource<BitmapDrawable> transcoded = transcoder.transcode(resource);
+    Resource<BitmapDrawable> transcoded = transcoder.transcode(resource, new Options());
 
     assertEquals(expected, transcoded.get().getBitmap());
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
index 1f6d4fd8f..d1cd38b01 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoderTest.java
@@ -5,6 +5,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import java.nio.ByteBuffer;
@@ -33,7 +34,7 @@ public void testReturnsBytesOfGivenGifDrawable() {
       ByteBuffer expected = ByteBuffer.wrap(fakeData.getBytes());
       when(gifDrawable.getBuffer()).thenReturn(expected);
 
-      Resource<byte[]> transcoded = transcoder.transcode(resource);
+      Resource<byte[]> transcoded = transcoder.transcode(resource, new Options());
 
       assertArrayEquals(expected.array(), transcoded.get());
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
index a1d8eb507..0c8713cf2 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/UnitTranscoderTest.java
@@ -3,6 +3,7 @@
 import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
 
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -16,6 +17,6 @@ public void testReturnsTheGivenResource() {
     Resource<Object> resource = mockResource();
     ResourceTranscoder<Object, Object> unitTranscoder = UnitTranscoder.get();
 
-    assertEquals(resource, unitTranscoder.transcode(resource));
+    assertEquals(resource, unitTranscoder.transcode(resource, new Options()));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 3e3372e8e..709573fed 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -2,7 +2,6 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
@@ -99,29 +98,6 @@ public void runTest(Harness harness) {
     });
   }
 
-  @Test
-  public void testCallsRequestManagerOnLowMemory() {
-    runTest(new TestCase() {
-      @Override
-      public void runTest(Harness harness) {
-        RequestManager requestManager = mock(RequestManager.class);
-        harness.setRequestManager(requestManager);
-        harness.onLowMemory();
-        verify(requestManager).onLowMemory();
-      }
-    });
-  }
-
-  @Test
-  public void testNonSupportFragmentCallsOnTrimMemory() {
-    RequestManagerHarness requestManagerHarness = new RequestManagerHarness();
-    int level = 100;
-    RequestManager requestManager = mock(RequestManager.class);
-    requestManagerHarness.setRequestManager(requestManager);
-    requestManagerHarness.onTrimMemory(level);
-    verify(requestManager).onTrimMemory(eq(level));
-  }
-
   @Test
   public void testOnLowMemoryCallOnNullRequestManagerDoesNotCrash() {
     runTest(new TestCase() {
@@ -212,7 +188,7 @@ public ActivityFragmentLifecycle getHarnessLifecycle() {
 
     @Override
     public ActivityFragmentLifecycle getFragmentLifecycle() {
-      return fragment.getLifecycle();
+      return fragment.getGlideLifecycle();
     }
 
     @Override
@@ -270,7 +246,7 @@ public ActivityFragmentLifecycle getHarnessLifecycle() {
 
     @Override
     public ActivityFragmentLifecycle getFragmentLifecycle() {
-      return supportFragment.getLifecycle();
+      return supportFragment.getGlideLifecycle();
     }
 
     @Override
diff --git a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
index 3c7648274..8725e85b7 100644
--- a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
+++ b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -9,6 +9,7 @@
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.os.Bundle;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import java.util.List;
@@ -119,7 +120,7 @@ public void applyOptions(Context context, GlideBuilder builder) {
     }
 
     @Override
-    public void registerComponents(Context context, Registry registry) {
+    public void registerComponents(Context context, Glide glide, Registry registry) {
     }
 
     @Override
@@ -140,7 +141,7 @@ public void applyOptions(Context context, GlideBuilder builder) {
     }
 
     @Override
-    public void registerComponents(Context context, Registry registry) {
+    public void registerComponents(Context context, Glide glide, Registry registry) {
     }
 
     @Override
diff --git a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
deleted file mode 100644
index c5dc2554c..000000000
--- a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
+++ /dev/null
@@ -1,139 +0,0 @@
-package com.bumptech.glide.request;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.graphics.Bitmap;
-import com.bumptech.glide.load.Transformation;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE)
-public class BaseRequestOptionsTest {
-
-  private TestOptions options;
-  @Mock private Transformation<Bitmap> transformation;
-
-  @Before
-  public void setUp() {
-    MockitoAnnotations.initMocks(this);
-    options = new TestOptions();
-  }
-
-  @Test
-  public void testIsTransformationRequired_byDefault_isFalse() {
-    assertThat(options.isTransformationRequired()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationSet_byDefault_isFalse() {
-    assertThat(options.isTransformationSet()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationAllowed_byDefault_isTrue() {
-    assertThat(options.isTransformationAllowed()).isTrue();
-  }
-
-  @Test
-  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
-    TestOptions other = new TestOptions();
-    other.transform(Bitmap.class, transformation);
-    options.apply(other);
-    assertThat(options.isTransformationSet()).isTrue();
-  }
-
-  @Test
-  public void testIsTransformationSet_afterDontTransform_isFalse() {
-    options.dontTransform();
-    assertThat(options.isTransformationSet()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
-    options.dontTransform();
-    assertThat(options.isTransformationAllowed()).isFalse();
-  }
-
-  @Test
-  public void testIsTransformationRequired_afterDontTransform_isFalse() {
-    options.dontTransform();
-    assertThat(options.isTransformationRequired()).isFalse();
-  }
-
-  @Test
-  public void testApplyingDontTransform_overridesTransformations() {
-    options.transform(transformation);
-    options.dontTransform();
-    assertThat(options.isTransformationSet()).isFalse();
-    assertThat(options.isTransformationRequired()).isFalse();
-    assertThat(options.getTransformations()).isEmpty();
-  }
-
-  @Test
-  public void testApplyingTransformation_overridesDontTransform() {
-    options.dontTransform();
-    options.transform(transformation);
-
-    assertThat(options.isTransformationAllowed()).isTrue();
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
-  }
-
-  @Test
-  public void testApplyingOptions_withDontTransform_overridesTransformations() {
-    options.transform(transformation);
-    TestOptions other = new TestOptions();
-    other.dontTransform();
-
-    options.apply(other);
-
-    assertThat(options.isTransformationAllowed()).isFalse();
-    assertThat(options.isTransformationSet()).isFalse();
-    assertThat(options.isTransformationRequired()).isFalse();
-    assertThat(options.getTransformations()).isEmpty();
-  }
-
-  @Test
-  public void testApplyingOptions_withTransformation_overridesDontTransform() {
-    options.dontTransform();
-    TestOptions other = new TestOptions();
-    other.transform(transformation);
-
-    options.apply(other);
-
-    assertThat(options.isTransformationAllowed()).isTrue();
-    assertThat(options.isTransformationSet()).isTrue();
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
-  }
-
-  @Test
-  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
-    options.dontTransform();
-    options.apply(new TestOptions());
-
-    assertThat(options.isTransformationAllowed()).isFalse();
-    assertThat(options.isTransformationRequired()).isFalse();
-    assertThat(options.getTransformations()).isEmpty();
-  }
-
-  @Test
-  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
-    options.transform(transformation);
-    options.apply(new TestOptions());
-
-    assertThat(options.isTransformationAllowed()).isTrue();
-    assertThat(options.isTransformationRequired()).isTrue();
-    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
-  }
-
-  private static class TestOptions extends BaseRequestOptions<TestOptions> {
-    // Empty.
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
new file mode 100644
index 000000000..b8940197b
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -0,0 +1,361 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.Application;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.MultiTransformation;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
+import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.signature.ObjectKey;
+import com.bumptech.glide.util.Util;
+import com.google.common.testing.EqualsTester;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class RequestOptionsTest {
+
+  private RequestOptions options;
+  @Mock private Transformation<Bitmap> transformation;
+  private Application app;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    options = new RequestOptions();
+
+    app = RuntimeEnvironment.application;
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_byDefault_isTrue() {
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withFitCenter_isTrue() {
+    options.fitCenter();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+    options.optionalFitCenter();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCenterInside_isTrue() {
+    options.centerInside();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+    options.optionalCenterInside();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCenterCrop_isFalse() {
+    options.centerCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalCenterCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCircleCrop_isFalse() {
+    options.circleCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.circleCrop();
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withBitmapTransformation_isFalse() {
+    options.transform(transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalTransform(transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withCustomTransformation_isFalse() {
+    options.transform(Bitmap.class, transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+    options.optionalTransform(Bitmap.class, transformation);
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withDownsampleStrategy_isTrue() {
+    options.downsample(DownsampleStrategy.CENTER_OUTSIDE);
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleAndThenDontTransform_isTrue() {
+    options.circleCrop().dontTransform();
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleAndAppliedDontTransform_isTrue() {
+    options.circleCrop();
+    options.apply(new RequestOptions().dontTransform());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withDontTransformAndAppliedNonScaleTransform_isFalse() {
+    options.fitCenter();
+    options.apply(new RequestOptions().circleCrop());
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleOnly_andAppliedWithScaleOnly_isTrue() {
+    options.circleCrop();
+    options.apply(new RequestOptions().fitCenter());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withScaleOnlyAndAppliedWithoutTransform_isTrue() {
+    options.fitCenter();
+    options.apply(new RequestOptions().dontAnimate());
+    assertThat(options.isScaleOnlyOrNoTransform()).isTrue();
+  }
+
+  @Test
+  public void isScaleOnlyOrNoTransform_withNonScaleOnlyAndAppliedWithoutTransform_isFalse() {
+    options.circleCrop();
+    options.apply(new RequestOptions().dontAnimate());
+    assertThat(options.isScaleOnlyOrNoTransform()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_byDefault_isFalse() {
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationSet_byDefault_isFalse() {
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_byDefault_isTrue() {
+    assertThat(options.isTransformationAllowed()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
+    RequestOptions other = new RequestOptions();
+    other.transform(Bitmap.class, transformation);
+    options.apply(other);
+    assertThat(options.isTransformationSet()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationAllowed()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testApplyingDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingTransformation_overridesDontTransform() {
+    options.dontTransform();
+    options.transform(transformation);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingOptions_withDontTransform_overridesTransformations() {
+    options.transform(transformation);
+    RequestOptions other = new RequestOptions();
+    other.dontTransform();
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingOptions_withTransformation_overridesDontTransform() {
+    options.dontTransform();
+    RequestOptions other = new RequestOptions();
+    other.transform(transformation);
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationSet()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
+    options.dontTransform();
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
+    options.transform(transformation);
+    options.apply(new RequestOptions());
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  @SuppressWarnings({"unchecked", "varargs"})
+  public void testApplyMultiTransform() {
+    options.transforms(new CircleCrop(), new CenterCrop());
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsKey(Bitmap.class);
+    assertThat(options.getTransformations().get(Bitmap.class))
+      .isInstanceOf(MultiTransformation.class);
+  }
+
+  @Test
+  public void testEqualsHashCode() {
+    Drawable first = new ColorDrawable(Color.RED);
+    Drawable second = new GradientDrawable();
+    assertThat(first).isNotEqualTo(second);
+    assertThat(Util.bothNullOrEqual(first, second)).isFalse();
+    new EqualsTester()
+        .addEqualityGroup(
+            new RequestOptions().sizeMultiplier(.7f),
+            new RequestOptions().sizeMultiplier(.7f))
+        .addEqualityGroup(new RequestOptions().sizeMultiplier(0.8f))
+        .addEqualityGroup(new RequestOptions().error(1), new RequestOptions().error(1))
+        .addEqualityGroup(new RequestOptions().error(2))
+        .addEqualityGroup(new RequestOptions().error(first), new RequestOptions().error(first))
+        .addEqualityGroup(new RequestOptions().error(second))
+        .addEqualityGroup(new RequestOptions().placeholder(1), new RequestOptions().placeholder(1))
+        .addEqualityGroup(new RequestOptions().placeholder(2))
+        .addEqualityGroup(
+            new RequestOptions().placeholder(first),
+            new RequestOptions().placeholder(first))
+        .addEqualityGroup(new RequestOptions().placeholder(second))
+        .addEqualityGroup(new RequestOptions().fallback(1), new RequestOptions().fallback(1))
+        .addEqualityGroup(new RequestOptions().fallback(2))
+        .addEqualityGroup(
+            new RequestOptions().fallback(first),
+            new RequestOptions().fallback(first))
+        .addEqualityGroup(new RequestOptions().fallback(second))
+        .addEqualityGroup(
+            new RequestOptions().skipMemoryCache(true),
+            new RequestOptions().skipMemoryCache(true))
+        .addEqualityGroup(
+            new RequestOptions(),
+            new RequestOptions().skipMemoryCache(false),
+            new RequestOptions().theme(null),
+            new RequestOptions().onlyRetrieveFromCache(false),
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(false))
+        .addEqualityGroup(
+            new RequestOptions().override(100),
+            new RequestOptions().override(100, 100))
+        .addEqualityGroup(
+            new RequestOptions().override(200),
+            new RequestOptions().override(200, 200))
+        .addEqualityGroup(
+            new RequestOptions().override(100, 200),
+            new RequestOptions().override(100, 200))
+        .addEqualityGroup(
+            new RequestOptions().override(200, 100),
+            new RequestOptions().override(200, 100))
+        .addEqualityGroup(
+            new RequestOptions().centerCrop(),
+            new RequestOptions().centerCrop())
+        .addEqualityGroup(
+            new RequestOptions().optionalCenterCrop(),
+            new RequestOptions().optionalCenterCrop())
+        .addEqualityGroup(new RequestOptions().fitCenter())
+        .addEqualityGroup(new RequestOptions().circleCrop())
+        .addEqualityGroup(new RequestOptions().centerInside())
+        .addEqualityGroup(
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(true),
+            new RequestOptions().useUnlimitedSourceGeneratorsPool(true))
+        .addEqualityGroup(
+            new RequestOptions().onlyRetrieveFromCache(true),
+            new RequestOptions().onlyRetrieveFromCache(true))
+        .addEqualityGroup(
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL),
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.ALL))
+        .addEqualityGroup(
+            new RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE))
+        .addEqualityGroup(
+            new RequestOptions().priority(Priority.HIGH),
+            new RequestOptions().priority(Priority.HIGH))
+        .addEqualityGroup(
+            new RequestOptions().priority(Priority.LOW))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.<Boolean>memory("test"), true),
+            new RequestOptions().set(Option.<Boolean>memory("test"), true))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.<Boolean>memory("test"), false))
+        .addEqualityGroup(
+            new RequestOptions().set(Option.<Boolean>memory("test2"), true))
+        .addEqualityGroup(
+            new RequestOptions().decode(Integer.class),
+            new RequestOptions().decode(Integer.class))
+        .addEqualityGroup(
+            new RequestOptions().decode(Float.class))
+        .addEqualityGroup(
+            new RequestOptions().signature(new ObjectKey("test")),
+            new RequestOptions().signature(new ObjectKey("test")))
+        .addEqualityGroup(
+            new RequestOptions().signature(new ObjectKey("test2")))
+        .addEqualityGroup(
+            new RequestOptions().theme(app.getTheme()),
+            new RequestOptions().theme(app.getTheme()))
+        .testEquals();
+  }
+
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index c0e60f63c..fc06b4087 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -50,7 +50,7 @@
 @Config(manifest = Config.NONE, sdk = 18)
 @SuppressWarnings("rawtypes")
 public class SingleRequestTest {
-  private RequestHarness harness;
+  private RequestHarness harness = new RequestHarness();
 
   /**
    * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
@@ -77,6 +77,7 @@
     Key signature = mock(Key.class);
     Priority priority = Priority.HIGH;
     boolean useUnlimitedSourceGeneratorsPool = false;
+    Class<List> transcodeClass = List.class;
 
     Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();
 
@@ -96,8 +97,9 @@ public RequestHarness() {
         .signature(signature)
         .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
       return SingleRequest
-          .obtain(glideContext, model, List.class, requestOptions, overrideWidth, overrideHeight,
-              priority, target, requestListener, requestCoordinator, engine, factory);
+          .obtain(glideContext, model, transcodeClass, requestOptions, overrideWidth,
+              overrideHeight, priority, target, requestListener, requestCoordinator, engine,
+              factory);
     }
   }
 
@@ -277,7 +279,7 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
     verify(harness.engine, times(1))
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), any(Options.class),
+            eq(harness.transformations), anyBoolean(), anyBoolean(), any(Options.class),
             anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
   }
 
@@ -296,7 +298,7 @@ public void testEngineLoadCancelledOnCancel() {
     when(harness.engine
        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
           eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-          eq(harness.transformations), anyBoolean(), any(Options.class),
+          eq(harness.transformations), anyBoolean(), anyBoolean(), any(Options.class),
           anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenReturn(loadStatus);
 
@@ -354,7 +356,7 @@ public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
 
     MockTarget target = new MockTarget();
 
-    harness.placeholderDrawable = placeholder;
+    harness.errorDrawable = placeholder;
     harness.target = target;
     harness.model = null;
     SingleRequest<List> request = harness.getRequest();
@@ -541,7 +543,7 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            anyBoolean(), any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
             any(ResourceCallback.class)))
         .thenAnswer(new Answer<Object>() {
           @Override
@@ -656,7 +658,7 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            anyBoolean(), any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
             any(ResourceCallback.class));
   }
 
@@ -678,7 +680,7 @@ public void testCanReRunCancelledRequests() {
     when(harness.engine
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), any(Options.class),
+            eq(harness.transformations), anyBoolean(), anyBoolean(), any(Options.class),
             anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenAnswer(new CallResourceCallback(harness.resource));
     SingleRequest<List> request = harness.getRequest();
@@ -708,7 +710,7 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            anyBoolean(), any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
             any(ResourceCallback.class));
   }
 
@@ -727,7 +729,7 @@ public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), eq(Boolean.TRUE), anyBoolean(),
+            anyBoolean(), any(Options.class), anyBoolean(), eq(Boolean.TRUE), anyBoolean(),
             any(ResourceCallback.class));
   }
 
@@ -745,10 +747,59 @@ public void testCallsSourceExecutorEngineIfOptionsIsSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), eq(Boolean.FALSE), anyBoolean(),
+            anyBoolean(), any(Options.class), anyBoolean(), eq(Boolean.FALSE), anyBoolean(),
             any(ResourceCallback.class));
   }
 
+  @Test
+  public void testIsEquivalentTo() {
+    SingleRequest<List> originalRequest1 = harness.getRequest();
+    SingleRequest<List> originalRequest2 = harness.getRequest();
+    assertTrue(originalRequest1.isEquivalentTo(originalRequest2));
+
+    harness = new RequestHarness();
+    harness.overrideWidth = harness.overrideWidth * 2;
+    SingleRequest<List> widthRequest = harness.getRequest();
+    assertTrue(widthRequest.isEquivalentTo(widthRequest));
+    assertFalse(widthRequest.isEquivalentTo(originalRequest1));
+    assertFalse(originalRequest1.isEquivalentTo(widthRequest));
+
+    harness = new RequestHarness();
+    harness.overrideHeight = harness.overrideHeight * 2;
+    SingleRequest<List> heightRequest = harness.getRequest();
+    assertTrue(heightRequest.isEquivalentTo(heightRequest));
+    assertFalse(heightRequest.isEquivalentTo(originalRequest1));
+    assertFalse(originalRequest1.isEquivalentTo(heightRequest));
+
+    harness = new RequestHarness();
+    harness.model = 12345679;
+    SingleRequest<List> modelRequest = harness.getRequest();
+    assertTrue(modelRequest.isEquivalentTo(modelRequest));
+    assertFalse(modelRequest.isEquivalentTo(originalRequest1));
+    assertFalse(originalRequest1.isEquivalentTo(modelRequest));
+
+    harness = new RequestHarness();
+    harness.model = null;
+    SingleRequest<List> nullModelRequest = harness.getRequest();
+    assertTrue(nullModelRequest.isEquivalentTo(nullModelRequest));
+    assertFalse(nullModelRequest.isEquivalentTo(originalRequest1));
+    assertFalse(originalRequest1.isEquivalentTo(nullModelRequest));
+
+    harness = new RequestHarness();
+    harness.errorDrawable = new ColorDrawable(Color.GRAY);
+    SingleRequest<List> errorRequest = harness.getRequest();
+    assertTrue(errorRequest.isEquivalentTo(errorRequest));
+    assertFalse(errorRequest.isEquivalentTo(originalRequest1));
+    assertFalse(originalRequest1.isEquivalentTo(errorRequest));
+
+    harness = new RequestHarness();
+    harness.priority = Priority.LOW;
+    SingleRequest<List> priorityRequest = harness.getRequest();
+    assertTrue(priorityRequest.isEquivalentTo(priorityRequest));
+    assertFalse(priorityRequest.isEquivalentTo(originalRequest1));
+    assertFalse(originalRequest1.isEquivalentTo(priorityRequest));
+  }
+
   // TODO do we want to move these to Util?
   @SuppressWarnings("unchecked")
   private static <T> Transition<T> mockTransition() {
@@ -835,6 +886,11 @@ public void onResourceReady(List resource, Transition<? super List> transition)
     public void getSize(SizeReadyCallback cb) {
     }
 
+    @Override
+    public void removeCallback(SizeReadyCallback cb) {
+      // Do nothing.
+    }
+
     @Override
     public void setRequest(Request request) {
     }
diff --git a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index 0b982933f..cf2087c8c 100644
--- a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -330,4 +330,25 @@ public void testDoesNotNotifyParentOnThumbRequestComplete() {
 
     verify(parent, never()).onRequestSuccess(any(Request.class));
   }
+
+  @Test
+  public void testIsEquivalentTo() {
+    ThumbnailRequestCoordinator first = new ThumbnailRequestCoordinator();
+    when(full.isEquivalentTo(full)).thenReturn(true);
+    when(thumb.isEquivalentTo(thumb)).thenReturn(true);
+    first.setRequests(full, thumb);
+    assertTrue(first.isEquivalentTo(first));
+
+    ThumbnailRequestCoordinator second = new ThumbnailRequestCoordinator();
+    second.setRequests(full, full);
+    assertTrue(second.isEquivalentTo(second));
+    assertFalse(second.isEquivalentTo(first));
+    assertFalse(first.isEquivalentTo(second));
+
+    ThumbnailRequestCoordinator third = new ThumbnailRequestCoordinator();
+    third.setRequests(thumb, thumb);
+    assertTrue(third.isEquivalentTo(third));
+    assertFalse(third.isEquivalentTo(first));
+    assertFalse(first.isEquivalentTo(third));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index a31adc29c..e8a603d36 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -13,10 +13,12 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
+import android.content.Context;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.view.View;
 import android.view.ViewTreeObserver;
+import android.view.WindowManager;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.tests.Util;
@@ -31,10 +33,12 @@
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.ShadowDisplay;
 import org.robolectric.shadows.ShadowView;
 
 @RunWith(RobolectricTestRunner.class)
@@ -63,6 +67,7 @@ public void setUp() {
   @After
   public void tearDown() {
     Util.setSdkVersionInt(sdkVersion);
+    ViewTarget.SizeDeterminer.maxDisplayLength = null;
   }
 
   @Test
@@ -123,46 +128,54 @@ public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet()
   }
 
   @Test
-  public void getSize_withBothWrapContent_returnsSizeOriginal() {
+  public void getSize_withBothWrapContent_usesDisplayDimens() {
     LayoutParams layoutParams =
         new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(layoutParams);
     shadowView.setIsLaidOut(true);
 
+    setDisplayDimens(200, 300);
+
     target.getSize(cb);
 
-    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
+    verify(cb).onSizeReady(300, 300);
   }
 
   @Test
-  public void getSize_withWrapContentWidthAndValidHeight_usesSizeOriginalWidthValidHeight() {
+  public void getSize_withWrapContentWidthAndValidHeight_usesDisplayDimenAndValidHeight() {
     int height = 100;
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
     view.setLayoutParams(params);
     shadowView.setIsLaidOut(true);
 
+    setDisplayDimens(100, 200);
+
     target.getSize(cb);
 
-    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
+    verify(cb).onSizeReady(200, height);
   }
 
   @Test
-  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndSizeOriginalHeight() {
+  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndDisplayDimen() {
     int width = 100;
     LayoutParams params = new LayoutParams(width, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
     shadowView.setIsLaidOut(true);
 
+    setDisplayDimens(200, 100);
+
     target.getSize(cb);
 
-    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
+    verify(cb).onSizeReady(width, 200);
   }
 
   @Test
-  public void getSize_withWrapContentWidthAndMatchParentHeight_usesSizeOriginalWidthAndHeight() {
+  public void getSize_withWrapContentWidthAndMatchParentHeight_usesDisplayDimenWidthAndHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
     view.setLayoutParams(params);
 
+    setDisplayDimens(500, 600);
+
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
@@ -174,25 +187,28 @@ public void getSize_withWrapContentWidthAndMatchParentHeight_usesSizeOriginalWid
 
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
+    verify(cb).onSizeReady(600, height);
   }
 
   @Test
-  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndSizeOriginalHeight() {
+  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndDisplayDimenHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
 
+    setDisplayDimens(300, 400);
+
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
+
     int width = 32;
     shadowView
         .setWidth(width)
         .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
+    verify(cb).onSizeReady(width, 400);
   }
 
   @Test
@@ -380,14 +396,14 @@ public void testDecreasesDimensionsByViewPadding() {
   }
 
   @Test
-  public void getSize_withValidWidthAndHeight_notLaidOut_doesNotCallSizeReady() {
+  public void getSize_withValidWidthAndHeight_notLaidOut_notLayoutRequested_callsSizeReady() {
     shadowView
         .setWidth(100)
         .setHeight(100)
         .setIsLaidOut(false);
     target.getSize(cb);
 
-    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+    verify(cb).onSizeReady(100, 100);
   }
 
   @Test
@@ -403,7 +419,7 @@ public void getSize_withLayoutParams_notLaidOut_doesCallSizeReady() {
   }
 
   @Test
-  public void getSize_withLayoutParams_zeroWidthHeight_notLaidOut_doesNotCallSizeReady() {
+  public void getSize_withLayoutParams_emptyParams_notLaidOutOrLayoutRequested_callsSizeReady() {
     shadowView
         .setLayoutParams(new LayoutParams(0, 0))
         .setWidth(100)
@@ -411,11 +427,11 @@ public void getSize_withLayoutParams_zeroWidthHeight_notLaidOut_doesNotCallSizeR
         .setIsLaidOut(false);
     target.getSize(cb);
 
-    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+    verify(cb).onSizeReady(100, 100);
   }
 
   @Test
-  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_doesNotCallSizeReady() {
+  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_callsSizeReady() {
     Util.setSdkVersionInt(18);
     shadowView
         .setWidth(100)
@@ -424,7 +440,7 @@ public void getSize_withValidWidthAndHeight_preV19_layoutRequested_doesNotCallSi
 
     target.getSize(cb);
 
-    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+    verify(cb).onSizeReady(100, 100);
   }
 
   @Test
@@ -441,6 +457,19 @@ public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
   }
 
+  private void setDisplayDimens(Integer width, Integer height) {
+    WindowManager windowManager =
+        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
+    ShadowDisplay shadowDisplay = Shadows.shadowOf(windowManager.getDefaultDisplay());
+    if (width != null) {
+      shadowDisplay.setWidth(width);
+    }
+
+    if (height != null) {
+      shadowDisplay.setHeight(height);
+    }
+  }
+
   @Implements(ViewTreeObserver.class)
   public static class PreDrawShadowViewTreeObserver {
     private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
index 98d37cb3d..e02f29e67 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
@@ -2,7 +2,6 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
-import static org.mockito.Mockito.mock;
 
 import android.graphics.drawable.Drawable;
 import com.bumptech.glide.load.DataSource;
@@ -21,9 +20,7 @@
   @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
-    ViewAnimationFactory<Drawable> viewAnimationFactory = mock(ViewAnimationFactory.class);
-    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/,
-        false /*isCrossFadeEnabled*/);
+    factory = new DrawableCrossFadeFactory(100 /*duration*/, false /*isCrossFadeEnabled*/);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index 6ade60e8b..022277447 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -1,10 +1,8 @@
 package com.bumptech.glide.request.transition;
 
 import static com.bumptech.glide.request.transition.Transition.ViewAdapter;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -13,7 +11,6 @@
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
-import android.widget.ImageView;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,13 +27,6 @@ public void setup() {
     harness = new CrossFadeHarness();
   }
 
-  @Test
-  public void testStartsDefaultAnimationIfNoPreviousDrawableIsNotSet() {
-    when(harness.adapter.getView()).thenReturn(harness.view);
-    harness.animation.transition(harness.current, harness.adapter);
-    verify(harness.defaultAnimation).transition(eq(harness.current), eq(harness.adapter));
-  }
-
   @Test
   public void testIgnoresNullViews() {
     when(harness.adapter.getView()).thenReturn(null);
@@ -44,21 +34,28 @@ public void testIgnoresNullViews() {
   }
 
   @Test
-  public void testReturnsFalseIfStartsDefaultAnimation() {
-    assertFalse(harness.animation.transition(harness.current, harness.adapter));
+  public void transition_withNonNullPreviousDrawable_setsTransitionDrawable() {
+    Drawable previous = new ColorDrawable(Color.WHITE);
+    when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
+    harness.animation.transition(harness.current, harness.adapter);
+
+    verify(harness.adapter).setDrawable(any(TransitionDrawable.class));
   }
 
   @Test
-  public void testSetsTransitionDrawableIfPreviousIsNotNull() {
-    Drawable previous = new ColorDrawable(Color.WHITE);
-    when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
+  public void transition_withNullPreviousDrawable_setsTransitionDrawable() {
     harness.animation.transition(harness.current, harness.adapter);
 
     verify(harness.adapter).setDrawable(any(TransitionDrawable.class));
   }
 
   @Test
-  public void testReturnsTrueIfSetsTransitionDrawable() {
+  public void transition_withNoCurrentDrawable_returnsTrue() {
+    assertTrue(harness.animation.transition(harness.current, harness.adapter));
+  }
+
+  @Test
+  public void transition_withCurrentDrawable_returnsTrue() {
     Drawable previous = new ColorDrawable(Color.RED);
     when(harness.adapter.getCurrentDrawable()).thenReturn(previous);
     assertTrue(harness.animation.transition(harness.current, harness.adapter));
@@ -68,11 +65,9 @@ public void testReturnsTrueIfSetsTransitionDrawable() {
   private static class CrossFadeHarness {
     Drawable current = new ColorDrawable(Color.GRAY);
     ViewAdapter adapter = mock(ViewAdapter.class);
-    ImageView view = mock(ImageView.class);
-    Transition<Drawable> defaultAnimation = mock(Transition.class);
     int duration = 200;
     DrawableCrossFadeTransition animation =
-        new DrawableCrossFadeTransition(defaultAnimation, duration, true /*isCrossFadeEnabled*/);
+        new DrawableCrossFadeTransition(duration, true /*isCrossFadeEnabled*/);
   }
 }
 
diff --git a/samples/contacturi/build.gradle b/samples/contacturi/build.gradle
index dccc94939..e8753dd15 100644
--- a/samples/contacturi/build.gradle
+++ b/samples/contacturi/build.gradle
@@ -2,8 +2,8 @@ apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':library')
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
+    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
diff --git a/samples/contacturi/lint.xml b/samples/contacturi/lint.xml
new file mode 100644
index 000000000..ab5a637a0
--- /dev/null
+++ b/samples/contacturi/lint.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+</lint>
diff --git a/samples/contacturi/src/main/AndroidManifest.xml b/samples/contacturi/src/main/AndroidManifest.xml
index ecfd4c859..50cd63461 100644
--- a/samples/contacturi/src/main/AndroidManifest.xml
+++ b/samples/contacturi/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.READ_CONTACTS" />
 
     <application
-        android:allowBackup="true"
+        android:allowBackup="false"
         android:icon="@android:drawable/sym_def_app_icon"
         android:label="@string/app_name"
         android:theme="@style/Theme.AppCompat" >
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
new file mode 100644
index 000000000..14dec10a2
--- /dev/null
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.contacturi;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Ensures that Glide's generated API is created for the Contact Uri sample.
+ */
+@GlideModule
+public class ContactUriModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
index 4fe9526c4..c928f9fd5 100644
--- a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -3,17 +3,22 @@
 import static android.os.Build.VERSION;
 import static android.os.Build.VERSION_CODES;
 
+import android.Manifest;
 import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ContentUris;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.net.Uri;
 import android.os.Bundle;
+import android.provider.ContactsContract;
 import android.provider.ContactsContract.Contacts;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.content.ContextCompat;
 import android.view.View;
+import android.widget.EditText;
 import android.widget.ImageView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 
@@ -26,11 +31,13 @@
  */
 public class MainActivity extends Activity {
   private static final int REQUEST_CONTACT = 1;
+  private static final int READ_CONTACTS = 0;
 
   private ImageView imageViewContact;
   private ImageView imageViewLookup;
   private ImageView imageViewPhoto;
   private ImageView imageViewDisplayPhoto;
+  private EditText numberEntry;
 
   @Override
   protected void onCreate(Bundle savedInstanceState) {
@@ -41,6 +48,16 @@ protected void onCreate(Bundle savedInstanceState) {
     imageViewLookup = (ImageView) findViewById(R.id.image_lookup);
     imageViewPhoto = (ImageView) findViewById(R.id.image_photo);
     imageViewDisplayPhoto = (ImageView) findViewById(R.id.image_display_photo);
+    numberEntry = (EditText) findViewById(R.id.number_entry);
+    // Make sure that user gives application required permissions
+    if (ContextCompat.checkSelfPermission(
+        getApplication(),
+        Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+      // No explanation needed, we can request the permission.
+      ActivityCompat.requestPermissions(this,
+      new String[]{Manifest.permission.READ_CONTACTS},
+      READ_CONTACTS);
+    }
 
     findViewById(R.id.button_pick_contact).setOnClickListener(new View.OnClickListener() {
       @Override
@@ -49,6 +66,18 @@ public void onClick(View v) {
         startActivityForResult(intent, REQUEST_CONTACT);
       }
     });
+
+    findViewById(R.id.button_find).setOnClickListener(new View.OnClickListener() {
+      @Override
+      public void onClick(View v) {
+        Uri uri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI,
+                                       Uri.encode(numberEntry.getText().toString()));
+        GlideApp.with(MainActivity.this)
+                .load(uri)
+                .override(Target.SIZE_ORIGINAL)
+                .into(imageViewLookup);
+        }
+    });
   }
 
   @Override
@@ -72,20 +101,21 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
 
   @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
   private void showContact(long id) {
+    GlideRequests glideRequests = GlideApp.with(this);
     RequestOptions originalSize = new RequestOptions().override(Target.SIZE_ORIGINAL);
 
     Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI, id);
-    Glide.with(this).load(contactUri).apply(originalSize).into(imageViewContact);
+    glideRequests.load(contactUri).apply(originalSize).into(imageViewContact);
 
     Uri lookupUri = Contacts.getLookupUri(getContentResolver(), contactUri);
-    Glide.with(this).load(lookupUri).apply(originalSize).into(imageViewLookup);
+    glideRequests.load(lookupUri).apply(originalSize).into(imageViewLookup);
 
     Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
-    Glide.with(this).load(photoUri).apply(originalSize).into(imageViewPhoto);
+    glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);
 
     if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
       Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
-      Glide.with(this).load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
+      glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
     }
   }
 }
diff --git a/samples/contacturi/src/main/res/layout/activity_main.xml b/samples/contacturi/src/main/res/layout/activity_main.xml
index fe9510388..7834e829d 100644
--- a/samples/contacturi/src/main/res/layout/activity_main.xml
+++ b/samples/contacturi/src/main/res/layout/activity_main.xml
@@ -17,6 +17,28 @@
                 android:layout_height="wrap_content"
                 android:text="@string/pick_contact"/>
 
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:orientation="horizontal">
+
+            <EditText
+                android:id="@+id/number_entry"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:ems="10"
+                android:hint="@string/hint_number_entry"
+                android:inputType="phone" />
+
+            <Button
+                android:id="@+id/button_find"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="@string/button_search_phone" />
+        </LinearLayout>
+
         <TextView
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"
diff --git a/samples/contacturi/src/main/res/values/strings.xml b/samples/contacturi/src/main/res/values/strings.xml
index 63bdff591..b258461bb 100644
--- a/samples/contacturi/src/main/res/values/strings.xml
+++ b/samples/contacturi/src/main/res/values/strings.xml
@@ -6,4 +6,6 @@
     <string name="image_lookup">Image based on lookup Uri, same as contact Uri</string>
     <string name="image_photo">Image based on photo Uri, thumbnail sized, usually 96x96px</string>
     <string name="image_display_photo">Image based on display photo Uri, possibly 512x512px</string>
+    <string name="hint_number_entry">Find by phone number</string>
+    <string name="button_search_phone">Find</string>
 </resources>
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index a0233b7a8..73b2b4e01 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -7,10 +7,9 @@ dependencies {
     }
     annotationProcessor project(':annotation:compiler')
 
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
-    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    compile "com.android.volley:volley:${VOLLEY_VERSION}"
+    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
diff --git a/samples/flickr/lint.xml b/samples/flickr/lint.xml
index 5c710c8c7..ac292ab1a 100644
--- a/samples/flickr/lint.xml
+++ b/samples/flickr/lint.xml
@@ -3,4 +3,5 @@
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
 </lint>
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
index cae1eaf14..9a9be21e1 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
@@ -13,7 +14,7 @@
 @GlideModule
 public class FlickrGlideModule extends AppGlideModule {
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
   }
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index 1b237163e..9539d0006 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -1,14 +1,10 @@
 package com.bumptech.glide.samples.flickr;
 
-import static com.bumptech.glide.GenericTransitionOptions.withNoTransition;
-import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
-import static com.bumptech.glide.request.RequestOptions.priorityOf;
-
 import android.content.Intent;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.v4.app.Fragment;
 import android.support.v7.widget.GridLayoutManager;
 import android.support.v7.widget.RecyclerView;
@@ -21,7 +17,6 @@
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.util.FixedPreloadSizeProvider;
@@ -44,9 +39,9 @@
   private int photoSize;
   private RecyclerView grid;
   private boolean thumbnail;
-  private RequestBuilder<Drawable> fullRequest;
-  private RequestBuilder<Drawable> thumbnailRequest;
-  private RequestBuilder<Drawable> preloadRequest;
+  private GlideRequest<Drawable> fullRequest;
+  private GlideRequest<Drawable> thumbnailRequest;
+  private GlideRequest<Drawable> preloadRequest;
   private GridLayoutManager layoutManager;
 
   public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean thumbnail) {
@@ -66,19 +61,17 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
     photoSize = args.getInt(IMAGE_SIZE_KEY);
     thumbnail = args.getBoolean(THUMBNAIL_KEY);
 
-    fullRequest = Glide.with(this)
+    fullRequest = GlideApp.with(this)
         .asDrawable()
-        .transition(withNoTransition())
-        .apply(centerCropTransform());
+        .centerCrop();
 
-    thumbnailRequest = Glide.with(this)
+    thumbnailRequest = GlideApp.with(this)
         .asDrawable()
-        .transition(withNoTransition())
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA).centerCrop()
-            .override(Api.SQUARE_THUMB_SIZE));
+        .centerCrop()
+        .override(Api.SQUARE_THUMB_SIZE);
 
     preloadRequest =
-        thumbnail ? thumbnailRequest.clone().apply(priorityOf(Priority.HIGH)) : fullRequest;
+        thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
 
     final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
 
@@ -99,7 +92,7 @@ public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
       @Override
       public void onViewRecycled(RecyclerView.ViewHolder holder) {
         PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;
-        Glide.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
+        GlideApp.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
       }
     });
 
@@ -199,11 +192,13 @@ public int getItemCount() {
       return photos.size();
     }
 
+    @NonNull
     @Override
     public List<Photo> getPreloadItems(int position) {
       return photos.subList(position, position + 1);
     }
 
+    @NonNull
     @Override
     public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
       return preloadRequest.load(item);
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index 15f3e56fc..e54856c2a 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -1,14 +1,13 @@
 package com.bumptech.glide.samples.flickr;
 
 import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
-import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 
 import android.content.Intent;
 import android.graphics.Color;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.v4.app.Fragment;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
@@ -17,10 +16,8 @@
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.TextView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
@@ -39,8 +36,8 @@
   private FlickrPhotoListAdapter adapter;
   private List<Photo> currentPhotos;
   private RecyclerView list;
-  private RequestBuilder<Drawable> fullRequest;
-  private RequestBuilder<Drawable> thumbRequest;
+  private GlideRequest<Drawable> fullRequest;
+  private GlideRequest<Drawable> thumbRequest;
   private ViewPreloadSizeProvider<Photo> preloadSizeProvider;
   private LinearLayoutManager layoutManager;
 
@@ -68,8 +65,9 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
     list.setAdapter(adapter);
 
     preloadSizeProvider = new ViewPreloadSizeProvider<>();
-    RecyclerViewPreloader<Photo> preloader = new RecyclerViewPreloader<>(Glide.with(this), adapter,
-        preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
+    RecyclerViewPreloader<Photo> preloader =
+        new RecyclerViewPreloader<>(
+            GlideApp.with(this), adapter, preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
     list.addOnScrollListener(preloader);
     list.setItemViewCacheSize(0);
 
@@ -77,23 +75,23 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
       adapter.setPhotos(currentPhotos);
     }
 
-    final RequestManager requestManager = Glide.with(this);
-    fullRequest = requestManager
+    final GlideRequests glideRequests = GlideApp.with(this);
+    fullRequest = glideRequests
         .asDrawable()
-        .apply(centerCropTransform()
-            .placeholder(new ColorDrawable(Color.GRAY)));
+        .centerCrop()
+        .placeholder(new ColorDrawable(Color.GRAY));
 
-    thumbRequest = requestManager
+    thumbRequest = glideRequests
         .asDrawable()
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
-            .override(Api.SQUARE_THUMB_SIZE))
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .override(Api.SQUARE_THUMB_SIZE)
         .transition(withCrossFade());
 
     list.setRecyclerListener(new RecyclerView.RecyclerListener() {
       @Override
       public void onViewRecycled(RecyclerView.ViewHolder holder) {
         PhotoTitleViewHolder vh = (PhotoTitleViewHolder) holder;
-        requestManager.clear(vh.imageView);
+        glideRequests.clear(vh.imageView);
       }
     });
 
@@ -168,11 +166,13 @@ public int getItemCount() {
       return photos.size();
     }
 
+    @NonNull
     @Override
     public List<Photo> getPreloadItems(int position) {
       return photos.subList(position, position + 1);
     }
 
+    @NonNull
     @Override
     public RequestBuilder<Drawable> getPreloadRequestBuilder(Photo item) {
       return fullRequest.thumbnail(thumbRequest.load(item)).load(item);
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index e29dd3f9d..cedac252f 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -1,9 +1,7 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.res.Resources;
-import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.HandlerThread;
@@ -12,7 +10,6 @@
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentPagerAdapter;
-import android.support.v4.view.MenuItemCompat;
 import android.support.v4.view.ViewPager;
 import android.support.v7.app.AppCompatActivity;
 import android.text.TextUtils;
@@ -23,13 +20,11 @@
 import android.view.ViewGroup;
 import android.widget.SearchView;
 import android.widget.TextView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.samples.flickr.api.Api;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import com.bumptech.glide.samples.flickr.api.Query;
-import com.bumptech.glide.samples.flickr.api.RecentQuery;
 import com.bumptech.glide.samples.flickr.api.SearchQuery;
 import java.io.File;
 import java.util.ArrayList;
@@ -49,6 +44,7 @@
     implements SearchView.OnQueryTextListener {
   private static final String TAG = "FlickrSearchActivity";
   private static final String STATE_QUERY = "state_search_string";
+  private static final Query DEFAULT_QUERY = new SearchQuery("kitten");
 
   private final QueryListener queryListener = new QueryListener();
   private View searching;
@@ -93,8 +89,7 @@ public boolean onCreateOptionsMenu(Menu menu) {
     MenuInflater menuInflater = getMenuInflater();
     menuInflater.inflate(R.menu.search_activity, menu);
 
-    searchView =
-        (SearchView) MenuItemCompat.getActionView(menu.findItem(R.id.search));
+    searchView = (SearchView) menu.findItem(R.id.search).getActionView();
     searchView.setSubmitButtonEnabled(true);
     searchView.setIconified(false);
     searchView.setOnQueryTextListener(this);
@@ -146,7 +141,7 @@ public void onCreate(Bundle savedInstanceState) {
         executeQuery(savedQuery);
       }
     } else {
-      executeQuery(RecentQuery.get());
+      executeQuery(DEFAULT_QUERY);
     }
 
     int smallGridSize = res.getDimensionPixelSize(R.dimen.small_photo_side);
@@ -157,7 +152,8 @@ public void onCreate(Bundle savedInstanceState) {
     if (savedInstanceState == null) {
       // Weight values determined experimentally by measuring the number of incurred GCs while
       // scrolling through the various photo grids/lists.
-      Glide.get(this).preFillBitmapPool(new PreFillType.Builder(smallGridSize).setWeight(1),
+      GlideApp.get(this).preFillBitmapPool(
+          new PreFillType.Builder(smallGridSize).setWeight(1),
           new PreFillType.Builder(mediumGridSize).setWeight(1),
           new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
     }
@@ -187,19 +183,6 @@ protected void onDestroy() {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  @Override
-  public void onTrimMemory(int level) {
-    super.onTrimMemory(level);
-    Glide.get(this).trimMemory(level);
-  }
-
-  @Override
-  public void onLowMemory() {
-    super.onLowMemory();
-    Glide.get(this).clearMemory();
-  }
-
   private void executeSearch(String searchString) {
     Query query = TextUtils.isEmpty(searchString) ? null : new SearchQuery(searchString);
     executeQuery(query);
@@ -284,13 +267,13 @@ public void setPrimaryItem(ViewGroup container, int position, Object object) {
       super.setPrimaryItem(container, position, object);
       if (position != mLastPosition) {
         if (mLastPosition >= 0) {
-          Glide.with(mLastFragment).pauseRequests();
+          GlideApp.with(mLastFragment).pauseRequests();
         }
         Fragment current = (Fragment) object;
         mLastPosition = position;
         mLastFragment = current;
         if (current.isAdded()) {
-          Glide.with(current).resumeRequests();
+          GlideApp.with(current).resumeRequests();
         }
       }
     }
@@ -349,7 +332,7 @@ public void run() {
           return;
         }
 
-        FutureTarget<File> futureTarget = Glide.with(context)
+        FutureTarget<File> futureTarget = GlideApp.with(context)
             .downloadOnly()
             .load(photo)
             .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
@@ -365,7 +348,7 @@ public void run() {
             Log.d(TAG, "Got ExecutionException waiting for background downloadOnly", e);
           }
         }
-        Glide.with(context).clear(futureTarget);
+        GlideApp.with(context).clear(futureTarget);
       }
     }
   }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index b2ab22e31..ba3095dc2 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -7,7 +7,6 @@
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
 import android.widget.ImageView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
 /**
@@ -29,6 +28,6 @@ protected void onCreate(Bundle savedInstanceState) {
     ImageView fullscreenView = (ImageView) findViewById(R.id.fullscreen_view);
     Photo photo = getIntent().getParcelableExtra(ARG_PHOTO);
 
-    Glide.with(this).load(photo).apply(fitCenterTransform()).into(fullscreenView);
+    GlideApp.with(this).load(photo).apply(fitCenterTransform()).into(fullscreenView);
   }
 }
diff --git a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
index 5a53ad9fd..d21744355 100644
--- a/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
+++ b/samples/flickr/src/main/res/layout/flickr_photo_grid_item.xml
@@ -2,6 +2,6 @@
 <com.bumptech.glide.samples.flickr.SquareImageView
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:scaleType="centerCrop"
-       android:layout_width="fill_parent"
-       android:layout_height="fill_parent"
+       android:layout_width="match_parent"
+       android:layout_height="match_parent"
        android:contentDescription="@string/image_description"/>
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index 9f1cce8bc..bc2e3fde3 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -5,8 +5,8 @@ dependencies {
     compile(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
diff --git a/samples/gallery/lint.xml b/samples/gallery/lint.xml
index 5c710c8c7..ac292ab1a 100644
--- a/samples/gallery/lint.xml
+++ b/samples/gallery/lint.xml
@@ -3,4 +3,5 @@
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
 </lint>
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
new file mode 100644
index 000000000..e5d4888ab
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.gallery;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Ensures that Glide's generated API is created for the Gallery sample.
+ */
+@GlideModule
+public final class GalleryModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
index 472c96a0e..30933931c 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -9,8 +9,6 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import java.util.List;
 
@@ -49,11 +47,11 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
   @Override
   public void onLoadFinished(Loader<List<MediaStoreData>> loader,
       List<MediaStoreData> mediaStoreData) {
-    RequestManager requestManager = Glide.with(this);
+    GlideRequests glideRequests = GlideApp.with(this);
     RecyclerAdapter adapter =
-        new RecyclerAdapter(getActivity(), mediaStoreData, requestManager);
+        new RecyclerAdapter(getActivity(), mediaStoreData, glideRequests);
     RecyclerViewPreloader<MediaStoreData> preloader =
-        new RecyclerViewPreloader<>(requestManager, adapter, adapter, 3);
+        new RecyclerViewPreloader<>(glideRequests, adapter, adapter, 3);
     recyclerView.addOnScrollListener(preloader);
     recyclerView.setAdapter(adapter);
   }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index fc8e0315a..cf315b106 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -1,8 +1,16 @@
 package com.bumptech.glide.samples.gallery;
 
+import android.Manifest.permission;
+import android.annotation.TargetApi;
+import android.content.pm.PackageManager;
+import android.os.Build;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
-import com.bumptech.glide.Glide;
+import android.support.v4.content.ContextCompat;
+import android.widget.Toast;
 import com.bumptech.glide.MemoryCategory;
 
 /**
@@ -10,10 +18,53 @@
  */
 public class MainActivity extends FragmentActivity {
 
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main_activity);
-        Glide.get(this).setMemoryCategory(MemoryCategory.HIGH);
+  private static final int REQUEST_READ_STORAGE = 0;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.main_activity);
+    GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
+        && ContextCompat.checkSelfPermission(this, permission.READ_EXTERNAL_STORAGE)
+        != PackageManager.PERMISSION_GRANTED) {
+      requestStoragePermission();
+    } else {
+      replaceFragment();
+    }
+  }
+
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+  private void requestStoragePermission() {
+     ActivityCompat.requestPermissions(this,
+        new String[]{permission.READ_EXTERNAL_STORAGE},
+        REQUEST_READ_STORAGE);
+  }
+
+  private void replaceFragment() {
+    Fragment fragment = new HorizontalGalleryFragment();
+    getSupportFragmentManager()
+        .beginTransaction()
+        .replace(R.id.fragment_container, fragment)
+        .commit();
+  }
+
+  @Override
+  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
+      @NonNull int[] grantResults) {
+    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+    switch (requestCode) {
+      case REQUEST_READ_STORAGE: {
+        // If request is cancelled, the result arrays are empty.
+        if (grantResults.length > 0
+            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+          replaceFragment();
+        } else {
+          Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG)
+              .show();
+          requestStoragePermission();
+        }
+      }
     }
+  }
 }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 16d5171c7..96897779d 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -1,10 +1,9 @@
 package com.bumptech.glide.samples.gallery;
 
-import static com.bumptech.glide.request.RequestOptions.signatureOf;
-
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.v7.widget.RecyclerView;
 import android.view.Display;
 import android.view.LayoutInflater;
@@ -15,9 +14,7 @@
 import android.widget.ImageView;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.load.Key;
-import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.signature.MediaStoreSignature;
 import java.util.Collections;
 import java.util.List;
@@ -31,13 +28,13 @@
 
   private final List<MediaStoreData> data;
   private final int screenWidth;
-  private final RequestBuilder<Drawable> requestBuilder;
+  private final GlideRequest<Drawable> requestBuilder;
 
   private int[] actualDimensions;
 
-  RecyclerAdapter(Context context, List<MediaStoreData> data, RequestManager requestManager) {
+  RecyclerAdapter(Context context, List<MediaStoreData> data, GlideRequests glideRequests) {
     this.data = data;
-    requestBuilder = requestManager.asDrawable().apply(RequestOptions.fitCenterTransform());
+    requestBuilder = glideRequests.asDrawable().fitCenter();
 
     setHasStableIds(true);
 
@@ -75,7 +72,7 @@ public void onBindViewHolder(ListViewHolder viewHolder, int position) {
 
     requestBuilder
         .clone()
-        .apply(signatureOf(signature))
+        .signature(signature)
         .load(current.uri)
         .into(viewHolder.image);
   }
@@ -95,18 +92,20 @@ public int getItemViewType(int position) {
     return 0;
   }
 
+  @NonNull
   @Override
   public List<MediaStoreData> getPreloadItems(int position) {
     return Collections.singletonList(data.get(position));
   }
 
+  @NonNull
   @Override
   public RequestBuilder<Drawable> getPreloadRequestBuilder(MediaStoreData item) {
     MediaStoreSignature signature =
         new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
     return requestBuilder
         .clone()
-        .apply(signatureOf(signature))
+        .signature(signature)
         .load(item.uri);
   }
 
diff --git a/samples/gallery/src/main/res/layout/main_activity.xml b/samples/gallery/src/main/res/layout/main_activity.xml
index 18c1a634f..8a31cf241 100644
--- a/samples/gallery/src/main/res/layout/main_activity.xml
+++ b/samples/gallery/src/main/res/layout/main_activity.xml
@@ -1,8 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-<merge xmlns:android="http://schemas.android.com/apk/res/android">
-    <fragment
-            android:name="com.bumptech.glide.samples.gallery.HorizontalGalleryFragment"
-            android:layout_width="match_parent"
-            android:layout_height="match_parent"
-            android:id="@+id/horizontal_gallery_fragment"/>
-</merge>
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/fragment_container"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent">
+</FrameLayout>
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index e2931ad27..9512035e5 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -5,8 +5,9 @@ dependencies {
     compile(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile 'com.google.code.gson:gson:2.4'
-    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    compile 'com.google.code.gson:gson:2.8.0'
+    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
     annotationProcessor project(':annotation:compiler')
 }
 
diff --git a/samples/giphy/lint.xml b/samples/giphy/lint.xml
index 95a2ab036..94bb2b69c 100644
--- a/samples/giphy/lint.xml
+++ b/samples/giphy/lint.xml
@@ -2,4 +2,5 @@
 <lint>
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
 </lint>
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index 8d3ac29ac..cff2771de 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.INTERNET"/>
 
     <application
-        android:allowBackup="true"
+        android:allowBackup="false"
         android:icon="@android:drawable/sym_def_app_icon"
         android:largeHeap="true"
         android:label="@string/app_name"
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
index fd796461e..fd92665ea 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.samples.giphy;
 
-import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
-
 import android.app.Activity;
 import android.content.ClipData;
 import android.content.ClipboardManager;
@@ -12,7 +10,6 @@
 import android.os.Bundle;
 import android.view.View;
 import android.widget.ImageView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
@@ -61,11 +58,11 @@ public void onClick(View view) {
       }
     });
 
-    RequestBuilder<Drawable> thumbnailRequest = Glide.with(this)
+    RequestBuilder<Drawable> thumbnailRequest = GlideApp.with(this)
         .load(result)
-        .apply(decodeTypeOf(Bitmap.class));
+        .decode(Bitmap.class);
 
-    Glide.with(this)
+    GlideApp.with(this)
         .load(result.images.original.url)
         .thumbnail(thumbnailRequest)
         .listener(new RequestListener<Drawable>() {
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
index 999600314..5381e1f22 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.content.Context;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
@@ -12,7 +13,7 @@
 @GlideModule
 public class GiphyGlideModule extends AppGlideModule {
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
   }
 
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
index 3321f9ab7..5ae74d704 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java
@@ -7,12 +7,12 @@
 import android.content.Intent;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
@@ -34,7 +34,7 @@ protected void onCreate(Bundle savedInstanceState) {
 
     ImageView giphyLogoView = (ImageView) findViewById(R.id.giphy_logo_view);
 
-    Glide.with(this)
+    GlideApp.with(this)
         .load(R.raw.large_giphy_logo)
         .into(giphyLogoView);
 
@@ -42,14 +42,15 @@ protected void onCreate(Bundle savedInstanceState) {
     LinearLayoutManager layoutManager = new LinearLayoutManager(this);
     gifList.setLayoutManager(layoutManager);
 
-    RequestBuilder<Drawable> gifItemRequest = Glide.with(this).asDrawable();
+    RequestBuilder<Drawable> gifItemRequest = GlideApp.with(this)
+        .asDrawable();
 
     ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider =
         new ViewPreloadSizeProvider<>();
     adapter = new GifAdapter(this, gifItemRequest, preloadSizeProvider);
     gifList.setAdapter(adapter);
     RecyclerViewPreloader<Api.GifResult> preloader =
-        new RecyclerViewPreloader<>(Glide.with(this), adapter, preloadSizeProvider, 4);
+        new RecyclerViewPreloader<>(GlideApp.with(this), adapter, preloadSizeProvider, 4);
     gifList.addOnScrollListener(preloader);
   }
 
@@ -83,14 +84,14 @@ public void onSearchComplete(Api.SearchResult result) {
 
     private Api.GifResult[] results = EMPTY_RESULTS;
 
-    public GifAdapter(Activity activity, RequestBuilder<Drawable> requestBuilder,
+    GifAdapter(Activity activity, RequestBuilder<Drawable> requestBuilder,
         ViewPreloadSizeProvider<Api.GifResult> preloadSizeProvider) {
       this.activity = activity;
       this.requestBuilder = requestBuilder;
       this.preloadSizeProvider = preloadSizeProvider;
     }
 
-    public void setResults(Api.GifResult[] results) {
+    void setResults(Api.GifResult[] results) {
       if (results != null) {
         this.results = results;
       } else {
@@ -137,11 +138,13 @@ public int getItemCount() {
       return results.length;
     }
 
+    @NonNull
     @Override
     public List<Api.GifResult> getPreloadItems(int position) {
       return Collections.singletonList(results[position]);
     }
 
+    @NonNull
     @Override
     public RequestBuilder<Drawable> getPreloadRequestBuilder(Api.GifResult item) {
       return requestBuilder.load(item);
@@ -151,7 +154,7 @@ public int getItemCount() {
   private static class GifViewHolder extends RecyclerView.ViewHolder {
     private final ImageView gifView;
 
-    public GifViewHolder(View itemView) {
+    GifViewHolder(View itemView) {
       super(itemView);
       gifView = (ImageView) itemView.findViewById(R.id.gif_view);
     }
diff --git a/samples/imgur/.gitignore b/samples/imgur/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/samples/imgur/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/samples/imgur/build.gradle b/samples/imgur/build.gradle
new file mode 100644
index 000000000..df3acd658
--- /dev/null
+++ b/samples/imgur/build.gradle
@@ -0,0 +1,55 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION
+
+    defaultConfig {
+        applicationId "com.bumptech.glide.samples.imgur"
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+        versionCode 1
+        versionName "1.0"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile project(':library')
+    annotationProcessor project(':annotation:compiler')
+
+    compile "com.google.dagger:dagger:${DAGGER_VERSION}"
+    annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}"
+    compile "com.google.dagger:dagger-android:${DAGGER_VERSION}"
+    compile "com.google.dagger:dagger-android-support:${DAGGER_VERSION}"
+    annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}"
+
+    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+    compile 'com.squareup.retrofit2:retrofit:2.2.0'
+    compile 'com.squareup.retrofit2:converter-gson:2.2.0'
+    compile 'com.squareup.retrofit2:adapter-rxjava:2.2.0'
+
+    compile 'io.reactivex:rxandroid:1.2.1'
+    compile 'io.reactivex:rxjava:1.2.9'
+
+    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
+    compile "com.android.support:cardview-v7:${ANDROID_SUPPORT_VERSION}"
+    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}"
+}
+
+task run(type: Exec, dependsOn: 'installDebug') {
+    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.card/.MainActivity'
+}
diff --git a/samples/imgur/lint.xml b/samples/imgur/lint.xml
new file mode 100644
index 000000000..ac292ab1a
--- /dev/null
+++ b/samples/imgur/lint.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Not supported by all build systems -->
+    <issue id="GradleOverrides" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore"/>
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
+</lint>
diff --git a/samples/imgur/proguard-rules.pro b/samples/imgur/proguard-rules.pro
new file mode 100644
index 000000000..896f865d9
--- /dev/null
+++ b/samples/imgur/proguard-rules.pro
@@ -0,0 +1,25 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/judds/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/samples/imgur/src/main/AndroidManifest.xml b/samples/imgur/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..23f5ec718
--- /dev/null
+++ b/samples/imgur/src/main/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="com.bumptech.glide.samples.imgur">
+  <uses-permission android:name="android.permission.INTERNET" />
+  <application
+    android:allowBackup="false"
+    android:icon="@mipmap/ic_launcher"
+    android:label="@string/app_name"
+    android:roundIcon="@mipmap/ic_launcher_round"
+    android:supportsRtl="true"
+    android:theme="@style/AppTheme"
+    android:name="com.bumptech.glide.samples.imgur.ImgurApplication">
+    <activity android:name="com.bumptech.glide.samples.imgur.MainActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity>
+  </application>
+
+</manifest>
\ No newline at end of file
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
new file mode 100644
index 000000000..d40c24c8c
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ApplicationModule.java
@@ -0,0 +1,16 @@
+package com.bumptech.glide.samples.imgur;
+
+import dagger.Module;
+import dagger.Provides;
+import okhttp3.OkHttpClient;
+
+/**
+ * The Application Dagger module for the Imgur sample.
+ */
+@Module
+public class ApplicationModule {
+  @Provides
+  OkHttpClient okHttpClient() {
+    return new OkHttpClient();
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
new file mode 100644
index 000000000..c2b788e2b
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.samples.imgur;
+
+import dagger.android.AndroidInjector;
+import dagger.android.support.DaggerApplication;
+
+/**
+ * Runs Dagger injection in the Imgur sample.
+ */
+public final class ImgurApplication extends DaggerApplication {
+  @Override
+  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {
+    return DaggerImgurApplicationComponent.create();
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
new file mode 100644
index 000000000..cdfc96e91
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide.samples.imgur;
+
+import com.bumptech.glide.samples.imgur.api.ApiModule;
+import dagger.Component;
+import dagger.android.AndroidInjector;
+import dagger.android.support.AndroidSupportInjectionModule;
+
+import javax.inject.Singleton;
+
+/**
+ * Specifies Dagger modules for {@link ImgurApplication}.
+ */
+@Singleton
+@Component(modules = {
+    AndroidSupportInjectionModule.class,
+    MainActivityModule.class,
+    ApplicationModule.class,
+    ApiModule.class
+})
+public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
new file mode 100644
index 000000000..c673ad244
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurGlideModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.imgur;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Generates a Glide API for the Imgur sample.
+ */
+@GlideModule(glideName = "ImgurGlide")
+public class ImgurGlideModule extends AppGlideModule {
+  // Intentionally Empty.
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
new file mode 100644
index 000000000..384543997
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivity.java
@@ -0,0 +1,114 @@
+package com.bumptech.glide.samples.imgur;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.ViewHolder;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+import com.bumptech.glide.samples.imgur.api.Image;
+import dagger.android.AndroidInjection;
+import java.util.Collections;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Named;
+import rx.Observable;
+import rx.Observer;
+import rx.android.schedulers.AndroidSchedulers;
+import rx.schedulers.Schedulers;
+
+/**
+ * Displays images and GIFs from Imgur in a scrollable list of cards.
+ */
+public final class MainActivity extends AppCompatActivity {
+
+  @Inject @Named("hotViralImages") Observable<List<Image>> fetchImagesObservable;
+  private ImgurImageAdapter adapter;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    AndroidInjection.inject(this);
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+    RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
+
+    recyclerView.setHasFixedSize(true);
+    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
+    recyclerView.setLayoutManager(layoutManager);
+    adapter = new ImgurImageAdapter();
+    recyclerView.setAdapter(adapter);
+
+    fetchImagesObservable
+        .subscribeOn(Schedulers.newThread())
+        .observeOn(AndroidSchedulers.mainThread())
+        .subscribe(new Observer<List<Image>>() {
+          @Override
+          public void onCompleted() { }
+
+          @Override
+          public void onError(Throwable e) { }
+
+          @Override
+          public void onNext(List<Image> images) {
+            adapter.setData(images);
+          }
+        });
+  }
+
+  @Override
+  protected void onDestroy() {
+    super.onDestroy();
+    fetchImagesObservable.unsubscribeOn(AndroidSchedulers.mainThread());
+  }
+
+  private final class ImgurImageAdapter extends RecyclerView.Adapter<ViewHolder> {
+
+    private List<Image> images = Collections.emptyList();
+
+    public void setData(@NonNull List<Image> images) {
+      this.images = images;
+      notifyDataSetChanged();
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      return new ViewHolder(LayoutInflater.from(parent.getContext())
+          .inflate(R.layout.image_card, parent, false));
+    }
+
+    @Override
+    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
+      ViewHolder vh = (ViewHolder) holder;
+      Image image = images.get(position);
+      vh.title.setText(
+          TextUtils.isEmpty(image.title) ? image.description : image.title);
+
+      ImgurGlide.with(vh.imageView)
+          .load(image.link)
+          .into(vh.imageView);
+    }
+
+    @Override
+    public int getItemCount() {
+      return images.size();
+    }
+
+    private final class ViewHolder extends RecyclerView.ViewHolder {
+
+      private final ImageView imageView;
+      private final TextView title;
+
+      ViewHolder(View itemView) {
+        super(itemView);
+        imageView = (ImageView) itemView.findViewById(R.id.image);
+        title = (TextView) itemView.findViewById(R.id.title);
+      }
+    }
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java
new file mode 100644
index 000000000..cef304fb2
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java
@@ -0,0 +1,10 @@
+package com.bumptech.glide.samples.imgur;
+
+import dagger.Module;
+import dagger.android.ContributesAndroidInjector;
+
+@Module
+abstract class MainActivityModule {
+  @ContributesAndroidInjector
+  abstract MainActivity contributeMainActivityInjector();
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
new file mode 100644
index 000000000..85b056916
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java
@@ -0,0 +1,59 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import dagger.Module;
+import dagger.Provides;
+import java.io.IOException;
+import java.util.List;
+import javax.inject.Named;
+import javax.inject.Singleton;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Response;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;
+import retrofit2.converter.gson.GsonConverterFactory;
+import rx.Observable;
+
+/**
+ * Provides classes related to the Imgur API via Dagger.
+ */
+@Singleton
+@Module
+public final class ApiModule {
+
+  @Singleton
+  @Named("hotViralImages")
+  @Provides
+  Observable<List<Image>> provideHotViralImages(ImgurObservables imgurObservables) {
+    return imgurObservables.getHotViralImages(5 /*maxPages*/);
+  }
+
+  @Provides ImgurObservables imgurObservables(ImgurService imgurService) {
+    return new ImgurObservables(imgurService);
+  }
+
+  @Provides ImgurService getImgurService(Retrofit retrofit) {
+    return retrofit.create(ImgurService.class);
+  }
+
+  @Provides Retrofit retrofit() {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .addInterceptor(new Interceptor() {
+          @Override
+          public Response intercept(Chain chain) throws IOException {
+            return chain.proceed(
+                chain.request()
+                    .newBuilder()
+                    .addHeader("Authorization", "Client-ID " + ImgurService.CLIENT_ID)
+                    .build());
+          }
+        })
+        .build();
+    return new Retrofit.Builder()
+        .client(client)
+        .addConverterFactory(GsonConverterFactory.create())
+        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .baseUrl("https://api.imgur.com/3/")
+        .build();
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
new file mode 100644
index 000000000..6466b1527
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Gallery.java
@@ -0,0 +1,19 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import java.util.List;
+
+/**
+ * Represents Imgur's Gallery resource.
+ *
+ * <p>Populated automatically by GSON.
+ */
+public final class Gallery {
+  public List<Image> data;
+
+  @Override
+  public String toString() {
+    return "Gallery{"
+        + "data=" + data
+        + '}';
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
new file mode 100644
index 000000000..3f0008234
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/Image.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.samples.imgur.api;
+
+/**
+ * Represents Imgur's Image resource.
+ *
+ * <p>Populated automatically by GSON
+ */
+public final class Image {
+  public String id;
+  public String title;
+  public String description;
+  public String link;
+  public boolean is_album;
+
+  @Override
+  public String toString() {
+    return "Image{"
+        + "id='" + id + '\''
+        + ", title='" + title + '\''
+        + ", description='" + description + '\''
+        + ", link='" + link + '\''
+        + ", is_album='" + is_album + '\''
+        + '}';
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
new file mode 100644
index 000000000..26d5f034a
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurObservables.java
@@ -0,0 +1,64 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import rx.Observable;
+import rx.functions.Func1;
+import rx.functions.Func2;
+
+/**
+ * Observables for retrieving metadata from Imgur's API.
+ */
+public final class ImgurObservables {
+
+  private final ImgurService imgurService;
+
+  ImgurObservables(ImgurService imgurService) {
+    this.imgurService = imgurService;
+  }
+
+  public Observable<List<Image>> getHotViralImages(int maxPages) {
+    return Observable.range(0, maxPages)
+        .flatMap(new Func1<Integer, Observable<List<Image>>>() {
+          @Override
+          public Observable<List<Image>> call(Integer integer) {
+            return imgurService.getHotViral(integer).map(new GetData()).flatMap(
+                new Func1<List<Image>, Observable<List<Image>>>() {
+                  @Override
+                  public Observable<List<Image>> call(List<Image> images) {
+                    for (Iterator<Image> iterator = images.iterator(); iterator.hasNext();) {
+                      if (iterator.next().is_album) {
+                        iterator.remove();
+                      }
+                    }
+                    return Observable.just(images);
+                  }
+                });
+          }
+        })
+        .takeWhile(new Func1<List<Image>, Boolean>() {
+          @Override
+          public Boolean call(List<Image> images) {
+            return !images.isEmpty();
+          }
+        })
+        .scan(new Func2<List<Image>, List<Image>, List<Image>>() {
+          @Override
+          public List<Image> call(List<Image> images, List<Image> images2) {
+            List<Image> result = new ArrayList<>(images.size() + images2.size());
+            result.addAll(images);
+            result.addAll(images2);
+            return result;
+          }
+        })
+        .cache();
+  }
+
+  private static class GetData implements Func1<Gallery, List<Image>> {
+    @Override
+    public List<Image> call(Gallery gallery) {
+      return gallery.data;
+    }
+  }
+}
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
new file mode 100644
index 000000000..ddab15062
--- /dev/null
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ImgurService.java
@@ -0,0 +1,41 @@
+package com.bumptech.glide.samples.imgur.api;
+
+import retrofit2.http.GET;
+import retrofit2.http.Path;
+import rx.Observable;
+
+/**
+ * Define's Imgur's API for Retrofit.
+ */
+public interface ImgurService {
+  String CLIENT_ID = "36d1f6bef16370c";
+
+  @GET("gallery/hot/viral/{page}")
+  Observable<Gallery> getHotViral(@Path("page") int page);
+
+  @GET("gallery/hot/{sort}/{page}.json")
+  Observable<Gallery> getHot(@Path("sort") Sort sort, @Path("page") int page);
+
+  @GET("gallery/{section}/{sort}/{page}.json")
+  Observable<Gallery> getGallery(@Path("section") Section section,
+      @Path("sort") Sort sort, @Path("page") int page);
+
+  /**
+   * Sections that Imgur's API allows us to query from.
+   */
+  enum Section {
+    hot,
+    top,
+    user
+  }
+
+  /**
+   * The sort order for content within a particular section.
+   */
+  enum Sort {
+    viral,
+    top,
+    time,
+    rising
+  }
+}
diff --git a/samples/imgur/src/main/res/layout/activity_main.xml b/samples/imgur/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..4e7309f0a
--- /dev/null
+++ b/samples/imgur/src/main/res/layout/activity_main.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merge
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:tools="http://schemas.android.com/tools"
+  tools:context="com.bumptech.glide.samples.imgur.MainActivity">
+
+  <android.support.v7.widget.RecyclerView
+    android:id="@+id/recycler_view"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:scrollbars="vertical"
+    />
+</merge>
diff --git a/samples/imgur/src/main/res/layout/image_card.xml b/samples/imgur/src/main/res/layout/image_card.xml
new file mode 100644
index 000000000..92f2cbb76
--- /dev/null
+++ b/samples/imgur/src/main/res/layout/image_card.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:card_view="http://schemas.android.com/apk/res-auto"
+  android:layout_width="match_parent"
+  android:layout_height="wrap_content"
+  android:padding="16dp">
+
+  <android.support.v7.widget.CardView
+    android:id="@+id/card_view"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    card_view:cardCornerRadius="4dp">
+    <LinearLayout
+      android:orientation="vertical"
+      android:padding="16dp"
+      android:gravity="center"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content">
+      <ImageView
+        android:id="@+id/image"
+        android:scaleType="fitCenter"
+        android:layout_width="match_parent"
+        android:layout_height="150dp"
+        android:contentDescription="@null"/>
+      <TextView
+        android:id="@+id/title"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        android:paddingTop="16dp"
+        />
+    </LinearLayout>
+  </android.support.v7.widget.CardView>
+</FrameLayout>
diff --git a/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 000000000..cde69bccc
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher_round.png
new file mode 100644
index 000000000..9a078e3e1
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-hdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 000000000..c133a0cbd
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher_round.png
new file mode 100644
index 000000000..efc028a63
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-mdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 000000000..bfa42f0e7
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..3af2608a4
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xhdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 000000000..324e72cdd
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..9bec2e623
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxhdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 000000000..aee44e138
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
new file mode 100644
index 000000000..34947cd6b
Binary files /dev/null and b/samples/imgur/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png differ
diff --git a/samples/imgur/src/main/res/values/colors.xml b/samples/imgur/src/main/res/values/colors.xml
new file mode 100644
index 000000000..5a077b3a7
--- /dev/null
+++ b/samples/imgur/src/main/res/values/colors.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <color name="colorPrimary">#3F51B5</color>
+  <color name="colorPrimaryDark">#303F9F</color>
+  <color name="colorAccent">#FF4081</color>
+</resources>
diff --git a/samples/imgur/src/main/res/values/strings.xml b/samples/imgur/src/main/res/values/strings.xml
new file mode 100644
index 000000000..73f9f0e5a
--- /dev/null
+++ b/samples/imgur/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+  <string name="app_name">Imgur</string>
+</resources>
diff --git a/samples/imgur/src/main/res/values/styles.xml b/samples/imgur/src/main/res/values/styles.xml
new file mode 100644
index 000000000..ccfe4e02e
--- /dev/null
+++ b/samples/imgur/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+  <!-- Base application theme. -->
+  <style name="AppTheme" parent="Theme.AppCompat">
+    <!-- Customize your theme here. -->
+    <item name="colorPrimary">@color/colorPrimary</item>
+    <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+    <item name="colorAccent">@color/colorAccent</item>
+  </style>
+
+</resources>
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index e244935ea..433c9c4d5 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -4,6 +4,7 @@ dependencies {
     compile project(':library')
     annotationProcessor project(':annotation:compiler')
     compile 'com.caverock:androidsvg:1.2.1'
+    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"
 }
 
 android {
diff --git a/samples/svg/lint.xml b/samples/svg/lint.xml
index 95a2ab036..94bb2b69c 100644
--- a/samples/svg/lint.xml
+++ b/samples/svg/lint.xml
@@ -2,4 +2,5 @@
 <lint>
     <!-- Not supported by all build systems -->
     <issue id="GradleOverrides" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore"/>
 </lint>
diff --git a/samples/svg/src/main/AndroidManifest.xml b/samples/svg/src/main/AndroidManifest.xml
index 7328e723d..bb5888e5e 100644
--- a/samples/svg/src/main/AndroidManifest.xml
+++ b/samples/svg/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.INTERNET"/>
 
     <application
-        android:allowBackup="true"
+        android:allowBackup="false"
         android:icon="@android:drawable/sym_def_app_icon"
         android:label="@string/app_name">
         <activity
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
index 0587c01f7..f60b46461 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.samples.svg;
 
 import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
-import static com.bumptech.glide.request.RequestOptions.placeholderOf;
 
 import android.app.Activity;
 import android.content.ContentResolver;
@@ -12,10 +11,8 @@
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.TextView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
-
 import java.io.File;
 
 /**
@@ -36,10 +33,10 @@ protected void onCreate(Bundle savedInstanceState) {
     imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
     imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);
 
-    requestBuilder = Glide.with(this)
+    requestBuilder = GlideApp.with(this)
         .as(PictureDrawable.class)
-        .apply(placeholderOf(R.drawable.image_loading)
-            .error(R.drawable.image_error))
+        .placeholder(R.drawable.image_loading)
+        .error(R.drawable.image_error)
         .transition(withCrossFade())
         .listener(new SvgSoftwareLayerSetter());
   }
@@ -52,9 +49,10 @@ protected void onStart() {
 
   public void clearCache(View v) {
     Log.w(TAG, "clearing cache");
-    Glide.with(this).clear(imageViewRes);
-    Glide.with(this).clear(imageViewNet);
-    Glide.get(this).clearMemory();
+    GlideRequests glideRequests = GlideApp.with(this);
+    glideRequests.clear(imageViewRes);
+    glideRequests.clear(imageViewNet);
+    GlideApp.get(this).clearMemory();
     File cacheDir = Glide.getPhotoCacheDir(this);
     if (cacheDir.isDirectory()) {
       for (File child : cacheDir.listFiles()) {
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
index 43352acd8..4f600fdc1 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java
@@ -2,7 +2,7 @@
 
 import android.graphics.Picture;
 import android.graphics.drawable.PictureDrawable;
-
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.resource.SimpleResource;
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
@@ -14,7 +14,7 @@
  */
 public class SvgDrawableTranscoder implements ResourceTranscoder<SVG, PictureDrawable> {
   @Override
-  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode) {
+  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode, Options options) {
     SVG svg = toTranscode.get();
     Picture picture = svg.renderToPicture();
     PictureDrawable drawable = new PictureDrawable(picture);
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
index 372fbefb6..798d0f07f 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.graphics.drawable.PictureDrawable;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.annotation.GlideModule;
 import com.bumptech.glide.module.AppGlideModule;
@@ -14,7 +15,7 @@
 @GlideModule
 public class SvgModule extends AppGlideModule {
   @Override
-  public void registerComponents(Context context, Registry registry) {
+  public void registerComponents(Context context, Glide glide, Registry registry) {
     registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
         .append(InputStream.class, SVG.class, new SvgDecoder());
   }
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index c35434caa..4b38c3961 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -122,20 +122,36 @@ afterEvaluate { project ->
             it.buildType.name.equalsIgnoreCase('release')
         }
 
-        task androidJavadocs(type: Javadoc, dependsOn: compileReleaseJavaWithJavac) {
+        def getAndroidCompileSdkVersion = project.android.compileSdkVersion
+
+        def getAndroidSdkDirectory = project.android.sdkDirectory
+
+        def getAndroidJar = "${getAndroidSdkDirectory}/platforms/${getAndroidCompileSdkVersion}/android.jar"
+
+        def getSupportJar = "${getAndroidSdkDirectory}/extras/android/support/v4/android-support-v4.jar"
+
+        task androidJavadocs(type: Javadoc, dependsOn: assembleRelease) {
             source = releaseVariants.collect { it.javaCompile.source }
-            classpath = files(releaseVariants.collect { files(it.javaCompile.classpath.files,
-                    project.android.bootClasspath) })
+            classpath = files(releaseVariants.collect {
+                files(it.javaCompile.classpath.files, getAndroidJar, getSupportJar)
+            })
+            classpath += files("${project.projectDir}/build/intermediates/classes/release")
 
             options {
-                links('http://docs.oracle.com/javase/7/docs/api/')
-                linksOffline('http://d.android.com/reference', "${android.sdkDirectory}/docs/reference")
+                links("http://docs.oracle.com/javase/7/docs/api/")
+                linksOffline("http://d.android.com/reference",
+                    "${getAndroidSdkDirectory}/docs/reference")
             }
 
             exclude '**/BuildConfig.java'
             exclude '**/R.java'
         }
 
+        def cleanJavadocTask = task("cleanJavadocTask", type: Delete) {
+            delete androidJavadocs.destinationDir
+        } as Task
+        project.clean.dependsOn(cleanJavadocTask)
+
         task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
             classifier = 'javadoc'
             from androidJavadocs.destinationDir
@@ -152,6 +168,7 @@ afterEvaluate { project ->
             from compileReleaseJavaWithJavac.destinationDir
             exclude '**/R.class'
             exclude '**/BuildConfig.class'
+            exclude '**/R$*.class'
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
diff --git a/settings.gradle b/settings.gradle
index 650b0e229..20c2b4430 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -12,6 +12,7 @@ include ':samples:giphy'
 include ':samples:svg'
 include ':samples:gallery'
 include ':samples:contacturi'
+include ':samples:imgur'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index 16e6d54fb..a19bcda5f 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -1,10 +1,10 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-    compile "com.android.support:support-annotations:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 
     testCompile project(':testutil')
-    testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
     testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index 90ccfbfc7..257cd98f0 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -20,6 +20,8 @@
   int STATUS_OPEN_ERROR = 2;
   /** Unable to fully decode the current frame. */
   int STATUS_PARTIAL_DECODE = 3;
+  /** The total iteration count which means repeat forever. */
+  int TOTAL_ITERATION_COUNT_FOREVER = 0;
 
   /** Android Lint annotation for status codes that can be used with a GIF decoder. */
   @Retention(RetentionPolicy.SOURCE)
@@ -126,12 +128,55 @@
   void resetFrameIndex();
 
   /**
-   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
+   * Gets the "Netscape" loop count, if any. A count of 0 means repeat indefinitely.
    *
-   * @return iteration count if one was specified, else 1.
+   * @deprecated Use {@link #getNetscapeLoopCount()} instead.
+   *             This method cannot distinguish whether the loop count is 1 or doesn't exist.
+   * @return loop count if one was specified, else 1.
    */
+  @Deprecated
   int getLoopCount();
 
+  /**
+   * Gets the "Netscape" loop count, if any.
+   * A count of 0 ({@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <br>
+   * Use {@link #getTotalIterationCount()}
+   * to know how many times the animation sequence should be displayed.
+   *
+   * @return loop count if one was specified,
+   *         else -1 ({@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}).
+   */
+  int getNetscapeLoopCount();
+
+  /**
+   * Gets the total count
+   * which represents how many times the animation sequence should be displayed.
+   * A count of 0 ({@link #TOTAL_ITERATION_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <p>
+   *     The total count is calculated as follows by using {@link #getNetscapeLoopCount()}.
+   *     This behavior is the same as most web browsers.
+   *     <table border='1'>
+   *         <tr class='tableSubHeadingColor'><th>{@code getNetscapeLoopCount()}</th>
+   *             <th>The total count</th></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}</td>
+   *             <td>{@link #TOTAL_ITERATION_COUNT_FOREVER}</td></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}</td>
+   *             <td>{@code 1}</td></tr>
+   *         <tr><td>{@code n (n > 0)}</td>
+   *             <td>{@code n + 1}</td></tr>
+   *     </table>
+   * </p>
+   *
+   * @see <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=592735#c5">Discussion about
+   *      the iteration count of animated GIFs (Chromium Issue 592735)</a>
+   *
+   * @return total iteration count calculated from "Netscape" loop count.
+   */
+  int getTotalIterationCount();
+
   /**
    * Returns an estimated byte size for this decoder based on the data provided to {@link
    * #setData(GifHeader, byte[])}, as well as internal buffers.
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index a0a9629f4..d43f7cca7 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -14,6 +14,11 @@
  */
 public class GifHeader {
 
+  /** The "Netscape" loop count which means loop forever. */
+  public static final int NETSCAPE_LOOP_COUNT_FOREVER = 0;
+  /** Indicates that this header has no "Netscape" loop count. */
+  public static final int NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST = -1;
+
   @ColorInt
   int[] gct = null;
   @GifDecoder.GifDecodeStatus
@@ -43,7 +48,7 @@
   int pixelAspect;
   @ColorInt
   int bgColor;
-  int loopCount;
+  int loopCount = NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
 
   public int getHeight() {
     return height;
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
index 6d3c8c500..f0d374ff6 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -198,11 +198,31 @@ public void resetFrameIndex() {
     framePointer = INITIAL_FRAME_POINTER;
   }
 
+  @Deprecated
   @Override
   public int getLoopCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
+    return header.loopCount;
+  }
+
+  @Override
+  public int getNetscapeLoopCount() {
     return header.loopCount;
   }
 
+  @Override
+  public int getTotalIterationCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_FOREVER) {
+      return TOTAL_ITERATION_COUNT_FOREVER;
+    }
+    return header.loopCount + 1;
+  }
+
   @Override
   public int getByteSize() {
     return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 23d368e50..13a581303 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -58,6 +58,36 @@ public void testFrameIndexStartsAtNegativeOne() {
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
 
+  @Test
+  public void testTotalIterationCountIsOneIfNetscapeLoopCountDoesntExist() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(1, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsForeverIfNetscapeLoopCountIsForever() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_FOREVER;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsTwoIfNetscapeLoopCountIsOne() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = 1;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(2, decoder.getTotalIterationCount());
+  }
+
   @Test
   public void testAdvanceIncrementsFrameIndex() {
     GifHeader gifheader = new GifHeader();
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index 3d45f5d39..55dfa41a4 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -65,6 +65,58 @@ public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOEx
     assertEquals(GifDecoder.STATUS_OK, header.status);
   }
 
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIsZero() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_0.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_FOREVER, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_1() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_1.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(1, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x0F()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_255.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(255, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x10()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_256.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(256, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0xFF()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_65535.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(65535, header.loopCount);
+  }
+
+  @Test
+  public void testLoopCountReturnsMinusOneWithoutNetscapeIterationCount()
+          throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_without_netscape_iteration.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST, header.loopCount);
+  }
+
   @Test
   public void testCanReadImageDescriptorWithoutGraphicalExtension() {
     final int lzwMinCodeSize = 2;
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif
new file mode 100644
index 000000000..3dd7c1cb6
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif
new file mode 100644
index 000000000..480dc8c64
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif
new file mode 100644
index 000000000..62a489ea2
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif
new file mode 100644
index 000000000..c0443cd42
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif
new file mode 100644
index 000000000..b976157c3
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif
new file mode 100644
index 000000000..f67b1b6bf
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif differ
