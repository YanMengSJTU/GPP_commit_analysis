diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 8092ebe10..76a4784d5 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -579,16 +579,22 @@ protected RequestOptions getMutableOptions() {
       @NonNull Y target,
       @Nullable RequestListener<TranscodeType> targetListener,
       @NonNull RequestOptions options) {
+    // 判断是否在主线程
     Util.assertMainThread();
+    // 判断target是否为空
     Preconditions.checkNotNull(target);
+    // into前必须调用load
     if (!isModelSet) {
       throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
 
     options = options.autoClone();
+    // 创建请求
     Request request = buildRequest(target, targetListener, options);
-
+    // 获取原先target的请求
     Request previous = target.getRequest();
+    // 如果请求相同而且当前设置可以使用缓存
+    // 则请求回收
     if (request.isEquivalentTo(previous)
         && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
       request.recycle();
@@ -596,6 +602,7 @@ protected RequestOptions getMutableOptions() {
       // triggering RequestListeners and Targets. If the request is failed, beginning again will
       // restart the request, giving it another chance to complete. If the request is already
       // running, we can let it continue running without interruption.
+      // 如果当前请求不在执行中, 则会重新开始请求
       if (!Preconditions.checkNotNull(previous).isRunning()) {
         // Use the previous request rather than the new one to allow for optimizations like skipping
         // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
@@ -607,6 +614,7 @@ protected RequestOptions getMutableOptions() {
 
     requestManager.clear(target);
     target.setRequest(request);
+    // 请求追踪
     requestManager.track(target, request);
 
     return target;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 3bccb0f29..2443745d3 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -144,6 +144,7 @@ public Engine(
    * @param width  The target width in pixels of the desired resource.
    * @param height The target height in pixels of the desired resource.
    * @param cb     The callback that will be called when the load completes.
+   * @param onlyRetrieveFromCache 仅存内存缓存加载
    */
   public <R> LoadStatus load(
       GlideContext glideContext,
@@ -166,10 +167,11 @@ public Engine(
       ResourceCallback cb) {
     Util.assertMainThread();
     long startTime = LogTime.getLogTime();
-
+    // 创建缓存key
     EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
         resourceClass, transcodeClass, options);
-
+    // 从存活资源内读取数据, 内部缓存由value为弱引用对象的map做管理, 做手动的计数管理
+    // 当资源计数为0时, 则回收
     EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
     if (active != null) {
       cb.onResourceReady(active, DataSource.MEMORY_CACHE);
@@ -178,25 +180,32 @@ public Engine(
       }
       return null;
     }
-
+    // 从内存中获取缓存数据
+    // 当内存缓存中有命中, 则将目标资源加到activeResources中
     EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
     if (cached != null) {
+      // 如果命中, 则回调加载
       cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         logWithTimeAndKey("Loaded resource from cache", startTime, key);
       }
       return null;
     }
-
+    // EngineJob : 调度DecodeJob, 添加, 移除资源回调, 并notify回调
     EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
+    // 当前存活的资源和内存缓存都没有的情况下
+    // 1. 先判断是否有资源(resouce什么时候回调true 不明), 如果有, 则回调加载
+    // 2. 如果加载失败, 则加载抛出异常
+    // 3. 否则, 在资源回调中添加
     if (current != null) {
       current.addCallback(cb);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         logWithTimeAndKey("Added to existing load", startTime, key);
       }
+      // 返回当前的LoadStatus
       return new LoadStatus(cb, current);
     }
-
+    // 当资源回调中都没有的情况
     EngineJob<R> engineJob =
         engineJobFactory.build(
             key,
@@ -204,7 +213,8 @@ public Engine(
             useUnlimitedSourceExecutorPool,
             useAnimationPool,
             onlyRetrieveFromCache);
-
+    // 实现了Runnable接口，调度任务的核心类，整个请求的繁重工作都在这里完成：处理来自缓存或者原始的资源，应用转换动画以及transcode。
+    // 负责根据缓存类型获取不同的Generator加载数据，数据加载成功后回调DecodeJob的onDataFetcherReady方法对资源进行处理
     DecodeJob<R> decodeJob =
         decodeJobFactory.build(
             glideContext,
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 2efc94290..ac1083b4d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -206,6 +206,7 @@ void handleResultOnMainThread() {
 
     // Hold on to resource for duration of request so we don't recycle it in the middle of
     // notifying if it synchronously released by one of the callbacks.
+    // 如果同步发布了一个回调, 就不回收资源
     engineResource.acquire();
     listener.onEngineJobComplete(this, key, engineResource);
 
