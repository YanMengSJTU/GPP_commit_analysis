diff --git a/library/lint.xml b/library/lint.xml
index fcbef49a6..2d559c9df 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -2,4 +2,7 @@
 <lint>
     <issue id="MissingApplicationIcon" severity="ignore" />
     <issue id="AllowBackup" severity="ignore" />
+    <issue id="InlinedApi">
+        <ignore path="src/com/bumptech/glide/resize/cache/LruMemoryCache.java" />
+    </issue>
 </lint>
diff --git a/library/src/com/bumptech/glide/Glide.java b/library/src/com/bumptech/glide/Glide.java
index 006b4c910..1e9ba6d28 100644
--- a/library/src/com/bumptech/glide/Glide.java
+++ b/library/src/com/bumptech/glide/Glide.java
@@ -22,7 +22,6 @@
 import com.bumptech.glide.loader.transformation.None;
 import com.bumptech.glide.loader.transformation.TransformationLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
-import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.presenter.target.ImageViewTarget;
 import com.bumptech.glide.presenter.target.Target;
 import com.bumptech.glide.resize.ImageManager;
@@ -54,6 +53,76 @@
 
     private ImageManager imageManager = null;
 
+    /**
+     * A class for monitoring the status of a request while images load.
+     *
+     * @param <T> The type of the model being loaded
+     */
+    public static abstract class RequestListener<T> {
+
+        /**
+         * Called when an exception occurs during a load. Will only be called if we currently want to display an image
+         * for the given model in the given target. It is recommended to create a single instance per activity/fragment
+         * rather than instantiate a new object for each call to {@code Glide.load()} to avoid object churn.
+         *
+         * <p>
+         *     It is safe to reload this or a different model or change what is displayed in the target at this point.
+         *     For example:
+         * <pre>
+         * <code>
+         *     public void onException(Exception e, T model, Target target) {
+         *         target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
+         *         Glide.load(model).into(target);
+         *     }
+         * </code>
+         * </pre>
+         * </p>
+         *
+         * <p>
+         *     Note - if you want to reload this or any other model after an exception, you will need to include all
+         *     relevant builder calls (like centerCrop, placeholder etc).
+         * </p>
+         *
+         * @param e The exception, or null
+         * @param model The model we were trying to load when the exception occurred
+         * @param target The {@link Target} we were trying to load the image into
+         */
+        public abstract void onException(Exception e, T model, Target target);
+
+        /**
+         * Called when a load completes successfully, immediately after
+         * {@link Target#onImageReady(android.graphics.Bitmap)}.
+         *
+         * @param model The specific model that was used to load the image.
+         * @param target The target the model was loaded into.
+         */
+        public abstract void onImageReady(T model, Target target);
+
+        /**
+         * {@inheritDoc}
+         *
+         * <p>
+         *     By default we only check the both objects are not null and that their classes are identical. This assumes
+         *     that two instances of the same anonymous inner class will behave identically.
+         * </p>
+         */
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            return true;
+        }
+
+        /**
+         * {@inheritDoc }
+         */
+        @Override
+        public int hashCode() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
     /**
      * Get the singleton.
      *
@@ -426,6 +495,7 @@ private ModelRequest(ModelLoaderFactory<T> factory) {
         private int errorId = -1;
         private Downsampler downsampler = Downsampler.AT_LEAST;
         private ArrayList<TransformationLoader<T>> transformationLoaders = new ArrayList<TransformationLoader<T>>();
+        private RequestListener<T> requestListener;
 
         private Request(T model) {
             this(model, GLIDE.getFactory(model));
@@ -572,6 +642,20 @@ public String getId() {
             return this;
         }
 
+        /**
+         * Sets a Request listener to monitor the image load. It's best to create a single instance of an exception
+         * handler per type of request (usually activity/fragment) rather than pass one in per request to avoid some
+         * redundant object allocation.
+         *
+         * @param requestListener The request listener to use
+         * @return This request
+         */
+        public Request<T> listener(RequestListener<T> requestListener) {
+            this.requestListener = requestListener;
+
+            return this;
+        }
+
         /**
          * Start loading the image into the view.
          *
@@ -648,7 +732,7 @@ private void finish(Context context, Target target) {
             return result;
         }
 
-        private ImagePresenter<T> buildImagePresenter(Target target) {
+        private ImagePresenter<T> buildImagePresenter(final Target target) {
             TransformationLoader<T> transformationLoader = getFinalTransformationLoader();
 
             ImagePresenter.Builder<T> builder = new ImagePresenter.Builder<T>()
@@ -657,14 +741,22 @@ private void finish(Context context, Target target) {
                     .setImageLoader(new ImageManagerLoader(context, downsampler))
                     .setTransformationLoader(transformationLoader);
 
-            if (animationId != -1) {
-                final Animation animation = AnimationUtils.loadAnimation(context, animationId);
-                builder.setImageReadyCallback(new ImageReadyCallback() {
+            if (animationId != -1 || requestListener != null) {
+                final Animation animation;
+                if (animationId != -1) {
+                    animation = AnimationUtils.loadAnimation(context, animationId);
+                } else {
+                    animation = null;
+                }
+                builder.setImageReadyCallback(new ImagePresenter.ImageReadyCallback<T>() {
                     @Override
-                    public void onImageReady(Target target, boolean fromCache) {
-                        if (!fromCache) {
+                    public void onImageReady(T model, Target target, boolean fromCache) {
+                        if (animation != null && !fromCache) {
                             target.startAnimation(animation);
                         }
+                        if (requestListener != null) {
+                            requestListener.onImageReady(null, target);
+                        }
                     }
                 });
             }
@@ -677,6 +769,17 @@ public void onImageReady(Target target, boolean fromCache) {
                 builder.setErrorResource(errorId);
             }
 
+            if (requestListener != null) {
+                builder.setExceptionHandler(new ImagePresenter.ExceptionHandler<T>() {
+                    @Override
+                    public void onException(Exception e, T model, boolean isCurrent) {
+                        if (isCurrent) {
+                            requestListener.onException(e, model, target);
+                        }
+                    }
+                });
+            }
+
             return builder.build();
         }
 
@@ -739,6 +842,7 @@ public void with(Context context) {
 
         private final String downsamplerId;
         private final String transformationId;
+        private final RequestListener requestListener;
 
         public Metadata(Request request) {
             modelClass = request.model.getClass();
@@ -748,6 +852,7 @@ public Metadata(Request request) {
             animationId = request.animationId;
             placeholderId = request.placeholderId;
             errorId = request.errorId;
+            requestListener = request.requestListener;
         }
 
         //we don't want to change behavior in sets/maps, just be able to compare properties
@@ -760,6 +865,8 @@ public boolean isIdenticalTo(Metadata metadata) {
             if (!modelClass.equals(metadata.modelClass)) return false;
             if (!modelLoaderClass.equals(metadata.modelLoaderClass)) return false;
             if (!transformationId.equals(metadata.transformationId)) return false;
+            if (requestListener == null ? metadata.requestListener != null :
+                    !requestListener.equals(metadata.requestListener)) return false;
 
             return true;
         }
diff --git a/library/src/com/bumptech/glide/loader/transformation/MultiTransformation.java b/library/src/com/bumptech/glide/loader/transformation/MultiTransformation.java
index ddaef5dc8..b9be9440a 100644
--- a/library/src/com/bumptech/glide/loader/transformation/MultiTransformation.java
+++ b/library/src/com/bumptech/glide/loader/transformation/MultiTransformation.java
@@ -24,8 +24,8 @@ public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHei
         Bitmap transformed;
         for (Transformation transformation : transformations) {
             transformed = transformation.transform(bitmap, pool, outWidth, outHeight);
-            if (current != null && current != transformed) {
-                pool.put(current);
+            if (current != null && current != transformed && !pool.put(current)) {
+                current.recycle();
             }
 
             current = transformed;
diff --git a/library/src/com/bumptech/glide/presenter/ImagePresenter.java b/library/src/com/bumptech/glide/presenter/ImagePresenter.java
index 79f916de2..29494f4f2 100644
--- a/library/src/com/bumptech/glide/presenter/ImagePresenter.java
+++ b/library/src/com/bumptech/glide/presenter/ImagePresenter.java
@@ -49,7 +49,7 @@
     public static class Builder<T> {
         private int placeholderResourceId;
         private Drawable placeholderDrawable;
-        private ImageReadyCallback imageReadyCallback;
+        private ImageReadyCallback<T> imageReadyCallback;
         private ImagePresenterCoordinator coordinator;
         private ImageLoader imageLoader;
         private Context context;
@@ -224,7 +224,7 @@ public void onException(Exception e, T model, boolean isCurrent) {
          * @param cb The callback to call
          * @return This Builder object
          */
-        public Builder<T> setImageReadyCallback(ImageReadyCallback cb) {
+        public Builder<T> setImageReadyCallback(ImageReadyCallback<T> cb) {
             this.imageReadyCallback = cb;
             return this;
         }
@@ -281,7 +281,7 @@ public void onException(Exception e, T model, boolean isCurrent) {
     private final TransformationLoader<T> transformationLoader;
 
     private final Drawable placeholderDrawable;
-    private final ImageReadyCallback imageReadyCallback;
+    private final ImageReadyCallback<T> imageReadyCallback;
     private final ImagePresenterCoordinator coordinator;
     private final ExceptionHandler<T> exceptionHandler;
 
@@ -332,6 +332,21 @@ public void onException(Exception e, T model, boolean isCurrent) {
         public void onException(Exception e, T model, boolean isCurrent);
     }
 
+    /**
+     * A callback interface used to perform some action when an {@link ImagePresenter} sets a new bitmap in an
+     * {@link android.widget.ImageView}
+     */
+    public interface ImageReadyCallback<T> {
+
+        /**
+         * The method called when a bitmap is set
+         *
+         * @param target The target that will display the bitmap
+         * @param fromCache True iff the load completed without a placeholder being shown.
+         */
+        public void onImageReady(T model, Target target, boolean fromCache);
+    }
+
     protected ImagePresenter(Builder<T> builder) {
         this.imageLoader = builder.imageLoader;
         this.transformationLoader = builder.transformationLoader;
@@ -438,9 +453,9 @@ private void fetchImage(final T model, int width, int height, final int loadCoun
             public boolean onImageReady(Bitmap image) {
                 if (loadCount != currentCount || !canSetImage() || image == null) return false;
 
-                if (imageReadyCallback != null)
-                    imageReadyCallback.onImageReady(target, loadedFromCache);
                 target.onImageReady(image);
+                if (imageReadyCallback != null)
+                    imageReadyCallback.onImageReady(model, target, loadedFromCache);
                 isImageSet = true;
                 return true;
             }
@@ -448,13 +463,13 @@ public boolean onImageReady(Bitmap image) {
             @Override
             public void onException(Exception e) {
                 final boolean relevant = loadCount == currentCount;
-                if (exceptionHandler != null) {
-                    exceptionHandler.onException(e, model, relevant);
-                }
                 if (relevant && canSetPlaceholder() && errorDrawable != null) {
                     isErrorSet = true;
                     target.setPlaceholder(errorDrawable);
                 }
+                if (exceptionHandler != null) {
+                    exceptionHandler.onException(e, model, relevant);
+                }
             }
         });
     }
diff --git a/library/src/com/bumptech/glide/presenter/ImageReadyCallback.java b/library/src/com/bumptech/glide/presenter/ImageReadyCallback.java
deleted file mode 100644
index 8a32acc27..000000000
--- a/library/src/com/bumptech/glide/presenter/ImageReadyCallback.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
- */
-
-package com.bumptech.glide.presenter;
-
-import com.bumptech.glide.presenter.target.Target;
-
-/**
- * A callback interface used to perform some action when an {@link ImagePresenter} sets a new bitmap in an
- * {@link android.widget.ImageView}
- */
-public interface ImageReadyCallback {
-
-    /**
-     * The method called when a bitmap is set
-     *
-     * @param target The target that will display the bitmap
-     * @param fromCache True iff the load completed without a placeholder being shown.
-     */
-    public void onImageReady(Target target, boolean fromCache);
-}
diff --git a/library/src/com/bumptech/glide/resize/ImageManager.java b/library/src/com/bumptech/glide/resize/ImageManager.java
index 2b124872c..a7f2391df 100644
--- a/library/src/com/bumptech/glide/resize/ImageManager.java
+++ b/library/src/com/bumptech/glide/resize/ImageManager.java
@@ -30,7 +30,6 @@
 import com.bumptech.glide.resize.load.ImageResizer;
 import com.bumptech.glide.resize.load.Transformation;
 import com.bumptech.glide.util.Log;
-import com.bumptech.glide.util.Util;
 
 import java.io.File;
 import java.io.IOException;
@@ -60,6 +59,7 @@
 
     private final BitmapReferenceCounter bitmapReferenceCounter;
     private final int bitmapCompressQuality;
+    private final BitmapPool bitmapPool;
     private boolean shutdown = false;
 
     private final Handler mainHandler = new Handler();
@@ -68,6 +68,7 @@
     private final MemoryCache memoryCache;
     private final ImageResizer resizer;
     private final DiskCache diskCache;
+    private final SafeKeyGenerator safeKeyGenerator = new SafeKeyGenerator();
 
     //special downsampler that doesn't check exif, and assumes inWidth and inHeight == outWidth and outHeight so it
     //doesn't need to read the image header for size information
@@ -363,6 +364,7 @@ private ImageManager(Builder builder) {
         memoryCache = builder.memoryCache;
         diskCache = builder.diskCache;
         bitmapReferenceCounter = builder.bitmapReferenceCounter;
+        bitmapPool = builder.bitmapPool;
         resizer = new ImageResizer(builder.bitmapPool, builder.decodeBitmapOptions);
 
         memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
@@ -373,6 +375,22 @@ public void onImageRemoved(Bitmap removed) {
         });
     }
 
+    /**
+     * Get the {@link BitmapPool} this ImageManager is using. If Bitmap recycling is not supported, an
+     * {@link BitmapPoolAdapter} will be returned. For the pool to be useful you must return a bitmap to the pool for
+     * every bitmap you obtain from the pool.
+     *
+     * <p>
+     *     Note the BitmapPool api is likely to change in the near future to support some new features released in
+     *     KitKat.
+     * </p>
+     *
+     * @return The bitmap pool.
+     */
+    public BitmapPool getBitmapPool() {
+        return bitmapPool;
+    }
+
     /**
      * Load an image
      *
@@ -389,7 +407,7 @@ public void onImageRemoved(Bitmap removed) {
     public ImageManagerJob getImage(String id, StreamLoader streamLoader, Transformation transformation, Downsampler downsampler, int width, int height, LoadedCallback cb) {
         if (shutdown) return null;
 
-        final String key = getKey(id, transformation.getId(), downsampler, width, height);
+        final String key = safeKeyGenerator.getSafeKey(id, transformation, downsampler, width, height);
 
         ImageManagerJob job = null;
         if (!returnFromCache(key, cb)) {
@@ -630,9 +648,4 @@ private void putInMemoryCache(String key, final Bitmap bitmap) {
             memoryCache.put(key, bitmap);
         }
     }
-
-    private static String getKey(String id, String transformationId, Downsampler downsampler, int width, int height) {
-        return String.valueOf(Util.hash(id.hashCode(), downsampler.getId().hashCode(),
-                transformationId.hashCode(), width, height));
-    }
 }
diff --git a/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java
new file mode 100644
index 000000000..9f5f14d94
--- /dev/null
+++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java
@@ -0,0 +1,130 @@
+package com.bumptech.glide.resize;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import com.bumptech.glide.resize.load.Downsampler;
+import com.bumptech.glide.resize.load.Transformation;
+import com.bumptech.glide.util.Util;
+
+import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayDeque;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Queue;
+
+public class SafeKeyGenerator {
+    private final Map<LoadId, String> loadIdToSafeHash = new HashMap<LoadId, String>();
+    private final ByteBuffer byteBuffer = ByteBuffer.allocate(8);
+    private final LoadIdPool loadIdPool = new LoadIdPool();
+    private MessageDigest messageDigest;
+
+    public SafeKeyGenerator() {
+        try {
+            messageDigest = MessageDigest.getInstance("SHA-256");
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public String getSafeKey(String id, Transformation transformation, Downsampler downsampler, int width, int height) {
+        LoadId loadId = loadIdPool.get(id, transformation.getId(), downsampler.getId(), width, height);
+        String safeKey = loadIdToSafeHash.get(loadId);
+        if (safeKey == null) {
+            try {
+                safeKey = loadId.generateSafeKey();
+            } catch (UnsupportedEncodingException e) {
+                e.printStackTrace();
+            }
+            loadIdToSafeHash.put(loadId, safeKey);
+        } else {
+            loadIdPool.offer(loadId);
+        }
+        return safeKey;
+    }
+
+    private class LoadIdPool {
+        private static final int MAX_SIZE = 20;
+        private Queue<LoadId> loadIdQueue;
+
+        @TargetApi(9)
+        public LoadIdPool() {
+            if (Build.VERSION.SDK_INT >= 9) {
+                loadIdQueue = new ArrayDeque<LoadId>(MAX_SIZE);
+            } else {
+                loadIdQueue = new LinkedList<LoadId>();
+            }
+        }
+
+        public LoadId get(String id, String transformationId, String downsamplerId, int width, int height) {
+            LoadId loadId = loadIdQueue.poll();
+            if (loadId == null) {
+                loadId = new LoadId();
+            }
+            loadId.init(id, transformationId, downsamplerId, width, height);
+            return loadId;
+        }
+
+        public void offer(LoadId loadId) {
+            if (loadIdQueue.size() < MAX_SIZE) {
+                loadIdQueue.offer(loadId);
+            }
+        }
+    }
+
+    private class LoadId {
+        private String id;
+        private String transformationId;
+        private String downsamplerId;
+        private int width;
+        private int height;
+
+        public void init(String id, String transformationId, String downsamplerId, int width, int height) {
+            this.id = id;
+            this.transformationId = transformationId;
+            this.downsamplerId = downsamplerId;
+            this.width = width;
+            this.height = height;
+        }
+
+        public String generateSafeKey() throws UnsupportedEncodingException {
+            messageDigest.update(id.getBytes("UTF-8"));
+            messageDigest.update(transformationId.getBytes("UTF-8"));
+            messageDigest.update(downsamplerId.getBytes("UTF-8"));
+            byteBuffer.position(0);
+            byteBuffer.putInt(width);
+            byteBuffer.putInt(height);
+            messageDigest.update(byteBuffer.array());
+            return Util.sha256BytesToHex(messageDigest.digest());
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            LoadId loadId = (LoadId) o;
+
+            if (height != loadId.height) return false;
+            if (width != loadId.width) return false;
+            if (!downsamplerId.equals(loadId.downsamplerId)) return false;
+            if (!id.equals(loadId.id)) return false;
+            if (!transformationId.equals(loadId.transformationId)) return false;
+
+            return true;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = id.hashCode();
+            result = 31 * result + transformationId.hashCode();
+            result = 31 * result + downsamplerId.hashCode();
+            result = 31 * result + width;
+            result = 31 * result + height;
+            return result;
+        }
+    }
+}
diff --git a/library/src/com/bumptech/glide/resize/bitmap_recycle/LruBitmapPool.java b/library/src/com/bumptech/glide/resize/bitmap_recycle/LruBitmapPool.java
index 88718810a..77b1d9fb5 100644
--- a/library/src/com/bumptech/glide/resize/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/com/bumptech/glide/resize/bitmap_recycle/LruBitmapPool.java
@@ -38,7 +38,9 @@ public synchronized boolean put(Bitmap bitmap) {
 
     private void evict() {
         while (currentSize > maxSize) {
-            currentSize -= getSize(pool.removeLast());
+            final Bitmap removed = pool.removeLast();
+            currentSize -= getSize(removed);
+            removed.recycle();
         }
     }
 
@@ -55,7 +57,7 @@ public synchronized Bitmap get(int width, int height, Bitmap.Config config) {
     }
 
     private static int getSize(Bitmap bitmap) {
-        return bitmap.getHeight() * bitmap.getWidth();
+        return bitmap.getHeight() * bitmap.getRowBytes();
     }
 
     /**
diff --git a/library/src/com/bumptech/glide/resize/bitmap_recycle/SerialBitmapReferenceCounter.java b/library/src/com/bumptech/glide/resize/bitmap_recycle/SerialBitmapReferenceCounter.java
index ff389d439..c40a8ddcb 100644
--- a/library/src/com/bumptech/glide/resize/bitmap_recycle/SerialBitmapReferenceCounter.java
+++ b/library/src/com/bumptech/glide/resize/bitmap_recycle/SerialBitmapReferenceCounter.java
@@ -69,7 +69,9 @@ public void releaseBitmap(Bitmap bitmap) {
     }
 
     private void recycle(InnerTracker tracker, Bitmap bitmap) {
-        target.put(bitmap);
+        if (!target.put(bitmap)) {
+            bitmap.recycle();
+        }
         counter.remove(bitmap);
         pool.release(tracker);
     }
diff --git a/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java b/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java
index f28f6c451..9673934b1 100644
--- a/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java
+++ b/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java
@@ -18,12 +18,14 @@
  */
 public class DiskLruCacheWrapper implements DiskCache {
 
+    private static final int APP_VERSION = 1;
+    private static final int VALUE_COUNT = 1;
     private static DiskLruCache CACHE = null;
     private static DiskLruCacheWrapper WRAPPER = null;
 
     private synchronized static DiskLruCache getDiskLruCache(File directory, int maxSize) throws IOException {
         if (CACHE == null) {
-            CACHE = DiskLruCache.open(directory, 0, 1, maxSize);
+            CACHE = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
         }
         return CACHE;
     }
diff --git a/library/src/com/bumptech/glide/resize/cache/LruMemoryCache.java b/library/src/com/bumptech/glide/resize/cache/LruMemoryCache.java
index 598090448..5bb048eb5 100644
--- a/library/src/com/bumptech/glide/resize/cache/LruMemoryCache.java
+++ b/library/src/com/bumptech/glide/resize/cache/LruMemoryCache.java
@@ -4,9 +4,13 @@
 
 package com.bumptech.glide.resize.cache;
 
-import android.graphics.Bitmap;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
 
+import android.graphics.Bitmap;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
+import java.util.Map;
 
 /**
  */
@@ -47,9 +51,33 @@ public void setImageRemovedListener(ImageRemovedListener listener) {
         this.imageRemovedListener = listener;
     }
 
-    private void evict() {
-        LinkedHashMap.Entry<String, Bitmap> last;
-        while (currentSize > maxSize) {
+    @Override
+    public void clearMemory() {
+        final Iterator<Map.Entry<String,Bitmap>> iterator = cache.entrySet().iterator();
+        while (iterator.hasNext()) {
+            final Bitmap bitmap = iterator.next().getValue();
+            bitmap.recycle();
+            iterator.remove();
+        }
+        currentSize = 0;
+    }
+
+    @Override
+    public void trimMemory(int level) {
+        if (level >= TRIM_MEMORY_MODERATE) {
+            // Nearing middle of list of cached background apps
+            // Evict our entire bitmap cache
+            clearMemory();
+        } else if (level >= TRIM_MEMORY_BACKGROUND) {
+            // Entering list of cached background apps
+            // Evict oldest half of our bitmap cache
+            trimToSize(currentSize / 2);
+        }
+    }
+
+    private void trimToSize(int size) {
+        Map.Entry<String, Bitmap> last;
+        while (currentSize > size) {
             last = cache.entrySet().iterator().next();
             final Bitmap toRemove = last.getValue();
             currentSize -= getSize(toRemove);
@@ -60,4 +88,8 @@ private void evict() {
             }
         }
     }
+
+    private void evict() {
+        trimToSize(maxSize);
+    }
 }
diff --git a/library/src/com/bumptech/glide/resize/cache/MemoryCache.java b/library/src/com/bumptech/glide/resize/cache/MemoryCache.java
index 403cb6c52..09aaf519f 100644
--- a/library/src/com/bumptech/glide/resize/cache/MemoryCache.java
+++ b/library/src/com/bumptech/glide/resize/cache/MemoryCache.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.resize.cache;
 
+import android.content.ComponentCallbacks2;
 import android.graphics.Bitmap;
 
 /**
@@ -40,4 +41,15 @@
      * @param listener The listener
      */
     public void setImageRemovedListener(ImageRemovedListener listener);
+
+    /**
+     * Evict all items from the memory cache.
+     */
+    public void clearMemory();
+
+    /**
+     * Trim the memory cache to the appropriate level. Typically called on the callback onTrimMemory.
+     * @param level This integer represents a trim level as specified in {@link ComponentCallbacks2}
+     */
+    public void trimMemory(int level);
 }
diff --git a/library/src/com/bumptech/glide/resize/cache/MemoryCacheAdapter.java b/library/src/com/bumptech/glide/resize/cache/MemoryCacheAdapter.java
index 7ca832da2..43d235682 100644
--- a/library/src/com/bumptech/glide/resize/cache/MemoryCacheAdapter.java
+++ b/library/src/com/bumptech/glide/resize/cache/MemoryCacheAdapter.java
@@ -26,4 +26,10 @@ public Bitmap put(String key, Bitmap bitmap) {
     public void setImageRemovedListener(ImageRemovedListener listener) {
         this.listener = listener;
     }
+
+    @Override
+    public void clearMemory() {}
+
+    @Override
+    public void trimMemory(int level) {}
 }
diff --git a/library/src/com/bumptech/glide/resize/load/Downsampler.java b/library/src/com/bumptech/glide/resize/load/Downsampler.java
index 4ac5f228d..0d5c5f43b 100644
--- a/library/src/com/bumptech/glide/resize/load/Downsampler.java
+++ b/library/src/com/bumptech/glide/resize/load/Downsampler.java
@@ -1,5 +1,10 @@
 package com.bumptech.glide.resize.load;
 
+import static com.bumptech.glide.resize.load.ImageHeaderParser.ImageType;
+import static com.bumptech.glide.resize.load.ImageHeaderParser.ImageType.PNG_A;
+import static com.bumptech.glide.resize.load.ImageHeaderParser.ImageType.JPEG;
+import static com.bumptech.glide.resize.load.ImageHeaderParser.ImageType.PNG;
+
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
@@ -7,13 +12,16 @@
 import com.bumptech.glide.resize.RecyclableBufferedInputStream;
 import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Log;
-
 import java.io.IOException;
+import java.util.EnumSet;
+import java.util.Set;
 
 /**
  * A base class with methods for loading and decoding images from InputStreams.
  */
 public abstract class Downsampler {
+
+    private static final Set<ImageType> TYPES_THAT_USE_POOL = EnumSet.of(JPEG, PNG_A, PNG);
     private final String id = getClass().toString();
 
     /**
@@ -98,8 +106,8 @@ public Bitmap downsample(RecyclableBufferedInputStream bis, BitmapFactory.Option
         final Bitmap downsampled = downsampleWithSize(bis, options, pool, inWidth, inHeight, sampleSize);
         final Bitmap rotated = ImageResizer.rotateImageExif(downsampled, pool, orientation);
 
-        if (downsampled != rotated) {
-            pool.put(downsampled);
+        if (downsampled != rotated && !pool.put(downsampled)) {
+            downsampled.recycle();
         }
 
         return rotated;
@@ -109,11 +117,32 @@ protected Bitmap downsampleWithSize(RecyclableBufferedInputStream bis, BitmapFac
         if (sampleSize > 1) {
             options.inSampleSize = sampleSize;
         } else {
-            setInBitmap(options, pool.get(inWidth, inHeight, getConfig(bis)));
+            // cannot reuse bitmaps when decoding images that are not PNG or JPG.
+            // look at : https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
+            if (shouldUsePool(bis)) {
+                setInBitmap(options, pool.get(inWidth, inHeight, getConfig(bis)));
+            }
         }
         return decodeStream(bis, options);
     }
 
+    private boolean shouldUsePool(RecyclableBufferedInputStream bis) {
+        bis.mark(1024);
+        try {
+            final ImageType type = new ImageHeaderParser(bis).getType();
+            return TYPES_THAT_USE_POOL.contains(type);
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                bis.reset();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        return false;
+    }
+
     private Bitmap.Config getConfig(RecyclableBufferedInputStream bis) {
         Bitmap.Config result = Bitmap.Config.RGB_565;
         bis.mark(1024); //we probably only need 25, but this is safer (particularly since the buffer size is > 1024)
@@ -180,9 +209,6 @@ private Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Opt
          }
 
         final Bitmap result = BitmapFactory.decodeStream(bis, null, options);
-        if (result == null && !options.inJustDecodeBounds) {
-            throw new IllegalArgumentException("IP: null result, sampleSize=" + options.inSampleSize);
-        }
 
         try {
             if (options.inJustDecodeBounds) {
diff --git a/library/src/com/bumptech/glide/resize/load/ImageHeaderParser.java b/library/src/com/bumptech/glide/resize/load/ImageHeaderParser.java
index 77b52a660..c78359bc9 100644
--- a/library/src/com/bumptech/glide/resize/load/ImageHeaderParser.java
+++ b/library/src/com/bumptech/glide/resize/load/ImageHeaderParser.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.resize.load;
 
+import static com.bumptech.glide.resize.load.ImageHeaderParser.ImageType.*;
+
 import com.bumptech.glide.util.Log;
 
 import java.io.IOException;
@@ -11,6 +13,29 @@
  * A class for parsing the exif orientation from an InputStream for an image. Handles jpegs and tiffs.
  */
 public class ImageHeaderParser {
+
+    public static enum ImageType {
+        /** GIF type */
+        GIF(true),
+        /** JPG type */
+        JPEG(false),
+        /** PNG type with alpha */
+        PNG_A(true),
+        /** PNG type without alpha */
+        PNG(false),
+        /** Unrecognized type */
+        UNKNOWN(false);
+        private final boolean hasAlpha;
+
+        ImageType(boolean hasAlpha) {
+            this.hasAlpha = hasAlpha;
+        }
+
+        public boolean hasAlpha() {
+            return hasAlpha;
+        }
+    }
+
     private static final int GIF_HEADER = 0x474946;
     private static final int PNG_HEADER = 0x89504E47;
     private static final int EXIF_MAGIC_NUMBER = 0xFFD8;
@@ -38,10 +63,14 @@ public ImageHeaderParser(InputStream is) {
     // 0xD0A3C68 -> <htm
     // 0xCAFEBABE -> <!DOCTYPE...
     public boolean hasAlpha() throws IOException {
+        return getType().hasAlpha();
+    }
+
+    public ImageType getType() throws IOException {
         int firstByte = streamReader.getUInt8();
 
         if (firstByte == EXIF_MAGIC_NUMBER >> 8) { //JPEG
-            return false;
+            return JPEG;
         }
 
         final int firstTwoBytes = firstByte << 8 & 0xFF00 | streamReader.getUInt8() & 0xFF;
@@ -51,14 +80,14 @@ public boolean hasAlpha() throws IOException {
             streamReader.skip(25 - 4);
             int alpha = streamReader.getByte();
             // A RGB indexed PNG can also have transparency. Better safe than sorry!
-            return alpha >= 3;
+            return alpha >= 3 ? PNG_A : PNG;
         }
 
         if (firstFourBytes >> 8 == GIF_HEADER) { //GIF from first 3 bytes
-            return true;
+            return GIF;
         }
 
-        return false;
+        return UNKNOWN;
     }
 
     /**
diff --git a/library/src/com/bumptech/glide/resize/load/ImageResizer.java b/library/src/com/bumptech/glide/resize/load/ImageResizer.java
index b61892a02..af6b53d2d 100644
--- a/library/src/com/bumptech/glide/resize/load/ImageResizer.java
+++ b/library/src/com/bumptech/glide/resize/load/ImageResizer.java
@@ -113,8 +113,8 @@ public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler down
         final Bitmap initial = downsampler.downsample(bis, options, bitmapPool, outWidth, outHeight);
         final Bitmap result = transformation.transform(initial, bitmapPool, outWidth, outHeight);
 
-        if (initial != result) {
-            bitmapPool.put(initial);
+        if (initial != result && !bitmapPool.put(initial)) {
+            initial.recycle();
         }
 
         releaseTempBytes(tempBytesForBis);
diff --git a/library/src/com/bumptech/glide/util/Util.java b/library/src/com/bumptech/glide/util/Util.java
index 44d64d5f0..999707e51 100644
--- a/library/src/com/bumptech/glide/util/Util.java
+++ b/library/src/com/bumptech/glide/util/Util.java
@@ -1,13 +1,22 @@
 package com.bumptech.glide.util;
 
 public class Util {
-    private static final int PRIME = 31;
+    private static final char[] hexArray = "0123456789abcdef".toCharArray();
+    private static final char[] sha256Chars = new char[64]; //32 bytes from sha-256 -> 64 hex chars
 
-    public static int hash(int... hashes) {
-        int result = 1;
-        for (int hash : hashes) {
-            result *= PRIME * hash;
+    public static String sha256BytesToHex(byte[] bytes) {
+        return bytesToHex(bytes, sha256Chars);
+    }
+
+    // Taken from:
+    // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java/9655275#9655275
+    private static String bytesToHex(byte[] bytes, char[] hexChars) {
+        int v;
+        for ( int j = 0; j < bytes.length; j++ ) {
+            v = bytes[j] & 0xFF;
+            hexChars[j * 2] = hexArray[v >>> 4];
+            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
         }
-        return result;
+        return new String(hexChars);
     }
 }
diff --git a/library/tests/src/com/bumptech/glide/GlideTest.java b/library/tests/src/com/bumptech/glide/GlideTest.java
index 744207abd..507392237 100644
--- a/library/tests/src/com/bumptech/glide/GlideTest.java
+++ b/library/tests/src/com/bumptech/glide/GlideTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide;
 
+import android.graphics.Bitmap;
 import android.net.Uri;
 import android.test.ActivityTestCase;
 import android.view.ViewGroup;
@@ -8,6 +9,8 @@
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.target.ImageViewTarget;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.presenter.target.Target;
 import com.bumptech.glide.tests.R;
 
 import java.io.File;
@@ -220,6 +223,42 @@ public void testClearingTagReplacesPresenter() {
         Glide.load("b").into(imageView);
     }
 
+    public void testObtainAndOfferToBitmapPool() {
+        Bitmap small = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+        Bitmap large = Bitmap.createBitmap(512, 512, Bitmap.Config.RGB_565);
+        BitmapPool bitmapPool = Glide.get().getImageManager(getInstrumentation().getContext()).getBitmapPool();
+        bitmapPool.put(small);
+        bitmapPool.put(large);
+
+        assertEquals(small, bitmapPool.get(small.getWidth(), small.getHeight(), small.getConfig()));
+        assertEquals(large, bitmapPool.get(large.getWidth(), large.getHeight(), large.getConfig()));
+    }
+
+    public void testDifferentRequestListenersReplacesPresenter() {
+        assertDifferentPresenters(
+                Glide.load("a").listener(new Glide.RequestListener<String>() {
+
+                    @Override
+                    public void onException(Exception e, String model, Target target) {
+
+                    }
+
+                    @Override
+                    public void onImageReady(String model, Target target) {
+                    }
+                }),
+                Glide.load("a").listener(new Glide.RequestListener<String>() {
+                    @Override
+                    public void onException(Exception e, String model, Target target) {
+                    }
+
+                    @Override
+                    public void onImageReady(String model, Target target) {
+                    }
+                })
+        );
+    }
+
     private void assertDifferentPresenters(Glide.Request a, Glide.Request b) {
         a.into(imageView);
         ImagePresenter first = getImagePresenterFromView();
@@ -233,5 +272,4 @@ private void assertDifferentPresenters(Glide.Request a, Glide.Request b) {
         assertSame(first, second);
         assertNotSame(first, third);
     }
-
 }
diff --git a/library/tests/src/com/bumptech/glide/ImagePresenterTest.java b/library/tests/src/com/bumptech/glide/ImagePresenterTest.java
index 952f97fca..f394b1f05 100644
--- a/library/tests/src/com/bumptech/glide/ImagePresenterTest.java
+++ b/library/tests/src/com/bumptech/glide/ImagePresenterTest.java
@@ -12,7 +12,6 @@
 import com.bumptech.glide.loader.model.ModelLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.presenter.ImagePresenter;
-import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.presenter.target.Target;
 import com.bumptech.glide.resize.load.Transformation;
 
@@ -330,9 +329,9 @@ public void onCallbackReceived(ImageLoader.ImageReadyCallback cb) {
                         cb.onImageReady(Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_4444));
                     }
                 }))
-                .setImageReadyCallback(new ImageReadyCallback() {
+                .setImageReadyCallback(new ImagePresenter.ImageReadyCallback<Object>() {
                     @Override
-                    public void onImageReady(Target target, boolean fromCache) {
+                    public void onImageReady(Object model, Target target, boolean fromCache) {
                         wasImageSetCallbackCalled.set(true);
                     }
                 })
diff --git a/library/tests/src/com/bumptech/glide/KeyGeneratorTest.java b/library/tests/src/com/bumptech/glide/KeyGeneratorTest.java
new file mode 100644
index 000000000..4c12fffcd
--- /dev/null
+++ b/library/tests/src/com/bumptech/glide/KeyGeneratorTest.java
@@ -0,0 +1,71 @@
+package com.bumptech.glide;
+
+import android.graphics.Bitmap;
+import android.test.AndroidTestCase;
+import com.bumptech.glide.resize.SafeKeyGenerator;
+import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.resize.load.Downsampler;
+import com.bumptech.glide.resize.load.Transformation;
+
+import java.util.UUID;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class KeyGeneratorTest extends AndroidTestCase {
+    private SafeKeyGenerator keyGenerator;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        keyGenerator = new SafeKeyGenerator();
+    }
+
+    public void testKeysAreValidForDiskCache() {
+        String key;
+        final Pattern diskCacheRegex = Pattern.compile("[a-z0-9_-]{64}");
+        for (int i = 0; i < 1000; i++) {
+            key = getRandomKeyFromGenerator();
+            final Matcher matcher = diskCacheRegex.matcher(key);
+            assertTrue(matcher.matches());
+        }
+    }
+
+    private String getRandomKeyFromGenerator() {
+        return keyGenerator.getSafeKey(getRandomId(), new RandomTransformation(), new RandomDownsampler(),
+                getRandomDimen(), getRandomDimen());
+    }
+
+    private static int getRandomDimen() {
+        return (int) Math.round(Math.random() * 1000);
+    }
+
+    private static String getRandomId() {
+        return UUID.randomUUID().toString();
+    }
+
+    private static class RandomDownsampler extends Downsampler {
+
+        @Override
+        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
+            return 0;
+        }
+
+        @Override
+        public String getId() {
+            return getRandomId();
+        }
+    }
+
+    private static class RandomTransformation extends Transformation {
+
+        @Override
+        public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight) {
+            return null;
+        }
+
+        @Override
+        public String getId() {
+            return getRandomId();
+        }
+    }
+}
diff --git a/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index fb713203f..67c0db818 100644
--- a/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -15,7 +15,6 @@
 import com.bumptech.glide.loader.model.Cache;
 import com.bumptech.glide.loader.transformation.CenterCrop;
 import com.bumptech.glide.presenter.ImagePresenter;
-import com.bumptech.glide.presenter.ImageReadyCallback;
 import com.bumptech.glide.presenter.target.Target;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
@@ -118,9 +117,9 @@ public View getView(int position, View view, ViewGroup container) {
                         .setImageView(imageView)
                         .setImageLoader(new ImageManagerLoader(context))
                         .setTransformationLoader(new CenterCrop<Photo>())
-                        .setImageReadyCallback(new ImageReadyCallback() {
+                        .setImageReadyCallback(new ImagePresenter.ImageReadyCallback<Photo>() {
                             @Override
-                            public void onImageReady(Target target, boolean fromCache) {
+                            public void onImageReady(Photo photo, Target target, boolean fromCache) {
                                 if (!fromCache) {
                                     target.startAnimation(fadeIn);
                                 }
