diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
index b9d7e913d..8099489d4 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -231,21 +231,28 @@ public String apply(VariableElement input) {
     List<? extends VariableElement> parameters =
         element.getParameters().subList(1, element.getParameters().size());
 
-    // Add the correct super() call.
-    if (overrideType == OVERRIDE_EXTEND) {
-      String callSuper = "super.$L(";
-      List<Object> args = new ArrayList<>();
-      args.add(element.getSimpleName().toString());
-      if (!parameters.isEmpty()) {
-        for (VariableElement variable : parameters) {
-          callSuper += "$L, ";
-          args.add(variable.getSimpleName().toString());
-        }
-        callSuper = callSuper.substring(0, callSuper.length() - 2);
+    // Generates the String and list of arguments to pass in when calling this method or super.
+    // IE centerCrop(context) creates methodLiterals="%L" and methodArgs=[centerCrop, context].
+    List<Object> methodArgs = new ArrayList<>();
+    methodArgs.add(element.getSimpleName().toString());
+    String methodLiterals = "";
+    if (!parameters.isEmpty()) {
+      for (VariableElement variable : parameters) {
+        methodLiterals += "$L, ";
+        methodArgs.add(variable.getSimpleName().toString());
       }
-      callSuper += ")";
+      methodLiterals = methodLiterals.substring(0, methodLiterals.length() - 2);
+    }
+
+    builder.beginControlFlow("if (isAutoCloneEnabled())")
+        .addStatement(
+            "return clone().$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0]))
+        .endControlFlow();
 
-      builder.addStatement(callSuper, args.toArray(new Object[0]))
+    // Add the correct super() call.
+    if (overrideType == OVERRIDE_EXTEND) {
+      String callSuper = "super.$L(" + methodLiterals + ")";
+      builder.addStatement(callSuper, methodArgs.toArray(new Object[0]))
           .addJavadoc(processorUtil.generateSeeMethodJavadoc(
               requestOptionsName, methodName, parameters))
           .addAnnotation(Override.class);
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index e35699f36..192db6e43 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -359,11 +359,15 @@ protected RequestOptions getMutableOptions() {
     Request request = buildRequest(target);
 
     Request previous = target.getRequest();
-    if (request.isEquivalentTo(previous)) {
+    // When request was failed or cancelled, be sure to use the updated model as it can contains
+    // unexposed data that could help the request to succeed on restart.
+    // See https://github.com/bumptech/glide/issues/2270
+    if (request.isEquivalentTo(previous)
+      && (Preconditions.checkNotNull(previous).isComplete()
+         || Preconditions.checkNotNull(previous).isRunning())) {
       request.recycle();
       // If the request is completed, beginning again will ensure the result is re-delivered,
-      // triggering RequestListeners and Targets. If the request is failed, beginning again will
-      // restart the request, giving it another chance to complete. If the request is already
+      // triggering RequestListeners and Targets. If the request is already
       // running, we can let it continue running without interruption.
       if (!Preconditions.checkNotNull(previous).isRunning()) {
         previous.begin();
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 8d024d495..243b76752 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -559,14 +559,15 @@ private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentExc
           + ", inBitmap: " + getInBitmapString(options), e);
   }
 
-  // Avoid short circuiting SDK checks.
   @SuppressWarnings("PMD.CollapsibleIfStatements")
   @TargetApi(Build.VERSION_CODES.O)
   private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
       int height) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
-        && options.inPreferredConfig == Config.HARDWARE) {
-      return;
+    // Avoid short circuiting, it appears to break on some devices.
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      if (options.inPreferredConfig == Config.HARDWARE) {
+        return;
+      }
     }
     // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
     options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 72c768d23..3c7d65573 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -1288,6 +1288,10 @@ private RequestOptions selfOrThrowIfLocked() {
     return this;
   }
 
+  protected boolean isAutoCloneEnabled() {
+    return isAutoCloneEnabled;
+  }
+
   @NonNull
   public final Map<Class<?>, Transformation<?>> getTransformations() {
     return transformations;
