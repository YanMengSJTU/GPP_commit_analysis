diff --git a/README.md b/README.md
index cd65987e4..c1319c58d 100644
--- a/README.md
+++ b/README.md
@@ -271,7 +271,184 @@ Manifest解析
     }
   }
 ```
-
+GlideExecutor
+```java
+  public final class GlideExecutor implements ExecutorService{
+    private static final String DEFAULT_SOURCE_EXECUTOR_NAME="source";
+    private static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME="disk-cache";
+    private static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS=1;
+    private static final String TAG="GlideExecutor";
+    private staic final String SOURCE_UNLIMITED_EXECUTOR_NAME="source-unlimited";
+    private static final String ANIMATION_EXECUTOR_NAME="animatioin";
+    private static final long KEEP_ALIVE_TIME_MS=TimeUnit.SECONDS.toMillis(10);
+    private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT=4;
+    private static volatile int bestThreadCount;
+    private final ExecutorService delegate;
+    
+    public static GlideExecutor newDiskCacheExecutor(){
+      return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,DEFAULT_DISK_CACHE_EXECUTOR_NAME,UncaughtThrowableStrategy.DEFAULT);
+    }
+    public static GlideExecutor newDiskCacheExecutor(UncaughtThrowableStrategy uncaughtThrowableStrategy){
+      return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,DEFAULT_DISK_CAHCE_EXECUTOR_NAME,uncaughtThrowableStrategy);
+    }
+    public static GlideExecutor newDiskCacheExecutor(int threadCount,String name,UncaughtThrowableStrategy uncaughtThrowableStrategy){
+      return new GlideExecutor(new TheadPoolExecutor(threadCount,threadCount,0,TimeUnit.MILLISECONDS
+        ,new PriorityBlockingQueue<Runnable>(),new DefaultThreadFactory(name,uncaughtThrowableStrategy,true)));
+    }
+    public static GlideExecutor newSourceExecutor(){
+      return newSourceExecutor(calculateBestThreadCount(),DEFAULT_SOURCE_EXECUTOR_NAME,UncaughtThrowableStrategy.DEFAULT);
+    }
+    public static GlideExecutor newSourceExecutor(UncaughtThrowableStrategy uncaughtThrowableStrategy){
+      return newSourceExecutor(calculateBestThreadCount(),DEFAULT_SOURCE_EXECUTOR_NAME,uncaughtThrowableStrategy);
+    }
+    public static GlideExecutor newSourceExecutor(int threadCount,String name,UncaughtThrowableStrategy uncaughtThrowableStrategy){
+      return new GlideExecutor(new ThreadPoolExecutor(threadCount,threadCount,0,TimeUnit.MILLISECONDS
+        ,new PriorityBlockingQueue<Runnable>(),new DefaultThreadFactory(name,uncaughtThrowableStrategy,false)));
+    }
+    public static GlideExecutor newUnlimitedSourceExecutor(){
+      return new GlideExecutor(new ThreadPoolExecutor(0,Integer.MAX_VALUE,KEEP_ALIVE_TIME_MS,TimeUnit.MILLISECONDS
+        ,new SynchronousQueue<Runnable>(),new DefaultThreadFactory(SOURCE_UNLIMITED_EXECUTOR_NAME,UncaughtThrowableStrategy.DEFAULT,false)));
+    }
+    public static GlideExecutor newAnimationExecutor(){
+      int bestThreadCount=calculateBestThreadCount();
+      int maximumPoolSize=bestThreadCount>=4?2:1;
+      return newAnimationExecutor(maximumPoolSize,UncaughtThrowableStrategy.DEFAULT);
+    }
+    public static GlideExecutor newAnimationExecutor(int threadCount,UncaughtThrowableStrategy uncaughtThrowableStrategy){
+      return new GlideExecutor(new ThreadPoolExecutor(0,threadCount,KEEP_ALIVE_TIME_MS,TimeUnit.MILLISECONDS
+        ,new PriorityBlockingQueue<Runnable>(),new DefaultThreadFactory(ANIMATION_EXECUTOR_NAME,uncaughtThrowableStrategy,true)));
+    }
+    GlideExecutor(ExecutorService delegate){
+      this.delegate=delegate;
+    }
+    @Override
+    public void execute(@NonNull Runnable command){
+      delegate.execute(command);
+    }
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task){
+      delegate.submit(task);
+    }
+    @NonNull
+    @Override
+    public <T>List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks) throws InterruptedException{
+      delegate.invokeAll(tasks);
+    }
+    @NonNull
+    @Override
+    public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks,long timeout,@NonNull TimeUnit unit) throws InterruptedException{
+      return delegate.invokeAll(tasks,timeout,unit);
+    }
+    @NonNull
+    @Override
+    public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks) throws InterruptedException,ExecutionException{
+      return delegate.invokeAny(tasks);
+    }
+    @Override
+    public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks,long timeout,@NonNull TimeUnit unit) throws InterruptedException,ExecutionException,TimeoutException{
+    return delegate.invokeAny(tasks,timeout,unit);
+    }
+    @NonNull
+    @Override
+    public <T> Fucture<T> submit(@NonNull Runnable task,T result){
+      return delegate.submit(task,result);
+    }
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task){
+      return delegate.submit(task);
+    }
+    @Override
+    public void shutdown(){
+      delegate.shutdown();
+    }
+    @NonNull
+    @Override
+    public List<Runnable> shutdownNow(){
+      return delegate.shutdownNow();
+    }
+    @Override
+    public boolean isShutdown(){
+      return delegate.isShutdown();
+    }
+    @Override
+    public boolean isTerminated(){
+      return delegate.isTerminated();
+    }
+    @Override
+    public boolean awaitTermination(long timeout,@NonNull TimeUnit unit) throws InterruptedException{
+      return delegate.awaitTermination(timeout,unit);
+    }
+    @Override
+    public String toString(){
+      return delegate.toString();
+    }
+    public static int calculateBestThreadCount(){
+      if(bestThreadCount==0){
+        bestThreadCount=Max.min(MAXIMUM_AUTOMATIC_THREAD_COUNT,RuntimeCompat.availableProcessors());
+      }
+      return bestThreadCount;
+    }
+    public interface UncaughtThrowableStrategy{
+      UncaughtThrowableStartegy IGNORE=new UncaughtThrowableStrategy(){
+        @Override
+        public void handle(Throwable t){
+          
+        }
+      };
+      UncaughtThrowableStrategy LOG=new UncaughtThrowableStrategy(){
+        @Override
+        public void handle(Throwable t){
+          if(t!=null&&Log.isLoggable(TAG,Log.ERROR)){
+            Log.e(TAG,"Request threw uncaught throwble",t);
+          }
+        }
+      };
+      UncaughtThrowableStrategy THROW=new UncaughtThrowableStrategy(){
+        @Override
+        public void handle(Throwable t){
+          if(t!=null){
+            throw new RuntimeException("Request threw uncaught throwable",t);
+          }
+        }
+      };
+      UncaughtThrowableStrategy DEFAULT=LOG;
+      void handle(Throwable t);
+    }
+    private static final class DefaultThreadFactory implements ThreadFactory{
+      private static final int DEFAULT_PRIORITY=android.os.Process.THREAD_PRIORITY_BACKGROUND
+        +android.os.Process.THREAD_PRIORITY_MODE_FAVORABLE;
+      private final String name;
+      @Synthetic final UncaughtThrowableStrategy uncaughtThrowableStrategy;
+      @Synthetic final boolean preventNetWorkOpretions;
+      private int threadNum;
+      DefaultTheadFactory(String name,UncaughtThrowableStrategy uncaughtThrowableStrategy,boolean prevetNetworkOperations){
+        this.name=name;
+        this.uncaughtThrowableStrategy=uncaughtThrowableStrategy;
+        this.preventNetworkOperations=preventNetworkOperations;
+      }
+      @Override
+      public synchronized Thread newThead(@NonNull Runnable runnable){
+        final Thread result=new Thead(runnable,"glide-"+name+"-thread-"+threadNum){
+          @Override
+          public void run(){
+            android.os.Process.setThreadPriority(DEFAULT_PRIORITY);
+            if(preventNetworkOperations){
+              StrictMode.setThreadPolicy(new ThreadPolicy.Builder().detectNetwork().penaltyDeath().build());
+            }
+            try{
+              super.run();
+            }catch(){
+              uncaughtThrowableStrategy.handle(t);
+            }
+          }
+        };
+        threadNum++;
+        return result;
+      }
+    }
+  }
+```
 
 
 
@@ -311,26 +488,3 @@ Manifest解析
 
 
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
