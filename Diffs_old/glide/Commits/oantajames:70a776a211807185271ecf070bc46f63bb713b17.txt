diff --git a/library/AndroidManifest.xml b/library/AndroidManifest.xml
index 09b5990ce..125c1a320 100644
--- a/library/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -3,6 +3,6 @@
           package="com.bumptech.glide"
           android:versionCode="3"
           android:versionName="2.0.1" >
-  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="18" />
+  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />
   <application />
 </manifest>
diff --git a/library/project.properties b/library/project.properties
index 18e583574..402ea5990 100644
--- a/library/project.properties
+++ b/library/project.properties
@@ -11,7 +11,7 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-18
+target=android-19
 
 # https://code.google.com/p/android/issues/detail?id=40487
 renderscript.opt.level=O0
diff --git a/library/src/com/bumptech/glide/Glide.java b/library/src/com/bumptech/glide/Glide.java
index 1e9ba6d28..5e574f891 100644
--- a/library/src/com/bumptech/glide/Glide.java
+++ b/library/src/com/bumptech/glide/Glide.java
@@ -24,6 +24,7 @@
 import com.bumptech.glide.presenter.ImagePresenter;
 import com.bumptech.glide.presenter.target.ImageViewTarget;
 import com.bumptech.glide.presenter.target.Target;
+
 import com.bumptech.glide.resize.ImageManager;
 import com.bumptech.glide.resize.load.Downsampler;
 import com.bumptech.glide.resize.load.Transformation;
@@ -58,7 +59,7 @@
      *
      * @param <T> The type of the model being loaded
      */
-    public static abstract class RequestListener<T> {
+    public interface RequestListener<T> {
 
         /**
          * Called when an exception occurs during a load. Will only be called if we currently want to display an image
@@ -97,30 +98,6 @@
          * @param target The target the model was loaded into.
          */
         public abstract void onImageReady(T model, Target target);
-
-        /**
-         * {@inheritDoc}
-         *
-         * <p>
-         *     By default we only check the both objects are not null and that their classes are identical. This assumes
-         *     that two instances of the same anonymous inner class will behave identically.
-         * </p>
-         */
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
-
-            return true;
-        }
-
-        /**
-         * {@inheritDoc }
-         */
-        @Override
-        public int hashCode() {
-            throw new UnsupportedOperationException();
-        }
     }
 
     /**
@@ -842,7 +819,7 @@ public void with(Context context) {
 
         private final String downsamplerId;
         private final String transformationId;
-        private final RequestListener requestListener;
+        private final Class requestListenerClass;
 
         public Metadata(Request request) {
             modelClass = request.model.getClass();
@@ -852,7 +829,8 @@ public Metadata(Request request) {
             animationId = request.animationId;
             placeholderId = request.placeholderId;
             errorId = request.errorId;
-            requestListener = request.requestListener;
+            requestListenerClass = (request.requestListener != null ?
+                    request.requestListener.getClass() : null);
         }
 
         //we don't want to change behavior in sets/maps, just be able to compare properties
@@ -865,8 +843,8 @@ public boolean isIdenticalTo(Metadata metadata) {
             if (!modelClass.equals(metadata.modelClass)) return false;
             if (!modelLoaderClass.equals(metadata.modelLoaderClass)) return false;
             if (!transformationId.equals(metadata.transformationId)) return false;
-            if (requestListener == null ? metadata.requestListener != null :
-                    !requestListener.equals(metadata.requestListener)) return false;
+            if (requestListenerClass == null ? metadata.requestListenerClass != null :
+                    !requestListenerClass.equals(metadata.requestListenerClass)) return false;
 
             return true;
         }
diff --git a/library/tests/project.properties b/library/tests/project.properties
index b476582d7..ed6ad5380 100644
--- a/library/tests/project.properties
+++ b/library/tests/project.properties
@@ -11,5 +11,5 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-16
+target=android-19
 
diff --git a/library/tests/src/com/bumptech/glide/GlideTest.java b/library/tests/src/com/bumptech/glide/GlideTest.java
index 507392237..244822d95 100644
--- a/library/tests/src/com/bumptech/glide/GlideTest.java
+++ b/library/tests/src/com/bumptech/glide/GlideTest.java
@@ -1,7 +1,10 @@
 package com.bumptech.glide;
 
 import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
 import android.net.Uri;
+import android.os.Handler;
+import android.os.HandlerThread;
 import android.test.ActivityTestCase;
 import android.view.ViewGroup;
 import android.widget.ImageView;
@@ -13,9 +16,14 @@
 import com.bumptech.glide.presenter.target.Target;
 import com.bumptech.glide.tests.R;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Created with IntelliJ IDEA.
@@ -259,6 +267,74 @@ public void onImageReady(String model, Target target) {
         );
     }
 
+//    public void testMemoryLeak() throws InterruptedException {
+//        final int numRequests = 200;
+//        final HandlerThread handlerThread = new HandlerThread("memory_leak");
+//        handlerThread.start();
+//        final Handler handler = new Handler(handlerThread.getLooper());
+//        final AtomicInteger totalRun = new AtomicInteger();
+//        Runnable doLoad = new Runnable() {
+//                @Override
+//                public void run() {
+//                    final ImageView temp = new ImageView(getInstrumentation().getContext());
+//                    temp.setBackgroundDrawable(new BitmapDrawable(
+//                            Bitmap.createBitmap(1000, 1000, Bitmap.Config.ARGB_8888)));
+//                    temp.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
+//                    Glide.using(new ModelLoader<Object>() {
+//                        @Override
+//                        public StreamLoader getStreamLoader(Object model, int width, int height) {
+//                            return new StreamLoader() {
+//                                @Override
+//                                public void loadStream(StreamReadyCallback cb) {
+//                                    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+//                                    ByteArrayOutputStream os = new ByteArrayOutputStream();
+//                                    bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os);
+//                                    cb.onStreamReady(new ByteArrayInputStream(os.toByteArray()));
+//                                }
+//
+//                                @Override
+//                                public void cancel() { }
+//                            };
+//                        }
+//
+//                        @Override
+//                        public String getId(Object model) {
+//                            return model.toString();
+//                        }
+//                    })
+//                            .load(new Object())
+//                            .animate(android.R.anim.fade_in)
+//                            .centerCrop()
+//                            .error(android.R.drawable.ic_delete)
+//                            .placeholder(android.R.drawable.ic_dialog_email)
+//                            .listener(new Glide.RequestListener<Object>() {
+//                                @Override
+//                                public void onException(Exception e, Object model, Target target) {
+//                                    temp.invalidate();
+//                                }
+//
+//                                @Override
+//                                public void onImageReady(Object model, Target target) {
+//                                    temp.jumpDrawablesToCurrentState();
+//                                }
+//                            })
+//                            .into(temp);
+//                    if (totalRun.getAndIncrement() < numRequests) {
+//                        handler.postDelayed(this, 10);
+//                    } else {
+//                        handler.postDelayed(new Runnable() {
+//                            @Override
+//                            public void run() {
+//                                handlerThread.getLooper().quit();
+//                            }
+//                        }, 100);
+//                    }
+//                }
+//        };
+//        handler.post(doLoad);
+//        handlerThread.join();
+//    }
+
     private void assertDifferentPresenters(Glide.Request a, Glide.Request b) {
         a.into(imageView);
         ImagePresenter first = getImagePresenterFromView();
diff --git a/library/tests/src/com/bumptech/glide/LruCacheTest.java b/library/tests/src/com/bumptech/glide/LruCacheTest.java
new file mode 100644
index 000000000..6e846d119
--- /dev/null
+++ b/library/tests/src/com/bumptech/glide/LruCacheTest.java
@@ -0,0 +1,186 @@
+package com.bumptech.glide;
+
+import android.content.ComponentCallbacks2;
+import android.graphics.Bitmap;
+import android.test.AndroidTestCase;
+import com.bumptech.glide.resize.cache.LruMemoryCache;
+import com.bumptech.glide.resize.cache.MemoryCache;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class LruCacheTest extends AndroidTestCase {
+    // 1MB
+    private static final int SIZE = 1024 * 1024;
+    private LruMemoryCache cache;
+    private String key;
+    private Bitmap test;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        cache = new LruMemoryCache(SIZE);
+        key = getKey();
+        test = getBitmap();
+    }
+
+    public void testCanAddABitmap() {
+        cache.put(key, test);
+        assertNotNull(cache.get(key));
+    }
+
+    public void testLeastRecentlyAddKeyEvictedFirstIfGetsAreEqual() {
+        LruMemoryCache smallCache = new LruMemoryCache(2 * getSize(test));
+        smallCache.put(key, test);
+        smallCache.put(getKey(), getBitmap());
+        final AtomicInteger totalRemoved = new AtomicInteger();
+        smallCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
+            @Override
+            public void onImageRemoved(Bitmap removed) {
+                assertEquals(test, removed);
+                totalRemoved.getAndIncrement();
+            }
+        });
+        smallCache.put(getKey(), getBitmap());
+        assertEquals(1, totalRemoved.get());
+    }
+
+    public void testLeastRecentlyUsedKeyEvictedFirst() {
+        LruMemoryCache smallCache = new LruMemoryCache(2 * getSize(test));
+        smallCache.put(key, test);
+        smallCache.put(getKey(), getBitmap());
+        smallCache.get(key);
+        final AtomicInteger totalRemoved = new AtomicInteger();
+        smallCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
+            @Override
+            public void onImageRemoved(Bitmap removed) {
+                assertNotSame(test, removed);
+                totalRemoved.getAndIncrement();
+            }
+        });
+        smallCache.put(getKey(), getBitmap());
+        assertEquals(1, totalRemoved.get());
+    }
+
+    public void testImageRemovedListenerCalledWhenBitmapEvicted() {
+        LruMemoryCache smallCache = new LruMemoryCache(getSize(test));
+        smallCache.put(getKey(), test);
+        final AtomicInteger totalRemoved = new AtomicInteger();
+        smallCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
+            @Override
+            public void onImageRemoved(Bitmap removed) {
+                totalRemoved.getAndIncrement();
+            }
+        });
+        smallCache.put(getKey(), getBitmap());
+        assertEquals(1, totalRemoved.get());
+    }
+
+    public void testBitmapLargerThanPoolIsImmediatelyEvicted() {
+        final Bitmap tooLarge = Bitmap.createBitmap(1000, 1000, Bitmap.Config.ARGB_8888);
+        assertTrue(getSize(tooLarge) > SIZE);
+        final AtomicInteger totalRemoved = new AtomicInteger();
+        cache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
+            @Override
+            public void onImageRemoved(Bitmap removed) {
+                totalRemoved.incrementAndGet();
+                assertEquals(tooLarge, removed);
+            }
+        });
+        cache.put(key, tooLarge);
+        assertFalse(cache.contains(key));
+        assertEquals(1, totalRemoved.get());
+    }
+
+    public void testEmptyCacheDoesNotContainKey() {
+        assertFalse(cache.contains(key));
+    }
+
+    public void testCacheContainsAddedBitmap() {
+        assertFalse(cache.contains(key));
+        cache.put(key, test);
+        assertTrue(cache.contains(key));
+    }
+
+    public void testItIsSizeLimited() {
+        final AtomicInteger totalRemoved = new AtomicInteger();
+        cache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
+            @Override
+            public void onImageRemoved(Bitmap removed) {
+                totalRemoved.incrementAndGet();
+            }
+        });
+        fillCache();
+        assertEquals(0, totalRemoved.get());
+        cache.put(key, test);
+        assertEquals(1, totalRemoved.get());
+    }
+
+    public void testClearMemory() {
+        List<String> keys = fillCache();
+        cache.clearMemory();
+        for (String key : keys) {
+            assertFalse(cache.contains(key));
+        }
+    }
+
+    public void testTrimMemoryCompleteClearsCache() {
+        List<String> keys = fillCache();
+        cache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
+        for (String key : keys) {
+            assertFalse(cache.contains(key));
+        }
+    }
+
+    public void testTrimMemoryModerateClearsCache() {
+        List<String> keys = fillCache();
+        cache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
+        for (String key : keys) {
+            assertFalse(cache.contains(key));
+        }
+    }
+
+    public void testTrimMemoryBackgroundRemovesHalfOfCache() {
+        List<String> keys = fillCache();
+        cache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
+        int totalMisses = 0;
+        for (String key : keys) {
+            if (!cache.contains(key)) {
+                totalMisses++;
+            }
+        }
+
+        assertEquals((int) Math.ceil(keys.size() / (double) 2), totalMisses);
+    }
+
+    private List<String> fillCache() {
+        List<String> keys = new ArrayList<String>();
+        Bitmap toPut = getBitmap();
+        int bitmapSize = getSize(toPut);
+        for (int i = 0; i < SIZE / bitmapSize; i++) {
+            final String key = getKey();
+            cache.put(key, Bitmap.createBitmap(toPut));
+            keys.add(key);
+        }
+
+        for (String key : keys) {
+            assertTrue(cache.contains(key));
+        }
+
+        return keys;
+    }
+
+    private static Bitmap getBitmap() {
+        return Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    }
+
+    private static int getSize(Bitmap bitmap) {
+        return bitmap.getRowBytes() * bitmap.getHeight();
+    }
+
+    private static String getKey() {
+        return UUID.randomUUID().toString();
+    }
+}
