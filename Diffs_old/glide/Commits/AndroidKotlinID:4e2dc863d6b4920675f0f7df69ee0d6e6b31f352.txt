diff --git a/checkstyle.xml b/checkstyle.xml
index 55273de62..ec3f4a74d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -127,7 +127,9 @@
 
         <!-- Checks for blocks. -->
         <!-- See http://checkstyle.sourceforge.net/config_blocks.html -->
-        <module name="AvoidNestedBlocks" />
+        <module name="AvoidNestedBlocks">
+          <property name="allowInSwitchCase" value="true" />
+        </module>
         <module name="EmptyBlock" >
             <property name="option" value="text"/>
         </module>
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 243b76752..f9c8877b5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -10,6 +10,7 @@
 import android.util.Log;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
 import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
@@ -19,6 +20,7 @@
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.SampleSizeRounding;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 import java.io.IOException;
@@ -120,6 +122,9 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
   // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer
   // but will resize up to this amount if necessary.
   private static final int MARK_POSITION = 5 * 1024 * 1024;
+  // Defines the level of precision we get when using inDensity/inTargetDensity to calculate an
+  // arbitrary float scale factor.
+  private static final int DENSITY_PRECISION_MULTIPLIER = 1000000000;
 
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
@@ -216,6 +221,7 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
       DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,
       int requestedHeight, boolean fixBitmapToRequestedDimensions,
       DecodeCallbacks callbacks) throws IOException {
+    long startTime = LogTime.getLogTime();
 
     int[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool);
     int sourceWidth = sourceDimensions[0];
@@ -229,8 +235,20 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
     int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
 
-    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,
-        targetHeight, options);
+    ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
+
+    calculateScaling(
+        imageType,
+        is,
+        callbacks,
+        bitmapPool,
+        downsampleStrategy,
+        degreesToRotate,
+        sourceWidth,
+        sourceHeight,
+        targetWidth,
+        targetHeight,
+        options);
     calculateConfig(
         is,
         decodeFormat,
@@ -242,8 +260,7 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
 
     boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
     // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
-    if ((options.inSampleSize == 1 || isKitKatOrGreater)
-        && shouldUsePool(is)) {
+    if ((options.inSampleSize == 1 || isKitKatOrGreater) && shouldUsePool(imageType)) {
       int expectedWidth;
       int expectedHeight;
       if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {
@@ -278,7 +295,7 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logDecode(sourceWidth, sourceHeight, sourceMimeType, options, downsampled,
-          requestedWidth, requestedHeight);
+          requestedWidth, requestedHeight, startTime);
     }
 
     Bitmap rotated = null;
@@ -297,10 +314,18 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
   }
 
   // Visible for testing.
-  static void calculateScaling(DownsampleStrategy downsampleStrategy,
+  static void calculateScaling(
+      ImageType imageType,
+      InputStream is,
+      DecodeCallbacks decodeCallbacks,
+      BitmapPool bitmapPool,
+      DownsampleStrategy downsampleStrategy,
       int degreesToRotate,
-      int sourceWidth, int sourceHeight, int targetWidth, int targetHeight,
-      BitmapFactory.Options options) {
+      int sourceWidth,
+      int sourceHeight,
+      int targetWidth,
+      int targetHeight,
+      BitmapFactory.Options options) throws IOException {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
       return;
@@ -321,7 +346,9 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy,
 
     if (exactScaleFactor <= 0f) {
       throw new IllegalArgumentException("Cannot scale with factor: " + exactScaleFactor
-          + " from: " + downsampleStrategy);
+          + " from: " + downsampleStrategy
+          + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
+          + ", target: [" + targetWidth + "x" + targetHeight + "]");
     }
     SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding(sourceWidth,
         sourceHeight, targetWidth, targetHeight);
@@ -329,8 +356,8 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy,
       throw new IllegalArgumentException("Cannot round with null rounding");
     }
 
-    int outWidth = (int) (exactScaleFactor * sourceWidth + 0.5f);
-    int outHeight = (int) (exactScaleFactor * sourceHeight + 0.5f);
+    int outWidth = round(exactScaleFactor * sourceWidth);
+    int outHeight = round(exactScaleFactor * sourceHeight);
 
     int widthScaleFactor = sourceWidth / outWidth;
     int heightScaleFactor = sourceHeight / outHeight;
@@ -352,14 +379,53 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy,
       }
     }
 
-    float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;
-
+    // Here we mimic framework logic for determining how inSampleSize division is rounded on various
+    // versions of Android. The logic here has been tested on emulators for Android versions 15-26.
+    // PNG - Always uses floor
+    // JPEG - Always uses ceiling
+    // Webp - Prior to N, always uses floor. At and after N, always uses round.
     options.inSampleSize = powerOfTwoSampleSize;
+    final int powerOfTwoWidth;
+    final int powerOfTwoHeight;
+    // Jpeg rounds with ceiling on all API verisons.
+    if (imageType == ImageType.JPEG) {
+      powerOfTwoWidth = (int) Math.ceil(sourceWidth / (float) powerOfTwoSampleSize);
+      powerOfTwoHeight = (int) Math.ceil(sourceHeight / (float) powerOfTwoSampleSize);
+    } else if (imageType == ImageType.PNG || imageType == ImageType.PNG_A) {
+      powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
+      powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+    } else if (imageType == ImageType.WEBP || imageType == ImageType.WEBP_A) {
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+        powerOfTwoWidth = Math.round(sourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = Math.round(sourceHeight / (float) powerOfTwoSampleSize);
+      } else {
+        powerOfTwoWidth = (int) Math.floor(sourceWidth / (float) powerOfTwoSampleSize);
+        powerOfTwoHeight = (int) Math.floor(sourceHeight / (float) powerOfTwoSampleSize);
+      }
+    } else if (
+        sourceWidth % powerOfTwoSampleSize != 0 || sourceHeight % powerOfTwoSampleSize != 0) {
+      // If we're not confident the image is in one of our types, fall back to checking the
+      // dimensions again. inJustDecodeBounds decodes do obey inSampleSize.
+      int[] dimensions = getDimensions(is, options, decodeCallbacks, bitmapPool);
+      // Power of two downsampling in BitmapFactory uses a variety of random factors to determine
+      // rounding that we can't reliably replicate for all image formats. Use ceiling here to make
+      // sure that we at least provide a Bitmap that's large enough to fit the content we're going
+      // to load.
+      powerOfTwoWidth = dimensions[0];
+      powerOfTwoHeight = dimensions[1];
+    } else {
+      powerOfTwoWidth = sourceWidth / powerOfTwoSampleSize;
+      powerOfTwoHeight = sourceHeight / powerOfTwoSampleSize;
+    }
+
+    double adjustedScaleFactor = downsampleStrategy.getScaleFactor(
+        powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);
+
     // Density scaling is only supported if inBitmap is null prior to KitKat. Avoid setting
     // densities here so we calculate the final Bitmap size correctly.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-      options.inTargetDensity = (int) (1000 * adjustedScaleFactor + 0.5f);
-      options.inDensity = 1000;
+      options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor);
+      options.inDensity = DENSITY_PRECISION_MULTIPLIER;
     }
     if (isScaling(options)) {
       options.inScaled = true;
@@ -371,6 +437,7 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy,
       Log.v(TAG, "Calculate scaling"
           + ", source: [" + sourceWidth + "x" + sourceHeight + "]"
           + ", target: [" + targetWidth + "x" + targetHeight + "]"
+          + ", power of two scaled: [" + powerOfTwoWidth + "x" + powerOfTwoHeight + "]"
           + ", exact scale factor: " + exactScaleFactor
           + ", power of 2 sample size: " + powerOfTwoSampleSize
           + ", adjusted scale factor: " + adjustedScaleFactor
@@ -379,24 +446,34 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy,
     }
   }
 
-  private boolean shouldUsePool(InputStream is) throws IOException {
+  /**
+   * BitmapFactory calculates the density scale factor as a float. This introduces some non-trivial
+   * error. This method attempts to account for that error by adjusting the inTargetDensity so that
+   * the final scale factor is as close to our target as possible.
+   */
+  private static int adjustTargetDensityForError(double adjustedScaleFactor) {
+    int targetDensity = round(DENSITY_PRECISION_MULTIPLIER * adjustedScaleFactor);
+    float scaleFactorWithError = targetDensity / (float) DENSITY_PRECISION_MULTIPLIER;
+    double difference = adjustedScaleFactor / scaleFactorWithError;
+    return round(difference * targetDensity);
+  }
+
+  // This is weird, but it matches the logic in a bunch of Android views/framework classes for
+  // rounding.
+  private static int round(double value) {
+    return (int) (value + 0.5d);
+  }
+
+  private boolean shouldUsePool(ImageType imageType) throws IOException {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       return true;
     }
 
-    try {
-      ImageHeaderParser.ImageType type = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
-      // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
-      // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
-      return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(type);
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine the image type from header", e);
-      }
-    }
-    return false;
+    // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
+    // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
+    return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(imageType);
   }
 
   private void calculateConfig(
@@ -518,7 +595,8 @@ private static boolean isScaling(BitmapFactory.Options options) {
   }
 
   private static void logDecode(int sourceWidth, int sourceHeight, String outMimeType,
-      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight) {
+      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight,
+      long startTime) {
     Log.v(TAG, "Decoded " + getBitmapString(result)
         + " from [" + sourceWidth + "x" + sourceHeight + "] " + outMimeType
         + " with inBitmap " + getInBitmapString(options)
@@ -526,7 +604,8 @@ private static void logDecode(int sourceWidth, int sourceHeight, String outMimeT
         + ", sample size: " + options.inSampleSize
         + ", density: " + options.inDensity
         + ", target density: " + options.inTargetDensity
-        + ", thread: " + Thread.currentThread().getName());
+        + ", thread: " + Thread.currentThread().getName()
+        + ", duration: " + LogTime.getElapsedMillis(startTime));
   }
 
   private static String getInBitmapString(BitmapFactory.Options options) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index e17e7500c..c81ad3554 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -127,11 +127,10 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
     final float heightPercentage = height / (float) inBitmap.getHeight();
     final float minPercentage = Math.min(widthPercentage, heightPercentage);
 
-    // take the floor of the target width/height, not round. If the matrix
-    // passed into drawBitmap rounds differently, we want to slightly
-    // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
-    final int targetWidth = (int) (minPercentage * inBitmap.getWidth());
-    final int targetHeight = (int) (minPercentage * inBitmap.getHeight());
+    // Round here in case we've decoded exactly the image we want, but take the floor below to
+    // avoid a line of garbage or blank pixels in images.
+    int targetWidth = Math.round(minPercentage * inBitmap.getWidth());
+    int targetHeight = Math.round(minPercentage * inBitmap.getHeight());
 
     if (inBitmap.getWidth() == targetWidth && inBitmap.getHeight() == targetHeight) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -140,6 +139,12 @@ public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitma
       return inBitmap;
     }
 
+    // Take the floor of the target width/height, not round. If the matrix
+    // passed into drawBitmap rounds differently, we want to slightly
+    // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
+    targetWidth = (int) (minPercentage * inBitmap.getWidth());
+    targetHeight = (int) (minPercentage * inBitmap.getHeight());
+
     Bitmap.Config config = getSafeConfig(inBitmap);
     Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
 
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index 09cc608fe..8fc6bab29 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -42,7 +42,6 @@
   // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
   // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
   private static final String FRAGMENT_INDEX_KEY = "key";
-  private static final String FRAGMENT_MANAGER_GET_FRAGMENT_KEY = "i";
 
   /**
    * The top application level RequestManager.
@@ -165,10 +164,9 @@ public RequestManager get(View view) {
     // Support Fragments.
     if (activity instanceof FragmentActivity) {
       Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
-      if (fragment == null) {
-        return get(activity);
+      if (fragment != null) {
+        return get(fragment);
       }
-      return get(fragment);
     }
 
     // Standard Fragments.
@@ -245,14 +243,29 @@ private Fragment findSupportFragment(View target, FragmentActivity activity) {
 
   // TODO: Consider using an accessor class in the support library package to more directly retrieve
   // non-support Fragments.
+  @TargetApi(Build.VERSION_CODES.O)
   private void findAllFragmentsWithViews(
       android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+      for (android.app.Fragment fragment : fragmentManager.getFragments()) {
+        if (fragment.getView() != null) {
+          result.put(fragment.getView(), fragment);
+          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+        }
+      }
+    } else {
+      findAllFragmentsWithViewsPreO(fragmentManager, result);
+    }
+  }
+
+  private void findAllFragmentsWithViewsPreO(
+      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
     int index = 0;
     while (true) {
       tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
       android.app.Fragment fragment = null;
       try {
-        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_MANAGER_GET_FRAGMENT_KEY);
+        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_INDEX_KEY);
       } catch (Exception e) {
         // This generates log spam from FragmentManager anyway.
       }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index a0cc26314..d21fbada2 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -122,7 +122,7 @@ public static RequestOptions sizeMultiplierOf(float sizeMultiplier) {
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
+   * Returns a {@link RequestOptions} object with {@link #diskCacheStrategy(DiskCacheStrategy)} set.
    */
   public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) {
     return new RequestOptions().diskCacheStrategy(diskCacheStrategy);
diff --git a/library/src/main/java/com/bumptech/glide/util/LogTime.java b/library/src/main/java/com/bumptech/glide/util/LogTime.java
index 834fc161d..344dbaa12 100644
--- a/library/src/main/java/com/bumptech/glide/util/LogTime.java
+++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java
@@ -24,7 +24,7 @@ public static long getLogTime() {
     if (Build.VERSION_CODES.JELLY_BEAN_MR1 <= Build.VERSION.SDK_INT) {
       return SystemClock.elapsedRealtimeNanos();
     } else {
-      return System.currentTimeMillis();
+      return SystemClock.uptimeMillis();
     }
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
deleted file mode 100644
index 4cbfc7e49..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ /dev/null
@@ -1,235 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.collect.Range.closed;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.Build;
-import android.util.DisplayMetrics;
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.ImageHeaderParser;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.bitmap.DownsamplerTest.AllocationSizeBitmap;
-import com.bumptech.glide.tests.Util;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Matchers;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 19, shadows = AllocationSizeBitmap.class)
-public class DownsamplerTest {
-  @Mock private BitmapPool bitmapPool;
-  @Mock private ArrayPool byteArrayPool;
-  private Downsampler downsampler;
-  private Options options;
-  private int initialSdkVersion;
-
-  @Before
-  public void setUp() throws Exception {
-    MockitoAnnotations.initMocks(this);
-    options = new Options();
-    DisplayMetrics displayMetrics =
-        RuntimeEnvironment.application.getResources().getDisplayMetrics();
-    when(byteArrayPool.get(anyInt(), Matchers.eq(byte[].class)))
-        .thenReturn(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
-
-    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
-    parsers.add(new DefaultImageHeaderParser());
-
-    downsampler = new Downsampler(parsers, displayMetrics, bitmapPool, byteArrayPool);
-
-    initialSdkVersion = Build.VERSION.SDK_INT;
-  }
-
-  @After
-  public void tearDown() {
-    Util.setSdkVersionInt(initialSdkVersion);
-  }
-
-  @Test
-  public void testAlwaysArgb8888() throws IOException {
-    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);
-    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-
-    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_ARGB_8888);
-    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
-    assertEquals(Bitmap.Config.ARGB_8888, result.get().getConfig());
-  }
-
-  @Test
-  public void testPreferRgb565() throws IOException {
-    Bitmap rgb565 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    InputStream stream = compressBitmap(rgb565, Bitmap.CompressFormat.JPEG);
-
-    options.set(Downsampler.DECODE_FORMAT, DecodeFormat.PREFER_RGB_565);
-    Resource<Bitmap> result = downsampler.decode(stream, 100, 100, options);
-    assertEquals(Bitmap.Config.RGB_565, result.get().getConfig());
-  }
-
-  @Test
-  public void testCalculateScaling_withInvalidSourceSizes_doesNotCrash() {
-    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_MOST, 0, 0);
-    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.AT_MOST, -1, -1);
-    runScaleTest(0, 0, 100, 100, DownsampleStrategy.AT_LEAST, 0, 0);
-    runScaleTest(-1, -1, 100, 100, DownsampleStrategy.CENTER_OUTSIDE, -1, -1);
-  }
-
-  @Test
-  public void testCalculateScaling_withAtMost() {
-    DownsampleStrategy strategy = DownsampleStrategy.AT_MOST;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 75, 75);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(801, 100, 100, 100, strategy, 50, 6);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  @Test
-  public void testCalculateScaling_withAtLeast() {
-    DownsampleStrategy strategy = DownsampleStrategy.AT_LEAST;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 150, 150);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  @Test
-  public void testCalculateScaling_withCenterInside() {
-    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(801, 100, 100, 100, strategy, 100, 13);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100);
-    runScaleTest(87, 78, 100, 100, strategy, 100, 90);
-  }
-
-  @Test
-  public void testCalculateScaling_withCenterOutside() {
-    DownsampleStrategy strategy = DownsampleStrategy.CENTER_OUTSIDE;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 112, 100);
-  }
-
-  @Test
-  public void testCalculateScaling_withNone() {
-    DownsampleStrategy strategy = DownsampleStrategy.NONE;
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100);
-    runScaleTest(200, 200, 100, 100, strategy, 200, 200);
-    runScaleTest(400, 400, 100, 100, strategy, 400, 400);
-    runScaleTest(300, 300, 100, 100, strategy, 300, 300);
-    runScaleTest(799, 100, 100, 100, strategy, 799, 100);
-    runScaleTest(800, 100, 100, 100, strategy, 800, 100);
-    runScaleTest(801, 100, 100, 100, strategy, 801, 100);
-    runScaleTest(100, 800, 100, 100, strategy, 100, 800);
-    runScaleTest(87, 78, 100, 100, strategy, 87, 78);
-  }
-
-  // BitmapFactory does not support downsampling wbmp files on platforms <=M. See b/27305903.
-  @Test
-  public void testCalculateScaling_withWbmp() {
-    Util.setSdkVersionInt(23);
-    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
-    BitmapFactory.Options options = new BitmapFactory.Options();
-
-    options.outMimeType = "image/vnd.wap.wbmp";
-    runScaleTest(100, 100, 100, 100, strategy, 100, 100, options);
-    runScaleTest(200, 200, 100, 100, strategy, 100, 100, options);
-    runScaleTest(400, 400, 100, 100, strategy, 100, 100, options);
-    runScaleTest(300, 300, 100, 100, strategy, 100, 100, options);
-    runScaleTest(799, 100, 100, 100, strategy, 100, 13, options);
-    runScaleTest(800, 100, 100, 100, strategy, 100, 13, options);
-    runScaleTest(801, 100, 100, 100, strategy, 100, 13, options);
-    runScaleTest(100, 800, 100, 100, strategy, 13, 100, options);
-    runScaleTest(87, 78, 100, 100, strategy, 100, 90, options);
-  }
-
-  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
-      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight) {
-    runScaleTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy, expectedWidth,
-        expectedHeight, new BitmapFactory.Options());
-  }
-
-  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
-      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight,
-      BitmapFactory.Options options) {
-    Downsampler.calculateScaling(strategy, 0, sourceWidth, sourceHeight, targetWidth, targetHeight,
-        options);
-    assertSize(sourceWidth, sourceHeight, expectedWidth, expectedHeight, options);
-  }
-
-  private static void assertSize(int sourceWidth, int sourceHeight, int expectedWidth,
-      int expectedHeight, BitmapFactory.Options options) {
-    float sampleSize = Math.max(1, options.inSampleSize);
-    int downsampledWidth = (int) ((sourceWidth / sampleSize) + 0.5f);
-    int downsampledHeight = (int) ((sourceHeight / sampleSize) + 0.5f);
-
-    float scaleFactor = options.inScaled && options.inTargetDensity > 0 && options.inDensity > 0
-        ? options.inTargetDensity / (float) options.inDensity : 1f;
-    int scaledWidth = (int) Math.ceil(downsampledWidth * scaleFactor);
-    int scaledHeight = (int) Math.ceil(downsampledHeight * scaleFactor);
-
-    assertThat(scaledWidth).isIn(closed(expectedWidth, expectedWidth + 1));
-    assertThat(scaledHeight).isIn(closed(expectedHeight, expectedHeight + 1));
-  }
-
-  private InputStream compressBitmap(Bitmap bitmap, Bitmap.CompressFormat compressFormat)
-      throws FileNotFoundException {
-    ByteArrayOutputStream os = new ByteArrayOutputStream();
-    bitmap.compress(compressFormat, 100, os);
-    return new ByteArrayInputStream(os.toByteArray());
-  }
-
-  // Robolectric doesn't implement getAllocationByteCount correctly.
-  @Implements(Bitmap.class)
-  public static class AllocationSizeBitmap extends ShadowBitmap {
-
-    @Implementation
-    public int getAllocationByteCount() {
-      return getWidth() * getHeight() * (getConfig() == Bitmap.Config.ARGB_8888 ? 4 : 2);
-    }
-  }
-}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index f600840b1..cf315b106 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -1,7 +1,16 @@
 package com.bumptech.glide.samples.gallery;
 
+import android.Manifest.permission;
+import android.annotation.TargetApi;
+import android.content.pm.PackageManager;
+import android.os.Build;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
+import android.support.v4.content.ContextCompat;
+import android.widget.Toast;
 import com.bumptech.glide.MemoryCategory;
 
 /**
@@ -9,10 +18,53 @@
  */
 public class MainActivity extends FragmentActivity {
 
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main_activity);
-        GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
+  private static final int REQUEST_READ_STORAGE = 0;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.main_activity);
+    GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
+        && ContextCompat.checkSelfPermission(this, permission.READ_EXTERNAL_STORAGE)
+        != PackageManager.PERMISSION_GRANTED) {
+      requestStoragePermission();
+    } else {
+      replaceFragment();
+    }
+  }
+
+  @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+  private void requestStoragePermission() {
+     ActivityCompat.requestPermissions(this,
+        new String[]{permission.READ_EXTERNAL_STORAGE},
+        REQUEST_READ_STORAGE);
+  }
+
+  private void replaceFragment() {
+    Fragment fragment = new HorizontalGalleryFragment();
+    getSupportFragmentManager()
+        .beginTransaction()
+        .replace(R.id.fragment_container, fragment)
+        .commit();
+  }
+
+  @Override
+  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
+      @NonNull int[] grantResults) {
+    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+    switch (requestCode) {
+      case REQUEST_READ_STORAGE: {
+        // If request is cancelled, the result arrays are empty.
+        if (grantResults.length > 0
+            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+          replaceFragment();
+        } else {
+          Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG)
+              .show();
+          requestStoragePermission();
+        }
+      }
     }
+  }
 }
diff --git a/samples/gallery/src/main/res/layout/main_activity.xml b/samples/gallery/src/main/res/layout/main_activity.xml
index 18c1a634f..8a31cf241 100644
--- a/samples/gallery/src/main/res/layout/main_activity.xml
+++ b/samples/gallery/src/main/res/layout/main_activity.xml
@@ -1,8 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-<merge xmlns:android="http://schemas.android.com/apk/res/android">
-    <fragment
-            android:name="com.bumptech.glide.samples.gallery.HorizontalGalleryFragment"
-            android:layout_width="match_parent"
-            android:layout_height="match_parent"
-            android:id="@+id/horizontal_gallery_fragment"/>
-</merge>
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/fragment_container"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent">
+</FrameLayout>
