diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index b6001b7a6..8e174594a 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -409,6 +409,7 @@ Glide build(@NonNull Context context) {
       if (size > 0) {
         bitmapPool = new LruBitmapPool(size);
       } else {
+        //如果计算出的bitmapPool大小是0,则不保存到缓存中,调用get方法会返回空的bitmap
         bitmapPool = new BitmapPoolAdapter();
       }
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
index 9060fd825..4b64893a5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java
@@ -22,16 +22,20 @@
   private final Map<K, LinkedEntry<K, V>> keyToEntry = new HashMap<>();
 
   public void put(K key, V value) {
+    //根据key获取对象
     LinkedEntry<K, V> entry = keyToEntry.get(key);
-
+    //如果entry不存在
     if (entry == null) {
       entry = new LinkedEntry<>(key);
+      //添加到entry的双链表中
       makeTail(entry);
+      //添加到hash map
       keyToEntry.put(key, entry);
     } else {
+      //添加元素
       key.offer();
     }
-
+    //添加到entry的list中
     entry.add(value);
   }
 
@@ -103,9 +107,12 @@ private void makeHead(LinkedEntry<K, V> entry) {
 
   // Make the entry the least recently used item.
   private void makeTail(LinkedEntry<K, V> entry) {
+    //从双向链表删除entry
     removeEntry(entry);
+    //将entry添加到双链表的头部位置
     entry.prev = head.prev;
     entry.next = head;
+    //连接双链表的上一个entry和下一个entry
     updateEntry(entry);
   }
 
@@ -119,6 +126,11 @@ private void makeTail(LinkedEntry<K, V> entry) {
     entry.next.prev = entry.prev;
   }
 
+  /**
+   * 双链表
+   * @param <K>
+   * @param <V>
+   */
   private static class LinkedEntry<K, V> {
     @Synthetic final K key;
     private List<V> values;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index d233c9130..f31ab67f6 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -27,6 +27,7 @@
   private final LruPoolStrategy strategy;
   private final Set<Bitmap.Config> allowedConfigs;
   private final long initialMaxSize;
+  /**bitmap跟踪器**/
   private final BitmapTracker tracker;
 
   private long maxSize;
@@ -259,6 +260,10 @@ private void dumpUnchecked() {
         + ", currentSize=" + currentSize + ", maxSize=" + maxSize + "\nStrategy=" + strategy);
   }
 
+  /**
+   * 创建默认的bitmap缓存
+   * @return
+   */
   private static LruPoolStrategy getDefaultStrategy() {
     final LruPoolStrategy strategy;
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index e496fde4e..c1ca14e86 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -60,7 +60,9 @@
 
   @Override
   public void put(Bitmap bitmap) {
+    //获取将要保存的图片的大小
     int size = Util.getBitmapByteSize(bitmap);
+    //根据图片的大小生成唯一的key
     Key key = keyPool.get(size, bitmap.getConfig());
 
     groupedMap.put(key, bitmap);
@@ -183,6 +185,10 @@ public Key get(int size, Bitmap.Config config) {
       return result;
     }
 
+    /**
+     * 当key对象不存在时,创建一个新的key
+     * @return
+     */
     @Override
     protected Key create() {
       return new Key(this);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 69acfabca..a16408171 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -21,7 +21,6 @@
   @VisibleForTesting
   static final int BYTES_PER_ARGB_8888_PIXEL = 4;
   private static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;
-
   private final int bitmapPoolSize;
   private final int memoryCacheSize;
   private final Context context;
@@ -50,13 +49,14 @@
     int heightPixels = builder.screenDimensions.getHeightPixels();
     //screenSize = 宽度*高度*4
     int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;
-    //bitmapPool大小 =屏幕尺寸*图片的大小(四舍五入),在8.0的系统上有特殊处理
+    //bitmapPool大小 =屏幕尺寸*图片的大小(四舍五入),在8.0的系统上有特殊处理,小于8.0的系统默认为 4
     int targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);
     //MemoryCache大小 = 屏幕尺寸*2 (四舍五入),默认为 2
     int targetMemoryCacheSize = Math.round(screenSize * builder.memoryCacheScreens);
     //可用大小 = 最大可用内存-arrayPoolSize的大小
     int availableSize = maxSize - arrayPoolSize;
 
+    //计算内存大小和bitmapPool
     if (targetMemoryCacheSize + targetBitmapPoolSize <= availableSize) {
       memoryCacheSize = targetMemoryCacheSize;
       bitmapPoolSize = targetBitmapPoolSize;
