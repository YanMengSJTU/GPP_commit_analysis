diff --git a/library/src/com/bumptech/glide/Glide.java b/library/src/com/bumptech/glide/Glide.java
index da91b9b1a..0e3ca90fb 100644
--- a/library/src/com/bumptech/glide/Glide.java
+++ b/library/src/com/bumptech/glide/Glide.java
@@ -18,6 +18,7 @@
 import com.bumptech.glide.loader.model.UriLoader;
 import com.bumptech.glide.loader.stream.StreamLoader;
 import com.bumptech.glide.loader.transformation.CenterCrop;
+import com.bumptech.glide.loader.transformation.CircleCrop;
 import com.bumptech.glide.loader.transformation.FitCenter;
 import com.bumptech.glide.loader.transformation.MultiTransformationLoader;
 import com.bumptech.glide.loader.transformation.None;
@@ -540,6 +541,17 @@ private Request(T model, ModelLoaderFactory<T> factory) {
         public Request<T> centerCrop() {
             return transform(new CenterCrop<T>());
         }
+        
+        /**
+         * Transform images using {@link com.bumptech.glide.loader.transformation.CircleCrop}.
+         *
+         * @see #transform(com.bumptech.glide.loader.transformation.TransformationLoader)
+         *
+         * @return This Request
+         */
+        public Request<T> circleCrop() {
+            return transform(new CircleCrop<T>());
+        }
 
         /**
          * Transform images using {@link com.bumptech.glide.loader.transformation.FitCenter}.
diff --git a/library/src/com/bumptech/glide/loader/transformation/CircleCrop.java b/library/src/com/bumptech/glide/loader/transformation/CircleCrop.java
new file mode 100644
index 000000000..c21921ac9
--- /dev/null
+++ b/library/src/com/bumptech/glide/loader/transformation/CircleCrop.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.loader.transformation;
+
+import com.bumptech.glide.resize.load.Transformation;
+
+/**
+ * Load image to exactly match the view in one dimension and then crop the image to fit the other dimension.
+ *
+ * @param <T> The type of the model. Can be any type since the {@link Transformation is model/type agnostic}.
+ */
+public class CircleCrop<T> implements TransformationLoader<T>{
+    @Override
+    public Transformation getTransformation(T model) {
+        return Transformation.CIRCLE_CROP;
+    }
+
+    @Override
+    public String getId() {
+        return Transformation.CIRCLE_CROP.getId();
+    }
+}
\ No newline at end of file
diff --git a/library/src/com/bumptech/glide/resize/load/ImageResizer.java b/library/src/com/bumptech/glide/resize/load/ImageResizer.java
index 034649725..560193204 100644
--- a/library/src/com/bumptech/glide/resize/load/ImageResizer.java
+++ b/library/src/com/bumptech/glide/resize/load/ImageResizer.java
@@ -9,7 +9,11 @@
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Paint;
+import android.graphics.PorterDuffXfermode;
+import android.graphics.Rect;
 import android.graphics.RectF;
+import android.graphics.Bitmap.Config;
+import android.graphics.PorterDuff.Mode;
 import android.media.ExifInterface;
 import android.os.Build;
 import android.util.Log;
@@ -233,6 +237,46 @@ public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int h
         canvas.drawBitmap(toCrop, m, paint);
         return result;
     }
+    
+    
+    /**
+     * Clip the given Bitmap with transparent circle
+     *
+     * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped portion of toCrop
+     *                 into
+     * @param toCrop The Bitmap to resize
+     * @param width The width of the final Bitmap
+     * @param height The height of the final Bitmap
+     * @return The resized Bitmap (will be recycled if recycled is not null)
+     */
+    public static Bitmap circleCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
+        if (toCrop == null) {
+            return null;
+        }
+        final Bitmap result;
+        if (recycled != null) {
+            result = recycled;
+        } else {
+        	result = Bitmap.createBitmap(toCrop.getWidth(), toCrop.getHeight(), Config.ARGB_8888);
+        }
+	    Canvas canvas = new Canvas(result);
+	
+	    final int color = 0xff424242;
+	    final Paint paint = new Paint();
+	    final Rect rect = new Rect(0, 0, toCrop.getWidth(), toCrop.getHeight());
+	    final RectF rectF = new RectF(rect);
+	
+	    paint.setAntiAlias(true);
+	    canvas.drawARGB(0, 0, 0, 0);
+	    paint.setColor(color);
+	    canvas.drawRoundRect(rectF, toCrop.getWidth(), toCrop.getHeight(), paint);
+	
+	    paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));
+	    canvas.drawBitmap(toCrop, rect, rect, paint);
+	
+	    return result;
+    
+        }
 
     /**
      * An expensive operation to resize the given image, maintaining the original proportions, so that its width
diff --git a/library/src/com/bumptech/glide/resize/load/Transformation.java b/library/src/com/bumptech/glide/resize/load/Transformation.java
index 1845fea31..866e42b48 100644
--- a/library/src/com/bumptech/glide/resize/load/Transformation.java
+++ b/library/src/com/bumptech/glide/resize/load/Transformation.java
@@ -40,6 +40,21 @@ public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHei
             return ImageResizer.fitInSpace(bitmap, outWidth, outHeight);
         }
     };
+    
+    /**
+     * Scale the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image
+     * will be equal to the given dimension and the other will be less than the given dimension
+     */
+    public static Transformation CIRCLE_CROP = new Transformation() {
+        @Override
+        public Bitmap transform(Bitmap bitmap, BitmapPool pool, int outWidth, int outHeight) {
+            if (outWidth <= 0 || outHeight <= 0) {
+                throw new IllegalArgumentException("Cannot circle crop image to width=" + outWidth + " and height="
+                        + outHeight);
+            }
+            return ImageResizer.circleCrop(pool.get(outWidth, outHeight, bitmap.getConfig()), bitmap, outWidth, outHeight);
+        }
+    };
 
     /**
      * A noop Transformation that simply returns the given bitmap
