diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
index 9b25b8a97..16e548732 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java
@@ -118,8 +118,12 @@ void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
           return;
         }
         EngineResource<?> newResource =
-            new EngineResource<>(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
-        newResource.setResourceListener(ref.key, listener);
+            new EngineResource<>(
+                ref.resource,
+                /*isMemoryCacheable=*/ true,
+                /*isRecyclable=*/ false,
+                ref.key,
+                listener);
         listener.onResourceReleased(ref.key, newResource);
       }
     }
@@ -180,9 +184,9 @@ void shutdown() {
       super(referent, queue);
       this.key = Preconditions.checkNotNull(key);
       this.resource =
-          referent.isCacheable() && isActiveResourceRetentionAllowed
+          referent.isMemoryCacheable() && isActiveResourceRetentionAllowed
               ? Preconditions.checkNotNull(referent.getResource()) : null;
-      isCacheable = referent.isCacheable();
+      isCacheable = referent.isMemoryCacheable();
     }
 
     void reset() {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index f3050c8b7..54697616d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -11,6 +11,7 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.DiskCacheAdapter;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
@@ -102,7 +103,12 @@ public Engine(
     if (engineJobFactory == null) {
       engineJobFactory =
           new EngineJobFactory(
-              diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);
+              diskCacheExecutor,
+              sourceExecutor,
+              sourceUnlimitedExecutor,
+              animationExecutor,
+              /*engineJobListener=*/ this,
+              /*resourceListener=*/ this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -276,7 +282,8 @@ private static void logWithTimeAndKey(String log, long startTime, Key key) {
       // Save an object allocation if we've cached an EngineResource (the typical case).
       result = (EngineResource<?>) cached;
     } else {
-      result = new EngineResource<>(cached, true /*isMemoryCacheable*/, true /*isRecyclable*/);
+      result = new EngineResource<>(
+          cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);
     }
     return result;
   }
@@ -294,12 +301,8 @@ public void release(Resource<?> resource) {
   public synchronized void onEngineJobComplete(
       EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
     // A null resource indicates that the load failed, usually due to an exception.
-    if (resource != null) {
-      resource.setResourceListener(key, this);
-
-      if (resource.isCacheable()) {
-        activeResources.activate(key, resource);
-      }
+    if (resource != null && resource.isMemoryCacheable()) {
+      activeResources.activate(key, resource);
     }
 
     jobs.removeIfCurrent(key, engineJob);
@@ -318,7 +321,7 @@ public void onResourceRemoved(@NonNull final Resource<?> resource) {
   @Override
   public synchronized void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
     activeResources.deactivate(cacheKey);
-    if (resource.isCacheable()) {
+    if (resource.isMemoryCacheable()) {
       cache.put(cacheKey, resource);
     } else {
       resourceRecycler.recycle(resource);
@@ -456,7 +459,8 @@ public DiskCache getDiskCache() {
     @Synthetic final GlideExecutor sourceExecutor;
     @Synthetic final GlideExecutor sourceUnlimitedExecutor;
     @Synthetic final GlideExecutor animationExecutor;
-    @Synthetic final EngineJobListener listener;
+    @Synthetic final EngineJobListener engineJobListener;
+    @Synthetic final ResourceListener resourceListener;
     @Synthetic final Pools.Pool<EngineJob<?>> pool =
         FactoryPools.threadSafe(
             JOB_POOL_SIZE,
@@ -468,7 +472,8 @@ public DiskCache getDiskCache() {
                     sourceExecutor,
                     sourceUnlimitedExecutor,
                     animationExecutor,
-                    listener,
+                    engineJobListener,
+                    resourceListener,
                     pool);
               }
             });
@@ -478,12 +483,14 @@ public DiskCache getDiskCache() {
         GlideExecutor sourceExecutor,
         GlideExecutor sourceUnlimitedExecutor,
         GlideExecutor animationExecutor,
-        EngineJobListener listener) {
+        EngineJobListener engineJobListener,
+        ResourceListener resourceListener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
       this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
       this.animationExecutor = animationExecutor;
-      this.listener = listener;
+      this.engineJobListener = engineJobListener;
+      this.resourceListener = resourceListener;
     }
 
     @VisibleForTesting
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index c3bd7358e..0a1846c95 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -5,6 +5,7 @@
 import android.support.v4.util.Pools;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.util.Executors;
@@ -31,9 +32,10 @@
   final ResourceCallbacksAndExecutors cbs = new ResourceCallbacksAndExecutors();
 
   private final StateVerifier stateVerifier = StateVerifier.newInstance();
+  private final ResourceListener resourceListener;
   private final Pools.Pool<EngineJob<?>> pool;
   private final EngineResourceFactory engineResourceFactory;
-  private final EngineJobListener listener;
+  private final EngineJobListener engineJobListener;
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
   private final GlideExecutor sourceUnlimitedExecutor;
@@ -73,14 +75,16 @@
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
       GlideExecutor animationExecutor,
-      EngineJobListener listener,
+      EngineJobListener engineJobListener,
+      ResourceListener resourceListener,
       Pools.Pool<EngineJob<?>> pool) {
     this(
         diskCacheExecutor,
         sourceExecutor,
         sourceUnlimitedExecutor,
         animationExecutor,
-        listener,
+        engineJobListener,
+        resourceListener,
         pool,
         DEFAULT_FACTORY);
   }
@@ -91,14 +95,16 @@
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
       GlideExecutor animationExecutor,
-      EngineJobListener listener,
+      EngineJobListener engineJobListener,
+      ResourceListener resourceListener,
       Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
     this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
     this.animationExecutor = animationExecutor;
-    this.listener = listener;
+    this.engineJobListener = engineJobListener;
+    this.resourceListener = resourceListener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
@@ -197,7 +203,7 @@ void cancel() {
 
     isCancelled = true;
     decodeJob.cancel();
-    listener.onEngineJobCancelled(this, key);
+    engineJobListener.onEngineJobCancelled(this, key);
   }
 
   // Exposed for testing.
@@ -231,7 +237,7 @@ void notifyCallbacksOfResult() {
       } else if (hasResource) {
         throw new IllegalStateException("Already have resource");
       }
-      engineResource = engineResourceFactory.build(resource, isCacheable);
+      engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener);
       // Hold on to resource for duration of our callbacks below so we don't recycle it in the
       // middle of notifying if it synchronously released by one of the callbacks. Acquire it under
       // a lock here so that any newly added callback that executes before the next locked section
@@ -244,7 +250,7 @@ void notifyCallbacksOfResult() {
       localResource = engineResource;
     }
 
-    listener.onEngineJobComplete(this, localKey, localResource);
+    engineJobListener.onEngineJobComplete(this, localKey, localResource);
 
     for (final ResourceCallbackAndExecutor entry : copy) {
       entry.executor.execute(new CallResourceReady(entry.cb));
@@ -347,7 +353,7 @@ void notifyCallbacksOfException() {
       incrementPendingCallbacks(copy.size() + 1);
     }
 
-    listener.onEngineJobComplete(this, localKey, /*resource=*/ null);
+    engineJobListener.onEngineJobComplete(this, localKey, /*resource=*/ null);
 
     for (ResourceCallbackAndExecutor entry : copy) {
       entry.executor.execute(new CallLoadFailed(entry.cb));
@@ -480,8 +486,10 @@ public int hashCode() {
 
   @VisibleForTesting
   static class EngineResourceFactory {
-    public <R> EngineResource<R> build(Resource<R> resource, boolean isMemoryCacheable) {
-      return new EngineResource<>(resource, isMemoryCacheable, /*isRecyclable=*/ true);
+    public <R> EngineResource<R> build(
+        Resource<R> resource, boolean isMemoryCacheable, Key key, ResourceListener listener) {
+      return new EngineResource<>(
+          resource, isMemoryCacheable, /*isRecyclable=*/ true, key, listener);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
index 2ff397bdc..4db3a1db7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java
@@ -11,12 +11,12 @@
  * @param <Z> The type of data returned by the wrapped {@link Resource}.
  */
 class EngineResource<Z> implements Resource<Z> {
-  private final boolean isCacheable;
+  private final boolean isMemoryCacheable;
   private final boolean isRecyclable;
   private final Resource<Z> resource;
+  private final ResourceListener listener;
+  private final Key key;
 
-  private ResourceListener listener;
-  private Key key;
   private int acquired;
   private boolean isRecycled;
 
@@ -24,23 +24,25 @@
     void onResourceReleased(Key key, EngineResource<?> resource);
   }
 
-  EngineResource(Resource<Z> toWrap, boolean isCacheable, boolean isRecyclable) {
+  EngineResource(
+      Resource<Z> toWrap,
+      boolean isMemoryCacheable,
+      boolean isRecyclable,
+      Key key,
+      ResourceListener listener) {
     resource = Preconditions.checkNotNull(toWrap);
-    this.isCacheable = isCacheable;
+    this.isMemoryCacheable = isMemoryCacheable;
     this.isRecyclable = isRecyclable;
-  }
-
-  synchronized void setResourceListener(Key key, ResourceListener listener) {
     this.key = key;
-    this.listener = listener;
+    this.listener = Preconditions.checkNotNull(listener);
   }
 
   Resource<Z> getResource() {
     return resource;
   }
 
-  boolean isCacheable() {
-    return isCacheable;
+  boolean isMemoryCacheable() {
+    return isMemoryCacheable;
   }
 
   @NonNull
@@ -119,7 +121,7 @@ void release() {
   @Override
   public synchronized String toString() {
     return "EngineResource{"
-        + "isCacheable=" + isCacheable
+        + "isMemoryCacheable=" + isMemoryCacheable
         + ", listener=" + listener
         + ", key=" + key
         + ", acquired=" + acquired
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
index 1991d205f..652505fd0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java
@@ -44,17 +44,23 @@
    * arbitrary.
    */
   private static final int MINIMUM_DECODES_BETWEEN_FD_CHECKS = 50;
-
   /**
    * 700 with an error of 50 Bitmaps in between at two FDs each lets us use up to 800 FDs for
    * hardware Bitmaps.
+   *
+   * <p>Reduced on S7 Edge devices due to  https://github.com/bumptech/glide/issues/3275.
    */
-  private static final int MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = 700;
+  private static final int MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = isSamsungGalaxyS7Edge() ? 350 : 700;
+
+  private static volatile HardwareConfigState instance;
 
   private volatile int decodesSinceLastFdCheck;
   private volatile boolean isHardwareConfigAllowed = true;
 
-  private static volatile HardwareConfigState instance;
+  // See https://bit.ly/2IW5AmI
+  private static boolean isSamsungGalaxyS7Edge() {
+    return Build.MODEL.startsWith("SM-G935") || Build.MODEL.startsWith("SM-G930");
+  }
 
   static HardwareConfigState getInstance() {
     if (instance == null) {
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
index a467ea774..acc1b6a30 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java
@@ -7,6 +7,7 @@
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 
+import android.os.Looper;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.ActiveResources.DequeuedResourceCallback;
@@ -26,8 +27,8 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLooper;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(shadows = GlideShadowLooper.class)
@@ -60,16 +61,14 @@ public void get_withMissingKey_returnsNull() {
 
   @Test
   public void get_withActiveKey_returnsResource() {
-    EngineResource<Object> expected =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> expected = newCacheableEngineResource();
     resources.activate(key, expected);
     assertThat(resources.get(key)).isEqualTo(expected);
   }
 
   @Test
   public void get_withDeactivatedKey_returnsNull() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
     resources.deactivate(key);
     assertThat(resources.get(key)).isNull();
@@ -82,8 +81,7 @@ public void deactivate_withNotActiveKey_doesNotThrow() {
 
   @Test
   public void get_withActiveAndClearedKey_returnsNull() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
     resources.activeEngineResources.get(key).clear();
     assertThat(resources.get(key)).isNull();
@@ -91,8 +89,7 @@ public void get_withActiveAndClearedKey_returnsNull() {
 
   @Test
   public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithWrappedResource() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
     resources.activeEngineResources.get(key).clear();
     resources.get(key);
@@ -106,8 +103,7 @@ public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithWr
 
   @Test
   public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithNotRecycleable() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
     resources.activeEngineResources.get(key).clear();
     resources.get(key);
@@ -122,8 +118,7 @@ public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithNo
 
   @Test
   public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithCacheable() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
     resources.activeEngineResources.get(key).clear();
     resources.get(key);
@@ -132,13 +127,12 @@ public void get_withActiveAndClearedKey_andCacheableResource_callsListenerWithCa
 
     verify(listener).onResourceReleased(eq(key), captor.capture());
 
-    assertThat(captor.getValue().isCacheable()).isTrue();
+    assertThat(captor.getValue().isMemoryCacheable()).isTrue();
   }
 
   @Test
   public void get_withActiveAndClearedKey_andNotCacheableResource_doesNotCallListener() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
     resources.activate(key, engineResource);
     resources.activeEngineResources.get(key).clear();
     resources.get(key);
@@ -148,8 +142,7 @@ public void get_withActiveAndClearedKey_andNotCacheableResource_doesNotCallListe
 
   @Test
   public void queueIdle_afterResourceRemovedFromActive_doesNotCallListener() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -162,8 +155,7 @@ public void queueIdle_afterResourceRemovedFromActive_doesNotCallListener() {
 
   @Test
   public void queueIdle_withCacheableResourceInActive_callListener() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -175,7 +167,7 @@ public void queueIdle_withCacheableResourceInActive_callListener() {
 
     EngineResource<?> released = captor.getValue();
     assertThat(released.getResource()).isEqualTo(resource);
-    assertThat(released.isCacheable()).isTrue();
+    assertThat(released.isMemoryCacheable()).isTrue();
 
     released.recycle();
     verify(resource, never()).recycle();
@@ -183,8 +175,7 @@ public void queueIdle_withCacheableResourceInActive_callListener() {
 
   @Test
   public void queueIdle_withNotCacheableResourceInActive_doesNotCallListener() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -196,8 +187,7 @@ public void queueIdle_withNotCacheableResourceInActive_doesNotCallListener() {
 
   @Test
   public void queueIdle_withCacheableResourceInActive_removesResourceFromActive() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -208,8 +198,7 @@ public void queueIdle_withCacheableResourceInActive_removesResourceFromActive()
 
   @Test
   public void queueIdle_withNotCacheableResourceInActive_removesResourceFromActive() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -220,8 +209,7 @@ public void queueIdle_withNotCacheableResourceInActive_removesResourceFromActive
 
   @Test
   public void get_withQueuedReference_returnsResource() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -232,8 +220,7 @@ public void get_withQueuedReference_returnsResource() {
 
   @Test
   public void get_withQueuedReference_doesNotNotifyListener() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -244,8 +231,7 @@ public void get_withQueuedReference_doesNotNotifyListener() {
 
   @Test
   public void queueIdle_withQueuedReferenceRetrievedFromGet_notifiesListener() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -261,8 +247,7 @@ public void queueIdle_withQueuedReferenceRetrievedFromGet_notifiesListener() {
 
   @Test
   public void queueIdle_withQueuedReferenceRetrievedFromGetAndNotCacheable_doesNotNotifyListener() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -303,8 +288,7 @@ public void run() {
               });
       resources.setListener(listener);
 
-      EngineResource<Object> engineResource =
-          new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+      EngineResource<Object> engineResource = newCacheableEngineResource();
       resources.activate(key, engineResource);
 
       ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -349,16 +333,14 @@ public void run() {
               });
       resources.setListener(listener);
 
-      EngineResource<Object> first =
-          new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+      EngineResource<Object> first = newCacheableEngineResource();
       resources.activate(key, first);
 
       ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
       CountDownLatch latch = getLatchForClearedRef();
       weakRef.enqueue();
 
-      EngineResource<Object> second =
-          new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+      EngineResource<Object> second = newCacheableEngineResource();
       resources.activate(key, second);
       blockExecutor.countDown();
 
@@ -373,8 +355,7 @@ public void run() {
 
   @Test
   public void activate_withNonCacheableResource_doesNotSaveResource() {
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newNonCacheableEngineResource();
     resources.activate(key, engineResource);
 
     assertThat(resources.activeEngineResources.get(key).resource).isNull();
@@ -384,8 +365,7 @@ public void activate_withNonCacheableResource_doesNotSaveResource() {
   public void get_withActiveClearedKey_cacheableResource_retentionDisabled_doesNotCallListener() {
     resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
     resources.setListener(listener);
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
     resources.activeEngineResources.get(key).clear();
     resources.get(key);
@@ -397,8 +377,7 @@ public void get_withActiveClearedKey_cacheableResource_retentionDisabled_doesNot
   public void get_withQueuedReference_retentionDisabled_returnsResource() {
     resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
     resources.setListener(listener);
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -411,8 +390,7 @@ public void get_withQueuedReference_retentionDisabled_returnsResource() {
   public void queueIdle_withQueuedReferenceRetrievedFromGet_retentionDisabled_doesNotNotify() {
     resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);
     resources.setListener(listener);
-    EngineResource<Object> engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
+    EngineResource<Object> engineResource = newCacheableEngineResource();
     resources.activate(key, engineResource);
 
     ResourceWeakReference weakRef = resources.activeEngineResources.get(key);
@@ -438,7 +416,7 @@ private void waitForLatch(CountDownLatch latch) {
     } catch (InterruptedException e) {
       throw new RuntimeException(e);
     }
-    ShadowLooper.getShadowMainLooper().runToEndOfTasks();
+    Shadows.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
   }
 
   private CountDownLatch getLatchForClearedRef() {
@@ -452,6 +430,16 @@ public void onResourceDequeued() {
     return toWait;
   }
 
+  private EngineResource<Object> newCacheableEngineResource() {
+    return new EngineResource<>(
+        resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ false, key, listener);
+  }
+
+  private EngineResource<Object> newNonCacheableEngineResource() {
+    return new EngineResource<>(
+        resource, /*isMemoryCacheable=*/ false, /*isRecyclable=*/ false, key, listener);
+  }
+
   @SuppressWarnings("unchecked")
   private static ArgumentCaptor<EngineResource<?>> getEngineResourceCaptor() {
     return (ArgumentCaptor<EngineResource<?>>) (ArgumentCaptor<?>)
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index d6bb580ed..51368f8a7 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -21,6 +21,7 @@
 import android.support.v4.util.Pools;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.EngineResource.ResourceListener;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
@@ -66,7 +67,7 @@ public void testListenerNotifiedJobCompleteOnOnResourceReady() {
 
     ShadowLooper.runUiThreadTasks();
 
-    verify(harness.listener)
+    verify(harness.engineJobListener)
         .onEngineJobComplete(eq(job), eq(harness.key), eq(harness.engineResource));
   }
 
@@ -110,7 +111,7 @@ public void testListenerNotifiedJobCompleteOnException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
     ShadowLooper.runUiThreadTasks();
-    verify(harness.listener)
+    verify(harness.engineJobListener)
         .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
   }
 
@@ -122,7 +123,9 @@ public void testResourceIsCacheableWhenIsCacheableOnReady() {
     job.onResourceReady(harness.resource, harness.dataSource);
 
     ShadowLooper.runUiThreadTasks();
-    verify(harness.factory).build(anyResource(), eq(harness.isCacheable));
+    verify(harness.factory)
+        .build(
+            anyResource(), eq(harness.isCacheable), eq(harness.key), eq(harness.resourceListener));
   }
 
   @Test
@@ -133,7 +136,9 @@ public void testResourceIsCacheableWhenNotIsCacheableOnReady() {
     job.onResourceReady(harness.resource, harness.dataSource);
 
     ShadowLooper.runUiThreadTasks();
-    verify(harness.factory).build(anyResource(), eq(harness.isCacheable));
+    verify(harness.factory)
+        .build(
+            anyResource(), eq(harness.isCacheable), eq(harness.key), eq(harness.resourceListener));
   }
 
   @Test
@@ -142,7 +147,7 @@ public void testListenerNotifiedOfCancelOnCancel() {
     job.start(harness.decodeJob);
     job.cancel();
 
-    verify(harness.listener).onEngineJobCancelled(eq(job), eq(harness.key));
+    verify(harness.engineJobListener).onEngineJobCancelled(eq(job), eq(harness.key));
   }
 
   @Test
@@ -205,7 +210,7 @@ public void testDoesNotNotifyCancelledIfCompletes() {
     job.start(harness.decodeJob);
     job.onResourceReady(harness.resource, harness.dataSource);
 
-    verify(harness.listener, never()).onEngineJobCancelled(eq(job), eq(harness.key));
+    verify(harness.engineJobListener, never()).onEngineJobCancelled(eq(job), eq(harness.key));
   }
 
   @Test
@@ -215,7 +220,7 @@ public void testDoesNotNotifyCancelledIfAlreadyCancelled() {
     job.cancel();
     job.cancel();
 
-    verify(harness.listener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));
+    verify(harness.engineJobListener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));
   }
 
   @Test
@@ -224,9 +229,10 @@ public void testDoesNotNotifyCancelledIfReceivedException() {
     job.start(harness.decodeJob);
     job.onLoadFailed(new GlideException("test"));
 
-    verify(harness.listener)
+    verify(harness.engineJobListener)
         .onEngineJobComplete(eq(job), eq(harness.key), isNull(EngineResource.class));
-    verify(harness.listener, never()).onEngineJobCancelled(any(EngineJob.class), any(Key.class));
+    verify(harness.engineJobListener, never())
+        .onEngineJobCancelled(any(EngineJob.class), any(Key.class));
   }
 
   @Test
@@ -481,7 +487,8 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
     final Key key = mock(Key.class);
     final Resource<Object> resource = mockResource();
     final EngineResource<Object> engineResource = mock(EngineResource.class);
-    final EngineJobListener listener = mock(EngineJobListener.class);
+    final EngineJobListener engineJobListener = mock(EngineJobListener.class);
+    final ResourceListener resourceListener = mock(ResourceListener.class);
     final boolean isCacheable = true;
     final boolean useUnlimitedSourceGeneratorPool = false;
     final boolean useAnimationPool = false;
@@ -499,14 +506,15 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
     final DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
-      when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
+      when(factory.build(resource, isCacheable, key, resourceListener)).thenReturn(engineResource);
       job =
           new EngineJob<>(
               diskCacheService,
               sourceService,
               sourceUnlimitedService,
               animationService,
-              listener,
+              engineJobListener,
+              resourceListener,
               pool,
               factory);
       job.init(
@@ -532,7 +540,8 @@ public MultiCbHarness() {
     final ResourceCallback cb = mock(ResourceCallback.class);
     final Resource<Object> resource = mockResource();
     final EngineResource<Object> engineResource = mock(EngineResource.class);
-    final EngineJobListener listener = mock(EngineJobListener.class);
+    final EngineJobListener engineJobListener = mock(EngineJobListener.class);
+    final ResourceListener resourceListener = mock(ResourceListener.class);
     final GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
     final GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
     final GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadExecutor();
@@ -546,14 +555,15 @@ public MultiCbHarness() {
     final DataSource dataSource = DataSource.DATA_DISK_CACHE;
 
     EngineJob<Object> getJob() {
-      when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
+      when(factory.build(resource, isCacheable, key, resourceListener)).thenReturn(engineResource);
       EngineJob<Object> result =
           new EngineJob<>(
               diskCacheService,
               sourceService,
               sourceUnlimitedService,
               animationService,
-              listener,
+              engineJobListener,
+              resourceListener,
               pool,
               factory);
       result.init(
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
index 3468931eb..954e4f1b7 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java
@@ -32,8 +32,8 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     engineResource =
-        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);
-    engineResource.setResourceListener(cacheKey, listener);
+        new EngineResource<>(
+            resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, cacheKey, listener);
   }
 
   @Test
@@ -143,24 +143,36 @@ public void testThrowsIfReleasedMoreThanAcquired() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfWrappedResourceIsNull() {
-    new EngineResource<>(/*toWrap=*/ null, /*isCacheable=*/ false, /*isRecyclable=*/ true);
+    new EngineResource<>(
+        /*toWrap=*/ null, /*isMemoryCacheable=*/ false, /*isRecyclable=*/ true, cacheKey, listener);
   }
 
   @Test
   public void testCanSetAndGetIsCacheable() {
     engineResource =
-        new EngineResource<>(mockResource(), /*isCacheable=*/ true, /*isRecyclable=*/ true);
-    assertTrue(engineResource.isCacheable());
+        new EngineResource<>(
+            mockResource(),
+            /*isMemoryCacheable=*/ true,
+            /*isRecyclable=*/ true,
+            cacheKey,
+            listener);
+    assertTrue(engineResource.isMemoryCacheable());
     engineResource =
-        new EngineResource<>(mockResource(), /*isCacheable=*/ false, /*isRecyclable=*/ true);
-    assertFalse(engineResource.isCacheable());
+        new EngineResource<>(
+            mockResource(),
+            /*isMemoryCacheable=*/ false,
+            /*isRecyclable=*/ true,
+            cacheKey,
+            listener);
+    assertFalse(engineResource.isMemoryCacheable());
   }
 
   @Test
   public void release_whenNotRecycleable_doesNotRecycleResource() {
     resource = mockResource();
-    engineResource = new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
-    engineResource.setResourceListener(cacheKey, listener);
+    engineResource =
+        new EngineResource<>(
+            resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ false, cacheKey, listener);
     engineResource.recycle();
 
     verify(listener, never()).onResourceReleased(any(Key.class), any(EngineResource.class));
diff --git a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 207d7abcc..172c8b1d7 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -267,15 +267,6 @@ public void testRunnerIsRemovedFromRunnersOnEngineNotifiedJobComplete() {
     assertThat(harness.jobs.getAll()).doesNotContainKey(harness.cacheKey);
   }
 
-  @Test
-  public void testEngineIsSetAsResourceListenerOnJobComplete() {
-    harness.doLoad();
-
-    harness.callOnEngineJobComplete();
-
-    verify(harness.resource).setResourceListener(eq(harness.cacheKey), eq(harness.getEngine()));
-  }
-
   @Test
   public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete() {
     harness.doLoad();
@@ -285,7 +276,7 @@ public void testEngineIsNotSetAsResourceListenerIfResourceIsNullOnJobComplete()
 
   @Test
   public void testResourceIsAddedToActiveResourcesOnEngineComplete() {
-    when(harness.resource.isCacheable()).thenReturn(true);
+    when(harness.resource.isMemoryCacheable()).thenReturn(true);
     harness.callOnEngineJobComplete();
 
     EngineResource<?> resource = harness.activeResources.get(harness.cacheKey);
@@ -300,7 +291,7 @@ public void testDoesNotPutNullResourceInActiveResourcesOnEngineComplete() {
 
   @Test
   public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {
-    when(harness.resource.isCacheable()).thenReturn(false);
+    when(harness.resource.isMemoryCacheable()).thenReturn(false);
     harness.callOnEngineJobComplete();
     assertThat(harness.activeResources.get(harness.cacheKey)).isNull();
   }
@@ -326,7 +317,7 @@ public void testJobIsNotRemovedFromJobsIfOldJobIsCancelled() {
   @Test
   public void testResourceIsAddedToCacheOnReleased() {
     final Object expected = new Object();
-    when(harness.resource.isCacheable()).thenReturn(true);
+    when(harness.resource.isMemoryCacheable()).thenReturn(true);
     when(harness.resource.get()).thenReturn(expected);
     doAnswer(
             new Answer<Void>() {
@@ -347,7 +338,7 @@ public Void answer(InvocationOnMock invocationOnMock) {
 
   @Test
   public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
-    when(harness.resource.isCacheable()).thenReturn(false);
+    when(harness.resource.isMemoryCacheable()).thenReturn(false);
     harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
 
     verify(harness.cache, never()).put(eq(harness.cacheKey), eq(harness.resource));
@@ -355,7 +346,7 @@ public void testResourceIsNotAddedToCacheOnReleasedIfNotCacheable() {
 
   @Test
   public void testResourceIsRecycledIfNotCacheableWhenReleased() {
-    when(harness.resource.isCacheable()).thenReturn(false);
+    when(harness.resource.isMemoryCacheable()).thenReturn(false);
     harness.getEngine().onResourceReleased(harness.cacheKey, harness.resource);
     verify(harness.resourceRecycler).recycle(eq(harness.resource));
   }
@@ -446,7 +437,7 @@ public void runTest() {
 
   @Test
   public void load_afterResourceIsLoadedInActiveResources_returnsFromMemoryCache() {
-    when(harness.resource.isCacheable()).thenReturn(true);
+    when(harness.resource.isMemoryCacheable()).thenReturn(true);
     doAnswer(
             new Answer<Object>() {
               @Override
@@ -465,7 +456,7 @@ public Object answer(InvocationOnMock invocationOnMock) {
   @Test
   public void load_afterResourceIsLoadedAndReleased_returnsFromMemoryCache() {
     harness.cache = new LruResourceCache(100);
-    when(harness.resource.isCacheable()).thenReturn(true);
+    when(harness.resource.isMemoryCacheable()).thenReturn(true);
     doAnswer(
             new Answer<Object>() {
               @Override
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
index 9256943d9..446f67953 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -278,6 +278,13 @@ public synchronized Bitmap getNextFrame() {
       act = pct;
       // Set transparent color if specified.
       act[currentFrame.transIndex] = COLOR_TRANSPARENT_BLACK;
+
+      if (currentFrame.dispose == DISPOSAL_BACKGROUND && framePointer == 0) {
+        // TODO: We should check and see if all individual pixels are replaced. If they are, the
+        // first frame isn't actually transparent. For now, it's simpler and safer to assume
+        // drawing a transparent background means the GIF contains transparency.
+        isFirstFrameTransparent = true;
+      }
     }
 
     // Transfer pixel data to image.
@@ -446,11 +453,6 @@ private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
           if (currentFrame.lct != null && header.bgIndex == currentFrame.transIndex) {
             c = COLOR_TRANSPARENT_BLACK;
           }
-        } else if (framePointer == 0) {
-          // TODO: We should check and see if all individual pixels are replaced. If they are, the
-          // first frame isn't actually transparent. For now, it's simpler and safer to assume
-          // drawing a transparent background means the GIF contains transparency.
-          isFirstFrameTransparent = true;
         }
         // The area used by the graphic must be restored to the background color.
         int downsampledIH = previousFrame.ih / sampleSize;
@@ -540,7 +542,8 @@ private void copyIntoScratchFast(GifFrame currentFrame) {
     }
 
     isFirstFrameTransparent =
-        isFirstFrameTransparent == null && isFirstFrame && transparentColorIndex != -1;
+        (isFirstFrameTransparent != null && isFirstFrameTransparent)
+            || (isFirstFrameTransparent == null && isFirstFrame && transparentColorIndex != -1);
   }
 
   private void copyCopyIntoScratchRobust(GifFrame currentFrame) {
