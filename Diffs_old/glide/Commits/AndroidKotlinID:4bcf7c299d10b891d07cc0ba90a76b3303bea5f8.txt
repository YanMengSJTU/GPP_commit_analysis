diff --git a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
index 5a2c92d2f..9a658eb84 100644
--- a/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -14,9 +15,13 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.io.File;
 import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
 import java.lang.Object;
 import java.lang.Override;
+import java.lang.String;
 import java.lang.SuppressWarnings;
+import java.net.URL;
 
 /**
  * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
@@ -65,6 +70,55 @@ public GlideRequests setDefaultRequestOptions(RequestOptions requestOptions) {
     return (GlideRequest<Drawable>) super.asDrawable();
   }
 
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Integer arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
   @Override
   @CheckResult
   public GlideRequest<Drawable> load(@Nullable Object arg0) {
diff --git a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
index 99aa810a1..7d02b4b5a 100644
--- a/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -14,10 +15,14 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.io.File;
 import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
 import java.lang.Number;
 import java.lang.Object;
 import java.lang.Override;
+import java.lang.String;
 import java.lang.SuppressWarnings;
+import java.net.URL;
 
 /**
  * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
@@ -73,6 +78,55 @@ public GlideRequests setDefaultRequestOptions(RequestOptions requestOptions) {
     return (GlideRequest<Drawable>) super.asDrawable();
   }
 
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Integer arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
   @Override
   @CheckResult
   public GlideRequest<Drawable> load(@Nullable Object arg0) {
diff --git a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
index e8cf9ea52..287ab6171 100644
--- a/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
+++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -14,10 +15,14 @@
 import com.bumptech.glide.request.RequestOptions;
 import java.io.File;
 import java.lang.Class;
+import java.lang.Deprecated;
+import java.lang.Integer;
 import java.lang.Number;
 import java.lang.Object;
 import java.lang.Override;
+import java.lang.String;
 import java.lang.SuppressWarnings;
+import java.net.URL;
 
 /**
  * Includes all additions from methods in {@link com.bumptech.glide.annotation.GlideExtension}s
@@ -75,6 +80,55 @@ public GlideRequests setDefaultRequestOptions(RequestOptions requestOptions) {
     return (GlideRequest<Drawable>) super.asDrawable();
   }
 
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable String arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Uri arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable File arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable Integer arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @Deprecated
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable URL arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
+  @Override
+  @CheckResult
+  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {
+    return (GlideRequest<Drawable>) super.load(arg0);
+  }
+
   @Override
   @CheckResult
   public GlideRequest<Drawable> load(@Nullable Object arg0) {
diff --git a/build.gradle b/build.gradle
index 1667c5696..e905716c5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -77,7 +77,7 @@ subprojects { project ->
     apply plugin: 'checkstyle'
 
     checkstyle {
-        toolVersion = '6.12.1'
+        toolVersion = '8.4'
     }
 
     checkstyle {
diff --git a/checkstyle.xml b/checkstyle.xml
index 821938198..327bc70d1 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -94,8 +94,16 @@
         <!-- Prevent importing Mockito matchers directly -->
         <module name="IllegalImport">
             <property name="illegalPkgs" value="org.mockito.internal" />
-            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />
+            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers." />
         </module>
+
+        <!-- ArgumentMatchers isn't available internally, the same methods are available on org.mockito.Mockito. -->
+        <module name="IllegalImport">
+            <property name="illegalClasses" value="org\.mockito\.ArgumentMatchers\..*" />
+            <property name="regexp" value="true" />
+            <message key="import.illegal" value="Import from illegal class - {0}. Use org.mockito.Mockito to statically import matcher methods." />
+        </module>
+
         <module name="ImportOrder">
           <!-- Checks for out of order import statements. -->
 
@@ -105,6 +113,7 @@
            <!-- This ensures that static imports go first. -->
            <property name="option" value="top"/>
            <property name="tokens" value="STATIC_IMPORT, IMPORT"/>
+           <property name="separated" value="true" />
          </module>
 
         <!-- Checks for whitespace. -->
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
index 069d45bfe..0ce9b6e28 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide;
 
 import static com.bumptech.glide.test.Matchers.anyDrawable;
-import static com.bumptech.glide.test.Matchers.anyTarget;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.Mockito.any;
@@ -88,7 +88,7 @@ public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFro
         .onResourceReady(
             anyDrawable(),
             any(),
-            anyTarget(),
+            anyDrawableTarget(),
             eq(DataSource.MEMORY_CACHE),
             anyBoolean());
   }
@@ -144,7 +144,7 @@ public void run() {
         .onResourceReady(
             anyDrawable(),
             any(),
-            anyTarget(),
+            anyDrawableTarget(),
             not(eq(DataSource.MEMORY_CACHE)),
             anyBoolean());
   }
@@ -172,7 +172,7 @@ public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCac
         .onResourceReady(
             anyDrawable(),
             any(),
-            anyTarget(),
+            anyDrawableTarget(),
             eq(DataSource.DATA_DISK_CACHE),
             anyBoolean());
   }
@@ -204,7 +204,7 @@ public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFr
         .onResourceReady(
             anyDrawable(),
             any(),
-            anyTarget(),
+            anyDrawableTarget(),
             eq(DataSource.MEMORY_CACHE),
             anyBoolean());
   }
@@ -273,7 +273,7 @@ public void clearDiskCache_doesNotPreventFutureLoads()
         .onResourceReady(
             anyDrawable(),
             any(),
-            anyTarget(),
+            anyDrawableTarget(),
             eq(DataSource.DATA_DISK_CACHE),
             anyBoolean());
   }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/Issue2638Test.java b/instrumentation/src/androidTest/java/com/bumptech/glide/Issue2638Test.java
deleted file mode 100644
index 2696fc73b..000000000
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/Issue2638Test.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package com.bumptech.glide;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.CompressFormat;
-import android.graphics.BitmapFactory;
-import android.graphics.Color;
-import android.graphics.drawable.BitmapDrawable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-import android.widget.AbsListView.LayoutParams;
-import android.widget.ImageView;
-import com.bumptech.glide.test.BitmapSubject;
-import com.bumptech.glide.test.ConcurrencyHelper;
-import com.bumptech.glide.test.ResourceIds;
-import com.bumptech.glide.test.TearDownGlide;
-import com.google.common.io.ByteStreams;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.ExecutionException;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-@RunWith(AndroidJUnit4.class)
-public class Issue2638Test {
-  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
-  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
-  private Context context;
-
-  @Before
-  public void setUp() {
-    context = InstrumentationRegistry.getTargetContext();
-  }
-
-  @Test
-  public void intoImageView_withDifferentByteArrays_loadsDifferentImages()
-      throws IOException, ExecutionException, InterruptedException {
-    final ImageView imageView = new ImageView(context);
-    imageView.setLayoutParams(new LayoutParams(/*w=*/ 100, /*h=*/ 100));
-
-    final byte[] canonicalBytes = getCanonicalBytes();
-    final byte[] modifiedBytes = getModifiedBytes();
-
-    Glide.with(context)
-        .load(canonicalBytes)
-        .submit()
-        .get();
-
-    concurrency.loadOnMainThread(Glide.with(context).load(canonicalBytes), imageView);
-    Bitmap firstBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();
-
-    concurrency.loadOnMainThread(Glide.with(context).load(modifiedBytes), imageView);
-    Bitmap secondBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();
-
-    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
-  }
-
-  private byte[] getModifiedBytes() throws IOException {
-    byte[] canonicalBytes = getCanonicalBytes();
-    BitmapFactory.Options options = new BitmapFactory.Options();
-    options.inMutable = true;
-    Bitmap bitmap =
-        BitmapFactory.decodeByteArray(canonicalBytes, 0, canonicalBytes.length, options);
-    bitmap.setPixel(0, 0, Color.TRANSPARENT);
-    ByteArrayOutputStream os = new ByteArrayOutputStream();
-    bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
-    return os.toByteArray();
-  }
-
-  private byte[] getCanonicalBytes() throws IOException {
-    int resourceId = ResourceIds.raw.canonical;
-    Resources resources = context.getResources();
-    InputStream is = resources.openRawResource(resourceId);
-    return ByteStreams.toByteArray(is);
-  }
-}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
new file mode 100644
index 000000000..fef214394
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java
@@ -0,0 +1,363 @@
+package com.bumptech.glide;
+
+
+import static com.bumptech.glide.test.Matchers.anyBitmap;
+import static com.bumptech.glide.test.Matchers.anyBitmapTarget;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBitmapTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Bitmap> bitmapListener;
+  @Mock private RequestListener<Drawable> drawableListener;
+
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void clearFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    FutureTarget<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    FutureTarget<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void clearFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    FutureTarget<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(bitmap)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transformFromRequestBuilder_withLoadedBitmap_asBitmap_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    FutureTarget<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    FutureTarget<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    FutureTarget<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(bitmap)
+            .centerCrop()
+            .listener(drawableListener)
+            .submit(100, 100));
+
+    verify(drawableListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    FutureTarget<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(
+            anyBitmap(),
+            any(),
+            anyBitmapTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asBitmap_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    FutureTarget<Bitmap> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asBitmap()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(bitmap)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asBitmap()
+            .load(bitmap)
+            .centerCrop()
+            .listener(bitmapListener)
+            .submit(100, 100));
+
+    verify(bitmapListener)
+        .onResourceReady(
+            anyBitmap(),
+            any(),
+            anyBitmapTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
new file mode 100644
index 000000000..052329f70
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java
@@ -0,0 +1,497 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.GlideOptions.skipMemoryCacheOf;
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.AbsListView.LayoutParams;
+import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.BitmapSubject;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> requestListener;
+
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+
+    imageView = new ImageView(context);
+    int[] dimensions = getCanonicalDimensions();
+    imageView.setLayoutParams(new LayoutParams(/*w=*/ dimensions[0], /*h=*/ dimensions[1]));
+
+    // Writes to the resource disk cache run in a non-blocking manner after the Target is notified.
+    // Unless we enforce a single threaded executor, the encode task races with our second decode
+    // task, causing the test to sometimes fail (when the second resource is started after the
+    // encode and loaded from the disk cache) and sometimes succeed (when the second resource is
+    // started before the encode and loads from source).
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    GlideExecutor glideExecutor = MockGlideExecutor.newTestExecutor(executor);
+    Glide.init(context, new GlideBuilder()
+        .setAnimationExecutor(glideExecutor)
+        .setDiskCacheExecutor(glideExecutor)
+        .setSourceExecutor(glideExecutor));
+  }
+
+  @Test
+  public void loadFromRequestManager_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(
+        Glide.with(context).load(canonicalBytes), imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context).load(modifiedBytes), imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void loadFromRequestBuilder_intoImageView_withDifferentByteArrays_loadsDifferentImages()
+      throws IOException, ExecutionException, InterruptedException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    final byte[] modifiedBytes = getModifiedBytes();
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(canonicalBytes),
+        imageView);
+    Bitmap firstBitmap = copyFromImageViewDrawable(imageView);
+
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(modifiedBytes),
+        imageView);
+    Bitmap secondBitmap = copyFromImageViewDrawable(imageView);
+
+    // This assertion alone doesn't catch the case where the second Bitmap is loaded from the result
+    // cache of the data from the first Bitmap.
+    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
+
+    Bitmap expectedCanonicalBitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    BitmapSubject.assertThat(firstBitmap).sameAs(expectedCanonicalBitmap);
+
+    Bitmap expectedModifiedBitmap =
+        BitmapFactory.decodeByteArray(modifiedBytes, /*offset=*/ 0, modifiedBytes.length);
+    BitmapSubject.assertThat(secondBitmap).sameAs(expectedModifiedBitmap);
+  }
+
+  @Test
+  public void requestManager_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .load(canonicalBytes)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void requestBuilder_intoImageView_withSameByteArrayAndMemoryCacheEnabled_loadsFromMemory()
+      throws IOException {
+    final byte[] canonicalBytes = getCanonicalBytes();
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .asDrawable()
+            .load(canonicalBytes)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    Glide.with(context).clear(imageView);
+
+    concurrency.loadOnMainThread(
+        Glide.with(context)
+            .asDrawable()
+            .load(canonicalBytes)
+            .listener(requestListener)
+            .apply(skipMemoryCacheOf(false)),
+        imageView);
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    FutureTarget<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_validDiskCacheStrategy_returnsFromDiskCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    FutureTarget<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    FutureTarget<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .skipMemoryCache(false)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_memoryCacheEnabled_returnsFromCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    FutureTarget<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .skipMemoryCache(false)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    FutureTarget<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArray_returnsFromLocal() throws IOException {
+    byte[] data = getCanonicalBytes();
+    FutureTarget<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestManager_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+       throws IOException {
+    byte[] data = getCanonicalBytes();
+    FutureTarget<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_withSameByteArrayAndMissingFromMemory_returnsFromLocal()
+       throws IOException {
+    byte[] data = getCanonicalBytes();
+    FutureTarget<Drawable> target = concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .submit());
+    GlideApp.with(context).clear(target);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .load(data)
+            .listener(requestListener)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.LOCAL), anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withDiskCacheStrategySetBeforeLoad_doesNotOverrideDiskCacheStrategy()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .load(data)
+            .submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .diskCacheStrategy(DiskCacheStrategy.RESOURCE)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromBuilder_withSkipMemoryCacheSetBeforeLoad_doesNotOverrideSkipMemoryCache()
+      throws IOException {
+    byte[] data = getCanonicalBytes();
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .skipMemoryCache(false)
+            .load(data)
+            .submit());
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .asDrawable()
+            .skipMemoryCache(false)
+            .listener(requestListener)
+            .load(data)
+            .submit());
+
+    verify(requestListener).onResourceReady(
+        anyDrawable(), any(), anyDrawableTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+  }
+
+  private Bitmap copyFromImageViewDrawable(ImageView imageView) {
+    if (imageView.getDrawable() == null) {
+      fail("Drawable unexpectedly null");
+    }
+
+    // Glide mutates Bitmaps, so it's possible that a Bitmap loaded into a View in one place may
+    // be re-used to load a different image later. Create a defensive copy just in case.
+    return Bitmap.createBitmap(((BitmapDrawable) imageView.getDrawable()).getBitmap());
+  }
+
+  private int[] getCanonicalDimensions() throws IOException {
+    byte[] canonicalBytes = getCanonicalBytes();
+    Bitmap bitmap =
+        BitmapFactory.decodeByteArray(canonicalBytes, /*offset=*/ 0, canonicalBytes.length);
+    return new int[] { bitmap.getWidth(), bitmap.getHeight() };
+  }
+
+  private byte[] getModifiedBytes() throws IOException {
+    int[] dimensions = getCanonicalDimensions();
+    Bitmap bitmap = Bitmap.createBitmap(dimensions[0], dimensions[1], Config.ARGB_8888);
+    ByteArrayOutputStream os = new ByteArrayOutputStream();
+    bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
+    return os.toByteArray();
+  }
+
+  private byte[] getCanonicalBytes() throws IOException {
+    int resourceId = ResourceIds.raw.canonical;
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(resourceId);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
new file mode 100644
index 000000000..5a73caa3a
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadDrawableTest.java
@@ -0,0 +1,213 @@
+package com.bumptech.glide;
+
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyBoolean;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
+import com.bumptech.glide.load.engine.cache.LruResourceCache;
+import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
+import com.bumptech.glide.request.FutureTarget;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.util.Util;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class LoadDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  @Mock private RequestListener<Drawable> listener;
+
+  private Context context;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void clear_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    FutureTarget<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(drawable)
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    // Allow Glide's resource recycler to run on the main thread.
+    concurrency.pokeMainThread();
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void transform_withLoadedBitmapDrawable_doesNotRecycleBitmap() {
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new MemoryCacheAdapter())
+        .setBitmapPool(new BitmapPoolAdapter()));
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .submit(100, 100));
+
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    FutureTarget<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    FutureTarget<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+
+  @Test
+  public void loadFromRequestBuilder_asDrawable_withBitmapAndStrategyBeforeLoad_notFromCache() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
+    Glide.init(context, new GlideBuilder()
+        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10))
+        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));
+    FutureTarget<Drawable> target =
+        concurrency.wait(
+            GlideApp.with(context)
+                .asDrawable()
+                .diskCacheStrategy(DiskCacheStrategy.ALL)
+                .load(drawable)
+                .centerCrop()
+                .submit(100, 100));
+    Glide.with(context).clear(target);
+
+    assertThat(bitmap.isRecycled()).isFalse();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        Glide.get(context).clearMemory();
+      }
+    });
+
+    concurrency.wait(
+        GlideApp.with(context)
+            .load(drawable)
+            .centerCrop()
+            .listener(listener)
+            .submit(100, 100));
+
+    verify(listener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyDrawableTarget(),
+            eq(DataSource.LOCAL),
+            anyBoolean());
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
index 3fa1cba76..e41db5705 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java
@@ -30,6 +30,7 @@
 import org.junit.rules.ExpectedException;
 import org.junit.rules.TestName;
 import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
 
 @RunWith(AndroidJUnit4.class)
 public class NonBitmapDrawableResourcesTest {
@@ -41,6 +42,7 @@
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
     context = InstrumentationRegistry.getTargetContext();
   }
 
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
index a6d25c58a..c89ea575c 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -1,7 +1,7 @@
 package com.bumptech.glide;
 
 import static com.bumptech.glide.test.Matchers.anyDrawable;
-import static com.bumptech.glide.test.Matchers.anyTarget;
+import static com.bumptech.glide.test.Matchers.anyDrawableTarget;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;
@@ -196,14 +196,14 @@ public void run() {
         .onResourceReady(
             anyDrawable(),
             any(),
-            anyTarget(),
+            anyDrawableTarget(),
             eq(DataSource.DATA_DISK_CACHE),
             anyBoolean());
     verify(requestListener, never())
         .onResourceReady(
             anyDrawable(),
             any(),
-            anyTarget(),
+            anyDrawableTarget(),
             eq(DataSource.RESOURCE_DISK_CACHE),
             anyBoolean());
     assertThat(imageView.getDrawable()).isNull();
@@ -234,14 +234,14 @@ public void run() {
         .onResourceReady(
             anyDrawable(),
             any(),
-            anyTarget(),
+            anyDrawableTarget(),
             eq(DataSource.DATA_DISK_CACHE),
             anyBoolean());
     verify(requestListener, never())
         .onResourceReady(
             anyDrawable(),
             any(),
-            anyTarget(),
+            anyDrawableTarget(),
             eq(DataSource.RESOURCE_DISK_CACHE),
             anyBoolean());
 
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..94ef1782c
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,116 @@
+package com.bumptech.glide.load.engine.executor;
+
+import android.os.StrictMode;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import com.google.common.util.concurrent.ForwardingExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+@VisibleForTesting
+public final class MockGlideExecutor {
+  private MockGlideExecutor() {
+    // Utility class.
+  }
+
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static GlideExecutor newTestExecutor(ExecutorService executorService) {
+    return new GlideExecutor(executorService);
+  }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return newTestExecutor(new DirectExecutorService());
+  }
+
+  /**
+   * @deprecated Use {@link #newMainThreadExecutor} instead.
+   */
+  @Deprecated
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return newMainThreadExecutor();
+  }
+
+  /**
+   * DirectExecutorService that enforces StrictMode and converts ExecutionExceptions into
+   * RuntimeExceptions.
+   */
+  private static final class DirectExecutorService extends ForwardingExecutorService {
+    private static final StrictMode.ThreadPolicy THREAD_POLICY =
+        new StrictMode.ThreadPolicy.Builder()
+            .detectNetwork()
+            .penaltyDeath()
+            .build();
+
+    private final ExecutorService delegate;
+
+    DirectExecutorService() {
+      delegate = MoreExecutors.newDirectExecutorService();
+    }
+
+    @Override
+    protected ExecutorService delegate() {
+      return delegate;
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Runnable task, @NonNull T result) {
+      return getUninterruptibly(super.submit(task, result));
+    }
+
+    @NonNull
+    @Override
+    public <T> Future<T> submit(@NonNull Callable<T> task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @NonNull
+    @Override
+    public Future<?> submit(@NonNull Runnable task) {
+      return getUninterruptibly(super.submit(task));
+    }
+
+    @Override
+    public void execute(@NonNull final Runnable command) {
+      delegate.execute(new Runnable() {
+        @Override
+        public void run() {
+          StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
+          StrictMode.setThreadPolicy(THREAD_POLICY);
+          try {
+            command.run();
+          } finally {
+            StrictMode.setThreadPolicy(oldPolicy);
+          }
+        }
+      });
+    }
+
+    private <T> Future<T> getUninterruptibly(Future<T> future) {
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+      }
+      return future;
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index 9a7be36fd..28cd3a489 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -103,6 +103,9 @@ public void run() {
 
     GifDrawable drawableFromView = (GifDrawable) imageView.getDrawable();
     assertThat(drawableFromView.isRunning()).isTrue();
+
+    gifDrawable.stop();
+    drawableFromView.stop();
   }
 
   // LayoutParams.TYPE_SYSTEM_ALERT.
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
index a44b59056..0e3df5e57 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.test;
 
 import android.graphics.drawable.Drawable;
+import android.os.Debug;
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.Nullable;
@@ -28,15 +29,25 @@
  */
 public class ConcurrencyHelper {
   private final Handler handler = new Handler(Looper.getMainLooper());
-  static final long TIMEOUT_MS = 5000;
-  static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;
-
-  public <T> T get(Future<T> future) {
-    try {
-      return future.get(TIMEOUT_MS, TIMEOUT_UNIT);
-    } catch (InterruptedException | ExecutionException | TimeoutException e) {
-      throw new RuntimeException(e);
-    }
+  private static final long TIMEOUT_SECONDS = 5;
+  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.SECONDS;
+
+  public <T> T get(final Future<T> future) {
+    final AtomicReference<T> reference = new AtomicReference<>();
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        try {
+          reference.set(future.get(timeout, timeUnit));
+          return true;
+        } catch (ExecutionException e) {
+          throw new RuntimeException(e);
+        } catch (TimeoutException e) {
+          return false;
+        }
+      }
+    });
+    return reference.get();
   }
 
   public <T, Y extends Future<T>> Y wait(Y future) {
@@ -46,7 +57,7 @@
 
   public void loadOnOtherThread(final Runnable runnable) {
     final AtomicBoolean isDone = new AtomicBoolean();
-    Thread thread = new Thread(new Runnable() {
+    final Thread thread = new Thread(new Runnable() {
       @Override
       public void run() {
         runnable.run();
@@ -54,14 +65,14 @@ public void run() {
       }
     });
     thread.start();
-    try {
-      thread.join(TIMEOUT_MS, /*nanos=*/0);
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
-    }
-    if (!isDone.get()) {
-      throw new IllegalStateException("Failed to finish job in available time");
-    }
+
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        thread.join(timeUnit.toMillis(timeout));
+        return isDone.get();
+      }
+    });
   }
 
   public void loadOnMainThread(
@@ -249,14 +260,12 @@ public Void call() throws Exception {
   }
 
   private <T> void callOnMainThread(final Callable<T> callable) {
-    final AtomicReference<T> reference = new AtomicReference<>();
     final CountDownLatch latch = new CountDownLatch(1);
     handler.post(new Runnable() {
       @Override
       public void run() {
         try {
-          T result = callable.call();
-          reference.set(result);
+          callable.call();
         } catch (Exception e) {
           throw new RuntimeException(e);
         }
@@ -264,16 +273,39 @@ public void run() {
       }
     });
     waitOnLatch(latch);
-    reference.get();
   }
 
-  private static void waitOnLatch(CountDownLatch latch) {
-    try {
-      if (!latch.await(TIMEOUT_MS, TIMEOUT_UNIT)) {
-        throw new RuntimeException("Timed out waiting for latch");
+  static void waitOnLatch(final CountDownLatch latch) {
+    wait(new Waiter() {
+      @Override
+      public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException {
+        return latch.await(timeout, timeUnit);
       }
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
-    }
+    });
+  }
+
+  private interface Waiter {
+    boolean await(long timeout, TimeUnit timeUnit) throws InterruptedException;
+  }
+
+  private static void wait(Waiter waiter) {
+    boolean isFinished = false;
+     do {
+       try {
+         try {
+           isFinished = waiter.await(TIMEOUT_SECONDS, TIMEOUT_UNIT);
+           if (!isFinished) {
+             throw new RuntimeException("Timed out while waiting");
+           }
+         } catch (InterruptedException e) {
+           throw new RuntimeException(e);
+         }
+       } catch (RuntimeException e) {
+         if (Debug.isDebuggerConnected()) {
+           continue;
+         }
+         throw e;
+       }
+     } while (Debug.isDebuggerConnected() && !isFinished);
   }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ExternallyClearedDiskCacheTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ExternallyClearedDiskCacheTest.java
new file mode 100644
index 000000000..34f9b4a79
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ExternallyClearedDiskCacheTest.java
@@ -0,0 +1,124 @@
+package com.bumptech.glide.test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.Key;
+import com.bumptech.glide.load.engine.cache.DiskCache;
+import com.bumptech.glide.load.engine.cache.DiskCache.Factory;
+import com.bumptech.glide.load.engine.cache.DiskLruCacheWrapper;
+import com.bumptech.glide.test.ResourceIds.raw;
+import java.io.File;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+// Tests #2465.
+@RunWith(AndroidJUnit4.class)
+public class ExternallyClearedDiskCacheTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private File cacheDir;
+
+  @Before
+  public void setUp() {
+    context = InstrumentationRegistry.getTargetContext();
+    cacheDir = context.getCacheDir();
+  }
+
+  @After
+  public void tearDown() {
+    // Force us to wait until Glide's threads shut down.
+    Glide.tearDown();
+    deleteRecursively(cacheDir);
+  }
+
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+  }
+
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeletedAndCleared_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+    cache.clear();
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(new Factory() {
+              @Override
+              public DiskCache build() {
+                return cache;
+              }
+            }));
+
+    Drawable drawable =
+        concurrency.get(
+            Glide.with(context)
+                .load(ResourceIds.raw.canonical)
+                .submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  @Test
+  public void loadFromCache_afterDiskCacheDeleted_doesNotFail() {
+    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursively(cacheDir);
+
+    Glide.init(
+        context,
+        new GlideBuilder()
+            .setDiskCache(new Factory() {
+              @Override
+              public DiskCache build() {
+                return cache;
+              }
+            }));
+
+    Drawable drawable =
+        concurrency.get(Glide.with(context)
+            .load(raw.canonical)
+            .submit());
+    assertThat(drawable).isNotNull();
+  }
+
+  private static void deleteRecursively(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursively(f);
+        }
+      }
+    }
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
+    }
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
index de7fbf088..d941793ea 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
@@ -2,6 +2,7 @@
 
 import static org.mockito.Mockito.any;
 
+import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
 import com.bumptech.glide.request.target.Target;
 
@@ -14,12 +15,24 @@ private Matchers() {
     // Utility class.
   }
 
+  public static Target<Drawable> anyDrawableTarget() {
+    return anyTarget();
+  }
+
+  public static Target<Bitmap> anyBitmapTarget() {
+    return anyTarget();
+  }
+
   @SuppressWarnings("unchecked")
-  public static Target<Drawable> anyTarget() {
-    return (Target<Drawable>) any(Target.class);
+  public static <T> Target<T> anyTarget() {
+    return (Target<T>) any(Target.class);
+  }
+
+  public static Bitmap anyBitmap() {
+    return any();
   }
 
   public static Drawable anyDrawable() {
-    return any(Drawable.class);
+    return any();
   }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
index 76c631202..01da84cd1 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
@@ -107,11 +107,7 @@ public void teardown() {
 
     @Override
     public void loadData(Priority priority, DataCallback<? super Data> callback) {
-      try {
-        toWaitOn.await(ConcurrencyHelper.TIMEOUT_MS, ConcurrencyHelper.TIMEOUT_UNIT);
-      } catch (InterruptedException e) {
-        throw new RuntimeException(e);
-      }
+      ConcurrencyHelper.waitOnLatch(toWaitOn);
       wrapped.loadData(priority, callback);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 082b9a603..ea902a565 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -355,17 +355,17 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
             Registry.BUCKET_BITMAP_DRAWABLE,
             ByteBuffer.class,
             BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool, byteBufferBitmapDecoder))
+            new BitmapDrawableDecoder<>(resources, byteBufferBitmapDecoder))
         .append(
             Registry.BUCKET_BITMAP_DRAWABLE,
             InputStream.class,
             BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool, streamBitmapDecoder))
+            new BitmapDrawableDecoder<>(resources, streamBitmapDecoder))
         .append(
             Registry.BUCKET_BITMAP_DRAWABLE,
             ParcelFileDescriptor.class,
             BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, bitmapPool, videoBitmapDecoder))
+            new BitmapDrawableDecoder<>(resources, videoBitmapDecoder))
         .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))
         /* GIFs */
         .append(
@@ -440,7 +440,7 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         .register(
             Bitmap.class,
             BitmapDrawable.class,
-            new BitmapDrawableTranscoder(resources, bitmapPool))
+            new BitmapDrawableTranscoder(resources))
         .register(Bitmap.class, byte[].class, new BitmapBytesTranscoder())
         .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
 
diff --git a/library/src/main/java/com/bumptech/glide/ModelTypes.java b/library/src/main/java/com/bumptech/glide/ModelTypes.java
new file mode 100644
index 000000000..71c77fb1c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/ModelTypes.java
@@ -0,0 +1,46 @@
+package com.bumptech.glide;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Ensures that the set of explicitly supported model types remains consistent across Glide's
+ * API surface.
+ */
+interface ModelTypes<T> {
+  @CheckResult
+  T load(@Nullable Bitmap bitmap);
+
+  @CheckResult
+   T load(@Nullable Drawable drawable);
+
+  @CheckResult
+  T load(@Nullable String string);
+
+  @CheckResult
+  T load(@Nullable Uri uri);
+
+  @CheckResult
+  T load(@Nullable File file);
+
+  @CheckResult
+  T load(@RawRes @DrawableRes @Nullable Integer resourceId);
+
+  @Deprecated
+  @CheckResult
+  T load(@Nullable URL url);
+
+  @CheckResult
+   T load(@Nullable byte[] model);
+
+  @CheckResult
+  @SuppressWarnings("unchecked")
+  T load(@Nullable Object model);
+}
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 7af04eeca..d59061f90 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -2,6 +2,7 @@
 
 import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
+import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
 
 import android.content.Context;
 import android.graphics.Bitmap;
@@ -28,12 +29,10 @@
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.target.ViewTarget;
 import com.bumptech.glide.signature.ApplicationVersionSignature;
-import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 import java.io.File;
 import java.net.URL;
-import java.util.UUID;
 
 /**
  * A generic class that can handle setting options and staring loads for generic resource types.
@@ -43,7 +42,8 @@
  */
 // Public API.
 @SuppressWarnings({"unused", "WeakerAccess"})
-public class RequestBuilder<TranscodeType> implements Cloneable {
+public class RequestBuilder<TranscodeType> implements Cloneable,
+    ModelTypes<RequestBuilder<TranscodeType>> {
   // Used in generated subclasses
   protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
@@ -230,7 +230,7 @@ protected RequestOptions getMutableOptions() {
   @SuppressWarnings({"CheckResult", "unchecked"})
   @CheckResult
   public RequestBuilder<TranscodeType> thumbnail(
-      @Nullable RequestBuilder<TranscodeType> /*@Nullable*/ ... thumbnails) {
+      @Nullable RequestBuilder<TranscodeType>... thumbnails) {
     if (thumbnails == null || thumbnails.length == 0) {
       return thumbnail((RequestBuilder<TranscodeType>) null);
     }
@@ -303,14 +303,12 @@ protected RequestOptions getMutableOptions() {
   /**
    * Sets the specific model to load data for.
    *
-   * <p> This method must be called at least once before
-   * {@link #into(com.bumptech.glide.request.target.Target)} is called. </p>
-   *
    * @param model The model to load data for, or null.
    * @return This request builder.
    */
   @CheckResult
   @SuppressWarnings("unchecked")
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Object model) {
     return loadGeneric(model);
   }
@@ -320,9 +318,8 @@ protected RequestOptions getMutableOptions() {
     isModelSet = true;
     return this;
   }
-
   /**
-   * Returns a request builder to load the given {@link Bitmap}.
+   * Returns an object to load the given {@link Bitmap}.
    *
    * <p>It's almost always better to allow Glide to load {@link Bitmap}s than
    * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is
@@ -330,8 +327,10 @@ protected RequestOptions getMutableOptions() {
    * {@link com.bumptech.glide.load.model.ModelLoader} or
    * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
    *
-   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other
-   * strategies may result in undefined behavior.
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
    *
    * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not
    * compared.
@@ -339,6 +338,7 @@ protected RequestOptions getMutableOptions() {
    * @see #load(Object)
    */
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
     return loadGeneric(bitmap)
         .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
@@ -353,8 +353,10 @@ protected RequestOptions getMutableOptions() {
    * {@link com.bumptech.glide.load.model.ModelLoader} or
    * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method.
    *
-   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other
-   * strategies may result in undefined behavior.
+   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Previous calls to
+   * {@link #apply(RequestOptions)} or previously applied {@link DiskCacheStrategy}s will be
+   * overridden by this method. Applying an {@link DiskCacheStrategy} other than
+   * {@link DiskCacheStrategy#NONE} after calling this method may result in undefined behavior.
    *
    * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not
    * compared.
@@ -362,6 +364,7 @@ protected RequestOptions getMutableOptions() {
    * @see #load(Object)
    */
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
     return loadGeneric(drawable)
         .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
@@ -386,6 +389,7 @@ protected RequestOptions getMutableOptions() {
    * @param string A file path, or a uri or url handled by
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
+  @Override
   @CheckResult
   public RequestBuilder<TranscodeType> load(@Nullable String string) {
     return loadGeneric(string);
@@ -410,6 +414,7 @@ protected RequestOptions getMutableOptions() {
    * {@link com.bumptech.glide.load.model.UriLoader}.
    */
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
     return loadGeneric(uri);
   }
@@ -417,7 +422,7 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a request builder to load the given {@link File}.
    *
-   * <p> Note - this method caches data for Files using only the file path itself as the cache key.
+   * <p>Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
    * expect the data in the File to change, Consider using
    * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
@@ -426,13 +431,13 @@ protected RequestOptions getMutableOptions() {
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
    * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
-   * </p>
    *
    * @see #load(Object)
    *
    * @param file The File containing the image
    */
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable File file) {
     return loadGeneric(file);
   }
@@ -470,6 +475,7 @@ protected RequestOptions getMutableOptions() {
    * @see com.bumptech.glide.signature.ApplicationVersionSignature
    */
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
     return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
   }
@@ -479,12 +485,13 @@ protected RequestOptions getMutableOptions() {
    *
    * @param url The URL representing the image.
    * @see #load(Object)
-   * @deprecated The {@link java.net.URL} class has <a href="http://goo.gl/c4hHNu">a number of
-   * performance problems</a> and should generally be avoided when possible. Prefer
-   * {@link #load(android.net.Uri)} or {@link #load(String)}.
+   * @deprecated The {@link java.net.URL} class has
+   * <a href="http://goo.gl/c4hHNu">a number of performance problems</a> and should generally be
+   * avoided when possible. Prefer {@link #load(android.net.Uri)} or {@link #load(String)}.
    */
   @Deprecated
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable URL url) {
     return loadGeneric(url);
   }
@@ -492,16 +499,22 @@ protected RequestOptions getMutableOptions() {
   /**
    * Returns a request to load the given byte array.
    *
-   * <p> Note - by default loads for bytes are not cached in either the memory or the disk cache.
-   * </p>
+   * <p>Note - by default loads for bytes are not cached in either the memory or the disk cache.
    *
    * @param model the data to load.
    * @see #load(Object)
    */
   @CheckResult
+  @Override
   public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {
-    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString()))
-        .diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(true /*skipMemoryCache*/));
+    RequestBuilder<TranscodeType> result = loadGeneric(model);
+    if (!result.requestOptions.isDiskCacheStrategySet()) {
+        result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
+    }
+    if (!result.requestOptions.isSkipMemoryCacheSet()) {
+      result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));
+    }
+    return result;
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 0475262f7..51f3a3ff4 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -7,6 +7,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.CheckResult;
@@ -30,6 +31,7 @@
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.Util;
 import java.io.File;
+import java.net.URL;
 
 /**
  * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity
@@ -43,7 +45,8 @@
  * @see Glide#with(android.support.v4.app.Fragment)
  * @see Glide#with(Context)
  */
-public class RequestManager implements LifecycleListener {
+public class RequestManager implements LifecycleListener,
+    ModelTypes<RequestBuilder<Drawable>> {
   private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
   private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
   private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
@@ -343,6 +346,98 @@ public void onDestroy() {
     return as(Drawable.class);
   }
 
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Bitmap)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
+    return asDrawable().load(bitmap);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Drawable)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
+    return asDrawable().load(drawable);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable String string) {
+    return asDrawable().load(string);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Uri)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Uri uri) {
+    return asDrawable().load(uri);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(File)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable File file) {
+    return asDrawable().load(file);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(Integer)}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable Integer resourceId) {
+    return asDrawable().load(resourceId);
+  }
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(URL).
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @SuppressWarnings("deprecation")
+  @CheckResult
+  @Override
+  @Deprecated
+  public RequestBuilder<Drawable> load(@Nullable URL url) {
+    return asDrawable().load(url);
+  }
+
+
+  /**
+   * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(byte[])}.
+   *
+   * @return A new request builder for loading a {@link Drawable} using the given model.
+   */
+  @CheckResult
+  @Override
+  public RequestBuilder<Drawable> load(@Nullable byte[] model) {
+    return asDrawable().load(model);
+  }
+
   /**
    * A helper method equivalent to calling {@link #asDrawable()} and then {@link
    * RequestBuilder#load(Object)} with the given model.
@@ -350,6 +445,7 @@ public void onDestroy() {
    * @return A new request builder for loading a {@link Drawable} using the given model.
    */
   @CheckResult
+  @Override
   public RequestBuilder<Drawable> load(@Nullable Object model) {
     return asDrawable().load(model);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
index a877d4760..364f84289 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java
@@ -163,11 +163,15 @@ public void delete(Key key) {
   public synchronized void clear() {
     try {
       getDiskCache().delete();
-      resetDiskCache();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
-        Log.w(TAG, "Unable to clear disk cache", e);
+        Log.w(TAG, "Unable to clear disk cache or disk cache cleared externally", e);
       }
+    } finally {
+      // Delete can close the cache but still throw. If we don't null out the disk cache here, every
+      // subsequent request will try to act on a closed disk cache and fail. By nulling out the disk
+      // cache we at least allow for attempts to open the cache in the future. See #2465.
+      resetDiskCache();
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 9f55c71c3..c0264e40b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -5,7 +5,7 @@
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.DataFetcher;
-import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.signature.ObjectKey;
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
@@ -27,10 +27,9 @@ public ByteArrayLoader(Converter<Data> converter) {
   }
 
   @Override
-  public LoadData<Data> buildLoadData(byte[] model, int width, int height,
-      Options options) {
-    // TODO: compare the actual bytes?
-    return new LoadData<>(EmptySignature.obtain(), new Fetcher<>(model, converter));
+  public LoadData<Data> buildLoadData(
+      byte[] model, int width, int height, Options options) {
+    return new LoadData<>(new ObjectKey(model), new Fetcher<>(model, converter));
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
index bcc996f34..e9b954c4a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java
@@ -4,7 +4,7 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -21,18 +21,28 @@
 
   private final ResourceDecoder<DataType, Bitmap> decoder;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
   // Public API.
-  @SuppressWarnings("unused")
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public BitmapDrawableDecoder(Context context, ResourceDecoder<DataType, Bitmap> decoder) {
-    this(context.getResources(), Glide.get(context).getBitmapPool(), decoder);
+    this(context.getResources(), decoder);
   }
 
-  public BitmapDrawableDecoder(Resources resources, BitmapPool bitmapPool,
+  /**
+   * @deprecated Use {@link #BitmapDrawableDecoder(Context, ResourceDecoder)}, {@code bitmapPool}
+   * is ignored.
+   */
+  @Deprecated
+  public BitmapDrawableDecoder(
+      Resources resources,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
       ResourceDecoder<DataType, Bitmap> decoder) {
+    this(resources, decoder);
+  }
+
+  public BitmapDrawableDecoder(
+      @NonNull Resources resources, @NonNull ResourceDecoder<DataType, Bitmap> decoder) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.decoder = Preconditions.checkNotNull(decoder);
   }
 
@@ -45,10 +55,6 @@ public boolean handles(DataType source, Options options) throws IOException {
   public Resource<BitmapDrawable> decode(DataType source, int width, int height, Options options)
       throws IOException {
     Resource<Bitmap> bitmapResource = decoder.decode(source, width, height, options);
-    if (bitmapResource == null) {
-      return null;
-    }
-
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, bitmapResource.get());
+    return LazyBitmapDrawableResource.obtain(resources, bitmapResource);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
index 54b7abc51..7fef9697e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java
@@ -63,15 +63,15 @@ public DrawableTransformation(Transformation<Bitmap> wrapped, boolean isRequired
       transformedBitmapResource.recycle();
       return resource;
     } else {
-      return newDrawableResource(context, transformedBitmapResource.get());
+      return newDrawableResource(context, transformedBitmapResource);
     }
   }
 
   @SuppressWarnings("unchecked")
   private Resource<Drawable> newDrawableResource(
-      Context context, Bitmap transformed) {
+      Context context, Resource<Bitmap> transformed) {
     Resource<? extends Drawable> result =
-        LazyBitmapDrawableResource.obtain(context, transformed);
+        LazyBitmapDrawableResource.obtain(context.getResources(), transformed);
     return (Resource<Drawable>) result;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index 0228f05db..42058fca8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -4,12 +4,13 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
 
 /**
  * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
@@ -18,23 +19,46 @@
 public final class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
     Initializable {
 
-  private final Bitmap bitmap;
   private final Resources resources;
-  private final BitmapPool bitmapPool;
+  private final Resource<Bitmap> bitmapResource;
 
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   * {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
   public static LazyBitmapDrawableResource obtain(Context context, Bitmap bitmap) {
-    return obtain(context.getResources(), Glide.get(context).getBitmapPool(), bitmap);
+    return
+        (LazyBitmapDrawableResource)
+            obtain(
+                context.getResources(),
+                BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));
   }
 
+  /**
+   * @deprecated Use {@link #obtain(Resources, Resource)} instead, it can be unsafe to extract
+   * {@link Bitmap}s from their wrapped {@link Resource}.
+   */
+  @Deprecated
   public static LazyBitmapDrawableResource obtain(Resources resources, BitmapPool bitmapPool,
       Bitmap bitmap) {
-    return new LazyBitmapDrawableResource(resources, bitmapPool, bitmap);
+    return
+        (LazyBitmapDrawableResource) obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));
   }
 
-  private LazyBitmapDrawableResource(Resources resources, BitmapPool bitmapPool, Bitmap bitmap) {
+  @Nullable
+  public static Resource<BitmapDrawable> obtain(
+      @NonNull Resources resources, @Nullable Resource<Bitmap> bitmapResource) {
+    if (bitmapResource == null) {
+      return null;
+    }
+    return new LazyBitmapDrawableResource(resources, bitmapResource);
+
+  }
+
+  private LazyBitmapDrawableResource(Resources resources, Resource<Bitmap> bitmapResource) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
-    this.bitmap = Preconditions.checkNotNull(bitmap);
+    this.bitmapResource = Preconditions.checkNotNull(bitmapResource);
   }
 
   @Override
@@ -44,21 +68,23 @@ private LazyBitmapDrawableResource(Resources resources, BitmapPool bitmapPool, B
 
   @Override
   public BitmapDrawable get() {
-    return new BitmapDrawable(resources, bitmap);
+    return new BitmapDrawable(resources, bitmapResource.get());
   }
 
   @Override
   public int getSize() {
-    return Util.getBitmapByteSize(bitmap);
+    return bitmapResource.getSize();
   }
 
   @Override
   public void recycle() {
-    bitmapPool.put(bitmap);
+    bitmapResource.recycle();
   }
 
   @Override
   public void initialize() {
-    bitmap.prepareToDraw();
+    if (bitmapResource instanceof Initializable) {
+      ((Initializable) bitmapResource).initialize();
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
index 57e28337e..2b91d2081 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java
@@ -4,7 +4,7 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.util.Util;
 import java.io.IOException;
 
 /**
@@ -12,7 +12,6 @@
  * so that the given {@link Bitmap} is not recycled.
  */
 public final class UnitBitmapDecoder implements ResourceDecoder<Bitmap, Bitmap> {
-  private static final BitmapPoolAdapter BITMAP_POOL = new BitmapPoolAdapter();
 
   @Override
   public boolean handles(Bitmap source, Options options) throws IOException {
@@ -22,6 +21,35 @@ public boolean handles(Bitmap source, Options options) throws IOException {
   @Override
   public Resource<Bitmap> decode(Bitmap source, int width, int height, Options options)
       throws IOException {
-    return new BitmapResource(source, BITMAP_POOL);
+    return new NonOwnedBitmapResource(source);
+  }
+
+  private static final class NonOwnedBitmapResource implements Resource<Bitmap> {
+
+    private final Bitmap bitmap;
+
+    NonOwnedBitmapResource(Bitmap bitmap) {
+      this.bitmap = bitmap;
+    }
+
+    @Override
+    public Class<Bitmap> getResourceClass() {
+      return Bitmap.class;
+    }
+
+    @Override
+    public Bitmap get() {
+      return bitmap;
+    }
+
+    @Override
+    public int getSize() {
+      return Util.getBitmapByteSize(bitmap);
+    }
+
+    @Override
+    public void recycle() {
+      // Do nothing.
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
index 789d5d925..616976a6c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
@@ -10,7 +10,7 @@
 final class NonOwnedDrawableResource extends DrawableResource<Drawable> {
 
   @SuppressWarnings("unchecked")
-  public static Resource<Drawable> newInstance(Drawable drawable) {
+  static Resource<Drawable> newInstance(Drawable drawable) {
     return new NonOwnedDrawableResource(drawable);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
index 12b6b79d3..a5a61ead9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java
@@ -4,7 +4,7 @@
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
-import com.bumptech.glide.Glide;
+import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -17,21 +17,28 @@
  */
 public class BitmapDrawableTranscoder implements ResourceTranscoder<Bitmap, BitmapDrawable> {
   private final Resources resources;
-  private final BitmapPool bitmapPool;
 
   // Public API.
   @SuppressWarnings("unused")
-  public BitmapDrawableTranscoder(Context context) {
-    this(context.getResources(), Glide.get(context).getBitmapPool());
+  public BitmapDrawableTranscoder(@NonNull Context context) {
+    this(context.getResources());
   }
 
-  public BitmapDrawableTranscoder(Resources resources, BitmapPool bitmapPool) {
+  /**
+   * @deprecated Use {@link #BitmapDrawableTranscoder(Resources)}, {@code bitmapPool} is unused.
+   */
+  @Deprecated
+  public BitmapDrawableTranscoder(
+      @NonNull Resources resources, @SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this(resources);
+  }
+
+  public BitmapDrawableTranscoder(@NonNull Resources resources) {
     this.resources = Preconditions.checkNotNull(resources);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
   }
 
   @Override
   public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {
-    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, toTranscode.get());
+    return LazyBitmapDrawableResource.obtain(resources, toTranscode);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index e4e60f361..3f0e2cb0d 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -1455,6 +1455,14 @@ protected boolean isAutoCloneEnabled() {
     return isAutoCloneEnabled;
   }
 
+  public final boolean isDiskCacheStrategySet() {
+    return isSet(DISK_CACHE_STRATEGY);
+  }
+
+  public final boolean isSkipMemoryCacheSet() {
+    return isSet(IS_CACHEABLE);
+  }
+
   @NonNull
   public final Map<Class<?>, Transformation<?>> getTransformations() {
     return transformations;
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index 64d8df110..f85f1692f 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -98,6 +98,8 @@
     GlideTest.MutableShadowBitmap.class })
 @SuppressWarnings("unchecked")
 public class GlideTest {
+  // Fixes method overload confusion.
+  private static final Object NULL = null;
 
   @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
 
@@ -276,6 +278,7 @@ private void runTestFileDefaultLoader() {
     assertNotNull(imageView.getDrawable());
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   public void testUrlDefaultLoader() throws MalformedURLException {
     URL url = new URL("http://www.google.com");
@@ -573,24 +576,24 @@ public void testReceivesRecursiveThumbnailWithPercentage() {
 
   @Test
   public void testNullModelInGenericImageLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericVideoLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelInGenericLoadDoesNotThrow() {
-    requestManager.load(null).into(target);
+    requestManager.load(NULL).into(target);
   }
 
   @Test
   public void testNullModelDoesNotThrow() {
     Drawable drawable = new ColorDrawable(Color.RED);
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(errorOf(drawable))
         .into(target);
 
@@ -603,7 +606,7 @@ public void testNullModelPrefersErrorDrawable() {
     Drawable error = new ColorDrawable(Color.RED);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder)
             .error(error))
         .into(target);
@@ -652,7 +655,7 @@ public void testNullModelPrefersFallbackDrawable() {
     Drawable fallback = new ColorDrawable(Color.BLUE);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder)
             .error(error)
             .fallback(fallback))
@@ -666,7 +669,7 @@ public void testNullModelResolvesToUsePlaceholder() {
     Drawable placeholder = new ColorDrawable(Color.GREEN);
 
     requestManager
-        .load(null)
+        .load(NULL)
         .apply(placeholderOf(placeholder))
         .into(target);
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index de91ea572..cb60eae94 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -3,7 +3,9 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
 
+import com.bumptech.glide.load.Key;
 import com.bumptech.glide.signature.ObjectKey;
 import com.bumptech.glide.tests.Util;
 import java.io.File;
@@ -41,21 +43,17 @@ public void tearDown() {
     }
   }
 
-  private void deleteRecursive(File file) {
-    if (!file.isDirectory()) {
-      if (!file.delete()) {
-        throw new IllegalStateException("Failed to delete: " + file);
+  private static void deleteRecursive(File file) {
+    if (file.isDirectory()) {
+      File[] files = file.listFiles();
+      if (files != null) {
+        for (File f : files) {
+          deleteRecursive(f);
+        }
       }
-      return;
-    }
-
-    File[] files = file.listFiles();
-    if (files == null) {
-      return;
     }
-
-    for (File child : files) {
-      deleteRecursive(child);
+    if (!file.delete() && file.exists()) {
+      throw new RuntimeException("Failed to delete: " + file);
     }
   }
 
@@ -136,4 +134,24 @@ public boolean write(File file) {
 
     assertArrayEquals(data, received);
   }
+
+  // Tests #2465.
+  @Test
+  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+  }
+
+  // Tests #2465.
+  @Test
+  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {
+    DiskCache cache = DiskLruCacheWrapper.create(dir, 1024 * 1024);
+    cache.get(mock(Key.class));
+    deleteRecursive(dir);
+    cache.clear();
+
+    cache.get(mock(Key.class));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
new file mode 100644
index 000000000..1ad62cac2
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResourceTest.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.load.engine.Initializable;
+import com.bumptech.glide.load.engine.Resource;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class LazyBitmapDrawableResourceTest {
+  @Mock private Resource<Bitmap> bitmapResource;
+  private LazyBitmapDrawableResource resource;
+  private Resources resources;
+  private Bitmap bitmap;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+
+    bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(bitmapResource.get()).thenReturn(bitmap);
+
+    resources = RuntimeEnvironment.application.getResources();
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+  }
+
+  @Test
+  public void obtain_withNullBitmapResource_returnsNull() {
+    assertThat(LazyBitmapDrawableResource.obtain(resources, null)).isNull();
+  }
+
+  @Test
+  public void getSize_returnsSizeOfWrappedResource() {
+    when(bitmapResource.getSize()).thenReturn(100);
+    assertThat(resource.getSize()).isEqualTo(100);
+  }
+
+  @Test
+  public void recycle_callsRecycleOnWrappedResource() {
+    resource.recycle();
+    verify(bitmapResource).recycle();
+  }
+
+  @Test
+  public void recycle_doesNotRecycleWrappedBitmap() {
+    resource.recycle();
+    assertThat(bitmap.isRecycled()).isFalse();
+  }
+
+  @Test
+  public void get_returnsDrawableContainingWrappedBitmap() {
+    BitmapDrawable drawable = resource.get();
+    assertThat(drawable.getBitmap()).isSameAs(bitmap);
+  }
+
+  @Test
+  public void initialize_withNonInitializableResource_doesNothing() {
+    resource.initialize();
+  }
+
+  @Test
+  public void initialize_withWrappedInitializableResource_callsInitializeOnWrapped() {
+    InitializableBitmapResource bitmapResource = mock(InitializableBitmapResource.class);
+    resource =
+        (LazyBitmapDrawableResource) LazyBitmapDrawableResource.obtain(resources, bitmapResource);
+    resource.initialize();
+
+    verify(bitmapResource).initialize();
+  }
+
+  private interface InitializableBitmapResource extends Initializable,
+      Resource<Bitmap> {
+    // Intentionally empty.
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
index 0707a342a..b3c195657 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java
@@ -2,14 +2,12 @@
 
 import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,8 +22,7 @@
 
   @Before
   public void setUp() {
-    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources(),
-        mock(BitmapPool.class));
+    transcoder = new BitmapDrawableTranscoder(RuntimeEnvironment.application.getResources());
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
index e14ad311e..aa61bc883 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -262,6 +262,38 @@ public void testApplyMultiTransform() {
       .isInstanceOf(MultiTransformation.class);
   }
 
+  @Test
+  public void isSkipMemoryCacheSet_withoutSkipMemoryCache_isFalse() {
+    assertThat(options.isSkipMemoryCacheSet()).isFalse();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheTrue_isTrue() {
+    assertThat(options.skipMemoryCache(true).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isSkipMemoryCacheSet_withSkipMemoryCacheFalse_isTrue() {
+    assertThat(options.skipMemoryCache(false).isSkipMemoryCacheSet()).isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withoutDiskCacheStrategy_isFalse() {
+    assertThat(options.isDiskCacheStrategySet()).isFalse();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).isDiskCacheStrategySet())
+        .isTrue();
+  }
+
+  @Test
+  public void isDiskCacheStrategySet_withDiskCacheStrategyNonDefault_isTrue() {
+    assertThat(options.diskCacheStrategy(DiskCacheStrategy.ALL).isDiskCacheStrategySet())
+        .isTrue();
+  }
+
   @Test
   public void testEqualsHashCode() {
     Drawable first = new ColorDrawable(Color.RED);
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
index 5bd0ab543..4be16ad5b 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java
@@ -6,7 +6,6 @@
 import com.bumptech.glide.load.resource.SimpleResource;
 import com.caverock.androidsvg.SVG;
 import com.caverock.androidsvg.SVGParseException;
-
 import java.io.IOException;
 import java.io.InputStream;
 
