diff --git a/gradle.properties b/gradle.properties
index 8058bbb2e..dc490ff17 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -43,7 +43,7 @@ ERROR_PRONE_PLUGIN_VERSION=0.0.13
 VIOLATIONS_PLUGIN_VERSION=1.8
 
 COMPILE_SDK_VERSION=28
-TARGET_SDK_VERSION=27
+TARGET_SDK_VERSION=28
 MIN_SDK_VERSION=14
 
 org.gradle.jvmargs=-Xmx4096M
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
index 463dd6a87..deaceae8c 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerEmulatorTest.java
@@ -28,6 +28,7 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.util.Preconditions;
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
@@ -121,6 +122,9 @@ public void calculateScaling_withAtMost() throws IOException {
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
         .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
         .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        // Original scaling
+        .setTargetDimensions(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)
+        .givenImageWithDimensionsOf(1821, 2634, onAllApisAndAllFormatsExpect(1821, 2634))
         .run();
   }
 
@@ -144,6 +148,9 @@ public void calculateScaling_withAtLeast() throws IOException {
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
         .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
         .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        // Original scaling
+        .setTargetDimensions(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)
+        .givenImageWithDimensionsOf(1821, 2634, onAllApisAndAllFormatsExpect(1821, 2634))
         .run();
   }
 
@@ -207,6 +214,9 @@ public void calculateScaling_withCenterInside() throws IOException {
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
         .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
         .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        // Original scaling
+        .setTargetDimensions(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)
+        .givenImageWithDimensionsOf(1821, 2634, onAllApisAndAllFormatsExpect(1821, 2634))
         .run();
   }
 
@@ -253,6 +263,9 @@ public void calculateScaling_withCenterOutside() throws IOException {
             450,
             atAndAbove(KITKAT).with(allFormats().expect(500, 1125)),
             below(KITKAT).with(allFormats().expect(200, 450)))
+        // Original scaling
+        .setTargetDimensions(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)
+        .givenImageWithDimensionsOf(1821, 2634, onAllApisAndAllFormatsExpect(1821, 2634))
         .run();
   }
 
@@ -276,6 +289,9 @@ public void calculateScaling_withNone() throws IOException {
         .givenSquareImageWithDimensionOf(200, onAllApisAndAllFormatsExpect(200, 200))
         .givenSquareImageWithDimensionOf(450, onAllApisAndAllFormatsExpect(450, 450))
         .givenImageWithDimensionsOf(200, 450, onAllApisAndAllFormatsExpect(200, 450))
+        // Original scaling
+        .setTargetDimensions(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)
+        .givenImageWithDimensionsOf(1821, 2634, onAllApisAndAllFormatsExpect(1821, 2634))
         .run();
   }
 
@@ -386,6 +402,9 @@ public void calculateScaling_withFitCenter() throws IOException {
             450,
             atAndAbove(KITKAT).with(allFormats().expect(222, 500)),
             below(KITKAT).with(allFormats().expect(200, 450)))
+        // Original scaling
+        .setTargetDimensions(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)
+        .givenImageWithDimensionsOf(1821, 2634, onAllApisAndAllFormatsExpect(1821, 2634))
         .run();
   }
 
diff --git a/integration/concurrent/build.gradle b/integration/concurrent/build.gradle
index a7f0ef332..0eb493878 100644
--- a/integration/concurrent/build.gradle
+++ b/integration/concurrent/build.gradle
@@ -5,10 +5,12 @@ dependencies {
     implementation "com.google.guava:guava:${GUAVA_VERSION}"
     implementation "androidx.concurrent:concurrent-futures:${ANDROID_X_FUTURES_VERSION}"
 
+    testImplementation project(':mocks')
+    testImplementation "androidx.legacy:legacy-support-v4:${ANDROID_X_VERSION}"
+    testImplementation "androidx.test:core:${ANDROIDX_TEST_VERSION}"
     testImplementation "com.google.truth:truth:${TRUTH_VERSION}"
     testImplementation "junit:junit:${JUNIT_VERSION}"
     testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testImplementation "androidx.legacy:legacy-support-v4:${ANDROID_X_VERSION}"
 }
 
 android {
diff --git a/integration/concurrent/src/test/java/com/bumptech/glide/integration/concurrent/GlideFuturesTest.java b/integration/concurrent/src/test/java/com/bumptech/glide/integration/concurrent/GlideFuturesTest.java
new file mode 100644
index 000000000..4c0eb8911
--- /dev/null
+++ b/integration/concurrent/src/test/java/com/bumptech/glide/integration/concurrent/GlideFuturesTest.java
@@ -0,0 +1,65 @@
+package com.bumptech.glide.integration.concurrent;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertThrows;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import androidx.test.core.app.ApplicationProvider;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+@RunWith(RobolectricTestRunner.class)
+public final class GlideFuturesTest {
+
+  private Context app;
+
+  @Before
+  public void setUp() {
+    app = ApplicationProvider.getApplicationContext();
+
+    GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
+    Glide.init(
+        app,
+        new GlideBuilder()
+            .setAnimationExecutor(executor)
+            .setSourceExecutor(executor)
+            .setDiskCacheExecutor(executor));
+  }
+
+  @Test
+  public void testBaseLoad() throws Exception {
+    ColorDrawable expected = new ColorDrawable(Color.RED);
+    ListenableFuture<Drawable> future = GlideFutures.submit(Glide.with(app).load(expected));
+    assertThat(((ColorDrawable) Futures.getDone(future)).getColor()).isEqualTo(expected.getColor());
+  }
+
+  @Test
+  public void testErrorLoad() {
+    // Load some unsupported model.
+    final ListenableFuture<Bitmap> future =
+        GlideFutures.submit(Glide.with(app).asBitmap().load(app));
+    // Make sure that it throws.
+    assertThrows(
+        ExecutionException.class,
+        new ThrowingRunnable() {
+          @Override
+          public void run() throws Throwable {
+            Futures.getDone(future);
+          }
+        });
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index da1a99a37..6237d2cd7 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -2,7 +2,9 @@
 
 import android.os.StrictMode;
 import android.os.StrictMode.ThreadPolicy;
+import android.text.TextUtils;
 import android.util.Log;
+import androidx.annotation.IntRange;
 import androidx.annotation.NonNull;
 import androidx.annotation.VisibleForTesting;
 import com.bumptech.glide.util.Synthetic;
@@ -45,9 +47,9 @@
    * The default thread name prefix for executors from unlimited thread pool used to
    * load/decode/transform data not found in cache.
    */
-  private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
+  private static final String DEFAULT_SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
 
-  private static final String ANIMATION_EXECUTOR_NAME = "animation";
+  private static final String DEFAULT_ANIMATION_EXECUTOR_NAME = "animation";
 
   /** The default keep alive time for threads in our cached thread pools in milliseconds. */
   private static final long KEEP_ALIVE_TIME_MS = TimeUnit.SECONDS.toMillis(10);
@@ -62,72 +64,50 @@
   private final ExecutorService delegate;
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from {@link
-   * #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name prefix,
-   * and the {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * Returns a new {@link Builder} with the {@link #DEFAULT_DISK_CACHE_EXECUTOR_THREADS} threads,
+   * {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} name and {@link UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy.
    *
    * <p>Disk cache executors do not allow network operations on their threads.
    */
+  public static GlideExecutor.Builder newDiskCacheBuilder() {
+    return new GlideExecutor.Builder(/*preventNetworkOperations=*/ true)
+        .setThreadCount(DEFAULT_DISK_CACHE_EXECUTOR_THREADS)
+        .setName(DEFAULT_DISK_CACHE_EXECUTOR_NAME);
+  }
+
+  /** Shortcut for calling {@link Builder#build()} on {@link #newDiskCacheBuilder()}. */
   public static GlideExecutor newDiskCacheExecutor() {
-    return newDiskCacheExecutor(
-        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
-        UncaughtThrowableStrategy.DEFAULT);
+    return newDiskCacheBuilder().build();
   }
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from {@link
-   * #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name prefix,
-   * and a custom {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} uncaught
-   * throwable strategy.
-   *
-   * <p>Disk cache executors do not allow network operations on their threads.
-   *
-   * @param uncaughtThrowableStrategy The {@link
-   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *     handle uncaught exceptions.
+   * @deprecated Use {@link #newDiskCacheBuilder()} and {@link
+   *     Builder#setUncaughtThrowableStrategy(UncaughtThrowableStrategy)} instead.
    */
   // Public API.
   @SuppressWarnings("unused")
+  @Deprecated
   public static GlideExecutor newDiskCacheExecutor(
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return newDiskCacheExecutor(
-        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
-        DEFAULT_DISK_CACHE_EXECUTOR_NAME,
-        uncaughtThrowableStrategy);
+    return newDiskCacheBuilder().setUncaughtThrowableStrategy(uncaughtThrowableStrategy).build();
   }
 
-  /**
-   * Returns a new fixed thread pool with the given thread count, thread name prefix, and {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
-   *
-   * <p>Disk cache executors do not allow network operations on their threads.
-   *
-   * @param threadCount The number of threads.
-   * @param name The prefix for each thread name.
-   * @param uncaughtThrowableStrategy The {@link
-   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *     handle uncaught exceptions.
-   */
+  /** @deprecated Use {@link #newDiskCacheBuilder()} instead. */
   // Public API.
   @SuppressWarnings("WeakerAccess")
+  @Deprecated
   public static GlideExecutor newDiskCacheExecutor(
       int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(
-        new ThreadPoolExecutor(
-            threadCount /* corePoolSize */,
-            threadCount /* maximumPoolSize */,
-            0 /* keepAliveTime */,
-            TimeUnit.MILLISECONDS,
-            new PriorityBlockingQueue<Runnable>(),
-            new DefaultThreadFactory(name, uncaughtThrowableStrategy, true)));
+    return newDiskCacheBuilder()
+        .setThreadCount(threadCount)
+        .setName(name)
+        .setUncaughtThrowableStrategy(uncaughtThrowableStrategy)
+        .build();
   }
 
   /**
-   * Returns a new fixed thread pool with the default thread count returned from {@link
+   * Returns a new {@link Builder} with the default thread count returned from {@link
    * #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name prefix, and
    * the {@link
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
@@ -135,58 +115,37 @@ public static GlideExecutor newDiskCacheExecutor(
    *
    * <p>Source executors allow network operations on their threads.
    */
+  public static GlideExecutor.Builder newSourceBuilder() {
+    return new GlideExecutor.Builder(/*preventNetworkOperations=*/ false)
+        .setThreadCount(calculateBestThreadCount())
+        .setName(DEFAULT_SOURCE_EXECUTOR_NAME);
+  }
+
+  /** Shortcut for calling {@link Builder#build()} on {@link #newSourceBuilder()}. */
   public static GlideExecutor newSourceExecutor() {
-    return newSourceExecutor(
-        calculateBestThreadCount(),
-        DEFAULT_SOURCE_EXECUTOR_NAME,
-        UncaughtThrowableStrategy.DEFAULT);
+    return newSourceBuilder().build();
   }
 
-  /**
-   * Returns a new fixed thread pool with the default thread count returned from {@link
-   * #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name prefix, and
-   * a custom {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} uncaught
-   * throwable strategy.
-   *
-   * <p>Source executors allow network operations on their threads.
-   *
-   * @param uncaughtThrowableStrategy The {@link
-   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *     handle uncaught exceptions.
-   */
+  /** @deprecated Use {@link #newSourceBuilder()} instead. */
   // Public API.
   @SuppressWarnings("unused")
+  @Deprecated
   public static GlideExecutor newSourceExecutor(
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return newSourceExecutor(
-        calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME, uncaughtThrowableStrategy);
+    return newSourceBuilder().setUncaughtThrowableStrategy(uncaughtThrowableStrategy).build();
   }
 
-  /**
-   * Returns a new fixed thread pool with the given thread count, thread name prefix, and {@link
-   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
-   *
-   * <p>Source executors allow network operations on their threads.
-   *
-   * @param threadCount The number of threads.
-   * @param name The prefix for each thread name.
-   * @param uncaughtThrowableStrategy The {@link
-   *     com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
-   *     handle uncaught exceptions.
-   */
+  /** @deprecated Use {@link #newSourceBuilder()} instead. */
   // Public API.
   @SuppressWarnings("WeakerAccess")
+  @Deprecated
   public static GlideExecutor newSourceExecutor(
       int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(
-        new ThreadPoolExecutor(
-            threadCount /* corePoolSize */,
-            threadCount /* maximumPoolSize */,
-            0 /* keepAliveTime */,
-            TimeUnit.MILLISECONDS,
-            new PriorityBlockingQueue<Runnable>(),
-            new DefaultThreadFactory(name, uncaughtThrowableStrategy, false)));
+    return newSourceBuilder()
+        .setThreadCount(threadCount)
+        .setName(name)
+        .setUncaughtThrowableStrategy(uncaughtThrowableStrategy)
+        .build();
   }
 
   /**
@@ -211,14 +170,16 @@ public static GlideExecutor newUnlimitedSourceExecutor() {
             TimeUnit.MILLISECONDS,
             new SynchronousQueue<Runnable>(),
             new DefaultThreadFactory(
-                SOURCE_UNLIMITED_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT, false)));
+                DEFAULT_SOURCE_UNLIMITED_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT, false)));
   }
 
   /**
    * Returns a new fixed thread pool that defaults to either one or two threads depending on the
    * number of available cores to use when loading frames of animations.
+   *
+   * <p>Animation executors do not allow network operations on their threads.
    */
-  public static GlideExecutor newAnimationExecutor() {
+  public static GlideExecutor.Builder newAnimationBuilder() {
     int bestThreadCount = calculateBestThreadCount();
     // We don't want to add a ton of threads running animations in parallel with our source and
     // disk cache executors. Doing so adds unnecessary CPU load and can also dramatically increase
@@ -227,25 +188,26 @@ public static GlideExecutor newAnimationExecutor() {
     // once.
     int maximumPoolSize = bestThreadCount >= 4 ? 2 : 1;
 
-    return newAnimationExecutor(maximumPoolSize, UncaughtThrowableStrategy.DEFAULT);
+    return new GlideExecutor.Builder(/*preventNetworkOperations=*/ true)
+        .setThreadCount(maximumPoolSize)
+        .setName(DEFAULT_ANIMATION_EXECUTOR_NAME);
   }
 
-  /**
-   * Returns a new fixed thread pool with the given thread count and {@link
-   * UncaughtThrowableStrategy} to use when loading frames of animations.
-   */
+  /** Shortcut for calling {@link Builder#build()} on {@link #newAnimationBuilder()}. */
+  public static GlideExecutor newAnimationExecutor() {
+    return newAnimationBuilder().build();
+  }
+
+  /** @deprecated Use {@link #newAnimationBuilder()} instead. */
   // Public API.
   @SuppressWarnings("WeakerAccess")
+  @Deprecated
   public static GlideExecutor newAnimationExecutor(
       int threadCount, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    return new GlideExecutor(
-        new ThreadPoolExecutor(
-            threadCount,
-            threadCount,
-            0,
-            TimeUnit.MILLISECONDS,
-            new PriorityBlockingQueue<Runnable>(),
-            new DefaultThreadFactory(ANIMATION_EXECUTOR_NAME, uncaughtThrowableStrategy, true)));
+    return newAnimationBuilder()
+        .setThreadCount(threadCount)
+        .setUncaughtThrowableStrategy(uncaughtThrowableStrategy)
+        .build();
   }
 
   @VisibleForTesting
@@ -438,4 +400,87 @@ public void run() {
       return result;
     }
   }
+
+  /** A builder for {@link GlideExecutor}s. */
+  public static final class Builder {
+    /**
+     * Prevents core and non-core threads from timing out ever if provided to {@link
+     * #setThreadTimeoutMillis(long)}.
+     */
+    public static final long NO_THREAD_TIMEOUT = 0L;
+
+    private final boolean preventNetworkOperations;
+
+    private int corePoolSize;
+    private int maximumPoolSize;
+
+    @NonNull
+    private UncaughtThrowableStrategy uncaughtThrowableStrategy = UncaughtThrowableStrategy.DEFAULT;
+
+    private String name;
+    private long threadTimeoutMillis;
+
+    @Synthetic
+    Builder(boolean preventNetworkOperations) {
+      this.preventNetworkOperations = preventNetworkOperations;
+    }
+
+    /**
+     * Allows both core and non-core threads in the executor to be terminated if no tasks arrive for
+     * at least the given timeout milliseconds.
+     *
+     * <p>Use {@link #NO_THREAD_TIMEOUT} to remove a previously set timeout.
+     */
+    public Builder setThreadTimeoutMillis(long threadTimeoutMillis) {
+      this.threadTimeoutMillis = threadTimeoutMillis;
+      return this;
+    }
+
+    /** Sets the maximum number of threads to use. */
+    public Builder setThreadCount(@IntRange(from = 1) int threadCount) {
+      corePoolSize = threadCount;
+      maximumPoolSize = threadCount;
+      return this;
+    }
+
+    /**
+     * Sets the {@link UncaughtThrowableStrategy} to use for unexpected exceptions thrown by tasks
+     * on {@link GlideExecutor}s built by this {@code Builder}.
+     */
+    public Builder setUncaughtThrowableStrategy(@NonNull UncaughtThrowableStrategy strategy) {
+      this.uncaughtThrowableStrategy = strategy;
+      return this;
+    }
+
+    /**
+     * Sets the prefix to use for each thread name created by any {@link GlideExecutor}s built by
+     * this {@code Builder}.
+     */
+    public Builder setName(String name) {
+      this.name = name;
+      return this;
+    }
+
+    /** Builds a new {@link GlideExecutor} with any previously specified options. */
+    public GlideExecutor build() {
+      if (TextUtils.isEmpty(name)) {
+        throw new IllegalArgumentException(
+            "Name must be non-null and non-empty, but given: " + name);
+      }
+      ThreadPoolExecutor executor =
+          new ThreadPoolExecutor(
+              corePoolSize,
+              maximumPoolSize,
+              /*keepAliveTime=*/ threadTimeoutMillis,
+              TimeUnit.MILLISECONDS,
+              new PriorityBlockingQueue<Runnable>(),
+              new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
+
+      if (threadTimeoutMillis != NO_THREAD_TIMEOUT) {
+        executor.allowCoreThreadTimeOut(true);
+      }
+
+      return new GlideExecutor(executor);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index c5ff4959e..98a1e4647 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -270,8 +270,14 @@ private Bitmap decodeFromWrappedStreams(
     int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
     boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);
 
-    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
-    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
+    int targetWidth =
+        requestedWidth == Target.SIZE_ORIGINAL
+            ? (isRotationRequired(degreesToRotate) ? sourceHeight : sourceWidth)
+            : requestedWidth;
+    int targetHeight =
+        requestedHeight == Target.SIZE_ORIGINAL
+            ? (isRotationRequired(degreesToRotate) ? sourceWidth : sourceHeight)
+            : requestedHeight;
 
     ImageType imageType = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
 
@@ -422,7 +428,7 @@ private static void calculateScaling(
     // width is decreased to near our target's height and the image height is decreased to near
     // our target width.
     //noinspection SuspiciousNameCombination
-    if (degreesToRotate == 90 || degreesToRotate == 270) {
+    if (isRotationRequired(degreesToRotate)) {
       orientedSourceWidth = sourceHeight;
       orientedSourceHeight = sourceWidth;
     }
@@ -906,4 +912,8 @@ private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
 
     void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException;
   }
+
+  private static boolean isRotationRequired(int degreesToRotate) {
+    return degreesToRotate == 90 || degreesToRotate == 270;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index c84cb83ff..8764ba3d6 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -194,7 +194,7 @@ public int read() {
       if (!byteBuffer.hasRemaining()) {
         return -1;
       }
-      return byteBuffer.get();
+      return byteBuffer.get() & 0xFF;
     }
 
     @Override
