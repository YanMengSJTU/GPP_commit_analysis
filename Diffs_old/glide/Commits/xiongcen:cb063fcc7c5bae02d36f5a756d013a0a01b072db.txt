diff --git a/.gitmodules b/.gitmodules
index 525eef67a..2a0e578c9 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -7,6 +7,3 @@
 [submodule "library/src/androidTest/resources/exif-orientation-examples"]
 	path = library/src/androidTest/resources/exif-orientation-examples
 	url = https://github.com/recurser/exif-orientation-examples.git
-[submodule "library/src/test/resources/exif-orientation-examples"]
-	path = library/src/test/resources/exif-orientation-examples
-	url = https://github.com/recurser/exif-orientation-examples
diff --git a/build.gradle b/build.gradle
index 8cf588b7e..d43db5fc8 100644
--- a/build.gradle
+++ b/build.gradle
@@ -7,7 +7,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.2.1'
+        classpath 'com.android.tools.build:gradle:2.2.3'
         classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}"
     }
 }
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
deleted file mode 100644
index 27e7be7c6..000000000
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ /dev/null
@@ -1,333 +0,0 @@
-package com.bumptech.glide.integration.gifencoder;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assume.assumeTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.graphics.Bitmap;
-import com.bumptech.glide.gifdecoder.GifDecoder;
-import com.bumptech.glide.gifdecoder.GifHeader;
-import com.bumptech.glide.gifdecoder.GifHeaderParser;
-import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
-import com.bumptech.glide.load.EncodeStrategy;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.Resource;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.util.ByteBufferUtil;
-import java.io.File;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.nio.ByteBuffer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-/**
- * Tests for {@link com.bumptech.glide.integration.gifencoder.ReEncodingGifResourceEncoder}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ReEncodingGifResourceEncoderTest {
-  @Mock Resource<GifDrawable> resource;
-  @Mock GifDecoder decoder;
-  @Mock GifHeaderParser parser;
-  @Mock AnimatedGifEncoder gifEncoder;
-  @Mock Resource<Bitmap> frameResource;
-  @Mock GifDrawable gifDrawable;
-  @Mock Transformation<Bitmap> frameTransformation;
-  @Mock Resource<Bitmap> transformedResource;
-
-  private ReEncodingGifResourceEncoder encoder;
-  private Options options;
-  private File file;
-
-  @SuppressWarnings("unchecked")
-  @Before
-  public void setUp() {
-    MockitoAnnotations.initMocks(this);
-
-    ReEncodingGifResourceEncoder.Factory factory = mock(ReEncodingGifResourceEncoder.Factory.class);
-    when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
-    when(factory.buildParser()).thenReturn(parser);
-    when(factory.buildEncoder()).thenReturn(gifEncoder);
-    when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class)))
-        .thenReturn(frameResource);
-
-    // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!)
-    when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt()))
-        .thenReturn(frameResource);
-
-    when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
-    when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.allocate(0));
-
-    when(resource.get()).thenReturn(gifDrawable);
-
-    encoder = new ReEncodingGifResourceEncoder(mock(BitmapPool.class), factory);
-    options = new Options();
-    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, true);
-
-    file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
-  }
-
-  @After
-  public void tearDown() {
-    if (file.exists() && !file.delete()) {
-      throw new RuntimeException("Failed to delete file");
-    }
-  }
-
-  @Test
-  public void testEncodeStrategy_withEncodeTransformationTrue_returnsTransformed() {
-    assertThat(encoder.getEncodeStrategy(options)).isEqualTo(EncodeStrategy.TRANSFORMED);
-  }
-
-  @Test
-  public void testEncodeStrategy_withEncodeTransformationUnSet_returnsSource() {
-    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, null);
-    assertThat(encoder.getEncodeStrategy(options)).isEqualTo(EncodeStrategy.SOURCE);
-  }
-
-  @Test
-  public void testEncodeStrategy_withEncodeTransformationFalse_returnsSource() {
-    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
-    assertThat(encoder.getEncodeStrategy(options)).isEqualTo(EncodeStrategy.SOURCE);
-  }
-
-  @Test
-  public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
-      throws IOException {
-    // Most likely an instance of http://stackoverflow.com/q/991489/253468
-    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
-    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
-    String expected = "testString";
-    byte[] data = expected.getBytes("UTF-8");
-    when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(data));
-
-    assertTrue(encoder.encode(resource, file, options));
-    assertThat(getEncodedData()).isEqualTo(expected);
-  }
-
-  @Test
-  public void testEncode_WithEncodeTransformationFalse_whenOsThrows_returnsFalse()
-      throws IOException {
-
-    options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
-    byte[] data = "testString".getBytes("UTF-8");
-    when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(data));
-
-    assertThat(file.mkdirs()).isTrue();
-
-    assertFalse(encoder.encode(resource, file, options));
-  }
-
-  @Test
-  public void testReturnsFalseIfEncoderFailsToStart() {
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(false);
-    assertFalse(encoder.encode(resource, file, options));
-  }
-
-  @Test
-  public void testSetsDataOnParserBeforeParsingHeader() {
-    ByteBuffer data = ByteBuffer.allocate(1);
-    when(gifDrawable.getBuffer()).thenReturn(data);
-
-    GifHeader header = mock(GifHeader.class);
-    when(parser.parseHeader()).thenReturn(header);
-
-    encoder.encode(resource, file, options);
-
-    InOrder order = inOrder(parser, decoder);
-    order.verify(parser).setData(eq(data));
-    order.verify(parser).parseHeader();
-    order.verify(decoder).setData(header, data);
-  }
-
-  @Test
-  public void testAdvancesDecoderBeforeAttemptingToGetFirstFrame() {
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-    when(decoder.getFrameCount()).thenReturn(1);
-    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
-
-    encoder.encode(resource, file, options);
-
-    InOrder order = inOrder(decoder);
-    order.verify(decoder).advance();
-    order.verify(decoder).getNextFrame();
-  }
-
-  @Test
-  public void testSetsDelayOnEncoderAfterAddingFrame() {
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-    when(gifEncoder.addFrame(any(Bitmap.class))).thenReturn(true);
-
-    when(decoder.getFrameCount()).thenReturn(1);
-    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));
-    int expectedIndex = 34;
-    when(decoder.getCurrentFrameIndex()).thenReturn(expectedIndex);
-    int expectedDelay = 5000;
-    when(decoder.getDelay(eq(expectedIndex))).thenReturn(expectedDelay);
-
-    encoder.encode(resource, file, options);
-
-    InOrder order = inOrder(gifEncoder, decoder);
-    order.verify(decoder).advance();
-    order.verify(gifEncoder).addFrame(any(Bitmap.class));
-    order.verify(gifEncoder).setDelay(eq(expectedDelay));
-    order.verify(decoder).advance();
-  }
-
-  @Test
-  public void testWritesSingleFrameToEncoderAndReturnsTrueIfEncoderFinishes() {
-    Bitmap frame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(frameResource.get()).thenReturn(frame);
-
-    when(decoder.getFrameCount()).thenReturn(1);
-    when(decoder.getNextFrame()).thenReturn(frame);
-
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-    when(gifEncoder.addFrame(eq(frame))).thenReturn(true);
-    when(gifEncoder.finish()).thenReturn(true);
-
-    assertTrue(encoder.encode(resource, file, options));
-    verify(gifEncoder).addFrame(eq(frame));
-  }
-
-  @Test
-  public void testReturnsFalseIfAddingFrameFails() {
-    when(decoder.getFrameCount()).thenReturn(1);
-    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));
-
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-    when(gifEncoder.addFrame(any(Bitmap.class))).thenReturn(false);
-
-    assertFalse(encoder.encode(resource, file, options));
-  }
-
-  @Test
-  public void testReturnsFalseIfFinishingFails() {
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-    when(gifEncoder.finish()).thenReturn(false);
-
-    assertFalse(encoder.encode(resource, file, options));
-  }
-
-  @Test
-  public void testWritesTransformedBitmaps() {
-    final Bitmap frame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(decoder.getFrameCount()).thenReturn(1);
-    when(decoder.getNextFrame()).thenReturn(frame);
-
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-
-    int expectedWidth = 123;
-    int expectedHeight = 456;
-    when(gifDrawable.getIntrinsicWidth()).thenReturn(expectedWidth);
-    when(gifDrawable.getIntrinsicHeight()).thenReturn(expectedHeight);
-
-    Bitmap transformedFrame = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
-    when(transformedResource.get()).thenReturn(transformedFrame);
-    when(frameTransformation.transform(eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
-        .thenReturn(transformedResource);
-    when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
-
-    encoder.encode(resource, file, options);
-
-    verify(gifEncoder).addFrame(eq(transformedFrame));
-  }
-
-  @Test
-  public void testRecyclesFrameResourceBeforeWritingIfTransformedResourceIsDifferent() {
-    when(decoder.getFrameCount()).thenReturn(1);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
-        .thenReturn(transformedResource);
-    Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
-    when(transformedResource.get()).thenReturn(expected);
-
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-
-    encoder.encode(resource, file, options);
-
-    InOrder order = inOrder(frameResource, gifEncoder);
-    order.verify(frameResource).recycle();
-    order.verify(gifEncoder).addFrame(eq(expected));
-  }
-
-  @Test
-  public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDifferent() {
-    when(decoder.getFrameCount()).thenReturn(1);
-    Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
-    when(transformedResource.get()).thenReturn(expected);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
-        .thenReturn(transformedResource);
-
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-
-    encoder.encode(resource, file, options);
-
-    InOrder order = inOrder(transformedResource, gifEncoder);
-    order.verify(gifEncoder).addFrame(eq(expected));
-    order.verify(transformedResource).recycle();
-  }
-
-  @Test
-  public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed() {
-    when(decoder.getFrameCount()).thenReturn(1);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
-        .thenReturn(frameResource);
-    Bitmap expected = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
-    when(frameResource.get()).thenReturn(expected);
-
-    when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
-
-    encoder.encode(resource, file, options);
-
-    InOrder order = inOrder(frameResource, gifEncoder);
-    order.verify(gifEncoder).addFrame(eq(expected));
-    order.verify(frameResource).recycle();
-  }
-
-  @Test
-  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation()
-      throws IOException {
-    // Most likely an instance of http://stackoverflow.com/q/991489/253468
-    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
-    when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
-    String expected = "expected";
-    when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(expected.getBytes()));
-
-    encoder.encode(resource, file, options);
-
-    assertThat(getEncodedData()).isEqualTo(expected);
-
-    verify(gifEncoder, never()).start(any(OutputStream.class));
-    verify(parser, never()).setData(any(byte[].class));
-    verify(parser, never()).parseHeader();
-  }
-
-  private String getEncodedData() {
-    try {
-      return new String(ByteBufferUtil.toBytes(ByteBufferUtil.fromFile(file)));
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 564283f73..de39d2afa 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -153,6 +153,10 @@ public static Glide get(Context context) {
           }
           glide = builder.createGlide();
           for (GlideModule module : modules) {
+            /**
+             * module很重要，决定了未来请求使用的类型！！！
+             * 这里假设使用
+             * @see com.bumptech.glide.integration.okhttp3.OkHttpGlideModule */
             module.registerComponents(applicationContext, glide.registry);
           }
         }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 2ebaf8b0f..be66b87fe 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -290,6 +290,7 @@ Glide createGlide() {
       arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
     }
 
+    // Glide的内存缓存默认使用LruResourceCache
     if (memoryCache == null) {
       memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());
     }
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index e6bf29b4e..8af9524a9 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -358,6 +358,7 @@
     requestOptions.lock();
     Request request = buildRequest(target);
     target.setRequest(request);
+    // 图片加载开始的方法
     requestManager.track(target, request);
 
     return target;
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 8c6876c05..cacec37aa 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -87,7 +87,7 @@ public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode t
 
     final Context context = glide.getGlideContext().getBaseContext();
 
-
+    // 创建网络监控者
     connectivityMonitor =
         factory.build(context, new RequestManagerConnectivityListener(requestTracker));
 
@@ -466,6 +466,7 @@ public RequestManagerConnectivityListener(RequestTracker requestTracker) {
     @Override
     public void onConnectivityChanged(boolean isConnected) {
       if (isConnected) {
+        // 收到网络状态连接就重启请求
         requestTracker.restartRequests();
       }
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index c00824e23..4ac065dc1 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -234,8 +234,10 @@ public void run() {
   private void runWrapped() {
      switch (runReason) {
       case INITIALIZE:
+        // 初始化 获取下一个阶段状态
         stage = getNextStage(Stage.INITIALIZE);
         currentGenerator = getNextGenerator();
+        // 运行 Generator：译为生产者
         runGenerators();
         break;
       case SWITCH_TO_SOURCE_SERVICE:
@@ -249,13 +251,21 @@ private void runWrapped() {
     }
   }
 
+  /**
+   * 根据Stage找到数据抓取生成器
+   * @return
+     */
   private DataFetcherGenerator getNextGenerator() {
     switch (stage) {
       case RESOURCE_CACHE:
+        // 产生含有降低采样/转换资源数据缓存文件的DataFetcher。
         return new ResourceCacheGenerator(decodeHelper, this);
       case DATA_CACHE:
+        // 产生包含原始未修改的源数据缓存文件的DataFetcher。
         return new DataCacheGenerator(decodeHelper, this);
       case SOURCE:
+        // 生成使用注册的ModelLoader和加载时提供的Model获取源数据规定的DataFetcher。
+        // 根据不同的磁盘缓存策略，源数据可首先被写入到磁盘，然后从缓存文件中加载，而不是直接返回。
         return new SourceGenerator(decodeHelper, this);
       case FINISHED:
         return null;
@@ -269,6 +279,7 @@ private void runGenerators() {
     startFetchTime = LogTime.getLogTime();
     boolean isStarted = false;
     while (!isCancelled && currentGenerator != null
+            // 来到发起实际请求的地方 SourceGenerator#startNext()
         && !(isStarted = currentGenerator.startNext())) {
       stage = getNextStage(stage);
       currentGenerator = getNextGenerator();
@@ -307,9 +318,20 @@ private void setNotifiedOrThrow() {
     isCallbackNotified = true;
   }
 
+  /**
+   * 这里的阶段策略首先是从resource中寻找，然后再是data，再是source
+   * @param current
+   * @return
+     */
   private Stage getNextStage(Stage current) {
     switch (current) {
       case INITIALIZE:
+        /**
+         * 根据定义的缓存策略来回去下一个状态
+         * 缓存策略来之于RequestBuilder的requestOptions域
+         * 如果你有自定义的策略，可以调用RequestBuilder.apply方法即可
+         * 详细的可用缓存策略请参看
+         *  @see com.bumptech.glide.load.engine.DiskCacheStrategy */
         return diskCacheStrategy.decodeCachedResource()
             ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
       case RESOURCE_CACHE:
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index fdeff2601..19cab4a7f 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -158,11 +158,14 @@ public Engine(MemoryCache memoryCache,
     Util.assertMainThread();
     long startTime = LogTime.getLogTime();
 
+    // 创建key，这是给每次加载资源的唯一标示。
     EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
         resourceClass, transcodeClass, options);
 
+    // 通过key查找缓存资源 （PS 这里的缓存主要是内存中的缓存，该类成员变量MemoryCache cache）
     EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
     if (cached != null) {
+      // 如果有，那么直接利用当前缓存的资源。
       cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         logWithTimeAndKey("Loaded resource from cache", startTime, key);
@@ -170,6 +173,8 @@ public Engine(MemoryCache memoryCache,
       return null;
     }
 
+    // 这是一个二级内存的缓存引用，很简单用了一个Map<Key, WeakReference<EngineResource<?>>>装载起来的。
+    // 在loadFromCache()中有调用
     EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
     if (active != null) {
       cb.onResourceReady(active, DataSource.MEMORY_CACHE);
@@ -179,8 +184,10 @@ public Engine(MemoryCache memoryCache,
       return null;
     }
 
+    // 根据key获取缓存的job
     EngineJob<?> current = jobs.get(key);
     if (current != null) {
+      // 给当前job添加上回调Callback
       current.addCallback(cb);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         logWithTimeAndKey("Added to existing load", startTime, key);
@@ -188,6 +195,9 @@ public Engine(MemoryCache memoryCache,
       return new LoadStatus(cb, current);
     }
 
+    // 创建job
+    // EngineJob充当了管理和调度者，主要负责加载和各类回调通知；
+    // DecodeJob是真正干活的劳动者，这个类实现了Runnable接口
     EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
         useUnlimitedSourceExecutorPool);
     DecodeJob<R> decodeJob = decodeJobFactory.build(
@@ -207,6 +217,7 @@ public Engine(MemoryCache memoryCache,
         engineJob);
     jobs.put(key, engineJob);
     engineJob.addCallback(cb);
+    // 放入线程池，执行
     engineJob.start(decodeJob);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
index c3f3420dc..a8fa0ebf8 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java
@@ -40,24 +40,31 @@ public SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
   @Override
   public boolean startNext() {
     if (dataToCache != null) {
+      // 当下载成功后缓存存在的时候走进if条件
       Object data = dataToCache;
       dataToCache = null;
       cacheData(data);
     }
 
     if (sourceCacheGenerator != null && sourceCacheGenerator.startNext()) {
+      // 当有sourceCacheGenerator，会执行sourceCacheGenerator#startNext()方法
       return true;
     }
     sourceCacheGenerator = null;
 
     loadData = null;
     boolean started = false;
+    // 查找ModelLoader
     while (!started && hasNextModelLoader()) {
       loadData = helper.getLoadData().get(loadDataListIndex++);
       if (loadData != null
           && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
           || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
         started = true;
+        // 根据model的fetcher加载数据
+        /** 这个model的fetcher的设置是在
+         * @see com.bumptech.glide.Glide#get(android.content.Context)
+         * 中通过查找AndroidManifest里的配置决定的*/
         loadData.fetcher.loadData(helper.getPriority(), this);
       }
     }
@@ -71,10 +78,12 @@ private boolean hasNextModelLoader() {
   private void cacheData(Object dataToCache) {
     long startTime = LogTime.getLogTime();
     try {
+      // 根据不同的数据获取注册的不同Encoder
       Encoder<Object> encoder = helper.getSourceEncoder(dataToCache);
       DataCacheWriter<Object> writer =
           new DataCacheWriter<>(encoder, dataToCache, helper.getOptions());
       originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());
+      // 这里的DiskCache实现是Engine中LazyDiskCacheProvider提供的DiskCacheAdapter
       helper.getDiskCache().put(originalKey, writer);
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "Finished encoding source to cache"
@@ -87,6 +96,7 @@ private void cacheData(Object dataToCache) {
       loadData.fetcher.cleanup();
     }
 
+    // 创建针对缓存的Generator
     sourceCacheGenerator =
         new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);
   }
@@ -100,12 +110,16 @@ public void cancel() {
   }
 
   @Override
+  /**
+   * 数据下载完成后的缓存处理
+   */
   public void onDataReady(Object data) {
     DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();
     if (data != null && diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) {
       dataToCache = data;
       // We might be being called back on someone else's thread. Before doing anything, we should
       // reschedule to get back onto Glide's thread.
+      // 这里相当于调用DecodeJob.reschedule()
       cb.reschedule();
     } else {
       cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index fd88428e8..c14af977a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -6,6 +6,7 @@
 import java.util.WeakHashMap;
 
 /**
+ * 生命周期回调管理类
  * A {@link com.bumptech.glide.manager.Lifecycle} implementation for tracking and notifying
  * listeners of {@link android.app.Fragment} and {@link android.app.Activity} lifecycle events.
  */
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 265550362..d91ce6517 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -82,6 +82,7 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
   }
 
   /**
+   * 看<href http://www.jianshu.com/p/317b2d6bde1b>的分析
    * Returns the set of fragments that this RequestManagerFragment's parent is a parent to. (i.e.
    * our parent is the fragment that we are annotating).
    */
@@ -95,7 +96,9 @@ private void removeChildRequestManagerFragment(RequestManagerFragment child) {
       // so just return an empty set.
       return Collections.emptySet();
     } else {
+        // 拿到Activity或者(fragment的activity)的子Fragment
       HashSet<RequestManagerFragment> descendants = new HashSet<>();
+        //遍历取出rootFragment中的RMF，并获取到其parentFragment，找出后裔。
       for (RequestManagerFragment fragment : rootRequestManagerFragment
           .getDescendantRequestManagerFragments()) {
         if (isDescendant(fragment.getParentFragment())) {
@@ -143,6 +146,16 @@ private boolean isDescendant(Fragment fragment) {
     return false;
   }
 
+    /**
+     * 这个rootRequestManagerFragment通过getRequestManagerFragment()方法拿到，有可能是自身，有可能已经被初始化过了，
+     * 1. 如果是通过with(Activity activity)的形式创建的，rootRequestManagerFragment会是自己本身；
+     * 2. 如果是通过with(Fragment fragment)的形式创建的，rootRequestManagerFragment将指向当前fragment绑定到Activity所绑定的RequestManagerFragment，
+     * 如果该Activity没有绑定过，那么会开启事务绑定一个RequestManagerFragment。
+     * <p>
+     * 并且如果自己不是rootRequestManagerFragment的话，那么将会把自己保存到rootRequestManagerFragment中的一个集合
+     *
+     * @param activity
+     */
   private void registerFragmentWithRoot(Activity activity) {
     unregisterFragmentWithRoot();
     rootRequestManagerFragment = RequestManagerRetriever.get()
@@ -163,6 +176,8 @@ private void unregisterFragmentWithRoot() {
   public void onAttach(Activity activity) {
     super.onAttach(activity);
     try {
+      // Glide每创建一个RequestManagerFragment，都会尝试实例化rootRequestManagerFragment，
+      // 这个fragment即顶级的Activity所创建的RequestManagerFragment
       registerFragmentWithRoot(activity);
     } catch (IllegalStateException e) {
       // OnAttach can be called after the activity is destroyed, see #497.
@@ -229,6 +244,7 @@ public String toString() {
 
     @Override
     public Set<RequestManager> getDescendants() {
+        // 调用外部类RequestManagerFragment的方法
       Set<RequestManagerFragment> descendantFragments = getDescendantRequestManagerFragments();
       HashSet<RequestManager> descendants = new HashSet<>(descendantFragments.size());
       for (RequestManagerFragment fragment : descendantFragments) {
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index 141cdb70e..8df2033a1 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -20,6 +20,7 @@
 import java.util.Map;
 
 /**
+ * Retriever英文翻译为：猎犬。
  * A collection of static methods for creating new {@link com.bumptech.glide.RequestManager}s or
  * retrieving existing ones from activities and fragment.
  */
@@ -111,6 +112,7 @@ public RequestManager get(Context context) {
   }
 
   public RequestManager get(FragmentActivity activity) {
+    // 如果在子线程进行的with操作，那么Glide默认使用ApplicationContext，不对请求的生命周期进行管理
     if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
@@ -166,12 +168,19 @@ public RequestManager get(android.app.Fragment fragment) {
   }
 
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+  /**
+   * 该方法创建了一个Fragment，并且创建并绑定了一个RequestManager
+   */
   RequestManagerFragment getRequestManagerFragment(
       final android.app.FragmentManager fm, android.app.Fragment parentHint) {
+    // 尝试根据id去找到此前创建的RequestManagerFragment
     RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
     if (current == null) {
+      // 如果没有找到，那么从临时存储中寻找
       current = pendingRequestManagerFragments.get(fm);
       if (current == null) {
+        // 如果仍然没有找到，那么新建一个RequestManagerFragment，并添加到临时存储中。
+        // 然后开启事务绑定fragment并使用handler发送消息来将临时存储的fragment移除。
         current = new RequestManagerFragment();
         current.setParentFragmentHint(parentHint);
         pendingRequestManagerFragments.put(fm, current);
@@ -185,10 +194,17 @@ RequestManagerFragment getRequestManagerFragment(
   @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
       android.app.Fragment parentHint) {
+    // 获取RequestManagerFragment，并获取绑定到这个fragment的RequestManager
     RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
       // TODO(b/27524013): Factor out this Glide.get() call.
+      /**
+       * 如果获取RequestManagerFragment还没有绑定过RequestManager,
+       * 那么就创建RequestManager并绑定到RequestManagerFragment
+       * RequestManager的构造函数内会将lifecycle加入
+       * @see com.bumptech.glide.manager.ActivityFragmentLifecycle#addListener()
+       */
       Glide glide = Glide.get(context);
       requestManager =
           new RequestManager(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
index 38d341b3a..ee5c3bd52 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java
@@ -4,6 +4,7 @@
 import java.util.Set;
 
 /**
+ * 保存请求树节点
  * Provides access to the relatives of a RequestManager based on the current context. The context
  * hierarchy is provided by nesting in Activity and Fragments; the application context does not
  * provide access to any other RequestManagers hierarchically.
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 78a66c6a3..d909308bb 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -9,6 +9,7 @@
 import java.util.WeakHashMap;
 
 /**
+ * RequestTracker即所有请求操作的真正处理者，所有Request的暂停取消执行操作都由RequestTracker来完成
  * A class for tracking, canceling, and restarting in progress, completed, and failed requests.
  *
  * <p>This class is not thread safe and must be accessed on the main thread.
@@ -35,10 +36,13 @@
    * Starts tracking the given request.
    */
   public void runRequest(Request request) {
+    // 添加内存缓存
     requests.add(request);
     if (!isPaused) {
+      // 开始请求
       request.begin();
     } else {
+      // 挂起请求
       pendingRequests.add(request);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index ce01040bd..f292cba72 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -20,6 +20,10 @@ public ManifestParser(Context context) {
     this.context = context;
   }
 
+  /**
+   * 从AndroidManifest.xml文件里读取的配置项，可配置网络请求的类型
+   * @return
+     */
   public List<GlideModule> parse() {
     if (Log.isLoggable(TAG, Log.DEBUG)) {
       Log.d(TAG, "Loading Glide modules");
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index c0dba86d6..d87593382 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request;
 
 import android.content.res.Resources;
+import android.database.sqlite.SQLiteDatabase;
 import android.graphics.drawable.Drawable;
 import android.support.v4.content.res.ResourcesCompat;
 import android.support.v4.util.Pools;
@@ -200,6 +201,7 @@ public void recycle() {
   public void begin() {
     stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
+    // 如果model空的，那么是不能执行的。 这里的model就是RequestBuilder中的model
     if (model == null) {
       if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
         width = overrideWidth;
@@ -213,12 +215,18 @@ public void begin() {
     }
 
     status = Status.WAITING_FOR_SIZE;
+    // 如果当前的View尺寸已经加载获取到了，就会进入真正的加载流程
     if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
       onSizeReady(overrideWidth, overrideHeight);
     } else {
+      // 反之，当前View还没有画出来，那么是没有尺寸的。
+      // 这里会调用到ViewTreeObserver.addOnPreDrawListener。
+      // 等待View的尺寸都ok，才会继续
+      // 跟踪ViewTarget的getSize方法
       target.getSize(this);
     }
 
+    // 如果等待和正在执行状态，那么当前会加载占位符Drawable
     if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
         && canNotifyStatusChanged()) {
       target.onLoadStarted(getPlaceholderDrawable());
@@ -360,6 +368,9 @@ private void setErrorPlaceholder() {
   }
 
   /**
+   * 这里是真正的加载流程，主要是Engine发起load操作
+   * Engine创建在
+   * @see com.bumptech.glide.GlideBuilder#createGlide()
    * A callback method that should never be invoked directly.
    */
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 2ffb77553..28cfe23d0 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -216,12 +216,14 @@ void getSize(SizeReadyCallback cb) {
         // We want to notify callbacks in the order they were added and we only expect one or two
         // callbacks to
         // be added a time, so a List is a reasonable choice.
+        // 加入尺寸监听集合
         if (!cbs.contains(cb)) {
           cbs.add(cb);
         }
         if (layoutListener == null) {
           final ViewTreeObserver observer = view.getViewTreeObserver();
           layoutListener = new SizeDeterminerLayoutListener(this);
+          // 绘画之前加入尺寸的监听，接下来看SizeDeterminerLayoutListener代码
           observer.addOnPreDrawListener(layoutListener);
         }
       }
@@ -297,6 +299,7 @@ private boolean isSizeValid(int size) {
 
     private static class SizeDeterminerLayoutListener implements ViewTreeObserver
         .OnPreDrawListener {
+      // 弱引用
       private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
       public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
@@ -310,6 +313,8 @@ public boolean onPreDraw() {
         }
         SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
         if (sizeDeterminer != null) {
+          // 通知SizeDeterminer去重新检查尺寸，并触发后续操作。
+          // SizeDeterminer有点像工具类，又作为尺寸回调的检测接口
           sizeDeterminer.checkCurrentDimens();
         }
         return true;
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
deleted file mode 100644
index 23d368e50..000000000
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ /dev/null
@@ -1,195 +0,0 @@
-package com.bumptech.glide.gifdecoder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.robolectric.Shadows.shadowOf;
-
-import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
-import com.bumptech.glide.testutil.TestUtil;
-import java.io.IOException;
-import java.util.Arrays;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.Shadows;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
-
-/**
- * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class GifDecoderTest {
-
-  private MockProvider provider;
-
-  @Before
-  public void setUp() {
-    provider = new MockProvider();
-  }
-
-  @Test
-  public void testCanDecodeFramesFromTestGif() throws IOException {
-    byte[] data = TestUtil.resourceToBytes(getClass(), "partial_gif_decode.gif");
-    GifHeaderParser headerParser = new GifHeaderParser();
-    headerParser.setData(data);
-    GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new StandardGifDecoder(provider);
-    decoder.setData(header, data);
-    decoder.advance();
-    Bitmap bitmap = decoder.getNextFrame();
-    assertNotNull(bitmap);
-    assertEquals(GifDecoder.STATUS_OK, decoder.getStatus());
-  }
-
-  @Test
-  public void testFrameIndexStartsAtNegativeOne() {
-    GifHeader gifheader = new GifHeader();
-    gifheader.frameCount = 4;
-    byte[] data = new byte[0];
-    GifDecoder decoder = new StandardGifDecoder(provider);
-    decoder.setData(gifheader, data);
-    assertEquals(-1, decoder.getCurrentFrameIndex());
-  }
-
-  @Test
-  public void testAdvanceIncrementsFrameIndex() {
-    GifHeader gifheader = new GifHeader();
-    gifheader.frameCount = 4;
-    byte[] data = new byte[0];
-    GifDecoder decoder = new StandardGifDecoder(provider);
-    decoder.setData(gifheader, data);
-    decoder.advance();
-    assertEquals(0, decoder.getCurrentFrameIndex());
-  }
-
-  @Test
-  public void testAdvanceWrapsIndexBackToZero() {
-    GifHeader gifheader = new GifHeader();
-    gifheader.frameCount = 2;
-    byte[] data = new byte[0];
-    GifDecoder decoder = new StandardGifDecoder(provider);
-    decoder.setData(gifheader, data);
-    decoder.advance();
-    decoder.advance();
-    decoder.advance();
-    assertEquals(0, decoder.getCurrentFrameIndex());
-  }
-
-  @Test
-  public void testSettingDataResetsFramePointer() {
-    GifHeader gifheader = new GifHeader();
-    gifheader.frameCount = 4;
-    byte[] data = new byte[0];
-    GifDecoder decoder = new StandardGifDecoder(provider);
-    decoder.setData(gifheader, data);
-    decoder.advance();
-    decoder.advance();
-    assertEquals(1, decoder.getCurrentFrameIndex());
-
-    decoder.setData(gifheader, data);
-    assertEquals(-1, decoder.getCurrentFrameIndex());
-  }
-
-  @Test
-  @Config(shadows = {CustomShadowBitmap.class})
-  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalBackground()
-      throws IOException {
-    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_background.gif");
-    GifHeaderParser headerParser = new GifHeaderParser();
-    headerParser.setData(data);
-    GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new StandardGifDecoder(provider);
-    decoder.setData(header, data);
-    decoder.advance();
-    Bitmap firstFrame = decoder.getNextFrame();
-    decoder.advance();
-    decoder.getNextFrame();
-    decoder.advance();
-    Bitmap firstFrameTwice = decoder.getNextFrame();
-    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
-        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
-  }
-
-  @Test
-  @Config(shadows = {CustomShadowBitmap.class})
-  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalNone() throws IOException {
-    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_none.gif");
-    GifHeaderParser headerParser = new GifHeaderParser();
-    headerParser.setData(data);
-    GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new StandardGifDecoder(provider);
-    decoder.setData(header, data);
-    decoder.advance();
-    Bitmap firstFrame = decoder.getNextFrame();
-    decoder.advance();
-    decoder.getNextFrame();
-    decoder.advance();
-    Bitmap firstFrameTwice = decoder.getNextFrame();
-    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
-        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
-  }
-
-  /**
-   * Preserve generated bitmap data for checking.
-   */
-  @Implements(Bitmap.class)
-  public static class CustomShadowBitmap extends ShadowBitmap {
-
-    private int[] pixels;
-
-    @Implementation
-    public void setPixels(int[] pixels, int offset, int stride,
-        int x, int y, int width, int height) {
-      this.pixels = new int[pixels.length];
-      System.arraycopy(pixels, 0, this.pixels, 0, this.pixels.length);
-    }
-
-    public int[] getPixels() {
-      return pixels;
-    }
-  }
-
-  private static class MockProvider implements GifDecoder.BitmapProvider {
-
-    @NonNull
-    @Override
-    public Bitmap obtain(int width, int height, Bitmap.Config config) {
-      Bitmap result = Bitmap.createBitmap(width, height, config);
-      Shadows.shadowOf(result).setMutable(true);
-      return result;
-    }
-
-    @Override
-    public void release(Bitmap bitmap) {
-      // Do nothing.
-    }
-
-    @Override
-    public byte[] obtainByteArray(int size) {
-      return new byte[size];
-    }
-
-    @Override
-    public void release(byte[] bytes) {
-      // Do nothing.
-    }
-
-    @Override
-    public int[] obtainIntArray(int size) {
-      return new int[size];
-    }
-
-    @Override
-    public void release(int[] array) {
-      // Do Nothing
-    }
-
-  }
-}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
deleted file mode 100644
index 3d45f5d39..000000000
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ /dev/null
@@ -1,264 +0,0 @@
-package com.bumptech.glide.gifdecoder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;
-import com.bumptech.glide.testutil.TestUtil;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/**
- * Tests for {@link com.bumptech.glide.gifdecoder.GifHeaderParser}.
- */
-@RunWith(JUnit4.class)
-public class GifHeaderParserTest {
-  private GifHeaderParser parser;
-
-  @Before
-  public void setUp() {
-    parser = new GifHeaderParser();
-  }
-
-  @Test
-  public void testReturnsHeaderWithFormatErrorIfDoesNotStartWithGifHeader() {
-    parser.setData("wrong_header".getBytes());
-    GifHeader result = parser.parseHeader();
-    assertEquals(GifDecoder.STATUS_FORMAT_ERROR, result.status);
-  }
-
-  @Test
-  public void testCanReadValidHeaderAndLSD() {
-    final int width = 10;
-    final int height = 20;
-    ByteBuffer buffer =
-        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH).order(ByteOrder.LITTLE_ENDIAN);
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, width, height, false, 0);
-
-    parser.setData(buffer.array());
-    GifHeader header = parser.parseHeader();
-    assertEquals(width, header.width);
-    assertEquals(height, header.height);
-    assertFalse(header.gctFlag);
-    // 2^(1+0) == 2^1 == 2.
-    assertEquals(2, header.gctSize);
-    assertEquals(0, header.bgIndex);
-    assertEquals(0, header.pixelAspect);
-  }
-
-  @Test
-  public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOException {
-    byte[] data =
-        TestUtil.resourceToBytes(getClass(), "gif_without_graphical_control_extension.gif");
-    parser.setData(data);
-    GifHeader header = parser.parseHeader();
-    assertEquals(1, header.frameCount);
-    assertNotNull(header.frames.get(0));
-    assertEquals(GifDecoder.STATUS_OK, header.status);
-  }
-
-  @Test
-  public void testCanReadImageDescriptorWithoutGraphicalExtension() {
-    final int lzwMinCodeSize = 2;
-    ByteBuffer buffer = ByteBuffer.allocate(
-        GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
-    GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
-
-    parser.setData(buffer.array());
-    GifHeader header = parser.parseHeader();
-    assertEquals(1, header.width);
-    assertEquals(1, header.height);
-    assertEquals(1, header.frameCount);
-    assertNotNull(header.frames.get(0));
-  }
-
-  private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {
-    final int lzwMinCodeSize = 2;
-    ByteBuffer buffer = ByteBuffer.allocate(
-        GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH
-            + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-    GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);
-    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
-    GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
-    return buffer;
-  }
-
-  @Test
-  public void testCanParseFrameDelay() {
-    final short frameDelay = 50;
-    ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
-
-    parser.setData(buffer.array());
-    GifHeader header = parser.parseHeader();
-    GifFrame frame = header.frames.get(0);
-
-    // Convert delay in 100ths of a second to ms.
-    assertEquals(frameDelay * 10, frame.delay);
-  }
-
-  @Test
-  public void testSetsDefaultFrameDelayIfFrameDelayIsZero() {
-    ByteBuffer buffer = writeHeaderWithGceAndFrameDelay((short) 0);
-
-    parser.setData(buffer.array());
-    GifHeader header = parser.parseHeader();
-    GifFrame frame = header.frames.get(0);
-
-    // Convert delay in 100ths of a second to ms.
-    assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);
-  }
-
-  @Test
-  public void testSetsDefaultFrameDelayIfFrameDelayIsLessThanMinimum() {
-    final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY - 1;
-    ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
-
-    parser.setData(buffer.array());
-    GifHeader header = parser.parseHeader();
-    GifFrame frame = header.frames.get(0);
-
-    // Convert delay in 100ths of a second to ms.
-    assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);
-  }
-
-  @Test
-  public void testObeysFrameDelayIfFrameDelayIsAtMinimum() {
-    final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY;
-    ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);
-
-    parser.setData(buffer.array());
-    GifHeader header = parser.parseHeader();
-    GifFrame frame = header.frames.get(0);
-
-    // Convert delay in 100ths of a second to ms.
-    assertEquals(frameDelay * 10, frame.delay);
-  }
-
-  @Test
-  public void testSetsFrameLocalColorTableToNullIfNoColorTable() {
-    final int lzwMinCodeSize = 2;
-    ByteBuffer buffer = ByteBuffer.allocate(
-        GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize)).order(ByteOrder.LITTLE_ENDIAN);
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);
-    GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);
-
-    parser.setData(buffer.array());
-    GifHeader header = parser.parseHeader();
-    assertEquals(1, header.width);
-    assertEquals(1, header.height);
-    assertEquals(1, header.frameCount);
-    assertNotNull(header.frames.get(0));
-    assertNull(header.frames.get(0).lct);
-  }
-
-  @Test
-  public void testSetsFrameLocalColorTableIfHasColorTable() {
-    final int lzwMinCodeSize = 2;
-    final int numColors = 4;
-    ByteBuffer buffer = ByteBuffer.allocate(
-        GifBytesTestUtil.HEADER_LENGTH + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-            .getImageDataSize(lzwMinCodeSize) + GifBytesTestUtil.getColorTableLength(numColors))
-        .order(ByteOrder.LITTLE_ENDIAN);
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, true /*hasLct*/, numColors);
-    GifBytesTestUtil.writeColorTable(buffer, numColors);
-    GifBytesTestUtil.writeFakeImageData(buffer, 2);
-
-    parser.setData(buffer.array());
-    GifHeader header = parser.parseHeader();
-    assertEquals(1, header.width);
-    assertEquals(1, header.height);
-    assertEquals(1, header.frameCount);
-    assertNotNull(header.frames.get(0));
-
-    GifFrame frame = header.frames.get(0);
-    assertNotNull(frame.lct);
-  }
-
-  @Test
-  public void testCanParseMultipleFrames() {
-    final int lzwMinCodeSize = 2;
-    final int expectedFrames = 3;
-
-    final int frameSize = GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + GifBytesTestUtil
-        .getImageDataSize(lzwMinCodeSize);
-    ByteBuffer buffer =
-        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + expectedFrames * frameSize)
-            .order(ByteOrder.LITTLE_ENDIAN);
-
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-    for (int i = 0; i < expectedFrames; i++) {
-      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
-      GifBytesTestUtil.writeFakeImageData(buffer, 2);
-    }
-
-    parser.setData(buffer.array());
-    GifHeader header = parser.parseHeader();
-    assertEquals(expectedFrames, header.frameCount);
-    assertEquals(expectedFrames, header.frames.size());
-  }
-
-  @Test
-  public void testIsAnimatedMultipleFrames() {
-    final int lzwMinCodeSize = 2;
-    final int numFrames = 3;
-
-    final int frameSize =
-        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
-    ByteBuffer buffer =
-        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize)
-            .order(ByteOrder.LITTLE_ENDIAN);
-
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-    for (int i = 0; i < numFrames; i++) {
-      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
-      GifBytesTestUtil.writeFakeImageData(buffer, 2);
-    }
-
-    parser.setData(buffer.array());
-    assertTrue(parser.isAnimated());
-  }
-
-  @Test
-  public void testIsNotAnimatedOneFrame() {
-    final int lzwMinCodeSize = 2;
-
-    final int frameSize =
-        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
-            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
-
-    ByteBuffer buffer =
-        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize)
-            .order(ByteOrder.LITTLE_ENDIAN);
-
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
-    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
-    GifBytesTestUtil.writeFakeImageData(buffer, 2);
-
-    parser.setData(buffer.array());
-    assertFalse(parser.isAnimated());
-  }
-
-
-  @Test(expected = IllegalStateException.class)
-  public void testThrowsIfParseHeaderCalledBeforeSetData() {
-    GifHeaderParser parser = new GifHeaderParser();
-    parser.parseHeader();
-  }
-}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
deleted file mode 100644
index 7a32733a6..000000000
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtil.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package com.bumptech.glide.gifdecoder.test;
-
-import java.nio.ByteBuffer;
-
-/**
- * Utils for writing the bytes of various parts of GIFs to byte buffers.
- */
-public class GifBytesTestUtil {
-  // Length in bytes.
-  public static final int HEADER_LENGTH = 13;
-  // Length in bytes.
-  public static final int IMAGE_DESCRIPTOR_LENGTH = 10;
-  // Length in bytes.
-  public static final int GRAPHICS_CONTROL_EXTENSION_LENGTH = 8;
-
-  public static int getColorTableLength(int numColors) {
-    return 3 * numColors;
-  }
-
-  public static int getImageDataSize(int lzwMinCodeSize) {
-    // TODO: fill this out.
-    return 4;
-  }
-
-  public static void writeFakeImageData(ByteBuffer out, int lzwMinCodeSize) {
-    // 1 for lzwMinCodeSize, 1 for length, 1 for min content, 1 for block terminator.
-    verifyRemaining(out, 4);
-    verifyShortValues(lzwMinCodeSize);
-
-    out.put((byte) lzwMinCodeSize);
-    // Block length.
-    out.put((byte) 0x01);
-    // Block content.
-    out.put((byte) 0x01);
-    // End of block.
-    out.put((byte) 0x00);
-  }
-
-  public static void writeColorTable(ByteBuffer out, int numColors) {
-    verifyRemaining(out, getColorTableLength(numColors));
-    for (int i = 0; i < numColors; i++) {
-      out.put((byte) (0xFF0000 & i));
-      out.put((byte) (0x00FF00 & i));
-      out.put((byte) (0x0000FF & i));
-    }
-  }
-
-  public static void writeImageDescriptor(ByteBuffer out, int imageLeft, int imageTop,
-      int imageWidth, int imageHeight, boolean hasLct, int numColors) {
-    verifyRemaining(out, IMAGE_DESCRIPTOR_LENGTH);
-    verifyShortValues(imageLeft, imageTop, imageWidth, imageHeight);
-
-    final byte packed;
-    if (hasLct) {
-      int size = log2(numColors) - 1;
-      packed = (byte) (0x80 | size);
-    } else {
-      packed = 0x00;
-    }
-
-    // Image separator
-    out.put((byte) 0x2C);
-    out.putShort((short) imageLeft).putShort((short) imageTop).putShort((short) imageWidth)
-        .putShort((short) imageHeight).put(packed);
-  }
-
-  private static int log2(int num) {
-    return (int) Math.round(Math.log(num) / Math.log(2));
-  }
-
-  public static void writeHeaderAndLsd(ByteBuffer out, int width, int height, boolean hasGct,
-      int gctSize) {
-    verifyRemaining(out, HEADER_LENGTH);
-    verifyShortValues(width, height);
-
-    // GIF
-    out.put((byte) 0x47).put((byte) 0x49).put((byte) 0x46);
-    // Version - 89a.
-    out.put((byte) 0x38).put((byte) 0x39).put((byte) 0x61);
-
-    /** LSD (Logical Screen Descriptor) **/
-    // Width.
-    out.putShort((short) width);
-    // Height.
-    out.putShort((short) height);
-    // Packed GCT (Global Color Table) flag + color resolution + sort flag + size of GCT.
-    // GCT flag (false) - most significant bit.
-    byte gctFlag = (byte) ((hasGct ? 1 : 0) << 7);
-    // Color resolution - next three bits.
-    byte colorResolution = 1 << 5;
-    // Sort flag - next bit;
-    byte sortFlag = 0 << 4;
-    // exponent of size of color table, size = 2^(1 + exponent) - least significant 3 bits.
-    byte size = (byte) gctSize;
-
-    byte packed = (byte) (gctFlag | colorResolution | sortFlag | size);
-    out.put(packed);
-
-    // Background color index.
-    out.put((byte) 0);
-
-    // Pixel aspect ratio.
-    out.put((byte) 0);
-  }
-
-  public static void writeGraphicsControlExtension(ByteBuffer out, int delayTime) {
-    verifyRemaining(out, GRAPHICS_CONTROL_EXTENSION_LENGTH);
-    verifyShortValues(delayTime);
-
-    // Extension inducer (constant).
-    out.put((byte) 0x21);
-    // Graphic control label (constant).
-    out.put((byte) 0xF9);
-    // Block size (constant).
-    out.put((byte) 0x04);
-    // Packed (disposal method, user input, transparent color flag)
-    out.put((byte) 0x00);
-
-    // Frame delay in 100ths of a second.
-    out.putShort((short) delayTime);
-
-    // Transparent color index.
-    out.put((byte) 0x00);
-
-    // Block terminator (constant).
-    out.put((byte) 0x00);
-  }
-
-  private static void verifyRemaining(ByteBuffer buffer, int expected) {
-    if (buffer.remaining() < expected) {
-      throw new IllegalArgumentException("Must have at least " + expected + " bytes to write");
-    }
-  }
-
-  private static void verifyShortValues(int... shortValues) {
-    for (int dimen : shortValues) {
-      if (dimen > Short.MAX_VALUE || dimen < 0) {
-        throw new IllegalArgumentException(
-            "Must pass in non-negative short dimensions, not: " + dimen);
-      }
-    }
-  }
-}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
deleted file mode 100644
index f09e8596e..000000000
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/test/GifBytesTestUtilTest.java
+++ /dev/null
@@ -1,147 +0,0 @@
-package com.bumptech.glide.gifdecoder.test;
-
-import static org.junit.Assert.assertArrayEquals;
-
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/**
- * Tests for {@link com.bumptech.glide.gifdecoder.test.GifBytesTestUtil}.
- */
-@RunWith(JUnit4.class)
-public class GifBytesTestUtilTest {
-
-  @Test
-  public void testWriteHeaderAndLsdWithoutGct() {
-    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH);
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, 8, 16, false, 0);
-
-    byte[] expected =
-        new byte[] { 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00, 0x08, 0x00, 0x10, 0x20, 0x00, 0x00 };
-
-    assertEquals(expected, buffer);
-  }
-
-  @Test
-  public void testWriteHeaderAndLsdWithGct() {
-    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH);
-    GifBytesTestUtil.writeHeaderAndLsd(buffer, 8, 16, true, 4);
-
-    byte[] expected =
-        new byte[] { 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00, 0x08, 0x00, 0x10, (byte) 0xA4, 0x00,
-            0x00 };
-
-    assertEquals(expected, buffer);
-  }
-
-  @Test
-  public void testWriteImageDescriptorWithoutColorTable() {
-    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH);
-    GifBytesTestUtil.writeImageDescriptor(buffer, 10, 9, 8, 7, false, 0);
-
-    byte[] expected = new byte[] {
-        // Image separator.
-        0x2C,
-        // Image left.
-        0x00, 0x0A,
-        // Image right.
-        0x00, 0X09,
-        // Image width.
-        0x00, 0x08,
-        // Image height.
-        0x00, 0x07,
-        // Packed field.
-        0x00 };
-
-    assertEquals(expected, buffer);
-  }
-
-  @Test
-  public void testWriteImageDescriptorWithColorTable() {
-    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH);
-    GifBytesTestUtil.writeImageDescriptor(buffer, 10, 9, 8, 7, true, 4);
-
-    byte packedField =
-        // Set LCT flag
-        (byte) 0x80
-            // Size of color table (2^(N + 1) == 4)
-            | 0x01;
-
-    byte[] expected = new byte[] {
-        // Image separator.
-        0x2C,
-        // Image left.
-        0x00, 0x0A,
-        // Image right.
-        0x00, 0X09,
-        // Image width.
-        0x00, 0x08,
-        // Image height.
-        0x00, 0x07, packedField };
-
-    assertEquals(expected, buffer);
-  }
-
-  @Test
-  public void testWriteColorTable() {
-    final int numColors = 4;
-    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.getColorTableLength(numColors));
-    GifBytesTestUtil.writeColorTable(buffer, numColors);
-
-    byte[] expected = new byte[] {
-        // First color.
-        0x00, 0x00, 0x00,
-        // Second color.
-        0x00, 0x00, 0x01,
-        // Third color.
-        0x00, 0x00, 0x02,
-        // Fourth color.
-        0x00, 0x00, 0x03, };
-
-
-    assertEquals(expected, buffer);
-  }
-
-  @Test
-  public void testWriteFakeImageData() {
-    ByteBuffer buffer = ByteBuffer.allocate(4);
-    GifBytesTestUtil.writeFakeImageData(buffer, 2);
-
-    byte[] expected = new byte[] { 0x02, 0x01, 0x01, 0x00 };
-
-    assertEquals(expected, buffer);
-  }
-
-  @Test
-  public void testWritesGraphicsControlExtension() {
-    short delay = 20;
-    ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH);
-    byte[] expected = new byte[] {
-        // Extension inducer.
-        0x21,
-        // Graphic control label.
-        (byte) 0xF9,
-        // Block size.
-        0x04,
-        // Packed byte.
-        0x00,
-        // Frame delay.
-        0x00, 0x14,
-        // Transparent color index.
-        0x00,
-        // block terminator.
-        0x00 };
-
-    GifBytesTestUtil.writeGraphicsControlExtension(buffer, delay);
-    assertEquals(expected, buffer);
-  }
-
-  private static void assertEquals(byte[] expected, ByteBuffer buffer) {
-    assertArrayEquals(
-        "expected=" + Arrays.toString(expected) + " received=" + Arrays.toString(buffer.array()),
-        expected, buffer.array());
-  }
-}
diff --git a/third_party/gif_decoder/src/test/resources/gif_without_graphical_control_extension.gif b/third_party/gif_decoder/src/test/resources/gif_without_graphical_control_extension.gif
deleted file mode 100644
index f949829de..000000000
Binary files a/third_party/gif_decoder/src/test/resources/gif_without_graphical_control_extension.gif and /dev/null differ
diff --git a/third_party/gif_decoder/src/test/resources/partial_gif_decode.gif b/third_party/gif_decoder/src/test/resources/partial_gif_decode.gif
deleted file mode 100644
index 2e3b6f279..000000000
Binary files a/third_party/gif_decoder/src/test/resources/partial_gif_decode.gif and /dev/null differ
diff --git a/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif b/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif
deleted file mode 100644
index 3c64b1d65..000000000
Binary files a/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif and /dev/null differ
diff --git a/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif b/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif
deleted file mode 100644
index 158e329ba..000000000
Binary files a/third_party/gif_decoder/src/test/resources/transparent_disposal_none.gif and /dev/null differ
