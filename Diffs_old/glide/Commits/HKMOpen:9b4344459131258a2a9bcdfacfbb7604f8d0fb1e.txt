diff --git a/.gitignore b/.gitignore
index dbfe9eb43..6a64b1779 100644
--- a/.gitignore
+++ b/.gitignore
@@ -39,4 +39,4 @@ docs/**/*
 **/.idea/dataSources.ids
 **/.idea/datasources.xml
 **/.idea/uiDesigner.xml
-
+**/.idea/runConfigurations.xml
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index 536c52938..da727f2ac 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -291,6 +291,34 @@
         <option name="DOWHILE_BRACE_FORCE" value="3" />
         <option name="WHILE_BRACE_FORCE" value="3" />
         <option name="FOR_BRACE_FORCE" value="3" />
+        <Objective-C-extensions>
+          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />
+          <option name="RELEASE_STYLE" value="IVAR" />
+          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />
+          <file>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />
+          </file>
+          <class>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />
+          </class>
+          <extensions>
+            <pair source="cpp" header="h" />
+            <pair source="c" header="h" />
+          </extensions>
+        </Objective-C-extensions>
         <XML>
           <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
         </XML>
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 5fc10cb16..950f16a66 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,26 +1,54 @@
 # Contributing
-Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other
-aspects of the library (documentation, the wiki etc.)
+Contributions of all types are welcome.
+We use GitHub as our bug and feature tracker both for code and for other aspects of the library (documentation, the wiki, etc.).
+
 
 ## Asking Questions
-The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on
-freenode.org.][3]
+The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on freenode.org][3].
+
 
 ## Filing issues
-To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more
-information you can provide, the more likely we are to be able help.
+When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed.
+Similarly if you support a particular feature request, feel free to let us know by commenting on the issue.
+
+To file a new issue, please use our issue template and fill out the template as much as possible (remove irrelevant parts).
+
+<pre>**Glide Version/Integration library (if any)**:
+**Device/Android Version**:
+**Issue details/Repro steps/Use case background**:
+
+**Glide load line**:
+```java
+Glide.with(...).....load(...).....into(...);
+```
+
+**Layout XML**:
+```xml
+&lt;...Layout&gt;
+    &lt;ImageView android:scaleType="..." ... /&gt;
+&lt;/..Layout&gt;
+```
+
+**Stack trace / LogCat**:
+```ruby
+paste stack trace here
+```
+</pre>
+
+You can save [this as a bookmark or just click it][1] to create a new issue.
+The more information you can provide, the more likely we are to be able help.
 
-When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if
-you support a particular feature request, feel free to let us know by commenting on the issue.
 
 ## Contributing code
-Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find
-instructions on building the project in our README. Our code style is defined in Intellij project files in the repo
-and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel
-free to put up your pull request anyway and we can help you fix the style issues. If you'd like to
-contribute code, you will need to sign [Google's individual contributor license agreement][4].
+Pull requests are welcome for all parts of the codebase, especially the integration libraries.
+You can find instructions on building the project in [README.md][5].
+Our code style is defined in Intellij project files in the repo and also by our Checkstyle config.
+If you'd like to submit code, but can't get the style checks to pass, feel free to put up your pull request anyway and we can help you fix the style issues.
+If you'd like to contribute code, you will need to sign [Google's individual contributor license agreement][4] which will be asked when you create the PR by [googlebot](https://github.com/googlebot) should you forget it.
+
 
-[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60
 [2]: https://groups.google.com/forum/#!forum/glidelibrary
 [3]: http://webchat.freenode.net/?channels=glide-library
-[4]: https://developers.google.com/open-source/cla/individual.
+[4]: https://developers.google.com/open-source/cla/individual
+[5]: /bumptech/glide
\ No newline at end of file
diff --git a/README.md b/README.md
index 34bbbf0b3..3cd7dbd8b 100644
--- a/README.md
+++ b/README.md
@@ -8,8 +8,8 @@ decoding, memory and disk caching, and resource pooling into a simple and easy t
 
 ![](static/glide_logo.png)
 
-Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible api
-that allows developers to plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based
+Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible API
+that allows developers to plug in to almost any network stack. By default Glide uses a custom `HttpUrlConnection` based
 stack, but also includes utility libraries plug in to Google's Volley project or Square's OkHttp library instead.
 
 Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is
@@ -21,13 +21,13 @@ You can download a jar from GitHub's [releases page][1].
 
 Or use Gradle:
 
-```groovy
+```gradle
 repositories {
-  mavenCentral()
+    mavenCentral()
 }
 
 dependencies {
-    compile 'com.github.bumptech.glide:glide:3.6.0'
+    compile 'com.github.bumptech.glide:glide:3.7.0'
     compile 'com.android.support:support-v4:19.1.0'
 }
 ```
@@ -36,22 +36,22 @@ Or Maven:
 
 ```xml
 <dependency>
-  <groupId>com.github.bumptech.glide</groupId>
-  <artifactId>glide</artifactId>
-  <version>3.6.0</version>
-  <type>aar</type>
+    <groupId>com.github.bumptech.glide</groupId>
+    <artifactId>glide</artifactId>
+    <version>3.7.0</version>
 </dependency>
 <dependency>
-  <groupId>com.google.android</groupId>
-  <artifactId>support-v4</artifactId>
-  <version>r7</version>
+    <groupId>com.google.android</groupId>
+    <artifactId>support-v4</artifactId>
+    <version>r7</version>
 </dependency>
 ```
 
 Proguard
 --------
 Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:
-```
+
+```pro
 -keep public class * implements com.bumptech.glide.module.GlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
     **[] $VALUES;
@@ -65,25 +65,22 @@ Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [jav
 
 Simple use cases will look something like this:
 
-```Java
-
+```java
 // For a simple view:
 @Override
 public void onCreate(Bundle savedInstanceState) {
     ...
-
     ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
 
     Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
 }
 
-// For a list:
+// For a simple image list:
 @Override
 public View getView(int position, View recycled, ViewGroup container) {
     final ImageView myImageView;
     if (recycled == null) {
-        myImageView = (ImageView) inflater.inflate(R.layout.my_image_view,
-                container, false);
+        myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);
     } else {
         myImageView = (ImageView) recycled;
     }
@@ -104,65 +101,66 @@ public View getView(int position, View recycled, ViewGroup container) {
 
 OkHttp and Volley
 -----------------
-Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies. The
-integration libraries are available via Maven or the [releases page][1].
+Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies.
+The integration libraries are available via Maven or the [releases page][1].
 
-For instructions on including either the OkHttp or the Volley integration libraries, see the
-[Integration Libraries][12] wiki page.
+For instructions on including either the OkHttp or the Volley integration libraries, see the [Integration Libraries][12] wiki page.
 
 Android SDK Version
 -------------------
-Glide requires a minimum sdk version of 10.
+Glide requires a minimum SDK version of 10.
 
 License
 -------
-BSD, part MIT and Apache 2.0. See LICENSE file for details.
+BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details.
 
 Status
 ------
-Version 3 is a stable public release used in multiple open source projects at Google including in the Android Camera
-app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!
+[*Version 3*][14] is a stable public release used in multiple open source projects at Google including in the Android Camera
+app and in the 2014 Google IO app. *Version 4* is currently under development on the `master` branch.
+Comments/bugs/questions/pull requests welcome!
 
 Build
-------
+-----
 Building Glide with gradle is fairly straight forward:
 
-```
-git clone git@github.com:bumptech/glide.git
+```shell
+git clone git@github.com:bumptech/glide.git # use https://github.com/bumptech/glide.git if "Permission Denied"
 cd glide
 git submodule init && git submodule update
 ./gradlew jar
 ```
 
-Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment
+**Note**: Make sure your *Android SDK* has the *Android Support Repository* installed, and that your `$ANDROID_HOME` environment
 variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line.
 
 Samples
 -------
-Follow the steps in the 'Build' section to setup the project and then:
+Follow the steps in the [Build](#build) section to setup the project and then:
 
-```
+```shell
 ./gradlew :samples:flickr:run
 ./gradlew :samples:giphy:run
 ./gradlew :samples:svg:run
 ```
+You may also find precompiled APKs on the [releases page][1].
 
 Development
 -----------
-Follow the steps in the 'Build' section to setup the project and then edit the files however you wish.
+Follow the steps in the [Build](#build) section to setup the project and then edit the files however you wish.
 [Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide.
 
 To open the project in Intellij 14:
 
-1. Go to File.
-2. Click on 'Open...'
+1. Go to *File* menu or the *Welcome Screen*
+2. Click on *Open...*
 3. Navigate to Glide's root directory.
-4. Select glide-parent.iml
+4. Select `build.gradle`
 
 Getting Help
 ------------
 To report a specific problem or feature request, [open a new issue on Github][5]. For questions, suggestions, or
-anything else, join or email [Glide's discussion group][6], or join our irc channel: [irc.freenode.net#glide-library][13].
+anything else, join or email [Glide's discussion group][6], or join our IRC channel: [irc.freenode.net#glide-library][13].
 
 Contributing
 ------------
@@ -170,10 +168,10 @@ Before submitting pull requests, contributors must sign Google's [individual con
 
 Thanks
 ------
-* The Android team and Jake Wharton for the [disk cache implementation][8] Glide's disk cache is based on.
-* Dave Smith for the [gif decoder gist][9] Glide's gif decoder is based on.
-* Chris Banes for his [gradle-mvn-push][10] script.
-* Corey Hall for Glide's [amazing logo][11].
+* The **Android team** and **Jake Wharton** for the [disk cache implementation][8] Glide's disk cache is based on.
+* **Dave Smith** for the [gif decoder gist][9] Glide's gif decoder is based on.
+* **Chris Banes** for his [gradle-mvn-push][10] script.
+* **Corey Hall** for Glide's [amazing logo][11].
 * Everyone who has contributed code and reported issues!
 
 Author
@@ -188,7 +186,7 @@ This is not an official Google product.
 [2]: https://github.com/bumptech/glide/wiki
 [3]: http://bumptech.github.io/glide/javadocs/latest/index.html
 [4]: https://www.jetbrains.com/idea/download/
-[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```
+[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
 [7]: https://developers.google.com/open-source/cla/individual
 [8]: https://github.com/JakeWharton/DiskLruCache
@@ -197,3 +195,6 @@ This is not an official Google product.
 [11]: static/glide_logo.png
 [12]: https://github.com/bumptech/glide/wiki/Integration-Libraries
 [13]: http://webchat.freenode.net/?channels=glide-library
+[14]: https://github.com/bumptech/glide/tree/3.0
+[15]: https://github.com/bumptech/glide/tree/master
+[16]: https://github.com/bumptech/glide/blob/master/LICENSE
diff --git a/build.gradle b/build.gradle
index ab3a44b96..72e455faf 100644
--- a/build.gradle
+++ b/build.gradle
@@ -40,11 +40,11 @@ subprojects { project ->
     apply plugin: 'checkstyle'
 
     checkstyle {
-        toolVersion = "6.6"
+        toolVersion = '6.12.1'
     }
 
     checkstyle {
-        configFile = new File(rootDir, 'checkstyle.xml')
+        configFile = rootProject.file('checkstyle.xml')
         configProperties.checkStyleConfigDir = rootProject.rootDir
     }
 
@@ -73,5 +73,6 @@ subprojects { project ->
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.2.1'
+    gradleVersion = '2.9'
+    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
 }
diff --git a/glide/build.gradle b/glide/build.gradle
index cee746200..be3f5da1c 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -44,6 +44,8 @@ def getAndroidJar() {
     "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar"
 }
 
+project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
+
 // Generate javadocs and sources containing batched documentation and sources for all internal projects.
 ['release', 'debug'].each { variantName ->
 
@@ -102,5 +104,3 @@ artifacts {
         classifier 'sources'
     }
 }
-
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
diff --git a/glide/gradle.properties b/glide/gradle.properties
index f205a7f3f..ba722e44c 100644
--- a/glide/gradle.properties
+++ b/glide/gradle.properties
@@ -1,4 +1,3 @@
-POM_NAME=Glide
-POM_ARTIFACT_ID=glide
+POM_NAME=Glide Full
+POM_ARTIFACT_ID=glide-full
 POM_PACKAGING=jar
-
diff --git a/gradle.properties b/gradle.properties
index 2f1163513..6e195cf97 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,8 +1,11 @@
+org.gradle.daemon=true
+org.gradle.configureondemand=true
+org.gradle.parallel=true
+
 VERSION_NAME=4.0.0-SNAPSHOT
 VERSION_MAJOR=4
 VERSION_MINOR=0
 VERSION_PATCH=0
-VERSION_CODE=12
 GROUP=com.github.bumptech.glide
 
 POM_DESCRIPTION=A fast and efficient image loading library for Android focused on smooth scrolling.
@@ -17,7 +20,7 @@ POM_DEVELOPER_EMAIL=judds@google.com
 SUPPORT_V4_VERSION=22.2.0
 SUPPORT_V7_VERSION=22.2.0
 VOLLEY_VERSION=1.0.16
-OK_HTTP_VERSION=2.3.0
+OK_HTTP_VERSION=3.0.1
 # TODO: use this in library/build.gradle.
 ANDROID_GRADLE_VERSION=1.2.3
 
@@ -26,8 +29,8 @@ COVERALLS_GRADLE_VERSION=2.4.0
 JUNIT_VERSION=4.12
 MOCKITO_VERSION=1.10.19
 ROBOLECTRIC_VERSION=3.0-rc3
-MOCKWEBSERVER_VERSION=2.3.0
-TRUTH_VERSION=0.25
+MOCKWEBSERVER_VERSION=3.0.0-RC1
+TRUTH_VERSION=0.26
 
 FINDBUGS_VERSION=3.0.0
 JACOCO_VERSION=0.7.1.201405082137
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index c97a8bdb9..941144813 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 25f7d42d7..63c5ca6b5 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed May 20 08:28:58 PDT 2015
+#Wed Nov 25 12:48:39 CET 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.9-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269e..9d82f7891 100755
--- a/gradlew
+++ b/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -61,9 +56,9 @@ while [ -h "$PRG" ] ; do
     fi
 done
 SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
+cd "`dirname \"$PRG\"`/" >/dev/null
 APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
+cd "$SAVED" >/dev/null
 
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/integration/build.gradle b/integration/build.gradle
index 5467b8ace..d4e8437e3 100644
--- a/integration/build.gradle
+++ b/integration/build.gradle
@@ -1,15 +1 @@
-evaluationDependsOnChildren()
-
-import com.android.build.gradle.api.BaseVariant
-subprojects {
-    android.libraryVariants.all { BaseVariant variant ->
-        def jarTask = project.tasks.create(name: "jar${variant.name.capitalize()}", type: Jar) {
-            from variant.javaCompile.destinationDir
-            exclude "**/R.class"
-            exclude "**/BuildConfig.class"
-            baseName "glide-${project.name}-integration"
-        }
-        jarTask.dependsOn variant.javaCompile
-        artifacts.add('archives', jarTask);
-    }
-}
+// keep an empty file to make sure Gradle recognizes the properties
diff --git a/integration/gifencoder/build.gradle b/integration/gifencoder/build.gradle
index 603500c46..0eddb12b8 100644
--- a/integration/gifencoder/build.gradle
+++ b/integration/gifencoder/build.gradle
@@ -1,12 +1,8 @@
 apply plugin: 'com.android.library'
 apply plugin: 'org.robolectric'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    compile project(':library')
 
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
@@ -30,7 +26,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode = VERSION_CODE as int
         versionName = VERSION_NAME as String
     }
 
@@ -40,4 +35,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/gifencoder/gradle.properties b/integration/gifencoder/gradle.properties
index 15bd7b334..45aef2b4a 100644
--- a/integration/gifencoder/gradle.properties
+++ b/integration/gifencoder/gradle.properties
@@ -9,7 +9,3 @@ VERSION_PATCH=0
 VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library allowing users to re-encode or create animated GIFs
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index 1d104591b..0f9ade749 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -3,6 +3,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
@@ -116,6 +117,8 @@ public void testEncodeStrategy_withEncodeTransformationFalse_returnsSource() {
   @Test
   public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream()
       throws IOException {
+    // Most likely an instance of http://stackoverflow.com/q/991489/253468
+    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, false);
     String expected = "testString";
     byte[] data = expected.getBytes("UTF-8");
@@ -307,6 +310,8 @@ public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed
   @Test
   public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation()
       throws IOException {
+    // Most likely an instance of http://stackoverflow.com/q/991489/253468
+    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));
     when(gifDrawable.getFrameTransformation()).thenReturn(UnitTransformation.<Bitmap>get());
     String expected = "expected";
     when(gifDrawable.getBuffer()).thenReturn(ByteBuffer.wrap(expected.getBytes()));
diff --git a/integration/gradle.properties b/integration/gradle.properties
new file mode 100644
index 000000000..9a3b597f9
--- /dev/null
+++ b/integration/gradle.properties
@@ -0,0 +1,3 @@
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-integration
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index c70aad959..2a48a7443 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -1,13 +1,9 @@
 apply plugin: 'com.android.library'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    compile project(':library')
 
-    compile "com.squareup.okhttp:okhttp:${OK_HTTP_VERSION}"
+    compile "com.squareup.okhttp:okhttp:2.7.1"
 }
 
 android {
@@ -18,7 +14,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -28,4 +23,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/okhttp/gradle.properties b/integration/okhttp/gradle.properties
index 636a1a822..7001e0c1c 100644
--- a/integration/okhttp/gradle.properties
+++ b/integration/okhttp/gradle.properties
@@ -8,8 +8,4 @@ VERSION_MINOR=0
 VERSION_PATCH=0
 VERSION_CODE=8
 
-POM_DESCRIPTION=An integration library to use OkHttp to fetch data over http/https in Glide
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
+POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
index 738e9602d..873c58611 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java
@@ -17,7 +17,10 @@
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
  * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule.
  */
+@Deprecated
 public class OkHttpGlideModule implements GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index 1985ca24a..3fac54a39 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -18,7 +18,10 @@
 
 /**
  * Fetches an {@link InputStream} using the okhttp library.
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpStreamFetcher.
  */
+@Deprecated
 public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "OkHttpFetcher";
   private final OkHttpClient client;
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 05c0fe683..8a55295e1 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -13,7 +13,10 @@
 
 /**
  * A simple model loader for fetching media over http/https using OkHttp.
+ *
+ * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader.
  */
+@Deprecated
 public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
 
   private final OkHttpClient client;
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
new file mode 100644
index 000000000..6ef7599ff
--- /dev/null
+++ b/integration/okhttp3/build.gradle
@@ -0,0 +1,26 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    compile project(':library')
+
+    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    defaultConfig {
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionName VERSION_NAME as String
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/okhttp3/gradle.properties b/integration/okhttp3/gradle.properties
new file mode 100644
index 000000000..477f1f526
--- /dev/null
+++ b/integration/okhttp3/gradle.properties
@@ -0,0 +1,11 @@
+POM_NAME=Glide OkHttp 3.x Integration
+POM_ARTIFACT_ID=okhttp3-integration
+POM_PACKAGING=aar
+
+VERSION_NAME=2.0.0-SNAPSHOT
+VERSION_MAJOR=2
+VERSION_MINOR=0
+VERSION_PATCH=0
+VERSION_CODE=8
+
+POM_DESCRIPTION=An integration library to use OkHttp 3.x to fetch data over http/https in Glide
diff --git a/integration/okhttp3/lint.xml b/integration/okhttp3/lint.xml
new file mode 100644
index 000000000..8b0842417
--- /dev/null
+++ b/integration/okhttp3/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore"/>
+    <!-- See https://github.com/square/okio/issues/58 -->
+    <issue id="InvalidPackage" severity="ignore">
+        <ignore regexp="okio-1.0.0.jar"/>
+    </issue>
+</lint>
diff --git a/integration/okhttp3/src/main/AndroidManifest.xml b/integration/okhttp3/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..bc8e5a72c
--- /dev/null
+++ b/integration/okhttp3/src/main/AndroidManifest.xml
@@ -0,0 +1,9 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.bumptech.glide.integration.okhttp">
+
+    <application>
+        <meta-data
+            android:name="com.bumptech.glide.integration.okhttp3.OkHttpGlideModule"
+            android:value="GlideModule"/>
+    </application>
+</manifest>
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
new file mode 100644
index 000000000..17799b54f
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -0,0 +1,31 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.content.Context;
+
+import com.bumptech.glide.GlideBuilder;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.GlideModule;
+
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader}
+ * with an OkHttp based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p> If you're using gradle, you can include this module simply by depending on the aar, the
+ * module will be merged in by manifest merger. For other build systems or for more more
+ * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ */
+public class OkHttpGlideModule implements GlideModule {
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Do nothing.
+  }
+
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
new file mode 100644
index 000000000..0aa8b2fe3
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -0,0 +1,99 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.util.Log;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.util.ContentLengthInputStream;
+import okhttp3.Call;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Map;
+
+/**
+ * Fetches an {@link InputStream} using the okhttp library.
+ */
+public class OkHttpStreamFetcher implements DataFetcher<InputStream> {
+  private static final String TAG = "OkHttpFetcher";
+  private final Call.Factory client;
+  private final GlideUrl url;
+  private InputStream stream;
+  private ResponseBody responseBody;
+  private volatile Call call;
+
+  public OkHttpStreamFetcher(Call.Factory client, GlideUrl url) {
+    this.client = client;
+    this.url = url;
+  }
+
+  @Override
+  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
+    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
+    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
+      String key = headerEntry.getKey();
+      requestBuilder.addHeader(key, headerEntry.getValue());
+    }
+    Request request = requestBuilder.build();
+
+    call = client.newCall(request);
+    call.enqueue(new okhttp3.Callback() {
+      @Override
+      public void onFailure(Call call, IOException e) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp failed to obtain result", e);
+        }
+        callback.onLoadFailed(e);
+      }
+
+      @Override
+      public void onResponse(Call call, Response response) throws IOException {
+        if (response.isSuccessful()) {
+          long contentLength = response.body().contentLength();
+          responseBody = response.body();
+          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
+        } else if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
+        }
+        callback.onDataReady(stream);
+      }
+    });
+  }
+
+  @Override
+  public void cleanup() {
+    try {
+      if (stream != null) {
+        stream.close();
+      }
+    } catch (IOException e) {
+      // Ignored
+    }
+    if (responseBody != null) {
+      responseBody.close();
+    }
+  }
+
+  @Override
+  public void cancel() {
+    Call local = call;
+    if (local != null) {
+      local.cancel();
+    }
+  }
+
+  @Override
+  public Class<InputStream> getDataClass() {
+    return InputStream.class;
+  }
+
+  @Override
+  public DataSource getDataSource() {
+    return DataSource.REMOTE;
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
new file mode 100644
index 000000000..984000a46
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -0,0 +1,82 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.content.Context;
+
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+
+import java.io.InputStream;
+
+/**
+ * A simple model loader for fetching media over http/https using OkHttp.
+ */
+public class OkHttpUrlLoader implements ModelLoader<GlideUrl, InputStream> {
+
+  private final Call.Factory client;
+
+  public OkHttpUrlLoader(Call.Factory client) {
+    this.client = client;
+  }
+
+  @Override
+  public boolean handles(GlideUrl url) {
+    return true;
+  }
+
+  @Override
+  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,
+      Options options) {
+    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));
+  }
+
+  /**
+   * The default factory for {@link OkHttpUrlLoader}s.
+   */
+  public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
+    private static volatile Call.Factory internalClient;
+    private Call.Factory client;
+
+    private static Call.Factory getInternalClient() {
+      if (internalClient == null) {
+        synchronized (Factory.class) {
+          if (internalClient == null) {
+            internalClient = new OkHttpClient();
+          }
+        }
+      }
+      return internalClient;
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using a static singleton client.
+     */
+    public Factory() {
+      this(getInternalClient());
+    }
+
+    /**
+     * Constructor for a new Factory that runs requests using given client.
+     *
+     * @param client this is typically an instance of {@code OkHttpClient}.
+     */
+    public Factory(Call.Factory client) {
+      this.client = client;
+    }
+
+    @Override
+    public ModelLoader<GlideUrl, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new OkHttpUrlLoader(client);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing, this instance doesn't own the client.
+    }
+  }
+}
diff --git a/integration/recyclerview/build.gradle b/integration/recyclerview/build.gradle
index 854dcefdd..498808a55 100644
--- a/integration/recyclerview/build.gradle
+++ b/integration/recyclerview/build.gradle
@@ -1,11 +1,7 @@
 apply plugin: 'com.android.library'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    compile project(':library')
     compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
 }
@@ -18,7 +14,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -28,4 +23,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/recyclerview/gradle.properties b/integration/recyclerview/gradle.properties
index 06c3c48dc..71a1c55f3 100644
--- a/integration/recyclerview/gradle.properties
+++ b/integration/recyclerview/gradle.properties
@@ -9,7 +9,3 @@ VERSION_PATCH=0
 VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library to display images in RecyclerView.
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index 3a592592b..7c9f79531 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -1,20 +1,16 @@
 apply plugin: 'com.android.library'
 apply plugin: 'org.robolectric'
 
-repositories {
-    mavenCentral()
-}
-
 dependencies {
-    compile project(':glide')
+    compile project(':library')
     compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
 
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
 }
 
 android {
@@ -25,7 +21,6 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
     }
 
@@ -35,4 +30,4 @@ android {
     }
 }
 
-apply from: "$rootProject.projectDir/scripts/upload.gradle"
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/integration/volley/gradle.properties b/integration/volley/gradle.properties
index 0fad11225..3a8aaa76d 100644
--- a/integration/volley/gradle.properties
+++ b/integration/volley/gradle.properties
@@ -9,7 +9,3 @@ VERSION_PATCH=0
 VERSION_CODE=8
 
 POM_DESCRIPTION=An integration library to use Volley to fetch data over http/https in Glide
-
-# Prefix and postfix for source and javadoc jars.
-JAR_PREFIX=glide-
-JAR_POSTFIX=-integration
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index 6adda6f3f..cbf27f64f 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -18,8 +18,8 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 
 import org.junit.After;
 import org.junit.Before;
@@ -97,7 +97,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -109,7 +109,7 @@ public void testHandlesRedirect301s() throws Exception {
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     waitForResponseLatch.await();
@@ -124,7 +124,7 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -162,7 +162,7 @@ public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {
   public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 20; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
     waitForResponseLatch.await();
@@ -202,11 +202,11 @@ public void testAppliesHeadersInGlideUrl() throws Exception {
   }
 
   private DataFetcher<InputStream> getFetcher() {
-    return getFetcher(Headers.NONE);
+    return getFetcher(Headers.DEFAULT);
   }
 
   private DataFetcher<InputStream> getFetcher(Headers headers) {
-    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    URL url = mockWebServer.url(DEFAULT_PATH).url();
     return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));
   }
 
diff --git a/library/build.gradle b/library/build.gradle
index 0b745203f..bde7cf66c 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -25,9 +25,9 @@ dependencies {
     testCompile 'com.google.guava:guava-testlib:18.0'
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
-    testCompile "com.squareup.okhttp:mockwebserver:${MOCKWEBSERVER_VERSION}"
+    testCompile "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
     testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
 }
 
@@ -44,8 +44,9 @@ android {
         minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
-        versionCode VERSION_CODE as int
         versionName VERSION_NAME as String
+
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
@@ -82,6 +83,10 @@ afterEvaluate {
 
     check.dependsOn('findbugs')
 
+    pmd {
+        toolVersion '5.4.0'
+    }
+
     task pmd(type: Pmd) {
         targetJdk = TargetJdk.VERSION_1_7
 
@@ -128,3 +133,15 @@ afterEvaluate {
         }
     }
 }
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
+// exclude <dependency> tag for android support-v4 library from :glide's pom
+// this will ensure that this warning will not prevent the build from completing:
+// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries but is a jar
+// most users will need to override support-v4 version anyway if a newer version is available
+// TODO make support-v4 a <scope>runtime</scope> dependency in pom.xml
+afterEvaluate {
+    uploadArchives.repositories.mavenDeployer.pom.whenConfigured { p ->
+        p.dependencies = p.dependencies.findAll { dep -> dep.artifactId != "support-v4" }
+    }
+}
diff --git a/library/findbugs-exclude.xml b/library/findbugs-exclude.xml
index f929a391d..e9defbbe7 100644
--- a/library/findbugs-exclude.xml
+++ b/library/findbugs-exclude.xml
@@ -36,4 +36,10 @@
        <Bug pattern="DM_DEFAULT_ENCODING" />
     </Match>
 
+    <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->
+    <Match>
+      <Class name="com.bumptech.glide.load.engine.executor.GlideExecutor" />
+      <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
+    </Match>
+
 </FindBugsFilter>
diff --git a/library/gradle.properties b/library/gradle.properties
index 6f3b84292..b361d87c5 100644
--- a/library/gradle.properties
+++ b/library/gradle.properties
@@ -1,3 +1,7 @@
-POM_NAME=Glide Library
-POM_ARTIFACT_ID=library
+POM_NAME=Glide
+POM_ARTIFACT_ID=glide
 POM_PACKAGING=aar
+
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
new file mode 100644
index 000000000..0432be6d2
--- /dev/null
+++ b/library/proguard-rules.txt
@@ -0,0 +1,5 @@
+-keep public class * implements com.bumptech.glide.module.GlideModule
+-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
+    **[] $VALUES;
+    public *;
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index a7ce42d77..8800231ca 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -20,8 +20,10 @@
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.data.InputStreamRewinder;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.prefill.BitmapPreFiller;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
@@ -29,6 +31,7 @@
 import com.bumptech.glide.load.model.ByteArrayLoader;
 import com.bumptech.glide.load.model.ByteBufferEncoder;
 import com.bumptech.glide.load.model.ByteBufferFileLoader;
+import com.bumptech.glide.load.model.DataUrlLoader;
 import com.bumptech.glide.load.model.FileLoader;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.MediaStoreFileLoader;
@@ -60,6 +63,7 @@
 import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder;
 import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
 import com.bumptech.glide.module.GlideModule;
 import com.bumptech.glide.module.ManifestParser;
@@ -92,7 +96,9 @@
   private final BitmapPreFiller bitmapPreFiller;
   private final GlideContext glideContext;
   private final Registry registry;
+  private final ArrayPool arrayPool;
   private final ByteArrayPool byteArrayPool;
+  private final ConnectivityMonitorFactory connectivityMonitorFactory;
   private final List<RequestManager> managers = new ArrayList<>();
 
   /**
@@ -165,12 +171,21 @@ static void tearDown() {
   }
 
   @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,
-      Context context, int logLevel, RequestOptions defaultRequestOptions) {
+  Glide(
+      Context context,
+      Engine engine,
+      MemoryCache memoryCache,
+      BitmapPool bitmapPool,
+      ArrayPool arrayPool,
+      ConnectivityMonitorFactory connectivityMonitorFactory,
+      int logLevel,
+      RequestOptions defaultRequestOptions) {
     this.engine = engine;
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
+    this.arrayPool = arrayPool;
     this.memoryCache = memoryCache;
+    this.connectivityMonitorFactory = connectivityMonitorFactory;
+    this.byteArrayPool = new LruByteArrayPool();
 
     DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
     bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
@@ -179,8 +194,8 @@ static void tearDown() {
 
     Downsampler downsampler =
         new Downsampler(resources.getDisplayMetrics(), bitmapPool, byteArrayPool);
-    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,
-        byteArrayPool);
+    ByteBufferGifDecoder byteBufferGifDecoder =
+        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);
     registry = new Registry(context)
         .register(ByteBuffer.class, new ByteBufferEncoder())
         .register(InputStream.class, new StreamEncoder(byteArrayPool))
@@ -223,6 +238,7 @@ static void tearDown() {
         .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory())
         .append(Integer.class, ParcelFileDescriptor.class,
             new ResourceLoader.FileDescriptorFactory())
+        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
@@ -276,6 +292,14 @@ public ByteArrayPool getByteArrayPool() {
     return byteArrayPool;
   }
 
+  public ArrayPool getArrayPool() {
+    return arrayPool;
+  }
+
+  ConnectivityMonitorFactory getConnectivityMonitorFactory() {
+    return connectivityMonitorFactory;
+  }
+
   GlideContext getGlideContext() {
     return glideContext;
   }
@@ -316,9 +340,12 @@ public void preFillBitmapPool(PreFillType.Builder... bitmapAttributeBuilders) {
    * @see android.content.ComponentCallbacks2#onLowMemory()
    */
   public void clearMemory() {
-    bitmapPool.clearMemory();
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be cleared before bitmap pool to clear re-pooled Bitmaps too. See #687.
     memoryCache.clearMemory();
-    byteArrayPool.clearMemory();
+    bitmapPool.clearMemory();
+    arrayPool.clearMemory();
   }
 
   /**
@@ -327,9 +354,12 @@ public void clearMemory() {
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
    */
   public void trimMemory(int level) {
-    bitmapPool.trimMemory(level);
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.trimMemory(level);
-    byteArrayPool.trimMemory(level);
+    bitmapPool.trimMemory(level);
+    arrayPool.trimMemory(level);
   }
 
   /**
@@ -355,6 +385,9 @@ public void clearDiskCache() {
    * to change the default. </p>
    */
   public void setMemoryCategory(MemoryCategory memoryCategory) {
+    // Engine asserts this anyway when removing resources, fail faster and consistently
+    Util.assertMainThread();
+    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.
     memoryCache.setSizeMultiplier(memoryCategory.getMultiplier());
     bitmapPool.setSizeMultiplier(memoryCategory.getMultiplier());
   }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 5f29cad0e..445507323 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -6,17 +6,19 @@
 
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.InternalCacheDiskCacheFactory;
 import com.bumptech.glide.load.engine.cache.LruResourceCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.cache.MemorySizeCalculator;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.manager.ConnectivityMonitorFactory;
+import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
 import com.bumptech.glide.request.RequestOptions;
 
 /**
@@ -27,12 +29,13 @@
 
   private Engine engine;
   private BitmapPool bitmapPool;
-  private ByteArrayPool byteArrayPool;
+  private ArrayPool arrayPool;
   private MemoryCache memoryCache;
   private GlideExecutor sourceExecutor;
   private GlideExecutor diskCacheExecutor;
   private DiskCache.Factory diskCacheFactory;
   private MemorySizeCalculator memorySizeCalculator;
+  private ConnectivityMonitorFactory connectivityMonitorFactory;
   private int logLevel = Log.INFO;
   private RequestOptions defaultRequestOptions = new RequestOptions();
 
@@ -53,14 +56,14 @@ public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
   }
 
   /**
-   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored
+   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored
    * and retrieved as needed.
    *
-   * @param byteArrayPool The pool to use.
+   * @param arrayPool The pool to use.
    * @return This builder.
    */
-  public GlideBuilder setByteArrayPool(ByteArrayPool byteArrayPool) {
-    this.byteArrayPool = byteArrayPool;
+  public GlideBuilder setArrayPool(ArrayPool arrayPool) {
+    this.arrayPool = arrayPool;
     return this;
   }
 
@@ -205,6 +208,19 @@ public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {
     return this;
   }
 
+  /**
+   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory}
+   * to use to notify {@link com.bumptech.glide.RequestManager} of connectivity events.
+   * If not set {@link com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used.
+   *
+   * @param factory The factory to use
+   * @return This builder.
+   */
+  public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory factory) {
+    this.connectivityMonitorFactory = factory;
+    return this;
+  }
+
   /**
    * Sets a log level constant from those in {@link Log} to indicate the desired log verbosity.
    *
@@ -247,17 +263,20 @@ GlideBuilder setEngine(Engine engine) {
 
   Glide createGlide() {
     if (sourceExecutor == null) {
-      final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());
-      sourceExecutor = new GlideExecutor("source", cores);
+      sourceExecutor = GlideExecutor.newSourceExecutor();
     }
     if (diskCacheExecutor == null) {
-      diskCacheExecutor = new GlideExecutor("disk-cache", 1);
+      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
 
     if (memorySizeCalculator == null) {
       memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
     }
 
+    if (connectivityMonitorFactory == null) {
+      connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();
+    }
+
     if (bitmapPool == null) {
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
         int size = memorySizeCalculator.getBitmapPoolSize();
@@ -267,8 +286,8 @@ Glide createGlide() {
       }
     }
 
-    if (byteArrayPool == null) {
-      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());
+    if (arrayPool == null) {
+      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
     }
 
     if (memoryCache == null) {
@@ -283,7 +302,14 @@ Glide createGlide() {
       engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor);
     }
 
-    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, logLevel,
+    return new Glide(
+        context,
+        engine,
+        memoryCache,
+        bitmapPool,
+        arrayPool,
+        connectivityMonitorFactory,
+        logLevel,
         defaultRequestOptions.lock());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index b44e50b6e..c8766199c 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -37,7 +37,7 @@
 public class RequestBuilder<TranscodeType> implements Cloneable {
   private static final TransitionOptions<?, ?> DEFAULT_ANIMATION_OPTIONS =
       new GenericTransitionOptions<Object>();
-  private static final BaseRequestOptions DOWNLOAD_ONLY_OPTIONS =
+  private static final BaseRequestOptions<?> DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
@@ -77,7 +77,14 @@
     this.requestOptions = defaultRequestOptions;
   }
 
-  public RequestBuilder<TranscodeType> apply(BaseRequestOptions requestOptions) {
+  /**
+   * Applies the given options to the request, options set or unset in the given options will
+   * replace those previously set in options in this class.
+   *
+   * @see BaseRequestOptions#apply(BaseRequestOptions)
+   * @return This request builder.
+   */
+  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
     Preconditions.checkNotNull(requestOptions);
     BaseRequestOptions<?> toMutate = defaultRequestOptions == this.requestOptions
         ? this.requestOptions.clone() : this.requestOptions;
@@ -85,8 +92,17 @@
     return this;
   }
 
+  /**
+   * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
+   * this load completes.
+   *
+   * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set
+   * previously.
+   *
+   * @return This request builder.
+   */
   public RequestBuilder<TranscodeType> transition(
-      TransitionOptions<?, ? super TranscodeType> transitionOptions) {
+      @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {
     this.transitionOptions = Preconditions.checkNotNull(transitionOptions);
     return this;
   }
@@ -328,11 +344,9 @@
    * @return The given target.
    * @see RequestManager#clear(Target)
    */
-  public <Y extends Target<TranscodeType>> Y into(Y target) {
+  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
     Util.assertMainThread();
-    if (target == null) {
-      throw new IllegalArgumentException("You must pass in a non null Target");
-    }
+    Preconditions.checkNotNull(target);
     if (!isModelSet) {
       throw new IllegalArgumentException("You must call #load() before calling #into()");
     }
@@ -364,11 +378,11 @@
    */
   public Target<TranscodeType> into(ImageView view) {
     Util.assertMainThread();
-    if (view == null) {
-      throw new IllegalArgumentException("You must pass in a non null View");
-    }
+    Preconditions.checkNotNull(view);
 
-    if (!requestOptions.isTransformationSet() && view.getScaleType() != null) {
+    if (!requestOptions.isTransformationSet()
+        && requestOptions.isTransformationAllowed()
+        && view.getScaleType() != null) {
       if (requestOptions.isLocked()) {
         requestOptions = requestOptions.clone();
       }
@@ -376,6 +390,9 @@
         case CENTER_CROP:
           requestOptions.optionalCenterCrop(context);
           break;
+        case CENTER_INSIDE:
+          requestOptions.optionalCenterInside(context);
+          break;
         case FIT_CENTER:
         case FIT_START:
         case FIT_END:
@@ -523,7 +540,7 @@ public void run() {
    */
   @Deprecated
   public FutureTarget<File> downloadOnly(int width, int height) {
-    return getDownloadOnlyRequest().into(width, height);
+    return getDownloadOnlyRequest().submit(width, height);
   }
 
   private RequestBuilder<File> getDownloadOnlyRequest() {
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 40078f8b7..18ebfb427 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -73,7 +73,8 @@ public void run() {
   private BaseRequestOptions<?> requestOptions;
 
   public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
-    this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());
+    this(context, lifecycle, treeNode,
+        new RequestTracker(), Glide.get(context).getConnectivityMonitorFactory());
   }
 
   RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index 99a177abc..f8fdd6d37 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -24,7 +24,7 @@ public MultiTransformation(Transformation<T>... transformations) {
   }
 
   public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {
-    if (transformationList.size() < 1) {
+    if (transformationList.isEmpty()) {
       throw new IllegalArgumentException(
           "MultiTransformation must contain at least one Transformation");
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/Option.java b/library/src/main/java/com/bumptech/glide/load/Option.java
index 04a03e5b6..e3b70a8c4 100644
--- a/library/src/main/java/com/bumptech/glide/load/Option.java
+++ b/library/src/main/java/com/bumptech/glide/load/Option.java
@@ -142,6 +142,8 @@ public String toString() {
   /**
    * An interface that updates a {@link MessageDigest} with the given value as part of a process to
    * generate a disk cache key.
+   *
+   * @param <T> The type of the option.
    */
   public interface CacheKeyUpdater<T> {
     /**
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 76a9ea297..489892e3b 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -2,6 +2,7 @@
 
 import android.content.ContentResolver;
 import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 
@@ -19,7 +20,11 @@ public FileDescriptorLocalUriFetcher(Context context, Uri uri) {
   @Override
   protected ParcelFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    return contentResolver.openAssetFileDescriptor(uri, "r").getParcelFileDescriptor();
+    AssetFileDescriptor assetFileDescriptor = contentResolver.openAssetFileDescriptor(uri, "r");
+    if (assetFileDescriptor == null) {
+      throw new FileNotFoundException("FileDescriptor is null for: " + uri);
+    }
+    return assetFileDescriptor.getParcelFileDescriptor();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index aafdc25aa..0704a922a 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -19,7 +19,11 @@ public StreamLocalUriFetcher(Context context, Uri uri) {
   @Override
   protected InputStream loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    return contentResolver.openInputStream(uri);
+    InputStream inputStream = contentResolver.openInputStream(uri);
+    if (inputStream == null) {
+      throw new FileNotFoundException("InputStream is null for :" + uri);
+    }
+    return inputStream;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index 285e5fe3e..3a010fed0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -137,7 +137,7 @@ boolean hasLoadPath(Class<?> dataClass) {
   <Z> Transformation<Z> getTransformation(Class<Z> resourceClass) {
     Transformation<Z> result = (Transformation<Z>) transformations.get(resourceClass);
      if (result == null) {
-      if (!transformations.isEmpty() && isTransformationRequired) {
+      if (transformations.isEmpty() && isTransformationRequired) {
         throw new IllegalArgumentException(
             "Missing transformation for " + resourceClass + ". If you wish to"
                 + " ignore unknown resource types, use the optional transformation methods.");
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
index 0633c1c16..b110e3121 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java
@@ -93,7 +93,7 @@ public boolean decodeCachedData() {
   public static final DiskCacheStrategy RESOURCE = new DiskCacheStrategy() {
     @Override
     public boolean isDataCacheable(DataSource dataSource) {
-      return true;
+      return false;
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index 070017e78..5ae6da255 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.engine;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 import com.bumptech.glide.load.DataSource;
@@ -178,6 +180,7 @@ private static void appendCausesWrapped(List<Exception> causes, Appendable appen
   }
 
   private static final class IndentedAppendable implements Appendable {
+    private static final String EMPTY_SEQUENCE = "";
     private static final String INDENT = "  ";
     private final Appendable appendable;
     private boolean printedNewLine = true;
@@ -198,19 +201,31 @@ public Appendable append(char c) throws IOException {
     }
 
     @Override
-    public Appendable append(CharSequence charSequence) throws IOException {
+    public Appendable append(@Nullable CharSequence charSequence) throws IOException {
+      charSequence = safeSequence(charSequence);
       return append(charSequence, 0, charSequence.length());
     }
 
     @Override
-    public Appendable append(CharSequence csq, int start, int end) throws IOException {
+    public Appendable append(@Nullable CharSequence charSequence, int start, int end)
+        throws IOException {
+      charSequence = safeSequence(charSequence);
       if (printedNewLine) {
         printedNewLine = false;
         appendable.append(INDENT);
       }
-      printedNewLine = csq.length() > 0 && csq.charAt(end - 1) == '\n';
-      appendable.append(csq, start, end);
+      printedNewLine = charSequence.length() > 0 && charSequence.charAt(end - 1) == '\n';
+      appendable.append(charSequence, start, end);
       return this;
     }
+
+    @NonNull
+    private CharSequence safeSequence(@Nullable CharSequence sequence) {
+      if (sequence == null) {
+        return EMPTY_SEQUENCE;
+      } else {
+        return sequence;
+      }
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
index 65c0decd0..0801cd92b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java
@@ -40,6 +40,9 @@ public ResourceCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
   @Override
   public boolean startNext() {
     List<Key> sourceIds = helper.getCacheKeys();
+    if (sourceIds.isEmpty()) {
+      return false;
+    }
     List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
     while (modelLoaders == null || !hasNextModelLoader()) {
       resourceClassIndex++;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
index ea3f11714..f6221fa1d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java
@@ -4,6 +4,7 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.util.LruCache;
+import com.bumptech.glide.util.Util;
 
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
@@ -37,10 +38,10 @@ public boolean equals(Object o) {
     if (o instanceof ResourceCacheKey) {
       ResourceCacheKey other = (ResourceCacheKey) o;
       return height == other.height && width == other.width
-          && (transformation == null
-              ? other.transformation == null : transformation.equals(other.transformation))
+          && Util.bothNullOrEqual(transformation, other.transformation)
           && decodedResourceClass.equals(other.decodedResourceClass)
-          && sourceKey.equals(other.sourceKey) && signature.equals(other.signature)
+          && sourceKey.equals(other.sourceKey)
+          && signature.equals(other.signature)
           && options.equals(other.options);
     }
     return false;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
new file mode 100644
index 000000000..048a43247
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -0,0 +1,32 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+/**
+ * Interface for handling operations on a primitive array type.
+ * @param <T> Array type (eg byte[], int[])
+ */
+public interface ArrayAdapterInterface<T> {
+
+  /**
+   * TAG for logging.
+   */
+  String getTag();
+
+  /**
+   * Return the length of the given array.
+   */
+  int getArrayLength(T array);
+
+  /**
+   * Reset the array for re-use (e.g. set all values to 0).
+   */
+  void resetArray(T array);
+
+  /**
+   * Allocate and return an array of the specified size.
+   */
+  T newArray(int length);
+
+  /**
+   * Return the size of an element in the array in bytes (e.g. for int return 4).
+   */
+  int getElementSizeInBytes();
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
new file mode 100644
index 000000000..a945ca874
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -0,0 +1,33 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+/**
+ * Interface for an array pool that pools arrays of different types.
+ */
+public interface ArrayPool {
+  /**
+   * Optionally adds the given array of the given type to the pool.
+   *
+   * <p>Arrays may be ignored, for example if the array is larger than the maximum size of the
+   * pool.
+   */
+  <T> void put(T array, Class<T> arrayClass);
+
+  /**
+   * Returns a non-null array of the given type with a length >= to the given size.
+   *
+   * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   */
+  <T> T get(int size, Class<T> arrayClass);
+  /**
+   * Clears all arrays from the pool.
+   */
+  void clearMemory();
+
+  /**
+   * Trims the size to the appropriate level.
+   *
+   * @param level A trim specified in {@link android.content.ComponentCallbacks2}.
+   */
+  void trimMemory(int level);
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
new file mode 100644
index 000000000..96a79def3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import java.util.Arrays;
+
+/**
+ * Adapter for handling primitive byte arrays.
+ */
+@SuppressWarnings("PMD.UseVarargs")
+public final class ByteArrayAdapter implements ArrayAdapterInterface<byte[]> {
+  private static final String TAG = "ByteArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(byte[] array) {
+    return array.length;
+  }
+
+  @Override
+  public void resetArray(byte[] array) {
+    Arrays.fill(array, (byte) 0);
+  }
+
+  @Override
+  public byte[] newArray(int length) {
+    return new byte[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 1;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
index 0213653b8..df88773ff 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayPool.java
@@ -2,6 +2,7 @@
 
 /**
  * Pool containing byte[] arrays of various sizes.
+ * TODO: this should be replaced with an ArrayPool
  */
 public interface ByteArrayPool {
   /**
@@ -24,16 +25,4 @@
    * <p>If an array of the given size isn't in the pool, a new one will be allocated.
    */
   byte[] get(int size);
-
-  /**
-   * Clears all byte arrays from the pool.
-   */
-  void clearMemory();
-
-  /**
-   * Trims the size to the appropriate level.
-   *
-   * @param level A trim specified in {@link android.content.ComponentCallbacks2}.
-   */
-  void trimMemory(int level);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
new file mode 100644
index 000000000..e6f8129be
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -0,0 +1,36 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import java.util.Arrays;
+
+/**
+ * Adapter for handling primitive int arrays.
+ */
+@SuppressWarnings("PMD.UseVarargs")
+public final class IntegerArrayAdapter implements ArrayAdapterInterface<int[]> {
+  private static final String TAG = "IntegerArrayPool";
+
+  @Override
+  public String getTag() {
+    return TAG;
+  }
+
+  @Override
+  public int getArrayLength(int[] array) {
+    return array.length;
+  }
+
+  @Override
+  public void resetArray(int[] array) {
+    Arrays.fill(array, 0);
+  }
+
+  @Override
+  public int[] newArray(int length) {
+    return new int[length];
+  }
+
+  @Override
+  public int getElementSizeInBytes() {
+    return 4;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
new file mode 100644
index 000000000..10f17c25f
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -0,0 +1,252 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+
+/**
+ * A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under
+ * the maximum byte size.
+ */
+public final class LruArrayPool implements ArrayPool {
+
+  /**
+   * The maximum number of times larger an int array may be to be than a requested size to eligble
+   * to be returned from the pool.
+   */
+  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
+  /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
+  private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
+
+  private final GroupedLinkedMap<Key, Object> groupedMap = new GroupedLinkedMap<>();
+  private final KeyPool keyPool = new KeyPool();
+  private final Map<Class, NavigableMap<Integer, Integer>> sortedSizes = new HashMap<>();
+  private final Map<Class, ArrayAdapterInterface> adapters = new HashMap<>();
+  private final int maxSize;
+  private int currentSize;
+
+  /**
+   * Constructor for a new pool.
+   *
+   * @param maxSize The maximum size in integers of the pool.
+   */
+  public LruArrayPool(int maxSize) {
+    this.maxSize = maxSize;
+  }
+
+  @Override
+  public synchronized <T> void put(T array, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    int size = arrayAdapter.getArrayLength(array);
+    if (!isSmallEnoughForReuse(size)) {
+      return;
+    }
+    Key key = keyPool.get(size, arrayClass);
+
+    groupedMap.put(key, array);
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(key.size);
+    sizes.put(key.size, current == null ? 1 : current + 1);
+    currentSize += size * arrayAdapter.getElementSizeInBytes();
+    evict();
+  }
+
+  @Override
+  public <T> T get(int size, Class<T> arrayClass) {
+    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
+    T result;
+    synchronized (this) {
+      Integer possibleSize = getSizesForAdapter(arrayClass).ceilingKey(size);
+      final Key key;
+      if (mayFillRequest(size, possibleSize)) {
+        key = keyPool.get(possibleSize, arrayClass);
+      } else {
+        key = keyPool.get(size, arrayClass);
+      }
+
+      result = getArrayForKey(key);
+      if (result != null) {
+        currentSize -= arrayAdapter.getArrayLength(result) * arrayAdapter.getElementSizeInBytes();
+        decrementArrayOfSize(arrayAdapter.getArrayLength(result), arrayClass);
+      }
+    }
+
+    if (result != null) {
+      arrayAdapter.resetArray(result);
+    } else {
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
+      }
+      result = arrayAdapter.newArray(size);
+    }
+    return result;
+  }
+
+  @SuppressWarnings("unchecked")
+  @Nullable
+  private <T> T getArrayForKey(Key key) {
+    return (T) groupedMap.get(key);
+  }
+
+  private boolean isSmallEnoughForReuse(int intSize) {
+    return intSize <= maxSize / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
+  }
+
+  private boolean mayFillRequest(int requestedSize, Integer actualSize) {
+    return actualSize != null
+        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));
+  }
+
+  private boolean isNoMoreThanHalfFull() {
+    return currentSize == 0 || (maxSize / currentSize >= 2);
+  }
+
+  @Override
+  public synchronized void clearMemory() {
+    evictToSize(0);
+  }
+
+  @Override
+  public synchronized void trimMemory(int level) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+      clearMemory();
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+      evictToSize(maxSize / 2);
+    }
+  }
+
+  private void evict() {
+    evictToSize(maxSize);
+  }
+
+  private void evictToSize(int size) {
+    while (currentSize > size) {
+      Object evicted = groupedMap.removeLast();
+      Preconditions.checkNotNull(evicted);
+      ArrayAdapterInterface<Object> arrayAdapter = getAdapterFromObject(evicted);
+      currentSize -= arrayAdapter.getArrayLength(evicted) * arrayAdapter.getElementSizeInBytes();
+      decrementArrayOfSize(arrayAdapter.getArrayLength(evicted), evicted.getClass());
+      if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
+        Log.v(arrayAdapter.getTag(), "evicted: " + arrayAdapter.getArrayLength(evicted));
+      }
+    }
+  }
+
+  private void decrementArrayOfSize(int size, Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
+    Integer current = sizes.get(size);
+    if (current == null) {
+      throw new NullPointerException(
+          "Tried to decrement empty size" + ", size: " + size + ", this: " + this);
+    }
+    if (current == 1) {
+      sizes.remove(size);
+    } else {
+      sizes.put(size, current - 1);
+    }
+  }
+
+  private NavigableMap<Integer, Integer> getSizesForAdapter(Class<?> arrayClass) {
+    NavigableMap<Integer, Integer> sizes = sortedSizes.get(arrayClass);
+    if (sizes == null) {
+      sizes = new TreeMap<>();
+      sortedSizes.put(arrayClass, sizes);
+    }
+    return sizes;
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromObject(T object) {
+    return (ArrayAdapterInterface<T>) getAdapterFromType(object.getClass());
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T> ArrayAdapterInterface<T> getAdapterFromType(Class<T> arrayPoolClass) {
+    ArrayAdapterInterface adapter = adapters.get(arrayPoolClass);
+    if (adapter == null) {
+      if (arrayPoolClass.equals(int[].class)) {
+        adapter = new IntegerArrayAdapter();
+      } else if (arrayPoolClass.equals(byte[].class)) {
+        adapter = new ByteArrayAdapter();
+      } else {
+          throw new IllegalArgumentException("No array pool found for: "
+              + arrayPoolClass.getSimpleName());
+      }
+      adapters.put(arrayPoolClass, adapter);
+    }
+    return adapter;
+  }
+
+  // VisibleForTesting
+  int getCurrentSize() {
+    int currentSize = 0;
+    for (Class<?> type : sortedSizes.keySet()) {
+      for (Integer size : sortedSizes.get(type).keySet()) {
+        ArrayAdapterInterface<?> adapter = getAdapterFromType(type);
+        currentSize += size * sortedSizes.get(type).get(size) * adapter.getElementSizeInBytes();
+      }
+    }
+    return currentSize;
+  }
+
+  private static final class KeyPool extends BaseKeyPool<Key> {
+
+    Key get(int size, Class arrayClass) {
+      Key result = get();
+      result.init(size, arrayClass);
+      return result;
+    }
+
+    @Override
+    protected Key create() {
+      return new Key(this);
+    }
+  }
+
+  private static final class Key implements Poolable {
+    private final KeyPool pool;
+    private int size;
+    private Class arrayClass;
+
+    Key(KeyPool pool) {
+      this.pool = pool;
+    }
+
+    void init(int length, Class arrayClass) {
+      this.size = length;
+      this.arrayClass = arrayClass;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Key) {
+        Key other = (Key) o;
+        return size == other.size && arrayClass == other.arrayClass;
+      }
+      return false;
+    }
+
+    @Override
+    public String toString() {
+      return "Key{" + "size=" + size + "array=" + arrayClass + '}';
+    }
+
+    @Override
+    public void offer() {
+      pool.offer(this);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = size;
+      result = 31 * result + (arrayClass != null ? arrayClass.hashCode() : 0);
+      return result;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 754544bea..8edb0f23c 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -201,9 +201,9 @@ public void trimMemory(int level) {
     if (Log.isLoggable(TAG, Log.DEBUG)) {
       Log.d(TAG, "trimMemory, level=" + level);
     }
-    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
       trimToSize(maxSize / 2);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
index dd6d5dc68..957a550df 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruByteArrayPool.java
@@ -1,195 +1,32 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import android.util.Log;
-
-import java.util.Arrays;
-import java.util.TreeMap;
-
 /**
  * A fixed size LruByteArrayPool that evicts arrays using an LRU strategy to keep the pool under
  * the maximum byte size.
+ *
+ * TODO: update Glide to use ArrayPool<byte[]> instead.
  */
 public final class LruByteArrayPool implements ByteArrayPool {
-  private static final String TAG = "LruBytesPool";
   // 4MB.
-  private static final int DEFAULT_SIZE = 4 * 1024 * 1024;
-  /**
-   * The maximum number of times larger a byte array may be to be than a requested size to eligble
-   * to be returned from the pool.
-   */
-  private static final int MAX_OVER_SIZE_MULTIPLE = 8;
-  /** Used to calculate the maximum % of the total pool size a single byte array may consume. */
-  private static final int SINGLE_ARRAY_MAX_SIZE_DIVISOR = 2;
-  private final GroupedLinkedMap<Key, byte[]> groupedMap = new GroupedLinkedMap<>();
-  private final KeyPool keyPool = new KeyPool();
-  private final TreeMap<Integer, Integer> sortedSizes = new TreeMap<>();
-  private final int maxSizeBytes;
+  static final int DEFAULT_SIZE = 4 * 1024 * 1024;
 
-  private int currentSizeBytes;
+  private final ArrayPool arrayPool;
 
-  /**
-   * Constructor for a new pool with a standard size.
-   */
   public LruByteArrayPool() {
     this(DEFAULT_SIZE);
   }
 
-  /**
-   * Constructor for a new pool.
-   *
-   * @param maxSizeBytes The maximum size in bytes of the pool.
-   */
-  public LruByteArrayPool(int maxSizeBytes) {
-    this.maxSizeBytes = maxSizeBytes;
+  public LruByteArrayPool(int maxSize) {
+    this.arrayPool = new LruArrayPool(maxSize);
   }
 
   @Override
   public synchronized void put(byte[] bytes) {
-    int size = bytes.length;
-    if (!isSmallEnoughForReuse(size)) {
-      return;
-    }
-    Key key = keyPool.get(size);
-
-    groupedMap.put(key, bytes);
-    Integer current = sortedSizes.get(size);
-    sortedSizes.put(size, current == null ? 1 : current + 1);
-    currentSizeBytes += size;
-    evict();
+    arrayPool.put(bytes, byte[].class);
   }
 
   @Override
   public byte[] get(int size) {
-    byte[] result;
-    synchronized (this) {
-      Integer possibleSize = sortedSizes.ceilingKey(size);
-      final Key key;
-      if (mayFillRequest(size, possibleSize)) {
-        key = keyPool.get(possibleSize);
-      } else {
-        key = keyPool.get(size);
-      }
-
-      result = groupedMap.get(key);
-      if (result != null) {
-        currentSizeBytes -= result.length;
-        decrementByteArrayOfSize(result.length);
-      }
-    }
-
-    if (result != null) {
-      Arrays.fill(result, (byte) 0);
-    } else {
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Allocated " + size + " bytes");
-      }
-      result = new byte[size];
-    }
-
-    return result;
-  }
-
-  private boolean isSmallEnoughForReuse(int byteSize) {
-    return byteSize <= maxSizeBytes / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
-  }
-
-  private boolean mayFillRequest(int requestedSize, Integer actualSize) {
-    return actualSize != null
-        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));
-  }
-
-  private boolean isNoMoreThanHalfFull() {
-    return currentSizeBytes == 0 || (maxSizeBytes / currentSizeBytes >= 2);
-  }
-
-  @Override
-  public synchronized void clearMemory() {
-    evictToSize(0);
-  }
-
-  @Override
-  public synchronized void trimMemory(int level) {
-     if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
-      clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
-      evictToSize(maxSizeBytes / 2);
-    }
-  }
-
-  private void evict() {
-    evictToSize(maxSizeBytes);
-  }
-
-  private void evictToSize(int size) {
-    while (currentSizeBytes > size) {
-      byte[] evicted = groupedMap.removeLast();
-      currentSizeBytes -= evicted.length;
-      decrementByteArrayOfSize(evicted.length);
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "evicted: " + evicted.length);
-      }
-    }
-  }
-
-  private void decrementByteArrayOfSize(int size) {
-    Integer current = sortedSizes.get(size);
-    if (current == 1) {
-      sortedSizes.remove(current);
-    } else {
-      sortedSizes.put(size, current - 1);
-    }
-  }
-
-  private static final class KeyPool extends BaseKeyPool<Key> {
-
-    Key get(int size) {
-      Key result = get();
-      result.init(size);
-      return result;
-    }
-
-    @Override
-    protected Key create() {
-      return new Key(this);
-    }
-  }
-
-  private static final class Key implements Poolable {
-    private final KeyPool pool;
-    private int size;
-
-    Key(KeyPool pool) {
-      this.pool = pool;
-    }
-
-    void init(int length) {
-      this.size = length;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof Key) {
-        Key other = (Key) o;
-        return size == other.size;
-      }
-      return false;
-    }
-
-    @Override
-    public int hashCode() {
-      return size;
-    }
-
-    @Override
-    public String toString() {
-      return "Key{"
-          + "size=" + size
-          + '}';
-    }
-
-    @Override
-    public void offer() {
-      pool.offer(this);
-    }
+    return arrayPool.get(size, byte[].class);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
index 0a011dbc3..4e9dbdd2e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java
@@ -213,7 +213,7 @@ public boolean equals(Object o) {
       if (o instanceof Key) {
         Key other = (Key) o;
         return size == other.size
-            && (config == null ? other.config == null : config.equals(other.config));
+            && Util.bothNullOrEqual(config, other.config);
       }
       return false;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
index 82391d42a..455204dca 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java
@@ -41,11 +41,11 @@ protected int getSize(Resource<?> item) {
   @SuppressLint("InlinedApi")
   @Override
   public void trimMemory(int level) {
-    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {
+    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
       // Nearing middle of list of cached background apps
       // Evict our entire bitmap cache
       clearMemory();
-    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
+    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
       // Entering list of cached background apps
       // Evict oldest half of our bitmap cache
       trimToSize(getCurrentSize() / 2);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index 6156e8802..49ee8459b 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -23,7 +23,7 @@
   private final int bitmapPoolSize;
   private final int memoryCacheSize;
   private final Context context;
-  private final int byteArrayPoolSize;
+  private final int arrayPoolSize;
 
   interface ScreenDimensions {
     int getWidthPixels();
@@ -32,10 +32,12 @@
 
   MemorySizeCalculator(Context context, ActivityManager activityManager,
       ScreenDimensions screenDimensions, float memoryCacheScreens, float bitmapPoolScreens,
-      int targetByteArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
+      int targetArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {
     this.context = context;
-    byteArrayPoolSize = isLowMemoryDevice(activityManager)
-        ? targetByteArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR : targetByteArrayPoolSize;
+    arrayPoolSize =
+        isLowMemoryDevice(activityManager)
+            ? targetArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR
+            : targetArrayPoolSize;
     final int maxSize = getMaxSize(activityManager, maxSizeMultiplier, lowMemoryMaxSizeMultiplier);
 
     final int screenSize = screenDimensions.getWidthPixels() * screenDimensions.getHeightPixels()
@@ -43,7 +45,7 @@
 
     int targetPoolSize = Math.round(screenSize * bitmapPoolScreens);
     int targetMemoryCacheSize = Math.round(screenSize * memoryCacheScreens);
-    int availableSize = maxSize - byteArrayPoolSize;
+    int availableSize = maxSize - arrayPoolSize;
 
     if (targetMemoryCacheSize + targetPoolSize <= availableSize) {
       memoryCacheSize = targetMemoryCacheSize;
@@ -55,14 +57,23 @@
     }
 
     if (Log.isLoggable(TAG, Log.DEBUG)) {
-      Log.d(TAG, "Calculation complete"
-          + ", Calculated memory cache size: " + toMb(memoryCacheSize)
-          + ", pool size: " + toMb(bitmapPoolSize)
-          + ", byte array size: " + toMb(byteArrayPoolSize)
-          + ", memory class limited? " + (targetMemoryCacheSize + targetPoolSize > maxSize)
-          + ", max size: " + toMb(maxSize)
-          + ", memoryClass: " + activityManager.getMemoryClass()
-          + ", isLowMemoryDevice: " + isLowMemoryDevice(activityManager));
+      Log.d(
+          TAG,
+          "Calculation complete"
+              + ", Calculated memory cache size: "
+              + toMb(memoryCacheSize)
+              + ", pool size: "
+              + toMb(bitmapPoolSize)
+              + ", byte array size: "
+              + toMb(arrayPoolSize)
+              + ", memory class limited? "
+              + (targetMemoryCacheSize + targetPoolSize > maxSize)
+              + ", max size: "
+              + toMb(maxSize)
+              + ", memoryClass: "
+              + activityManager.getMemoryClass()
+              + ", isLowMemoryDevice: "
+              + isLowMemoryDevice(activityManager));
     }
   }
 
@@ -81,10 +92,10 @@ public int getBitmapPoolSize() {
   }
 
   /**
-   * Returns the recommended byte array pool size for the device it is run on in bytes.
+   * Returns the recommended array pool size for the device it is run on in bytes.
    */
-  public int getByteArrayPoolSize() {
-    return byteArrayPoolSize;
+  public int getArrayPoolSizeInBytes() {
+    return arrayPoolSize;
   }
 
   private static int getMaxSize(ActivityManager activityManager, float maxSizeMultiplier,
@@ -101,9 +112,11 @@ private String toMb(int bytes) {
 
   @TargetApi(Build.VERSION_CODES.KITKAT)
   private static boolean isLowMemoryDevice(ActivityManager activityManager) {
-    final int sdkInt = Build.VERSION.SDK_INT;
-    return sdkInt < Build.VERSION_CODES.HONEYCOMB
-        || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());
+    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+      return activityManager.isLowRamDevice();
+    } else {
+      return Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB;
+    }
   }
 
   /**
@@ -117,7 +130,7 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
     static final float MAX_SIZE_MULTIPLIER = 0.4f;
     static final float LOW_MEMORY_MAX_SIZE_MULTIPLIER = 0.33f;
     // 4MB.
-    static final int BYTE_ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
+    static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
     private final Context context;
 
@@ -129,7 +142,7 @@ private static boolean isLowMemoryDevice(ActivityManager activityManager) {
     private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
     private float maxSizeMultiplier = MAX_SIZE_MULTIPLIER;
     private float lowMemoryMaxSizeMultiplier = LOW_MEMORY_MAX_SIZE_MULTIPLIER;
-    private int byteArrayPoolSizeBytes = BYTE_ARRAY_POOL_SIZE_BYTES;
+    private int arrayPoolSizeBytes = ARRAY_POOL_SIZE_BYTES;
 
     public Builder(Context context) {
       this.context = context;
@@ -194,14 +207,14 @@ public Builder setLowMemoryMaxSizeMultiplier(float lowMemoryMaxSizeMultiplier) {
 
     /**
      * Sets the size in bytes of the {@link
-     * com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool} to use to store temporary
+     * com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool} to use to store temporary
      * arrays while decoding data and returns this builder.
      *
      * <p>This number will be halved on low memory devices that return {@code true} from
      * {@link ActivityManager#isLowRamDevice()}.
      */
-    public Builder setByteArrayPoolSize(int byteArrayPoolSizeBytes) {
-      this.byteArrayPoolSizeBytes = byteArrayPoolSizeBytes;
+    public Builder setArrayPoolSize(int arrayPoolSizeBytes) {
+      this.arrayPoolSizeBytes = arrayPoolSizeBytes;
       return this;
     }
 
@@ -219,9 +232,9 @@ Builder setScreenDimensions(ScreenDimensions screenDimensions) {
 
     public MemorySizeCalculator build() {
       return new MemorySizeCalculator(context, activityManager, screenDimensions,
-          memoryCacheScreens, bitmapPoolScreens, byteArrayPoolSizeBytes, maxSizeMultiplier,
+          memoryCacheScreens, bitmapPoolScreens, arrayPoolSizeBytes, maxSizeMultiplier,
           lowMemoryMaxSizeMultiplier);
-    }
+      }
   }
 
   private static final class DisplayMetricsScreenDimensions implements ScreenDimensions {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
index 06cc14ffa..612350704 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java
@@ -1,8 +1,12 @@
 package com.bumptech.glide.load.engine.cache;
 
+import android.support.v4.util.Pools;
+
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.util.LruCache;
 import com.bumptech.glide.util.Util;
+import com.bumptech.glide.util.pool.FactoryPools;
+import com.bumptech.glide.util.pool.StateVerifier;
 
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
@@ -13,16 +17,17 @@
  */
 public class SafeKeyGenerator {
   private final LruCache<Key, String> loadIdToSafeHash = new LruCache<>(1000);
-
-  private static String calculateHexStringDigest(Key key) {
-     try {
-        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
-        key.updateDiskCacheKey(messageDigest);
-        return Util.sha256BytesToHex(messageDigest.digest());
-      } catch (NoSuchAlgorithmException e) {
-       throw new RuntimeException(e);
-      }
-  }
+  private final Pools.Pool<PoolableDigestContainer> digestPool = FactoryPools.threadSafe(10,
+      new FactoryPools.Factory<PoolableDigestContainer>() {
+        @Override
+        public PoolableDigestContainer create() {
+          try {
+            return new PoolableDigestContainer(MessageDigest.getInstance("SHA-256"));
+          } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+          }
+        }
+      });
 
   public String getSafeKey(Key key) {
     String safeKey;
@@ -37,4 +42,30 @@ public String getSafeKey(Key key) {
     }
     return safeKey;
   }
+
+  private String calculateHexStringDigest(Key key) {
+    PoolableDigestContainer container = digestPool.acquire();
+    try {
+      key.updateDiskCacheKey(container.messageDigest);
+      // calling digest() will automatically reset()
+      return Util.sha256BytesToHex(container.messageDigest.digest());
+    } finally {
+      digestPool.release(container);
+    }
+  }
+
+  private static final class PoolableDigestContainer implements FactoryPools.Poolable {
+
+    private final MessageDigest messageDigest;
+    private final StateVerifier stateVerifier = StateVerifier.newInstance();
+
+    PoolableDigestContainer(MessageDigest messageDigest) {
+      this.messageDigest = messageDigest;
+    }
+
+    @Override
+    public StateVerifier getVerifier() {
+      return stateVerifier;
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index aca64853a..dd970fb84 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -1,79 +1,204 @@
 package com.bumptech.glide.load.engine.executor;
 
+import android.os.StrictMode;
+import android.os.StrictMode.ThreadPolicy;
+import android.support.annotation.NonNull;
 import android.util.Log;
 
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.regex.Pattern;
 
 /**
  * A prioritized {@link ThreadPoolExecutor} for running jobs in Glide.
  */
-public class GlideExecutor extends ThreadPoolExecutor {
+public final class GlideExecutor extends ThreadPoolExecutor {
+
+  /**
+   * The default thread name prefix for executors used to load/decode/transform data not found in
+   * cache.
+   */
+  public static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";
+  /**
+   * The default thread name prefix for executors used to load/decode/transform data found in
+   * Glide's cache.
+   */
+  public static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";
+  /**
+   * The default thread count for executors used to load/decode/transform data found in Glide's
+   * cache.
+   */
+  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;
+
   private static final String TAG = "GlideExecutor";
-  private static final String DEFAULT_NAME = "fifo-pool";
+  private static final String CPU_NAME_REGEX = "cpu[0-9]+";
+  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
+  // Don't use more than four threads when automatically determining thread count..
+  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
+  private final boolean executeSynchronously;
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
+   * prefix, and the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy.
    *
-   * @param poolSize The number of threads.
+   * <p>Disk cache executors do not allow network operations on their threads.
    */
-  public GlideExecutor(int poolSize) {
-    this(poolSize, new DefaultThreadFactory());
+  public static GlideExecutor newDiskCacheExecutor() {
+    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,
+        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix,
+   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   *
+   * <p>Disk cache executors do not allow network operations on their threads.
    *
-   * @param poolSize The number of threads.
-   * @param uncaughtThrowableStrategy Dictates how the pool should handle uncaught and unexpected
-   *                                  throwables thrown by Futures run by the pool.
+   * @param threadCount The number of threads.
+   * @param name The prefix for each thread name.
+   * @param uncaughtThrowableStrategy The {@link
+   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
+   *                                  handle uncaught exceptions.
    */
-  public GlideExecutor(int poolSize,
+  public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    this(poolSize, new DefaultThreadFactory(uncaughtThrowableStrategy));
+    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
+        true /*preventNetworkOperations*/, false /*executeSynchronously*/);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the default thread count returned from
+   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name
+   * prefix, and the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy.
    *
-   * @param name The prefix for threads created by this pool.
-   * @param poolSize The number of threads.
+   * <p>Source executors allow network operations on their threads.
    */
-  public GlideExecutor(String name, int poolSize) {
-    this(poolSize, new DefaultThreadFactory(name));
+  public static GlideExecutor newSourceExecutor() {
+    return newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT);
   }
 
   /**
-   * Constructor to build a fixed thread pool with the given pool size.
+   * Returns a new fixed thread pool with the given thread count, thread name prefix,
+   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}.
+   *
+   * <p>Source executors allow network operations on their threads.
    *
+   * @param threadCount The number of threads.
    * @param name The prefix for each thread name.
-   * @param poolSize The number of threads.
    * @param uncaughtThrowableStrategy The {@link
    * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to
    *                                  handle uncaught exceptions.
    */
-  public GlideExecutor(String name, int poolSize,
+  public static GlideExecutor newSourceExecutor(int threadCount, String name,
       UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-    this(poolSize, new DefaultThreadFactory(name, uncaughtThrowableStrategy));
+    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,
+        false /*preventNetworkOperations*/, false /*executeSynchronously*/);
+  }
+
+  // Visible for testing.
+  GlideExecutor(int poolSize, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously) {
+    super(
+        poolSize /*corePoolSize*/,
+        poolSize /*maximumPoolSize*/,
+        0 /*keepAliveTime*/,
+        TimeUnit.MILLISECONDS,
+        new PriorityBlockingQueue<Runnable>(),
+        new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
+    this.executeSynchronously = executeSynchronously;
   }
 
-  private GlideExecutor(int corePoolSize, ThreadFactory threadFactory) {
-    super(corePoolSize, corePoolSize, 0, TimeUnit.MILLISECONDS,
-        new PriorityBlockingQueue<Runnable>(), threadFactory);
+  @Override
+  public void execute(Runnable command) {
+    if (executeSynchronously) {
+      command.run();
+    } else {
+      super.execute(command);
+    }
+  }
+
+  @NonNull
+  @Override
+  public Future<?> submit(Runnable task) {
+    return maybeWait(super.submit(task));
+  }
+
+  private <T> Future<T> maybeWait(Future<T> future) {
+    if (executeSynchronously) {
+        try {
+        future.get();
+      } catch (InterruptedException | ExecutionException e) {
+        throw new RuntimeException(e);
+      }
+    }
+    return future;
+  }
+
+  @NonNull
+  @Override
+  public <T> Future<T> submit(Runnable task, T result) {
+    return maybeWait(super.submit(task, result));
+  }
+
+  @Override
+  public <T> Future<T> submit(Callable<T> task) {
+    return maybeWait(super.submit(task));
+  }
+
+  /**
+   * Determines the number of cores available on the device.
+   *
+   * <p>{@link Runtime#availableProcessors()} returns the number of awake cores, which may not
+   * be the number of available cores depending on the device's current state. See
+   * http://goo.gl/8H670N.
+   */
+  public static int calculateBestThreadCount() {
+    File[] cpus = null;
+    try {
+      File cpuInfo = new File(CPU_LOCATION);
+      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+      cpus = cpuInfo.listFiles(new FilenameFilter() {
+        @Override
+        public boolean accept(File file, String s) {
+          return cpuNamePattern.matcher(s).matches();
+        }
+      });
+    } catch (Throwable t) {
+      if (Log.isLoggable(TAG, Log.ERROR)) {
+        Log.e(TAG, "Failed to calculate accurate cpu count", t);
+      }
+    }
+
+    int cpuCount = cpus != null ? cpus.length : 0;
+    int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());
+    return Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));
   }
 
   /**
-   * A strategy for handling unexpected and uncaught throwables thrown by futures run on the pool.
+   * A strategy for handling unexpected and uncaught {@link Throwable}s thrown by futures run on the
+   * pool.
    */
   public enum UncaughtThrowableStrategy {
     /**
-     * Silently catches and ignores the uncaught throwables.
+     * Silently catches and ignores the uncaught {@link Throwable}s.
      */
     IGNORE,
     /**
-     * Logs the uncaught throwables using {@link #TAG} and {@link Log}.
+     * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}.
      */
     LOG {
       @Override
@@ -84,7 +209,7 @@ protected void handle(Throwable t) {
       }
     },
     /**
-     * Rethrows the uncaught throwables to crash the app.
+     * Rethrows the uncaught {@link Throwable}s to crash the app.
      */
     THROW {
       @Override
@@ -96,6 +221,9 @@ protected void handle(Throwable t) {
       }
     };
 
+    /** The default strategy, currently {@link #LOG}. */
+    public static final UncaughtThrowableStrategy DEFAULT = LOG;
+
     protected void handle(Throwable t) {
       // Ignore.
     }
@@ -108,31 +236,29 @@ protected void handle(Throwable t) {
   private static final class DefaultThreadFactory implements ThreadFactory {
     private final String name;
     private final UncaughtThrowableStrategy uncaughtThrowableStrategy;
-    private int threadNum = 0;
-
-    DefaultThreadFactory() {
-      this(DEFAULT_NAME);
-    }
+    private final boolean preventNetworkOperations;
+    private int threadNum;
 
-    DefaultThreadFactory(String name) {
-      this(name, UncaughtThrowableStrategy.LOG);
-    }
-
-    DefaultThreadFactory(UncaughtThrowableStrategy uncaughtThrowableStrategy) {
-      this(DEFAULT_NAME, uncaughtThrowableStrategy);
-    }
-
-    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {
+    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy,
+        boolean preventNetworkOperations) {
       this.name = name;
       this.uncaughtThrowableStrategy = uncaughtThrowableStrategy;
+      this.preventNetworkOperations = preventNetworkOperations;
     }
 
     @Override
-    public Thread newThread(Runnable runnable) {
-      final Thread result = new Thread(runnable, name + "-thread-" + threadNum) {
+    public synchronized Thread newThread(@NonNull Runnable runnable) {
+      final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
         @Override
         public void run() {
           android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+          if (preventNetworkOperations) {
+            StrictMode.setThreadPolicy(
+                new ThreadPolicy.Builder()
+                    .detectNetwork()
+                    .penaltyDeath()
+                    .build());
+          }
           try {
             super.run();
           } catch (Throwable t) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
index b91c4f73a..9bd0fd808 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java
@@ -53,7 +53,7 @@ public void preFill(PreFillType.Builder... bitmapAttributeBuilders) {
   }
 
   // Visible for testing.
-  PreFillQueue generateAllocationOrder(PreFillType[] preFillSizes) {
+  PreFillQueue generateAllocationOrder(PreFillType... preFillSizes) {
     final int maxSize =
         memoryCache.getMaxSize() - memoryCache.getCurrentSize() + bitmapPool.getMaxSize();
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
new file mode 100644
index 000000000..1a105edde
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -0,0 +1,161 @@
+package com.bumptech.glide.load.model;
+
+import android.content.Context;
+import android.util.Base64;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.signature.ObjectKey;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A simple model loader for loading data from a Data URL String.
+ *
+ * Data URIs use the "data" scheme.
+ *
+ * <p>See http://www.ietf.org/rfc/rfc2397.txt  for a complete description of the 'data' URL scheme.
+ *
+ * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],somedata"</pre>
+ *
+ * @param <Data> The type of data that can be opened.
+ */
+public final class DataUrlLoader<Data> implements ModelLoader<String, Data> {
+
+  private static final String DATA_SCHEME_IMAGE = "data:image";
+  private static final String BASE64_TAG = ";base64";
+  private final DataDecoder<Data> dataDecoder;
+
+  public DataUrlLoader(DataDecoder<Data> dataDecoder) {
+    this.dataDecoder = dataDecoder;
+  }
+
+  @Override
+  public LoadData<Data> buildLoadData(String model, int width, int height, Options options) {
+    return new LoadData<>(new ObjectKey(model), new DataUriFetcher<Data>(model, dataDecoder));
+  }
+
+  @Override
+  public boolean handles(String url) {
+    return url.startsWith(DATA_SCHEME_IMAGE);
+  }
+
+  /**
+   * Allows decoding a specific type of data from a Data URL String.
+   *
+   * @param <Data> The type of data that can be opened.
+   */
+  public interface DataDecoder<Data> {
+
+    Data decode(String uri) throws IllegalArgumentException;
+
+    void close(Data data) throws IOException;
+
+    Class<Data> getDataClass();
+  }
+
+  private static final class DataUriFetcher<Data> implements DataFetcher<Data> {
+
+    private final String dataUri;
+    private final DataDecoder<Data> reader;
+    private Data data;
+
+    public DataUriFetcher(String dataUri, DataDecoder<Data> reader) {
+      this.dataUri = dataUri;
+      this.reader = reader;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+      try {
+        data = reader.decode(dataUri);
+        callback.onDataReady(data);
+      } catch (IllegalArgumentException e) {
+        callback.onLoadFailed(e);
+      }
+    }
+
+    @Override
+    public void cleanup() {
+      try {
+        reader.close(data);
+      } catch (IOException e) {
+        // Ignored.
+      }
+    }
+
+    @Override
+    public void cancel() {
+      // Do nothing.
+    }
+
+    @Override
+    public Class<Data> getDataClass() {
+      return reader.getDataClass();
+    }
+
+    @Override
+    public DataSource getDataSource() {
+      return DataSource.LOCAL;
+    }
+  }
+
+  /**
+   * Factory for loading {@link InputStream} from Data URL string.
+   */
+  public static final class StreamFactory implements ModelLoaderFactory<String, InputStream> {
+
+    private final DataDecoder<InputStream> opener;
+
+    public StreamFactory() {
+      opener = new DataDecoder<InputStream>() {
+        @Override
+        public InputStream decode(String url) {
+          if (!url.startsWith(DATA_SCHEME_IMAGE)) {
+            throw new IllegalArgumentException("Not a valid image data URL.");
+          }
+
+          int commaIndex = url.indexOf(',');
+          if (commaIndex == -1) {
+            throw new IllegalArgumentException("Missing comma in data URL.");
+          }
+
+          String beforeComma = url.substring(0, commaIndex);
+          if (!beforeComma.endsWith(BASE64_TAG)) {
+            throw new IllegalArgumentException("Not a base64 image data URL.");
+          }
+
+          String afterComma = url.substring(commaIndex + 1);
+          byte[] bytes = Base64.decode(afterComma, Base64.DEFAULT);
+
+          return new ByteArrayInputStream(bytes);
+        }
+
+        @Override
+        public void close(InputStream inputStream) throws IOException {
+          inputStream.close();
+        }
+
+        @Override
+        public Class<InputStream> getDataClass() {
+          return InputStream.class;
+        }
+      };
+    }
+
+    @Override
+    public final ModelLoader<String, InputStream> build(Context context,
+        MultiModelLoaderFactory multiFactory) {
+      return new DataUrlLoader<>(opener);
+    }
+
+    @Override
+    public final void teardown() {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
index 78f292430..66a76cd11 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.load.model;
 
+import android.support.annotation.Nullable;
+
 /**
  * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
  * example) to be generated in the background during the first fetch.
@@ -8,6 +10,15 @@
  */
 public interface LazyHeaderFactory {
 
+    /**
+     * Returns an http header, or {@code null} if no header could be built.
+     *
+     * <p>Returning {@code null} or an empty String from this method will result in this particular
+     * key/value being excluded from the headers provided in the request. If there are multiple
+     * factories or values for a particular key, any non-null values will still be included for that
+     * key.
+     */
+    @Nullable
     String buildHeader();
 
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
index 915185fbd..27164f763 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java
@@ -47,12 +47,18 @@
       int size = factories.size();
       for (int i = 0; i < size; i++) {
         LazyHeaderFactory factory = factories.get(i);
-        sb.append(factory.buildHeader());
-        if (i != factories.size() - 1) {
-          sb.append(',');
+        String header = factory.buildHeader();
+        if (!TextUtils.isEmpty(header)) {
+          sb.append(header);
+          if (i != factories.size() - 1) {
+            sb.append(',');
+          }
         }
       }
-      combinedHeaders.put(entry.getKey(), sb.toString());
+      String values = sb.toString();
+      if (!TextUtils.isEmpty(values)) {
+        combinedHeaders.put(entry.getKey(), sb.toString());
+      }
     }
 
     return combinedHeaders;
@@ -117,9 +123,9 @@ public int hashCode() {
     }
 
     private boolean copyOnModify = true;
-    private boolean isEncodingDefault = true;
     private Map<String, List<LazyHeaderFactory>> headers = DEFAULT_HEADERS;
-    private boolean isUserAgentDefault = headers.containsKey(DEFAULT_USER_AGENT);
+    private boolean isEncodingDefault = true;
+    private boolean isUserAgentDefault = true;
 
     /**
      * Adds a value for the given header and returns this builder.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index e6c82d9c2..3948b6736 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.content.Context;
+import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
 
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
@@ -196,9 +197,10 @@ public boolean handles(Class<?> modelClass) {
 
   private static class EmptyModelLoader implements ModelLoader<Object, Object> {
 
+    @Nullable
     @Override
     public LoadData<Object> buildLoadData(Object o, int width, int height, Options options) {
-      throw new UnsupportedOperationException("EmptyModelLoader does not handle data");
+      return null;
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index b3807a2db..e93e41371 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -64,12 +64,13 @@ public DataSource getDataSource() {
 
   /**
    * Factory for producing {@link com.bumptech.glide.load.model.UnitModelLoader}s.
+   *
+   * @param <Model> The type of model that will also be returned as decodable data.
    */
-  public static class Factory<ResourceType> implements ModelLoaderFactory<ResourceType,
-      ResourceType> {
+  public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
 
     @Override
-    public ModelLoader<ResourceType, ResourceType> build(Context context,
+    public ModelLoader<Model, Model> build(Context context,
         MultiModelLoaderFactory multiFactory) {
       return new UnitModelLoader<>();
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
new file mode 100644
index 000000000..daeb15fad
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+
+import java.security.MessageDigest;
+
+/**
+ * Returns the image with its original size if its dimensions match or are smaller
+ * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}
+ * in order to center it in Target. If not, then it is scaled so that one of the dimensions of
+ * the image will be equal to the given dimension and the other will be less than the given
+ * dimension (maintaining the image's aspect ratio).
+ */
+public class CenterInside extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  public CenterInside(Context context) {
+    super(context);
+  }
+
+  public CenterInside(BitmapPool bitmapPool) {
+    super(bitmapPool);
+  }
+
+  @Override
+  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
+      int outHeight) {
+    return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return o instanceof CenterInside;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode();
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+  }
+}
+
+
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index 0ab010b53..c5c293483 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -11,12 +11,13 @@
    * requested size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or
+   * {@link #CENTER_INSIDE}.
    *
    * <p>On pre-KitKat devices, this is equivalent to {@link #AT_MOST} because only power of
    * two downsampling can be used.
    */
-  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
+  public static final DownsampleStrategy FIT_CENTER = new FitCenter();
 
   /**
    * Scales, maintaining the original aspect ratio, so that one of the image's dimensions is
@@ -24,7 +25,8 @@
    * the requested size.
    *
    * <p>This method will upscale if the requested width and height are greater than the source width
-   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}.
+   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},
+   * or {@link #CENTER_INSIDE}.
    *
    * <p>On pre-KitKat devices, this is equivalent to {@link #AT_LEAST} because only power of
    * two downsampling can be used.
@@ -43,6 +45,15 @@
    */
   public static final DownsampleStrategy AT_MOST = new AtMost();
 
+  /**
+   * Returns the original image if it is smaller than the target, otherwise it will be downscaled
+   * maintaining its original aspect ratio, so that one of the image's dimensions is exactly equal
+   * to the requested size and the other is less or equal than the requested size.
+   *
+   * <p>This method will not upscale.</p>
+   */
+  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();
+
   /**
    * Performs no downsampling or scaling.
    */
@@ -86,7 +97,7 @@ public abstract float getScaleFactor(int sourceWidth, int sourceHeight, int requ
   public abstract SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
       int requestedWidth, int requestedHeight);
 
-  private static class CenterInside extends DownsampleStrategy {
+  private static class FitCenter extends DownsampleStrategy {
 
     @Override
     public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
@@ -168,6 +179,23 @@ public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeigh
     }
   }
 
+  private static class CenterInside extends DownsampleStrategy {
+
+    @Override
+    public float getScaleFactor(int sourceWidth, int sourceHeight, int requestedWidth,
+        int requestedHeight) {
+
+      return Math.min(1.f,
+          FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));
+    }
+
+    @Override
+    public SampleSizeRounding getSampleSizeRounding(int sourceWidth, int sourceHeight,
+        int requestedWidth, int requestedHeight) {
+      return SampleSizeRounding.QUALITY;
+    }
+  }
+
   /**
    * Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage
    * or higher quality.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 065e9796a..7db211e77 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -400,17 +400,19 @@ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options
     int sourceHeight = options.outHeight;
     String outMimeType = options.outMimeType;
     final Bitmap result;
+    TransformationUtils.getBitmapDrawableLock().lock();
     try {
       result = BitmapFactory.decodeStream(is, null, options);
     } catch (IllegalArgumentException e) {
       throw newIoExceptionForInBitmapAssertion(e, sourceWidth, sourceHeight, outMimeType, options);
+    } finally {
+      TransformationUtils.getBitmapDrawableLock().unlock();
     }
 
     if (options.inJustDecodeBounds) {
       is.reset();
 
     }
-
     return result;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
index 2411ddab0..0fa7e01e1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
@@ -40,6 +40,10 @@
     PNG_A(true),
     /** PNG type without alpha. */
     PNG(false),
+    /** WebP type with alpha. */
+    WEBP_A(true),
+    /** WebP type without alpha. */
+    WEBP(false),
     /**
      * Unrecognized type.
      */
@@ -71,6 +75,21 @@ public boolean hasAlpha() {
   private static final int EXIF_SEGMENT_TYPE = 0xE1;
   private static final int ORIENTATION_TAG_TYPE = 0x0112;
   private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
+  // WebP-related
+  // "RIFF"
+  private static final int RIFF_HEADER = 0x52494646;
+  // "WEBP"
+  private static final int WEBP_HEADER = 0x57454250;
+  // "VP8" null.
+  private static final int VP8_HEADER = 0x56503800;
+  private static final int VP8_HEADER_MASK = 0xFFFFFF00;
+  private static final int VP8_HEADER_TYPE_MASK = 0x000000FF;
+  // 'X'
+  private static final int VP8_HEADER_TYPE_EXTENDED = 0x00000058;
+  // 'L'
+  private static final int VP8_HEADER_TYPE_LOSSLESS = 0x0000004C;
+  private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
+  private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
 
   private final ByteArrayPool byteArrayPool;
   private final Reader reader;
@@ -117,7 +136,33 @@ public ImageType getType() throws IOException {
       return GIF;
     }
 
-    return UNKNOWN;
+    // WebP (reads up to 21 bytes). See https://developers.google.com/speed/webp/docs/riff_container
+    // for details.
+    if (firstFourBytes != RIFF_HEADER) {
+      return UNKNOWN;
+    }
+    // Bytes 4 - 7 contain length information. Skip these.
+    reader.skip(4);
+    final int thirdFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    if (thirdFourBytes != WEBP_HEADER) {
+      return UNKNOWN;
+    }
+    final int fourthFourBytes = reader.getUInt16() << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
+    if ((fourthFourBytes & VP8_HEADER_MASK) != VP8_HEADER) {
+      return UNKNOWN;
+    }
+    if ((fourthFourBytes & VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_EXTENDED) {
+      // Skip some more length bytes and check for transparency/alpha flag.
+      reader.skip(4);
+      return (reader.getByte() & WEBP_EXTENDED_ALPHA_FLAG) != 0 ? ImageType.WEBP_A : ImageType.WEBP;
+    }
+    if ((fourthFourBytes & VP8_HEADER_TYPE_MASK) == VP8_HEADER_TYPE_LOSSLESS) {
+      // See chromium.googlesource.com/webm/libwebp/+/master/doc/webp-lossless-bitstream-spec.txt
+      // for more info.
+      reader.skip(4);
+      return (reader.getByte() & WEBP_LOSSLESS_ALPHA_FLAG) != 0 ? ImageType.WEBP_A : ImageType.WEBP;
+    }
+    return ImageType.WEBP;
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
new file mode 100644
index 000000000..33af8b853
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -0,0 +1,64 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+/**
+ * A {@link BitmapTransformation} which rounds the corners of a bitmap.
+ */
+public final class RoundedCorners extends BitmapTransformation {
+  private static final String ID = "com.bumptech.glide.load.resource.bitmap.RoundedCorners";
+  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
+
+  private final int roundingRadius;
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   */
+  public RoundedCorners(BitmapPool bitmapPool, int roundingRadius) {
+    super(bitmapPool);
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+    this.roundingRadius = roundingRadius;
+  }
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   */
+  public RoundedCorners(Context context, int roundingRadius) {
+    super(context);
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+    this.roundingRadius = roundingRadius;
+  }
+
+  @Override
+  protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
+    return TransformationUtils.roundedCorners(pool, toTransform, outWidth, outHeight,
+        roundingRadius);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return (o instanceof RoundedCorners) && ((RoundedCorners) o).roundingRadius == roundingRadius;
+  }
+
+  @Override
+  public int hashCode() {
+    return ID.hashCode() + roundingRadius;
+  }
+
+  @Override
+  public void updateDiskCacheKey(MessageDigest messageDigest) {
+    messageDigest.update(ID_BYTES);
+
+    byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();
+    messageDigest.update(radiusData);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 0f201106d..85da2b8c8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -2,19 +2,27 @@
 
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
+import android.graphics.BitmapShader;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffXfermode;
-import android.graphics.Rect;
 import android.graphics.RectF;
+import android.graphics.Shader;
 import android.media.ExifInterface;
 import android.os.Build;
 import android.support.annotation.NonNull;
 import android.util.Log;
 
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.util.Preconditions;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * A class with methods to efficiently resize Bitmaps.
@@ -26,6 +34,18 @@
   private static final int CIRCLE_CROP_PAINT_FLAGS = PAINT_FLAGS | Paint.ANTI_ALIAS_FLAG;
   private static final Paint CIRCLE_CROP_SHAPE_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
+  /**
+   * https://github.com/bumptech/glide/issues/738 On some devices (Moto X with android 5.1) bitmap
+   * drawing is not thread safe.
+   * This lock only locks for these specific devices. For other types of devices the lock is always
+   * available and therefore does not impact performance
+   */
+  private static final Lock BITMAP_DRAWABLE_LOCK = "XT1097".equals(Build.MODEL)
+      // TODO: Switch to Build.VERSION_CODES.LOLLIPOP_MR1 when apps have updated target API levels.
+      && Build.VERSION.SDK_INT == 22
+      ? new ReentrantLock()
+      : new NoLock();
+
   static {
     CIRCLE_CROP_BITMAP_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
     CIRCLE_CROP_BITMAP_PAINT.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
@@ -35,43 +55,47 @@ private TransformationUtils() {
     // Utility class.
   }
 
+
+  public static Lock getBitmapDrawableLock() {
+    return BITMAP_DRAWABLE_LOCK;
+  }
+
   /**
    * A potentially expensive operation to crop the given Bitmap so that it fills the given
    * dimensions. This operation is significantly less expensive in terms of memory if a mutable
    * Bitmap with the given dimensions is passed in as well.
    *
    * @param pool     The BitmapPool to obtain a bitmap from.
-   * @param toCrop   The Bitmap to resize.
+   * @param inBitmap   The Bitmap to resize.
    * @param width    The width in pixels of the final Bitmap.
    * @param height   The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int width,
+  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
       int height) {
-    if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
-      return toCrop;
+    if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
+      return inBitmap;
     }
     // From ImageView/Bitmap.createScaledBitmap.
     final float scale;
     float dx = 0, dy = 0;
     Matrix m = new Matrix();
-    if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
-      scale = (float) height / (float) toCrop.getHeight();
-      dx = (width - toCrop.getWidth() * scale) * 0.5f;
+    if (inBitmap.getWidth() * height > width * inBitmap.getHeight()) {
+      scale = (float) height / (float) inBitmap.getHeight();
+      dx = (width - inBitmap.getWidth() * scale) * 0.5f;
     } else {
-      scale = (float) width / (float) toCrop.getWidth();
-      dy = (height - toCrop.getHeight() * scale) * 0.5f;
+      scale = (float) width / (float) inBitmap.getWidth();
+      dy = (height - inBitmap.getHeight() * scale) * 0.5f;
     }
 
     m.setScale(scale, scale);
     m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
 
-    Bitmap result = pool.get(width, height, getSafeConfig(toCrop));
+    Bitmap result = pool.get(width, height, getSafeConfig(inBitmap));
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-    TransformationUtils.setAlpha(toCrop, result);
+    TransformationUtils.setAlpha(inBitmap, result);
 
-    Canvas canvas = new Canvas(result);
-    canvas.drawBitmap(toCrop, m, DEFAULT_PAINT);
+    applyMatrix(inBitmap, result, m);
     return result;
   }
 
@@ -80,69 +104,94 @@ public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop
    * dimensions maintain the original proportions.
    *
    * @param pool   The BitmapPool obtain a bitmap from.
-   * @param toFit  The Bitmap to shrink.
+   * @param inBitmap  The Bitmap to shrink.
    * @param width  The width in pixels the final image will fit within.
    * @param height The height in pixels the final image will fit within.
    * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or
    * height matches the given dimensions and toFit fits within the given dimensions
    */
-  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap toFit, int width,
+  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
       int height) {
-    if (toFit.getWidth() == width && toFit.getHeight() == height) {
+    if (inBitmap.getWidth() == width && inBitmap.getHeight() == height) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "requested target size matches input, returning input");
       }
-      return toFit;
+      return inBitmap;
     }
-    final float widthPercentage = width / (float) toFit.getWidth();
-    final float heightPercentage = height / (float) toFit.getHeight();
+    final float widthPercentage = width / (float) inBitmap.getWidth();
+    final float heightPercentage = height / (float) inBitmap.getHeight();
     final float minPercentage = Math.min(widthPercentage, heightPercentage);
 
     // take the floor of the target width/height, not round. If the matrix
     // passed into drawBitmap rounds differently, we want to slightly
     // overdraw, not underdraw, to avoid artifacts from bitmap reuse.
-    final int targetWidth = (int) (minPercentage * toFit.getWidth());
-    final int targetHeight = (int) (minPercentage * toFit.getHeight());
+    final int targetWidth = (int) (minPercentage * inBitmap.getWidth());
+    final int targetHeight = (int) (minPercentage * inBitmap.getHeight());
 
-    if (toFit.getWidth() == targetWidth && toFit.getHeight() == targetHeight) {
+    if (inBitmap.getWidth() == targetWidth && inBitmap.getHeight() == targetHeight) {
       if (Log.isLoggable(TAG, Log.VERBOSE)) {
         Log.v(TAG, "adjusted target size matches input, returning input");
       }
-      return toFit;
+      return inBitmap;
     }
 
-    Bitmap.Config config = getSafeConfig(toFit);
+    Bitmap.Config config = getSafeConfig(inBitmap);
     Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
 
     // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.
-    TransformationUtils.setAlpha(toFit, toReuse);
+    TransformationUtils.setAlpha(inBitmap, toReuse);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       Log.v(TAG, "request: " + width + "x" + height);
-      Log.v(TAG, "toFit:   " + toFit.getWidth() + "x" + toFit.getHeight());
+      Log.v(TAG, "toFit:   " + inBitmap.getWidth() + "x" + inBitmap.getHeight());
       Log.v(TAG, "toReuse: " + toReuse.getWidth() + "x" + toReuse.getHeight());
       Log.v(TAG, "minPct:   " + minPercentage);
     }
 
-    Canvas canvas = new Canvas(toReuse);
     Matrix matrix = new Matrix();
     matrix.setScale(minPercentage, minPercentage);
-    canvas.drawBitmap(toFit, matrix, DEFAULT_PAINT);
+    applyMatrix(inBitmap, toReuse, matrix);
 
     return toReuse;
   }
 
+  /**
+   * If the Bitmap is smaller or equal to the Target it returns the original size, if not then
+   * {@link #fitCenter(BitmapPool, Bitmap, int, int)} is called instead.
+   *
+   * @param pool   The BitmapPool obtain a bitmap from.
+   * @param inBitmap  The Bitmap to center.
+   * @param width  The width in pixels of the target.
+   * @param height The height in pixels of the target.
+   * @return returns input Bitmap if smaller or equal to target, or toFit if the Bitmap's width or
+   * height is larger than the given dimensions
+   */
+  public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,
+                                 int height) {
+    if (inBitmap.getWidth() <= width && inBitmap.getHeight() <= height) {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "requested target size larger or equal to input, returning input");
+      }
+      return inBitmap;
+    } else {
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "requested target size too big for input, fit centering instead");
+      }
+      return fitCenter(pool, inBitmap, width, height);
+    }
+  }
+
   /**
    * Sets the alpha of the Bitmap we're going to re-use to the alpha of the Bitmap we're going to
    * transform. This keeps {@link android.graphics.Bitmap#hasAlpha()}} consistent before and after
    * the transformation for transformations that don't add or remove transparent pixels.
    *
-   * @param toTransform The {@link android.graphics.Bitmap} that will be transformed.
+   * @param inBitmap The {@link android.graphics.Bitmap} that will be transformed.
    * @param outBitmap   The {@link android.graphics.Bitmap} that will be returned from the
    *                    transformation.
    */
-  public static void setAlpha(Bitmap toTransform, Bitmap outBitmap) {
-    setAlphaIfAvailable(outBitmap, toTransform.hasAlpha());
+  public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
+    setAlphaIfAvailable(outBitmap, inBitmap.hasAlpha());
   }
 
   @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
@@ -201,6 +250,7 @@ public static int getExifOrientationDegrees(int exifOrientation) {
         break;
       default:
         degreesToRotate = 0;
+        break;
     }
     return degreesToRotate;
   }
@@ -210,33 +260,31 @@ public static int getExifOrientationDegrees(int exifOrientation) {
    *
    * @param pool            A pool that may or may not contain an image of the necessary
    *                        dimensions.
-   * @param toOrient        The bitmap to rotate/flip.
+   * @param inBitmap        The bitmap to rotate/flip.
    * @param exifOrientation the exif orientation [1-8].
    * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary.
    */
-  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap toOrient,
+  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
       int exifOrientation) {
     final Matrix matrix = new Matrix();
     initializeMatrixForRotation(exifOrientation, matrix);
     if (matrix.isIdentity()) {
-      return toOrient;
+      return inBitmap;
     }
 
     // From Bitmap.createBitmap.
-    final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
+    final RectF newRect = new RectF(0, 0, inBitmap.getWidth(), inBitmap.getHeight());
     matrix.mapRect(newRect);
 
     final int newWidth = Math.round(newRect.width());
     final int newHeight = Math.round(newRect.height());
 
-    Bitmap.Config config = getSafeConfig(toOrient);
+    Bitmap.Config config = getSafeConfig(inBitmap);
     Bitmap result = pool.get(newWidth, newHeight, config);
 
     matrix.postTranslate(-newRect.left, -newRect.top);
 
-    final Canvas canvas = new Canvas(result);
-    canvas.drawBitmap(toOrient, matrix, DEFAULT_PAINT);
-
+    applyMatrix(inBitmap, result, matrix);
     return result;
   }
 
@@ -245,42 +293,136 @@ public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap t
    * have the same width and height equal to the min-edge of the result image.
    *
    * @param pool   The BitmapPool obtain a bitmap from.
-   * @param toCrop   The Bitmap to resize.
+   * @param inBitmap   The Bitmap to resize.
    * @param destWidth    The width in pixels of the final Bitmap.
    * @param destHeight   The height in pixels of the final Bitmap.
    * @return The resized Bitmap (will be recycled if recycled is not null).
    */
-  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int destWidth,
-      int destHeight) {
+  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
+      int destWidth, int destHeight) {
     int destMinEdge = Math.min(destWidth, destHeight);
     float radius = destMinEdge / 2f;
-    Rect destRect = new Rect((destWidth - destMinEdge) / 2, (destHeight - destMinEdge) / 2,
-        destMinEdge, destMinEdge);
 
-    int srcWidth = toCrop.getWidth();
-    int srcHeight = toCrop.getHeight();
-    int srcMinEdge = Math.min(srcWidth, srcHeight);
-    Rect srcRect = new Rect((srcWidth - srcMinEdge) / 2, (srcHeight - srcMinEdge) / 2,
-        srcMinEdge, srcMinEdge);
+    int srcWidth = inBitmap.getWidth();
+    int srcHeight = inBitmap.getHeight();
+
+    float scaleX = destMinEdge / (float) srcWidth;
+    float scaleY = destMinEdge / (float) srcHeight;
+    float maxScale = Math.max(scaleX, scaleY);
+
+    float scaledWidth = maxScale * srcWidth;
+    float scaledHeight = maxScale * srcHeight;
+    float left = (destMinEdge - scaledWidth) / 2f;
+    float top = (destMinEdge - scaledHeight) / 2f;
+
+    RectF destRect = new RectF(left, top, left + scaledWidth, top + scaledHeight);
 
-    Bitmap result = pool.get(destWidth, destHeight, getSafeConfig(toCrop));
+    // Alpha is required for this transformation.
+    Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
+
+    Bitmap result = pool.get(destMinEdge, destMinEdge, Bitmap.Config.ARGB_8888);
     setAlphaIfAvailable(result, true /*hasAlpha*/);
-    Canvas canvas = new Canvas(result);
 
-    // Draw a circle
-    canvas.drawCircle(destRect.left + radius, destRect.top + radius, radius,
-        CIRCLE_CROP_SHAPE_PAINT);
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(result);
+      // Draw a circle
+      canvas.drawCircle(radius, radius, radius, CIRCLE_CROP_SHAPE_PAINT);
+      // Draw the bitmap in the circle
+      canvas.drawBitmap(toTransform, null, destRect, CIRCLE_CROP_BITMAP_PAINT);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
 
-    // Draw the bitmap in the circle
-    canvas.drawBitmap(toCrop, srcRect, destRect, CIRCLE_CROP_BITMAP_PAINT);
+    if (!toTransform.equals(inBitmap)) {
+      pool.put(toTransform);
+    }
 
     return result;
   }
 
+  private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
+      @NonNull Bitmap maybeAlphaSafe) {
+    if (Bitmap.Config.ARGB_8888.equals(maybeAlphaSafe.getConfig())) {
+      return maybeAlphaSafe;
+    }
+
+    Bitmap argbBitmap = pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(),
+        Bitmap.Config.ARGB_8888);
+    new Canvas(argbBitmap).drawBitmap(maybeAlphaSafe, 0 /*left*/, 0 /*top*/, null /*pain*/);
+
+    // We now own this Bitmap. It's our responsibility to replace it in the pool outside this method
+    // when we're finished with it.
+    return argbBitmap;
+  }
+
+  /**
+   * Creates a bitmap from a source bitmap and rounds the corners.
+   *
+   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
+   * @param width the width of the generated bitmap.
+   * @param height the height of the generated bitmap.
+   * @param roundingRadius the corner radius to be applied (in device-specific pixels).
+   * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
+   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
+   */
+  public static Bitmap roundedCorners(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
+      int width, int height, int roundingRadius) {
+    Preconditions.checkArgument(width > 0, "width must be greater than 0.");
+    Preconditions.checkArgument(height > 0, "height must be greater than 0.");
+    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
+
+    // Alpha is required for this transformation.
+    Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
+    Bitmap result = pool.get(width, height, Bitmap.Config.ARGB_8888);
+
+    setAlphaIfAvailable(result, true /* hasAlpha */);
+
+    BitmapShader shader = new BitmapShader(toTransform, Shader.TileMode.CLAMP,
+        Shader.TileMode.CLAMP);
+    Paint paint = new Paint();
+    paint.setAntiAlias(true);
+    paint.setShader(shader);
+    RectF rect = new RectF(0, 0, result.getWidth(), result.getHeight());
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(result);
+      canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
+      canvas.drawRoundRect(rect, roundingRadius, roundingRadius, paint);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
+
+    if (!toTransform.equals(inBitmap)) {
+      pool.put(toTransform);
+    }
+
+    return result;
+  }
+
+  // Avoids warnings in M+.
+  private static void clear(Canvas canvas) {
+    canvas.setBitmap(null);
+  }
+
   private static Bitmap.Config getSafeConfig(Bitmap bitmap) {
     return bitmap.getConfig() != null ? bitmap.getConfig() : Bitmap.Config.ARGB_8888;
   }
 
+  private static void applyMatrix(@NonNull Bitmap inBitmap, @NonNull Bitmap targetBitmap,
+      Matrix matrix) {
+    BITMAP_DRAWABLE_LOCK.lock();
+    try {
+      Canvas canvas = new Canvas(targetBitmap);
+      canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);
+      clear(canvas);
+    } finally {
+      BITMAP_DRAWABLE_LOCK.unlock();
+    }
+  }
+
   // Visible for testing.
   static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
     switch (exifOrientation) {
@@ -312,4 +454,37 @@ static void initializeMatrixForRotation(int exifOrientation, Matrix matrix) {
         // Do nothing.
     }
   }
+
+  private static final class NoLock implements Lock {
+    @Override
+    public void lock() {
+      // do nothing
+    }
+
+    @Override
+    public void lockInterruptibly() throws InterruptedException {
+      // do nothing
+    }
+
+    @Override
+    public boolean tryLock() {
+      return true;
+    }
+
+    @Override
+    public boolean tryLock(long time, @NonNull TimeUnit unit) throws InterruptedException {
+      return true;
+    }
+
+    @Override
+    public void unlock() {
+      // do nothing
+    }
+
+    @NonNull
+    @Override
+    public Condition newCondition() {
+      throw new UnsupportedOperationException("Should not be called");
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index c3cb3f5c6..9c240aed5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -125,17 +125,20 @@ public boolean handles(ParcelFileDescriptor data, Options options) {
     }
     Integer frameOption = options.get(FRAME_OPTION);
 
-    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
-    mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
     final Bitmap result;
-    if (frameTimeMicros == DEFAULT_FRAME) {
-      result = mediaMetadataRetriever.getFrameAtTime();
-    } else if (frameOption == null) {
-      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
-    } else {
-      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
+    try {
+      mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
+      if (frameTimeMicros == DEFAULT_FRAME) {
+        result = mediaMetadataRetriever.getFrameAtTime();
+      } else if (frameOption == null) {
+        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
+      } else {
+        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+      }
+    } finally {
+      mediaMetadataRetriever.release();
     }
-    mediaMetadataRetriever.release();
     resource.close();
     return BitmapResource.obtain(result, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index aa62a9250..da9ba30ff 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -12,8 +12,10 @@
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
@@ -45,31 +47,35 @@
   private final Context context;
   private final GifHeaderParserPool parserPool;
   private final BitmapPool bitmapPool;
-  private final ByteArrayPool byteArrayPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
   public ByteBufferGifDecoder(Context context) {
-    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getByteArrayPool());
+    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
   }
 
-  public ByteBufferGifDecoder(Context context, BitmapPool bitmapPool, ByteArrayPool byteArrayPool) {
-    this(context, bitmapPool, byteArrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
+  public ByteBufferGifDecoder(
+      Context context, BitmapPool bitmapPool, ArrayPool arrayPool) {
+    this(context, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
   // Visible for testing.
-  ByteBufferGifDecoder(Context context, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,
-      GifHeaderParserPool parserPool, GifDecoderFactory gifDecoderFactory) {
+  ByteBufferGifDecoder(
+      Context context,
+      BitmapPool bitmapPool,
+      ArrayPool arrayPool,
+      GifHeaderParserPool parserPool,
+      GifDecoderFactory gifDecoderFactory) {
     this.context = context;
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
     this.gifDecoderFactory = gifDecoderFactory;
-    this.provider = new GifBitmapProvider(bitmapPool, byteArrayPool);
+    this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
     this.parserPool = parserPool;
   }
 
   @Override
   public boolean handles(ByteBuffer source, Options options) throws IOException {
+    ByteArrayPool byteArrayPool = new LruByteArrayPool();
     return !options.get(DISABLE_ANIMATION)
         && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
index 6b2988df9..dd75da497 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java
@@ -6,8 +6,8 @@
 import android.support.annotation.Nullable;
 
 import com.bumptech.glide.gifdecoder.GifDecoder;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;
 
 /**
  * Implements {@link com.bumptech.glide.gifdecoder.GifDecoder.BitmapProvider} by wrapping Glide's
@@ -15,23 +15,23 @@
  */
 public final class GifBitmapProvider implements GifDecoder.BitmapProvider {
   private final BitmapPool bitmapPool;
-  @Nullable private final ByteArrayPool byteArrayPool;
+  @Nullable private final ArrayPool arrayPool;
 
   /**
    * Constructs an instance without a shared byte array pool. Byte arrays will be always constructed
    * when requested.
    */
   public GifBitmapProvider(BitmapPool bitmapPool) {
-    this(bitmapPool, null /*byteArrayPool*/);
+    this(bitmapPool, null /* arrayPool */);
   }
 
   /**
-   * Constructs an instance with a shared byte array pool. Byte arrays will be reused where
+   * Constructs an instance with a shared array pool. Arrays will be reused where
    * possible.
    */
-  public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ByteArrayPool byteArrayPool) {
+  public GifBitmapProvider(BitmapPool bitmapPool, ArrayPool arrayPool) {
     this.bitmapPool = bitmapPool;
-    this.byteArrayPool = byteArrayPool;
+    this.arrayPool = arrayPool;
   }
 
   @NonNull
@@ -47,17 +47,35 @@ public void release(Bitmap bitmap) {
 
   @Override
   public byte[] obtainByteArray(int size) {
-    if (byteArrayPool == null) {
+    if (arrayPool == null) {
       return new byte[size];
     }
-    return byteArrayPool.get(size);
+    return arrayPool.get(size, byte[].class);
   }
 
+  @SuppressWarnings("PMD.UseVarargs")
   @Override
   public void release(byte[] bytes) {
-    if (byteArrayPool == null) {
+    if (arrayPool == null) {
       return;
     }
-    byteArrayPool.put(bytes);
+    arrayPool.put(bytes, byte[].class);
+  }
+
+  @Override
+  public int[] obtainIntArray(int size) {
+    if (arrayPool == null) {
+      return new int[size];
+    }
+    return arrayPool.get(size, int[].class);
+  }
+
+  @SuppressWarnings("PMD.UseVarargs")
+  @Override
+  public void release(int[] array) {
+    if (arrayPool == null) {
+      return;
+    }
+    arrayPool.put(array, int[].class);
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 5431bca24..d6b4263ec 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -58,6 +58,7 @@ public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int hei
         getRequestBuilder(context, width, height), transformation, firstFrame);
   }
 
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
   GifFrameLoader(Context context, RequestManager requestManager, GifDecoder gifDecoder,
       Handler handler, RequestBuilder<Bitmap> requestBuilder, Transformation<Bitmap> transformation,
       Bitmap firstFrame) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
index e6c965436..ad1c55c6e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java
@@ -11,7 +11,7 @@
 public interface ResourceTranscoder<Z, R> {
 
   /**
-   * Transcodes the given resource to the new resource type and returns the wew resource.
+   * Transcodes the given resource to the new resource type and returns the new resource.
    *
    * @param toTranscode The resource to transcode.
    */
diff --git a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
index 3b130fd70..b226cd425 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java
@@ -1,23 +1,16 @@
 package com.bumptech.glide.manager;
 
 import android.content.Context;
-import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
 
 /**
- * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
- * if the application has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op
- * non functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have
- * the required permission.
+ * A factory class that produces a functional
+ * {@link com.bumptech.glide.manager.ConnectivityMonitor}.
  */
-public class ConnectivityMonitorFactory {
-  public ConnectivityMonitor build(Context context,
-      ConnectivityMonitor.ConnectivityListener listener) {
-    final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
-    final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
-    if (hasPermission) {
-      return new DefaultConnectivityMonitor(context, listener);
-    } else {
-      return new NullConnectivityMonitor();
-    }
-  }
+public interface ConnectivityMonitorFactory {
+
+  @NonNull
+  ConnectivityMonitor build(
+      @NonNull Context context,
+      @NonNull ConnectivityMonitor.ConnectivityListener listener);
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
index 945df9f96..d191bda2a 100644
--- a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java
@@ -7,6 +7,9 @@
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 
+/**
+ * Uses {@link android.net.ConnectivityManager} to identify connectivity changes.
+ */
 class DefaultConnectivityMonitor implements ConnectivityMonitor {
   private final Context context;
   private final ConnectivityListener listener;
diff --git a/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
new file mode 100644
index 000000000..ab3713962
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide.manager;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
+
+/**
+ * A factory class that produces a functional {@link com.bumptech.glide.manager.ConnectivityMonitor}
+ * if the application has the {@code android.permission.ACCESS_NETWORK_STATE} permission and a no-op
+ * non functional {@link com.bumptech.glide.manager.ConnectivityMonitor} if the app does not have
+ * the required permission.
+ */
+public class DefaultConnectivityMonitorFactory implements ConnectivityMonitorFactory {
+
+  @NonNull
+  public ConnectivityMonitor build(
+      @NonNull Context context,
+      @NonNull ConnectivityMonitor.ConnectivityListener listener) {
+    final int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");
+    final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;
+    if (hasPermission) {
+      return new DefaultConnectivityMonitor(context, listener);
+    } else {
+      return new NullConnectivityMonitor();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index e46936da8..1ca543956 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -239,6 +239,7 @@ public boolean handleMessage(Message message) {
         break;
       default:
         handled = false;
+        break;
     }
     if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {
       Log.w(TAG, "Failed to remove expected request manager fragment, manager: " + key);
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
index dbb9b2097..f9df455c9 100644
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
@@ -18,6 +18,7 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CenterInside;
 import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
@@ -61,6 +62,8 @@
   private static final int FALLBACK = 1 << 13;
   private static final int FALLBACK_ID = 1 << 14;
   private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
 
   private int fields;
 
@@ -76,6 +79,7 @@
   private int overrideWidth = UNSET;
   private Key signature = EmptySignature.obtain();
   private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
   private Drawable fallbackDrawable;
   private int fallbackId;
 
@@ -409,6 +413,10 @@ public final CHILD decode(@NonNull Class<?> resourceClass) {
     return selfOrThrowIfLocked();
   }
 
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
   public final boolean isTransformationSet() {
     return isSet(TRANSFORMATION);
   }
@@ -469,6 +477,8 @@ public CHILD downsample(@NonNull DownsampleStrategy strategy) {
    * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
    * ignores unknown types.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link android.content.Context}.
    * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
    * @see #centerCrop(android.content.Context)
@@ -481,6 +491,8 @@ public CHILD optionalCenterCrop(Context context) {
    * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and
    * throws an exception if asked to transform an unknown type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link android.content.Context}.
    * @see #transform(Class, com.bumptech.glide.load.Transformation)
    * @see #optionalCenterCrop(android.content.Context)
@@ -493,29 +505,63 @@ public CHILD centerCrop(Context context) {
    * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
    * ignores unknown types.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link android.content.Context}.
    * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
    * @see #fitCenter(android.content.Context)
    */
   public CHILD optionalFitCenter(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));
+    return optionalTransform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));
   }
 
   /**
    * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types and
    * throws an exception if asked to transform an unknown type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link android.content.Context}.
    * @see #transform(Class, com.bumptech.glide.load.Transformation)
    * @see #optionalFitCenter(android.content.Context)
    */
   public CHILD fitCenter(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));
+    return transform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link android.content.Context}.
+   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
+   * @see #centerInside(Context) (android.content.Context)
+   */
+  public CHILD optionalCenterInside(Context context) {
+    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link android.content.Context}.
+   * @see #transform(Class, com.bumptech.glide.load.Transformation)
+   * @see #optionalCenterInside(Context) (android.content.Context)
+   */
+  public CHILD centerInside(Context context) {
+    return transform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));
   }
 
   /**
    * Applies {@link CircleCrop} to all default types, and ignores unknown types.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link Context}.
    * @see #optionalTransform(Context, Transformation)
    * @see #circleCrop(Context)
@@ -528,6 +574,8 @@ public CHILD optionalCircleCrop(Context context) {
    * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
    * an unknown type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context Any {@link Context}.
    * @see #transform(Class, Transformation)
    * @see #optionalCenterCrop(Context)
@@ -563,6 +611,8 @@ final CHILD transform(Context context, DownsampleStrategy downsampleStrategy,
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
    * and throws an exception if asked to transform an unknown type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context        Any {@link android.content.Context}.
    * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
    *                       {@link android.graphics.Bitmap}s.
@@ -576,6 +626,7 @@ public CHILD transform(Context context, @NonNull Transformation<Bitmap> transfor
 
     optionalTransform(context, transformation);
     isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
     return selfOrThrowIfLocked();
   }
 
@@ -585,6 +636,8 @@ public CHILD transform(Context context, @NonNull Transformation<Bitmap> transfor
    * {@link android.graphics.drawable.BitmapDrawable}, and
    * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param context        Any {@link android.content.Context}.
    * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
    *                       {@link android.graphics.Bitmap}s.
@@ -616,6 +669,8 @@ public CHILD optionalTransform(Context context, Transformation<Bitmap> transform
    * an unknown resource class will throw an exception. To allow unknown types, users must always
    * call the optional version of each method. </p>
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param resourceClass  The type of resource to transform.
    * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
    */
@@ -627,8 +682,10 @@ public CHILD optionalTransform(Context context, Transformation<Bitmap> transform
 
     Preconditions.checkNotNull(resourceClass);
     Preconditions.checkNotNull(transformation);
-    fields |= TRANSFORMATION;
     transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
     return selfOrThrowIfLocked();
   }
 
@@ -636,6 +693,8 @@ public CHILD optionalTransform(Context context, Transformation<Bitmap> transform
    * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
    * the given type and throws if asked to transform an unknown resource type.
    *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
    * @param resourceClass  The type of resource to transform.
    * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
    * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
@@ -647,6 +706,7 @@ public CHILD optionalTransform(Context context, Transformation<Bitmap> transform
 
     optionalTransform(resourceClass, transformation);
     isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
     return selfOrThrowIfLocked();
   }
 
@@ -660,9 +720,12 @@ public final CHILD dontTransform() {
       return clone().dontTransform();
     }
 
-    fields &= ~TRANSFORMATION;
     transformations.clear();
+    fields &= ~TRANSFORMATION;
     isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
     return selfOrThrowIfLocked();
   }
 
@@ -731,10 +794,25 @@ public final CHILD apply(BaseRequestOptions<?> other) {
     if (isSet(other.fields, THEME)) {
       theme = other.theme;
     }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+    }
 
-    isTransformationRequired |= other.isTransformationRequired;
     fields |= other.fields;
-    transformations.putAll(other.transformations);
     options.putAll(other.options);
 
     return selfOrThrowIfLocked();
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestListener.java b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
index cd8ddb751..0bde3e95a 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestListener.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java
@@ -38,9 +38,9 @@
    *                        request failed.
    * @param model           The model we were trying to load when the exception occurred.
    * @param target          The {@link Target} we were trying to load the image into.
-   * @param isFirstResource True if this exception is for the first resource to load.
-   * @return True if the listener has handled updating the target for the given exception, false to
-   * allow Glide's request to update the target.
+   * @param isFirstResource {@code true} if this exception is for the first resource to load.
+   * @return {@code true} if the listener has handled updating the target for the given exception,
+   *         {@code false} to allow Glide's request to update the target.
    */
   boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
       boolean isFirstResource);
@@ -53,12 +53,13 @@ boolean onLoadFailed(@Nullable GlideException e, Object model, Target<R> target,
    * @param model             The specific model that was used to load the image.
    * @param target            The target the model was loaded into.
    * @param dataSource        The {@link DataSource} the resource was loaded from.
-   * @param isFirstResource   True if this is the first resource to in this load to be loaded into
-   *                          the target. For example when loading a thumbnail and a fullsize image,
-   *                          this will be true for the first image to load and false for the
-   *                          second.
-   * @return True if the listener has handled setting the resource on the target (including any
-   * animations), false to allow Glide's request to update the target (again including animations).
+   * @param isFirstResource   {@code true} if this is the first resource to in this load to be
+   *                          loaded into the target. For example when loading a thumbnail and a
+   *                          full-sized image, this will be {@code true} for the first image to
+   *                          load and {@code false} for the second.
+   * @return {@code true} if the listener has handled setting the resource on the target,
+   *         {@code false} to allow Glide's request to update the target.
+   *         Setting the resource includes handling animations, be sure to take that into account.
    */
   boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,
       boolean isFirstResource);
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 6e8aa1e65..3bf554ecd 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -26,6 +26,7 @@
   private static RequestOptions skipMemoryCacheTrueOptions;
   private static RequestOptions skipMemoryCacheFalseOptions;
   private static RequestOptions fitCenterOptions;
+  private static RequestOptions centerInsideOptions;
   private static RequestOptions centerCropOptions;
   private static RequestOptions circleCropOptions;
   private static RequestOptions noTransformOptions;
@@ -131,6 +132,18 @@ public static RequestOptions fitCenterTransform(Context context) {
     return fitCenterOptions;
   }
 
+  /**
+   * Returns a {@link RequestOptions} object with {@link #centerInside(Context)} set.
+   */
+  public static RequestOptions centerInsideTransform(Context context) {
+    if (centerInsideOptions == null) {
+      centerInsideOptions = new RequestOptions()
+              .centerInside(context.getApplicationContext())
+              .autoLock();
+    }
+    return centerInsideOptions;
+  }
+
   /**
    * Returns a {@link RequestOptions} object with {@link #circleCrop(Context)} set.
    */
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index e8262fa69..0f07a3dec 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -200,7 +200,14 @@ public void begin() {
     stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
     if (model == null) {
-      onLoadFailed(new GlideException("Received null model"));
+      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
+        width = overrideWidth;
+        height = overrideHeight;
+      }
+      // Only log at more verbose log levels if the user has set a fallback drawable, because
+      // fallback Drawables indicate the user expects null models occasionally.
+      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
+      onLoadFailed(new GlideException("Received null model"), logLevel);
       return;
     }
 
@@ -482,9 +489,13 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
    */
   @Override
   public void onLoadFailed(GlideException e) {
+    onLoadFailed(e, Log.WARN);
+  }
+
+  private void onLoadFailed(GlideException e, int maxLogLevel) {
     stateVerifier.throwIfRecycled();
     int logLevel = glideContext.getLogLevel();
-    if (logLevel <= Log.WARN) {
+    if (logLevel <= maxLogLevel) {
       Log.w(GLIDE_TAG, "Load failed for " + model + " with size [" + width + "x" + height + "]", e);
       if (logLevel <= Log.INFO) {
         e.logRootCauses(GLIDE_TAG);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
index 6928462ae..ccfe0f1fe 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java
@@ -17,7 +17,6 @@
  * for every subsequent load. </p>
  */
 public class AppWidgetTarget extends SimpleTarget<Bitmap> {
-
   private final int[] widgetIds;
   private final ComponentName componentName;
   private final RemoteViews remoteViews;
@@ -29,16 +28,16 @@
    * it.
    *
    * @param context     Context to use in the AppWidgetManager initialization.
-   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
-   * @param viewId      The id of the ImageView view that will load the image.
    * @param width       Desired width in pixels of the bitmap that will be loaded. (Needs to be
    *                    manually put because of RemoteViews limitations.)
    * @param height      Desired height in pixels of the bitmap that will be loaded. (Needs to be
    *                    manually put because of RemoteViews limitations.)
+   * @param viewId      The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param widgetIds   The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, int... widgetIds) {
+  public AppWidgetTarget(Context context, int width, int height,
+      int viewId, RemoteViews remoteViews, int... widgetIds) {
     super(width, height);
     if (widgetIds.length == 0) {
       throw new IllegalArgumentException("WidgetIds must have length > 0");
@@ -56,29 +55,30 @@ public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int
    * that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
    * @param context     Context to use in the AppWidgetManager initialization.
-   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param viewId      The id of the ImageView view that will load the image.
+   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap.
    * @param widgetIds   The int[] that contains the widget ids of an application.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int... widgetIds) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, widgetIds);
+  public AppWidgetTarget(Context context,
+      int viewId, RemoteViews remoteViews, int... widgetIds) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);
   }
 
   /**
    * Constructor using a ComponentName to get a handle on the Widget in order to update it.
    *
    * @param context       Context to use in the AppWidgetManager initialization.
-   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
-   *                      bitmap.
-   * @param viewId        The id of the ImageView view that will load the image.
    * @param width         Desired width in pixels of the bitmap that will be loaded. (Needs to be
    *                      manually put because of RemoteViews limitations.)
    * @param height        Desired height in pixels of the bitmap that will be loaded. (Needs to be
    *                      manually put because of RemoteViews limitations.)
+   * @param viewId        The id of the ImageView view that will load the image.
+   * @param remoteViews   RemoteViews object which contains the ImageView that will load the
+   *                      bitmap.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, ComponentName componentName) {
+  public AppWidgetTarget(Context context, int width, int height,
+      int viewId, RemoteViews remoteViews, ComponentName componentName) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context can not be null!");
     this.remoteViews =
@@ -94,14 +94,14 @@ public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId, int
    * order to update it that uses {@link #SIZE_ORIGINAL} as the target width and height.
    *
    * @param context       Context to use in the AppWidgetManager initialization.
+   * @param viewId        The id of the ImageView view that will load the image.
    * @param remoteViews   RemoteViews object which contains the ImageView that will load the
    *                      bitmap.
-   * @param viewId        The id of the ImageView view that will load the image.
    * @param componentName The ComponentName that refers to our AppWidget.
    */
-  public AppWidgetTarget(Context context, RemoteViews remoteViews, int viewId,
-      ComponentName componentName) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, componentName);
+  public AppWidgetTarget(Context context,
+      int viewId, RemoteViews remoteViews, ComponentName componentName) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
index ec889d0ad..60171de82 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java
@@ -18,7 +18,6 @@
  * for every subsequent load. </p>
  */
 public class NotificationTarget extends SimpleTarget<Bitmap> {
-
   private final RemoteViews remoteViews;
   private final Context context;
   private final int notificationId;
@@ -31,15 +30,15 @@
    * height.
    *
    * @param context        Context to use in the AppWidgetManager initialization.
+   * @param viewId         The id of the ImageView view that will load the image.
    * @param remoteViews    RemoteViews object which contains the ImageView that will load the
    *                       bitmap.
-   * @param viewId         The id of the ImageView view that will load the image.
    * @param notification   The Notification object that we want to update.
    * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
    */
-  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
-      Notification notification, int notificationId) {
-    this(context, remoteViews, viewId, SIZE_ORIGINAL, SIZE_ORIGINAL, notification, notificationId);
+  public NotificationTarget(Context context,
+      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {
+    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId);
   }
 
   /**
@@ -47,18 +46,18 @@ public NotificationTarget(Context context, RemoteViews remoteViews, int viewId,
    * Notification in order to update it.
    *
    * @param context        Context to use in the AppWidgetManager initialization.
-   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
-   *                       bitmap.
-   * @param viewId         The id of the ImageView view that will load the image.
    * @param width          Desired width of the bitmap that will be loaded.(Need to be manually put
    *                       because of RemoteViews limitations.)
    * @param height         Desired height of the bitmap that will be loaded. (Need to be manually
    *                       put because of RemoteViews limitations.)
+   * @param viewId         The id of the ImageView view that will load the image.
+   * @param remoteViews    RemoteViews object which contains the ImageView that will load the
+   *                       bitmap.
    * @param notification   The Notification object that we want to update.
    * @param notificationId The notificationId of the Notification that we want to load the Bitmap.
    */
-  public NotificationTarget(Context context, RemoteViews remoteViews, int viewId, int width,
-      int height, Notification notification, int notificationId) {
+  public NotificationTarget(Context context, int width, int height,
+      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {
     super(width, height);
     this.context = Preconditions.checkNotNull(context, "Context must not be null!");
     this.notification =
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
index 5192b150b..2417f8ab6 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java
@@ -15,6 +15,9 @@
 
   /**
    * A factory that always returns the same {@link NoTransition}.
+   *
+   * @param <R> the resource type that will be transitioned into a
+   * {@link com.bumptech.glide.request.target.Target}.
    */
   public static class NoAnimationFactory<R> implements TransitionFactory<R> {
     @SuppressWarnings("unchecked")
diff --git a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
index 37f15a62f..4c0474748 100644
--- a/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
+++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.signature;
 
 import com.bumptech.glide.load.Key;
+import com.bumptech.glide.util.Util;
 
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
@@ -32,6 +33,7 @@ public MediaStoreSignature(String mimeType, long dateModified, int orientation)
     this.orientation = orientation;
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -49,10 +51,9 @@ public boolean equals(Object o) {
     if (orientation != that.orientation) {
       return false;
     }
-    if (mimeType != null ? !mimeType.equals(that.mimeType) : that.mimeType != null) {
+    if (!Util.bothNullOrEqual(mimeType, that.mimeType)) {
       return false;
     }
-
     return true;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
index 72204c4b4..a3f5c3de0 100644
--- a/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
+++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.util;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -112,6 +113,27 @@ public static InputStream toStream(ByteBuffer buffer) {
     return new ByteBufferStream(buffer);
   }
 
+  public static ByteBuffer fromStream(InputStream stream) throws IOException {
+    ByteArrayOutputStream outStream = new ByteArrayOutputStream(BUFFER_SIZE);
+
+    byte[] buffer = BUFFER_REF.getAndSet(null);
+    if (buffer == null) {
+      buffer = new byte[BUFFER_SIZE];
+    }
+
+    int n = -1;
+    while ((n = stream.read(buffer)) >= 0) {
+      outStream.write(buffer, 0, n);
+    }
+
+    BUFFER_REF.set(buffer);
+
+    byte[] bytes = outStream.toByteArray();
+
+    // Some resource decoders require a direct byte buffer. Prefer allocateDirect() over wrap()
+    return (ByteBuffer) ByteBuffer.allocateDirect(bytes.length).put(bytes).position(0);
+  }
+
   private static SafeArray getSafeArray(ByteBuffer byteBuffer) {
     if (!byteBuffer.isReadOnly() && byteBuffer.hasArray()) {
       return new SafeArray(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit());
diff --git a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
index de27683b6..18fd5e04e 100644
--- a/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
+++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java
@@ -3,6 +3,7 @@
 /**
  * A key of two {@link Class}es to be used in hashed collections.
  */
+@SuppressWarnings({"PMD.ConstructorCallsOverridableMethod"})
 public class MultiClassKey {
   private Class<?> first;
   private Class<?> second;
@@ -35,6 +36,7 @@ public String toString() {
     return "MultiClassKey{" + "first=" + first + ", second=" + second + '}';
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
@@ -52,10 +54,7 @@ public boolean equals(Object o) {
     if (!second.equals(that.second)) {
       return false;
     }
-    if (third == null && that.third != null) {
-      return false;
-    }
-    if (third != null && !third.equals(that.third)) {
+    if (!Util.bothNullOrEqual(third, that.third)) {
       return false;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 762d49765..0f9c35794 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -37,6 +37,7 @@ public static String sha256BytesToHex(byte[] bytes) {
   // Taken from:
   // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
   // /9655275#9655275
+  @SuppressWarnings("PMD.UseVarargs")
   private static String bytesToHex(byte[] bytes, char[] hexChars) {
     int v;
     for (int j = 0; j < bytes.length; j++) {
@@ -108,6 +109,7 @@ private static int getBytesPerPixel(Bitmap.Config config) {
       case ARGB_8888:
       default:
         bytesPerPixel = 4;
+        break;
     }
     return bytesPerPixel;
   }
@@ -178,4 +180,13 @@ public static boolean isOnBackgroundThread() {
       }
       return result;
   }
+
+  /**
+   * Null-safe equivalent of {@code a.equals(b)}.
+   *
+   * @see java.util.Objects#equals
+   */
+  public static boolean bothNullOrEqual(Object a, Object b) {
+    return a == null ? b == null : a.equals(b);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
index 5677b391d..f37f74fe8 100644
--- a/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
+++ b/library/src/main/java/com/bumptech/glide/util/ViewPreloadSizeProvider.java
@@ -40,7 +40,7 @@ public ViewPreloadSizeProvider() {
    *             android.view.ViewTreeObserver .OnPreDrawListener}
    */
   public ViewPreloadSizeProvider(View view) {
-    setView(view);
+    this.viewTarget = new SizeViewTarget(view, this);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
index 87c9d71fc..009ddebf6 100644
--- a/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
+++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java
@@ -105,6 +105,8 @@ public void reset(List<T> object) {
 
   /**
    * Creates new instances of the given type.
+   *
+   * @param <T> The type of Object that will be created.
    */
   public interface Factory<T> {
     T create();
@@ -112,6 +114,8 @@ public void reset(List<T> object) {
 
   /**
    * Resets state when objects are returned to the pool.
+   *
+   * @param <T> The type of Object that will be reset.
    */
   public interface Resetter<T> {
     void reset(T object);
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index 01bdd28b8..c64747fdb 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -39,6 +39,7 @@
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
@@ -654,15 +655,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
     @Override
     public void applyOptions(Context context, GlideBuilder builder) {
       // Run all tasks on the main thread so they complete synchronously.
-      GlideExecutor executor = mock(GlideExecutor.class);
-      doAnswer(new Answer<Void>() {
-        @Override
-        public Void answer(InvocationOnMock invocation) throws Throwable {
-          Runnable runnable = (Runnable) invocation.getArguments()[0];
-          runnable.run();
-          return null;
-        }
-      }).when(executor).execute(isA(Runnable.class));
+      GlideExecutor executor = MockGlideExecutor.newMainThreadExecutor();
 
       DiskCache.Factory diskCacheFactory = mock(DiskCache.Factory.class);
       when(diskCacheFactory.build()).thenReturn(mock(DiskCache.class));
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index f08fae2af..d27622655 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -70,12 +70,12 @@ public void testRemovesPreviousRequestFromRequestTracker() {
     verify(requestManager).clear(eq(target));
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfGivenNullTarget() {
     getNullModelRequest().into((Target) null);
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfGivenNullView() {
     getNullModelRequest().into((ImageView) null);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 678b9460a..4cef86d3a 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -10,9 +10,9 @@
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.testutil.TestUtil;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 
 import org.junit.After;
 import org.junit.Before;
@@ -55,7 +55,7 @@ public void setUp() throws IOException {
     defaultFollowRedirects = HttpURLConnection.getFollowRedirects();
     HttpURLConnection.setFollowRedirects(false);
     mockWebServer = new MockWebServer();
-    mockWebServer.play();
+    mockWebServer.start();
 
     streamCaptor = ArgumentCaptor.forClass(InputStream.class);
   }
@@ -80,7 +80,7 @@ public void testReturnsInputStreamOnStatusOk() throws Exception {
   public void testHandlesRedirect301s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
@@ -91,7 +91,7 @@ public void testHandlesRedirect301s() throws Exception {
   public void testHandlesRedirect302s() throws Exception {
     String expected = "fakedata";
     mockWebServer.enqueue(new MockResponse().setResponseCode(302)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
     getFetcher().loadData(Priority.LOW, callback);
     verify(callback).onDataReady(streamCaptor.capture());
@@ -120,7 +120,7 @@ public void testHandlesUpToFiveRedirects() throws Exception {
     String redirectBase = "/redirect";
     for (int i = 0; i < numRedirects; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
+          .setHeader("Location", mockWebServer.url(redirectBase + i).toString()));
     }
     mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
 
@@ -137,9 +137,9 @@ public void testHandlesUpToFiveRedirects() throws Exception {
   @Test
   public void testFailsOnRedirectLoops() throws Exception {
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
     mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-        .setHeader("Location", mockWebServer.getUrl("/redirect")));
+        .setHeader("Location", mockWebServer.url("/redirect").toString()));
 
     getFetcher().loadData(Priority.IMMEDIATE, callback);
 
@@ -176,7 +176,7 @@ public void testFailsIfStatusCodeIsNegativeOne() throws Exception {
   public void testFailsAfterTooManyRedirects() throws Exception {
     for (int i = 0; i < 10; i++) {
       mockWebServer.enqueue(new MockResponse().setResponseCode(301)
-          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
+          .setHeader("Location", mockWebServer.url("/redirect" + i).toString()));
     }
     getFetcher().loadData(Priority.NORMAL, callback);
 
@@ -204,7 +204,7 @@ public void testSetsReadTimeout() throws Exception {
     MockWebServer tempWebServer = new MockWebServer();
     tempWebServer.enqueue(
         new MockResponse().setBody("test").throttleBody(1, TIMEOUT_TIME_MS, TimeUnit.MILLISECONDS));
-    tempWebServer.play();
+    tempWebServer.start();
 
     try {
       getFetcher().loadData(Priority.HIGH, callback);
@@ -233,11 +233,11 @@ public void testAppliesHeadersInGlideUrl() throws Exception {
   }
 
   private HttpUrlFetcher getFetcher() {
-    return getFetcher(Headers.NONE);
+    return getFetcher(Headers.DEFAULT);
   }
 
   private HttpUrlFetcher getFetcher(Headers headers) {
-    URL url = mockWebServer.getUrl(DEFAULT_PATH);
+    URL url = mockWebServer.url(DEFAULT_PATH).url();
     return new HttpUrlFetcher(new GlideUrl(url, headers), TIMEOUT_TIME_MS,
         HttpUrlFetcher.DEFAULT_CONNECTION_FACTORY);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index b9790640b..3a4f231ef 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.data.resource;
 
 import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -26,6 +27,8 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.internal.ShadowExtractor;
 
+import java.io.FileNotFoundException;
+
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class FileDescriptorLocalUriFetcherTest {
@@ -38,9 +41,9 @@ public void setUp() {
   }
 
   @Test
-  public void testLoadsFileDescriptor() throws Exception {
-    final Context context = RuntimeEnvironment.application;
-    final Uri uri = Uri.parse("file://nothing");
+  public void testLoadResource_returnsFileDescriptor() throws Exception {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
     ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
@@ -55,4 +58,17 @@ public void testLoadsFileDescriptor() throws Exception {
     verify(callback).onDataReady(eq(parcelFileDescriptor));
   }
 
+  @Test
+  public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
+
+    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
+    fetcher.loadData(Priority.NORMAL, callback);
+    verify(callback).onLoadFailed(isA(FileNotFoundException.class));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index ee8f8d922..9e93b4880 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -1,14 +1,17 @@
 package com.bumptech.glide.load.data.resource;
 
+import static org.mockito.Matchers.isA;
 import static org.mockito.Matchers.isNotNull;
 import static org.mockito.Mockito.verify;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
 
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
+import com.bumptech.glide.tests.ContentResolverShadow;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -18,11 +21,14 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.internal.ShadowExtractor;
 
+import java.io.ByteArrayInputStream;
+import java.io.FileNotFoundException;
 import java.io.InputStream;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
 public class StreamLocalUriFetcherTest {
   @Mock DataFetcher.DataCallback<InputStream> callback;
 
@@ -32,11 +38,32 @@ public void setUp() {
   }
 
   @Test
-  public void testLoadsInputStream() throws Exception {
-    final Context context = RuntimeEnvironment.application;
-    Uri uri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
+  public void testLoadResource_returnsInputStream() throws Exception {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
+
     StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
   }
+
+  @Test
+  public void testLoadResource_withNullInputStream_callsLoadFailed() {
+    Context context = RuntimeEnvironment.application;
+    Uri uri = Uri.parse("file://nothing");
+
+    ContentResolver contentResolver = context.getContentResolver();
+    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+
+    shadow.registerInputStream(uri, null /*inputStream*/);
+
+    StreamLocalUriFetcher fecther = new StreamLocalUriFetcher(context, uri);
+    fecther.loadData(Priority.LOW, callback);
+
+    verify(callback).onLoadFailed(isA(FileNotFoundException.class));
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 1987cc797..eb9198f88 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -21,6 +21,7 @@
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 
 import org.junit.Before;
@@ -414,27 +415,30 @@ public void testCancelsDecodeJobOnCancel() {
   @Test
   public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {
     EngineJob<Object> job = harness.getJob();
+    harness.diskCacheService.shutdownNow();
     job.reschedule(harness.decodeJob);
 
-    verify(harness.sourceService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
   }
 
   @Test
   public void testSubmitsDecodeJobToDiskCacheServiceWhenDecodingFromCacheOnStart() {
     EngineJob<Object> job = harness.getJob();
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(true);
+    harness.diskCacheService.shutdownNow();
     job.start(harness.decodeJob);
 
-    verify(harness.diskCacheService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
   }
 
   @Test
   public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSoureOnlyOnStart() {
     EngineJob<Object> job = harness.getJob();
     when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    harness.diskCacheService.shutdownNow();
     job.start(harness.decodeJob);
 
-    verify(harness.sourceService).execute(eq(harness.decodeJob));
+    verify(harness.decodeJob).run();
   }
 
   @SuppressWarnings("unchecked")
@@ -448,8 +452,8 @@ public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSoureOnlyOnStart(
     List<ResourceCallback> cbs = new ArrayList<>();
     EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
     EngineJob<Object> job;
-    GlideExecutor diskCacheService = mock(GlideExecutor.class);
-    GlideExecutor sourceService = mock(GlideExecutor.class);
+    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     DataSource dataSource = DataSource.LOCAL;
@@ -476,8 +480,8 @@ public MultiCbHarness() {
     Resource<Object> resource = mock(Resource.class);
     EngineResource<Object> engineResource = mock(EngineResource.class);
     EngineJobListener listener = mock(EngineJobListener.class);
-    GlideExecutor diskCacheService = mock(GlideExecutor.class);
-    GlideExecutor sourceService = mock(GlideExecutor.class);
+    GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
     boolean isCacheable = true;
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 8cbe62361..ac0098a9d 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -27,6 +27,7 @@
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.engine.cache.MemoryCache;
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.load.engine.executor.MockGlideExecutor;
 import com.bumptech.glide.request.ResourceCallback;
 import com.bumptech.glide.tests.BackgroundUtil;
 import com.bumptech.glide.tests.GlideShadowLooper;
@@ -476,9 +477,10 @@ public EngineTestHarness() {
 
       job = mock(EngineJob.class);
 
-      engine = new Engine(cache, mock(DiskCache.Factory.class), mock(GlideExecutor.class),
-          mock(GlideExecutor.class), jobs, keyFactory, activeResources, engineJobFactory,
-          decodeJobFactory, resourceRecycler);
+      engine = new Engine(cache, mock(DiskCache.Factory.class),
+          GlideExecutor.newDiskCacheExecutor(),
+          MockGlideExecutor.newMainThreadExecutor(), jobs, keyFactory, activeResources,
+          engineJobFactory, decodeJobFactory, resourceRecycler);
     }
 
     public Engine.LoadStatus doLoad() {
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
new file mode 100644
index 000000000..f48d297dd
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java
@@ -0,0 +1,111 @@
+package com.bumptech.glide.load.engine.bitmap_recycle;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.DEFAULT, sdk = 18)
+public class LruArrayPoolTest {
+  private static final int MAX_SIZE = 10;
+  private static final Class ARRAY_CLASS = byte[].class;
+  private static final ArrayAdapterInterface ADAPTER = new ByteArrayAdapter();
+  private LruArrayPool pool;
+
+  @Before
+  public void setUp() throws Exception {
+    pool = new LruArrayPool(MAX_SIZE);
+  }
+
+  @Test
+  public void testNewPoolIsEmpty() {
+    assertEquals(pool.getCurrentSize(), 0);
+  }
+
+  @Test
+  public void testICanAddAndGetValidArray() {
+    int size = 758;
+    int value = 564;
+    fillPool(pool, size - 1, value);
+    pool.put(createArray(ARRAY_CLASS, size, value), ARRAY_CLASS);
+    Object array = pool.get(size, ARRAY_CLASS);
+    assertNotNull(array);
+    assertTrue(ADAPTER.getArrayLength(array) >= size);
+    assertTrue(array.getClass() == ARRAY_CLASS);
+    assertTrue(((byte[]) array)[0] == (byte) 0);
+  }
+
+  @Test
+  public void testItIsSizeLimited() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 1);
+    assertTrue(pool.getCurrentSize() <= MAX_SIZE);
+  }
+
+  @Test
+  public void testArrayLargerThanPoolIsNotAdded() {
+    pool = new LruArrayPool(MAX_SIZE);
+    pool.put(createArray(ARRAY_CLASS, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0),
+        ARRAY_CLASS);
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testClearMemoryRemovesAllArrays() {
+    fillPool(pool, MAX_SIZE / ADAPTER.getElementSizeInBytes() + 1, 0);
+    pool.clearMemory();
+    assertEquals(0, pool.getCurrentSize());
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
+  }
+
+  @Test
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {
+    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {
+      testTrimMemory(MAX_SIZE, trimLevel, 0);
+    }
+  }
+
+  private void testTrimMemory(int fillSize, int trimLevel, int expectedSize) {
+    pool = new LruArrayPool(MAX_SIZE);
+    fillPool(pool, fillSize / ADAPTER.getElementSizeInBytes(), 1);
+    pool.trimMemory(trimLevel);
+    assertEquals("Failed level=" + trimLevel, expectedSize, pool.getCurrentSize());
+  }
+
+  private void fillPool(LruArrayPool pool, int arrayCount, int arrayLength) {
+    for (int i = 0; i < arrayCount; i++) {
+      pool.put(createArray(ARRAY_CLASS, arrayLength, 10), ARRAY_CLASS);
+    }
+  }
+
+  private Object createArray(Class type, int size, int value) {
+    Object array = null;
+    if (type.equals(int[].class)) {
+      array = new int[size];
+      Arrays.fill((int[]) array, value);
+    } else if (type.equals(byte[].class)) {
+      array = new byte[size];
+      Arrays.fill((byte[]) array, (byte) value);
+    }
+    return array;
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
index 6db6062dd..14b51fedc 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java
@@ -2,7 +2,7 @@
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -102,18 +102,18 @@ public void testEvictedBitmapsAreRecycled() {
   }
 
   @Test
-  public void testTrimMemoryBackgroundOrLessRemovesHalfOfBitmaps() {
-    testTrimMemory(MAX_SIZE, TRIM_MEMORY_BACKGROUND, MAX_SIZE / 2);
+  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfBitmaps() {
+    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);
   }
 
   @Test
-  public void testTrimMemoryBackgroundOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
-    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_BACKGROUND, 0);
+  public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {
+    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, 0);
   }
 
   @Test
-  public void testTrimMemoryModerateOrGreaterRemovesAllBitmaps() {
-    for (int trimLevel : new int[] { TRIM_MEMORY_MODERATE, TRIM_MEMORY_COMPLETE }) {
+  public void testTrimMemoryBackgroundOrGreaterRemovesAllBitmaps() {
+    for (int trimLevel : new int[] { TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE }) {
       testTrimMemory(MAX_SIZE, trimLevel, MAX_SIZE);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
index 61918f223..4944d2564 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java
@@ -39,30 +39,30 @@ public TrimClearMemoryCacheHarness() {
   }
 
   @Test
-  public void testTrimMemoryModerate() {
+  public void testTrimMemoryBackground() {
     TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
 
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
 
     verify(harness.listener).onResourceRemoved(eq(harness.first));
     verify(harness.listener).onResourceRemoved(eq(harness.second));
   }
 
   @Test
-  public void testTrimMemoryComplete() {
+  public void testTrimMemoryModerate() {
     TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
 
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);
 
     verify(harness.listener).onResourceRemoved(harness.first);
     verify(harness.listener).onResourceRemoved(harness.second);
   }
 
   @Test
-  public void testTrimMemoryBackground() {
+  public void testTrimMemoryUiHidden() {
     TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();
 
-    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
+    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
 
     verify(harness.listener).onResourceRemoved(harness.first);
     verify(harness.listener, never()).onResourceRemoved(harness.second);
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index 3d3bb983c..d22bf9fa9 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -141,7 +141,7 @@ public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
 
     Util.setSdkVersionInt(10);
 
-    int byteArrayPoolSize = harness.getCalculator().getByteArrayPoolSize();
+    int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
     assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
   }
 
@@ -161,7 +161,7 @@ private int getLargeEnoughMemoryClass() {
     float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;
     float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;
     float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;
-    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.BYTE_ARRAY_POOL_SIZE_BYTES;
+    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.ARRAY_POOL_SIZE_BYTES;
     ActivityManager activityManager =
         (ActivityManager) RuntimeEnvironment.application.getSystemService(Context.ACTIVITY_SERVICE);
     MemorySizeCalculator.ScreenDimensions screenDimensions =
@@ -176,7 +176,7 @@ public MemorySizeCalculator getCalculator() {
           .setMaxSizeMultiplier(sizeMultiplier)
           .setActivityManager(activityManager)
           .setScreenDimensions(screenDimensions)
-          .setByteArrayPoolSize(byteArrayPoolSizeBytes)
+          .setArrayPoolSize(byteArrayPoolSizeBytes)
           .build();
     }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
index 1a6f5d9cd..54cf63722 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/GlideExecutorTest.java
@@ -19,7 +19,7 @@
   @Test
   public void testLoadsAreExecutedInOrder() throws InterruptedException {
     final List<Integer> resultPriorities = Collections.synchronizedList(new ArrayList<Integer>());
-    GlideExecutor executor = new GlideExecutor(1);
+    GlideExecutor executor = GlideExecutor.newDiskCacheExecutor();
     for (int i = 5; i > 0; i--) {
       executor.execute(new MockRunnable(i, new MockRunnable.OnRun() {
         @Override
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
new file mode 100644
index 000000000..2b5d216f2
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.load.engine.executor;
+
+/**
+ * Creates mock {@link GlideExecutor}s.
+ */
+public final class MockGlideExecutor {
+
+  private MockGlideExecutor() { }
+
+  public static GlideExecutor newMainThreadExecutor() {
+    return new GlideExecutor(1 /*poolSize*/, "mock-glide-executor",
+        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
+        true /*runAllOnMainThread*/);
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
new file mode 100644
index 000000000..640ed84f2
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -0,0 +1,136 @@
+package com.bumptech.glide.load.model;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import android.support.annotation.Nullable;
+import android.util.Base64;
+
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * Tests for the {@link DataUrlLoader} class.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DataUrlLoaderTest {
+
+  // A valid base64-encoded PNG (a small "Google" logo).
+  private static final String VALID_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAALCA"
+      + "YAAAAeEY8BAAADFElEQVR42mNgAAK5ig+CiiUfSmUL3mVL5r7PE8t5M1U06027eMYLMQZKQUMDE8eyxGrOJYmdDKtC"
+      + "mTHkFfO/iCsUfTykUPFeASH6n1Es+3WjSM5rKQYqANbFcTmsC2OXYpWUKXw/R67ofQEhQ+5FecnfDnYxPJNmzAp35n"
+      + "8Gxv/7pTT+75PQBrFh4iq5b/lk8z+aiue+tZDKeaPBMC8qh2leFNgB/xkYGO+Eu+ncCnZRAiuWyHv3VDzngxMui0EW"
+      + "Pgpx6n4U4Wx7J8De86aP2blrrgaq//fwCv8/KNT//5CU0f99okn/dwse+b9fQECx9IObQvGHMrn8D66See9eiWa9s2"
+      + "GYE57DMCdi6Qs3N+6HIc4T70a4mtz2t55909u0jkE85+1Tsdx30ciWSuQ+F+VPe6kskPFc4Z6XRcp9H8t2mNxVF72G"
+      + "q066K//vZe//v4cDru//ds7V/7dx1MoXf9gtW/zRFGLO+x7x7DeVDDOBDpgZvvSut3nWXR/LyptuxgG33Axzr7rr2T"
+      + "KIZb1eIpL1ejco3mGGCWe8cRJMf7FVKO1F/y1Xww4gng6Tu+Ko7X7JTvPo/52Mm//vYMqBO2AbU/H/LUwzpQreT5LO"
+      + "f98PEhPLftslkfvGjGF6aA4QL73halh7y9XgwHVnM2G4b0G+FM549Uw440U7Q+h/eCoVSH0+GYjrrjrr2V530n16w1"
+      + "qdFyR+wUYr6YKNRtH/7QzpQHzsfwMDE9gBmxl6/29hcNdu+M8G9HmCWM7bQ6I5bxPBhk0NzmGYErT0mpOe0TVHnY+X"
+      + "HXRMQMKrQhkg9omkvZYUSHvZJ5T+Yh3IUoHUZ/mCqc87BdOe2UB9HXzZQWvCeTuNqPO2GgmghAROgFsZ8oCWtgBxDN"
+      + "ABASC1olmveEQyX/sB8SKRzJcPgbQxw0S/IoaJvksZJvsqXnLQDLhoq7n7nI3GxHOWWs4M1AQ8ic9FhdNf7ZRKeyYC"
+      + "jsrUly7AqDzOQC8glP7SFWjhCVhUKiTc5xBIebaAbg4AWcyf+qxNMPXZKoGU57UCqU+KQKGCTwsAbxBBmvLaD+cAAA"
+      + "AASUVORK5CYII=";
+
+  private static final String INVALID_URL_WRONG_SCHEME1 = "test";
+  private static final String INVALID_URL_WRONG_SCHEME2 = "http://google.com";
+  private static final String INVALID_URL_WRONG_SCHEME3 = "data:text";
+  private static final String INVALID_URL_MISSING_COMMA = "data:image/png;base64=NOTBASE64";
+  private static final String INVALID_URL_WRONG_ENCODING = "data:image/png;base32,";
+
+  @Mock
+  private MultiModelLoaderFactory multiFactory;
+  private DataUrlLoader<Object> dataUrlLoader;
+  private DataFetcher<Object> fetcher;
+  private Options options;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+    DataUrlLoader.StreamFactory factory = new DataUrlLoader.StreamFactory();
+    options = new Options();
+    dataUrlLoader = (DataUrlLoader) factory.build(RuntimeEnvironment.application, multiFactory);
+    fetcher = dataUrlLoader.buildLoadData(VALID_PNG, -1, -1, options).fetcher;
+
+  }
+
+  @Test
+  public void testHandleDataUri() {
+    assertTrue(dataUrlLoader.handles(VALID_PNG));
+  }
+
+  @Test
+  public void testHandleFalseDataUri() {
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME1));
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME2));
+    assertFalse(dataUrlLoader.handles(INVALID_URL_WRONG_SCHEME3));
+  }
+
+  @Test
+  public void testDecode() throws IOException {
+    byte[] expected = Base64
+        .decode(VALID_PNG.substring(VALID_PNG.indexOf(',') + 1), Base64.DEFAULT);
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    byte[] result = new byte[((ByteArrayInputStream) callback.data).available()];
+    ((ByteArrayInputStream) callback.data).read(result);
+    assertTrue(Arrays.equals(result, expected));
+    assertNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeInvalidScheme() throws IOException {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_SCHEME1, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeMissingComma() throws IOException {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_MISSING_COMMA, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  @Test
+  public void testDecodeWrongEncoding() throws IOException {
+    fetcher = dataUrlLoader.buildLoadData(INVALID_URL_WRONG_ENCODING, -1, -1, options).fetcher;
+    CallBack callback = new CallBack();
+    fetcher.loadData(Priority.HIGH, callback);
+    assertNotNull(callback.exception);
+  }
+
+  private class CallBack implements DataFetcher.DataCallback<Object> {
+
+    public Object data;
+    public Exception exception;
+
+    @Override
+    public void onDataReady(@Nullable Object data) {
+      this.data = data;
+    }
+
+    @Override
+    public void onLoadFailed(Exception e) {
+      this.exception = e;
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
index 8e0269c4e..3b65bc59a 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java
@@ -6,8 +6,12 @@
 
 import com.google.common.testing.EqualsTester;
 
+import android.support.annotation.Nullable;
+
 import com.bumptech.glide.load.model.LazyHeaders.Builder;
 
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -18,6 +22,22 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
 public class LazyHeadersTest {
+  private static final String DEFAULT_USER_AGENT = "default_user_agent";
+  private static final String DEFAULT_USER_AGENT_PROPERTY = "http.agent";
+  private String initialUserAgent;
+
+  @Before
+  public void setUp() {
+    initialUserAgent = System.getProperty(DEFAULT_USER_AGENT_PROPERTY);
+    System.setProperty(DEFAULT_USER_AGENT_PROPERTY, DEFAULT_USER_AGENT);
+  }
+
+  @After
+  public void tearDown() {
+    if (initialUserAgent != null) {
+      System.setProperty(DEFAULT_USER_AGENT_PROPERTY, initialUserAgent);
+    }
+  }
 
   @Test
   public void testIncludesEagerHeaders() {
@@ -211,6 +231,55 @@ public void testRemovingAndAddingUserAgentHeaderReplacesDefaultThenAppends() {
     assertThat(headers.getHeaders()).containsEntry("User-Agent", "false,true");
   }
 
+  @Test
+  public void testKeyNotIncludedWithFactoryThatReturnsNullValue() {
+    Builder builder = new Builder();
+    builder.setHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return null;
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("test");
+  }
+
+  @Test
+  public void testKeyNotIncludedWithFactoryThatReturnsEmptyValue() {
+    Builder builder = new Builder();
+    builder.setHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return "";
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).doesNotContainKey("test");
+  }
+
+  @Test
+  public void testKeyIncludedWithOneFactoryThatReturnsNullAndOneFactoryThatDoesNotReturnNull() {
+    Builder builder = new Builder();
+    builder.addHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return null;
+      }
+    });
+    builder.addHeader("test", new LazyHeaderFactory() {
+      @Nullable
+      @Override
+      public String buildHeader() {
+        return "value";
+      }
+    });
+    LazyHeaders headers = builder.build();
+    assertThat(headers.getHeaders()).containsEntry("test", "value");
+  }
+
   @Test
   public void testEquals() {
     LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
new file mode 100644
index 000000000..3121e7701
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -0,0 +1,118 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+
+import com.bumptech.glide.load.Transformation;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
+import com.bumptech.glide.tests.KeyAssertions;
+import com.bumptech.glide.tests.Util;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowCanvas;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18, shadows = { CenterInsideTest.DrawNothingCanvas.class })
+public class CenterInsideTest {
+
+  @Mock Resource<Bitmap> resource;
+  @Mock Transformation<Bitmap> transformation;
+  private BitmapPool pool;
+  private CenterInside centerInside;
+  private int bitmapWidth;
+  private int bitmapHeight;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    bitmapWidth = 100;
+    bitmapHeight = 100;
+    Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
+    when(resource.get()).thenReturn(bitmap);
+
+    pool = new BitmapPoolAdapter();
+
+    centerInside = new CenterInside(pool);
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfMatchesSizeExactly() {
+    Resource<Bitmap> result =
+            centerInside.transform(resource, bitmapWidth, bitmapHeight);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testReturnsGivenResourceIfSmallerThanTarget() {
+    Resource<Bitmap> result =
+        centerInside.transform(resource, 150, 150);
+
+    assertEquals(resource, result);
+  }
+
+  @Test
+  public void testReturnsNewResourceIfLargerThanTarget() {
+    Resource<Bitmap> result =
+        centerInside.transform(resource, 50, 50);
+
+    assertNotEquals(resource, result);
+  }
+
+
+  @Test
+  public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
+    centerInside.transform(resource, bitmapWidth, bitmapHeight);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testDoesNotRecycleGivenResource() {
+    centerInside.transform(resource, 50, 50);
+
+    verify(resource, never()).recycle();
+  }
+
+  @Test
+  public void testEquals() throws NoSuchAlgorithmException {
+    KeyAssertions.assertSame(centerInside, new CenterInside(pool));
+
+    doAnswer(new Util.WriteDigest("other")).when(transformation)
+        .updateDiskCacheKey(any(MessageDigest.class));
+    KeyAssertions.assertDifferent(centerInside, transformation);
+  }
+
+  @Implements(Canvas.class)
+  public static final class DrawNothingCanvas extends ShadowCanvas {
+
+    @Implementation
+    @Override
+    public void drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) {
+      // Do nothing.
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
index 63bd65c10..6a629a101 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -90,18 +90,17 @@ private void assertSamePixels(Bitmap expected, Bitmap actual) {
 
   @TargetApi(12)
   private Bitmap createBitmapWithRedCircle(int width, int height) {
-    Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+    int minEdge = Math.min(width, height);
+    float radius = minEdge / 2f;
+
+    Bitmap result = Bitmap.createBitmap(minEdge, minEdge, Bitmap.Config.ARGB_8888);
     result.setHasAlpha(true);
     Canvas canvas = new Canvas(result);
     Paint paint = new Paint();
+    paint.setAntiAlias(true);
     paint.setColor(Color.RED);
 
-    int minEdge = Math.min(width, height);
-    float radius = minEdge / 2f;
-    int left = (width - minEdge) / 2;
-    int top = (height - minEdge) / 2;
-
-    canvas.drawCircle(left + radius, top + radius, radius, paint);
+    canvas.drawCircle(radius, radius, radius, paint);
     return result;
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
index f68d1e556..c6a624025 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java
@@ -91,11 +91,11 @@ public void testAtLeast_withSourceGreaterInOneDimension_returnsScaleFactorOfSmal
 
   @Test
   public void testCenterInside_scalesImageToFitWithinRequestedBounds() {
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 200, 300, 300))
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 200, 300, 300))
         .isEqualTo(300 / 200f);
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(270, 480, 724, 440))
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(270, 480, 724, 440))
         .isEqualTo(440 / 480f);
-    assertThat(DownsampleStrategy.CENTER_INSIDE.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
+    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
index c88e3081a..7ce96f19c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
@@ -112,7 +112,7 @@ public void testCalculateScaling_withAtLeast() {
 
   @Test
   public void testCalculateScaling_withCenterInside() {
-    DownsampleStrategy strategy = DownsampleStrategy.CENTER_INSIDE;
+    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
     runScaleTest(100, 100, 100, 100, strategy, 100, 100);
     runScaleTest(200, 200, 100, 100, strategy, 100, 100);
     runScaleTest(400, 400, 100, 100, strategy, 100, 100);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
index 705246076..4718f0a40 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
@@ -95,6 +95,32 @@ public void run(ImageHeaderParser parser) throws IOException {
     });
   }
 
+  @Test
+  public void testCanParseWebpWithAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
+        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType());
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithoutAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
+        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(ImageHeaderParser parser) throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType());
+      }
+    });
+  }
+
   @Test
   public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
     byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index f403e3080..257e50e75 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -14,7 +14,7 @@
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.tests.GlideShadowLooper;
 
 import org.junit.Before;
@@ -34,6 +34,7 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
 public class ByteBufferGifDecoderTest {
   private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };
+  static final int ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;
 
   private ByteBufferGifDecoder decoder;
   private GifHeader gifHeader;
@@ -58,8 +59,13 @@ public void setUp() {
         .thenReturn(gifDecoder);
 
     options = new Options();
-    decoder = new ByteBufferGifDecoder(RuntimeEnvironment.application, bitmapPool,
-        new LruByteArrayPool(), parserPool, decoderFactory);
+    decoder =
+        new ByteBufferGifDecoder(
+            RuntimeEnvironment.application,
+            bitmapPool,
+            new LruArrayPool(ARRAY_POOL_SIZE_BYTES),
+            parserPool,
+            decoderFactory);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
similarity index 92%
rename from library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
rename to library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
index d1a14b0a1..e78445533 100644
--- a/library/src/test/java/com/bumptech/glide/manager/ConnectivityMonitorFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactoryTest.java
@@ -13,12 +13,12 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
-public class ConnectivityMonitorFactoryTest {
+public class DefaultConnectivityMonitorFactoryTest {
   private ConnectivityMonitorFactory factory;
 
   @Before
   public void setUp() {
-    factory = new ConnectivityMonitorFactory();
+    factory = new DefaultConnectivityMonitorFactory();
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
index 16b4f1d4a..dad0d87eb 100644
--- a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
@@ -1,14 +1,18 @@
 package com.bumptech.glide.request;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.mock;
+
+import android.graphics.Bitmap;
 
 import com.bumptech.glide.load.Transformation;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
@@ -16,20 +20,122 @@
 public class BaseRequestOptionsTest {
 
   private TestOptions options;
+  @Mock private Transformation<Bitmap> transformation;
 
   @Before
   public void setUp() {
+    MockitoAnnotations.initMocks(this);
     options = new TestOptions();
   }
 
   @Test
-  public void testTransformationIsSetAfterApplyingOtherOptionsWithTransformation() {
+  public void testIsTransformationRequired_byDefault_isFalse() {
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationSet_byDefault_isFalse() {
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_byDefault_isTrue() {
+    assertThat(options.isTransformationAllowed()).isTrue();
+  }
+
+  @Test
+  public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
     TestOptions other = new TestOptions();
-    other.transform(Object.class, mock(Transformation.class));
+    other.transform(Bitmap.class, transformation);
     options.apply(other);
     assertThat(options.isTransformationSet()).isTrue();
   }
 
+  @Test
+  public void testIsTransformationSet_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationAllowed_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationAllowed()).isFalse();
+  }
+
+  @Test
+  public void testIsTransformationRequired_afterDontTransform_isFalse() {
+    options.dontTransform();
+    assertThat(options.isTransformationRequired()).isFalse();
+  }
+
+  @Test
+  public void testApplyingDontTransform_overridesTransformations() {
+    options.transform(RuntimeEnvironment.application, transformation);
+    options.dontTransform();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingTransformation_overridesDontTransform() {
+    options.dontTransform();
+    options.transform(RuntimeEnvironment.application, transformation);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingOptions_withDontTransform_overridesTransformations() {
+    options.transform(RuntimeEnvironment.application, transformation);
+    TestOptions other = new TestOptions();
+    other.dontTransform();
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationSet()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingOptions_withTransformation_overridesDontTransform() {
+    options.dontTransform();
+    TestOptions other = new TestOptions();
+    other.transform(RuntimeEnvironment.application, transformation);
+
+    options.apply(other);
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationSet()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
+    options.dontTransform();
+    options.apply(new TestOptions());
+
+    assertThat(options.isTransformationAllowed()).isFalse();
+    assertThat(options.isTransformationRequired()).isFalse();
+    assertThat(options.getTransformations()).isEmpty();
+  }
+
+  @Test
+  public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
+    options.transform(RuntimeEnvironment.application, transformation);
+    options.apply(new TestOptions());
+
+    assertThat(options.isTransformationAllowed()).isTrue();
+    assertThat(options.isTransformationRequired()).isTrue();
+    assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
+  }
+
   private static class TestOptions extends BaseRequestOptions<TestOptions> {
     // Empty.
   }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index 8a13ace4b..da94c9799 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -26,7 +26,6 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = AppWidgetTargetTest
     .UpdateShadowAppWidgetManager.class)
 public class AppWidgetTargetTest {
-
   private UpdateShadowAppWidgetManager shadowManager;
   private RemoteViews views;
   private int viewId;
@@ -43,7 +42,7 @@ public void setUp() {
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName() {
     ComponentName componentName = mock(ComponentName.class);
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
     Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
     target.onResourceReady(bitmap, null /*glideAnimation*/);
@@ -55,7 +54,7 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithComponentName()
   public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
     ComponentName componentName = mock(ComponentName.class);
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, componentName);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);
 
     target.onResourceReady(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888), null
     /*glideAnimation*/);
@@ -68,7 +67,7 @@ public void testUpdatesAppWidgetWhenCreatedWithComponentName() {
   public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
     int[] widgetIds = new int[] { 1 };
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
     Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
     target.onResourceReady(bitmap, null /*glideAnimation*/);
@@ -80,7 +79,7 @@ public void testSetsBitmapOnRemoteViewsWithViewIdWhenCreatedWithWidgetIds() {
   public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
     int[] widgetIds = new int[] { 1 };
     AppWidgetTarget target =
-        new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, widgetIds);
+        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);
 
     target.onResourceReady(Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888), null
     /*glideAnimation*/);
@@ -91,39 +90,39 @@ public void testUpdatesAppWidgetWhenCreatedWithWidgetIds() {
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullContextWithWidgetIds() {
-    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, 1 /*widgetIds*/);
+    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullContextWithComponentName() {
-    new AppWidgetTarget(null /*context*/, views, 1234 /*viewId*/, mock(ComponentName.class));
+    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId, 1
-    /*widgetIds*/);
+    new AppWidgetTarget(RuntimeEnvironment.application,
+        viewId, null /*remoteViews*/, 1 /*widgetIds*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullRemoteViewsWithComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application, null /*remoteViews*/, viewId,
-        mock(ComponentName.class));
+    new AppWidgetTarget(RuntimeEnvironment.application,
+        viewId, null /*remoteViews*/, mock(ComponentName.class));
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (int[]) null /*widgetIds*/);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (int[]) null /*widgetIds*/);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsWhenGivenEmptyWidgetIds() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsWhenGivenNullComponentName() {
-    new AppWidgetTarget(RuntimeEnvironment.application, views, viewId, (ComponentName) null);
+    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (ComponentName) null);
   }
 
   @Implements(AppWidgetManager.class)
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index 1a0dfc8d1..5e085c26e 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -26,7 +26,6 @@
 @Config(manifest = Config.NONE, sdk = 18, shadows = NotificationTargetTest
     .UpdateShadowNotificationManager.class)
 public class NotificationTargetTest {
-
   private UpdateShadowNotificationManager shadowManager;
   private RemoteViews remoteViews;
   private int viewId;
@@ -47,8 +46,8 @@ public void setUp() {
 
 
     target =
-        new NotificationTarget(RuntimeEnvironment.application, remoteViews, viewId, 100 /*width*/,
-            100 /*height*/, notification, notificationId);
+        new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+            viewId, remoteViews, notification, notificationId);
   }
 
   @Test
@@ -69,22 +68,21 @@ public void updatesNotificationManagerWithNotificationIdAndNotificationOnResourc
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfContextIsNull() {
-    new NotificationTarget(null /*context*/, mock(RemoteViews.class), 123 /*viewId*/, 100 /*width*/,
-        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    new NotificationTarget(null /*context*/, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, mock(RemoteViews.class), mock(Notification.class), 456 /*notificationId*/);
   }
 
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfNotificationIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, mock(RemoteViews.class), 123 /*viewId*/,
-        100 /*width*/, 100 /*height*/, null /*notification*/, 456 /*notificationId*/);
+    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, mock(RemoteViews.class), null /*notification*/, 456 /*notificationId*/);
   }
 
   @Test(expected = NullPointerException.class)
   public void testThrowsIfRemoteViewsIsNull() {
-    new NotificationTarget(RuntimeEnvironment.application, null /*remoteViews*/, 123 /*viewId*/,
-        100 /*width*/,
-        100 /*height*/, mock(Notification.class), 456 /*notificationId*/);
+    new NotificationTarget(RuntimeEnvironment.application, 100 /*width*/, 100 /*height*/,
+        123 /*viewId*/, null /*remoteViews*/, mock(Notification.class), 456 /*notificationId*/);
   }
 
   @Implements(NotificationManager.class)
diff --git a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
index aa6adc361..61e476548 100644
--- a/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
+++ b/library/src/test/java/com/bumptech/glide/tests/ContentResolverShadow.java
@@ -6,26 +6,31 @@
 
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowContentResolver;
 
+import java.io.InputStream;
 import java.util.HashMap;
 import java.util.Map;
 
 @Implements(ContentResolver.class)
-public class ContentResolverShadow extends ShadowContentResolver {
-  private Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<>();
+public class ContentResolverShadow {
+  private final Map<Uri, AssetFileDescriptor> fileDescriptorMap = new HashMap<>();
+  private final Map<Uri, InputStream> inputStreamMap = new HashMap<>();
 
   public void registerFileDescriptor(Uri uri, AssetFileDescriptor fileDescriptor) {
     fileDescriptorMap.put(uri, fileDescriptor);
   }
 
+  public void registerInputStream(Uri uri, InputStream inputStream) {
+    inputStreamMap.put(uri, inputStream);
+  }
+
+  @Implementation
+  public InputStream openInputStream(Uri uri) {
+    return inputStreamMap.get(uri);
+  }
+
   @Implementation
   public AssetFileDescriptor openAssetFileDescriptor(Uri uri, String mode) {
-    AssetFileDescriptor fileDescriptor = fileDescriptorMap.get(uri);
-    if (fileDescriptor != null) {
-      return fileDescriptor;
-    } else {
-      return null;
-    }
+    return fileDescriptorMap.get(uri);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/src/test/java/com/bumptech/glide/tests/Util.java
index 366f7d425..ab333bec8 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/src/test/java/com/bumptech/glide/tests/Util.java
@@ -24,6 +24,7 @@
 import java.io.OutputStream;
 import java.security.MessageDigest;
 
+// FIXME move to testutil module
 public class Util {
 
   public static String getExpectedClassId(Class clazz) {
diff --git a/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java b/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
new file mode 100644
index 000000000..4eb221597
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/util/ByteBufferUtilTest.java
@@ -0,0 +1,68 @@
+package com.bumptech.glide.util;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class ByteBufferUtilTest {
+  private static final int BUFFER_SIZE = 16384;
+
+  @Test
+  public void testFromStream_small() throws IOException {
+    testFromStream(4);
+  }
+
+  @Test
+  public void testFromStream_empty() throws IOException {
+    testFromStream(0);
+  }
+
+  @Test
+  public void testFromStream_bufferAndAHalf() throws IOException {
+    testFromStream(BUFFER_SIZE + BUFFER_SIZE / 2);
+  }
+
+  @Test
+  public void testFromStream_massive() throws IOException {
+    testFromStream(12 * BUFFER_SIZE + 12345);
+  }
+
+  /**
+   * All tests are basically the same thing but with different amounts of data.
+   */
+  private void testFromStream(int dataLength) throws IOException {
+    byte[] bytes = createByteData(dataLength);
+    InputStream byteStream = new ByteArrayInputStream(bytes);
+    ByteBuffer byteBuffer = ByteBufferUtil.fromStream(byteStream);
+    assertByteBufferContents(byteBuffer, bytes);
+    byteStream.close();
+  }
+
+  private byte[] createByteData(int size) {
+    byte[] bytes = new byte[size];
+
+    // Put some arbitrary bytes in there.
+    for (int i = 0; i < size; i++) {
+      bytes[i] = (byte) (i % 4);
+    }
+
+    return bytes;
+  }
+
+  private void assertByteBufferContents(ByteBuffer buffer, byte[] expectedBytes) {
+    assertEquals(expectedBytes.length, buffer.limit());
+    for (int i = 0; i < expectedBytes.length; i++) {
+      assertEquals(expectedBytes[i], buffer.get(i));
+    }
+  }
+}
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index 8a924d58a..163c9d220 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -354,7 +354,7 @@ public void run() {
         FutureTarget<File> futureTarget = Glide.with(context)
             .downloadOnly()
             .load(photo)
-            .into(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
+            .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
 
         try {
           futureTarget.get();
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
index 36cb19ab6..42570507e 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Photo.java
@@ -91,6 +91,7 @@ public String toString() {
     return getPartialUrl();
   }
 
+  @SuppressWarnings({"PMD.SimplifyBooleanReturns", "RedundantIfStatement"})
   @Override
   public boolean equals(Object o) {
     if (this == o) {
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index 8346d8778..30b337cf4 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -29,5 +29,5 @@ android {
 
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
-    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.flickr/.FlickrSearchActivity'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.gallery/.MainActivity'
 }
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index 973afa473..58a4e9f06 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -1,7 +1,8 @@
 apply plugin: 'com.android.application'
 
-repositories {
-    mavenCentral()
+dependencies {
+    compile project(':library')
+    compile 'com.caverock:androidsvg:1.2.1'
 }
 
 android {
@@ -23,11 +24,6 @@ android {
     }
 }
 
-dependencies {
-    compile project(':library')
-    compile 'com.caverock:androidsvg:1.2.1'
-}
-
 task run(type: Exec, dependsOn: 'installDebug') {
     description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
     commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.svg/.MainActivity'
diff --git a/scripts/upload.gradle b/scripts/upload.gradle
index ec5af0341..a27f1999b 100644
--- a/scripts/upload.gradle
+++ b/scripts/upload.gradle
@@ -15,6 +15,10 @@
  *
  *
  * Based on: https://github.com/mcxiaoke/gradle-mvn-push/blob/master/gradle-mvn-push.gradle.
+ * Local test with (..._REPOSITORY_URL properties must be full paths):
+ * gradlew clean buildArchives uploadArchives --stacktrace --info -PSNAPSHOT_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-snapshot -PRELEASE_REPOSITORY_URL=file://p:\projects\contrib\github-glide\repo-release
+ * For faster runs add: -x check
+ * 
  */
 
 apply plugin: 'maven'
@@ -29,20 +33,20 @@ def isReleaseBuild() {
 
 def getReleaseRepositoryUrl() {
     return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
-            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+            : 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
 }
 
 def getSnapshotRepositoryUrl() {
     return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
-            : "https://oss.sonatype.org/content/repositories/snapshots/"
+            : 'https://oss.sonatype.org/content/repositories/snapshots/'
 }
 
 def getRepositoryUsername() {
-    return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME')?NEXUS_USERNAME:"")
+    return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : '')
 }
 
 def getRepositoryPassword() {
-    return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD')?NEXUS_PASSWORD:"")
+    return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : '')
 }
 
 afterEvaluate { project ->
@@ -51,6 +55,11 @@ afterEvaluate { project ->
     uploadArchives {
         repositories {
             mavenDeployer {
+                // allow uploading through FTP protocol with the following command:
+                // gradle uploadArchives -PSNAPSHOT_REPOSITORY_URL=ftp://host/repo/path -PUSERNAME=uname -PPASSWORD=passwd
+                configuration = configurations.create('deployerJars')
+                configuration.dependencies.add dependencies.create('org.apache.maven.wagon:wagon-ftp:2.2')
+
                 beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
 
                 pom.groupId = GROUP
@@ -78,14 +87,14 @@ afterEvaluate { project ->
 
                     licenses {
                         license {
-                            name = "Simplified BSD License"
-                            url = "http://www.opensource.org/licenses/bsd-license"
-                            distribution = "repo"
+                            name = 'Simplified BSD License'
+                            url = 'http://www.opensource.org/licenses/bsd-license'
+                            distribution = 'repo'
                         }
                         license {
-                            name = "The Apache Software License, Version 2.0"
-                            url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
-                            distribution = "repo"
+                            name = 'The Apache Software License, Version 2.0'
+                            url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                            distribution = 'repo'
                         }
                     }
 
@@ -102,16 +111,16 @@ afterEvaluate { project ->
     }
 
     signing {
-        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        required { isReleaseBuild() && gradle.taskGraph.hasTask('uploadArchives') }
         sign configurations.archives
     }
 
-    if (project.getPlugins().hasPlugin('android') || project.getPlugins().hasPlugin('android-library')) {
-        def releaseVariants = project.android.libraryVariants.findAll { variant ->
-            variant.buildType.name.equalsIgnoreCase("release")
-        }
+    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library')
 
-        def androidSdkDirectory = project.android.sdkDirectory
+    if (isAndroidProject) {
+        def releaseVariants = project.android.libraryVariants.findAll {
+            it.buildType.name.equalsIgnoreCase('release')
+        }
 
         task androidJavadocs(type: Javadoc, dependsOn: compileReleaseJava) {
             source = releaseVariants.collect { it.javaCompile.source }
@@ -119,8 +128,8 @@ afterEvaluate { project ->
                     project.android.bootClasspath) })
 
             options {
-                links("http://docs.oracle.com/javase/7/docs/api/")
-                linksOffline("http://d.android.com/reference", "${androidSdkDirectory}/docs/reference")
+                links('http://docs.oracle.com/javase/7/docs/api/')
+                linksOffline('http://d.android.com/reference', "${android.sdkDirectory}/docs/reference")
             }
 
             exclude '**/BuildConfig.java'
@@ -128,24 +137,45 @@ afterEvaluate { project ->
         }
 
         task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+            classifier = 'javadoc'
             from androidJavadocs.destinationDir
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
 
         task androidSourcesJar(type: Jar) {
+            classifier = 'sources'
             from project.android.sourceSets.main.java.source
             baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
         }
-    }
 
-    artifacts {
-        if (project.getPlugins().hasPlugin('android') || project.getPlugins().hasPlugin('android-library')) {
-            archives androidSourcesJar {
-                classifier "sources"
-            }
-            archives androidJavadocsJar {
-                classifier "javadoc"
-            }
+        task androidLibraryJar(type: Jar, dependsOn: compileReleaseJava /* == variant.javaCompile */) {
+            from compileReleaseJava.destinationDir
+            exclude '**/R.class'
+            exclude '**/BuildConfig.class'
+            baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"
+        }
+
+        artifacts {
+            archives androidLibraryJar
+            archives androidSourcesJar
+            archives androidJavadocsJar
+        }
+    } else if (project.plugins.hasPlugin('java')) {
+        task sourcesJar(type: Jar, dependsOn: classes) {
+            classifier = 'sources'
+            from sourceSets.main.allSource
+        }
+
+        task javadocsJar(type: Jar, dependsOn: javadoc) {
+            classifier = 'javadoc'
+            from javadoc.destinationDir
+        }
+
+        artifacts {
+            archives sourcesJar
+            archives javadocsJar
         }
     }
+    logger.info("Published artifacts in ${configurations.archives}:")
+    configurations.archives.artifacts.files.files.each { logger.info("\t$it"); }
 }
diff --git a/settings.gradle b/settings.gradle
index 6f0fe1a45..5239ec3ec 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -12,6 +12,7 @@ include ':samples:gallery'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
+include ':integration:okhttp3'
 include ':integration:gifencoder'
 include ':integration:recyclerview'
 include ':testutil'
diff --git a/third_party/disklrucache b/third_party/disklrucache
index 847e0dad0..743de2592 160000
--- a/third_party/disklrucache
+++ b/third_party/disklrucache
@@ -1 +1 @@
-Subproject commit 847e0dad08098c57e6dd12104463780e47e8e24e
+Subproject commit 743de259274020cdef3de809b8537c0775043c8a
diff --git a/third_party/gif_decoder/build.gradle b/third_party/gif_decoder/build.gradle
index e0904012a..bd5aa45e0 100644
--- a/third_party/gif_decoder/build.gradle
+++ b/third_party/gif_decoder/build.gradle
@@ -2,13 +2,13 @@ apply plugin: 'com.android.library'
 apply plugin: 'org.robolectric'
 
 dependencies {
-    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:support-annotations:${SUPPORT_V4_VERSION}"
 
     testCompile project(':testutil')
     testCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
     testCompile "junit:junit:${JUNIT_VERSION}"
-    testCompile "org.mockito:mockito-all:${MOCKITO_VERSION}"
+    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}"
     testCompile "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
 }
 
@@ -21,3 +21,5 @@ android {
         targetSdkVersion TARGET_SDK_VERSION as int
     }
 }
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/third_party/gif_decoder/gradle.properties b/third_party/gif_decoder/gradle.properties
new file mode 100644
index 000000000..53d022433
--- /dev/null
+++ b/third_party/gif_decoder/gradle.properties
@@ -0,0 +1,11 @@
+POM_NAME=Glide Gif Decoder Library
+POM_ARTIFACT_ID=gifdecoder
+POM_PACKAGING=aar
+
+VERSION_NAME=1.0.0-SNAPSHOT
+VERSION_MAJOR=1
+VERSION_MINOR=0
+VERSION_PATCH=0
+VERSION_CODE=1
+
+POM_DESCRIPTION=Implementation of GifDecoder that is more memory efficient to animate for Android devices.
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index b23984a94..a6defca35 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -41,16 +41,16 @@
  * Reads frame data from a GIF image source and decodes it into individual frames for animation
  * purposes.  Image data can be read from either and InputStream source or a byte[].
  *
- * This class is optimized for running animations with the frames, there are no methods to get
+ * <p>This class is optimized for running animations with the frames, there are no methods to get
  * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
  * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
  * in the animation sequence.
  *
- * The animation must be manually moved forward using {@link #advance()} before requesting the next
- * frame.  This method must also be called before you request the first frame or an error will
- * occur.
+ * <p>The animation must be manually moved forward using {@link #advance()} before requesting the
+ * next frame.  This method must also be called before you request the first frame or an error
+ * will occur.
  *
- * Implementation adapted from sample code published in Lyons. (2004). <em>Java for
+ * <p>Implementation adapted from sample code published in Lyons. (2004). <em>Java for
  * Programmers</em>, republished under the MIT Open Source License
  */
 public class GifDecoder {
@@ -170,6 +170,17 @@
      */
     void release(byte[] bytes);
 
+    /**
+     * Returns an int array used for decoding/generating the frame bitmaps.
+     * @param size
+     */
+    int[] obtainIntArray(int size);
+
+    /**
+     * Release the given array back to the pool.
+     * @param array
+     */
+    void release(int[] array);
   }
 
   public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
@@ -307,10 +318,12 @@ public synchronized Bitmap getNextFrame() {
     status = STATUS_OK;
 
     GifFrame currentFrame = header.frames.get(framePointer);
-    GifFrame previousFrame = null;
+    GifFrame previousFrame;
     int previousIndex = framePointer - 1;
     if (previousIndex >= 0) {
       previousFrame = header.frames.get(previousIndex);
+    } else {
+      previousFrame = header.frames.get(getFrameCount() - 1);
     }
 
     final int savedBgColor = header.bgColor;
@@ -391,8 +404,12 @@ public int read(InputStream is, int contentLength) {
 
   public void clear() {
     header = null;
-    mainPixels = null;
-    mainScratch = null;
+    if (mainPixels != null) {
+      bitmapProvider.release(mainPixels);
+    }
+    if (mainScratch != null) {
+      bitmapProvider.release(mainScratch);
+    }
     if (previousImage != null) {
       bitmapProvider.release(previousImage);
     }
@@ -443,8 +460,9 @@ public synchronized void setData(GifHeader header, ByteBuffer buffer, int sample
     // Now that we know the size, init scratch arrays.
     // TODO: Find a way to avoid this entirely or at least downsample it
     // (either should be possible).
-    mainPixels = new byte[header.width * header.height];
-    mainScratch = new int[(header.width / sampleSize) * (header.height / sampleSize)];
+    mainPixels = bitmapProvider.obtainByteArray(header.width * header.height);
+    mainScratch =
+        bitmapProvider.obtainIntArray((header.width / sampleSize) * (header.height / sampleSize));
     downsampledWidth = header.width / sampleSize;
     downsampledHeight = header.height / sampleSize;
   }
@@ -646,7 +664,7 @@ private void decodeBitmapData(GifFrame frame) {
 
     if (mainPixels == null || mainPixels.length < npix) {
       // Allocate new pixel array.
-      mainPixels = new byte[npix];
+      mainPixels = bitmapProvider.obtainByteArray(npix);
     }
     if (prefix == null) {
       prefix = new short[MAX_STACK_SIZE];
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index 2036b6cab..3a0a16bb7 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -17,7 +17,7 @@
   public static final String TAG = "GifHeaderParser";
 
   // The minimum frame delay in hundredths of a second.
-  static final int MIN_FRAME_DELAY = 3;
+  static final int MIN_FRAME_DELAY = 2;
   // The default frame delay in hundredths of a second for GIFs with frame delays less than the
   // minimum.
   static final int DEFAULT_FRAME_DELAY = 10;
@@ -79,13 +79,32 @@ public GifHeader parseHeader() {
     return header;
   }
 
+  /**
+   * Determines if the GIF is animated by trying to read in the first 2 frames
+   * This method reparses the data even if the header has already been read.
+   */
+  public boolean isAnimated() {
+    readHeader();
+    if (!err()) {
+      readContents(2 /* maxFrames */);
+    }
+    return header.frameCount > 1;
+  }
+
   /**
    * Main file parser. Reads GIF content blocks.
    */
   private void readContents() {
+    readContents(Integer.MAX_VALUE /* maxFrames */);
+  }
+
+  /**
+   * Main file parser. Reads GIF content blocks. Stops after reading maxFrames
+   */
+  private void readContents(int maxFrames) {
     // Read GIF file content blocks.
     boolean done = false;
-    while (!(done || err())) {
+    while (!(done || err() || header.frameCount > maxFrames)) {
       int code = read();
       switch (code) {
         // Image separator.
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 9566e4c32..210818ea2 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -2,6 +2,8 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.robolectric.Shadows.shadowOf;
 
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
@@ -14,8 +16,12 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
 
 import java.io.IOException;
+import java.util.Arrays;
 
 /**
  * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}.
@@ -94,6 +100,45 @@ public void testSettingDataResetsFramePointer() {
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
 
+  @Test
+  @Config(shadows = { CustomShadowBitmap.class })
+  public void testFirstFrameMustUsingLastFrameDispose() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_dispose.gif");
+    GifHeaderParser headerParser = new GifHeaderParser();
+    headerParser.setData(data);
+    GifHeader header = headerParser.parseHeader();
+    GifDecoder decoder = new GifDecoder(provider);
+    decoder.setData(header, data);
+    decoder.advance();
+    Bitmap firstFrame = decoder.getNextFrame();
+    decoder.advance();
+    decoder.getNextFrame();
+    decoder.advance();
+    Bitmap firstFrameTwice = decoder.getNextFrame();
+    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),
+        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));
+  }
+
+  /**
+   * Preserve generated bitmap data for checking.
+   */
+  @Implements(Bitmap.class)
+  public static class CustomShadowBitmap extends ShadowBitmap {
+
+    private int[] pixels;
+
+    @Implementation
+    public void setPixels(int[] pixels, int offset, int stride,
+        int x, int y, int width, int height) {
+      this.pixels = new int[pixels.length];
+      System.arraycopy(pixels, 0, this.pixels, 0, this.pixels.length);
+    }
+
+    public int[] getPixels() {
+      return pixels;
+    }
+  }
+
   private static class MockProvider implements GifDecoder.BitmapProvider {
 
     @NonNull
@@ -119,5 +164,15 @@ public void release(byte[] bytes) {
       // Do nothing.
     }
 
+    @Override
+    public int[] obtainIntArray(int size) {
+      return new int[size];
+    }
+
+    @Override
+    public void release(int[] array) {
+      // Do Nothing
+    }
+
   }
 }
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index fa14b3870..22f2e5c78 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -4,6 +4,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;
 import com.bumptech.glide.testutil.TestUtil;
@@ -214,6 +215,49 @@ public void testCanParseMultipleFrames() {
     assertEquals(expectedFrames, header.frames.size());
   }
 
+  @Test
+  public void testIsAnimatedMultipleFrames() {
+    final int lzwMinCodeSize = 2;
+    final int numFrames = 3;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    for (int i = 0; i < numFrames; i++) {
+      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+      GifBytesTestUtil.writeFakeImageData(buffer, 2);
+    }
+
+    parser.setData(buffer.array());
+    assertTrue(parser.isAnimated());
+  }
+
+  @Test
+  public void testIsNotAnimatedOneFrame() {
+    final int lzwMinCodeSize = 2;
+
+    final int frameSize =
+        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH
+            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);
+
+    ByteBuffer buffer =
+        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize)
+            .order(ByteOrder.LITTLE_ENDIAN);
+
+    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);
+    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);
+    GifBytesTestUtil.writeFakeImageData(buffer, 2);
+
+    parser.setData(buffer.array());
+    assertFalse(parser.isAnimated());
+  }
+
+
   @Test(expected = IllegalStateException.class)
   public void testThrowsIfParseHeaderCalledBeforeSetData() {
     GifHeaderParser parser = new GifHeaderParser();
diff --git a/third_party/gif_decoder/src/test/resources/transparent_dispose.gif b/third_party/gif_decoder/src/test/resources/transparent_dispose.gif
new file mode 100644
index 000000000..3c64b1d65
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/transparent_dispose.gif differ
diff --git a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
index aa1123f67..e08a214f7 100644
--- a/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java
@@ -22,6 +22,7 @@
  *     e.setDelay(1000);   // 1 frame per sec
  *     e.addFrame(image1);
  *     e.addFrame(image2);
+ *     e.addFrame(image3, 100, 100);    // set position of the frame
  *     e.finish();
  * </pre>
  *
@@ -38,13 +39,18 @@
 public class AnimatedGifEncoder {
     private static final String TAG = "AnimatedGifEncoder";
 
-    // The minimum % of an images pixels that must be transparent for us to set a transparent index automatically.
+    // The minimum % of an images pixels that must be transparent for us to set a transparent index
+    // automatically.
     private static final double MIN_TRANSPARENT_PERCENTAGE = 4d;
 
     private int width; // image size
 
     private int height;
 
+    private int fixedWidth;   // set by setSize()
+
+    private int fixedHeight;
+
     private Integer transparent = null; // transparent color if given
 
     private int transIndex; // transparent index in color table
@@ -140,22 +146,46 @@ public void setTransparent(int color) {
      * Adds next GIF frame. The frame is not written immediately, but is actually
      * deferred until the next frame is received so that timing data can be
      * inserted. Invoking <code>finish()</code> flushes all frames. If
-     * <code>setSize</code> was not invoked, the size of the first image is used
-     * for all subsequent frames.
+     * <code>setSize</code> was invoked, the size is used for all subsequent frames.
+     * Otherwise, the actual size of the image is used for each frames.
      *
      * @param im
      *          BufferedImage containing frame to write.
      * @return true if successful.
      */
     public boolean addFrame(Bitmap im) {
+        return addFrame(im, 0, 0);
+    }
+
+    /**
+     * Adds next GIF frame to the specified position. The frame is not written immediately, but is
+     * actually deferred until the next frame is received so that timing data can be inserted.
+     * Invoking <code>finish()</code> flushes all frames. If <code>setSize</code> was invoked, the
+     * size is used for all subsequent frames. Otherwise, the actual size of the image is used for
+     * each frame.
+     *
+     * See page 11 of http://giflib.sourceforge.net/gif89.txt for the position of the frame
+     *
+     * @param im
+     *          BufferedImage containing frame to write.
+     * @param x
+     *          Column number, in pixels, of the left edge of the image, with respect to the left
+     *          edge of the Logical Screen.
+     * @param y
+     *          Row number, in pixels, of the top edge of the image with respect to the top edge of
+     *          the Logical Screen.
+     * @return true if successful.
+     */
+    public boolean addFrame(Bitmap im, int x, int y) {
         if ((im == null) || !started) {
             return false;
         }
         boolean ok = true;
         try {
-            if (!sizeSet) {
-                // use first frame's size
-                setSize(im.getWidth(), im.getHeight());
+            if (sizeSet) {
+                setFrameSize(fixedWidth, fixedHeight);
+            } else {
+                setFrameSize(im.getWidth(), im.getHeight());
             }
             image = im;
             getImagePixels(); // convert to correct format if necessary
@@ -169,7 +199,7 @@ public boolean addFrame(Bitmap im) {
                 }
             }
             writeGraphicCtrlExt(); // write graphic control extension
-            writeImageDesc(); // image descriptor
+            writeImageDesc(x, y); // image descriptor
             if (!firstFrame) {
                 writePalette(); // local color table
             }
@@ -243,8 +273,8 @@ public void setQuality(int quality) {
     }
 
     /**
-     * Sets the GIF frame size. The default size is the size of the first frame
-     * added if this method is not invoked.
+     * Sets the fixed GIF frame size for all the frames.
+     * This should be called before start.
      *
      * @param w
      *          int frame width.
@@ -252,15 +282,33 @@ public void setQuality(int quality) {
      *          int frame width.
      */
     public void setSize(int w, int h) {
-        if (started && !firstFrame)
+        if (started) {
             return;
+        }
+
+        fixedWidth = w;
+        fixedHeight = h;
+        if (fixedWidth < 1) {
+            fixedWidth = 320;
+        }
+        if (fixedHeight < 1) {
+            fixedHeight = 240;
+        }
+
+        sizeSet = true;
+    }
+
+    /**
+     * Sets current GIF frame size.
+     *
+     * @param w
+     *          int frame width.
+     * @param h
+     *          int frame width.
+     */
+    private void setFrameSize(int w, int h) {
         width = w;
         height = h;
-        if (width < 1)
-            width = 320;
-        if (height < 1)
-            height = 240;
-        sizeSet = true;
     }
 
     /**
@@ -400,11 +448,12 @@ private void getImagePixels() {
         }
 
         double transparentPercentage = 100 * totalTransparentPixels / (double) pixelsInt.length;
-        // Assume images with greater where more than n% of the pixels are transparent actually have transparency.
-        // See issue #214.
+        // Assume images with greater where more than n% of the pixels are transparent actually have
+        // transparency. See issue #214.
         hasTransparentPixels = transparentPercentage > MIN_TRANSPARENT_PERCENTAGE;
         if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "got pixels for frame with " + transparentPercentage + "% transparent pixels");
+            Log.d(TAG, "got pixels for frame with " + transparentPercentage
+                + "% transparent pixels");
         }
     }
 
@@ -442,10 +491,10 @@ private void writeGraphicCtrlExt() throws IOException {
     /**
      * Writes Image Descriptor
      */
-    private void writeImageDesc() throws IOException {
+    private void writeImageDesc(int x, int y) throws IOException {
         out.write(0x2c); // image separator
-        writeShort(0); // image position x,y = 0,0
-        writeShort(0);
+        writeShort(x); // image position
+        writeShort(y);
         writeShort(width); // image size
         writeShort(height);
         // packed fields
diff --git a/third_party/gradle.properties b/third_party/gradle.properties
new file mode 100644
index 000000000..d01cfd2be
--- /dev/null
+++ b/third_party/gradle.properties
@@ -0,0 +1,3 @@
+# Prefix and postfix for source and javadoc jars.
+JAR_PREFIX=glide-
+JAR_POSTFIX=-thirdparty
