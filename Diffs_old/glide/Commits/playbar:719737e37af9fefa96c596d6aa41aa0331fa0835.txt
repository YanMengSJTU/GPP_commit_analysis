diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
index da727f2ac..fe060621a 100644
--- a/.idea/codeStyleSettings.xml
+++ b/.idea/codeStyleSettings.xml
@@ -349,6 +349,6 @@
         </codeStyleSettings>
       </value>
     </option>
-    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />
   </component>
 </project>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index 546e7aa55..e3dc14645 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,8 +3,8 @@ android:
   components:
   - tools
   - platform-tools
-  - build-tools-24.0.2
-  - android-24
+  - build-tools-25.0.2
+  - android-25
   - extra-android-m2repository
   - extra-android-support
 
diff --git a/README.md b/README.md
index b35334abc..495fd8877 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 Glide
 =====
 
-[![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
+[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.bumptech.glide/glide) [![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
 [Report an issue with Glide][5]
 
 Glide is a fast and efficient open source media management and image loading framework for Android that wraps media
@@ -28,8 +28,9 @@ repositories {
 }
 
 dependencies {
-  compile 'com.github.bumptech.glide:glide:3.7.0'
-  compile 'com.android.support:support-v4:19.1.0'
+  compile 'com.github.bumptech.glide:glide:4.0.0-RC0'
+  compile 'com.android.support:support-v4:25.3.1'
+  annotationProcessor 'com.github.bumptech.glide:compiler:4.0.0-RC0'
 }
 ```
 
@@ -39,13 +40,19 @@ Or Maven:
 <dependency>
   <groupId>com.github.bumptech.glide</groupId>
   <artifactId>glide</artifactId>
-  <version>3.7.0</version>
+  <version>4.0.0-RC0</version>
 </dependency>
 <dependency>
   <groupId>com.google.android</groupId>
   <artifactId>support-v4</artifactId>
   <version>r7</version>
 </dependency>
+<dependency>
+  <groupdId>com.github.bumptech.glide</groupId>
+  <artifactId>compiler</artifactId>
+  <version>4.0.0-RC0</version>
+  <optional>true</optional>
+</dependency>
 ```
 
 For info on using the bleeding edge, see the [Snapshots][17] wiki page.
@@ -60,14 +67,18 @@ Depending on your ProGuard (DexGuard) config and usage, you may need to include
   **[] $VALUES;
   public *;
 }
+
+# for DexGuard only
 -keepresourcexmlelements manifest/application/meta-data@value=GlideModule
 ```
 
 How do I use Glide?
 -------------------
-Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [javadocs][3].
+Checkout the [documentation][20] for pages on a variety of topics, and see the [javadocs][3].
+
+For Glide v3, see the [wiki][2].
 
-Simple use cases will look something like this:
+Simple use cases with Glide's [generated API][21] will look something like this:
 
 ```java
 // For a simple view:
@@ -75,7 +86,7 @@ Simple use cases will look something like this:
   ...
   ImageView imageView = (ImageView) findViewById(R.id.my_image_view);
 
-  Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView);
+  GlideApp.with(this).load("http://goo.gl/gEgYUd").into(imageView);
 }
 
 // For a simple image list:
@@ -89,12 +100,11 @@ Simple use cases will look something like this:
 
   String url = myUrls.get(position);
 
-  Glide
+  GlideApp
     .with(myFragment)
     .load(url)
     .centerCrop()
     .placeholder(R.drawable.loading_spinner)
-    .crossFade()
     .into(myImageView);
 
   return myImageView;
@@ -186,7 +196,7 @@ This is not an official Google product.
 
 [1]: https://github.com/bumptech/glide/releases
 [2]: https://github.com/bumptech/glide/wiki
-[3]: http://bumptech.github.io/glide/javadocs/latest/index.html
+[3]: http://bumptech.github.io/glide/ref/javadocs.html
 [4]: https://www.jetbrains.com/idea/download/
 [5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md
 [6]: https://groups.google.com/forum/#!forum/glidelibrary
@@ -203,3 +213,5 @@ This is not an official Google product.
 [17]: https://github.com/bumptech/glide/wiki/Snapshots
 [18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView
 [19]: https://github.com/wasabeef/glide-transformations
+[20]: http://bumptech.github.io/glide/
+[21]: http://bumptech.github.io/glide/doc/generatedapi.html
diff --git a/annotation/.gitignore b/annotation/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/build.gradle b/annotation/build.gradle
new file mode 100644
index 000000000..d6a7f76df
--- /dev/null
+++ b/annotation/build.gradle
@@ -0,0 +1,3 @@
+apply plugin: 'java'
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
\ No newline at end of file
diff --git a/annotation/compiler/.gitignore b/annotation/compiler/.gitignore
new file mode 100644
index 000000000..796b96d1c
--- /dev/null
+++ b/annotation/compiler/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/annotation/compiler/build.gradle b/annotation/compiler/build.gradle
new file mode 100644
index 000000000..0b51f2584
--- /dev/null
+++ b/annotation/compiler/build.gradle
@@ -0,0 +1,17 @@
+import org.gradle.internal.jvm.Jvm
+
+apply plugin: 'java'
+
+dependencies {
+    compile 'com.squareup:javapoet:1.8.0'
+    compile 'com.google.auto.service:auto-service:1.0-rc3'
+    compile 'com.google.code.findbugs:jsr305:3.0.1'
+    compile project(':annotation')
+    // This is to support com.sun.tootls.javac.util.List, currently used in RootModuleGenerator.
+    compile files(Jvm.current().getToolsJar())
+
+    testCompile "junit:junit:${JUNIT_VERSION}"
+    testCompile 'com.google.testing.compile:compile-testing:0.10'
+}
+
+apply from: "${rootProject.projectDir}/scripts/upload.gradle"
diff --git a/annotation/compiler/gradle.properties b/annotation/compiler/gradle.properties
new file mode 100644
index 000000000..1f7f8a7a7
--- /dev/null
+++ b/annotation/compiler/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide Annotation processor
+POM_ARTIFACT_ID=compiler
+POM_PACKAGING=jar
+POM_DESCRIPTION=Glide's anntation processor. Should be included in all Applications and in all libraries that use Glide's modules for configuration.
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
new file mode 100644
index 000000000..6e45b850a
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java
@@ -0,0 +1,230 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.Excludes;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeSpec.Builder;
+import com.squareup.javapoet.WildcardTypeName;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates a new implementation of a AppGlideModule that calls all included LibraryGlideModules
+ * and the original AppGlideModule.
+ *
+ * <p>The generated class will always call the AppGlideModule last to give it priority over choices
+ * made or classes registered in LibraryGlideModules.
+ *
+ * <p>Android logging is included to allow developers to see exactly which modules are included at
+ * runtime.
+ *
+ * <p>The generated class looks something like this:
+ * <pre>
+ * <code>
+ *  final class GeneratedAppGlideModuleImpl extends com.bumptech.glide.GeneratedAppGlideModule {
+ *    private final com.bumptech.glide.samples.giphy.GiphyGlideModule appGlideModule;
+ *
+ *    GeneratedAppGlideModule() {
+ *      appGlideModule = new com.bumptech.glide.samples.giphy.GiphyGlideModule();
+ *      if (android.util.Log.isLoggable("Glide", android.util.Log.DEBUG)) {
+ *        android.util.Log.d("Glide", "Discovered AppGlideModule from annotation:"
+ *            + " com.bumptech.glide.samples.giphy.GiphyGlideModule");
+ *        android.util.Log.d("Glide", "Discovered LibraryGlideModule from annotation:"
+ *            + "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule");
+ *      }
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public void applyOptions(android.content.Context context,
+ *        com.bumptech.glide.GlideBuilder builder) {
+ *      appGlideModule.applyOptions(context, builder);
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public void registerComponents(android.content.Context context,
+ *        com.bumptech.glide.Registry registry) {
+ *      new com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule()
+ *          .registerComponents(context, registry);
+ *      appGlideModule.registerComponents(context, registry);
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public boolean isManifestParsingEnabled() {
+ *      return appGlideModule.isManifestParsingEnabled();
+ *    }
+ *
+ *    {@literal @java.lang.Override}
+ *    public java.util.Set<java.lang.Class<?>> getExcludedModuleClasses() {
+ *      return appGlideModule.getExcludedModuleClasses();
+ *    }
+ *  }
+ * </code>
+ * </pre>
+ */
+final class AppModuleGenerator {
+  static final String GENERATED_ROOT_MODULE_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String GLIDE_LOG_TAG = "Glide";
+  private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME =
+      "GeneratedAppGlideModuleImpl";
+  private static final String GENERATED_ROOT_MODULE_SIMPLE_NAME = "GeneratedAppGlideModule";
+  private final ProcessorUtil processorUtil;
+
+  AppModuleGenerator(ProcessorUtil processorUtil) {
+    this.processorUtil = processorUtil;
+  }
+
+  TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {
+    ClassName appGlideModuleClassName = ClassName.get(appGlideModule);
+    Set<String> excludedGlideModuleClassNames =
+        getExcludedGlideModuleClassNames(appGlideModule);
+
+    MethodSpec constructor =
+        generateConstructor(
+            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+
+    MethodSpec registerComponents =
+        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);
+
+    MethodSpec getExcludedModuleClasses =
+        generateGetExcludedModuleClasses(excludedGlideModuleClassNames);
+
+    MethodSpec applyOptions =
+        MethodSpec.methodBuilder("applyOptions")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(ClassName.get("android.content", "Context"), "context")
+            .addParameter(ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder")
+            .addStatement("appGlideModule.applyOptions(context, builder)", appGlideModule)
+            .build();
+
+    MethodSpec isManifestParsingEnabled =
+        MethodSpec.methodBuilder("isManifestParsingEnabled")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .returns(boolean.class)
+            .addStatement("return appGlideModule.isManifestParsingEnabled()", appGlideModule)
+            .build();
+
+    Builder builder = TypeSpec.classBuilder(GENERATED_APP_MODULE_IMPL_SIMPLE_NAME)
+        .addModifiers(Modifier.FINAL)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build()
+        )
+        .superclass(
+            ClassName.get(GENERATED_ROOT_MODULE_PACKAGE_NAME, GENERATED_ROOT_MODULE_SIMPLE_NAME))
+        .addField(appGlideModuleClassName, "appGlideModule", Modifier.PRIVATE, Modifier.FINAL)
+        .addMethod(constructor)
+        .addMethod(applyOptions)
+        .addMethod(registerComponents)
+        .addMethod(isManifestParsingEnabled)
+        .addMethod(getExcludedModuleClasses);
+
+    ClassName generatedRequestManagerFactoryClassName =
+        ClassName.get(
+            RequestManagerFactoryGenerator.GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME,
+            RequestManagerFactoryGenerator.GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME);
+
+    builder.addMethod(
+        MethodSpec.methodBuilder("getRequestManagerFactory")
+            .addAnnotation(Override.class)
+            .returns(generatedRequestManagerFactoryClassName)
+            .addStatement("return new $T()", generatedRequestManagerFactoryClassName)
+            .build());
+    return builder.build();
+  }
+
+  // TODO: When we drop support for parsing GlideModules from AndroidManifests, remove this method.
+  private MethodSpec generateGetExcludedModuleClasses(Set<String> excludedClassNames) {
+    TypeName wildCardOfObject = WildcardTypeName.subtypeOf(Object.class);
+    ParameterizedTypeName classOfWildcardOfObjet =
+        ParameterizedTypeName.get(ClassName.get(Class.class), wildCardOfObject);
+    ParameterizedTypeName setOfClassOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(Set.class), classOfWildcardOfObjet);
+    ParameterizedTypeName hashSetOfClassOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(HashSet.class), classOfWildcardOfObjet);
+    MethodSpec.Builder builder = MethodSpec.methodBuilder("getExcludedModuleClasses")
+        .addModifiers(Modifier.PUBLIC)
+        .addAnnotation(Override.class)
+        .returns(setOfClassOfWildcardOfObject);
+
+    if (excludedClassNames.isEmpty()) {
+      builder.addStatement("return $T.emptySet()", Collections.class);
+    } else {
+      builder.addStatement(
+          "$T excludedClasses = new $T()", setOfClassOfWildcardOfObject,
+          hashSetOfClassOfWildcardOfObject);
+      for (String excludedClassName : excludedClassNames) {
+        // TODO: Remove this when we no longer support manifest parsing.
+        // Using a Literal ($L) instead of a type ($T) to get a fully qualified import that allows
+        // us to suppress deprecation warnings. Aimed at deprecated GlideModules.
+        builder.addStatement("excludedClasses.add($L.class)", excludedClassName);
+      }
+      builder.addStatement("return excludedClasses");
+    }
+
+    return builder.build();
+  }
+
+  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,
+      Set<String> excludedGlideModuleClassNames) {
+    MethodSpec.Builder registerComponents =
+        MethodSpec.methodBuilder("registerComponents")
+            .addModifiers(Modifier.PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(ClassName.get("android.content", "Context"), "context")
+            .addParameter(ClassName.get("com.bumptech.glide", "Registry"), "registry");
+
+    for (String glideModule : libraryGlideModuleClassNames) {
+      if (excludedGlideModuleClassNames.contains(glideModule)) {
+        continue;
+      }
+      ClassName moduleClassName = ClassName.bestGuess(glideModule);
+      registerComponents.addStatement(
+          "new $T().registerComponents(context, registry)", moduleClassName);
+    }
+    // Order matters here. The AppGlideModule must be called last.
+    registerComponents.addStatement("appGlideModule.registerComponents(context, registry)");
+    return registerComponents.build();
+  }
+
+  private MethodSpec generateConstructor(ClassName appGlideModule,
+      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {
+    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder();
+    constructorBuilder.addStatement("appGlideModule = new $T()", appGlideModule);
+
+    ClassName androidLogName = ClassName.get("android.util", "Log");
+
+    // Add some log lines to indicate to developers which modules where discovered.
+    constructorBuilder.beginControlFlow("if ($T.isLoggable($S, $T.DEBUG))",
+        androidLogName, GLIDE_LOG_TAG, androidLogName);
+    constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+        "Discovered AppGlideModule from annotation: " + appGlideModule);
+    // Excluded GlideModule classes from the manifest are logged in Glide's singleton.
+    for (String glideModule : libraryGlideModuleClassNames) {
+      ClassName moduleClassName = ClassName.bestGuess(glideModule);
+      if (excludedGlideModuleClassNames.contains(glideModule)) {
+        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);
+      } else {
+        constructorBuilder.addStatement("$T.d($S, $S)", androidLogName, GLIDE_LOG_TAG,
+            "Discovered LibraryGlideModule from annotation: " + moduleClassName);
+      }
+    }
+    constructorBuilder.endControlFlow();
+    return constructorBuilder.build();
+  }
+
+  private Set<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {
+    return processorUtil.findClassValuesFromAnnotationOnClassAsNames(
+        appGlideModule, Excludes.class);
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
new file mode 100644
index 000000000..17f64f327
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java
@@ -0,0 +1,177 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Runs the final steps of Glide's annotation process and generates the combined
+ * {@link AppGlideModule}, {@link com.bumptech.glide.Glide},
+ * {@link com.bumptech.glide.RequestManager}, and
+ * {@link com.bumptech.glide.request.RequestOptions} classes.
+ */
+final class AppModuleProcessor {
+  private static final String COMPILER_PACKAGE_NAME =
+      GlideAnnotationProcessor.class.getPackage().getName();
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final List<TypeElement> appGlideModules = new ArrayList<>();
+  private final RequestOptionsGenerator requestOptionsGenerator;
+  private final RequestManagerGenerator requestManagerGenerator;
+  private final AppModuleGenerator appModuleGenerator;
+  private final RequestBuilderGenerator requestBuilderGenerator;
+  private final RequestManagerFactoryGenerator requestManagerFactoryGenerator;
+  private final GlideGenerator glideGenerator;
+
+  AppModuleProcessor(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    appModuleGenerator = new AppModuleGenerator(processorUtil);
+    requestOptionsGenerator = new RequestOptionsGenerator(processingEnv, processorUtil);
+    requestManagerGenerator = new RequestManagerGenerator(processingEnv, processorUtil);
+    requestManagerFactoryGenerator = new RequestManagerFactoryGenerator(processingEnv);
+    glideGenerator = new GlideGenerator(processingEnv, processorUtil);
+    requestBuilderGenerator = new RequestBuilderGenerator(processingEnv, processorUtil);
+  }
+
+  void processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
+     for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+       if (processorUtil.isAppGlideModule(element)) {
+         appGlideModules.add(element);
+       }
+     }
+
+    processorUtil.debugLog("got app modules: " + appGlideModules);
+
+    if (appGlideModules.size() > 1) {
+      throw new IllegalStateException(
+          "You cannot have more than one AppGlideModule, found: " + appGlideModules);
+    }
+  }
+
+  boolean maybeWriteAppModule() {
+    // appGlideModules is added to in order to catch errors where multiple AppGlideModules may be
+    // present for a single application or library. Because we only add to appGlideModules, we use
+    // isGeneratedAppGlideModuleWritten to make sure the GeneratedAppGlideModule is written at
+    // most once.
+    if (appGlideModules.isEmpty()) {
+      return false;
+    }
+    TypeElement appModule = appGlideModules.get(0);
+    processorUtil.debugLog("Processing app module: " + appModule);
+    // If this package is null, it means there are no classes with this package name. One way this
+    // could happen is if we process an annotation and reach this point without writing something
+    // to the package. We do not error check here because that shouldn't happen with the
+    // current implementation.
+    PackageElement glideGenPackage =
+        processingEnv.getElementUtils().getPackageElement(COMPILER_PACKAGE_NAME);
+    FoundIndexedClassNames indexedClassNames = getIndexedClassNames(glideGenPackage);
+
+    // Write all generated code to the package containing the AppGlideModule. Doing so fixes
+    // classpath collisions if more than one Application containing a AppGlideModule is included
+    // in a project.
+    String generatedCodePackageName = appModule.getEnclosingElement().toString();
+
+    TypeSpec generatedRequestOptions =
+          requestOptionsGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);
+      writeRequestOptions(generatedCodePackageName, generatedRequestOptions);
+
+    TypeSpec generatedRequestBuilder =
+        requestBuilderGenerator.generate(generatedCodePackageName, generatedRequestOptions);
+    writeRequestBuilder(generatedCodePackageName, generatedRequestBuilder);
+
+    TypeSpec requestManager =
+        requestManagerGenerator.generate(
+            generatedCodePackageName, generatedRequestOptions, generatedRequestBuilder,
+            indexedClassNames.extensions);
+    writeRequestManager(generatedCodePackageName, requestManager);
+
+    TypeSpec requestManagerFactory =
+        requestManagerFactoryGenerator.generate(generatedCodePackageName, requestManager);
+    writeRequestManagerFactory(requestManagerFactory);
+
+    TypeSpec glide =
+        glideGenerator.generate(generatedCodePackageName, getGlideName(appModule), requestManager);
+    writeGlide(generatedCodePackageName, glide);
+
+    TypeSpec generatedAppGlideModule =
+        appModuleGenerator.generate(appModule, indexedClassNames.glideModules);
+    writeAppModule(generatedAppGlideModule);
+
+    processorUtil.infoLog("Wrote GeneratedAppGlideModule with: " + indexedClassNames.glideModules);
+
+    return true;
+  }
+
+  private String getGlideName(TypeElement appModule) {
+    return appModule.getAnnotation(GlideModule.class).glideName();
+  }
+
+  @SuppressWarnings("unchecked")
+  private FoundIndexedClassNames getIndexedClassNames(PackageElement glideGenPackage) {
+    Set<String> glideModules = new HashSet<>();
+    Set<String> extensions = new HashSet<>();
+    List<? extends Element> glideGeneratedElements = glideGenPackage.getEnclosedElements();
+    for (Element indexer : glideGeneratedElements) {
+      Index annotation = indexer.getAnnotation(Index.class);
+      // If the annotation is null, it means we've come across another class in the same package
+      // that we can safely ignore.
+      if (annotation != null) {
+        Collections.addAll(glideModules, annotation.modules());
+        Collections.addAll(extensions, annotation.extensions());
+      }
+    }
+
+    processorUtil.debugLog("Found GlideModules: " + glideModules);
+    return new FoundIndexedClassNames(glideModules, extensions);
+  }
+
+  private void writeGlide(String packageName, TypeSpec glide) {
+    processorUtil.writeClass(packageName, glide);
+  }
+
+  private void writeRequestManager(String packageName, TypeSpec requestManager) {
+    processorUtil.writeClass(packageName, requestManager);
+  }
+
+  // We dont' care about collisions in IDEs since this class isn't an API class.
+  private void writeRequestManagerFactory(TypeSpec requestManagerFactory) {
+    processorUtil.writeClass(
+        AppModuleGenerator.GENERATED_ROOT_MODULE_PACKAGE_NAME, requestManagerFactory);
+  }
+
+  // The app module we generate subclasses a package private class. We don't care about classpath
+  // collisions in IDEs since this class isn't an API class.
+  private void writeAppModule(TypeSpec appModule) {
+    processorUtil.writeClass(AppModuleGenerator.GENERATED_ROOT_MODULE_PACKAGE_NAME, appModule);
+  }
+
+  private void writeRequestOptions(String packageName, TypeSpec requestOptions) {
+    processorUtil.writeClass(packageName, requestOptions);
+  }
+
+  private void writeRequestBuilder(String packageName, TypeSpec requestBuilder) {
+    processorUtil.writeClass(packageName, requestBuilder);
+  }
+
+  private static final class FoundIndexedClassNames {
+    final Set<String> glideModules;
+    final Set<String> extensions;
+
+    private FoundIndexedClassNames(Set<String> glideModules, Set<String> extensions) {
+      this.glideModules = glideModules;
+      this.extensions = extensions;
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
new file mode 100644
index 000000000..4d6ac80c8
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java
@@ -0,0 +1,43 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Writes Indexer classes annotated with {@link Index} for all
+ * classes found annotated with {@link GlideExtension}.
+ */
+final class ExtensionProcessor {
+  private final ProcessorUtil processorUtil;
+  private final IndexerGenerator indexerGenerator;
+
+  ExtensionProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+    this.processorUtil = processorUtil;
+    this.indexerGenerator = indexerGenerator;
+  }
+
+  boolean processExtensions(Set<? extends TypeElement> set, RoundEnvironment env) {
+    List<TypeElement> elements = processorUtil.getElementsFor(GlideExtension.class, env);
+    processorUtil.debugLog("Processing types : " + elements);
+    for (TypeElement typeElement : elements) {
+      GlideExtensionValidator.validateExtension(typeElement);
+      processorUtil.debugLog("Processing elements: " + typeElement.getEnclosedElements());
+    }
+
+    if (elements.isEmpty()) {
+      return false;
+    }
+    TypeSpec spec = indexerGenerator.generate(elements);
+    processorUtil.writeIndexer(spec);
+    return true;
+  }
+
+  Set<String> getSupportedAnnotationTypes() {
+    return Collections.singleton(GlideExtension.class.getName());
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
new file mode 100644
index 000000000..9046219e2
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java
@@ -0,0 +1,129 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideType;
+import com.google.auto.service.AutoService;
+import java.util.HashSet;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.TypeElement;
+
+// Links in Javadoc will work due to build setup, even though there is no direct dependency here.
+/**
+ * Generates classes based on Glide's annotations that configure Glide, add support for additional
+ * resource types, and/or extend Glide's API.
+ *
+ * <p>This processor discovers all {@link AppGlideModule} and
+ * {@link LibraryGlideModule} implementations that are
+ * annotated with {@link com.bumptech.glide.annotation.GlideModule}. Any implementations missing the
+ * annotation will be ignored.
+ *
+ * <p>This processor also discovers all {@link com.bumptech.glide.annotation.GlideExtension}
+ * annotated classes.
+ *
+ * <p>Multiple classes are generated by this processor:
+ * <ul>
+ *   <li>For {@link LibraryGlideModule}s - A GlideIndexer class in a
+ *      specific package that will later be used by the processor to discover all
+ *      {@link LibraryGlideModule} classes.
+ *   <li>For {@link AppGlideModule}s - A single
+ *      {@link AppGlideModule} implementation
+ *     ({@link com.bumptech.glide.GeneratedAppGlideModule}) that calls all
+ *     {@link LibraryGlideModule}s and the
+ *     original {@link AppGlideModule} in the correct order when Glide is
+ *     initialized.
+ *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -
+ *   <ul>
+ *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains
+ *     static versions of all builder methods in the base class and both static and instance
+ *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s.
+ *     <li>If one or more methods in one or more
+ *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with
+ *     {@link GlideType}:
+ *     <ul>
+ *       <li>A {@link com.bumptech.glide.RequestManager} implementation containing a generated
+ *       method for each method annotated with
+ *       {@link GlideType}.
+ *       <li>A {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ *       implementation that produces the generated {@link com.bumptech.glide.RequestManager}s.
+ *       <li>A {@link com.bumptech.glide.Glide} look-alike that implements all static methods in
+ *       the {@link com.bumptech.glide.Glide} singleton and returns the generated
+ *       {@link com.bumptech.glide.RequestManager} implementation when appropriate.
+ *     </ul>
+ *   </ul>
+ * </ul>
+ *
+ * <p>{@link AppGlideModule} implementations must only be included in
+ * applications, not in libraries. There must be exactly one
+ * {@link AppGlideModule} implementation per
+ * Application. The {@link AppGlideModule} class is
+ * used as a signal that all modules have been found and that the final merged
+ * {@link com.bumptech.glide.GeneratedAppGlideModule} impl can be created.
+ */
+@AutoService(Processor.class)
+public final class GlideAnnotationProcessor extends AbstractProcessor {
+  static final boolean DEBUG = false;
+  private ProcessorUtil processorUtil;
+  private LibraryModuleProcessor libraryModuleProcessor;
+  private AppModuleProcessor appModuleProcessor;
+  private boolean isGeneratedAppGlideModuleWritten;
+  private ExtensionProcessor extensionProcessor;
+
+  @Override
+  public synchronized void init(ProcessingEnvironment processingEnvironment) {
+    super.init(processingEnvironment);
+    processorUtil = new ProcessorUtil(processingEnvironment);
+    IndexerGenerator indexerGenerator = new IndexerGenerator(processorUtil);
+    libraryModuleProcessor = new LibraryModuleProcessor(processorUtil, indexerGenerator);
+    appModuleProcessor = new AppModuleProcessor(processingEnvironment, processorUtil);
+    extensionProcessor = new ExtensionProcessor(processorUtil, indexerGenerator);
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    Set<String> result = new HashSet<>();
+    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());
+    result.addAll(extensionProcessor.getSupportedAnnotationTypes());
+    return result;
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+   /**
+   * Each round we do the following:
+   * <ol>
+   *   <li>Find all AppGlideModules and save them to an instance variable (throw if > 1).
+   *   <li>Find all LibraryGlideModules
+   *   <li>For each LibraryGlideModule, write an Indexer with an Annotation with the class name.
+   *   <li>If we wrote any Indexers, return and wait for the next round.
+   *   <li>If we didn't write any Indexers and there is a AppGlideModule, write the
+   *   GeneratedAppGlideModule. Once the GeneratedAppGlideModule is written, we expect to be
+   *   finished. Any further generation of related classes will result in errors.
+   * </ol>
+   */
+  @Override
+  public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {
+    processorUtil.process();
+    boolean newModulesWritten = libraryModuleProcessor.processModules(set, env);
+    boolean newExtensionWritten = extensionProcessor.processExtensions(set, env);
+    appModuleProcessor.processModules(set, env);
+
+    if (newExtensionWritten || newModulesWritten) {
+      if (isGeneratedAppGlideModuleWritten) {
+        throw new IllegalStateException("Cannot process annotations after writing AppGlideModule");
+      }
+      return true;
+    }
+
+    if (!isGeneratedAppGlideModuleWritten) {
+      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();
+    }
+    return true;
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
new file mode 100644
index 000000000..488c5578f
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -0,0 +1,94 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideOption;
+import com.bumptech.glide.annotation.GlideType;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Validates that classes annotated with {@link com.bumptech.glide.annotation.GlideExtension}
+ * contains methods with the expected format.
+ *
+ * <p>Validation is performed so that errors can be found when a library is compiled. Without
+ * validation, an error written in to a library wouldn't be found until Glide tried to generate code
+ * for an Application.
+ */
+final class GlideExtensionValidator {
+
+  private GlideExtensionValidator() { }
+
+  static void validateExtension(TypeElement typeElement) {
+    if (!typeElement.getModifiers().contains(Modifier.PUBLIC)) {
+      throw new IllegalArgumentException("RequestOptionsExtensions must be public");
+    }
+    for (Element element : typeElement.getEnclosedElements()) {
+      if (element.getKind() == ElementKind.CONSTRUCTOR) {
+        if (!element.getModifiers().contains(Modifier.PRIVATE)) {
+          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
+              + " constructors and only static methods. Found a non-private constructor");
+        }
+        ExecutableElement executableElement = (ExecutableElement) element;
+        if (!executableElement.getParameters().isEmpty()) {
+          throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
+              + " constructors and only static methods. Found parameters in the constructor");
+        }
+        continue;
+      }
+      if (element.getKind() == ElementKind.METHOD) {
+        ExecutableElement executableElement = (ExecutableElement) element;
+        if (executableElement.getAnnotation(GlideOption.class) != null) {
+          validateExtendsRequestOptions(executableElement);
+        } else if (executableElement.getAnnotation(GlideType.class) != null) {
+          validateExtendsRequestManager(executableElement);
+        }
+      }
+    }
+  }
+
+  private static void validateExtendsRequestOptions(ExecutableElement executableElement) {
+    validateStaticVoid(executableElement, GlideOption.class);
+    if (executableElement.getParameters().isEmpty()) {
+      throw new IllegalArgumentException("@GlideOption methods must take a "
+          + "RequestOptions object as their first parameter, but given none");
+    }
+    VariableElement first = executableElement.getParameters().get(0);
+    TypeMirror expected = first.asType();
+    if (!expected.toString().equals(
+        "com.bumptech.glide.request.RequestOptions")) {
+      throw new IllegalArgumentException("@GlideOption methods must take a"
+          + " RequestOptions object as their first parameter, but given: " + expected);
+    }
+  }
+
+  private static void validateExtendsRequestManager(ExecutableElement executableElement) {
+    validateStaticVoid(executableElement, GlideType.class);
+    if (executableElement.getParameters().size() != 1) {
+      throw new IllegalArgumentException("@GlideType methods must take a"
+          + " RequestOptions object as their first and only parameter, found multiple for: "
+      + executableElement.getEnclosingElement() + "#" + executableElement);
+    }
+
+    VariableElement first = executableElement.getParameters().get(0);
+    TypeMirror expected = first.asType();
+    if (!expected.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
+      throw new IllegalArgumentException("@GlideType methods must take a"
+          + " RequestBuilder object as their first parameter, but given: " + expected);
+    }
+  }
+
+  private static void validateStaticVoid(ExecutableElement executableElement, Class<?> clazz) {
+    if (!executableElement.getModifiers().contains(Modifier.STATIC)) {
+      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must be static");
+    }
+    TypeMirror returnType = executableElement.getReturnType();
+    if (returnType.getKind() != TypeKind.VOID) {
+      throw new IllegalArgumentException("@" + clazz.getSimpleName() + " methods must return void");
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
new file mode 100644
index 000000000..1f54c7667
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java
@@ -0,0 +1,197 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.google.common.base.Function;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates a Glide look-alike that acts as the entry point to the generated API
+ * (GlideApp.with(...)).
+ *
+ * <p>>Generated {@link com.bumptech.glide.Glide} look-alikes look like this (note that the name
+ * is configurable in {@link com.bumptech.glide.annotation.GlideModule}):
+ * <pre>
+ * <code>
+ * public final class GlideApp {
+ *   private GiphyGlide() {
+ *   }
+ *
+ *   public static File getPhotoCacheDir(Context context) {
+ *     return Glide.getPhotoCacheDir(context);
+ *   }
+ *
+ *   public static File getPhotoCacheDir(Context context, String cacheName) {
+ *     return Glide.getPhotoCacheDir(context, cacheName);
+ *   }
+ *
+ *   public static Glide get(Context context) {
+ *     return Glide.get(context);
+ *   }
+ *
+ *   public static void tearDown() {
+ *     Glide.tearDown();
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Context context) {
+ *     return (GeneratedRequestManager) Glide.with(context);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Activity activity) {
+ *    return (GeneratedRequestManager) Glide.with(activity);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(FragmentActivity activity) {
+ *     return (GeneratedRequestManager) Glide.with(activity);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(Fragment fragment) {
+ *     return (GeneratedRequestManager) Glide.with(fragment);
+ *   }
+ *
+ *   public static GeneratedRequestManager with(android.support.v4.app.Fragment fragment) {
+ *     return (GeneratedRequestManager) Glide.with(fragment);
+ *   }
+ * </code>
+ * </pre>
+ */
+final class GlideGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final TypeElement glideType;
+  private final TypeElement requestManagerType;
+
+  GlideGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    Elements elementUtils = processingEnv.getElementUtils();
+
+    requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(
+      String generatedCodePackageName, String glideName, TypeSpec generatedRequestManager) {
+    return TypeSpec.classBuilder(glideName)
+        .addJavadoc(
+            "The entry point for interacting with Glide for Applications\n"
+                + "\n"
+                + "<p>Includes all generated APIs from all\n"
+                + "{@link $T}s in source and dependent libraries.\n"
+                + "\n"
+                + "<p>This class is generated and should not be modified"
+                + "\n"
+                + "@see $T\n", GlideExtension.class, glideType)
+        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addMethod(MethodSpec.constructorBuilder()
+            .addModifiers(Modifier.PRIVATE)
+            .build())
+        .addMethods(
+            generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager))
+        .build();
+  }
+
+  private List<MethodSpec> generateOverridesForGlideMethods(
+      final String generatedCodePackageName, final TypeSpec generatedRequestManager) {
+    return Lists.transform(discoverGlideMethodsToOverride(),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            if (isGlideWithMethod(input)) {
+              return overrideGlideWithMethod(
+                  generatedCodePackageName, generatedRequestManager, input);
+            } else {
+              return overrideGlideStaticMethod(input);
+            }
+          }
+        });
+  }
+
+  private MethodSpec overrideGlideStaticMethod(ExecutableElement methodToOverride) {
+    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+
+    TypeElement element =
+        (TypeElement) processingEnv.getTypeUtils().asElement(methodToOverride.getReturnType());
+
+    MethodSpec.Builder builder =
+        MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+            .addParameters(Lists.transform(parameters,
+                new Function<VariableElement, ParameterSpec>() {
+                  @Override
+                  public ParameterSpec apply(VariableElement input) {
+                    return ParameterSpec.get(input);
+                  }
+            }));
+
+    boolean returnsValue = element != null;
+    if (returnsValue) {
+      builder.returns(ClassName.get(element));
+    }
+
+    String code = returnsValue ? "return " : "";
+    code += "$T.$N(";
+    List<Object> args = new ArrayList<>();
+    args.add(ClassName.get(glideType));
+    args.add(methodToOverride.getSimpleName());
+    if (!parameters.isEmpty()) {
+      for (VariableElement param : parameters) {
+        code += "$L, ";
+        args.add(param.getSimpleName());
+      }
+      code = code.substring(0, code.length() - 2);
+    }
+    code += ")";
+    builder.addStatement(code, args.toArray(new Object[0]));
+    return builder.build();
+  }
+
+  private List<ExecutableElement> discoverGlideMethodsToOverride() {
+    return processorUtil.findStaticMethods(glideType);
+  }
+
+  private boolean isGlideWithMethod(ExecutableElement element) {
+    return processorUtil.isReturnValueTypeMatching(element, requestManagerType);
+  }
+
+  private MethodSpec overrideGlideWithMethod(
+      String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {
+    ClassName generatedRequestManagerClassName =
+        ClassName.get(packageName, generatedRequestManager.name);
+    List<? extends VariableElement> parameters = methodToOverride.getParameters();
+    Preconditions.checkArgument(
+        parameters.size() == 1, "Expected size of 1, but got %s", methodToOverride);
+    VariableElement parameter = parameters.iterator().next();
+    return MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(methodToOverride))
+        .returns(generatedRequestManagerClassName)
+        .addParameter(ClassName.get(parameter.asType()), parameter.getSimpleName().toString())
+        .addStatement("return ($T) $T.$N($L)",
+            generatedRequestManagerClassName, glideType,
+            methodToOverride.getSimpleName().toString(),
+            parameter.getSimpleName())
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
new file mode 100644
index 000000000..afae52f38
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java
@@ -0,0 +1,109 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.List;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates an empty class with an annotation containing the class names of one or more
+ * LibraryGlideModules and/or one or more GlideExtensions.
+ *
+ * <p>We use a separate class so that LibraryGlideModules and GlideExtensions written in libraries
+ * can be bundled into an AAR and later retrieved by the annotation processor when it processes the
+ * AppGlideModule in an application.
+ *
+ * <p>The output file generated by this class with a LibraryGlideModule looks like this:
+ * <pre>
+ * <code>
+ *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
+ *      modules = "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule"
+ *  )
+ *  public class Indexer_GlideModule_com_bumptech_glide_integration_okhttp3_OkHttpLibraryGlideModule
+ *  {
+ *  }
+ * </code>
+ * </pre>
+ *
+ * <p>The output file generated by this class with a GlideExtension looks like this:
+ * <pre>
+ * <code>
+ *  {@literal @com.bumptech.glide.annotation.compiler.Index(}
+ *      extensions = "com.bumptech.glide.integration.gif.GifOptions"
+ *  )
+ *  public class Indexer_GlideExtension_com_bumptech_glide_integration_gif_GifOptions {
+ *  }
+ * </code>
+ * </pre>
+ * </p>
+ */
+final class IndexerGenerator {
+  private static final String INDEXER_NAME_PREFIX = "GlideIndexer_";
+  private final ProcessorUtil processorUtil;
+
+  IndexerGenerator(ProcessorUtil processorUtil) {
+    this.processorUtil = processorUtil;
+  }
+
+  TypeSpec generate(List<TypeElement> types) {
+    List<TypeElement> modules =  new ArrayList<>();
+    List<TypeElement> extensions = new ArrayList<>();
+    for (TypeElement element : types) {
+      if (processorUtil.isExtension(element)) {
+        extensions.add(element);
+      } else if (processorUtil.isLibraryGlideModule(element)) {
+        modules.add(element);
+      } else {
+        throw new IllegalArgumentException("Unrecognized type: " + element);
+      }
+    }
+    if (!modules.isEmpty() && !extensions.isEmpty()) {
+      throw new IllegalArgumentException("Given both modules and extensions, expected one or the "
+          + "other. Modules: " + modules + " Extensions: " + extensions);
+    }
+    if (!modules.isEmpty()) {
+      return generate(types, GlideModule.class);
+    } else {
+      return generate(types, GlideExtension.class);
+    }
+  }
+
+  private static TypeSpec generate(List<TypeElement> libraryModules,
+      Class<? extends Annotation> annotation) {
+    AnnotationSpec.Builder annotationBuilder =
+        AnnotationSpec.builder(Index.class);
+
+    String value = getAnnotationValue(annotation);
+    for (TypeElement childModule : libraryModules) {
+      annotationBuilder.addMember(value, "$S", ClassName.get(childModule).toString());
+    }
+
+    String indexerName = INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_";
+    for (TypeElement element : libraryModules) {
+      indexerName += element.getQualifiedName().toString().replace(".", "_");
+      indexerName += "_";
+    }
+    indexerName = indexerName.substring(0, indexerName.length() - 1);
+
+    return TypeSpec.classBuilder(indexerName)
+        .addAnnotation(annotationBuilder.build())
+        .addModifiers(Modifier.PUBLIC)
+        .build();
+  }
+
+  private static String getAnnotationValue(Class<? extends Annotation> annotation) {
+    if (annotation == GlideModule.class) {
+      return "modules";
+    } else if (annotation == GlideExtension.class) {
+      return "extensions";
+    } else {
+      throw new IllegalArgumentException("Unrecognized annotation: " + annotation);
+    }
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
new file mode 100644
index 000000000..8f79cb7e2
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/LibraryModuleProcessor.java
@@ -0,0 +1,61 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.squareup.javapoet.TypeSpec;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates Indexer classes annotated with {@link Index} for all
+ * {@link LibraryGlideModule}s.
+ */
+final class LibraryModuleProcessor {
+  private ProcessorUtil processorUtil;
+  private IndexerGenerator indexerGenerator;
+
+  LibraryModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {
+    this.processorUtil = processorUtil;
+    this.indexerGenerator = indexerGenerator;
+  }
+
+  boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {
+     // Order matters here, if we find an Indexer below, we return before writing the root module.
+    // If we fail to add to appModules before then, we might accidentally skip a valid RootModule.
+    List<TypeElement> libraryGlideModules = new ArrayList<>();
+    for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {
+      // Root elements are added separately and must be checked separately because they're sub
+      // classes of LibraryGlideModules.
+      if (processorUtil.isAppGlideModule(element)) {
+        continue;
+      } else if (!processorUtil.isLibraryGlideModule(element)) {
+        throw new IllegalStateException("@GlideModule can only be applied to LibraryGlideModule"
+            + " and AppGlideModule implementations, not: " + element);
+      }
+
+      libraryGlideModules.add(element);
+    }
+
+    processorUtil.debugLog("got child modules: " + libraryGlideModules);
+    if (libraryGlideModules.isEmpty()) {
+      return false;
+    }
+
+    TypeSpec indexer = indexerGenerator.generate(libraryGlideModules);
+    processorUtil.writeIndexer(indexer);
+    processorUtil.debugLog("Wrote an Indexer this round, skipping the app module to ensure all "
+        + "indexers are found");
+     // If I write an Indexer in a round in the target package, then try to find all classes in
+    // the target package, my newly written Indexer won't be found. Since we wrote a class with
+    // an Annotation handled by this processor, we know we will be called again in the next round
+    // and we can safely wait to write our AppGlideModule until then.
+    return true;
+  }
+
+  Set<String> getSupportedAnnotationTypes() {
+    return Collections.singleton(GlideModule.class.getName());
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
new file mode 100644
index 000000000..5229afc21
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -0,0 +1,364 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor.DEBUG;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.sun.tools.javac.code.Attribute;
+import com.sun.tools.javac.code.Type.ClassType;
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+/**
+ * Utilities for writing classes and logging.
+ */
+final class ProcessorUtil {
+  private static final String GLIDE_MODULE_PACKAGE_NAME = "com.bumptech.glide.module";
+  private static final String APP_GLIDE_MODULE_SIMPLE_NAME = "AppGlideModule";
+  private static final String LIBRARY_GLIDE_MODULE_SIMPLE_NAME = "LibraryGlideModule";
+  private static final String APP_GLIDE_MODULE_QUALIFIED_NAME =
+      GLIDE_MODULE_PACKAGE_NAME + "." + APP_GLIDE_MODULE_SIMPLE_NAME;
+  private static final String LIBRARY_GLIDE_MODULE_QUALIFIED_NAME =
+      GLIDE_MODULE_PACKAGE_NAME + "." + LIBRARY_GLIDE_MODULE_SIMPLE_NAME;
+  private static final String COMPILER_PACKAGE_NAME =
+      GlideAnnotationProcessor.class.getPackage().getName();
+
+  private final ProcessingEnvironment processingEnv;
+  private final TypeElement appGlideModuleType;
+  private final TypeElement libraryGlideModuleType;
+  private int round;
+
+  ProcessorUtil(ProcessingEnvironment processingEnv) {
+    this.processingEnv = processingEnv;
+
+    appGlideModuleType =
+        processingEnv.getElementUtils().getTypeElement(APP_GLIDE_MODULE_QUALIFIED_NAME);
+    libraryGlideModuleType =
+        processingEnv.getElementUtils().getTypeElement(LIBRARY_GLIDE_MODULE_QUALIFIED_NAME);
+  }
+
+  void process() {
+    round++;
+  }
+
+  boolean isAppGlideModule(TypeElement element) {
+    return processingEnv.getTypeUtils().isAssignable(element.asType(),
+        appGlideModuleType.asType());
+  }
+
+  boolean isLibraryGlideModule(TypeElement element) {
+    return processingEnv.getTypeUtils().isAssignable(element.asType(),
+        libraryGlideModuleType.asType());
+  }
+
+  boolean isExtension(TypeElement element) {
+    return element.getAnnotation(GlideExtension.class) != null;
+  }
+
+  void writeIndexer(TypeSpec indexer) {
+    writeClass(COMPILER_PACKAGE_NAME, indexer);
+  }
+
+  void writeClass(String packageName, TypeSpec clazz) {
+    try {
+      debugLog("Writing class:\n" + clazz);
+      JavaFile.builder(packageName, clazz).build().writeTo(processingEnv.getFiler());
+    } catch (Throwable e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  List<ExecutableElement> findAnnotatedElementsInClasses(
+      Set<String> classNames, Class<? extends Annotation> annotationClass) {
+    List<ExecutableElement> result = new ArrayList<>();
+    for (String glideExtensionClassName : classNames) {
+      TypeElement glideExtension = processingEnv.getElementUtils()
+          .getTypeElement(glideExtensionClassName);
+      for (Element element : glideExtension.getEnclosedElements()) {
+        if (element.getAnnotation(annotationClass) != null) {
+          result.add((ExecutableElement) element);
+        }
+      }
+    }
+    return result;
+  }
+
+  List<TypeElement> getElementsFor(
+      Class<? extends Annotation> clazz, RoundEnvironment env) {
+    Collection<? extends Element> annotatedElements = env.getElementsAnnotatedWith(clazz);
+    return ElementFilter.typesIn(annotatedElements);
+  }
+
+  /**
+   * Generates a Javadoc code block for generated methods that delegate to methods in
+   * {@link GlideExtension}s.
+   *
+   * <p>The generated block looks something like this:
+   * <pre>
+   * <code>
+   *   {@literal @see} com.extension.package.name.ExtensionClassName#extensionMethod(arg1, argN)
+   * </code>
+   * </pre>
+   *
+   * @param method The method from the {@link GlideExtension} annotated class that the generated
+   * method this Javadoc will be attached to delegates to.
+   */
+  CodeBlock generateSeeMethodJavadoc(ExecutableElement method) {
+    // Use the simple name of the containing type instead of just the containing type's TypeMirror
+    // so that we avoid appending <CHILD> or other type arguments to the class and breaking
+    // Javadoc's linking.
+    // With this we get @see RequestOptions#methodName().
+    // With just ClassName.get(element.getEnclosingElement().asType()), we get:
+    // @see RequestOptions<CHILD>#methodName().
+    return generateSeeMethodJavadoc(getJavadocSafeName(method.getEnclosingElement()),
+        method.getSimpleName().toString(), method.getParameters());
+  }
+
+  /**
+   * Generates a Javadoc block for generated methods that delegate to other methods.
+   *
+   * <p>The generated block looks something like this:
+   * <pre>
+   * <code>
+   *     {@literal @see} com.package.ClassContainingMethod.methodSimpleName(
+   *         methodParam1, methodParamN)
+   * </code>
+   * </pre>
+   * @param nameOfClassContainingMethod The simple class name of the class containing the method
+   * without any generic types like {@literal <T>}.
+   * @param methodSimpleName The name of the method.
+   * @param methodParameters A maybe empty list of all the parameters for the method in question.
+   */
+  CodeBlock generateSeeMethodJavadoc(
+      TypeName nameOfClassContainingMethod, String methodSimpleName,
+      List<? extends VariableElement> methodParameters) {
+    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
+        methodSimpleName, Lists.transform(methodParameters,
+            new Function<VariableElement, Object>() {
+              @Override
+              public Object apply(VariableElement input) {
+                return getJavadocSafeName(input);
+              }
+            }));
+  }
+
+  CodeBlock generateSeeMethodJavadoc(
+      TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {
+    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,
+        methodSpec.name, Lists.transform(methodSpec.parameters,
+            new Function<ParameterSpec, Object>() {
+              @Override
+              public Object apply(ParameterSpec input) {
+                return input.type;
+              }
+            }));
+  }
+
+  private CodeBlock generateSeeMethodJavadocInternal(
+      TypeName nameOfClassContainingMethod, String methodName,
+      List<Object> safeParameterNames) {
+     String javadocString = "@see $T#$L(";
+    List<Object> javadocArgs = new ArrayList<>();
+    javadocArgs.add(nameOfClassContainingMethod);
+    javadocArgs.add(methodName);
+
+    for (Object param : safeParameterNames) {
+      javadocString += "$T, ";
+      javadocArgs.add(param);
+    }
+    if (javadocArgs.size() > 2) {
+      javadocString = javadocString.substring(0, javadocString.length() - 2);
+    }
+    javadocString += ")\n";
+    return CodeBlock.of(javadocString, javadocArgs.toArray(new Object[0]));
+  }
+
+
+   /**
+   * Returns a safe String to use in a Javadoc that will function in a link.
+   *
+   * <p>This method exists because by Javadoc doesn't handle type parameters({@literal <T>}
+   * in {@literal RequestOptions<T>} for example).
+   */
+  private TypeName getJavadocSafeName(Element element) {
+    Types typeUtils = processingEnv.getTypeUtils();
+    TypeMirror type = element.asType();
+    if (typeUtils.asElement(type) == null) {
+      // If there is no Element, it's a primitive and can't have additional types, so we're done.
+      return ClassName.get(element.asType());
+    }
+    Name simpleName = typeUtils.asElement(type).getSimpleName();
+    return ClassName.bestGuess(simpleName.toString());
+  }
+
+  void debugLog(String toLog) {
+    if (DEBUG) {
+      infoLog(toLog);
+    }
+  }
+
+  void infoLog(String toLog) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "[" + round + "] " + toLog);
+  }
+
+  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeElement returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findStaticMethodsReturning(TypeElement clazz, TypeElement returnType) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods(returnType, MethodType.STATIC))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  List<ExecutableElement> findStaticMethods(TypeElement clazz) {
+    return FluentIterable.from(clazz.getEnclosedElements())
+        .filter(new FilterPublicMethods((TypeMirror) null /*returnType*/, MethodType.STATIC))
+        .transform(new ToMethod())
+        .toList();
+  }
+
+  Set<String> findClassValuesFromAnnotationOnClassAsNames(
+      Element clazz, Class<? extends Annotation> annotationClass) {
+    String annotationClassName = annotationClass.getName();
+    AnnotationValue excludedModuleAnnotationValue = null;
+    for (AnnotationMirror annotationMirror : clazz.getAnnotationMirrors()) {
+      // Two different AnnotationMirrors the same class might not be equal, so compare Strings
+      // instead. This check is necessary because a given class may have multiple Annotations.
+      if (!annotationClassName.equals(annotationMirror.getAnnotationType().toString())) {
+        continue;
+      }
+      Set<? extends Map.Entry<? extends ExecutableElement, ? extends AnnotationValue>> values =
+          annotationMirror.getElementValues().entrySet();
+      // Excludes has only one value. If we ever change that, we'd need to iterate over all
+      // values in the entry set and compare the keys to whatever our Annotation's attribute is
+      // (usually value).
+      if (values.size() != 1) {
+        throw new IllegalArgumentException("Expected single value, but found: " + values);
+      }
+      excludedModuleAnnotationValue = values.iterator().next().getValue();
+      if (excludedModuleAnnotationValue == null) {
+        throw new NullPointerException("Failed to find Excludes#value");
+      }
+    }
+    if (excludedModuleAnnotationValue == null) {
+      return Collections.emptySet();
+    }
+    Object value = excludedModuleAnnotationValue.getValue();
+    if (value instanceof List) {
+      List values = (List) value;
+      Set<String> result = new HashSet<>(values.size());
+      for (Object current : values) {
+        Attribute.Class currentClass = (Attribute.Class) current;
+        result.add(currentClass.getValue().toString());
+      }
+      return result;
+    } else {
+      ClassType classType = (ClassType) value;
+      return Collections.singleton(classType.toString());
+    }
+  }
+
+  private enum MethodType {
+    STATIC,
+    INSTANCE
+  }
+
+  private final class FilterPublicMethods implements Predicate<Element> {
+    @Nullable
+    private final TypeMirror returnType;
+    private final MethodType methodType;
+
+    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType)  {
+      this.returnType = returnType;
+      this.methodType = methodType;
+    }
+
+    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType)  {
+      this(returnType != null ? returnType.asType() : null, methodType);
+    }
+
+    @Override
+    public boolean apply(@Nullable Element input) {
+      if (input == null
+          || input.getKind() != ElementKind.METHOD
+          || !input.getModifiers().contains(Modifier.PUBLIC)) {
+        return false;
+      }
+      boolean isStatic = input.getModifiers().contains(Modifier.STATIC);
+      if (methodType == MethodType.STATIC && !isStatic) {
+        return false;
+      } else if (methodType == MethodType.INSTANCE && isStatic) {
+        return false;
+      }
+      ExecutableElement method = (ExecutableElement) input;
+      if (returnType == null) {
+        return true;
+      }
+      return isReturnValueTypeMatching(method, returnType);
+    }
+  }
+
+  boolean isReturnValueTypeMatching(ExecutableElement method, TypeElement expectedReturnType) {
+    return isReturnValueTypeMatching(method, expectedReturnType.asType());
+  }
+
+  private boolean isReturnValueTypeMatching(
+      ExecutableElement method, TypeMirror expectedReturnType) {
+    return processingEnv.getTypeUtils().isAssignable(
+        method.getReturnType(), expectedReturnType);
+  }
+
+  private static final class ToMethod implements Function<Element, ExecutableElement> {
+
+    @Nullable
+    @Override
+    public ExecutableElement apply(@Nullable Element input) {
+      return (ExecutableElement) input;
+    }
+  }
+
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
new file mode 100644
index 000000000..21c147ddc
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -0,0 +1,351 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import com.squareup.javapoet.WildcardTypeName;
+import java.io.File;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Generates a {@link com.bumptech.glide.RequestBuilder} subclass containing all methods from
+ * the base class, all methods from {@link com.bumptech.glide.request.RequestOptions} and all
+ * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated
+ * classes.
+ *
+ * <p>Generated code looks like this:
+ * <pre>
+ * <code>
+ * public final class GlideRequest<TranscodeType> extends RequestBuilder<TranscodeType> {
+ *   GlideRequest(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+ *     super(transcodeClass, other);
+ *   }
+ *
+ *   GlideRequest(GlideContext context, RequestManager requestManager,
+ *       Class<TranscodeType> transcodeClass) {
+ *     super(context, requestManager ,transcodeClass);
+ *   }
+ *
+ *   {@literal @Override}
+ *   protected GlideRequest<File> getDownloadOnlyRequest() {
+ *    return new GlideRequest<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
+ *   }
+ *
+ *   /**
+ *    * {@literal @see} GlideOptions#dontAnimate()
+ *    *\/
+ *   public GlideRequest<TranscodeType> dontAnimate() {
+ *     if (getMutableOptions() instanceof GlideOptions) {
+ *       this.requestOptions = ((GlideOptions) getMutableOptions()).dontAnimate();
+ *     } else {
+ *       this.requestOptions = new GlideOptions().apply(this.requestOptions).dontAnimate();
+ *     }
+ *     return this;
+ *   }
+ *
+ *   /**
+ *    * {@literal @see} RequestOptions#sizeMultiplier(float)
+ *    *\/
+ *   public GlideRequest<TranscodeType> sizeMultiplier(float sizeMultiplier) {
+ *     this.requestOptions = getMutableOptions().sizeMultiplier(sizeMultiplier);
+ *     return this;
+ *   }
+ *
+ *   ...
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestBuilderGenerator {
+  private static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  private static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
+
+  private static final String REQUEST_BUILDER_PACKAGE_NAME = "com.bumptech.glide";
+  private static final String REQUEST_BUILDER_SIMPLE_NAME = "RequestBuilder";
+  static final String REQUEST_BUILDER_QUALIFIED_NAME =
+      REQUEST_BUILDER_PACKAGE_NAME + "." + REQUEST_BUILDER_SIMPLE_NAME;
+
+  // Uses package private methods and variables.
+  private static final String GENERATED_REQUEST_BUILDER_SIMPLE_NAME = "GlideRequest";
+
+  /**
+   * An arbitrary name of the Generic type in the generated RequestBuilder.
+   * e.g. RequestBuilder<TranscodeType>
+   */
+  private static final String TRANSCODE_TYPE_NAME = "TranscodeType";
+  /** A set of method names to avoid overriding from RequestOptions. */
+  private static final ImmutableSet<String> EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS =
+      ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");
+
+  private final ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private ClassName generatedRequestBuilderClassName;
+  private final TypeVariableName transcodeTypeName;
+  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;
+  private final TypeElement requestOptionsType;
+  private final TypeElement requestBuilderType;
+  private ClassName requestOptionsClassName;
+
+  RequestBuilderGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    requestBuilderType = processingEnv.getElementUtils()
+        .getTypeElement(REQUEST_BUILDER_QUALIFIED_NAME);
+
+    transcodeTypeName = TypeVariableName.get(TRANSCODE_TYPE_NAME);
+
+    requestOptionsType = processingEnv.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {
+    generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);
+    generatedRequestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);
+
+    if (generatedOptions != null) {
+      requestOptionsClassName =
+          ClassName.get(generatedCodePackageName, generatedOptions.name);
+    } else {
+      requestOptionsClassName =
+          ClassName.get(
+              RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,
+              RequestBuilderGenerator.REQUEST_OPTIONS_SIMPLE_NAME);
+    }
+
+    ParameterizedTypeName requestBuilderOfTranscodeType =
+        ParameterizedTypeName.get(
+            ClassName.get(REQUEST_BUILDER_PACKAGE_NAME, REQUEST_BUILDER_SIMPLE_NAME),
+            transcodeTypeName);
+
+    return TypeSpec.classBuilder(GENERATED_REQUEST_BUILDER_SIMPLE_NAME)
+        .addJavadoc("Contains all public methods from {@link $T}, all options from\n",
+            requestBuilderType)
+        .addJavadoc("{@link $T} and all generated options from\n", requestOptionsType)
+        .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class)
+        .addJavadoc("{@link $T} annotated classes.\n", GlideExtension.class)
+        .addJavadoc("\n")
+        .addJavadoc("<p>Generated code, do not modify.\n")
+        .addJavadoc("\n")
+        .addJavadoc("@see $T\n", requestBuilderType)
+        .addJavadoc("@see $T\n", requestOptionsType)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "unused")
+                .addMember("value", "$S", "deprecation")
+                .build())
+        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addTypeVariable(transcodeTypeName)
+        .superclass(requestBuilderOfTranscodeType)
+        .addMethods(generateConstructors())
+        .addMethod(generateDownloadOnlyRequestMethod())
+        .addMethods(generateGeneratedRequestOptionsEquivalents(generatedOptions))
+        .addMethods(generateRequestBuilderOverrides())
+        .build();
+  }
+
+  /**
+   * Generates overrides of all methods in {@link com.bumptech.glide.RequestBuilder} that return
+   * {@link com.bumptech.glide.RequestBuilder} so that they return our generated subclass instead.
+   */
+  private List<MethodSpec> generateRequestBuilderOverrides() {
+    TypeMirror rawRequestBuilderType =
+        processingEnv.getTypeUtils().erasure(requestBuilderType.asType());
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestBuilderType, rawRequestBuilderType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestBuilderOverride(input);
+          }
+        });
+  }
+
+  /**
+   * Generates an override of a particular method in {@link com.bumptech.glide.RequestBuilder} that
+   * returns {@link com.bumptech.glide.RequestBuilder} so that it returns our generated subclass
+   * instead.
+   */
+  private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOverride) {
+    // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // exactly one type argument, so this is safe unless those assumptions change.
+    TypeMirror typeArgument =
+        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
+
+    ParameterizedTypeName generatedRequestBuilderOfType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
+
+    return MethodSpec.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(",
+                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build())
+        .build();
+  }
+
+  /**
+   * Generates methods with equivalent names and arguments to methods annotated with
+   * {@link GlideOption} in
+   * {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated
+   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   */
+  private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(
+      @Nullable final TypeSpec generatedOptions) {
+    if (generatedOptions == null) {
+      return Collections.emptyList();
+    }
+    return FluentIterable
+        .from(generatedOptions.methodSpecs)
+        .filter(new Predicate<MethodSpec>() {
+          @Override
+          public boolean apply(MethodSpec input) {
+            return isUsefulGeneratedRequestOption(input);
+          }
+        })
+        .transform(new Function<MethodSpec, MethodSpec>() {
+          @Override
+          public MethodSpec apply(MethodSpec input) {
+            return generateGeneratedRequestOptionEquivalent(input);
+          }
+        })
+        .toList();
+  }
+
+  /**
+   * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our
+   * {@link com.bumptech.glide.RequestBuilder} subclass.
+   *
+   * <p>Only newly generated methods will be included in the generated
+   * {@link com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out
+   * methods that override other methods to avoid duplicates.
+   */
+  private boolean isUsefulGeneratedRequestOption(MethodSpec requestOptionMethod) {
+    return
+        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionMethod.name)
+        && requestOptionMethod.hasModifier(Modifier.PUBLIC)
+        && !requestOptionMethod.hasModifier(Modifier.STATIC)
+        && requestOptionMethod.returnType.toString()
+            .equals(requestOptionsClassName.toString());
+  }
+
+   /**
+   * Generates a particular method with  an equivalent name and arguments to the given method
+   * from the generated {@link com.bumptech.glide.request.BaseRequestBuilder} subclass.
+   */
+  private MethodSpec generateGeneratedRequestOptionEquivalent(MethodSpec requestOptionMethod) {
+    CodeBlock callRequestOptionsMethod = CodeBlock.builder()
+        .add(".$N(", requestOptionMethod.name)
+        .add(FluentIterable.from(requestOptionMethod.parameters)
+            .transform(new Function<ParameterSpec, String>() {
+              @Override
+              public String apply(ParameterSpec input) {
+                return input.name;
+              }
+            })
+            .join(Joiner.on(", ")))
+        .add(");\n")
+        .build();
+
+    return MethodSpec.methodBuilder(requestOptionMethod.name)
+        .addJavadoc(
+            processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod))
+        .addModifiers(Modifier.PUBLIC)
+        .addTypeVariables(requestOptionMethod.typeVariables)
+        .addParameters(requestOptionMethod.parameters)
+        .returns(generatedRequestBuilderOfTranscodeType)
+        .beginControlFlow(
+            "if (getMutableOptions() instanceof $T)", requestOptionsClassName)
+        .addCode("this.requestOptions = (($T) getMutableOptions())",
+            requestOptionsClassName)
+        .addCode(callRequestOptionsMethod)
+        .nextControlFlow("else")
+        .addCode(CodeBlock.of("this.requestOptions = new $T().apply(this.requestOptions)",
+            requestOptionsClassName))
+        .addCode(callRequestOptionsMethod)
+        .endControlFlow()
+        .addStatement("return this")
+        .build();
+  }
+
+  private List<MethodSpec> generateConstructors() {
+    ParameterizedTypeName classOfTranscodeType =
+        ParameterizedTypeName.get(ClassName.get(Class.class), transcodeTypeName);
+
+    TypeName wildcardOfObject = WildcardTypeName.subtypeOf(Object.class);
+    ParameterizedTypeName requestBuilderOfWildcardOfObject =
+        ParameterizedTypeName.get(ClassName.get(requestBuilderType), wildcardOfObject);
+
+    MethodSpec firstConstructor =
+        MethodSpec.constructorBuilder()
+            .addParameter(classOfTranscodeType, "transcodeClass")
+            .addParameter(requestBuilderOfWildcardOfObject, "other")
+        .addStatement("super($N, $N)", "transcodeClass", "other")
+        .build();
+
+    ClassName glide = ClassName.get("com.bumptech.glide", "Glide");
+    ClassName requestManager = ClassName.get("com.bumptech.glide", "RequestManager");
+    MethodSpec secondConstructor =
+        MethodSpec.constructorBuilder()
+            .addParameter(glide, "glide")
+            .addParameter(requestManager, "requestManager")
+            .addParameter(classOfTranscodeType, "transcodeClass")
+            .addStatement("super($N, $N ,$N)", "glide", "requestManager", "transcodeClass")
+            .build();
+    return ImmutableList.of(firstConstructor, secondConstructor);
+  }
+
+  /**
+   * Overrides the protected downloadOnly method in {@link com.bumptech.glide.RequestBuilder} to
+   * return our generated subclass instead.
+   */
+  private MethodSpec generateDownloadOnlyRequestMethod() {
+    ParameterizedTypeName generatedRequestBuilderOfFile
+        = ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(File.class));
+    return MethodSpec.methodBuilder("getDownloadOnlyRequest")
+        .addAnnotation(Override.class)
+        .returns(generatedRequestBuilderOfFile)
+        .addModifiers(Modifier.PROTECTED)
+        .addStatement("return new $T<>($T.class, $N).apply($N)",
+            generatedRequestBuilderClassName, File.class, "this",
+            "DOWNLOAD_ONLY_OPTIONS")
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
new file mode 100644
index 000000000..a86bb1a37
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java
@@ -0,0 +1,89 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates an implementation of
+ * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} that returns a
+ * generated {@link com.bumptech.glide.RequestManager} implementation.
+ *
+ * <p>Generated {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}
+ * classes look like this:
+ * <pre>
+ * <code>
+ * public class GeneratedRequestManagerFactory
+ *     implements RequestManagerRetriever.RequestManagerFactory {
+ *   {@literal @Override}
+ *   public RequestManager build(Glide glide, Lifecycle lifecycle,
+ *       RequestManagerTreeNode treeNode) {
+ *     return new GeneratedRequestManager(glide, lifecycle, treeNode);
+ *   }
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestManagerFactoryGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+  private static final String LIFECYCLE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.Lifecycle";
+  private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerTreeNode";
+  private static final String REQUEST_MANAGER_FACTORY_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_PACKAGE_NAME =
+      "com.bumptech.glide";
+  static final String GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME =
+      "GeneratedRequestManagerFactory";
+
+  private final TypeElement glideType;
+  private final TypeElement lifecycleType;
+  private final TypeElement requestManagerTreeNodeType;
+  private final TypeElement requestManagerFactoryInterface;
+  private final ClassName requestManagerClassName;
+
+  RequestManagerFactoryGenerator(ProcessingEnvironment processingEnv) {
+    Elements elementUtils = processingEnv.getElementUtils();
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+    lifecycleType = elementUtils.getTypeElement(LIFECYCLE_QUALIFIED_NAME);
+    requestManagerTreeNodeType =
+        elementUtils.getTypeElement(REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME);
+
+    requestManagerFactoryInterface =
+        elementUtils.getTypeElement(REQUEST_MANAGER_FACTORY_QUALIFIED_NAME);
+
+    TypeElement requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+    requestManagerClassName = ClassName.get(requestManagerType);
+
+  }
+
+  TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestManagerSpec) {
+    return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_FACTORY_SIMPLE_NAME)
+        .addModifiers(Modifier.FINAL)
+        .addSuperinterface(ClassName.get(requestManagerFactoryInterface))
+        .addJavadoc("Generated code, do not modify\n")
+        .addMethod(
+            MethodSpec.methodBuilder("build")
+                .addModifiers(Modifier.PUBLIC)
+                .addAnnotation(Override.class)
+                .returns(requestManagerClassName)
+                .addParameter(ClassName.get(glideType), "glide")
+                .addParameter(ClassName.get(lifecycleType), "lifecycle")
+                .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
+                .addStatement(
+                    "return new $T(glide, lifecycle, treeNode)",
+                    ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name))
+                .build()
+        )
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
new file mode 100644
index 000000000..9bc11e7dc
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -0,0 +1,296 @@
+package com.bumptech.glide.annotation.compiler;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideType;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates an implementation of {@link com.bumptech.glide.RequestManager} that contains generated
+ * methods from {@link GlideExtension}s and {@link GlideType}.
+ *
+ * <p>Generated {@link com.bumptech.glide.RequestManager} implementations look like this:
+ * <pre>
+ * <code>
+ * public final class GeneratedRequestManager extends RequestManager {
+ *   GeneratedRequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+ *     super(glide, lifecycle, treeNode);
+ *   }
+ *
+ *   public RequestBuilder<GifDrawable> asGif() {
+ *     RequestBuilder<GifDrawable> requestBuilder = this.as(GifDrawable.class);
+ *     GifOptions.asGif(requestBuilder);
+ *     return requestBuilder;
+ *   }
+ * }
+ * </code>
+ * </pre>
+ */
+final class RequestManagerGenerator {
+  private static final String GLIDE_QUALIFIED_NAME =
+      "com.bumptech.glide.Glide";
+  private static final String REQUEST_MANAGER_QUALIFIED_NAME =
+      "com.bumptech.glide.RequestManager";
+  private static final String LIFECYCLE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.Lifecycle";
+  private static final String REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME =
+      "com.bumptech.glide.manager.RequestManagerTreeNode";
+
+  private static final String GENERATED_REQUEST_MANAGER_SIMPLE_NAME =
+      "GlideRequests";
+
+  private ProcessingEnvironment processingEnv;
+  private final ProcessorUtil processorUtil;
+  private final ClassName requestManagerClassName;
+  private final TypeElement lifecycleType;
+  private final TypeElement requestManagerTreeNodeType;
+  private final TypeElement glideType;
+  private final TypeElement requestManagerType;
+  private final TypeElement requestBuilderType;
+  private ClassName generatedRequestBuilderClassName;
+
+  RequestManagerGenerator(ProcessingEnvironment processingEnv, ProcessorUtil processorUtil) {
+    this.processingEnv = processingEnv;
+    this.processorUtil = processorUtil;
+
+    Elements elementUtils = processingEnv.getElementUtils();
+
+    requestManagerType = elementUtils.getTypeElement(REQUEST_MANAGER_QUALIFIED_NAME);
+    requestManagerClassName = ClassName.get(requestManagerType);
+
+    lifecycleType = elementUtils.getTypeElement(LIFECYCLE_QUALIFIED_NAME);
+    requestManagerTreeNodeType =
+        elementUtils.getTypeElement(REQUEST_MANAGER_TREE_NODE_QUALIFIED_NAME);
+
+    requestBuilderType =
+        elementUtils.getTypeElement(RequestBuilderGenerator.REQUEST_BUILDER_QUALIFIED_NAME);
+
+    glideType = elementUtils.getTypeElement(GLIDE_QUALIFIED_NAME);
+  }
+
+  @Nullable
+  TypeSpec generate(
+      String generatedCodePackageName, @Nullable TypeSpec requestOptions, TypeSpec requestBuilder,
+      Set<String> glideExtensions) {
+    generatedRequestBuilderClassName = ClassName.get(generatedCodePackageName, requestBuilder.name);
+    return TypeSpec.classBuilder(GENERATED_REQUEST_MANAGER_SIMPLE_NAME)
+         .superclass(requestManagerClassName)
+         .addJavadoc("Includes all additions from methods in {@link $T}s\n"
+                 + "annotated with {@link $T}\n"
+                 + "\n"
+                 + "<p>Generated code, do not modify\n",
+             GlideExtension.class, GlideType.class)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build())
+         .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+         .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
+         .addMethod(generateCallSuperConstructor())
+         .addMethods(generateAdditionalRequestManagerMethods(glideExtensions))
+         .addMethods(generateRequestManagerMethodOverrides())
+         .addMethods(
+             FluentIterable.from(
+                 Collections.singletonList(
+                     generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions)))
+                 .filter(Predicates.<MethodSpec>notNull()))
+         .build();
+  }
+
+  private MethodSpec generateCallSuperConstructor() {
+    return MethodSpec.constructorBuilder()
+        .addModifiers(Modifier.PUBLIC)
+        .addParameter(ClassName.get(glideType), "glide")
+        .addParameter(ClassName.get(lifecycleType), "lifecycle")
+        .addParameter(ClassName.get(requestManagerTreeNodeType), "treeNode")
+        .addStatement("super(glide, lifecycle, treeNode)")
+        .build();
+  }
+
+  private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec requestBuilder) {
+    TypeVariableName resourceType = TypeVariableName.get("ResourceType");
+    ParameterizedTypeName classOfResouceType = ParameterizedTypeName
+        .get(ClassName.get(Class.class), resourceType);
+
+    ClassName generatedRequestBuilderClassName =
+        ClassName.get(generatedCodePackageName, requestBuilder.name);
+
+    ParameterizedTypeName requestBuilderOfResourceType = ParameterizedTypeName
+        .get(generatedRequestBuilderClassName, resourceType);
+
+    return MethodSpec.methodBuilder("as")
+        .addModifiers(Modifier.PUBLIC)
+        .addAnnotation(Override.class)
+        .addTypeVariable(TypeVariableName.get("ResourceType"))
+        .addParameter(classOfResouceType, "resourceClass")
+        .returns(requestBuilderOfResourceType)
+        .addStatement("return new $T<>(glide, this, resourceClass)",
+            this.generatedRequestBuilderClassName)
+        .build();
+  }
+
+  private List<MethodSpec> generateRequestManagerMethodOverrides() {
+    // Without the erasure, this is a RequestBuilder<Y>. A RequestBuilder<X> is not assignable to a
+    // RequestBuilder<Y>. After type erasure this is a RequestBuilder. A RequestBuilder<X> is
+    // assignable to the raw RequestBuilder.
+    TypeMirror rawRequestBuilder = processingEnv.getTypeUtils()
+        .erasure(requestBuilderType.asType());
+
+    final TypeElement classType =
+        processingEnv.getElementUtils().getTypeElement(Class.class.getCanonicalName());
+    final TypeMirror rawClassType = processingEnv.getTypeUtils().erasure(classType.asType());
+
+    return FluentIterable.from(
+        processorUtil.findInstanceMethodsReturning(requestManagerType, rawRequestBuilder))
+        .filter(new Predicate<ExecutableElement>() {
+          @Override
+          public boolean apply(ExecutableElement input) {
+            // Skip the <T> as(Class<T>) method.
+            return !input.getSimpleName().toString().equals("as")
+                || input.getParameters().size() != 1
+                || !processingEnv.getTypeUtils().isAssignable(
+                    input.getParameters().get(0).asType(), rawClassType);
+          }
+        })
+        .transform(new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestManagerMethodOverride(input);
+          }
+        })
+        .toList();
+  }
+
+  /**
+   * Generates overrides of existing RequestManager methods so that they return our generated
+   * RequestBuilder subtype.
+   */
+  private MethodSpec generateRequestManagerMethodOverride(ExecutableElement methodToOverride) {
+     // We've already verified that this method returns a RequestBuilder and RequestBuilders have
+    // exactly one type argument, so this is safe unless those assumptions change.
+    TypeMirror typeArgument =
+        ((DeclaredType) methodToOverride.getReturnType()).getTypeArguments().get(0);
+
+    ParameterizedTypeName generatedRequestBuilderOfType =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
+
+    return MethodSpec.overriding(methodToOverride)
+        .returns(generatedRequestBuilderOfType)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(",
+                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build())
+        .build();
+  }
+
+  private List<MethodSpec> generateAdditionalRequestManagerMethods(
+      Set<String> glideExtensions) {
+    List<ExecutableElement> requestManagerExtensionMethods =
+        processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);
+
+    return Lists.transform(requestManagerExtensionMethods,
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateAdditionalRequestManagerMethod(input);
+          }
+        });
+  }
+
+  // Generates methods added to RequestManager via GlideExtensions.
+  private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement extensionMethod) {
+    String returnType = processorUtil.findClassValuesFromAnnotationOnClassAsNames(extensionMethod,
+        GlideType.class).iterator().next();
+    ClassName returnTypeClassName = ClassName.bestGuess(returnType);
+    ParameterizedTypeName parameterizedTypeName =
+        ParameterizedTypeName.get(generatedRequestBuilderClassName, returnTypeClassName);
+
+    return MethodSpec.methodBuilder(extensionMethod.getSimpleName().toString())
+        .addModifiers(Modifier.PUBLIC)
+        .returns(parameterizedTypeName)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(extensionMethod))
+        .addStatement(
+            "$T requestBuilder = this.as($T.class)", parameterizedTypeName, returnTypeClassName)
+        .addStatement("$T.$N(requestBuilder)",
+            extensionMethod.getEnclosingElement(), extensionMethod.getSimpleName())
+        .addStatement("return requestBuilder")
+        .build();
+  }
+
+  /**
+   * The {@link com.bumptech.glide.request.RequestOptions} subclass should always be our
+   * generated subclass type to avoid inadvertent errors where a different subclass is applied that
+   * accidentally wipes out some logic in overidden methods in our generated subclass.
+   */
+  @Nullable
+  private MethodSpec generateOverrideSetRequestOptions(
+      String generatedCodePackageName, @Nullable TypeSpec generatedRequestOptions) {
+    if (generatedRequestOptions == null) {
+      return null;
+    }
+
+    Elements elementUtils = processingEnv.getElementUtils();
+    TypeElement requestOptionsType =
+            elementUtils.getTypeElement(
+                RequestOptionsGenerator.REQUEST_OPTIONS_QUALIFIED_NAME);
+    TypeElement androidNonNullType =
+            elementUtils.getTypeElement("android.support.annotation.NonNull");
+
+    // This class may have just been generated and therefore may not be found if we try to obtain
+    // it via Elements, so use just the String version instead.
+    String generatedRequestOptionsQualifiedName =
+        generatedCodePackageName + "." + generatedRequestOptions.name;
+
+    String methodName = "setRequestOptions";
+    String parameterName = "toSet";
+
+    return MethodSpec.methodBuilder(methodName)
+        .addAnnotation(Override.class)
+        .addModifiers(Modifier.PROTECTED)
+        .addParameter(
+            ParameterSpec.builder(ClassName.get(requestOptionsType), parameterName)
+                .addAnnotation(ClassName.get(androidNonNullType))
+                .build())
+        .beginControlFlow("if ($N instanceof $L)",
+            parameterName, generatedRequestOptionsQualifiedName)
+        .addStatement("super.$N($N)", methodName, parameterName)
+        .nextControlFlow("else")
+        .addStatement("super.setRequestOptions(new $L().apply($N))",
+            generatedRequestOptionsQualifiedName, parameterName)
+        .endControlFlow()
+        .build();
+  }
+}
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
new file mode 100644
index 000000000..b9d7e913d
--- /dev/null
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -0,0 +1,614 @@
+package com.bumptech.glide.annotation.compiler;
+
+import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;
+import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_NONE;
+
+import com.bumptech.glide.annotation.GlideExtension;
+import com.bumptech.glide.annotation.GlideOption;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
+import com.google.common.base.Strings;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.CodeBlock.Builder;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * Generates a new implementation of {@link com.bumptech.glide.request.RequestOptions}
+ * containing static versions of methods included in the base class and static and instance versions
+ * of all methods annotated with {@link GlideOption} in classes annotated with
+ * {@link GlideExtension}.
+ *
+ * <p>The generated class looks something like this:
+ * <pre>
+ * <code>
+ * public final class GlideOptions extends com.bumptech.glide.request.RequestOptions {
+ *
+ *   public static com.google.android.apps.photos.glide.GlideOptions signatureOf(
+ *       com.bumptech.glide.load.Key arg0) {
+ *     return new com.google.android.apps.photos.glide.GlideOptions()
+ *         .apply(com.bumptech.glide.request.RequestOptions.signatureOf(arg0));
+ *   }
+ *
+ *   ... // The rest of the static versions of methods from RequestOptions go here.
+ *
+ *   // Now on to methods generated from an extension:
+ *   public com.bumptech.glide.GlideOptions dontAnimate() {
+ *     com.bumptech.glide.integration.gifdecoder.GifOptions.dontAnimate(this);
+ *     return this;
+ *   }
+ *
+ *   public static com.bumptech.glide.GlideOptions noAnimation() {
+ *     return new com.bumptech.glide.GlideOptions().dontAnimate();
+ *   }
+ * }
+ * </code>
+ * </pre>
+ * </p>
+ */
+final class RequestOptionsGenerator {
+  private static final String GENERATED_REQUEST_OPTIONS_SIMPLE_NAME = "GlideOptions";
+  static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";
+  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";
+  static final String REQUEST_OPTIONS_QUALIFIED_NAME =
+      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;
+
+  private final ProcessingEnvironment processingEnvironment;
+  private final ClassName requestOptionsName;
+  private final TypeElement requestOptionsType;
+  private final ProcessorUtil processorUtil;
+  private ClassName glideOptionsName;
+  private int nextStaticFieldUniqueId;
+
+  RequestOptionsGenerator(
+      ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {
+    this.processingEnvironment = processingEnvironment;
+    this.processorUtil = processorUtil;
+
+    requestOptionsName = ClassName.get(REQUEST_OPTIONS_PACKAGE_NAME,
+        REQUEST_OPTIONS_SIMPLE_NAME);
+
+    requestOptionsType = processingEnvironment.getElementUtils().getTypeElement(
+        REQUEST_OPTIONS_QUALIFIED_NAME);
+  }
+
+  TypeSpec generate(String generatedCodePackageName, Set<String> glideExtensionClassNames) {
+    glideOptionsName =
+        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_OPTIONS_SIMPLE_NAME);
+
+    List<MethodAndStaticVar> methodsForExtensions =
+        generateMethodsForExtensions(glideExtensionClassNames);
+
+    Set<MethodSignature> extensionMethodSignatures = ImmutableSet.copyOf(
+        Iterables.transform(methodsForExtensions,
+            new Function<MethodAndStaticVar, MethodSignature>() {
+              @Nullable
+              @Override
+              public MethodSignature apply(MethodAndStaticVar f) {
+                return new MethodSignature(f.method);
+              }
+            }));
+
+    List<MethodAndStaticVar> staticOverrides = generateStaticMethodOverridesForRequestOptions();
+    List<MethodSpec> instanceOverrides = generateInstanceMethodOverridesForRequestOptions();
+
+    List<MethodAndStaticVar> allMethodsAndStaticVars = new ArrayList<>();
+    for (MethodAndStaticVar item : staticOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(item.method))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(item);
+    }
+    for (MethodSpec methodSpec : instanceOverrides) {
+      if (extensionMethodSignatures.contains(new MethodSignature(methodSpec))) {
+        continue;
+      }
+      allMethodsAndStaticVars.add(new MethodAndStaticVar(methodSpec));
+    }
+    allMethodsAndStaticVars.addAll(methodsForExtensions);
+
+    TypeSpec.Builder classBuilder = TypeSpec.classBuilder(GENERATED_REQUEST_OPTIONS_SIMPLE_NAME)
+        .addAnnotation(
+            AnnotationSpec.builder(SuppressWarnings.class)
+                .addMember("value", "$S", "deprecation")
+                .build())
+        .addJavadoc(generateClassJavadoc(glideExtensionClassNames))
+        .addModifiers(Modifier.FINAL)
+        .addModifiers(Modifier.PUBLIC)
+        .superclass(requestOptionsName);
+
+    for (MethodAndStaticVar methodAndStaticVar : allMethodsAndStaticVars) {
+      if (methodAndStaticVar.method != null) {
+        classBuilder.addMethod(methodAndStaticVar.method);
+      }
+      if (methodAndStaticVar.staticField != null) {
+        classBuilder.addField(methodAndStaticVar.staticField);
+      }
+    }
+    return classBuilder.build();
+  }
+
+  private CodeBlock generateClassJavadoc(Set<String> glideExtensionClassNames) {
+    Builder builder = CodeBlock.builder()
+        .add("Automatically generated from {@link $T} annotated classes.\n",
+            GlideExtension.class)
+        .add("\n")
+        .add("@see $T\n", requestOptionsName);
+
+    for (String glideExtensionClass : glideExtensionClassNames) {
+      builder.add("@see $T\n", ClassName.bestGuess(glideExtensionClass));
+    }
+    return builder.build();
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForExtensions(
+      Set<String> glideExtensionClassNames) {
+    List<ExecutableElement> requestOptionExtensionMethods =
+        processorUtil.findAnnotatedElementsInClasses(
+            glideExtensionClassNames, GlideOption.class);
+
+    List<MethodAndStaticVar> result = new ArrayList<>(requestOptionExtensionMethods.size());
+    for (ExecutableElement requestOptionsExtensionMethod : requestOptionExtensionMethods) {
+      result.addAll(generateMethodsForRequestOptionsExtension(requestOptionsExtensionMethod));
+    }
+
+    return result;
+  }
+
+  private List<MethodSpec> generateInstanceMethodOverridesForRequestOptions() {
+    return Lists.transform(
+        processorUtil.findInstanceMethodsReturning(requestOptionsType, requestOptionsType),
+        new Function<ExecutableElement, MethodSpec>() {
+          @Override
+          public MethodSpec apply(ExecutableElement input) {
+            return generateRequestOptionOverride(input);
+          }
+        });
+  }
+
+  private MethodSpec generateRequestOptionOverride(ExecutableElement methodToOverride) {
+    return MethodSpec.overriding(methodToOverride)
+        .returns(glideOptionsName)
+        .addCode(CodeBlock.builder()
+            .add("return ($T) super.$N(", glideOptionsName, methodToOverride.getSimpleName())
+            .add(FluentIterable.from(methodToOverride.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(", ")))
+            .add(");\n")
+            .build())
+        .build();
+  }
+
+  private List<MethodAndStaticVar> generateMethodsForRequestOptionsExtension(
+      ExecutableElement element) {
+    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);
+    int overrideType = getOverrideType(element);
+    if (isOverridingRequestOptionsMethod && overrideType == OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Accidentally attempting to override a method in"
+          + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
+          + " if this is intentional. Offending method: "
+          + element.getEnclosingElement() + "#" + element);
+    } else if (!isOverridingRequestOptionsMethod && overrideType != OVERRIDE_NONE) {
+      throw new IllegalArgumentException("Requested to override an existing method in"
+          + " RequestOptions, but no such method was found. Offending method: "
+          + element.getEnclosingElement() + "#" + element);
+    }
+    String methodName = element.getSimpleName().toString();
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addModifiers(Modifier.PUBLIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+        .returns(glideOptionsName);
+
+    // The 0th element is expected to be a RequestOptions object.
+    List<? extends VariableElement> parameters =
+        element.getParameters().subList(1, element.getParameters().size());
+
+    // Add the correct super() call.
+    if (overrideType == OVERRIDE_EXTEND) {
+      String callSuper = "super.$L(";
+      List<Object> args = new ArrayList<>();
+      args.add(element.getSimpleName().toString());
+      if (!parameters.isEmpty()) {
+        for (VariableElement variable : parameters) {
+          callSuper += "$L, ";
+          args.add(variable.getSimpleName().toString());
+        }
+        callSuper = callSuper.substring(0, callSuper.length() - 2);
+      }
+      callSuper += ")";
+
+      builder.addStatement(callSuper, args.toArray(new Object[0]))
+          .addJavadoc(processorUtil.generateSeeMethodJavadoc(
+              requestOptionsName, methodName, parameters))
+          .addAnnotation(Override.class);
+    }
+
+    for (VariableElement variable : parameters) {
+      builder.addParameter(getParameterSpec(variable));
+    }
+
+    // Adds: <AnnotatedClass>.<thisMethodName>(RequestOptions<?>, <arg1>, <arg2>, <argN>);
+    List<Object> args = new ArrayList<>();
+    String code = "$T.$L($L, ";
+    args.add(ClassName.get(element.getEnclosingElement().asType()));
+    args.add(element.getSimpleName().toString());
+    args.add("this");
+    if (!parameters.isEmpty()) {
+      for (VariableElement variable : parameters) {
+        code += "$L, ";
+        args.add(variable.getSimpleName().toString());
+      }
+    }
+    code = code.substring(0, code.length() - 2);
+    code += ")";
+    builder.addStatement(code, args.toArray(new Object[0]));
+
+    builder.addStatement("return this");
+
+    List<MethodAndStaticVar> result = new ArrayList<>();
+
+    result.add(new MethodAndStaticVar(builder.build()));
+    result.add(generateStaticMethodEquivalentForExtensionMethod(element));
+
+    return result;
+  }
+
+  private List<MethodAndStaticVar> generateStaticMethodOverridesForRequestOptions() {
+    List<ExecutableElement> staticMethodsThatReturnRequestOptions =
+        processorUtil.findStaticMethodsReturning(requestOptionsType, requestOptionsType);
+    List<MethodAndStaticVar> staticMethods = new ArrayList<>();
+    for (ExecutableElement element : staticMethodsThatReturnRequestOptions) {
+      if (element.getAnnotation(Deprecated.class) != null) {
+        continue;
+      }
+      staticMethods.add(generateStaticMethodEquivalentForRequestOptionsStaticMethod(element));
+    }
+    return staticMethods;
+  }
+
+  /**
+   * This method is a bit of a hack, but it lets us tie the static version of a method with the
+   * instance version. In turn that lets us call the instance versions on the generated subclass,
+   * instead of just delegating to the RequestOptions static methods. Using the instance methods
+   * on the generated subclass allows our static methods to properly call code that overrides
+   * an existing method in RequestOptions.
+   *
+   * <p>The string names here just map between the static methods in
+   * {@link com.bumptech.glide.request.RequestOptions} and the instance methods they call.
+   */
+  private static String getInstanceMethodNameFromStaticMethodName(String staticMethodName) {
+    String equivalentInstanceMethodName;
+    if ("bitmapTransform".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "transform";
+    } else if ("decodeTypeOf".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "decode";
+    } else if (staticMethodName.endsWith("Transform")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 9);
+    } else if (staticMethodName.endsWith("Of")) {
+      equivalentInstanceMethodName = staticMethodName.substring(0, staticMethodName.length() - 2);
+    } else if ("noTransformation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontTransform";
+    } else if ("noAnimation".equals(staticMethodName)) {
+      equivalentInstanceMethodName = "dontAnimate";
+    } else if (staticMethodName.equals("option")) {
+      equivalentInstanceMethodName = "set";
+    } else {
+      throw new IllegalArgumentException("Unrecognized static method name: " + staticMethodName);
+    }
+    return equivalentInstanceMethodName;
+  }
+
+  private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStaticMethod(
+      ExecutableElement staticMethod) {
+    boolean memoize = memoizeStaticMethodFromArguments(staticMethod);
+    String staticMethodName = staticMethod.getSimpleName().toString();
+
+    String equivalentInstanceMethodName =
+        getInstanceMethodNameFromStaticMethodName(staticMethodName);
+
+    MethodSpec.Builder methodSpecBuilder =
+        MethodSpec.methodBuilder(staticMethodName)
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(staticMethod))
+        .returns(glideOptionsName);
+
+    List<? extends VariableElement> parameters = staticMethod.getParameters();
+    String createNewOptionAndCall = "new $T().$N(";
+    if (!parameters.isEmpty()) {
+      for (VariableElement parameter : parameters) {
+        methodSpecBuilder.addParameter(getParameterSpec(parameter));
+        createNewOptionAndCall += parameter.getSimpleName().toString();
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall += ".getApplicationContext()";
+        }
+        createNewOptionAndCall += ", ";
+      }
+      createNewOptionAndCall =
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
+    }
+    createNewOptionAndCall += ")";
+
+    FieldSpec requiredStaticField = null;
+    if (memoize) {
+      // Generates code that looks like:
+      // if (GlideOptions.<methodName> == null) {
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
+      // }
+
+      // Mix in an incrementing unique id to handle method overloading.
+      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
+          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+          .build();
+      methodSpecBuilder.beginControlFlow(
+          "if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName, staticVariableName, glideOptionsName, equivalentInstanceMethodName,
+              "autoClone()")
+          .endControlFlow()
+          .addStatement("return $T.$N", glideOptionsName, staticVariableName);
+    } else {
+      // Generates code that looks like:
+      // return new GlideOptions().<methodName>()
+      methodSpecBuilder.addStatement(
+          "return " + createNewOptionAndCall, glideOptionsName, equivalentInstanceMethodName);
+    }
+
+    List<? extends TypeParameterElement> typeParameters = staticMethod.getTypeParameters();
+    for (TypeParameterElement typeParameterElement : typeParameters) {
+      methodSpecBuilder.addTypeVariable(
+          TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
+    }
+
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
+  }
+
+  private static boolean memoizeStaticMethodFromArguments(ExecutableElement staticMethod) {
+    return staticMethod.getParameters().isEmpty()
+        || (staticMethod.getParameters().size() == 1
+        && staticMethod.getParameters().get(0).getSimpleName().toString()
+        .equals("android.content.Context"));
+  }
+
+  private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
+      ExecutableElement instanceMethod) {
+    boolean skipStaticMethod = skipStaticMethod(instanceMethod);
+    if (skipStaticMethod) {
+      return new MethodAndStaticVar();
+    }
+    String staticMethodName = getStaticMethodName(instanceMethod);
+    String instanceMethodName = instanceMethod.getSimpleName().toString();
+    if (Strings.isNullOrEmpty(staticMethodName)) {
+      if (instanceMethodName.startsWith("dont")) {
+        staticMethodName = "no" + instanceMethodName.replace("dont", "");
+      } else {
+        staticMethodName = instanceMethodName + "Of";
+      }
+    }
+    boolean memoize = memoizeStaticMethodFromAnnotation(instanceMethod);
+
+    MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+        .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
+        .returns(glideOptionsName);
+
+    List<? extends VariableElement> parameters = instanceMethod.getParameters();
+
+    // Always remove the first parameter because it's always RequestOptions in extensions. The
+    // actual method we want to generate will pass the RequestOptions in to the extension method,
+    // but should not itself require a RequestOptions object to be passed in.
+    if (parameters.isEmpty()) {
+      throw new IllegalArgumentException(
+          "Expected non-empty parameters for: " + instanceMethod);
+    }
+    // Remove is not supported.
+    parameters = parameters.subList(1, parameters.size());
+
+    String createNewOptionAndCall = "new $T().$L(";
+    if (!parameters.isEmpty()) {
+      for (VariableElement parameter : parameters) {
+        methodSpecBuilder.addParameter(getParameterSpec(parameter));
+        createNewOptionAndCall += parameter.getSimpleName().toString();
+        // use the Application Context to avoid memory leaks.
+        if (memoize && isAndroidContext(parameter)) {
+          createNewOptionAndCall += ".getApplicationContext()";
+        }
+        createNewOptionAndCall += ", ";
+      }
+      createNewOptionAndCall =
+          createNewOptionAndCall.substring(0, createNewOptionAndCall.length() - 2);
+    }
+    createNewOptionAndCall += ")";
+
+    FieldSpec requiredStaticField = null;
+    if (memoize) {
+      // if (GlideOptions.<methodName> == null) {
+      //   GlideOptions.<methodName> = new GlideOptions().<methodName>().autoClone()
+      // }
+
+      // Mix in an incrementing unique id to handle method overloading.
+      String staticVariableName = staticMethodName + nextStaticFieldUniqueId++;
+      requiredStaticField = FieldSpec.builder(glideOptionsName, staticVariableName)
+          .addModifiers(Modifier.PRIVATE, Modifier.STATIC)
+          .build();
+      methodSpecBuilder.beginControlFlow(
+          "if ($T.$N == null)", glideOptionsName, staticVariableName)
+          .addStatement("$T.$N =\n" + createNewOptionAndCall + ".$N",
+              glideOptionsName, staticVariableName, glideOptionsName, instanceMethodName,
+              "autoClone()")
+          .endControlFlow()
+          .addStatement("return $T.$N", glideOptionsName, staticVariableName);
+    } else {
+      // return new GlideOptions().<methodName>()
+      methodSpecBuilder.addStatement(
+          "return " + createNewOptionAndCall, glideOptionsName, instanceMethodName);
+    }
+
+    List<? extends TypeParameterElement> typeParameters = instanceMethod.getTypeParameters();
+    for (TypeParameterElement typeParameterElement : typeParameters) {
+      methodSpecBuilder.addTypeVariable(
+          TypeVariableName.get(typeParameterElement.getSimpleName().toString()));
+    }
+
+    return new MethodAndStaticVar(methodSpecBuilder.build(), requiredStaticField);
+  }
+
+  private boolean isAndroidContext(VariableElement variableElement) {
+    Element element = processingEnvironment.getTypeUtils().asElement(variableElement.asType());
+    return element.toString().equals("android.content.Context");
+  }
+
+  private boolean isMethodInRequestOptions(ExecutableElement toFind) {
+    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type.
+    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that
+    // first type.
+    List<String> toFindParameterNames = getComparableParameterNames(toFind, true /*skipFirst*/);
+    String toFindSimpleName = toFind.getSimpleName().toString();
+    for (Element element : requestOptionsType.getEnclosedElements()) {
+      if (element.getKind() != ElementKind.METHOD) {
+        continue;
+      }
+      ExecutableElement inBase = (ExecutableElement) element;
+      if (toFindSimpleName.equals(inBase.getSimpleName().toString())) {
+        List<String> parameterNamesInBase =
+            getComparableParameterNames(inBase, false /*skipFirst*/);
+        if (parameterNamesInBase.equals(toFindParameterNames)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private static ParameterSpec getParameterSpec(VariableElement variable) {
+    return ParameterSpec.builder(
+        TypeName.get(variable.asType()), variable.getSimpleName().toString()).build();
+  }
+
+  private static List<String> getComparableParameterNames(
+      ExecutableElement element, boolean skipFirst) {
+    List<? extends VariableElement> parameters = element.getParameters();
+    if (skipFirst) {
+      parameters = parameters.subList(1, parameters.size());
+    }
+    List<String> result = new ArrayList<>(parameters.size());
+    for (VariableElement parameter : parameters) {
+      result.add(parameter.asType().toString());
+    }
+    return result;
+  }
+
+  private static int getOverrideType(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption.override();
+  }
+
+  @Nullable
+  private static String getStaticMethodName(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    String result = glideOption != null ? glideOption.staticMethodName() : null;
+    return Strings.emptyToNull(result);
+  }
+
+  private static boolean memoizeStaticMethodFromAnnotation(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption != null && glideOption.memoizeStaticMethod();
+  }
+
+  private static boolean skipStaticMethod(ExecutableElement element) {
+    GlideOption glideOption =
+        element.getAnnotation(GlideOption.class);
+    return glideOption != null && glideOption.skipStaticMethod();
+  }
+
+  private static final class MethodAndStaticVar {
+    @Nullable
+    final MethodSpec method;
+    @Nullable
+    final FieldSpec staticField;
+
+    MethodAndStaticVar() {
+      this(null /*method*/);
+    }
+
+    MethodAndStaticVar(@Nullable MethodSpec method) {
+      this(method, null /*staticField*/);
+    }
+
+    MethodAndStaticVar(@Nullable MethodSpec method, @Nullable FieldSpec staticField) {
+      this.method = method;
+      this.staticField = staticField;
+    }
+  }
+
+  private static final class MethodSignature {
+    private final TypeName returnType;
+    private final List<TypeName> parameterTypes;
+    private final Set<Modifier> modifiers;
+    private final String name;
+
+    MethodSignature(MethodSpec spec) {
+      name = spec.name;
+      modifiers = spec.modifiers;
+      returnType = spec.returnType;
+      parameterTypes =
+          Lists.transform(spec.parameters, new Function<ParameterSpec, TypeName>() {
+            @Nullable
+            @Override
+            public TypeName apply(ParameterSpec parameterSpec) {
+              return parameterSpec.type;
+
+            }
+          });
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof MethodSignature) {
+        MethodSignature other = (MethodSignature) o;
+        return name.equals(other.name)
+            && returnType.equals(other.returnType)
+            && parameterTypes.equals(other.parameterTypes)
+            && modifiers.equals(other.modifiers);
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hashCode(name, returnType, parameterTypes, modifiers);
+    }
+  }
+}
diff --git a/annotation/gradle.properties b/annotation/gradle.properties
new file mode 100644
index 000000000..ab55616cf
--- /dev/null
+++ b/annotation/gradle.properties
@@ -0,0 +1,4 @@
+POM_NAME=Glide Annotations
+POM_ARTIFACT_ID=annotations
+POM_PACKAGING=jar
+POM_DESCRIPTION=A set of annotations for configuring Glide.
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
new file mode 100644
index 000000000..0a15f5a0d
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/Excludes.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Specifies a set of GlideModule and/or LibraryGlideModule classes that should be excluded
+ * from an application.
+ *
+ * <p>Used only on AppGlideModules. Adding this annotation to other classes will have no affect.
+ *
+ * <p>Cannot be used to exclude AppGlideModules (there must be at most one per Application anyway).
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Excludes {
+  Class[] value();
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
new file mode 100644
index 000000000..bb525c849
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideExtension.java
@@ -0,0 +1,15 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicate a class that extends Glide's public API.
+ *
+ * @see GlideOption
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.SOURCE)
+public @interface GlideExtension { }
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
new file mode 100644
index 000000000..690b8f727
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideModule.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies AppGlideModules and ChildeGlideModules for Glide's annotation processor to merge at
+ * compile time.
+ *
+ * <p>Replaces <meta-data /> tags in AndroidManifest.xml.
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.SOURCE)
+public @interface GlideModule {
+  /**
+   * Returns the name of the class that will be used as a replacement for
+   * {@link com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.
+   */
+  String glideName() default "GlideApp";
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
new file mode 100644
index 000000000..50bfbecb0
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java
@@ -0,0 +1,83 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies methods in {@link GlideExtension} annotated classes that extend
+ * {@link com.bumptech.glide.request.RequestOptions}.
+ *
+ * <p>All annotated methods will be added to a single
+ * {@link com.bumptech.glide.request.RequestOptions} implementation generated per application.
+ * Overlapping method names in different extensions may cause errors at compile time.
+ *
+ * <p>Static equivalents of annotated methods will also be generated.
+ *
+ * <p>Methods with this annotation will only be found if they belong to classes annotated with
+ * {@link GlideExtension}.
+ */
+@Target(ElementType.METHOD)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+public @interface GlideOption {
+   /** Does not intend to override a method in a super class. */
+  int OVERRIDE_NONE = 0;
+  /** Expects to call super and then add additional functionality to an overridden method. */
+  int OVERRIDE_EXTEND = 1;
+  /** Expects to not call super and replace an overridden method. */
+  int OVERRIDE_REPLACE = 2;
+
+  /**
+   * Determines how and whether a generated method should extend a method from it's parent.
+   *
+   * <p>Must be one of {@link #OVERRIDE_NONE}, {@link #OVERRIDE_EXTEND}, {@link #OVERRIDE_REPLACE}.
+   *
+   * <p>The extended method is determined by String and argument matching against methods in the
+   * extended class. If {@link #OVERRIDE_NONE} is used and the method and arguments match a method
+   * in the extended class, a compile time error will result. Similarly if any other override type
+   * is used and no method/arguments in the extended class match, a compile time error will result.
+   */
+  int override() default OVERRIDE_NONE;
+
+  /**
+   * Sets the name for the generated static version of this method.
+   *
+   * <p>If this value is not set, the static method name is just the original method name with "Of"
+   * appended.
+   */
+  String staticMethodName() default "";
+
+  /**
+   * {@code true} to indicate that it's safe to statically memoize the result of this method using
+   * {@link com.bumptech.glide.request.RequestOptions#autoClone()}.
+   *
+   * <p>This method should only be used for no-arg methods where there's only a single possible
+   * value.
+   *
+   * <p>Memoization can save object allocations for frequently used options.
+   */
+  boolean memoizeStaticMethod() default false;
+
+  /**
+   * {@code true} to prevent a static builder method from being generated.
+   *
+   * <p>By default static methods are generated for all methods annotated with
+   * {@link GlideOption}. These static factory methods allow for a cleaner API when used
+   * with {@link com.bumptech.glide.RequestBuilder#apply}. The static factory method by default
+   * simply creates a new {@link com.bumptech.glide.request.RequestOptions} object, calls the
+   * instance version of the method on it and returns it. For example:
+   * <pre>
+   * <code>
+   * public static GlideOptions noAnimation() {
+   *   return new GlideOptions().dontAnimate();
+   * }
+   * </code>
+   * </pre>
+   *
+   * @see #memoizeStaticMethod()
+   * @see #staticMethodName()
+   */
+  boolean skipStaticMethod() default false;
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
new file mode 100644
index 000000000..f0c19a599
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideType.java
@@ -0,0 +1,39 @@
+package com.bumptech.glide.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Identifies methods in {@link GlideExtension} annotated classes that extend
+ * {@link com.bumptech.glide.RequestManager}.
+ *
+ * <p>If one or more method is found with this annotation, an additional API entry point that
+ * exposes a generated {@link com.bumptech.glide.RequestManager} subclass will be created. The
+ * generated API entry point acts as a drop in replacement for Glide. Glide.with(fragment) becomes
+ * GlideApp.with(fragment). Although the Glide.with variant will still be available, only the new
+ * API entry point will provide access to these additional methods.
+ *
+ * <p>The name of the API entry point created when one of these methods is found can be controlled
+ * by {@link GlideModule#glideName()}.
+ *
+ * <p>Methods with this annotation will only be found if they are contained in a class annotated
+ * with {@link GlideExtension}.
+ *
+ * <p>Methods annotated with GlideType must have a single parameter. The type of the
+ * single parameter must be {@link com.bumptech.glide.request.RequestOptions}, with a type
+ * matching the value of {@link #value()}.
+ */
+@Target(ElementType.METHOD)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+public @interface GlideType {
+
+  /**
+   * A Resource class name, like GifDrawable.class, Bitmap.class etc.
+   *
+   * <p>Must match the type of the {@link com.bumptech.glide.request.RequestOptions} parameter.
+   */
+  Class<?> value();
+}
diff --git a/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
new file mode 100644
index 000000000..81ba54ae1
--- /dev/null
+++ b/annotation/src/main/java/com/bumptech/glide/annotation/compiler/Index.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.annotation.compiler;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used to retrieve LibraryGlideModule and GlideExtension classes in our annotation processor from
+ * libraries and applications.
+ *
+ * <p>Part of the internals of Glide's annotation processor and not for public use.
+ */
+@Target(ElementType.TYPE)
+// Needs to be parsed from class files in JAR.
+@Retention(RetentionPolicy.CLASS)
+@interface Index {
+  String[] modules() default {};
+  String[] extensions() default {};
+}
diff --git a/build.gradle b/build.gradle
index 878aab49f..de9f3c9d1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -67,6 +67,11 @@ subprojects { project ->
             options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
         }
     }
+
+    // We generate a combined javadoc, no need to create javadocs for each library independently.
+    if (!project.name.equals('glide')) {
+        tasks.withType(Javadoc).all { enabled = false }
+    }
 }
 
 task wrapper(type: Wrapper) {
diff --git a/glide/build.gradle b/glide/build.gradle
index 698f9c7ed..4e8216ad8 100644
--- a/glide/build.gradle
+++ b/glide/build.gradle
@@ -1,69 +1,142 @@
 apply plugin: 'java'
 
-evaluationDependsOn(':third_party:gif_decoder')
-evaluationDependsOn(':third_party:disklrucache')
-evaluationDependsOn(':library')
+// The paths of Android projects that should be included in the jar and javadoc.
+static def getAndroidPathsForJar() {
+    [':third_party:gif_decoder', ':library']
+}
+
+// The paths of Java projects that should be included in the jar and javadoc.
+static def getJavaPathsForJar() {
+    [':third_party:disklrucache']
+}
+
+// The paths of Android projects that should be included only in Javadoc, not in the jar.
+static def getAndroidPathsForJavadoc() {
+    [
+            ':integration:okhttp',
+            ':integration:okhttp3',
+            ':integration:volley',
+            ':integration:gifencoder'
+    ]
+}
+
+// The paths of Java projects that should be included only in Javadoc, not in the jar.
+static def getJavaPathsForJavadoc() {
+    [':annotation', ':annotation:compiler']
+}
+
+(getAndroidPathsForJavadoc() + getAndroidPathsForJar() +
+        getJavaPathsForJar() + getJavaPathsForJavadoc()).forEach {
+    evaluationDependsOn(it)
+}
+
+def asProjects(paths) {
+    paths.collect { project(it) }
+}
 
 def getAndroidSdkDirectory() {
-  project(':library').android.sdkDirectory
+    project(':library').android.sdkDirectory
 }
 
 def getAndroidCompileSdkVersion() {
-  project(':library').android.compileSdkVersion
+    project(':library').android.compileSdkVersion
+}
+
+def getInternalAndroidProjectsForJar() {
+    asProjects(getAndroidPathsForJar())
 }
 
-def getInternalAndroidProjects() {
-    [':third_party:gif_decoder', ':library'].collect { project(it) }
+def getInternalJavaProjectsForJar() {
+    asProjects(getJavaPathsForJar())
 }
-def getInternalJavaProjects() {
-    [':third_party:disklrucache'].collect { project(it) }
+
+def getInternalAndroidProjectsForJavadoc() {
+    asProjects(getAndroidPathsForJavadoc())
+}
+
+def getInternalJavaProjectsForJavadoc() {
+    asProjects(getJavaPathsForJavadoc())
 }
 
-def getAllInternalProjects() {
-    getInternalAndroidProjects() + getInternalJavaProjects()
+def getReleaseVariantAndroidProjectsForJar() {
+    getAndroidLibraryVariantsForJar('release')
 }
 
-def getReleaseVariantAndroidProjects() {
-    getAndroidLibraryVariants('release')
+def getAndroidLibraryVariantsForJar(variantName) {
+    getAndroidLibraryVariants(getInternalAndroidProjectsForJar(), variantName)
 }
 
-def getAndroidLibraryVariants(variantName) {
-    getInternalAndroidProjects().collect { project ->
+def getAndroidLibraryVariantsForJavadoc(variantName) {
+    getAndroidLibraryVariants(getInternalAndroidProjectsForJavadoc(), variantName)
+}
+
+static def getAndroidLibraryVariants(projects, variantName) {
+    projects.collect { project ->
         project.android.libraryVariants.findAll { type ->
             type.buildType.name.equalsIgnoreCase(variantName)
         }
     }.sum()
 }
 
-def getSourceFilesForVariant(variantName) {
-    getAndroidLibraryVariants(variantName).collect { it.javaCompile.source } +
-            getInternalJavaProjects().collect { it.sourceSets.main.allJava }
+def getSourceFilesForVariantJar(variantName) {
+    getAndroidLibraryVariantsForJar(variantName).collect { it.javaCompile.source } +
+            getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }
+}
+
+def getSourceFilesForVariantJavadoc(variantName) {
+    getAndroidLibraryVariantsForJavadoc(variantName).collect { it.javaCompile.source } +
+            getInternalJavaProjectsForJavadoc().collect { it.sourceSets.main.allJava }
 }
 
 def getAndroidJar() {
     "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar"
 }
 
+def getSupportJar() {
+    "${getAndroidSdkDirectory()}/extras/android/support/v4/android-support-v4.jar"
+}
+
 project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
 
-// Generate javadocs and sources containing batched documentation and sources for all internal projects.
+// Generate javadocs and sources containing batched documentation and sources for all internal
+// projects.
 ['release', 'debug'].each { variantName ->
 
     task("${variantName}SourceJar", type: Jar) {
-      from getSourceFilesForVariant(variantName)
+      from getSourceFilesForVariantJar(variantName)
     }
 
     def javadocTask = task("${variantName}Javadoc", type: Javadoc) {
-        source = getSourceFilesForVariant(variantName)
+        source = getSourceFilesForVariantJar(variantName)
+        source += getSourceFilesForVariantJavadoc(variantName)
 
-        classpath = files(getAndroidLibraryVariants(variantName).collect {
-            files(it.javaCompile.classpath.files, getAndroidJar())
+        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {
+            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
+        })
+        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {
+            files(it.javaCompile.classpath.files, getAndroidJar(), getSupportJar())
         })
-        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }.sum()
+        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {
+            it.sourceSets.main.compileClasspath.files
+        }.flatten())
+        classpathFiles += (getInternalJavaProjectsForJar().collect {
+            it.sourceSets.main.compileClasspath.files
+        }.flatten())
+        // Finds dependencies of Android packages that would otherwise be ignored (Volley in
+        // particular)
+        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {
+            files("${it.projectDir}/build/intermediates/classes/release")
+        }
+        classpath = files(classpathFiles)
 
         options {
             links("http://docs.oracle.com/javase/7/docs/api/")
-            linksOffline("http://d.android.com/reference", "${getAndroidSdkDirectory()}/docs/reference")
+            links("https://square.github.io/okhttp/3.x/okhttp/")
+            links("https://square.github.io/okhttp/2.x/okhttp/")
+            // TODO: Ideally this would point to something hosted by Android.
+            links("http://afzaln.com/volley/")
+            linksOffline("http://d.android.com/reference",
+                    "${getAndroidSdkDirectory()}/docs/reference")
         }
 
         exclude '**/BuildConfig.java'
@@ -76,23 +149,30 @@ project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}"
     clean.dependsOn(cleanJavadocTask)
 
     def javadocJarTask = task("${variantName}JavadocJar", type: Jar) {
-      from javadocTask.destinationDir
+        from javadocTask.destinationDir
     } as Task
     javadocJarTask.dependsOn(javadocTask)
 }
 
 jar {
     from files(
-            getReleaseVariantAndroidProjects().collect { variant ->
+            getReleaseVariantAndroidProjectsForJar().collect { variant ->
                 variant.javaCompile.destinationDir
             }
     )
     exclude "**/R.class"
     exclude "**/BuildConfig.class"
-    from files(getInternalJavaProjects().collect { it.sourceSets.main.output })
+    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output })
+}
+
+def getAllInternalProjectBuildDeps() {
+    getInternalAndroidProjectsForJar() + getInternalJavaProjectsForJar() +
+            getInternalJavaProjectsForJavadoc() + getInternalAndroidProjectsForJavadoc()
 }
 
-getAllInternalProjects().each { project ->
+getAllInternalProjectBuildDeps().each { project ->
+    releaseJavadoc.dependsOn(project.tasks.assemble)
+    debugJavadoc.dependsOn(project.tasks.assemble)
     jar.dependsOn(project.tasks.build)
 }
 
diff --git a/gradle.properties b/gradle.properties
index 6f86b1874..ff2eb93f1 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,7 +1,7 @@
 org.gradle.daemon=true
 org.gradle.configureondemand=true
 
-VERSION_NAME=4.0.0-SNAPSHOT
+VERSION_NAME=4.0.0-RC0
 VERSION_MAJOR=4
 VERSION_MINOR=0
 VERSION_PATCH=0
@@ -15,26 +15,25 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
-SUPPORT_V4_VERSION=24.2.0
-SUPPORT_V7_VERSION=24.2.0
+SUPPORT_V4_VERSION=25.3.1
+SUPPORT_V7_VERSION=25.3.1
 VOLLEY_VERSION=1.0.0
 OK_HTTP_VERSION=3.0.1
-# TODO: use this in library/build.gradle.
-ANDROID_GRADLE_VERSION=2.1.3
+ANDROID_GRADLE_VERSION=2.3.0
 
 COVERALLS_GRADLE_VERSION=2.4.0
 JUNIT_VERSION=4.12
 MOCKITO_VERSION=1.10.19
-ROBOLECTRIC_VERSION=3.1.2
+ROBOLECTRIC_VERSION=3.3.2
 MOCKWEBSERVER_VERSION=3.0.0-RC1
 TRUTH_VERSION=0.26
 
 FINDBUGS_VERSION=3.0.0
 JACOCO_VERSION=0.7.1.201405082137
 
-COMPILE_SDK_VERSION=24
-BUILD_TOOLS_VERSION=24.0.2
-TARGET_SDK_VERSION=24
-MIN_SDK_VERSION=10
+COMPILE_SDK_VERSION=25
+BUILD_TOOLS_VERSION=25.0.2
+TARGET_SDK_VERSION=25
+MIN_SDK_VERSION=14
 
-org.gradle.jvmargs=-Xmx2048M
\ No newline at end of file
+org.gradle.jvmargs=-Xmx2048M
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 4564509f7..06cc66097 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Nov 25 12:48:39 CET 2015
+#Fri Mar 31 22:27:21 PDT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/integration/gifencoder/gradle.properties b/integration/gifencoder/gradle.properties
index 9687ee227..1ceaa1dac 100644
--- a/integration/gifencoder/gradle.properties
+++ b/integration/gifencoder/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide GifEncoder Integration
 POM_ARTIFACT_ID=gifencoder-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library allowing users to re-encode or create animated GIFs
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index 4f4fb58b2..9051d5f12 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.integration.gifencoder;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.util.Log;
 import com.bumptech.glide.gifdecoder.GifDecoder;
@@ -58,15 +59,17 @@ public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest)
   private static final Factory FACTORY = new Factory();
   private static final String TAG = "GifEncoder";
   private final GifDecoder.BitmapProvider provider;
+  private Context context;
   private final BitmapPool bitmapPool;
   private final Factory factory;
 
-  public ReEncodingGifResourceEncoder(BitmapPool bitmapPool) {
-    this(bitmapPool, FACTORY);
+  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {
+    this(context, bitmapPool, FACTORY);
   }
 
   // Visible for testing.
-  ReEncodingGifResourceEncoder(BitmapPool bitmapPool, Factory factory) {
+  ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {
+    this.context = context;
     this.bitmapPool = bitmapPool;
     provider = new GifBitmapProvider(bitmapPool);
     this.factory = factory;
@@ -179,8 +182,9 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
       Transformation<Bitmap> transformation, GifDrawable drawable) {
     // TODO: what if current frame is null?
     Resource<Bitmap> bitmapResource = factory.buildFrameResource(currentFrame, bitmapPool);
-    Resource<Bitmap> transformedResource = transformation
-        .transform(bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
+    Resource<Bitmap> transformedResource =
+        transformation.transform(
+            context, bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
     if (!bitmapResource.equals(transformedResource)) {
       bitmapResource.recycle();
     }
diff --git a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
index 27e7be7c6..dde1d0243 100644
--- a/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java
@@ -13,6 +13,8 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
+import android.content.Context;
 import android.graphics.Bitmap;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
@@ -65,6 +67,8 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
+    Application context = RuntimeEnvironment.application;
+
     ReEncodingGifResourceEncoder.Factory factory = mock(ReEncodingGifResourceEncoder.Factory.class);
     when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);
     when(factory.buildParser()).thenReturn(parser);
@@ -73,7 +77,7 @@ public void setUp() {
         .thenReturn(frameResource);
 
     // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!)
-    when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), any(Resource.class), anyInt(), anyInt()))
         .thenReturn(frameResource);
 
     when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
@@ -81,11 +85,11 @@ public void setUp() {
 
     when(resource.get()).thenReturn(gifDrawable);
 
-    encoder = new ReEncodingGifResourceEncoder(mock(BitmapPool.class), factory);
+    encoder = new ReEncodingGifResourceEncoder(context, mock(BitmapPool.class), factory);
     options = new Options();
     options.set(ReEncodingGifResourceEncoder.ENCODE_TRANSFORMATION, true);
 
-    file = new File(RuntimeEnvironment.application.getCacheDir(), "test");
+    file = new File(context.getCacheDir(), "test");
   }
 
   @After
@@ -245,7 +249,8 @@ public void testWritesTransformedBitmaps() {
 
     Bitmap transformedFrame = Bitmap.createBitmap(200, 200, Bitmap.Config.RGB_565);
     when(transformedResource.get()).thenReturn(transformedFrame);
-    when(frameTransformation.transform(eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
+    when(frameTransformation.transform(
+        anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight)))
         .thenReturn(transformedResource);
     when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);
 
@@ -257,7 +262,7 @@ public void testWritesTransformedBitmaps() {
   @Test
   public void testRecyclesFrameResourceBeforeWritingIfTransformedResourceIsDifferent() {
     when(decoder.getFrameCount()).thenReturn(1);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(transformedResource);
     Bitmap expected = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);
     when(transformedResource.get()).thenReturn(expected);
@@ -276,7 +281,7 @@ public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDi
     when(decoder.getFrameCount()).thenReturn(1);
     Bitmap expected = Bitmap.createBitmap(100, 200, Bitmap.Config.RGB_565);
     when(transformedResource.get()).thenReturn(expected);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(transformedResource);
 
     when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);
@@ -291,7 +296,7 @@ public void testRecyclesTransformedResourceAfterWritingIfTransformedResourceIsDi
   @Test
   public void testRecyclesFrameResourceAfterWritingIfFrameResourceIsNotTransformed() {
     when(decoder.getFrameCount()).thenReturn(1);
-    when(frameTransformation.transform(eq(frameResource), anyInt(), anyInt()))
+    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt()))
         .thenReturn(frameResource);
     Bitmap expected = Bitmap.createBitmap(200, 100, Bitmap.Config.ARGB_8888);
     when(frameResource.get()).thenReturn(expected);
@@ -330,4 +335,8 @@ private String getEncodedData() {
       throw new RuntimeException(e);
     }
   }
+
+  private static Context anyContext() {
+    return any(Context.class);
+  }
 }
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index 2a48a7443..c01164e2e 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -2,6 +2,7 @@ apply plugin: 'com.android.library'
 
 dependencies {
     compile project(':library')
+    annotationProcessor project(':annotation:compiler')
 
     compile "com.squareup.okhttp:okhttp:2.7.1"
 }
diff --git a/integration/okhttp/gradle.properties b/integration/okhttp/gradle.properties
index 990db7764..e725ea973 100644
--- a/integration/okhttp/gradle.properties
+++ b/integration/okhttp/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide OkHttp Integration
 POM_ARTIFACT_ID=okhttp-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide
diff --git a/integration/okhttp/src/main/AndroidManifest.xml b/integration/okhttp/src/main/AndroidManifest.xml
index c11d7167d..738e5c900 100644
--- a/integration/okhttp/src/main/AndroidManifest.xml
+++ b/integration/okhttp/src/main/AndroidManifest.xml
@@ -1,9 +1,5 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.bumptech.glide.integration.okhttp">
 
-    <application>
-        <meta-data
-            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule"
-            android:value="GlideModule"/>
-    </application>
+    <application />
 </manifest>
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
new file mode 100644
index 000000000..5a46639f9
--- /dev/null
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.integration.okhttp;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * Registers OkHttp related classes via Glide's annotation processor.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public class OkHttpLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
index aca220c91..2b1f90a78 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java
@@ -36,7 +36,6 @@ public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
   @Override
   public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
     Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
-    boolean isUserAgentSet = false;
     for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
       String key = headerEntry.getKey();
       requestBuilder.addHeader(key, headerEntry.getValue());
@@ -56,7 +55,7 @@ public void onFailure(Request request, IOException e) {
       public void onResponse(Response response) throws IOException {
         responseBody = response.body();
         if (response.isSuccessful()) {
-          long contentLength = response.body().contentLength();
+          long contentLength = responseBody.contentLength();
           stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
         } else if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
diff --git a/integration/okhttp3/build.gradle b/integration/okhttp3/build.gradle
index 6ef7599ff..59a222795 100644
--- a/integration/okhttp3/build.gradle
+++ b/integration/okhttp3/build.gradle
@@ -2,6 +2,7 @@ apply plugin: 'com.android.library'
 
 dependencies {
     compile project(':library')
+    annotationProcessor project(':annotation:compiler')
 
     compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
 }
diff --git a/integration/okhttp3/gradle.properties b/integration/okhttp3/gradle.properties
index 4e8d18972..f241acfb1 100644
--- a/integration/okhttp3/gradle.properties
+++ b/integration/okhttp3/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide OkHttp 3.x Integration
 POM_ARTIFACT_ID=okhttp3-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library to use OkHttp 3.x to fetch data over http/https in Glide
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
index 17799b54f..1c05bf678 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java
@@ -1,12 +1,10 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.content.Context;
-
 import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.module.GlideModule;
-
 import java.io.InputStream;
 
 /**
@@ -17,7 +15,11 @@
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
  * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ *
+ * @deprecated Replaced by {@link OkHttpLibraryGlideModule} for Applications that use Glide's
+ * annotations.
  */
+@Deprecated
 public class OkHttpGlideModule implements GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
new file mode 100644
index 000000000..911b5acac
--- /dev/null
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java
@@ -0,0 +1,24 @@
+package com.bumptech.glide.integration.okhttp3;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * Registers OkHttp related classes via Glide's annotation processor.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
+  }
+}
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
index c08955f7b..61adb97b1 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.integration.okhttp3;
 
 import android.util.Log;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.data.DataFetcher;
@@ -55,7 +54,7 @@ public void onFailure(Call call, IOException e) {
       public void onResponse(Call call, Response response) throws IOException {
         responseBody = response.body();
         if (response.isSuccessful()) {
-          long contentLength = response.body().contentLength();
+          long contentLength = responseBody.contentLength();
           stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
         } else if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());
diff --git a/integration/recyclerview/gradle.properties b/integration/recyclerview/gradle.properties
index 7bf1e8bea..700106ff1 100644
--- a/integration/recyclerview/gradle.properties
+++ b/integration/recyclerview/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide RecyclerView Integration
 POM_ARTIFACT_ID=recyclerview-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library to display images in RecyclerView.
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index caebd67f9..8f04a9b1a 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -3,6 +3,7 @@ apply plugin: 'com.android.library'
 dependencies {
     compile project(':library')
     compile "com.android.volley:volley:${VOLLEY_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
diff --git a/integration/volley/gradle.properties b/integration/volley/gradle.properties
index ff93096bd..198619280 100644
--- a/integration/volley/gradle.properties
+++ b/integration/volley/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide Volley Integration
 POM_ARTIFACT_ID=volley-integration
 POM_PACKAGING=aar
-
-VERSION_NAME=2.0.0-SNAPSHOT
-VERSION_MAJOR=2
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=An integration library to use Volley to fetch data over http/https in Glide
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
index 2a86867c9..669e7b732 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java
@@ -14,8 +14,11 @@
  *
  * <p> If you're using gradle, you can include this module simply by depending on the aar, the
  * module will be merged in by manifest merger. For other build systems or for more more
- * information, see {@link com.bumptech.glide.module.GlideModule}. </p>
+ * information, see {@link com.bumptech.glide.module.GlideModule}.
+ *
+ * @deprecated Replaced with {@link VolleyLibraryGlideModule}.
  */
+@Deprecated
 public class VolleyGlideModule implements GlideModule {
   @Override
   public void applyOptions(Context context, GlideBuilder builder) {
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
new file mode 100644
index 000000000..22f12df4e
--- /dev/null
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java
@@ -0,0 +1,26 @@
+package com.bumptech.glide.integration.volley;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.load.model.GlideUrl;
+import com.bumptech.glide.module.AppGlideModule;
+import com.bumptech.glide.module.LibraryGlideModule;
+import java.io.InputStream;
+
+/**
+ * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default
+ * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with a
+ * Volley based {@link com.bumptech.glide.load.model.ModelLoader}.
+ *
+ * <p>For Applications that depend on this library and include an
+ * {@link AppGlideModule} and Glide's annotation processor, this class
+ * will be automatically included.
+ */
+@GlideModule
+public class VolleyLibraryGlideModule extends LibraryGlideModule {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
+  }
+}
diff --git a/library/build.gradle b/library/build.gradle
index e26156b70..bcef2c2bb 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -18,6 +18,7 @@ coveralls {
 dependencies {
     compile project(':third_party:gif_decoder')
     compile project(':third_party:disklrucache')
+    compile project(':annotation')
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
 
     testCompile project(':testutil')
@@ -140,8 +141,9 @@ afterEvaluate {
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
 // exclude <dependency> tag for android support-v4 library from :glide's pom
 // this will ensure that this warning will not prevent the build from completing:
-// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries but is a jar
-// most users will need to override support-v4 version anyway if a newer version is available
+// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries
+// but is a jar. Most users will need to override support-v4 version anyway if a newer version is
+// available
 // TODO make support-v4 a <scope>runtime</scope> dependency in pom.xml
 afterEvaluate {
     uploadArchives.repositories.mavenDeployer.pom.whenConfigured { p ->
diff --git a/library/lint.xml b/library/lint.xml
index ff7e5955c..869eb6598 100644
--- a/library/lint.xml
+++ b/library/lint.xml
@@ -1,4 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <lint>
     <issue id="AllowBackup" severity="ignore"/>
+    <!-- TODO: Fix this after RequestManager#get(View) uses official APIs -->
+    <issue id="RestrictedApi" severity="ignore"/>
 </lint>
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
index 0432be6d2..078afb542 100644
--- a/library/proguard-rules.txt
+++ b/library/proguard-rules.txt
@@ -1,4 +1,5 @@
 -keep public class * implements com.bumptech.glide.module.GlideModule
+-keep public class * extends com.bumptech.glide.GeneratedAppGlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
     **[] $VALUES;
     public *;
diff --git a/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
new file mode 100644
index 000000000..1c852b961
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java
@@ -0,0 +1,27 @@
+package com.bumptech.glide;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.module.AppGlideModule;
+import java.util.Set;
+
+/**
+ * A temporary interface to allow {@link AppGlideModule}s to exclude
+ * {@link com.bumptech.glide.annotation.GlideModule}s to ease the migration from
+ * {@link com.bumptech.glide.annotation.GlideModule}s to Glide's annotation processing system.
+ */
+@Deprecated
+abstract class GeneratedAppGlideModule extends AppGlideModule {
+  /**
+   * This method can be removed when manifest parsing is no longer supported.
+   */
+  @Deprecated
+  @NonNull
+  abstract Set<Class<?>> getExcludedModuleClasses();
+
+  @Nullable
+  RequestManagerRetriever.RequestManagerFactory getRequestManagerFactory() {
+    return null;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 564283f73..a6ef96c89 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -16,6 +16,7 @@
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
+import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.data.InputStreamRewinder;
@@ -48,6 +49,7 @@
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableEncoder;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
 import com.bumptech.glide.load.resource.bitmap.ByteBufferBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
@@ -68,13 +70,17 @@
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.ImageViewTargetFactory;
 import com.bumptech.glide.request.target.Target;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
 import java.io.File;
 import java.io.InputStream;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
 
 /**
  * A singleton to present a simple static interface for building requests with
@@ -94,6 +100,7 @@
   private final GlideContext glideContext;
   private final Registry registry;
   private final ArrayPool arrayPool;
+  private final RequestManagerRetriever requestManagerRetriever;
   private final ConnectivityMonitorFactory connectivityMonitorFactory;
   private final List<RequestManager> managers = new ArrayList<>();
   private MemoryCategory memoryCategory = MemoryCategory.NORMAL;
@@ -144,17 +151,7 @@ public static Glide get(Context context) {
     if (glide == null) {
       synchronized (Glide.class) {
         if (glide == null) {
-          Context applicationContext = context.getApplicationContext();
-          List<GlideModule> modules = new ManifestParser(applicationContext).parse();
-
-          GlideBuilder builder = new GlideBuilder(applicationContext);
-          for (GlideModule module : modules) {
-            module.applyOptions(applicationContext, builder);
-          }
-          glide = builder.createGlide();
-          for (GlideModule module : modules) {
-            module.registerComponents(applicationContext, glide.registry);
-          }
+          initGlide(context);
         }
       }
     }
@@ -162,11 +159,96 @@ public static Glide get(Context context) {
     return glide;
   }
 
+  @VisibleForTesting
+  public static void init(Glide glide) {
+    Glide.glide = glide;
+  }
+
   @VisibleForTesting
   public static void tearDown() {
     glide = null;
   }
 
+  @SuppressWarnings("deprecation")
+  private static void initGlide(Context context) {
+    Context applicationContext = context.getApplicationContext();
+
+    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
+    List<GlideModule> manifestModules = Collections.emptyList();
+    if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
+      manifestModules = new ManifestParser(applicationContext).parse();
+    }
+
+    if (annotationGeneratedModule != null
+        && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
+      Set<Class<?>> excludedModuleClasses =
+          annotationGeneratedModule.getExcludedModuleClasses();
+      for (Iterator<GlideModule> iterator = manifestModules.iterator(); iterator.hasNext();) {
+        GlideModule current = iterator.next();
+        if (!excludedModuleClasses.contains(current.getClass())) {
+          continue;
+        }
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "AppGlideModule excludes manifest GlideModule: " + current);
+        }
+        iterator.remove();
+      }
+    }
+
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      for (GlideModule glideModule : manifestModules) {
+        Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
+      }
+    }
+
+    RequestManagerRetriever.RequestManagerFactory factory =
+        annotationGeneratedModule != null
+            ? annotationGeneratedModule.getRequestManagerFactory() : null;
+    GlideBuilder builder = new GlideBuilder()
+        .setRequestManagerFactory(factory);
+    for (GlideModule module : manifestModules) {
+      module.applyOptions(applicationContext, builder);
+    }
+    if (annotationGeneratedModule != null) {
+      annotationGeneratedModule.applyOptions(applicationContext, builder);
+    }
+    glide = builder.build(applicationContext);
+    for (GlideModule module : manifestModules) {
+      module.registerComponents(applicationContext, glide.registry);
+    }
+    if (annotationGeneratedModule != null) {
+      annotationGeneratedModule.registerComponents(applicationContext, glide.registry);
+    }
+  }
+
+  @Nullable
+  @SuppressWarnings({"unchecked", "deprecation"})
+  private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
+    GeneratedAppGlideModule result = null;
+    try {
+      Class<GeneratedAppGlideModule> clazz =
+          (Class<GeneratedAppGlideModule>)
+              Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
+      result = clazz.newInstance();
+    } catch (ClassNotFoundException e) {
+      if (Log.isLoggable(TAG, Log.WARN)) {
+        Log.w(TAG, "Failed to find GeneratedAppGlideModule. You should include an"
+            + " annotationProcessor compile dependency on com.github.bumptech.glide:glide:compiler"
+            + " in your application and a @GlideModule annotated AppGlideModule implementation or"
+            + " LibraryGlideModules will be silently ignored");
+      }
+    } catch (InstantiationException e) {
+      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+          + " If you've manually implemented this class, remove your implementation. The Annotation"
+          + " processor will generate a correct implementation.", e);
+    } catch (IllegalAccessException e) {
+      throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly."
+          + " If you've manually implemented this class, remove your implementation. The Annotation"
+          + " processor will generate a correct implementation.", e);
+    }
+    return result;
+  }
+
   @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   Glide(
       Context context,
@@ -174,6 +256,7 @@ public static void tearDown() {
       MemoryCache memoryCache,
       BitmapPool bitmapPool,
       ArrayPool arrayPool,
+      RequestManagerRetriever requestManagerRetriever,
       ConnectivityMonitorFactory connectivityMonitorFactory,
       int logLevel,
       RequestOptions defaultRequestOptions) {
@@ -181,6 +264,7 @@ public static void tearDown() {
     this.bitmapPool = bitmapPool;
     this.arrayPool = arrayPool;
     this.memoryCache = memoryCache;
+    this.requestManagerRetriever = requestManagerRetriever;
     this.connectivityMonitorFactory = connectivityMonitorFactory;
 
     DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
@@ -188,12 +272,15 @@ public static void tearDown() {
 
     final Resources resources = context.getResources();
 
-    Downsampler downsampler =
-        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);
+    registry = new Registry();
+    registry.register(new DefaultImageHeaderParser());
+
+    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
+        resources.getDisplayMetrics(), bitmapPool, arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
-        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);
-    registry = new Registry()
-        .register(ByteBuffer.class, new ByteBufferEncoder())
+        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+
+    registry.register(ByteBuffer.class, new ByteBufferEncoder())
         .register(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
         .append(ByteBuffer.class, Bitmap.class,
@@ -214,7 +301,7 @@ public static void tearDown() {
         .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder()))
         /* GIFs */
         .prepend(InputStream.class, GifDrawable.class,
-            new StreamGifDecoder(byteBufferGifDecoder, arrayPool))
+            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool))
         .prepend(ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder)
         .register(GifDrawable.class, new GifDrawableEncoder())
         /* GIF Frames */
@@ -385,6 +472,14 @@ public void clearDiskCache() {
     engine.clearDiskCache();
   }
 
+
+  /**
+   * Internal method.
+   */
+  public RequestManagerRetriever getRequestManagerRetriever() {
+    return requestManagerRetriever;
+  }
+
   /**
    * Adjusts Glide's current and maximum memory usage based on the given {@link MemoryCategory}.
    *
@@ -408,6 +503,16 @@ public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
     return oldCategory;
   }
 
+  private static RequestManagerRetriever getRetriever(@Nullable Context context) {
+    // Context could be null for other reasons (ie the user passes in null), but in practice it will
+    // only occur due to errors with the Fragment lifecycle.
+    Preconditions.checkNotNull(
+        "You cannot start a load on a not yet attached View or a  Fragment where getActivity() "
+            + "returns null (which usually occurs when getActivity() is called before the Fragment "
+            + "is attached or after the Fragment is destroyed).");
+    return Glide.get(context).getRequestManagerRetriever();
+  }
+
   /**
    * Begin a load with Glide by passing in a context.
    *
@@ -431,8 +536,7 @@ public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
    * @see #with(android.support.v4.app.FragmentActivity)
    */
   public static RequestManager with(Context context) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(context);
+    return getRetriever(context).get(context);
   }
 
   /**
@@ -443,8 +547,7 @@ public static RequestManager with(Context context) {
    * @return A RequestManager for the given activity that can be used to start a load.
    */
   public static RequestManager with(Activity activity) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(activity);
+    return getRetriever(activity).get(activity);
   }
 
   /**
@@ -456,8 +559,7 @@ public static RequestManager with(Activity activity) {
    * @return A RequestManager for the given FragmentActivity that can be used to start a load.
    */
   public static RequestManager with(FragmentActivity activity) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(activity);
+    return getRetriever(activity).get(activity);
   }
 
   /**
@@ -467,10 +569,8 @@ public static RequestManager with(FragmentActivity activity) {
    * @param fragment The fragment to use.
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   public static RequestManager with(android.app.Fragment fragment) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(fragment);
+    return getRetriever(fragment.getActivity()).get(fragment);
   }
 
   /**
@@ -482,8 +582,31 @@ public static RequestManager with(android.app.Fragment fragment) {
    * @return A RequestManager for the given Fragment that can be used to start a load.
    */
   public static RequestManager with(Fragment fragment) {
-    RequestManagerRetriever retriever = RequestManagerRetriever.get();
-    return retriever.get(fragment);
+    return getRetriever(fragment.getActivity()).get(fragment);
+  }
+
+  /**
+   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},
+   * {@link android.app.Fragment}, or {@link Activity} that contains the View.
+   *
+   * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View
+   * is a child of the View returned by the {@link Fragment#getView()}} method.
+   *
+   * <p>This method will not work if the View is not attached. Prefer the Activity and Fragment
+   * variants unless you're loading in a View subclass.
+   *
+   * <p>This method may be inefficient for large hierarchies. Consider memoizing the result after
+   * the View is attached.
+   *
+   * <p>When used in Applications that use the non-support {@link android.app.Fragment} classes,
+   * calling this method will produce noisy logs from {@link android.app.FragmentManager}. Consider
+   * avoiding entirely or using the {@link Fragment}s from the support library instead.
+   *
+   * @param view The view to search for a containing Fragment or Activity from.
+   * @return A RequestManager that can be used to start a load.
+   */
+  public static RequestManager with(View view) {
+    return getRetriever(view.getContext()).get(view);
   }
 
   public Registry getRegistry() {
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 2ebaf8b0f..784aa08b9 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -1,13 +1,12 @@
 package com.bumptech.glide;
 
 import android.content.Context;
-import android.os.Build;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;
 import com.bumptech.glide.load.engine.cache.DiskCache;
@@ -18,14 +17,14 @@
 import com.bumptech.glide.load.engine.executor.GlideExecutor;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;
+import com.bumptech.glide.manager.RequestManagerRetriever;
+import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;
 import com.bumptech.glide.request.RequestOptions;
 
 /**
  * A builder class for setting default structural classes for Glide to use.
  */
 public final class GlideBuilder {
-  private final Context context;
-
   private Engine engine;
   private BitmapPool bitmapPool;
   private ArrayPool arrayPool;
@@ -37,10 +36,8 @@
   private ConnectivityMonitorFactory connectivityMonitorFactory;
   private int logLevel = Log.INFO;
   private RequestOptions defaultRequestOptions = new RequestOptions();
-
-  GlideBuilder(Context context) {
-    this.context = context.getApplicationContext();
-  }
+  @Nullable
+  private RequestManagerFactory requestManagerFactory;
 
   /**
    * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
@@ -149,7 +146,7 @@ public GlideBuilder setDiskCacheExecutor(GlideExecutor service) {
    * Sets the default {@link RequestOptions} to use for all loads across the app.
    *
    * <p>Applying additional options with {@link
-   * RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions)} will override defaults
+   * RequestBuilder#apply(RequestOptions)} will override defaults
    * set here.
    *
    * @param requestOptions The options to use by default.
@@ -254,13 +251,19 @@ public GlideBuilder setLogLevel(int logLevel) {
     return this;
   }
 
+  GlideBuilder setRequestManagerFactory(
+      @Nullable RequestManagerRetriever.RequestManagerFactory factory) {
+    this.requestManagerFactory = factory;
+    return this;
+  }
+
   // For testing.
   GlideBuilder setEngine(Engine engine) {
     this.engine = engine;
     return this;
   }
 
-  Glide createGlide() {
+  public Glide build(Context context) {
     if (sourceExecutor == null) {
       sourceExecutor = GlideExecutor.newSourceExecutor();
     }
@@ -278,12 +281,8 @@ Glide createGlide() {
     }
 
     if (bitmapPool == null) {
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-        int size = memorySizeCalculator.getBitmapPoolSize();
-        bitmapPool = new LruBitmapPool(size);
-      } else {
-        bitmapPool = new BitmapPoolAdapter();
-      }
+      int size = memorySizeCalculator.getBitmapPoolSize();
+      bitmapPool = new LruBitmapPool(size);
     }
 
     if (arrayPool == null) {
@@ -303,12 +302,16 @@ Glide createGlide() {
           GlideExecutor.newUnlimitedSourceExecutor());
     }
 
+    RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(
+        requestManagerFactory);
+
     return new Glide(
         context,
         engine,
         memoryCache,
         bitmapPool,
         arrayPool,
+        requestManagerRetriever,
         connectivityMonitorFactory,
         logLevel,
         defaultRequestOptions.lock());
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index ddaae41d7..9844786b3 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -226,5 +226,10 @@ public void onResourceReady(Object resource, Transition<? super Object> transiti
     public void getSize(SizeReadyCallback cb) {
       cb.onSizeReady(photoWidth, photoHeight);
     }
+
+    @Override
+    public void removeCallback(SizeReadyCallback cb) {
+      // Do nothing because we don't retain references to SizeReadyCallbacks.
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index be6272bbd..7468be5be 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -2,6 +2,7 @@
 
 import android.support.v4.util.Pools.Pool;
 import com.bumptech.glide.load.Encoder;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.ResourceEncoder;
 import com.bumptech.glide.load.data.DataRewinder;
@@ -15,6 +16,7 @@
 import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
 import com.bumptech.glide.load.resource.transcode.TranscoderRegistry;
 import com.bumptech.glide.provider.EncoderRegistry;
+import com.bumptech.glide.provider.ImageHeaderParserRegistry;
 import com.bumptech.glide.provider.LoadPathCache;
 import com.bumptech.glide.provider.ModelToResourceClassCache;
 import com.bumptech.glide.provider.ResourceDecoderRegistry;
@@ -34,6 +36,7 @@
   private final ResourceEncoderRegistry resourceEncoderRegistry;
   private final DataRewinderRegistry dataRewinderRegistry;
   private final TranscoderRegistry transcoderRegistry;
+  private final ImageHeaderParserRegistry imageHeaderParserRegistry;
 
   private final ModelToResourceClassCache modelToResourceClassCache =
       new ModelToResourceClassCache();
@@ -47,6 +50,7 @@ public Registry() {
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
     this.dataRewinderRegistry = new DataRewinderRegistry();
     this.transcoderRegistry = new TranscoderRegistry();
+    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();
   }
 
   public <Data> Registry register(Class<Data> dataClass, Encoder<Data> encoder) {
@@ -83,6 +87,11 @@ public Registry register(DataRewinder.Factory factory) {
     return this;
   }
 
+  public Registry register(ImageHeaderParser parser) {
+    imageHeaderParserRegistry.add(parser);
+    return this;
+  }
+
   /**
    * Use the given factory to build a {@link com.bumptech.glide.load.model.ModelLoader} for models
    * of the given class. Generally the best use of this method is to replace one of the default
@@ -220,6 +229,14 @@ public boolean isResourceEncoderAvailable(Resource<?> resource) {
     return result;
   }
 
+  public List<ImageHeaderParser> getImageHeaderParsers() {
+    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();
+    if (result.isEmpty()) {
+      throw new NoImageHeaderParserException();
+    }
+    return result;
+  }
+
   /**
    * Thrown when no {@link com.bumptech.glide.load.model.ModelLoader} is registered for a given
    * model class.
@@ -260,4 +277,13 @@ public MissingComponentException(String message) {
       super(message);
     }
   }
+
+  /**
+   * Thrown when no {@link ImageHeaderParser} is registered.
+   */
+  public static final class NoImageHeaderParserException extends MissingComponentException {
+    public NoImageHeaderParserException() {
+      super("Failed to find image header parser.");
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index e6bf29b4e..81fea6e36 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -7,7 +7,6 @@
 import android.support.annotation.Nullable;
 import android.widget.ImageView;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestCoordinator;
@@ -35,16 +34,18 @@
 public class RequestBuilder<TranscodeType> implements Cloneable {
   private static final TransitionOptions<?, ?> DEFAULT_ANIMATION_OPTIONS =
       new GenericTransitionOptions<Object>();
-  private static final BaseRequestOptions<?> DOWNLOAD_ONLY_OPTIONS =
+  // Used in generated subclasses
+  protected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
   private final GlideContext context;
   private final RequestManager requestManager;
   private final Class<TranscodeType> transcodeClass;
-  private final BaseRequestOptions<?> defaultRequestOptions;
+  private final RequestOptions defaultRequestOptions;
+  private final Glide glide;
 
-  @NonNull private BaseRequestOptions<?> requestOptions;
+  @NonNull protected RequestOptions requestOptions;
   @SuppressWarnings("unchecked")
   private TransitionOptions<?, ? super TranscodeType> transitionOptions =
       (TransitionOptions<?, ? super TranscodeType>) DEFAULT_ANIMATION_OPTIONS;
@@ -58,38 +59,41 @@
   private boolean isModelSet;
   private boolean isThumbnailBuilt;
 
-  RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
-    this(other.context, other.requestManager, transcodeClass);
-    model = other.model;
-    isModelSet = other.isModelSet;
-    requestOptions = other.requestOptions;
-  }
-
-  RequestBuilder(GlideContext context, RequestManager requestManager,
+  protected RequestBuilder(Glide glide, RequestManager requestManager,
       Class<TranscodeType> transcodeClass) {
+    this.glide = glide;
     this.requestManager = requestManager;
-    this.context = Preconditions.checkNotNull(context);
+    this.context = glide.getGlideContext();
     this.transcodeClass = transcodeClass;
-
     this.defaultRequestOptions = requestManager.getDefaultRequestOptions();
     this.requestOptions = defaultRequestOptions;
   }
 
+  protected RequestBuilder(Class<TranscodeType> transcodeClass, RequestBuilder<?> other) {
+    this(other.glide, other.requestManager, transcodeClass);
+    model = other.model;
+    isModelSet = other.isModelSet;
+    requestOptions = other.requestOptions;
+  }
+
   /**
    * Applies the given options to the request, options set or unset in the given options will
    * replace those previously set in options in this class.
    *
-   * @see BaseRequestOptions#apply(BaseRequestOptions)
+   * @see RequestOptions#apply(RequestOptions)
    * @return This request builder.
    */
-  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
+  public RequestBuilder<TranscodeType> apply(@NonNull RequestOptions requestOptions) {
     Preconditions.checkNotNull(requestOptions);
-    BaseRequestOptions<?> toMutate = defaultRequestOptions == this.requestOptions
-        ? this.requestOptions.clone() : this.requestOptions;
-    this.requestOptions = toMutate.apply(requestOptions);
+    this.requestOptions = getMutableOptions().apply(requestOptions);
     return this;
   }
 
+  protected RequestOptions getMutableOptions() {
+    return defaultRequestOptions == this.requestOptions
+        ? this.requestOptions.clone() : this.requestOptions;
+  }
+
   /**
    * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when
    * this load completes.
@@ -155,8 +159,8 @@
    * <p> Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
    * and {@link com.bumptech.glide.load.Transformation}s. However,
-   * {@link com.bumptech.glide.request.BaseRequestOptions#placeholder(int)} and
-   * {@link com.bumptech.glide.request.BaseRequestOptions#error(int)}, and
+   * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
+   * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
    * {@link #listener(RequestListener)} will only be used on the full size load and will not be
    * copied for the thumbnail load. </p>
    *
@@ -202,11 +206,11 @@
    * <p> Note - this method caches data using only the given String as the cache key. If the data is
    * a Uri outside of your control, or you otherwise expect the data represented by the given String
    * to change without the String identifier changing, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create that identifies the data currently at the given String that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
    * </p>
    *
@@ -225,11 +229,11 @@
    * <p> Note - this method caches data at Uris using only the Uri itself as the cache key. The data
    * represented by Uris from some content providers may change without the Uri changing, which
    * means using this method can lead to displaying stale data. Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)} to
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)} to
    * mixin a signature you create based on the data at the given Uri that will invalidate the cache
    * if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate. </p>
    *
    * @see #load(Object)
@@ -247,11 +251,11 @@
    * <p> Note - this method caches data for Files using only the file path itself as the cache key.
    * The data in the File can change so using this method can lead to displaying stale data. If you
    * expect the data in the File to change, Consider using
-   * {@link com.bumptech.glide.request.BaseRequestOptions#signature(com.bumptech.glide.load.Key)}
+   * {@link com.bumptech.glide.request.RequestOptions#signature(com.bumptech.glide.load.Key)}
    * to mixin a signature you create that identifies the data currently in the File that will
    * invalidate the cache if that data changes. Alternatively, using
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} and/or
-   * {@link com.bumptech.glide.request.BaseRequestOptions#skipMemoryCache(boolean)} may be
+   * {@link com.bumptech.glide.request.RequestOptions#skipMemoryCache(boolean)} may be
    * appropriate.
    * </p>
    *
@@ -275,7 +279,7 @@
    * version code before each install and you replace a Drawable with different data without
    * changing the Drawable name, you may see inconsistent cached data. To get around this, consider
    * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
-   * {@link BaseRequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
+   * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
    * during development, and re-enabling the default
    * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds. </p>
    *
@@ -386,17 +390,21 @@
       }
       switch (view.getScaleType()) {
         case CENTER_CROP:
-          requestOptions.optionalCenterCrop(context);
+          requestOptions.optionalCenterCrop();
           break;
         case CENTER_INSIDE:
-          requestOptions.optionalCenterInside(context);
+          requestOptions.optionalCenterInside();
           break;
         case FIT_CENTER:
         case FIT_START:
         case FIT_END:
-          requestOptions.optionalFitCenter(context);
+          requestOptions.optionalFitCenter();
+          break;
+        case FIT_XY:
+          requestOptions.optionalCenterInside();
           break;
-        //$CASES-OMITTED$
+        case CENTER:
+        case MATRIX:
         default:
           // Do nothing.
       }
@@ -410,11 +418,11 @@
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    * @see RequestManager#clear(Target)
    *
@@ -446,11 +454,11 @@
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    */
   public FutureTarget<TranscodeType> submit(int width, int height) {
@@ -481,11 +489,11 @@ public void run() {
    *
    * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if
    *               previously called.
    * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be
    *               overridden by
-   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if
+   *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if
    *               previously called).
    * @return A {@link Target} that can be used to cancel the load via
    * {@link RequestManager#clear(Target)}.
@@ -541,7 +549,7 @@ public void run() {
     return getDownloadOnlyRequest().submit(width, height);
   }
 
-  private RequestBuilder<File> getDownloadOnlyRequest() {
+  protected RequestBuilder<File> getDownloadOnlyRequest() {
     return new RequestBuilder<>(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);
   }
 
@@ -607,7 +615,7 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
       ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
       Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,
           priority, overrideWidth, overrideHeight);
-      BaseRequestOptions<?> thumbnailOptions = requestOptions.clone()
+      RequestOptions thumbnailOptions = requestOptions.clone()
           .sizeMultiplier(thumbSizeMultiplier);
 
       Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,
@@ -623,7 +631,7 @@ private Request buildRequestRecursive(Target<TranscodeType> target,
   }
 
   private Request obtainRequest(Target<TranscodeType> target,
-      BaseRequestOptions<?> requestOptions, RequestCoordinator requestCoordinator,
+      RequestOptions requestOptions, RequestCoordinator requestCoordinator,
       TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,
       int overrideWidth, int overrideHeight) {
     requestOptions.lock();
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 8c6876c05..3a1ecec2a 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -22,7 +22,6 @@
 import com.bumptech.glide.manager.RequestManagerTreeNode;
 import com.bumptech.glide.manager.RequestTracker;
 import com.bumptech.glide.manager.TargetTracker;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
@@ -51,7 +50,7 @@
       diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
-  private final Glide glide;
+  protected final Glide glide;
   @Synthetic final Lifecycle lifecycle;
   private final RequestTracker requestTracker;
   private final RequestManagerTreeNode treeNode;
@@ -66,14 +65,14 @@ public void run() {
   private final ConnectivityMonitor connectivityMonitor;
 
   @NonNull
-  private BaseRequestOptions<?> defaultRequestOptions;
-  @NonNull
-  private BaseRequestOptions<?> requestOptions;
+  private RequestOptions requestOptions;
 
   public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
     this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory());
   }
 
+  // Our usage is safe here.
+  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
   RequestManager(
       Glide glide,
       Lifecycle lifecycle,
@@ -87,7 +86,6 @@ public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode t
 
     final Context context = glide.getGlideContext().getBaseContext();
 
-
     connectivityMonitor =
         factory.build(context, new RequestManagerConnectivityListener(requestTracker));
 
@@ -102,12 +100,19 @@ public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode t
     }
     lifecycle.addListener(connectivityMonitor);
 
-    defaultRequestOptions = glide.getGlideContext().getDefaultRequestOptions();
-    requestOptions = defaultRequestOptions;
+    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());
 
     glide.registerRequestManager(this);
   }
 
+  protected void setRequestOptions(@NonNull RequestOptions toSet) {
+    this.requestOptions = toSet.clone().autoClone();
+  }
+
+  private void updateRequestOptions(RequestOptions toUpdate) {
+    this.requestOptions.apply(toUpdate);
+  }
+
   /**
    * Updates the default {@link RequestOptions} for all loads started with this request manager
    * with the given {@link RequestOptions}.
@@ -122,14 +127,12 @@ public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode t
    *
    * <p>The modified options will only be applied to loads started after this method is called.
    *
-   * @see RequestBuilder#apply(BaseRequestOptions)
+   * @see RequestBuilder#apply(RequestOptions)
    *
    * @return This request manager.
    */
   public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions) {
-    BaseRequestOptions<?> toMutate = this.requestOptions == defaultRequestOptions
-        ? this.requestOptions.clone() : this.defaultRequestOptions;
-    this.requestOptions = toMutate.apply(requestOptions);
+    updateRequestOptions(requestOptions);
     return this;
   }
 
@@ -151,8 +154,7 @@ public RequestManager applyDefaultRequestOptions(RequestOptions requestOptions)
    * @return This request manager.
    */
   public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
-    this.defaultRequestOptions = requestOptions;
-    this.requestOptions = requestOptions;
+    setRequestOptions(requestOptions);
     return this;
   }
 
@@ -376,7 +378,7 @@ public void onDestroy() {
    * @return A new request builder for loading the given resource class.
    */
   public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(glide.getGlideContext(), this, resourceClass);
+    return new RequestBuilder<>(glide, this, resourceClass);
   }
 
   /**
@@ -446,7 +448,7 @@ void track(Target<?> target, Request request) {
     requestTracker.runRequest(request);
   }
 
-  BaseRequestOptions<?> getDefaultRequestOptions() {
+  RequestOptions getDefaultRequestOptions() {
     return requestOptions;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
new file mode 100644
index 000000000..6cecef3ac
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java
@@ -0,0 +1,63 @@
+package com.bumptech.glide.load;
+
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * Interface for the ImageHeaderParser.
+ */
+public interface ImageHeaderParser {
+  /**
+   * A constant indicating we were unable to parse the orientation from the image either because
+   * no exif segment containing orientation data existed, or because of an I/O error attempting to
+   * read the exif segment.
+   */
+  int UNKNOWN_ORIENTATION = -1;
+
+  /**
+   * The format of the image data including whether or not the image may include transparent
+   * pixels.
+   */
+  enum ImageType {
+    GIF(true),
+    JPEG(false),
+    RAW(false),
+    /** PNG type with alpha. */
+    PNG_A(true),
+    /** PNG type without alpha. */
+    PNG(false),
+    /** WebP type with alpha. */
+    WEBP_A(true),
+    /** WebP type without alpha. */
+    WEBP(false),
+    /**
+     * Unrecognized type.
+     */
+    UNKNOWN(false);
+    private final boolean hasAlpha;
+
+    ImageType(boolean hasAlpha) {
+      this.hasAlpha = hasAlpha;
+    }
+
+    public boolean hasAlpha() {
+      return hasAlpha;
+    }
+  }
+
+  ImageType getType(InputStream is) throws IOException;
+  ImageType getType(ByteBuffer byteBuffer) throws IOException;
+
+  /**
+   * Parse the orientation from the image header. If it doesn't handle this image type (or this is
+   * not an image) it will return a default value rather than throwing an exception.
+   *
+   * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't
+   * contain an orientation
+   * @throws IOException
+   */
+  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;
+  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
new file mode 100644
index 000000000..b092e15f2
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java
@@ -0,0 +1,90 @@
+package com.bumptech.glide.load;
+
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+/**
+ * Utilities for the ImageHeaderParser.
+ */
+public final class ImageHeaderParserUtils {
+  // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer but
+  // will resize up to this amount if necessary.
+  private static final int MARK_POSITION = 5 * 1024 * 1024;
+
+  private ImageHeaderParserUtils() { }
+
+  /** Returns the ImageType for the given InputStream. */
+  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable InputStream is,
+      ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    for (ImageHeaderParser parser : parsers) {
+      try {
+        ImageType type = parser.getType(is);
+        if (type != ImageType.UNKNOWN) {
+          return type;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /** Returns the ImageType for the given ByteBuffer. */
+  public static ImageType getType(List<ImageHeaderParser> parsers, @Nullable ByteBuffer buffer)
+      throws IOException {
+    if (buffer == null) {
+      return ImageType.UNKNOWN;
+    }
+
+    for (ImageHeaderParser parser : parsers) {
+      ImageType type = parser.getType(buffer);
+      if (type != ImageType.UNKNOWN) {
+        return type;
+      }
+    }
+
+    return ImageType.UNKNOWN;
+  }
+
+  /** Returns the orientation for the given InputStream. */
+  public static int getOrientation(List<ImageHeaderParser> parsers, @Nullable InputStream is,
+      ArrayPool byteArrayPool) throws IOException {
+    if (is == null) {
+      return ImageHeaderParser.UNKNOWN_ORIENTATION;
+    }
+
+    if (!is.markSupported()) {
+      is = new RecyclableBufferedInputStream(is, byteArrayPool);
+    }
+
+    is.mark(MARK_POSITION);
+    for (ImageHeaderParser parser : parsers) {
+      try {
+        int orientation = parser.getOrientation(is, byteArrayPool);
+        if (orientation != ImageHeaderParser.UNKNOWN_ORIENTATION) {
+          return orientation;
+        }
+      } finally {
+        is.reset();
+      }
+    }
+
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
index 91a7fc2d7..c4c5d712b 100644
--- a/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.content.Context;
 import com.bumptech.glide.load.engine.Resource;
 import java.security.MessageDigest;
 import java.util.Arrays;
@@ -31,11 +32,12 @@ public MultiTransformation(Collection<? extends Transformation<T>> transformatio
   }
 
   @Override
-  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(
+      Context context, Resource<T> resource, int outWidth, int outHeight) {
     Resource<T> previous = resource;
 
     for (Transformation<T> transformation : transformations) {
-      Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);
+      Resource<T> transformed = transformation.transform(context, previous, outWidth, outHeight);
       if (previous != null && !previous.equals(resource) && !previous.equals(transformed)) {
         previous.recycle();
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/Transformation.java b/library/src/main/java/com/bumptech/glide/load/Transformation.java
index b11a635bd..659dad412 100644
--- a/library/src/main/java/com/bumptech/glide/load/Transformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import android.content.Context;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -40,6 +41,7 @@
    * Transformation. Otherwise the resource you request may be loaded from disk cache and your
    * Transformation may not be called.
    *
+   * @param context The Application context
    * @param resource  The resource to transform.
    * @param outWidth  The width of the view or target the resource will be displayed in, or {@link
    *                  com.bumptech.glide.request.target.Target#SIZE_ORIGINAL} to indicate the
@@ -49,5 +51,5 @@
    *                  original resource height.
    * @return The transformed resource.
    */
-  Resource<T> transform(Resource<T> resource, int outWidth, int outHeight);
+  Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index 5dab84909..e441bef2a 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -93,6 +93,10 @@ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
     urlConnection.setUseCaches(false);
     urlConnection.setDoInput(true);
 
+    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that
+    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.
+    urlConnection.setInstanceFollowRedirects(false);
+
     // Connect explicitly to avoid errors in decoders if connection fails.
     urlConnection.connect();
     if (isCancelled) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index 6db40af7f..fe0eed476 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -82,12 +82,8 @@ private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver
 
   @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
   private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {
-    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
-      return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri);
-    } else {
-      return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
-          true /*preferHighres*/);
-    }
+    return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
+        true /*preferHighres*/);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index 4bd15097b..f7f7db337 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -39,8 +39,10 @@ public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
 
   private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
     ArrayPool byteArrayPool = Glide.get(context).getArrayPool();
-    return new ThumbFetcher(
-        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));
+    ThumbnailStreamOpener opener = new ThumbnailStreamOpener(
+        Glide.get(context).getRegistry().getImageHeaderParsers(), query, byteArrayPool,
+        context.getContentResolver());
+    return new ThumbFetcher(uri, opener);
   }
 
   // Visible for testing.
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index 7ccc08820..323f02e17 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -5,27 +5,33 @@
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Log;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.List;
 
 class ThumbnailStreamOpener {
   private static final String TAG = "ThumbStreamOpener";
   private static final FileService DEFAULT_SERVICE = new FileService();
+
   private final FileService service;
   private final ThumbnailQuery query;
   private final ArrayPool byteArrayPool;
   private final ContentResolver contentResolver;
+  private final List<ImageHeaderParser> parsers;
 
   public ThumbnailStreamOpener(
-      ThumbnailQuery query, ArrayPool byteArrayPool, ContentResolver contentResolver) {
-    this(DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
+      List<ImageHeaderParser> parsers, ThumbnailQuery query, ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
+    this(parsers, DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
   public ThumbnailStreamOpener(
+      List<ImageHeaderParser> parsers,
       FileService service,
       ThumbnailQuery query,
       ArrayPool byteArrayPool,
@@ -34,28 +40,29 @@ public ThumbnailStreamOpener(
     this.query = query;
     this.byteArrayPool = byteArrayPool;
     this.contentResolver = contentResolver;
+    this.parsers = parsers;
   }
 
   public int getOrientation(Uri uri) {
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
     InputStream is = null;
     try {
       is = contentResolver.openInputStream(uri);
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
-    } catch (IOException e) {
+      return ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
+      // openInputStream can throw NPEs.
+    } catch (IOException | NullPointerException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
-          Log.d(TAG, "Failed to open uri: " + uri, e);
+        Log.d(TAG, "Failed to open uri: " + uri, e);
       }
     } finally {
       if (is != null) {
-          try {
-              is.close();
-          } catch (IOException e) {
-              // Ignored.
-          }
+        try {
+          is.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
       }
     }
-    return orientation;
+    return ImageHeaderParser.UNKNOWN_ORIENTATION;
   }
 
   public InputStream open(Uri uri) throws FileNotFoundException {
@@ -82,7 +89,13 @@ public InputStream open(Uri uri) throws FileNotFoundException {
       }
     }
     if (thumbnailUri != null) {
-      inputStream = contentResolver.openInputStream(thumbnailUri);
+      try {
+        inputStream = contentResolver.openInputStream(thumbnailUri);
+        // openInputStream can throw NPEs.
+      } catch (NullPointerException e) {
+        throw (FileNotFoundException)
+          new FileNotFoundException("NPE opening uri: " + thumbnailUri).initCause(e);
+      }
     }
     return inputStream;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
index f39c06da9..bbd9504ed 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java
@@ -198,8 +198,14 @@ boolean isSourceKey(Key key) {
       int size = loadData.size();
       for (int i = 0; i < size; i++) {
         LoadData<?> data = loadData.get(i);
-        cacheKeys.add(data.sourceKey);
-        cacheKeys.addAll(data.alternateKeys);
+        if (!cacheKeys.contains(data.sourceKey)) {
+          cacheKeys.add(data.sourceKey);
+        }
+        for (int j = 0; j < data.alternateKeys.size(); j++) {
+          if (!cacheKeys.contains(data.alternateKeys.get(j))) {
+            cacheKeys.add(data.alternateKeys.get(j));
+          }
+        }
       }
     }
     return cacheKeys;
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index c00824e23..8b2abacef 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -58,6 +58,7 @@
   private Stage stage;
   private RunReason runReason;
   private long startFetchTime;
+  private boolean onlyRetrieveFromCache;
 
   private Thread currentThread;
   @Synthetic Key currentSourceKey;
@@ -88,6 +89,7 @@
       DiskCacheStrategy diskCacheStrategy,
       Map<Class<?>, Transformation<?>> transformations,
       boolean isTransformationRequired,
+      boolean onlyRetrieveFromCache,
       Options options,
       Callback<R> callback,
       int order) {
@@ -112,6 +114,7 @@
     this.width = width;
     this.height = height;
     this.diskCacheStrategy = diskCacheStrategy;
+    this.onlyRetrieveFromCache = onlyRetrieveFromCache;
     this.options = options;
     this.callback = callback;
     this.order = order;
@@ -316,7 +319,8 @@ private Stage getNextStage(Stage current) {
         return diskCacheStrategy.decodeCachedData()
             ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
       case DATA_CACHE:
-        return Stage.SOURCE;
+        // Skip loading from source if the user opted to only retrieve the resource from cache.
+        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
       case SOURCE:
       case FINISHED:
         return Stage.FINISHED;
@@ -350,6 +354,7 @@ public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetche
   @Override
   public void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher<?> fetcher,
       DataSource dataSource) {
+    fetcher.cleanup();
     GlideException exception = new GlideException("Fetching data failed", e);
     exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());
     exceptions.add(exception);
@@ -383,6 +388,10 @@ private void decodeFromRetrievedData() {
   }
 
   private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {
+    if (resource instanceof Initializable) {
+      ((Initializable) resource).initialize();
+    }
+
     Resource<R> result = resource;
     LockedResource<R> lockedResource = null;
     if (deferredEncodeManager.hasResourceToEncode()) {
@@ -455,11 +464,12 @@ public StateVerifier getVerifier() {
     return stateVerifier;
   }
 
-  class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
+  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {
 
     private final DataSource dataSource;
 
-    public DecodeCallback(DataSource dataSource) {
+    @Synthetic
+    DecodeCallback(DataSource dataSource) {
       this.dataSource = dataSource;
     }
 
@@ -470,7 +480,7 @@ public DecodeCallback(DataSource dataSource) {
       Resource<Z> transformed = decoded;
       if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
         appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
-        transformed = appliedTransformation.transform(decoded, width, height);
+        transformed = appliedTransformation.transform(glideContext, decoded, width, height);
       }
       // TODO: Make this the responsibility of the Transformation.
       if (!decoded.equals(transformed)) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index fdeff2601..1dc070d50 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -154,6 +154,7 @@ public Engine(MemoryCache memoryCache,
       Options options,
       boolean isMemoryCacheable,
       boolean useUnlimitedSourceExecutorPool,
+      boolean onlyRetrieveFromCache,
       ResourceCallback cb) {
     Util.assertMainThread();
     long startTime = LogTime.getLogTime();
@@ -203,6 +204,7 @@ public Engine(MemoryCache memoryCache,
         diskCacheStrategy,
         transformations,
         isTransformationRequired,
+        onlyRetrieveFromCache,
         options,
         engineJob);
     jobs.put(key, engineJob);
@@ -418,6 +420,7 @@ public boolean queueIdle() {
         DiskCacheStrategy diskCacheStrategy,
         Map<Class<?>, Transformation<?>> transformations,
         boolean isTransformationRequired,
+        boolean onlyRetrieveFromCache,
         Options options,
         DecodeJob.Callback<R> callback) {
       DecodeJob<R> result = (DecodeJob<R>) pool.acquire();
@@ -434,6 +437,7 @@ public boolean queueIdle() {
           diskCacheStrategy,
           transformations,
           isTransformationRequired,
+          onlyRetrieveFromCache,
           options,
           callback,
           creationOrder++);
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
new file mode 100644
index 000000000..9b34820b1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java
@@ -0,0 +1,14 @@
+package com.bumptech.glide.load.engine;
+
+/**
+ * A callback allowing a resource to do some optimization on a background thread before being
+ * returned to the ui.
+ */
+public interface Initializable {
+
+  /**
+   * Called on a background thread so the {@link Resource} can do some eager initialization.
+   */
+  void initialize();
+
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
index c97a84b0c..18427396a 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java
@@ -15,11 +15,6 @@
    */
   int getArrayLength(T array);
 
-  /**
-   * Reset the array for re-use (e.g. set all values to 0).
-   */
-  void resetArray(T array);
-
   /**
    * Allocate and return an array of the specified size.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
index 34d78b312..bfdb18621 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java
@@ -22,6 +22,8 @@
    * Returns a non-null array of the given type with a length >= to the given size.
    *
    * <p>If an array of the given size isn't in the pool, a new one will be allocated.
+   *
+   * <p>This class makes no guarantees about the contents of the returned array.
    */
   <T> T get(int size, Class<T> arrayClass);
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
index 96a79def3..95f5ff708 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import java.util.Arrays;
-
 /**
  * Adapter for handling primitive byte arrays.
  */
@@ -19,11 +17,6 @@ public int getArrayLength(byte[] array) {
     return array.length;
   }
 
-  @Override
-  public void resetArray(byte[] array) {
-    Arrays.fill(array, (byte) 0);
-  }
-
   @Override
   public byte[] newArray(int length) {
     return new byte[length];
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
index e6f8129be..4fb179c38 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.engine.bitmap_recycle;
 
-import java.util.Arrays;
-
 /**
  * Adapter for handling primitive int arrays.
  */
@@ -19,11 +17,6 @@ public int getArrayLength(int[] array) {
     return array.length;
   }
 
-  @Override
-  public void resetArray(int[] array) {
-    Arrays.fill(array, 0);
-  }
-
   @Override
   public int[] newArray(int length) {
     return new int[length];
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
index 87301f1ca..6da2cb0e0 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -85,9 +85,7 @@ public LruArrayPool(int maxSize) {
       }
     }
 
-    if (result != null) {
-      arrayAdapter.resetArray(result);
-    } else {
+    if (result == null) {
       if (Log.isLoggable(arrayAdapter.getTag(), Log.VERBOSE)) {
         Log.v(arrayAdapter.getTag(), "Allocated " + size + " bytes");
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
index 69eaa843a..2cf9c0f37 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java
@@ -169,17 +169,10 @@ private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config
   // Setting these two values provides Bitmaps that are essentially equivalent to those returned
   // from Bitmap.createBitmap.
   private static void normalize(Bitmap bitmap) {
-    maybeSetAlpha(bitmap);
+    bitmap.setHasAlpha(true);
     maybeSetPreMultiplied(bitmap);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-  private static void maybeSetAlpha(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
-      bitmap.setHasAlpha(true);
-    }
-  }
-
   @TargetApi(Build.VERSION_CODES.KITKAT)
   private static void maybeSetPreMultiplied(Bitmap bitmap) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
index b495081ae..7e0bb505e 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.engine.cache;
 
-import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
@@ -109,12 +108,13 @@ private String toMb(int bytes) {
     return Formatter.formatFileSize(context, bytes);
   }
 
-  @TargetApi(Build.VERSION_CODES.KITKAT)
   private static boolean isLowMemoryDevice(ActivityManager activityManager) {
+    // Explicitly check with an if statement, on some devices both parts of boolean expressions
+    // can be evaluated even if we'd normally expect a short circuit.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       return activityManager.isLowRamDevice();
     } else {
-      return Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB;
+      return false;
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
index 7d76ff1c0..023e2d978 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource;
 
+import android.content.Context;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import java.security.MessageDigest;
@@ -27,7 +28,7 @@ private UnitTransformation() {
   }
 
   @Override
-  public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {
+  public Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight) {
     return resource;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
index 6977a0559..989664e20 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 import com.bumptech.glide.util.Util;
@@ -15,7 +16,8 @@
  * given {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} when the resource is
  * recycled. </p>
  */
-public class BitmapDrawableResource extends DrawableResource<BitmapDrawable> {
+public class BitmapDrawableResource extends DrawableResource<BitmapDrawable>
+    implements Initializable {
   private final BitmapPool bitmapPool;
 
   public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {
@@ -37,4 +39,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(drawable.getBitmap());
   }
+
+  @Override
+  public void initialize() {
+    drawable.getBitmap().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
index aab12a1e1..299e31d42 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java
@@ -15,31 +15,43 @@
  */
 public class BitmapDrawableTransformation implements Transformation<BitmapDrawable> {
 
-  private final Context context;
-  private final BitmapPool bitmapPool;
   private final Transformation<Bitmap> wrapped;
 
-  public BitmapDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
-    this(context, Glide.get(context).getBitmapPool(), wrapped);
+  public BitmapDrawableTransformation(Transformation<Bitmap> wrapped) {
+    this.wrapped = Preconditions.checkNotNull(wrapped);
+  }
+
+  /**
+   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
+   */
+  @Deprecated
+  public BitmapDrawableTransformation(
+      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
+    this(wrapped);
   }
 
-  // Visible for testing.
-  BitmapDrawableTransformation(Context context, BitmapPool bitmapPool,
+  /**
+   * @deprecated use {@link #BitmapDrawableTransformation(Transformation)}}
+   */
+  @Deprecated
+  public BitmapDrawableTransformation(
+      @SuppressWarnings("unused") Context context,
+      @SuppressWarnings("unused") BitmapPool bitmapPool,
       Transformation<Bitmap> wrapped) {
-    this.context = context.getApplicationContext();
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
-    this.wrapped = Preconditions.checkNotNull(wrapped);
+    this(wrapped);
   }
 
   @Override
-  public Resource<BitmapDrawable> transform(Resource<BitmapDrawable> drawableResourceToTransform,
-      int outWidth, int outHeight) {
+  public Resource<BitmapDrawable> transform(
+      Context context, Resource<BitmapDrawable> drawableResourceToTransform, int outWidth,
+      int outHeight) {
     BitmapDrawable drawableToTransform = drawableResourceToTransform.get();
     Bitmap bitmapToTransform = drawableToTransform.getBitmap();
 
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     BitmapResource bitmapResourceToTransform = BitmapResource.obtain(bitmapToTransform, bitmapPool);
     Resource<Bitmap> transformedBitmapResource =
-        wrapped.transform(bitmapResourceToTransform, outWidth, outHeight);
+        wrapped.transform(context, bitmapResourceToTransform, outWidth, outHeight);
 
     if (transformedBitmapResource.equals(bitmapResourceToTransform)) {
       return drawableResourceToTransform;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
index 474c76f4c..102c688c0 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java
@@ -2,6 +2,7 @@
 
 import android.graphics.Bitmap;
 import android.support.annotation.Nullable;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
@@ -10,7 +11,8 @@
 /**
  * A resource wrapping a {@link android.graphics.Bitmap} object.
  */
-public class BitmapResource implements Resource<Bitmap> {
+public class BitmapResource implements Resource<Bitmap>,
+    Initializable {
   private final Bitmap bitmap;
   private final BitmapPool bitmapPool;
 
@@ -54,4 +56,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(bitmap);
   }
+
+  @Override
+  public void initialize() {
+    bitmap.prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
index 5098721b0..f204cc54e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java
@@ -52,23 +52,29 @@
  */
 public abstract class BitmapTransformation implements Transformation<Bitmap> {
 
-  private final BitmapPool bitmapPool;
+  public BitmapTransformation() {
+    // Intentionally empty.
+  }
 
-  public BitmapTransformation(Context context) {
-    this(Glide.get(context).getBitmapPool());
+  @Deprecated
+  public BitmapTransformation(@SuppressWarnings("unused") Context context) {
+    this();
   }
 
-  public BitmapTransformation(BitmapPool bitmapPool) {
-    this.bitmapPool = bitmapPool;
+  @Deprecated
+  public BitmapTransformation(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   @Override
-  public final Resource<Bitmap> transform(Resource<Bitmap> resource, int outWidth, int outHeight) {
+  public final Resource<Bitmap> transform(
+      Context context, Resource<Bitmap> resource, int outWidth, int outHeight) {
     if (!Util.isValidDimensions(outWidth, outHeight)) {
       throw new IllegalArgumentException(
           "Cannot apply transformation on width: " + outWidth + " or height: " + outHeight
               + " less than or equal to zero and not Target.SIZE_ORIGINAL");
     }
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Bitmap toTransform = resource.get();
     int targetWidth = outWidth == Target.SIZE_ORIGINAL ? toTransform.getWidth() : outWidth;
     int targetHeight = outHeight == Target.SIZE_ORIGINAL ? toTransform.getHeight() : outHeight;
@@ -111,6 +117,6 @@ public BitmapTransformation(BitmapPool bitmapPool) {
    * @param outHeight   The ideal height of the transformed bitmap (the transformed height does not
    *                    need to match exactly).
    */
-  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,
-      int outWidth, int outHeight);
+  protected abstract Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
index 7b3770aff..bdc38562a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java
@@ -17,19 +17,25 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterCrop";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterCrop(Context context) {
-    super(context);
+  public CenterCrop() {
+    // Intentionally empty.
   }
 
-  public CenterCrop(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  @Deprecated
+  public CenterCrop(@SuppressWarnings("unused") Context context) {
+    this();
+  }
+
+  @Deprecated
+  public CenterCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
index 0162311c6..6efdbad47 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java
@@ -17,17 +17,29 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CenterInside(Context context) {
-    super(context);
+  public CenterInside() {
+    // Intentionally empty.
   }
 
-  public CenterInside(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  /**
+   * Use {@link #CenterInside()}.
+   */
+  @Deprecated
+  public CenterInside(@SuppressWarnings("unused") Context context) {
+    this();
+  }
+
+  /**
+   * Use {@link #CenterInside()}.
+   */
+  @Deprecated
+  public CenterInside(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
index 1a39e62c9..655487175 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java
@@ -19,19 +19,31 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.CircleCrop." + VERSION;
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public CircleCrop(Context context) {
-    super(context);
+  public CircleCrop() {
+    // Intentionally empty.
   }
 
-  public CircleCrop(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  /**
+   * @deprecated Use {@link #CircleCrop()}.
+   */
+  @Deprecated
+  public CircleCrop(@SuppressWarnings("unused") Context context) {
+    this();
+  }
+
+  /**
+   * @deprecated Use {@link #CircleCrop()}
+   */
+  @Deprecated
+  public CircleCrop(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   // Bitmap doesn't implement equals, so == and .equals are equivalent here.
   @SuppressWarnings("PMD.CompareObjectsWithEquals")
   @Override
-  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
-      int outHeight) {
+  protected Bitmap transform(
+      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
     return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
similarity index 79%
rename from library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
rename to library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
index 0ad18f335..5bfe67f8c 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParser.java
@@ -1,12 +1,13 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.GIF;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.JPEG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.PNG_A;
-import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType.UNKNOWN;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.GIF;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.JPEG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.PNG_A;
+import static com.bumptech.glide.load.ImageHeaderParser.ImageType.UNKNOWN;
 
 import android.util.Log;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.util.Preconditions;
 import java.io.IOException;
@@ -18,59 +19,25 @@
 /**
  * A class for parsing the exif orientation and other data from an image header.
  */
-public class ImageHeaderParser {
-  private static final String TAG = "ImageHeaderParser";
-  /**
-   * A constant indicating we were unable to parse the orientation from the image either because
-   * no exif segment containing orientation data existed, or because of an I/O error attempting to
-   * read the exif segment.
-   */
-  public static final int UNKNOWN_ORIENTATION = -1;
-
-  /**
-   * The format of the image data including whether or not the image may include transparent
-   * pixels.
-   */
-  public enum ImageType {
-    GIF(true),
-    JPEG(false),
-    /** PNG type with alpha. */
-    PNG_A(true),
-    /** PNG type without alpha. */
-    PNG(false),
-    /** WebP type with alpha. */
-    WEBP_A(true),
-    /** WebP type without alpha. */
-    WEBP(false),
-    /**
-     * Unrecognized type.
-     */
-    UNKNOWN(false);
-    private final boolean hasAlpha;
-
-    ImageType(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
-  }
+public final class DefaultImageHeaderParser implements ImageHeaderParser {
+  // Due to https://code.google.com/p/android/issues/detail?id=97751.
+  // TAG needs to be under 23 chars, so "Default" > "Dflt".
+  private static final String TAG = "DfltImageHeaderParser";
 
   private static final int GIF_HEADER = 0x474946;
   private static final int PNG_HEADER = 0x89504E47;
-  private static final int EXIF_MAGIC_NUMBER = 0xFFD8;
+  static final int EXIF_MAGIC_NUMBER = 0xFFD8;
   // "MM".
   private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
   // "II".
   private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
-  private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
-  private static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
+  static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
+  static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES =
       JPEG_EXIF_SEGMENT_PREAMBLE.getBytes(Charset.forName("UTF-8"));
   private static final int SEGMENT_SOS = 0xDA;
   private static final int MARKER_EOI = 0xD9;
-  private static final int SEGMENT_START_ID = 0xFF;
-  private static final int EXIF_SEGMENT_TYPE = 0xE1;
+  static final int SEGMENT_START_ID = 0xFF;
+  static final int EXIF_SEGMENT_TYPE = 0xE1;
   private static final int ORIENTATION_TAG_TYPE = 0x0112;
   private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };
   // WebP-related
@@ -89,28 +56,29 @@ public boolean hasAlpha() {
   private static final int WEBP_EXTENDED_ALPHA_FLAG = 1 << 4;
   private static final int WEBP_LOSSLESS_ALPHA_FLAG = 1 << 3;
 
-  private final ArrayPool byteArrayPool;
-  private final Reader reader;
+  @Override
+  public ImageType getType(InputStream is) throws IOException {
+    return getType(new StreamReader(Preconditions.checkNotNull(is)));
+  }
 
-  public ImageHeaderParser(InputStream is, ArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(is);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new StreamReader(is);
+  @Override
+  public ImageType getType(ByteBuffer byteBuffer) throws IOException {
+    return getType(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)));
   }
 
-  public ImageHeaderParser(ByteBuffer byteBuffer, ArrayPool byteArrayPool) {
-    Preconditions.checkNotNull(byteBuffer);
-    this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
-    reader = new ByteBufferReader(byteBuffer);
+  @Override
+  public int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException {
+    return getOrientation(new StreamReader(Preconditions.checkNotNull(is)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  // 0xD0A3C68 -> <htm
-  // 0xCAFEBABE -> <!DOCTYPE...
-  public boolean hasAlpha() throws IOException {
-    return getType().hasAlpha();
+  @Override
+  public int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException {
+    return getOrientation(new ByteBufferReader(Preconditions.checkNotNull(byteBuffer)),
+        Preconditions.checkNotNull(byteArrayPool));
   }
 
-  public ImageType getType() throws IOException {
+  private ImageType getType(Reader reader) throws IOException {
     int firstTwoBytes = reader.getUInt16();
 
     // JPEG.
@@ -171,7 +139,7 @@ public ImageType getType() throws IOException {
    * contain an orientation
    * @throws IOException
    */
-  public int getOrientation() throws IOException {
+  private int getOrientation(Reader reader, ArrayPool byteArrayPool) throws IOException {
     final int magicNumber = reader.getUInt16();
 
     if (!handles(magicNumber)) {
@@ -180,7 +148,7 @@ public int getOrientation() throws IOException {
       }
       return UNKNOWN_ORIENTATION;
     } else {
-      int exifSegmentLength = moveToExifSegmentAndGetLength();
+      int exifSegmentLength = moveToExifSegmentAndGetLength(reader);
       if (exifSegmentLength == -1) {
         if (Log.isLoggable(TAG, Log.DEBUG)) {
           Log.d(TAG, "Failed to parse exif segment length, or exif segment not found");
@@ -190,14 +158,15 @@ public int getOrientation() throws IOException {
 
       byte[] exifData = byteArrayPool.get(exifSegmentLength, byte[].class);
       try {
-        return parseExifSegment(exifData, exifSegmentLength);
+        return parseExifSegment(reader, exifData, exifSegmentLength);
       } finally {
         byteArrayPool.put(exifData, byte[].class);
       }
     }
   }
 
-  private int parseExifSegment(byte[] tempArray, int exifSegmentLength) throws IOException {
+  private int parseExifSegment(Reader reader, byte[] tempArray, int exifSegmentLength)
+      throws IOException {
     int read = reader.read(tempArray, exifSegmentLength);
     if (read != exifSegmentLength) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -237,7 +206,7 @@ private boolean hasJpegExifPreamble(byte[] exifData, int exifSegmentLength) {
    * Moves reader to the start of the exif segment and returns the length of the exif segment or
    * {@code -1} if no exif segment is found.
    */
-  private int moveToExifSegmentAndGetLength() throws IOException {
+  private int moveToExifSegmentAndGetLength(Reader reader) throws IOException {
     short segmentId, segmentType;
     int segmentLength;
     while (true) {
@@ -377,29 +346,33 @@ private static boolean handles(int imageMagicNumber) {
         || imageMagicNumber == INTEL_TIFF_MAGIC_NUMBER;
   }
 
-  private static class RandomAccessReader {
+  private static final class RandomAccessReader {
     private final ByteBuffer data;
 
-    public RandomAccessReader(byte[] data, int length) {
+    RandomAccessReader(byte[] data, int length) {
       this.data = (ByteBuffer) ByteBuffer.wrap(data)
           .order(ByteOrder.BIG_ENDIAN)
           .limit(length);
     }
 
-    public void order(ByteOrder byteOrder) {
+    void order(ByteOrder byteOrder) {
       this.data.order(byteOrder);
     }
 
-    public int length() {
+    int length() {
       return data.remaining();
     }
 
-    public int getInt32(int offset) {
-      return data.getInt(offset);
+    int getInt32(int offset) {
+      return isAvailable(offset, 4) ? data.getInt(offset) : -1;
+    }
+
+    short getInt16(int offset) {
+      return isAvailable(offset, 2) ? data.getShort(offset) : -1;
     }
 
-    public short getInt16(int offset) {
-      return data.getShort(offset);
+    private boolean isAvailable(int offset, int byteSize) {
+      return data.remaining() - offset >= byteSize;
     }
   }
 
@@ -411,11 +384,11 @@ public short getInt16(int offset) {
     int getByte() throws IOException;
   }
 
-  private static class ByteBufferReader implements Reader {
+  private static final class ByteBufferReader implements Reader {
 
     private final ByteBuffer byteBuffer;
 
-    public ByteBufferReader(ByteBuffer byteBuffer) {
+    ByteBufferReader(ByteBuffer byteBuffer) {
       this.byteBuffer = byteBuffer;
       byteBuffer.order(ByteOrder.BIG_ENDIAN);
     }
@@ -440,7 +413,10 @@ public long skip(long total) throws IOException {
     @Override
     public int read(byte[] buffer, int byteCount) throws IOException {
       int toRead = Math.min(byteCount, byteBuffer.remaining());
-      byteBuffer.get(buffer, 0 /*dstOffset*/, byteCount);
+      if (toRead == 0) {
+        return -1;
+      }
+      byteBuffer.get(buffer, 0 /*dstOffset*/, toRead);
       return toRead;
     }
 
@@ -453,10 +429,10 @@ public int getByte() throws IOException {
     }
   }
 
-  private static class StreamReader implements Reader {
+  private static final class StreamReader implements Reader {
     private final InputStream is;
     // Motorola / big endian byte order.
-    public StreamReader(InputStream is) {
+    StreamReader(InputStream is) {
       this.is = is;
     }
 
@@ -513,4 +489,3 @@ public int getByte() throws IOException {
     }
   }
 }
-
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
index 27e401045..71548c5e9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java
@@ -62,9 +62,9 @@
   public static final DownsampleStrategy NONE = new None();
 
   /**
-   * Default strategy, currently {@link #AT_LEAST}.
+   * Default strategy, currently {@link #CENTER_OUTSIDE}.
    */
-  public static final DownsampleStrategy DEFAULT = AT_LEAST;
+  public static final DownsampleStrategy DEFAULT = CENTER_OUTSIDE;
 
   /**
    * Returns a float (0, +infinity) indicating a scale factor to apply to the source
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index 55d23b2ca..e16adcc79 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -4,9 +4,12 @@
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.os.Build;
+import android.support.annotation.Nullable;
 import android.util.DisplayMetrics;
 import android.util.Log;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
@@ -23,6 +26,7 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 
@@ -47,6 +51,19 @@
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
           DownsampleStrategy.AT_LEAST);
 
+  /**
+   * Ensure that the size of the bitmap is fixed to the requested width and height of the
+   * resource from the caller.  The final resource dimensions may differ from the requested
+   * width and height, and thus setting this to true may result in the bitmap size differing
+   * from the resource dimensions.
+   *
+   * This can be used as a performance optimization for KitKat and above by fixing the size of the
+   * bitmap for a collection of requested resources so that the bitmap pool will not need to
+   * allocate new bitmaps for images of different sizes.
+   */
+  public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =
+      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);
+
   private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
   private static final String ICO_MIME_TYPE = "image/x-ico";
   private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
@@ -85,9 +102,11 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
   private final ArrayPool byteArrayPool;
+  private final List<ImageHeaderParser> parsers;
 
-  public Downsampler(DisplayMetrics displayMetrics, BitmapPool bitmapPool,
-       ArrayPool byteArrayPool) {
+  public Downsampler(List<ImageHeaderParser> parsers, DisplayMetrics displayMetrics,
+      BitmapPool bitmapPool, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.displayMetrics = Preconditions.checkNotNull(displayMetrics);
     this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
     this.byteArrayPool = Preconditions.checkNotNull(byteArrayPool);
@@ -151,10 +170,12 @@ public boolean handles(ByteBuffer byteBuffer) {
 
     DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
     DownsampleStrategy downsampleStrategy = options.get(DOWNSAMPLE_STRATEGY);
+    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
 
     try {
       Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
-          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight, callbacks);
+          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,
+          fixBitmapToRequestedDimensions, callbacks);
       return BitmapResource.obtain(result, bitmapPool);
     } finally {
       releaseOptions(bitmapFactoryOptions);
@@ -165,25 +186,61 @@ public boolean handles(ByteBuffer byteBuffer) {
   private Bitmap decodeFromWrappedStreams(InputStream is,
       BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
       DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,
-      DecodeCallbacks callbacks) throws IOException {
+      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {
 
     int[] sourceDimensions = getDimensions(is, options, callbacks);
     int sourceWidth = sourceDimensions[0];
     int sourceHeight = sourceDimensions[1];
     String sourceMimeType = options.outMimeType;
 
-    int orientation = getOrientation(is);
+    int orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);
     int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
 
     options.inPreferredConfig = getConfig(is, decodeFormat);
     if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
       options.inDither = true;
     }
-    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, requestedWidth,
-        requestedHeight, options);
 
-    Bitmap downsampled = downsampleWithSize(is, options, bitmapPool, sourceWidth,
-        sourceHeight, callbacks);
+    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
+    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
+
+    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,
+        targetHeight, options);
+
+    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
+    if ((options.inSampleSize == 1 || isKitKatOrGreater)
+        && shouldUsePool(is)) {
+      int expectedWidth;
+      int expectedHeight;
+      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {
+        expectedWidth = targetWidth;
+        expectedHeight = targetHeight;
+      } else {
+        float densityMultiplier = isScaling(options)
+            ? (float) options.inTargetDensity / options.inDensity : 1f;
+        int sampleSize = options.inSampleSize;
+        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
+        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
+        expectedWidth = Math.round(downsampledWidth * densityMultiplier);
+        expectedHeight = Math.round(downsampledHeight * densityMultiplier);
+
+        if (Log.isLoggable(TAG, Log.VERBOSE)) {
+          Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
+              + " [" + sourceWidth + "x" + sourceHeight + "]"
+              + ", sampleSize: " + sampleSize
+              + ", targetDensity: " + options.inTargetDensity
+              + ", density: " + options.inDensity
+              + ", density multiplier: " + densityMultiplier);
+        }
+      }
+      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
+      // will be -1 here.
+      if (expectedWidth > 0 && expectedHeight > 0) {
+        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);
+      }
+    }
+    Bitmap downsampled = decodeStream(is, options, callbacks);
     callbacks.onDecodeComplete(bitmapPool, downsampled);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
@@ -208,16 +265,13 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
 
   // Visible for testing.
   static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesToRotate,
-      int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight,
+      int sourceWidth, int sourceHeight, int targetWidth, int targetHeight,
       BitmapFactory.Options options) {
     // We can't downsample source content if we can't determine its dimensions.
     if (sourceWidth <= 0 || sourceHeight <= 0) {
       return;
     }
 
-    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;
-    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;
-
     final float exactScaleFactor;
     if (degreesToRotate == 90 || degreesToRotate == 270) {
       // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
@@ -291,54 +345,6 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
     }
   }
 
-  private int getOrientation(InputStream is) throws IOException {
-    is.mark(MARK_POSITION);
-    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
-    try {
-      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
-    } catch (IOException e) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Cannot determine the image orientation from header", e);
-      }
-    } finally {
-      is.reset();
-    }
-    return orientation;
-  }
-
-  private Bitmap downsampleWithSize(InputStream is, BitmapFactory.Options options,
-      BitmapPool pool, int sourceWidth, int sourceHeight, DecodeCallbacks callbacks)
-      throws IOException {
-    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
-    if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT)
-        && shouldUsePool(is)) {
-
-      float densityMultiplier = isScaling(options)
-          ? (float) options.inTargetDensity / options.inDensity : 1f;
-
-      int sampleSize = options.inSampleSize;
-      int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
-      int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
-      int expectedWidth = Math.round(downsampledWidth * densityMultiplier);
-      int expectedHeight = Math.round(downsampledHeight * densityMultiplier);
-
-      if (Log.isLoggable(TAG, Log.VERBOSE)) {
-        Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source"
-            + " [" + sourceWidth + "x" + sourceHeight + "]"
-            + ", sampleSize: " + sampleSize
-            + ", targetDensity: " + options.inTargetDensity
-            + ", density: " + options.inDensity
-            + ", density multiplier: " + densityMultiplier);
-      }
-      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
-      // will be -1 here.
-      if (expectedWidth > 0 && expectedHeight > 0) {
-        setInBitmap(options, pool, expectedWidth, expectedHeight, options.inPreferredConfig);
-      }
-    }
-    return decodeStream(is, options, callbacks);
-  }
-
   private boolean shouldUsePool(InputStream is) throws IOException {
     // On KitKat+, any bitmap (of a given config) can be used to decode any other bitmap
     // (with the same config).
@@ -346,9 +352,8 @@ private boolean shouldUsePool(InputStream is) throws IOException {
       return true;
     }
 
-    is.mark(MARK_POSITION);
     try {
-      final ImageHeaderParser.ImageType type = new ImageHeaderParser(is, byteArrayPool).getType();
+      ImageHeaderParser.ImageType type = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool);
       // We cannot reuse bitmaps when decoding images that are not PNG or JPG prior to KitKat.
       // See: https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
       return TYPES_THAT_USE_POOL_PRE_KITKAT.contains(type);
@@ -356,8 +361,6 @@ private boolean shouldUsePool(InputStream is) throws IOException {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Cannot determine the image type from header", e);
       }
-    } finally {
-      is.reset();
     }
     return false;
   }
@@ -370,16 +373,13 @@ private boolean shouldUsePool(InputStream is) throws IOException {
     }
 
     boolean hasAlpha = false;
-    is.mark(MARK_POSITION);
     try {
-      hasAlpha = new ImageHeaderParser(is, byteArrayPool).hasAlpha();
+      hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
         Log.d(TAG, "Cannot determine whether the image has alpha or not from header"
             + ", format " + format, e);
       }
-    } finally {
-      is.reset();
     }
 
     return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
@@ -452,31 +452,27 @@ private static void logDecode(int sourceWidth, int sourceHeight, String outMimeT
         + ", thread: " + Thread.currentThread().getName());
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static String getInBitmapString(BitmapFactory.Options options) {
-    return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB
-        ? getBitmapString(options.inBitmap) : null;
+    return getBitmapString(options.inBitmap);
   }
 
+  @Nullable
   @TargetApi(Build.VERSION_CODES.KITKAT)
   private static String getBitmapString(Bitmap bitmap) {
-    final String result;
     if (bitmap == null) {
-      result = null;
-    } else {
-      String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
-          ? " (" + bitmap.getAllocationByteCount() + ")" : "";
-      result = "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
-          + sizeString;
+      return null;
     }
-    return result;
+
+    String sizeString = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
+        ? " (" + bitmap.getAllocationByteCount() + ")" : "";
+    return  "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig()
+        + sizeString;
   }
 
   // BitmapFactory throws an IllegalArgumentException if any error occurs attempting to decode a
   // file when inBitmap is non-null, including those caused by partial or corrupt data. We still log
   // the error because the IllegalArgumentException is supposed to catch errors reusing Bitmaps, so
   // want some useful log output. In most cases this can be safely treated as a normal IOException.
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentException e,
       int outWidth, int outHeight, String outMimeType, BitmapFactory.Options options) {
     return new IOException("Exception decoding bitmap"
@@ -486,16 +482,12 @@ private static IOException newIoExceptionForInBitmapAssertion(IllegalArgumentExc
           + ", inBitmap: " + getInBitmapString(options), e);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static void setInBitmap(BitmapFactory.Options options, BitmapPool bitmapPool, int width,
-      int height, Bitmap.Config config) {
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
-      options.inBitmap = bitmapPool.getDirty(width, height, config);
-    }
+      int height) {
+    // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
+    options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static synchronized BitmapFactory.Options getDefaultOptions() {
     BitmapFactory.Options decodeBitmapOptions;
     synchronized (OPTIONS_QUEUE) {
@@ -516,7 +508,6 @@ private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.inTempStorage = null;
     decodeBitmapOptions.inDither = false;
@@ -529,11 +520,8 @@ private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
     decodeBitmapOptions.outWidth = 0;
     decodeBitmapOptions.outHeight = 0;
     decodeBitmapOptions.outMimeType = null;
-
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      decodeBitmapOptions.inBitmap = null;
-      decodeBitmapOptions.inMutable = true;
-    }
+    decodeBitmapOptions.inBitmap = null;
+    decodeBitmapOptions.inMutable = true;
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
index 33eadc1d2..c29ef691d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java
@@ -15,12 +15,24 @@
   private static final String ID = "com.bumptech.glide.load.resource.bitmap.FitCenter";
   private static final byte[] ID_BYTES = ID.getBytes(CHARSET);
 
-  public FitCenter(Context context) {
-    super(context);
+  public FitCenter() {
+    // Intentionally empty.
   }
 
-  public FitCenter(BitmapPool bitmapPool) {
-    super(bitmapPool);
+  /**
+   * @deprecated Use {@link #FitCenter()}.
+   */
+  @Deprecated
+  public FitCenter(@SuppressWarnings("unused") Context context) {
+    this();
+  }
+
+  /**
+   * @deprecated Use {@link #FitCenter()}.
+   */
+  @Deprecated
+  public FitCenter(@SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this();
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
index f936b5c80..412c5cc5b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java
@@ -5,6 +5,7 @@
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
 import com.bumptech.glide.Glide;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
@@ -14,7 +15,8 @@
  * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given
  * {@link android.graphics.Bitmap} on the first call to {@link #get()}.
  */
-public class LazyBitmapDrawableResource implements Resource<BitmapDrawable> {
+public class LazyBitmapDrawableResource implements Resource<BitmapDrawable>,
+    Initializable {
 
   private final Bitmap bitmap;
   private final Resources resources;
@@ -54,4 +56,9 @@ public int getSize() {
   public void recycle() {
     bitmapPool.put(bitmap);
   }
+
+  @Override
+  public void initialize() {
+    bitmap.prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
index 83967ea5d..be3e804a2 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -21,8 +21,7 @@
    * @param roundingRadius the corner radius (in device-specific pixels).
    * @throws IllegalArgumentException if rounding radius is 0 or less.
    */
-  public RoundedCorners(BitmapPool bitmapPool, int roundingRadius) {
-    super(bitmapPool);
+  public RoundedCorners(int roundingRadius) {
     Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
     this.roundingRadius = roundingRadius;
   }
@@ -30,11 +29,23 @@ public RoundedCorners(BitmapPool bitmapPool, int roundingRadius) {
   /**
    * @param roundingRadius the corner radius (in device-specific pixels).
    * @throws IllegalArgumentException if rounding radius is 0 or less.
+   *
+   * @deprecated Use {@link #RoundedCorners(int)}
    */
-  public RoundedCorners(Context context, int roundingRadius) {
-    super(context);
-    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
-    this.roundingRadius = roundingRadius;
+  @Deprecated
+  public RoundedCorners(@SuppressWarnings("unused") BitmapPool bitmapPool, int roundingRadius) {
+    this(roundingRadius);
+  }
+
+  /**
+   * @param roundingRadius the corner radius (in device-specific pixels).
+   * @throws IllegalArgumentException if rounding radius is 0 or less.
+   *
+   * @deprecated Use {@link #RoundedCorners(int)}
+   */
+  @Deprecated
+  public RoundedCorners(@SuppressWarnings("unused") Context context, int roundingRadius) {
+    this(roundingRadius);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index cbfb156a8..e7abbb8ab 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.resource.bitmap;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.BitmapShader;
 import android.graphics.Canvas;
@@ -18,6 +17,8 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
+import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.Lock;
@@ -33,17 +34,22 @@
   private static final int CIRCLE_CROP_PAINT_FLAGS = PAINT_FLAGS | Paint.ANTI_ALIAS_FLAG;
   private static final Paint CIRCLE_CROP_SHAPE_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
   private static final Paint CIRCLE_CROP_BITMAP_PAINT;
+
+  // See #738.
+  private static final List<String> MODELS_REQUIRING_BITMAP_LOCK =
+      Arrays.asList(
+          "XT1097",
+          "XT1085");
   /**
    * https://github.com/bumptech/glide/issues/738 On some devices (Moto X with android 5.1) bitmap
    * drawing is not thread safe.
    * This lock only locks for these specific devices. For other types of devices the lock is always
    * available and therefore does not impact performance
    */
-  private static final Lock BITMAP_DRAWABLE_LOCK = "XT1097".equals(Build.MODEL)
-      // TODO: Switch to Build.VERSION_CODES.LOLLIPOP_MR1 when apps have updated target API levels.
-      && Build.VERSION.SDK_INT == 22
-      ? new ReentrantLock()
-      : new NoLock();
+  private static final Lock BITMAP_DRAWABLE_LOCK =
+      MODELS_REQUIRING_BITMAP_LOCK.contains(Build.MODEL)
+          && Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP_MR1
+          ? new ReentrantLock() : new NoLock();
 
   static {
     CIRCLE_CROP_BITMAP_PAINT = new Paint(CIRCLE_CROP_PAINT_FLAGS);
@@ -190,14 +196,7 @@ public static Bitmap centerInside(@NonNull BitmapPool pool, @NonNull Bitmap inBi
    *                    transformation.
    */
   public static void setAlpha(Bitmap inBitmap, Bitmap outBitmap) {
-    setAlphaIfAvailable(outBitmap, inBitmap.hasAlpha());
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-  private static void setAlphaIfAvailable(Bitmap bitmap, boolean hasAlpha) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1 && bitmap != null) {
-      bitmap.setHasAlpha(hasAlpha);
-    }
+    outBitmap.setHasAlpha(inBitmap.hasAlpha());
   }
 
   /**
@@ -320,7 +319,7 @@ public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap inBitm
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
 
     Bitmap result = pool.get(destMinEdge, destMinEdge, Bitmap.Config.ARGB_8888);
-    setAlphaIfAvailable(result, true /*hasAlpha*/);
+    result.setHasAlpha(true);
 
     BITMAP_DRAWABLE_LOCK.lock();
     try {
@@ -376,7 +375,7 @@ public static Bitmap roundedCorners(@NonNull BitmapPool pool, @NonNull Bitmap in
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
     Bitmap result = pool.get(width, height, Bitmap.Config.ARGB_8888);
 
-    setAlphaIfAvailable(result, true /* hasAlpha */);
+    result.setHasAlpha(true);
 
     BitmapShader shader = new BitmapShader(toTransform, Shader.TileMode.CLAMP,
         Shader.TileMode.CLAMP);
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
index 22672fadd..163cbe50a 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java
@@ -1,7 +1,10 @@
 package com.bumptech.glide.load.resource.drawable;
 
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.util.Preconditions;
 
 /**
@@ -14,7 +17,8 @@
  *
  * @param <T> type of the wrapped {@link Drawable}
  */
-public abstract class DrawableResource<T extends Drawable> implements Resource<T> {
+public abstract class DrawableResource<T extends Drawable> implements Resource<T>,
+    Initializable {
   protected final T drawable;
 
   public DrawableResource(T drawable) {
@@ -30,4 +34,13 @@ public final T get() {
     // and subsequent copies may end up with that temporary state. See #276.
     return (T) drawable.getConstantState().newDrawable();
   }
+
+  @Override
+  public void initialize() {
+    if (drawable instanceof BitmapDrawable) {
+      ((BitmapDrawable) drawable).getBitmap().prepareToDraw();
+    } else if (drawable instanceof GifDrawable) {
+      ((GifDrawable) drawable).getFirstFrame().prepareToDraw();
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index 3ff49505f..2b56d271e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -8,20 +8,21 @@
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
 import com.bumptech.glide.gifdecoder.StandardGifDecoder;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
 import com.bumptech.glide.load.resource.UnitTransformation;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 import com.bumptech.glide.util.LogTime;
 import com.bumptech.glide.util.Util;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.List;
 import java.util.Queue;
 
 /**
@@ -43,28 +44,33 @@
   private static final GifHeaderParserPool PARSER_POOL = new GifHeaderParserPool();
 
   private final Context context;
+  private final List<ImageHeaderParser> parsers;
   private final GifHeaderParserPool parserPool;
   private final BitmapPool bitmapPool;
   private final GifDecoderFactory gifDecoderFactory;
   private final GifBitmapProvider provider;
 
   public ByteBufferGifDecoder(Context context) {
-    this(context, Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
+    this(context, Glide.get(context).getRegistry().getImageHeaderParsers(),
+        Glide.get(context).getBitmapPool(), Glide.get(context).getArrayPool());
   }
 
   public ByteBufferGifDecoder(
-      Context context, BitmapPool bitmapPool, ArrayPool arrayPool) {
-    this(context, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
+      Context context, List<ImageHeaderParser> parsers, BitmapPool bitmapPool,
+      ArrayPool arrayPool) {
+    this(context, parsers, bitmapPool, arrayPool, PARSER_POOL, GIF_DECODER_FACTORY);
   }
 
   // Visible for testing.
   ByteBufferGifDecoder(
       Context context,
+      List<ImageHeaderParser> parsers,
       BitmapPool bitmapPool,
       ArrayPool arrayPool,
       GifHeaderParserPool parserPool,
       GifDecoderFactory gifDecoderFactory) {
     this.context = context.getApplicationContext();
+    this.parsers = parsers;
     this.bitmapPool = bitmapPool;
     this.gifDecoderFactory = gifDecoderFactory;
     this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
@@ -73,9 +79,8 @@ public ByteBufferGifDecoder(
 
   @Override
   public boolean handles(ByteBuffer source, Options options) throws IOException {
-    ArrayPool byteArrayPool = new LruArrayPool();
     return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+        && ImageHeaderParserUtils.getType(parsers, source) == ImageType.GIF;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index 39cf6fe16..5e6f98eed 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
-import android.annotation.TargetApi;
+import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;
+
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -11,7 +12,6 @@
 import android.graphics.Rect;
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
 import android.support.annotation.VisibleForTesting;
 import android.view.Gravity;
 import com.bumptech.glide.Glide;
@@ -154,6 +154,15 @@ private void resetLoopCount() {
     loopCount = 0;
   }
 
+  /**
+   * Starts the animation from the first frame. Can only be called while animation is not running.
+   */
+  public void startFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "You cannot restart a currently running animation.");
+    state.frameLoader.setNextStartFromFirstFrame();
+    start();
+  }
+
   @Override
   public void start() {
     isStarted = true;
@@ -273,10 +282,9 @@ public int getOpacity() {
     return PixelFormat.TRANSPARENT;
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @Override
   public void onFrameReady() {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB && getCallback() == null) {
+    if (getCallback() == null) {
       stop();
       invalidateSelf();
       return;
@@ -318,7 +326,9 @@ public void setLoopCount(int loopCount) {
     }
 
     if (loopCount == LOOP_INTRINSIC) {
-      maxLoopCount = state.frameLoader.getLoopCount();
+      int intrinsicCount = state.frameLoader.getLoopCount();
+      maxLoopCount =
+          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;
     } else {
       maxLoopCount = loopCount;
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
index 6b8301462..d0275e023 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java
@@ -1,11 +1,13 @@
 package com.bumptech.glide.load.resource.gif;
 
+import com.bumptech.glide.load.engine.Initializable;
 import com.bumptech.glide.load.resource.drawable.DrawableResource;
 
 /**
  * A resource wrapping an {@link com.bumptech.glide.load.resource.gif.GifDrawable}.
  */
-public class GifDrawableResource extends DrawableResource<GifDrawable> {
+public class GifDrawableResource extends DrawableResource<GifDrawable>
+    implements Initializable {
   public GifDrawableResource(GifDrawable drawable) {
     super(drawable);
   }
@@ -25,4 +27,9 @@ public void recycle() {
     drawable.stop();
     drawable.recycle();
   }
+
+  @Override
+  public void initialize() {
+    drawable.getFirstFrame().prepareToDraw();
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
index b9fa47118..06b1a4fb4 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java
@@ -17,20 +17,32 @@
  */
 public class GifDrawableTransformation implements Transformation<GifDrawable> {
   private final Transformation<Bitmap> wrapped;
-  private final BitmapPool bitmapPool;
 
-  public GifDrawableTransformation(Context context, Transformation<Bitmap> wrapped) {
-    this(wrapped, Glide.get(context).getBitmapPool());
+  public GifDrawableTransformation(Transformation<Bitmap> wrapped) {
+    this.wrapped = Preconditions.checkNotNull(wrapped);
   }
 
-  public GifDrawableTransformation(Transformation<Bitmap> wrapped, BitmapPool bitmapPool) {
-    this.wrapped = Preconditions.checkNotNull(wrapped);
-    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);
+  /**
+   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}.
+   */
+  @Deprecated
+  public GifDrawableTransformation(
+      @SuppressWarnings("unused") Context context, Transformation<Bitmap> wrapped) {
+    this(wrapped);
+  }
+
+  /**
+   * @deprecated Use {@link #GifDrawableTransformation(Transformation)}
+   */
+  @Deprecated
+  public GifDrawableTransformation(
+      Transformation<Bitmap> wrapped, @SuppressWarnings("unused") BitmapPool bitmapPool) {
+    this(wrapped);
   }
 
   @Override
-  public Resource<GifDrawable> transform(Resource<GifDrawable> resource, int outWidth,
-      int outHeight) {
+  public Resource<GifDrawable> transform(
+      Context context, Resource<GifDrawable> resource, int outWidth, int outHeight) {
     GifDrawable drawable = resource.get();
 
     // The drawable needs to be initialized with the correct width and height in order for a view
@@ -38,9 +50,10 @@ public GifDrawableTransformation(Transformation<Bitmap> wrapped, BitmapPool bitm
     // modify the dimensions of our GIF, here we create a stand in for a frame and pass it to the
     // transformation to see what the final transformed dimensions will be so that our drawable can
     // report the correct intrinsic width and height.
+    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();
     Bitmap firstFrame = drawable.getFirstFrame();
     Resource<Bitmap> bitmapResource = new BitmapResource(firstFrame, bitmapPool);
-    Resource<Bitmap> transformed = wrapped.transform(bitmapResource, outWidth, outHeight);
+    Resource<Bitmap> transformed = wrapped.transform(context, bitmapResource, outWidth, outHeight);
     if (!bitmapResource.equals(transformed)) {
       bitmapResource.recycle();
     }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 61ef285c5..9ad656df5 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -3,7 +3,6 @@
 import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 import static com.bumptech.glide.request.RequestOptions.signatureOf;
 
-import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Looper;
@@ -32,13 +31,13 @@
 class GifFrameLoader {
   private final GifDecoder gifDecoder;
   private final Handler handler;
-  private final Context context;
   private final List<FrameCallback> callbacks = new ArrayList<>();
   @Synthetic final RequestManager requestManager;
   private final BitmapPool bitmapPool;
 
   private boolean isRunning = false;
   private boolean isLoadPending = false;
+  private boolean startFromFirstFrame = false;
   private RequestBuilder<Bitmap> requestBuilder;
   private DelayTarget current;
   private boolean isCleared;
@@ -58,7 +57,6 @@ public GifFrameLoader(
       Transformation<Bitmap> transformation,
       Bitmap firstFrame) {
     this(
-        glide.getContext(),
         glide.getBitmapPool(),
         Glide.with(glide.getContext()),
         gifDecoder,
@@ -70,7 +68,6 @@ public GifFrameLoader(
 
   @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
   GifFrameLoader(
-      Context context,
       BitmapPool bitmapPool,
       RequestManager requestManager,
       GifDecoder gifDecoder,
@@ -82,7 +79,6 @@ public GifFrameLoader(
     if (handler == null) {
       handler = new Handler(Looper.getMainLooper(), new FrameLoaderCallback());
     }
-    this.context = context;
     this.bitmapPool = bitmapPool;
     this.handler = handler;
     this.requestBuilder = requestBuilder;
@@ -95,7 +91,7 @@ public GifFrameLoader(
   void setFrameTransformation(Transformation<Bitmap> transformation, Bitmap firstFrame) {
     this.transformation = Preconditions.checkNotNull(transformation);
     this.firstFrame = Preconditions.checkNotNull(firstFrame);
-    requestBuilder = requestBuilder.apply(new RequestOptions().transform(context, transformation));
+    requestBuilder = requestBuilder.apply(new RequestOptions().transform(transformation));
   }
 
   Transformation<Bitmap> getFrameTransformation() {
@@ -157,7 +153,7 @@ int getFrameCount() {
   }
 
   int getLoopCount() {
-    return gifDecoder.getLoopCount();
+    return gifDecoder.getTotalIterationCount();
   }
 
   private void start() {
@@ -198,6 +194,10 @@ private void loadNextFrame() {
     if (!isRunning || isLoadPending) {
       return;
     }
+    if (startFromFirstFrame) {
+      gifDecoder.resetFrameIndex();
+      startFromFirstFrame = false;
+    }
     isLoadPending = true;
     // Get the delay before incrementing the pointer because the delay indicates the amount of time
     // we want to spend on the current frame.
@@ -216,6 +216,11 @@ private void recycleFirstFrame() {
     }
   }
 
+  void setNextStartFromFirstFrame() {
+    Preconditions.checkArgument(!isRunning, "Can't restart a running animation");
+    startFromFirstFrame = true;
+  }
+
   // Visible for testing.
   void onFrameReady(DelayTarget delayTarget) {
     if (isCleared) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
index 933c65698..4e887ed11 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java
@@ -25,8 +25,7 @@ public boolean handles(GifDecoder source, Options options) {
   }
 
   @Override
-  public Resource<Bitmap> decode(GifDecoder source, int width, int height,
-      Options options) {
+  public Resource<Bitmap> decode(GifDecoder source, int width, int height, Options options) {
     Bitmap bitmap = source.getNextFrame();
     return BitmapResource.obtain(bitmap, bitmapPool);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
index bd8b6d70e..baf4abc43 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java
@@ -1,17 +1,19 @@
 package com.bumptech.glide.load.resource.gif;
 
 import android.util.Log;
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.ImageHeaderParserUtils;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.List;
 
 /**
  * A relatively inefficient decoder for {@link com.bumptech.glide.load.resource.gif.GifDrawable}
@@ -28,11 +30,13 @@
   public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(
       "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);
 
+  private final List<ImageHeaderParser> parsers;
   private final ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;
   private final ArrayPool byteArrayPool;
 
-  public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder,
-      ArrayPool byteArrayPool) {
+  public StreamGifDecoder(List<ImageHeaderParser> parsers, ResourceDecoder<ByteBuffer,
+      GifDrawable> byteBufferDecoder, ArrayPool byteArrayPool) {
+    this.parsers = parsers;
     this.byteBufferDecoder = byteBufferDecoder;
     this.byteArrayPool = byteArrayPool;
   }
@@ -40,7 +44,7 @@ public StreamGifDecoder(ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecod
   @Override
   public boolean handles(InputStream source, Options options) throws IOException {
     return !options.get(DISABLE_ANIMATION)
-        && new ImageHeaderParser(source, byteArrayPool).getType() == ImageType.GIF;
+        && ImageHeaderParserUtils.getType(parsers, source, byteArrayPool) == ImageType.GIF;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
index 265550362..af6d7f599 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java
@@ -7,6 +7,7 @@
 import android.os.Build;
 import android.support.annotation.Nullable;
 import android.util.Log;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Synthetic;
 import java.util.Collections;
@@ -22,7 +23,6 @@
  * @see com.bumptech.glide.manager.RequestManagerRetriever
  * @see com.bumptech.glide.RequestManager
  */
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class RequestManagerFragment extends Fragment {
   private static final String TAG = "RMFragment";
   private final ActivityFragmentLifecycle lifecycle;
@@ -145,7 +145,7 @@ private boolean isDescendant(Fragment fragment) {
 
   private void registerFragmentWithRoot(Activity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = RequestManagerRetriever.get()
+    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getRequestManagerFragment(activity.getFragmentManager(), null);
     if (rootRequestManagerFragment != this) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index 141cdb70e..b07a23677 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -6,16 +6,24 @@
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.os.Build;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
+import android.support.v4.util.ArrayMap;
 import android.util.Log;
+import android.view.View;
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
+import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Util;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -28,14 +36,14 @@
   static final String FRAGMENT_TAG = "com.bumptech.glide.manager";
   private static final String TAG = "RMRetriever";
 
-  /**
-   * The singleton instance of RequestManagerRetriever.
-   */
-  private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();
-
   private static final int ID_REMOVE_FRAGMENT_MANAGER = 1;
   private static final int ID_REMOVE_SUPPORT_FRAGMENT_MANAGER = 2;
 
+  // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that
+  // allow us to iterate over and retrieve all active Fragments in a FragmentManager.
+  private static final String FRAGMENT_INDEX_KEY = "key";
+  private static final String FRAGMENT_MANAGER_GET_FRAGMENT_KEY = "i";
+
   /**
    * The top application level RequestManager.
    */
@@ -59,16 +67,16 @@
    * Main thread handler to handle cleaning up pending fragment maps.
    */
   private final Handler handler;
+  private final RequestManagerFactory factory;
 
-  /**
-   * Retrieves and returns the RequestManagerRetriever singleton.
-   */
-  public static RequestManagerRetriever get() {
-    return INSTANCE;
-  }
+  // Objects used to find Fragments and Activities containing views.
+  private final ArrayMap<View, Fragment> tempViewToSupportFragment = new ArrayMap<>();
+  private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();
+  private final Bundle tempBundle = new Bundle();
 
   // Visible for testing.
-  RequestManagerRetriever() {
+  public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
+    this.factory = factory != null ? factory : DEFAULT_FACTORY;
     handler = new Handler(Looper.getMainLooper(), this /* Callback */);
   }
 
@@ -85,8 +93,7 @@ private RequestManager getApplicationManager(Context context) {
           // TODO(b/27524013): Factor out this Glide.get() call.
           Glide glide = Glide.get(context);
           applicationManager =
-              new RequestManager(
-                  glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
+              factory.build(glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
         }
       }
     }
@@ -116,15 +123,13 @@ public RequestManager get(FragmentActivity activity) {
     } else {
       assertNotDestroyed(activity);
       FragmentManager fm = activity.getSupportFragmentManager();
-      return supportFragmentGet(activity, fm, null);
+      return supportFragmentGet(activity, fm, null /*parentHint*/);
     }
   }
 
   public RequestManager get(Fragment fragment) {
-    if (fragment.getActivity() == null) {
-      throw new IllegalArgumentException(
-          "You cannot start a load on a fragment before it is attached");
-    }
+    Preconditions.checkNotNull(fragment.getActivity(),
+          "You cannot start a load on a fragment before it is attached or after it is destroyed");
     if (Util.isOnBackgroundThread()) {
       return get(fragment.getActivity().getApplicationContext());
     } else {
@@ -133,14 +138,142 @@ public RequestManager get(Fragment fragment) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   public RequestManager get(Activity activity) {
-    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+    if (Util.isOnBackgroundThread()) {
       return get(activity.getApplicationContext());
     } else {
       assertNotDestroyed(activity);
       android.app.FragmentManager fm = activity.getFragmentManager();
-      return fragmentGet(activity, fm, null);
+      return fragmentGet(activity, fm, null /*parentHint*/);
+    }
+  }
+
+  public RequestManager get(View view) {
+    if (Util.isOnBackgroundThread()) {
+      return get(view.getContext().getApplicationContext());
+    }
+
+    Preconditions.checkNotNull(view);
+    Preconditions.checkNotNull(view.getContext(),
+        "Unable to obtain a request manager for a view without a Context");
+    Activity activity = findActivity(view.getContext());
+    // The view might be somewhere else, like a service.
+    if (activity == null) {
+      return get(view.getContext().getApplicationContext());
+    }
+
+    // Support Fragments.
+    if (activity instanceof FragmentActivity) {
+      Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
+      if (fragment == null) {
+        return get(activity);
+      }
+      return get(fragment);
+    }
+
+    // Standard Fragments.
+    android.app.Fragment fragment = findFragment(view, activity);
+    if (fragment == null) {
+      return get(activity);
+    }
+    return get(fragment);
+  }
+
+  private static void findAllSupportFragmentsWithViews(
+      @Nullable Collection<Fragment> topLevelFragments,
+      Map<View, Fragment> result) {
+    if (topLevelFragments == null) {
+      return;
+    }
+    for (Fragment fragment : topLevelFragments) {
+      if (fragment.getView() == null) {
+        continue;
+      }
+      result.put(fragment.getView(), fragment);
+      findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);
+    }
+  }
+
+  @Nullable
+  private Fragment findSupportFragment(View target, FragmentActivity activity) {
+    tempViewToSupportFragment.clear();
+    findAllSupportFragmentsWithViews(
+        activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
+    Fragment result = null;
+    View activityRoot = activity.findViewById(android.R.id.content);
+    View current = target;
+    while (!current.equals(activityRoot)) {
+      result = tempViewToSupportFragment.get(current);
+      if (result != null) {
+        break;
+      }
+      if (current.getParent() instanceof View) {
+        current = (View) current.getParent();
+      } else {
+        break;
+      }
+    }
+
+    tempViewToSupportFragment.clear();
+    return result;
+  }
+
+  @Nullable
+  private android.app.Fragment findFragment(View target, Activity activity) {
+    tempViewToFragment.clear();
+    findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);
+
+    android.app.Fragment result = null;
+
+    View activityRoot = activity.findViewById(android.R.id.content);
+    View current = target;
+     while (!current.equals(activityRoot)) {
+      result = tempViewToFragment.get(current);
+      if (result != null) {
+        break;
+      }
+      if (current.getParent() instanceof View) {
+        current = (View) current.getParent();
+      } else {
+        break;
+      }
+    }
+    tempViewToFragment.clear();
+    return result;
+  }
+
+  // TODO: Consider using an accessor class in the support library package to more directly retrieve
+  // non-support Fragments.
+  private void findAllFragmentsWithViews(
+      android.app.FragmentManager fragmentManager, ArrayMap<View, android.app.Fragment> result) {
+    int index = 0;
+    while (true) {
+      tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);
+      android.app.Fragment fragment = null;
+      try {
+        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_MANAGER_GET_FRAGMENT_KEY);
+      } catch (Exception e) {
+        // This generates log spam from FragmentManager anyway.
+      }
+      if (fragment == null) {
+        break;
+      }
+      if (fragment.getView() != null) {
+        result.put(fragment.getView(), fragment);
+        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) {
+          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);
+        }
+      }
+    }
+  }
+
+  private Activity findActivity(Context context) {
+    if (context instanceof Activity) {
+      return (Activity) context;
+    } else if (context instanceof ContextWrapper) {
+      return findActivity(((ContextWrapper) context).getBaseContext());
+    } else {
+      return null;
     }
   }
 
@@ -182,8 +315,7 @@ RequestManagerFragment getRequestManagerFragment(
     return current;
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
+  private RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
       android.app.Fragment parentHint) {
     RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
@@ -191,7 +323,7 @@ RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
       // TODO(b/27524013): Factor out this Glide.get() call.
       Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -214,14 +346,15 @@ SupportRequestManagerFragment getSupportRequestManagerFragment(
     return current;
   }
 
-  RequestManager supportFragmentGet(Context context, FragmentManager fm, Fragment parentHint) {
+  private RequestManager supportFragmentGet(Context context, FragmentManager fm,
+      Fragment parentHint) {
     SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
       // TODO(b/27524013): Factor out this Glide.get() call.
       Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
+          factory.build(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -252,4 +385,20 @@ public boolean handleMessage(Message message) {
     }
     return handled;
   }
+
+  /**
+   * Used internally to create {@link RequestManager}s.
+   */
+  public interface RequestManagerFactory {
+    RequestManager build(
+        Glide glide, Lifecycle lifecycle, RequestManagerTreeNode requestManagerTreeNode);
+  }
+
+  private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {
+    @Override
+    public RequestManager build(Glide glide, Lifecycle lifecycle,
+        RequestManagerTreeNode requestManagerTreeNode) {
+      return new RequestManager(glide, lifecycle, requestManagerTreeNode);
+    }
+  };
 }
diff --git a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
index 611747452..a61b3af9b 100644
--- a/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
+++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java
@@ -6,6 +6,7 @@
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Synthetic;
 import java.util.Collections;
@@ -134,7 +135,7 @@ private boolean isDescendant(Fragment fragment) {
 
   private void registerFragmentWithRoot(FragmentActivity activity) {
     unregisterFragmentWithRoot();
-    rootRequestManagerFragment = RequestManagerRetriever.get()
+    rootRequestManagerFragment = Glide.get(activity).getRequestManagerRetriever()
         .getSupportRequestManagerFragment(activity.getSupportFragmentManager(), null);
     if (rootRequestManagerFragment != this) {
       rootRequestManagerFragment.addChildRequestManagerFragment(this);
diff --git a/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
new file mode 100644
index 000000000..9d40b969c
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/AppGlideModule.java
@@ -0,0 +1,40 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.GlideBuilder;
+
+/**
+ * Defines a set of dependencies and options to use when initializing Glide within an application.
+ *
+ * <p>There can be at most one {@link AppGlideModule} in an application. Only Applications
+ * can include a {@link AppGlideModule}. Libraries must use {@link LibraryGlideModule}.
+ *
+ * <p>Classes that extend {@link AppGlideModule} must be annotated with
+ * {@link com.bumptech.glide.annotation.GlideModule} to be processed correctly.
+ *
+ * <p>Classes that extend {@link AppGlideModule} can optionally be annotated with
+ * {@link com.bumptech.glide.annotation.Excludes} to optionally exclude one or more
+ * {@link LibraryGlideModule} and/or {@link GlideModule} classes.
+ *
+ * <p>Once an application has migrated itself and all libraries it depends on to use Glide's
+ * annotation processor, {@link AppGlideModule} implementations should override
+ * {@link #isManifestParsingEnabled()} and return {@code false}.
+ */
+public abstract class AppGlideModule extends LibraryGlideModule implements AppliesOptions {
+  /**
+   * Returns {@code true} if Glide should check the AndroidManifest for {@link GlideModule}s.
+   *
+   * <p>Implementations should return {@code false} after they and their dependencies have migrated
+   * to Glide's annotation processor.
+   *
+   * <p>Returns {@code true} by default.
+   */
+  public boolean isManifestParsingEnabled() {
+    return true;
+  }
+
+  @Override
+  public void applyOptions(Context context, GlideBuilder builder) {
+    // Default empty impl.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
new file mode 100644
index 000000000..923d364f7
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/AppliesOptions.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.GlideBuilder;
+
+/**
+ * An internal interface, to be removed when {@link GlideModule}s are removed.
+ */
+interface AppliesOptions {
+  /**
+   * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
+   * singleton is created.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context An Application {@link android.content.Context}.
+   * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
+   */
+  void applyOptions(Context context, GlideBuilder builder);
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/GlideModule.java b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
index d587b74c1..b8e2108e6 100644
--- a/library/src/main/java/com/bumptech/glide/module/GlideModule.java
+++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.module;
 
-import android.content.Context;
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
 
 /**
@@ -52,28 +50,9 @@
  * applying conflicting settings in different modules. If an application depends on libraries that
  * have conflicting modules, the application should consider avoiding the library modules and
  * instead providing their required dependencies in a single application module. </p>
+ *
+ * @deprecated Libraries should use {@link LibraryGlideModule} and Applications should use
+ * {@link AppGlideModule}.
  */
-public interface GlideModule {
-
-  /**
-   * Lazily apply options to a {@link com.bumptech.glide.GlideBuilder} immediately before the Glide
-   * singleton is created.
-   *
-   * <p> This method will be called once and only once per implementation. </p>
-   *
-   * @param context An Application {@link android.content.Context}.
-   * @param builder The {@link com.bumptech.glide.GlideBuilder} that will be used to create Glide.
-   */
-  void applyOptions(Context context, GlideBuilder builder);
-
-  /**
-   * Lazily register components immediately after the Glide singleton is created but before any
-   * requests can be started.
-   *
-   * <p> This method will be called once and only once per implementation. </p>
-   *
-   * @param context  An Application {@link android.content.Context}.
-   * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
-   */
-  void registerComponents(Context context, Registry registry);
-}
+@Deprecated
+public interface GlideModule extends RegistersComponents, AppliesOptions { }
diff --git a/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
new file mode 100644
index 000000000..f543d3729
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/LibraryGlideModule.java
@@ -0,0 +1,22 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+
+/**
+ * Registers a set of components to use when initializing Glide within an app when
+ * Glide's annotation processor is used.
+ *
+ * <p>Any number of LibraryGlideModules can be contained within any library or application.
+ *
+ * <p>LibraryGlideModules are called in no defined order. If LibraryGlideModules within an
+ * application conflict, {@link AppGlideModule}s can use the
+ * {@link com.bumptech.glide.annotation.Excludes} annotation to selectively remove one or more of
+ * the conflicting modules.
+ */
+public abstract class LibraryGlideModule implements RegistersComponents {
+  @Override
+  public void registerComponents(Context context, Registry registry) {
+    // Default empty impl.
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index ce01040bd..9b0eb69a8 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -20,6 +20,7 @@ public ManifestParser(Context context) {
     this.context = context;
   }
 
+  @SuppressWarnings("deprecation")
   public List<GlideModule> parse() {
     if (Log.isLoggable(TAG, Log.DEBUG)) {
       Log.d(TAG, "Loading Glide modules");
@@ -29,8 +30,14 @@ public ManifestParser(Context context) {
       ApplicationInfo appInfo = context.getPackageManager()
           .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
       if (appInfo.metaData == null) {
+        if (Log.isLoggable(TAG, Log.DEBUG)) {
+          Log.d(TAG, "Got null app info metadata");
+        }
         return modules;
       }
+      if (Log.isLoggable(TAG, Log.VERBOSE)) {
+        Log.v(TAG, "Got app info metadata: " + appInfo.metaData);
+      }
       for (String key : appInfo.metaData.keySet()) {
         if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
           modules.add(parseModule(key));
@@ -49,6 +56,7 @@ public ManifestParser(Context context) {
     return modules;
   }
 
+  @SuppressWarnings("deprecation")
   private static GlideModule parseModule(String className) {
     Class<?> clazz;
     try {
@@ -60,9 +68,13 @@ private static GlideModule parseModule(String className) {
     Object module;
     try {
       module = clazz.newInstance();
-    } catch (InstantiationException | IllegalAccessException e) {
+    } catch (InstantiationException e) {
+      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
+              e);
+      // These can't be combined until API minimum is 19.
+    } catch (IllegalAccessException e) {
       throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,
-          e);
+              e);
     }
 
     if (!(module instanceof GlideModule)) {
diff --git a/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
new file mode 100644
index 000000000..1c6d8c9b8
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java
@@ -0,0 +1,21 @@
+package com.bumptech.glide.module;
+
+import android.content.Context;
+import com.bumptech.glide.Registry;
+
+/**
+ * An internal interface, to be removed when {@link GlideModule}s are removed.
+ */
+interface RegistersComponents {
+
+  /**
+   * Lazily register components immediately after the Glide singleton is created but before any
+   * requests can be started.
+   *
+   * <p> This method will be called once and only once per implementation. </p>
+   *
+   * @param context  An Application {@link android.content.Context}.
+   * @param registry An {@link com.bumptech.glide.Registry} to use to register components.
+   */
+  void registerComponents(Context context, Registry registry);
+}
diff --git a/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
new file mode 100644
index 000000000..af329320e
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/provider/ImageHeaderParserRegistry.java
@@ -0,0 +1,20 @@
+package com.bumptech.glide.provider;
+
+import com.bumptech.glide.load.ImageHeaderParser;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Contains an unordered list of {@link ImageHeaderParser}s capable of parsing image headers.
+ */
+public final class ImageHeaderParserRegistry {
+  private final List<ImageHeaderParser> parsers = new ArrayList<>();
+
+  public synchronized List<ImageHeaderParser> getParsers() {
+    return parsers;
+  }
+
+  public synchronized void add(ImageHeaderParser parser) {
+    parsers.add(parser);
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
deleted file mode 100644
index 0bab50800..000000000
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ /dev/null
@@ -1,963 +0,0 @@
-package com.bumptech.glide.request;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import com.bumptech.glide.Priority;
-import com.bumptech.glide.load.DecodeFormat;
-import com.bumptech.glide.load.Key;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.Transformation;
-import com.bumptech.glide.load.engine.DiskCacheStrategy;
-import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
-import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
-import com.bumptech.glide.load.resource.bitmap.CenterCrop;
-import com.bumptech.glide.load.resource.bitmap.CenterInside;
-import com.bumptech.glide.load.resource.bitmap.CircleCrop;
-import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
-import com.bumptech.glide.load.resource.bitmap.Downsampler;
-import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
-import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
-import com.bumptech.glide.load.resource.gif.GifDrawable;
-import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
-import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
-import com.bumptech.glide.signature.EmptySignature;
-import com.bumptech.glide.util.Preconditions;
-import com.bumptech.glide.util.Util;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Contains and exposes a variety of non type specific options that can be applied to a load in
- * Glide.
- *
- * <p> If {@link #lock()} has been called, this class will throw if any further mutations are
- * attempted. To unlock, use {@link #clone()}. </p>
- *
- * @param <CHILD> The concrete and <em>final</em> subclass.
- */
-public abstract class BaseRequestOptions<CHILD extends BaseRequestOptions<CHILD>>
-    implements Cloneable {
-  private static final int UNSET = -1;
-  private static final int SIZE_MULTIPLIER = 1 << 1;
-  private static final int DISK_CACHE_STRATEGY = 1 << 2;
-  private static final int PRIORITY = 1 << 3;
-  private static final int ERROR_PLACEHOLDER = 1 << 4;
-  private static final int ERROR_ID = 1 << 5;
-  private static final int PLACEHOLDER = 1 << 6;
-  private static final int PLACEHOLDER_ID = 1 << 7;
-  private static final int IS_CACHEABLE = 1 << 8;
-  private static final int OVERRIDE = 1 << 9;
-  private static final int SIGNATURE = 1 << 10;
-  private static final int TRANSFORMATION = 1 << 11;
-  private static final int RESOURCE_CLASS = 1 << 12;
-  private static final int FALLBACK = 1 << 13;
-  private static final int FALLBACK_ID = 1 << 14;
-  private static final int THEME = 1 << 15;
-  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
-  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
-  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
-
-  private int fields;
-
-  private float sizeMultiplier = 1f;
-  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
-  private Priority priority = Priority.NORMAL;
-  private Drawable errorPlaceholder;
-  private int errorId;
-  private Drawable placeholderDrawable;
-  private int placeholderId;
-  private boolean isCacheable = true;
-  private int overrideHeight = UNSET;
-  private int overrideWidth = UNSET;
-  private Key signature = EmptySignature.obtain();
-  private boolean isTransformationRequired;
-  private boolean isTransformationAllowed = true;
-  private Drawable fallbackDrawable;
-  private int fallbackId;
-
-  private Options options = new Options();
-  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
-  private Class<?> resourceClass = Object.class;
-  private boolean isLocked;
-  private Resources.Theme theme;
-  private boolean isAutoCloneEnabled;
-  private boolean useUnlimitedSourceGeneratorsPool;
-
-  /**
-   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
-   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
-   * (particularly {@link android.graphics.Bitmap}s on devices with overly dense screens.
-   *
-   * @param sizeMultiplier The multiplier to apply to the
-   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
-   *                       loading the resource.
-   * @return This request builder.
-   */
-  public final CHILD sizeMultiplier(float sizeMultiplier) {
-    if (isAutoCloneEnabled) {
-      return clone().sizeMultiplier(sizeMultiplier);
-    }
-
-    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
-      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
-    }
-    this.sizeMultiplier = sizeMultiplier;
-    fields |= SIZE_MULTIPLIER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  public final CHILD useUnlimitedSourceGeneratorsPool(boolean flag) {
-    if (isAutoCloneEnabled) {
-      return clone().useUnlimitedSourceGeneratorsPool(flag);
-    }
-
-    this.useUnlimitedSourceGeneratorsPool = flag;
-    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load.
-   *
-   * <p> Defaults to {@link com.bumptech.glide.load.engine.DiskCacheStrategy#AUTOMATIC}. </p>
-   *
-   * <p> For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} is
-   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
-   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
-   * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#DATA} or
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}. </p>
-   *
-   * @param strategy The strategy to use.
-   * @return This request builder.
-   */
-  public final CHILD diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
-    if (isAutoCloneEnabled) {
-      return clone().diskCacheStrategy(strategy);
-    }
-    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
-    fields |= DISK_CACHE_STRATEGY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the priority for this load.
-   *
-   * @param priority A priority.
-   * @return This request builder.
-   */
-  public final CHILD priority(@NonNull Priority priority) {
-    if (isAutoCloneEnabled) {
-      return clone().priority(priority);
-    }
-
-    this.priority = Preconditions.checkNotNull(priority);
-    fields |= PRIORITY;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD placeholder(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(drawable);
-    }
-
-    this.placeholderDrawable = drawable;
-    fields |= PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resource to
-   * display while a resource is loading.
-   *
-   * @param resourceId The id of the resource to use as a placeholder
-   * @return This request builder.
-   */
-  public final CHILD placeholder(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().placeholder(resourceId);
-    }
-
-    this.placeholderId = resourceId;
-    fields |= PLACEHOLDER_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets an {@link android.graphics.drawable.Drawable} to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
-   * error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param drawable The drawable to display as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD fallback(Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(drawable);
-    }
-
-    this.fallbackDrawable = drawable;
-    fields |= FALLBACK;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if the model provided to
-   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
-   *
-   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
-   * the error drawable is not set, the placeholder will be displayed.
-   *
-   * @see #placeholder(Drawable)
-   * @see #placeholder(int)
-   *
-   * @param resourceId The id of the resource to use as a fallback.
-   * @return This request builder.
-   */
-  public final CHILD fallback(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().fallback(resourceId);
-    }
-
-    this.fallbackId = resourceId;
-    fields |= FALLBACK_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a {@link Drawable} to display if a load fails.
-   *
-   * @param drawable The drawable to display.
-   * @return This request builder.
-   */
-  public final CHILD error(@Nullable Drawable drawable) {
-    if (isAutoCloneEnabled) {
-      return clone().error(drawable);
-    }
-
-    this.errorPlaceholder = drawable;
-    fields |= ERROR_PLACEHOLDER;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets a resource to display if a load fails.
-   *
-   * @param resourceId The id of the resource to use as a placeholder.
-   * @return This request builder.
-   */
-  public final CHILD error(int resourceId) {
-    if (isAutoCloneEnabled) {
-      return clone().error(resourceId);
-    }
-    this.errorId = resourceId;
-    fields |= ERROR_ID;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
-   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
-   * {@link #fallback(Drawable)}.
-   *
-   * @param theme The theme to use when loading Drawables.
-   * @return this request builder.
-   */
-  public final CHILD theme(Resources.Theme theme) {
-    if (isAutoCloneEnabled) {
-      return clone().theme(theme);
-    }
-
-    this.theme = theme;
-    fields |= THEME;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Allows the loaded resource to skip the memory cache.
-   *
-   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
-   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
-   *
-   * @param skip True to allow the resource to skip the memory cache.
-   * @return This request builder.
-   */
-  public final CHILD skipMemoryCache(boolean skip) {
-    if (isAutoCloneEnabled) {
-      return clone().skipMemoryCache(true);
-    }
-
-    this.isCacheable = !skip;
-    fields |= IS_CACHEABLE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given values. This is useful for thumbnails, and should only be used for other cases when you
-   * need a very specific image size.
-   *
-   * @param width  The width in pixels to use to load the resource.
-   * @param height The height in pixels to use to load the resource.
-   * @return This request builder.
-   */
-  public final CHILD override(int width, int height) {
-    if (isAutoCloneEnabled) {
-      return clone().override(width, height);
-    }
-
-    this.overrideWidth = width;
-    this.overrideHeight = height;
-    fields |= OVERRIDE;
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
-   * given size.
-   *
-   * @see #override(int, int)
-   * @param size The width and height to use.
-   * @return This request builder.
-   */
-  public final CHILD override(int size) {
-    return override(size, size);
-  }
-
-  /**
-   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
-   * more control over when cached data is invalidated.
-   *
-   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
-   *
-   * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current
-   *                  state of the model that will be mixed in to the cache key.
-   * @return This request builder.
-   * @see com.bumptech.glide.signature.ObjectKey
-   */
-  public final CHILD signature(@NonNull Key signature) {
-    if (isAutoCloneEnabled) {
-      return clone().signature(signature);
-    }
-
-    this.signature = Preconditions.checkNotNull(signature);
-    fields |= SIGNATURE;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Returns a copy of this request builder with all of the options put so far on this builder.
-   *
-   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
-   * changes to one builder will not affect the other builder. However, in addition to immutable
-   * arguments, the current model is not copied copied so changes to the model will affect both
-   * builders. </p>
-   *
-   * <p> Even if this object was locked, the cloned object returned from this method will not be
-   * locked. </p>
-   */
-  @SuppressWarnings("unchecked")
-  @Override
-  public final CHILD clone() {
-    try {
-      BaseRequestOptions<CHILD> result = (BaseRequestOptions<CHILD>) super.clone();
-      result.options = new Options();
-      result.options.putAll(options);
-      result.transformations = new HashMap<>();
-      result.transformations.putAll(transformations);
-      result.isLocked = false;
-      result.isAutoCloneEnabled = false;
-      return (CHILD) result;
-    } catch (CloneNotSupportedException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public final <T> CHILD set(@NonNull Option<T> option, @NonNull T value) {
-    if (isAutoCloneEnabled) {
-      return clone().set(option, value);
-    }
-
-    Preconditions.checkNotNull(option);
-    Preconditions.checkNotNull(value);
-    options.set(option, value);
-    return selfOrThrowIfLocked();
-  }
-
-  public final CHILD decode(@NonNull Class<?> resourceClass) {
-    if (isAutoCloneEnabled) {
-      return clone().decode(resourceClass);
-    }
-
-    this.resourceClass = Preconditions.checkNotNull(resourceClass);
-    fields |= RESOURCE_CLASS;
-    return selfOrThrowIfLocked();
-  }
-
-  public final boolean isTransformationAllowed() {
-    return isTransformationAllowed;
-  }
-
-  public final boolean isTransformationSet() {
-    return isSet(TRANSFORMATION);
-  }
-
-  public final boolean isLocked() {
-    return isLocked;
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
-   */
-  public CHILD encodeFormat(@NonNull Bitmap.CompressFormat format) {
-    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the value for key
-   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_QUALITY}.
-   */
-  public CHILD encodeQuality(int quality) {
-    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
-  }
-
-  /**
-   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
-   * {@link Downsampler}.
-   *
-   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
-   * decoded using a decoder that cannot control the format
-   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
-   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
-   * image has alpha).
-   */
-  public CHILD format(@NonNull DecodeFormat format) {
-    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
-  }
-
-  /**
-   * Sets the time position of the frame to extract from a video.
-   *
-   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
-   *                        Android framework implementation return a representative frame.
-   */
-  public CHILD frame(long frameTimeMicros) {
-    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
-  }
-
-  /**
-   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
-   * {@link Downsampler}.
-   */
-  public CHILD downsample(@NonNull DownsampleStrategy strategy) {
-    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerCrop(android.content.Context)
-   */
-  public CHILD optionalCenterCrop(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalCenterCrop(android.content.Context)
-   */
-  public CHILD centerCrop(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #fitCenter(android.content.Context)
-   */
-  public CHILD optionalFitCenter(Context context) {
-    return optionalTransform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalFitCenter(android.content.Context)
-   */
-  public CHILD fitCenter(Context context) {
-    return transform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
-   * ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   * @see #centerInside(Context) (android.content.Context)
-   */
-  public CHILD optionalCenterInside(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));
-  }
-
-  /**
-   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types and
-   * throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link android.content.Context}.
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   * @see #optionalCenterInside(Context) (android.content.Context)
-   */
-  public CHILD centerInside(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link Context}.
-   * @see #optionalTransform(Context, Transformation)
-   * @see #circleCrop(Context)
-   */
-  public CHILD optionalCircleCrop(Context context) {
-    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));
-  }
-
-  /**
-   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
-   * an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context Any {@link Context}.
-   * @see #transform(Class, Transformation)
-   * @see #optionalCenterCrop(Context)
-   */
-  public CHILD circleCrop(Context context) {
-    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));
-  }
-
-  final CHILD optionalTransform(Context context, DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(context, downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return optionalTransform(context, transformation);
-  }
-
-  final CHILD transform(Context context, DownsampleStrategy downsampleStrategy,
-      Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(context, downsampleStrategy, transformation);
-    }
-
-    downsample(downsampleStrategy);
-    return transform(context, transformation);
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
-   * and throws an exception if asked to transform an unknown type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context        Any {@link android.content.Context}.
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #optionalTransform(android.content.Context, com.bumptech.glide.load.Transformation)
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public CHILD transform(Context context, @NonNull Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(context, transformation);
-    }
-
-    optionalTransform(context, transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for
-   * {@link android.graphics.Bitmap Bitmaps} to the default types ({@link android.graphics.Bitmap},
-   * {@link android.graphics.drawable.BitmapDrawable}, and
-   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param context        Any {@link android.content.Context}.
-   * @param transformation Any {@link com.bumptech.glide.load.Transformation} for
-   *                       {@link android.graphics.Bitmap}s.
-   * @see #transform(android.content.Context, com.bumptech.glide.load.Transformation)
-   * @see #transform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public CHILD optionalTransform(Context context, Transformation<Bitmap> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(context, transformation);
-    }
-
-    optionalTransform(Bitmap.class, transformation);
-    // TODO: remove BitmapDrawable decoder and this transformation.
-    optionalTransform(BitmapDrawable.class,
-        new BitmapDrawableTransformation(context, transformation));
-    optionalTransform(GifDrawable.class, new GifDrawableTransformation(context, transformation));
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and allows unknown resource types to be ignored.
-   *
-   * <p> Users can apply different transformations for each resource class. Applying a
-   * {@link com.bumptech.glide.load.Transformation} for a resource type that already has a
-   * {@link com.bumptech.glide.load.Transformation} will override the previous call. </p>
-   *
-   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
-   * an unknown resource class will throw an exception. To allow unknown types, users must always
-   * call the optional version of each method. </p>
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   */
-  public final <T> CHILD optionalTransform(Class<T> resourceClass,
-      Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().optionalTransform(resourceClass, transformation);
-    }
-
-    Preconditions.checkNotNull(resourceClass);
-    Preconditions.checkNotNull(transformation);
-    transformations.put(resourceClass, transformation);
-    fields |= TRANSFORMATION;
-    isTransformationAllowed = true;
-    fields |= TRANSFORMATION_ALLOWED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Applies the given {@link com.bumptech.glide.load.Transformation} for any decoded resource of
-   * the given type and throws if asked to transform an unknown resource type.
-   *
-   * <p>This will override previous calls to {@link #dontTransform()}.
-   *
-   * @param resourceClass  The type of resource to transform.
-   * @param transformation The {@link com.bumptech.glide.load.Transformation} to apply.
-   * @see #optionalTransform(Class, com.bumptech.glide.load.Transformation)
-   */
-  public final <T> CHILD transform(Class<T> resourceClass, Transformation<T> transformation) {
-    if (isAutoCloneEnabled) {
-      return clone().transform(resourceClass, transformation);
-    }
-
-    optionalTransform(resourceClass, transformation);
-    isTransformationRequired = true;
-    fields |= TRANSFORMATION_REQUIRED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Removes all applied {@link com.bumptech.glide.load.Transformation Transformations} for all
-   * resource classes and allows unknown resource types to be transformed without throwing an
-   * exception.
-   */
-  public final CHILD dontTransform() {
-    if (isAutoCloneEnabled) {
-      return clone().dontTransform();
-    }
-
-    transformations.clear();
-    fields &= ~TRANSFORMATION;
-    isTransformationRequired = false;
-    fields &= ~TRANSFORMATION_REQUIRED;
-    isTransformationAllowed = false;
-    fields |= TRANSFORMATION_ALLOWED;
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Disables resource decoders that return animated resources so any resource returned will be
-   * static.
-   *
-   * <p> To disable transitions (fades etc) use
-   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
-   */
-  public final CHILD dontAnimate() {
-    if (isAutoCloneEnabled) {
-      return clone().dontAnimate();
-    }
-
-    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
-    set(StreamGifDecoder.DISABLE_ANIMATION, true);
-    return selfOrThrowIfLocked();
-  }
-
-  public final CHILD apply(BaseRequestOptions<?> other) {
-    if (isAutoCloneEnabled) {
-      return clone().apply(other);
-    }
-
-    if (isSet(other.fields, SIZE_MULTIPLIER)) {
-      sizeMultiplier = other.sizeMultiplier;
-    }
-    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
-      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
-    }
-    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
-      diskCacheStrategy = other.diskCacheStrategy;
-    }
-    if (isSet(other.fields, PRIORITY)) {
-      priority = other.priority;
-    }
-    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
-      errorPlaceholder = other.errorPlaceholder;
-    }
-    if (isSet(other.fields, ERROR_ID)) {
-      errorId = other.errorId;
-    }
-    if (isSet(other.fields, PLACEHOLDER)) {
-      placeholderDrawable = other.placeholderDrawable;
-    }
-    if (isSet(other.fields, PLACEHOLDER_ID)) {
-      placeholderId = other.placeholderId;
-    }
-    if (isSet(other.fields, IS_CACHEABLE)) {
-      isCacheable = other.isCacheable;
-    }
-    if (isSet(other.fields, OVERRIDE)) {
-      overrideWidth = other.overrideWidth;
-      overrideHeight = other.overrideHeight;
-    }
-    if (isSet(other.fields, SIGNATURE)) {
-      signature = other.signature;
-    }
-    if (isSet(other.fields, RESOURCE_CLASS)) {
-      resourceClass = other.resourceClass;
-    }
-    if (isSet(other.fields, FALLBACK)) {
-      fallbackDrawable = other.fallbackDrawable;
-    }
-    if (isSet(other.fields, FALLBACK_ID)) {
-      fallbackId = other.fallbackId;
-    }
-    if (isSet(other.fields, THEME)) {
-      theme = other.theme;
-    }
-    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
-      isTransformationAllowed = other.isTransformationAllowed;
-    }
-    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
-      isTransformationRequired = other.isTransformationRequired;
-    }
-    if (isSet(other.fields, TRANSFORMATION)) {
-      transformations.putAll(other.transformations);
-    }
-
-    // Applying options with dontTransform() is expected to clear our transformations.
-    if (!isTransformationAllowed) {
-      transformations.clear();
-      fields &= ~TRANSFORMATION;
-      isTransformationRequired = false;
-      fields &= ~TRANSFORMATION_REQUIRED;
-    }
-
-    fields |= other.fields;
-    options.putAll(other.options);
-
-    return selfOrThrowIfLocked();
-  }
-
-  /**
-   * Throws if any further mutations are attempted.
-   *
-   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
-   */
-  @SuppressWarnings("unchecked")
-  public final CHILD lock() {
-    isLocked = true;
-    // This is the only place we should not check locked.
-    return (CHILD) this;
-  }
-
-  /**
-   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
-   * before the mutation resulting in all methods returning a new Object and leaving the original
-   * locked object unmodified.
-   *
-   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
-   * are mutable and are not locked.
-   */
-  public final CHILD autoLock() {
-    if (isLocked && !isAutoCloneEnabled) {
-      throw new IllegalStateException("You cannot auto lock an already locked options object"
-          + ", try clone() first");
-    }
-    isAutoCloneEnabled = true;
-    return lock();
-  }
-
-  @SuppressWarnings("unchecked")
-  private CHILD selfOrThrowIfLocked() {
-    if (isLocked) {
-      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
-    }
-    return (CHILD) this;
-  }
-
-  public final Map<Class<?>, Transformation<?>> getTransformations() {
-    return transformations;
-  }
-
-  public final boolean isTransformationRequired() {
-    return isTransformationRequired;
-  }
-
-  public final Options getOptions() {
-    return options;
-  }
-
-  public final Class<?> getResourceClass() {
-    return resourceClass;
-  }
-
-  public final DiskCacheStrategy getDiskCacheStrategy() {
-    return diskCacheStrategy;
-  }
-
-  public final Drawable getErrorPlaceholder() {
-    return errorPlaceholder;
-  }
-
-  public final int getErrorId() {
-    return errorId;
-  }
-
-  public final int getPlaceholderId() {
-    return placeholderId;
-  }
-
-  public final Drawable getPlaceholderDrawable() {
-    return placeholderDrawable;
-  }
-
-  public final int getFallbackId() {
-    return fallbackId;
-  }
-
-  public final Drawable getFallbackDrawable() {
-    return fallbackDrawable;
-  }
-
-  public final Resources.Theme getTheme() {
-    return theme;
-  }
-
-  public final boolean isMemoryCacheable() {
-    return isCacheable;
-  }
-
-  public final Key getSignature() {
-    return signature;
-  }
-
-  public final boolean isPrioritySet() {
-    return isSet(PRIORITY);
-  }
-
-  public final Priority getPriority() {
-    return priority;
-  }
-
-  public final int getOverrideWidth() {
-    return overrideWidth;
-  }
-
-  public final boolean isValidOverride() {
-    return Util.isValidDimensions(overrideWidth, overrideHeight);
-  }
-
-  public final int getOverrideHeight() {
-    return overrideHeight;
-  }
-
-  public final float getSizeMultiplier() {
-    return sizeMultiplier;
-  }
-
-  private boolean isSet(int flag) {
-    return isSet(fields, flag);
-  }
-
-  private static boolean isSet(int fields, int flag) {
-    return (fields & flag) != 0;
-  }
-
-  public final boolean getUseUnlimitedSourceGeneratorsPool() {
-    return useUnlimitedSourceGeneratorsPool;
-  }
-}
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 5292c24ab..4ba29827f 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -81,17 +81,15 @@ public RequestFutureTarget(Handler mainHandler, int width, int height) {
 
   @Override
   public synchronized boolean cancel(boolean mayInterruptIfRunning) {
-    if (isCancelled) {
-      return true;
+    if (isDone()) {
+      return false;
     }
-
-    final boolean result = !isDone();
-    if (result) {
-      isCancelled = true;
-      waiter.notifyAll(this);
+    isCancelled = true;
+    waiter.notifyAll(this);
+    if (mayInterruptIfRunning) {
+      clearOnMainThread();
     }
-    clearOnMainThread();
-    return result;
+    return true;
   }
 
   @Override
@@ -127,6 +125,11 @@ public void getSize(SizeReadyCallback cb) {
     cb.onSizeReady(width, height);
   }
 
+  @Override
+  public void removeCallback(SizeReadyCallback cb) {
+    // Do nothing because we do not retain references to SizeReadyCallbacks.
+  }
+
   /**
    * {@inheritDoc}
    */
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index 1ed0cb125..e796c58cb 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -1,7 +1,9 @@
 package com.bumptech.glide.request;
 
 import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -9,18 +11,53 @@
 import com.bumptech.glide.load.DecodeFormat;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.bitmap.BitmapDrawableTransformation;
+import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
+import com.bumptech.glide.load.resource.bitmap.CenterCrop;
+import com.bumptech.glide.load.resource.bitmap.CenterInside;
+import com.bumptech.glide.load.resource.bitmap.CircleCrop;
 import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;
+import com.bumptech.glide.load.resource.bitmap.Downsampler;
+import com.bumptech.glide.load.resource.bitmap.FitCenter;
+import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
+import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
+import com.bumptech.glide.signature.EmptySignature;
+import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
- * The standard concrete implementation of {@link com.bumptech.glide.request.BaseRequestOptions}.
- *
- * <p> Uses with custom types, transformations, or options can subclass and customize. {@link
- * com.bumptech.glide.request.BaseRequestOptions}. </p>
+ * Provides type independent options to customize loads with Glide.
  */
 @SuppressWarnings({"PMD.UseUtilityClass", "unused"})
-public final class RequestOptions extends BaseRequestOptions<RequestOptions> {
+public class RequestOptions implements Cloneable {
+  private static final int UNSET = -1;
+  private static final int SIZE_MULTIPLIER = 1 << 1;
+  private static final int DISK_CACHE_STRATEGY = 1 << 2;
+  private static final int PRIORITY = 1 << 3;
+  private static final int ERROR_PLACEHOLDER = 1 << 4;
+  private static final int ERROR_ID = 1 << 5;
+  private static final int PLACEHOLDER = 1 << 6;
+  private static final int PLACEHOLDER_ID = 1 << 7;
+  private static final int IS_CACHEABLE = 1 << 8;
+  private static final int OVERRIDE = 1 << 9;
+  private static final int SIGNATURE = 1 << 10;
+  private static final int TRANSFORMATION = 1 << 11;
+  private static final int RESOURCE_CLASS = 1 << 12;
+  private static final int FALLBACK = 1 << 13;
+  private static final int FALLBACK_ID = 1 << 14;
+  private static final int THEME = 1 << 15;
+  private static final int TRANSFORMATION_ALLOWED = 1 << 16;
+  private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
+  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
 
   private static RequestOptions skipMemoryCacheTrueOptions;
   private static RequestOptions skipMemoryCacheFalseOptions;
@@ -31,6 +68,31 @@
   private static RequestOptions noTransformOptions;
   private static RequestOptions noAnimationOptions;
 
+  private int fields;
+  private float sizeMultiplier = 1f;
+  private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.AUTOMATIC;
+  private Priority priority = Priority.NORMAL;
+  private Drawable errorPlaceholder;
+  private int errorId;
+  private Drawable placeholderDrawable;
+  private int placeholderId;
+  private boolean isCacheable = true;
+  private int overrideHeight = RequestOptions.UNSET;
+  private int overrideWidth = RequestOptions.UNSET;
+  private Key signature = EmptySignature.obtain();
+  private boolean isTransformationRequired;
+  private boolean isTransformationAllowed = true;
+  private Drawable fallbackDrawable;
+  private int fallbackId;
+  private Options options = new Options();
+  private Map<Class<?>, Transformation<?>> transformations = new HashMap<>();
+  private Class<?> resourceClass = Object.class;
+  private boolean isLocked;
+  private Resources.Theme theme;
+  private boolean isAutoCloneEnabled;
+  private boolean useUnlimitedSourceGeneratorsPool;
+  private boolean onlyRetrieveFromCache;
+
   /**
    * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
    */
@@ -86,12 +148,12 @@ public static RequestOptions errorOf(int errorId) {
   public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
     if (skipMemoryCache) {
       if (skipMemoryCacheTrueOptions == null) {
-        skipMemoryCacheTrueOptions = new RequestOptions().skipMemoryCache(true).autoLock();
+        skipMemoryCacheTrueOptions = new RequestOptions().skipMemoryCache(true).autoClone();
       }
       return skipMemoryCacheTrueOptions;
     } else {
       if (skipMemoryCacheFalseOptions == null) {
-        skipMemoryCacheFalseOptions = new RequestOptions().skipMemoryCache(false).autoLock();
+        skipMemoryCacheFalseOptions = new RequestOptions().skipMemoryCache(false).autoClone();
       }
       return skipMemoryCacheFalseOptions;
     }
@@ -120,69 +182,89 @@ public static RequestOptions signatureOf(@NonNull Key signature) {
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #fitCenter(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link #fitCenter()} set.
    */
-  public static RequestOptions fitCenterTransform(Context context) {
+  public static RequestOptions fitCenterTransform() {
     if (fitCenterOptions == null) {
       fitCenterOptions = new RequestOptions()
-          .fitCenter(context.getApplicationContext())
-          .autoLock();
+          .fitCenter()
+          .autoClone();
     }
     return fitCenterOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #centerInside(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link #centerInside()} set.
    */
-  public static RequestOptions centerInsideTransform(Context context) {
+  public static RequestOptions centerInsideTransform() {
     if (centerInsideOptions == null) {
       centerInsideOptions = new RequestOptions()
-              .centerInside(context.getApplicationContext())
-              .autoLock();
+              .centerInside()
+              .autoClone();
     }
     return centerInsideOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #circleCrop(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link #centerCrop()} set.
    */
-  public static RequestOptions centerCropTransform(Context context) {
+  public static RequestOptions centerCropTransform() {
     if (centerCropOptions == null) {
       centerCropOptions = new RequestOptions()
-          .centerCrop(context.getApplicationContext())
-          .autoLock();
+          .centerCrop()
+          .autoClone();
     }
     return centerCropOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop(Context)} set.
+   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop()} set.
    */
-  public static RequestOptions circleCropTransform(Context context) {
+  public static RequestOptions circleCropTransform() {
     if (circleCropOptions == null) {
       circleCropOptions = new RequestOptions()
-          .circleCrop(context.getApplicationContext())
-          .autoLock();
+          .circleCrop()
+          .autoClone();
     }
     return circleCropOptions;
   }
 
   /**
-   * Returns a {@link RequestOptions} object with {@link #transform(Context, Transformation)} set.
+   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
+   *
+   * @deprecated Use {@link #bitmapTransform(Transformation)}.
+   */
+  @Deprecated
+  public static RequestOptions bitmapTransform(
+      Context context, @NonNull Transformation<Bitmap> transformation) {
+    return bitmapTransform(transformation);
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #transform(Transformation)} set.
    */
-  public static RequestOptions bitmapTransform(Context context,
-      @NonNull Transformation<Bitmap> transformation) {
-    return new RequestOptions().transform(context, transformation);
+  public static RequestOptions bitmapTransform(@NonNull Transformation<Bitmap> transformation) {
+    return new RequestOptions().transform(transformation);
   }
 
   /**
    * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
+   *
+   * @deprecated use {@link #noTransformation()}
    */
+  @Deprecated
   public static RequestOptions noTransform() {
+    return noTransformation();
+  }
+
+  /**
+   * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.
+   */
+  public static RequestOptions noTransformation() {
     if (noTransformOptions == null) {
       noTransformOptions = new RequestOptions()
           .dontTransform()
-          .autoLock();
+          .autoClone();
     }
     return noTransformOptions;
   }
@@ -247,8 +329,966 @@ public static RequestOptions noAnimation() {
     if (noAnimationOptions == null) {
       noAnimationOptions = new RequestOptions()
           .dontAnimate()
-          .autoLock();
+          .autoClone();
     }
     return noAnimationOptions;
   }
+
+  private static boolean isSet(int fields, int flag) {
+    return (fields & flag) != 0;
+  }
+
+  /**
+   * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
+   * loading the resource. Useful for loading thumbnails or trying to avoid loading huge resources
+   * (particularly {@link Bitmap}s on devices with overly dense screens.
+   *
+   * @param sizeMultiplier The multiplier to apply to the
+   *                       {@link com.bumptech.glide.request.target.Target}'s dimensions when
+   *                       loading the resource.
+   * @return This request builder.
+   */
+  public RequestOptions sizeMultiplier(float sizeMultiplier) {
+    if (isAutoCloneEnabled) {
+      return clone().sizeMultiplier(sizeMultiplier);
+    }
+
+    if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
+      throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
+    }
+    this.sizeMultiplier = sizeMultiplier;
+    fields |= SIZE_MULTIPLIER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useUnlimitedSourceGeneratorsPool(flag);
+    }
+
+    this.useUnlimitedSourceGeneratorsPool = flag;
+    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * If set to true, will only load an item if found in the cache, and will not fetch from source.
+   */
+  public RequestOptions onlyRetrieveFromCache(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().onlyRetrieveFromCache(flag);
+    }
+
+    this.onlyRetrieveFromCache = flag;
+    fields |= ONLY_RETRIEVE_FROM_CACHE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link DiskCacheStrategy} to use for this load.
+   *
+   * <p> Defaults to {@link DiskCacheStrategy#AUTOMATIC}. </p>
+   *
+   * <p> For most applications {@link DiskCacheStrategy#RESOURCE} is
+   * ideal. Applications that use the same resource multiple times in multiple sizes and are willing
+   * to trade off some speed and disk space in return for lower bandwidth usage may want to consider
+   * using {@link DiskCacheStrategy#DATA} or
+   * {@link DiskCacheStrategy#ALL}. </p>
+   *
+   * @param strategy The strategy to use.
+   * @return This request builder.
+   */
+  public RequestOptions diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {
+    if (isAutoCloneEnabled) {
+      return clone().diskCacheStrategy(strategy);
+    }
+    this.diskCacheStrategy = Preconditions.checkNotNull(strategy);
+    fields |= DISK_CACHE_STRATEGY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the priority for this load.
+   *
+   * @param priority A priority.
+   * @return This request builder.
+   */
+  public RequestOptions priority(@NonNull Priority priority) {
+    if (isAutoCloneEnabled) {
+      return clone().priority(priority);
+    }
+
+    this.priority = Preconditions.checkNotNull(priority);
+    fields |= PRIORITY;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display while a resource is loading.
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  public RequestOptions placeholder(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(drawable);
+    }
+
+    this.placeholderDrawable = drawable;
+    fields |= PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an Android resource id for a {@link Drawable} resource to
+   * display while a resource is loading.
+   *
+   * @param resourceId The id of the resource to use as a placeholder
+   * @return This request builder.
+   */
+  public RequestOptions placeholder(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().placeholder(resourceId);
+    }
+
+    this.placeholderId = resourceId;
+    fields |= PLACEHOLDER_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets an {@link Drawable} to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If the
+   * error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param drawable The drawable to display as a placeholder.
+   * @return This request builder.
+   */
+  public RequestOptions fallback(Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(drawable);
+    }
+
+    this.fallbackDrawable = drawable;
+    fields |= FALLBACK;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if the model provided to
+   * {@link com.bumptech.glide.RequestBuilder#load(Object)} is {@code null}.
+   *
+   * <p> If a fallback is not set, null models will cause the error drawable to be displayed. If
+   * the error drawable is not set, the placeholder will be displayed.
+   *
+   * @see #placeholder(Drawable)
+   * @see #placeholder(int)
+   *
+   * @param resourceId The id of the resource to use as a fallback.
+   * @return This request builder.
+   */
+  public RequestOptions fallback(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().fallback(resourceId);
+    }
+
+    this.fallbackId = resourceId;
+    fields |= FALLBACK_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a {@link Drawable} to display if a load fails.
+   *
+   * @param drawable The drawable to display.
+   * @return This request builder.
+   */
+  public RequestOptions error(@Nullable Drawable drawable) {
+    if (isAutoCloneEnabled) {
+      return clone().error(drawable);
+    }
+
+    this.errorPlaceholder = drawable;
+    fields |= ERROR_PLACEHOLDER;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets a resource to display if a load fails.
+   *
+   * @param resourceId The id of the resource to use as a placeholder.
+   * @return This request builder.
+   */
+  public RequestOptions error(int resourceId) {
+    if (isAutoCloneEnabled) {
+      return clone().error(resourceId);
+    }
+    this.errorId = resourceId;
+    fields |= ERROR_ID;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s
+   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and
+   * {@link #fallback(Drawable)}.
+   *
+   * @param theme The theme to use when loading Drawables.
+   * @return this request builder.
+   */
+  public RequestOptions theme(Resources.Theme theme) {
+    if (isAutoCloneEnabled) {
+      return clone().theme(theme);
+    }
+
+    this.theme = theme;
+    fields |= THEME;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Allows the loaded resource to skip the memory cache.
+   *
+   * <p> Note - this is not a guarantee. If a request is already pending for this resource and that
+   * request is not also skipping the memory cache, the resource will be cached in memory.</p>
+   *
+   * @param skip True to allow the resource to skip the memory cache.
+   * @return This request builder.
+   */
+  public RequestOptions skipMemoryCache(boolean skip) {
+    if (isAutoCloneEnabled) {
+      return clone().skipMemoryCache(true);
+    }
+
+    this.isCacheable = !skip;
+    fields |= IS_CACHEABLE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given values. This is useful for thumbnails, and should only be used for other cases when you
+   * need a very specific image size.
+   *
+   * @param width  The width in pixels to use to load the resource.
+   * @param height The height in pixels to use to load the resource.
+   * @return This request builder.
+   */
+  public RequestOptions override(int width, int height) {
+    if (isAutoCloneEnabled) {
+      return clone().override(width, height);
+    }
+
+    this.overrideWidth = width;
+    this.overrideHeight = height;
+    fields |= OVERRIDE;
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the
+   * given size.
+   *
+   * @see #override(int, int)
+   * @param size The width and height to use.
+   * @return This request builder.
+   */
+  public RequestOptions override(int size) {
+    return override(size, size);
+  }
+
+  /**
+   * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller
+   * more control over when cached data is invalidated.
+   *
+   * <p> Note - The signature does not replace the cache key, it is purely additive. </p>
+   *
+   * @param signature A unique non-null {@link Key} representing the current
+   *                  state of the model that will be mixed in to the cache key.
+   * @return This request builder.
+   * @see com.bumptech.glide.signature.ObjectKey
+   */
+  public RequestOptions signature(@NonNull Key signature) {
+    if (isAutoCloneEnabled) {
+      return clone().signature(signature);
+    }
+
+    this.signature = Preconditions.checkNotNull(signature);
+    fields |= SIGNATURE;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Returns a copy of this request builder with all of the options put so far on this builder.
+   *
+   * <p> This method returns a "deep" copy in that all non-immutable arguments are copied such that
+   * changes to one builder will not affect the other builder. However, in addition to immutable
+   * arguments, the current model is not copied copied so changes to the model will affect both
+   * builders. </p>
+   *
+   * <p> Even if this object was locked, the cloned object returned from this method will not be
+   * locked. </p>
+   */
+  @SuppressWarnings("unchecked")
+  @Override
+  public RequestOptions clone() {
+    try {
+      RequestOptions result = (RequestOptions) super.clone();
+      result.options = new Options();
+      result.options.putAll(options);
+      result.transformations = new HashMap<>();
+      result.transformations.putAll(transformations);
+      result.isLocked = false;
+      result.isAutoCloneEnabled = false;
+      return (RequestOptions) result;
+    } catch (CloneNotSupportedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  public <T> RequestOptions set(@NonNull Option<T> option, @NonNull T value) {
+    if (isAutoCloneEnabled) {
+      return clone().set(option, value);
+    }
+
+    Preconditions.checkNotNull(option);
+    Preconditions.checkNotNull(value);
+    options.set(option, value);
+    return selfOrThrowIfLocked();
+  }
+
+  public RequestOptions decode(@NonNull Class<?> resourceClass) {
+    if (isAutoCloneEnabled) {
+      return clone().decode(resourceClass);
+    }
+
+    this.resourceClass = Preconditions.checkNotNull(resourceClass);
+    fields |= RESOURCE_CLASS;
+    return selfOrThrowIfLocked();
+  }
+
+  public final boolean isTransformationAllowed() {
+    return isTransformationAllowed;
+  }
+
+  public final boolean isTransformationSet() {
+    return isSet(TRANSFORMATION);
+  }
+
+  public final boolean isLocked() {
+    return isLocked;
+  }
+
+  /**
+   * Sets the value for key
+   * {@link com.bumptech.glide.load.resource.bitmap.BitmapEncoder#COMPRESSION_FORMAT}.
+   */
+  public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
+    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the value for key
+   * {@link BitmapEncoder#COMPRESSION_QUALITY}.
+   */
+  public RequestOptions encodeQuality(int quality) {
+    return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
+  }
+
+  /**
+   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using
+   * {@link Downsampler}.
+   *
+   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be
+   * decoded using a decoder that cannot control the format
+   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to
+   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the
+   * image has alpha).
+   */
+  public RequestOptions format(@NonNull DecodeFormat format) {
+    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));
+  }
+
+  /**
+   * Sets the time position of the frame to extract from a video.
+   *
+   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
+   *                        Android framework implementation return a representative frame.
+   */
+  public RequestOptions frame(long frameTimeMicros) {
+    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
+  }
+
+  /**
+   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using
+   * {@link Downsampler}.
+   */
+  public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
+    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerCrop()
+   */
+  public RequestOptions optionalCenterCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context any {@link Context}.
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   *
+   * @deprecated Use {@link #centerCrop()}.
+   */
+  @Deprecated
+  public RequestOptions centerCrop(@SuppressWarnings("unused") Context context) {
+    return centerCrop();
+  }
+
+  /**
+   * Applies {@link CenterCrop} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>this will override previous calls to {@link #dontTransform()} ()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  public RequestOptions centerCrop() {
+    return transform(DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #fitCenter()
+   */
+  public RequestOptions optionalFitCenter() {
+    return optionalTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link FitCenter} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalFitCenter()
+   */
+  public RequestOptions fitCenter() {
+    return transform(DownsampleStrategy.FIT_CENTER, new FitCenter());
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link Context}.
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   *
+   * @deprecated Use {@link #optionalCenterInside()}
+   */
+  @Deprecated
+  public RequestOptions optionalCenterInside(@SuppressWarnings("unused") Context context) {
+    return optionalCenterInside();
+  }
+
+  /**
+   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and
+   * ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Class, Transformation)
+   * @see #centerInside()
+   */
+  public RequestOptions optionalCenterInside() {
+    return optionalTransform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CenterInside} to all default types and
+   * throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterInside()
+   */
+  public RequestOptions centerInside() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CenterInside());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types, and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #optionalTransform(Transformation)
+   * @see #circleCrop()
+   */
+  public RequestOptions optionalCircleCrop() {
+    return optionalTransform(DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop());
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context Any {@link Context}.
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   *
+   * @deprecated Use {@link #circleCrop()}.
+   */
+  @Deprecated
+  public RequestOptions circleCrop(@SuppressWarnings("unused") Context context) {
+    return circleCrop();
+  }
+
+  /**
+   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform
+   * an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @see #transform(Class, Transformation)
+   * @see #optionalCenterCrop()
+   */
+  public RequestOptions circleCrop() {
+    return transform(DownsampleStrategy.CENTER_INSIDE, new CircleCrop());
+  }
+
+  // calling optionalTransform() on the result of clone() requires greater access.
+  @SuppressWarnings("WeakerAccess")
+  final RequestOptions optionalTransform(DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return optionalTransform(transformation);
+  }
+
+  // calling transform() on the result of clone() requires greater access.
+  @SuppressWarnings("WeakerAccess")
+  final RequestOptions transform(DownsampleStrategy downsampleStrategy,
+      Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(downsampleStrategy, transformation);
+    }
+
+    downsample(downsampleStrategy);
+    return transform(transformation);
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable})
+   * and throws an exception if asked to transform an unknown type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for
+   *                       {@link Bitmap}s.
+   * @see #optionalTransform(Transformation)
+   * @see #optionalTransform(Class, Transformation)
+   */
+  public RequestOptions transform(@NonNull Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(transformation);
+    }
+
+    optionalTransform(transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param context        Any {@link Context}.
+   * @param transformation Any {@link Transformation} for
+   *                       {@link Bitmap}s.
+   * @see #transform(Class, Transformation)
+   *
+   * @deprecated Use {@link #optionalTransform(Transformation)}
+   */
+  @Deprecated
+  public RequestOptions optionalTransform(Context context, Transformation<Bitmap> transformation) {
+    return optionalTransform(transformation);
+  }
+
+  /**
+   * Applies the given {@link Transformation} for
+   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},
+   * {@link android.graphics.drawable.BitmapDrawable}, and
+   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}) and ignores unknown types.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param transformation Any {@link Transformation} for
+   *                       {@link Bitmap}s.
+   * @see #transform(Transformation)
+   * @see #transform(Class, Transformation)
+   */
+  public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(transformation);
+    }
+
+    optionalTransform(Bitmap.class, transformation);
+    // TODO: remove BitmapDrawable decoder and this transformation.
+    optionalTransform(BitmapDrawable.class,
+        new BitmapDrawableTransformation(transformation));
+    optionalTransform(GifDrawable.class, new GifDrawableTransformation(transformation));
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and allows unknown resource types to be ignored.
+   *
+   * <p> Users can apply different transformations for each resource class. Applying a
+   * {@link Transformation} for a resource type that already has a
+   * {@link Transformation} will override the previous call. </p>
+   *
+   * <p> If any calls are made to the non-optional transform methods, then attempting to transform
+   * an unknown resource class will throw an exception. To allow unknown types, users must always
+   * call the optional version of each method. </p>
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   */
+  public <T> RequestOptions optionalTransform(Class<T> resourceClass,
+      Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().optionalTransform(resourceClass, transformation);
+    }
+
+    Preconditions.checkNotNull(resourceClass);
+    Preconditions.checkNotNull(transformation);
+    transformations.put(resourceClass, transformation);
+    fields |= TRANSFORMATION;
+    isTransformationAllowed = true;
+    fields |= TRANSFORMATION_ALLOWED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Applies the given {@link Transformation} for any decoded resource of
+   * the given type and throws if asked to transform an unknown resource type.
+   *
+   * <p>This will override previous calls to {@link #dontTransform()}.
+   *
+   * @param resourceClass  The type of resource to transform.
+   * @param transformation The {@link Transformation} to apply.
+   * @see #optionalTransform(Class, Transformation)
+   */
+  public <T> RequestOptions transform(
+      Class<T> resourceClass, Transformation<T> transformation) {
+    if (isAutoCloneEnabled) {
+      return clone().transform(resourceClass, transformation);
+    }
+
+    optionalTransform(resourceClass, transformation);
+    isTransformationRequired = true;
+    fields |= TRANSFORMATION_REQUIRED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Removes all applied {@link Transformation Transformations} for all
+   * resource classes and allows unknown resource types to be transformed without throwing an
+   * exception.
+   */
+  public RequestOptions dontTransform() {
+    if (isAutoCloneEnabled) {
+      return clone().dontTransform();
+    }
+
+    transformations.clear();
+    fields &= ~TRANSFORMATION;
+    isTransformationRequired = false;
+    fields &= ~TRANSFORMATION_REQUIRED;
+    isTransformationAllowed = false;
+    fields |= TRANSFORMATION_ALLOWED;
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Disables resource decoders that return animated resources so any resource returned will be
+   * static.
+   *
+   * <p> To disable transitions (fades etc) use
+   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>
+   */
+  public RequestOptions dontAnimate() {
+    if (isAutoCloneEnabled) {
+      return clone().dontAnimate();
+    }
+
+    set(ByteBufferGifDecoder.DISABLE_ANIMATION, true);
+    set(StreamGifDecoder.DISABLE_ANIMATION, true);
+    return selfOrThrowIfLocked();
+  }
+
+  public RequestOptions apply(RequestOptions other) {
+    if (isAutoCloneEnabled) {
+      return clone().apply(other);
+    }
+
+    if (isSet(other.fields, SIZE_MULTIPLIER)) {
+      sizeMultiplier = other.sizeMultiplier;
+    }
+    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
+      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
+    }
+    if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
+      diskCacheStrategy = other.diskCacheStrategy;
+    }
+    if (isSet(other.fields, PRIORITY)) {
+      priority = other.priority;
+    }
+    if (isSet(other.fields, ERROR_PLACEHOLDER)) {
+      errorPlaceholder = other.errorPlaceholder;
+    }
+    if (isSet(other.fields, ERROR_ID)) {
+      errorId = other.errorId;
+    }
+    if (isSet(other.fields, PLACEHOLDER)) {
+      placeholderDrawable = other.placeholderDrawable;
+    }
+    if (isSet(other.fields, PLACEHOLDER_ID)) {
+      placeholderId = other.placeholderId;
+    }
+    if (isSet(other.fields, IS_CACHEABLE)) {
+      isCacheable = other.isCacheable;
+    }
+    if (isSet(other.fields, OVERRIDE)) {
+      overrideWidth = other.overrideWidth;
+      overrideHeight = other.overrideHeight;
+    }
+    if (isSet(other.fields, SIGNATURE)) {
+      signature = other.signature;
+    }
+    if (isSet(other.fields, RESOURCE_CLASS)) {
+      resourceClass = other.resourceClass;
+    }
+    if (isSet(other.fields, FALLBACK)) {
+      fallbackDrawable = other.fallbackDrawable;
+    }
+    if (isSet(other.fields, FALLBACK_ID)) {
+      fallbackId = other.fallbackId;
+    }
+    if (isSet(other.fields, THEME)) {
+      theme = other.theme;
+    }
+    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {
+      isTransformationAllowed = other.isTransformationAllowed;
+    }
+    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {
+      isTransformationRequired = other.isTransformationRequired;
+    }
+    if (isSet(other.fields, TRANSFORMATION)) {
+      transformations.putAll(other.transformations);
+    }
+    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {
+      onlyRetrieveFromCache = other.onlyRetrieveFromCache;
+    }
+
+    // Applying options with dontTransform() is expected to clear our transformations.
+    if (!isTransformationAllowed) {
+      transformations.clear();
+      fields &= ~TRANSFORMATION;
+      isTransformationRequired = false;
+      fields &= ~TRANSFORMATION_REQUIRED;
+    }
+
+    fields |= other.fields;
+    options.putAll(other.options);
+
+    return selfOrThrowIfLocked();
+  }
+
+  /**
+   * Throws if any further mutations are attempted.
+   *
+   * <p> Once locked, the only way to unlock is to use {@link #clone()} </p>
+   */
+  @SuppressWarnings("unchecked")
+  public RequestOptions lock() {
+    isLocked = true;
+    // This is the only place we should not check locked.
+    return (RequestOptions) this;
+  }
+
+  /**
+   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen
+   * before the mutation resulting in all methods returning a new Object and leaving the original
+   * locked object unmodified.
+   *
+   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects
+   * are mutable and are not locked.
+   */
+  public RequestOptions autoClone() {
+    if (isLocked && !isAutoCloneEnabled) {
+      throw new IllegalStateException("You cannot auto lock an already locked options object"
+          + ", try clone() first");
+    }
+    isAutoCloneEnabled = true;
+    return lock();
+  }
+
+  @SuppressWarnings("unchecked")
+  private RequestOptions selfOrThrowIfLocked() {
+    if (isLocked) {
+      throw new IllegalStateException("You cannot modify locked RequestOptions, consider clone()");
+    }
+    return (RequestOptions) this;
+  }
+
+  public final Map<Class<?>, Transformation<?>> getTransformations() {
+    return transformations;
+  }
+
+  public final boolean isTransformationRequired() {
+    return isTransformationRequired;
+  }
+
+  public final Options getOptions() {
+    return options;
+  }
+
+  public final Class<?> getResourceClass() {
+    return resourceClass;
+  }
+
+  public final DiskCacheStrategy getDiskCacheStrategy() {
+    return diskCacheStrategy;
+  }
+
+  public final Drawable getErrorPlaceholder() {
+    return errorPlaceholder;
+  }
+
+  public final int getErrorId() {
+    return errorId;
+  }
+
+  public final int getPlaceholderId() {
+    return placeholderId;
+  }
+
+  public final Drawable getPlaceholderDrawable() {
+    return placeholderDrawable;
+  }
+
+  public final int getFallbackId() {
+    return fallbackId;
+  }
+
+  public final Drawable getFallbackDrawable() {
+    return fallbackDrawable;
+  }
+
+  public final Resources.Theme getTheme() {
+    return theme;
+  }
+
+  public final boolean isMemoryCacheable() {
+    return isCacheable;
+  }
+
+  public final Key getSignature() {
+    return signature;
+  }
+
+  public final boolean isPrioritySet() {
+    return isSet(PRIORITY);
+  }
+
+  public final Priority getPriority() {
+    return priority;
+  }
+
+  public final int getOverrideWidth() {
+    return overrideWidth;
+  }
+
+  public final boolean isValidOverride() {
+    return Util.isValidDimensions(overrideWidth, overrideHeight);
+  }
+
+  public final int getOverrideHeight() {
+    return overrideHeight;
+  }
+
+  public final float getSizeMultiplier() {
+    return sizeMultiplier;
+  }
+
+  private boolean isSet(int flag) {
+    return isSet(fields, flag);
+  }
+
+  public final boolean getUseUnlimitedSourceGeneratorsPool() {
+    return useUnlimitedSourceGeneratorsPool;
+  }
+
+  public final boolean getOnlyRetrieveFromCache() {
+    return onlyRetrieveFromCache;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index c0dba86d6..637a142e6 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -85,7 +85,7 @@
   private GlideContext glideContext;
   private Object model;
   private Class<R> transcodeClass;
-  private BaseRequestOptions<?> requestOptions;
+  private RequestOptions requestOptions;
   private int overrideWidth;
   private int overrideHeight;
   private Priority priority;
@@ -107,7 +107,7 @@
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
@@ -146,7 +146,7 @@ private void init(
       GlideContext glideContext,
       Object model,
       Class<R> transcodeClass,
-      BaseRequestOptions<?> requestOptions,
+      RequestOptions requestOptions,
       int overrideWidth,
       int overrideHeight,
       Priority priority,
@@ -238,6 +238,7 @@ public void begin() {
    */
   void cancel() {
     stateVerifier.throwIfRecycled();
+    target.removeCallback(this);
     status = Status.CANCELLED;
     if (loadStatus != null) {
       loadStatus.cancel();
@@ -395,6 +396,7 @@ public void onSizeReady(int width, int height) {
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
         requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+        requestOptions.getOnlyRetrieveFromCache(),
         this);
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
diff --git a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
index d426d38ac..792de64a3 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.request.target;
 
 import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.request.Request;
 
 /**
@@ -22,27 +23,28 @@
   private Request request;
 
   @Override
-  public void setRequest(Request request) {
+  public void setRequest(@Nullable Request request) {
     this.request = request;
   }
 
   @Override
+  @Nullable
   public Request getRequest() {
     return request;
   }
 
   @Override
-  public void onLoadCleared(Drawable placeholder) {
+  public void onLoadCleared(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
   @Override
-  public void onLoadStarted(Drawable placeholder) {
+  public void onLoadStarted(@Nullable Drawable placeholder) {
     // Do nothing.
   }
 
   @Override
-  public void onLoadFailed(Drawable errorDrawable) {
+  public void onLoadFailed(@Nullable Drawable errorDrawable) {
     // Do nothing.
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
index 81942e412..f5d978a22 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java
@@ -81,7 +81,6 @@ public void setFilterBitmap(boolean filter) {
     wrapped.setFilterBitmap(filter);
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @Override
   public Callback getCallback() {
     return wrapped.getCallback();
diff --git a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
index 8144e5d90..fd1baf5b7 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java
@@ -64,4 +64,9 @@ public final void getSize(SizeReadyCallback cb) {
     }
     cb.onSizeReady(width, height);
   }
+
+  @Override
+  public void removeCallback(SizeReadyCallback cb) {
+    // Do nothing, we never retain a reference to the callback.
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index 0488526e6..dbdbc4779 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -83,6 +83,13 @@
    */
   void getSize(SizeReadyCallback cb);
 
+  /**
+   * Removes the given callback from the pending set if it's still retained.
+   *
+   * @param cb The callback to remove.
+   */
+  void removeCallback(SizeReadyCallback cb);
+
   /**
    * Sets the current request for this target to retain, should not be called outside of Glide.
    */
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 2ffb77553..0dd3d4f2e 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -1,18 +1,12 @@
 package com.bumptech.glide.request.target;
 
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.graphics.Point;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.support.annotation.Nullable;
-import android.support.v4.view.ViewCompat;
 import android.util.Log;
-import android.view.Display;
 import android.view.View;
 import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
-import android.view.WindowManager;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
@@ -74,6 +68,11 @@ public void getSize(SizeReadyCallback cb) {
     sizeDeterminer.getSize(cb);
   }
 
+  @Override
+  public void removeCallback(SizeReadyCallback cb) {
+    sizeDeterminer.removeCallback(cb);
+  }
+
   @Override
   public void onLoadCleared(Drawable placeholder) {
     super.onLoadCleared(placeholder);
@@ -167,15 +166,14 @@ public static void setTagId(int tagId) {
   }
 
   private static class SizeDeterminer {
-    // Some negative sizes (WRAP_CONTENT) are valid, 0 is never valid.
+    // Some negative sizes (Target.SIZE_ORIGINAL) are valid, 0 is never valid.
     private static final int PENDING_SIZE = 0;
     private final View view;
     private final List<SizeReadyCallback> cbs = new ArrayList<>();
 
     @Nullable private SizeDeterminerLayoutListener layoutListener;
-    @Nullable private Point displayDimens;
 
-    public SizeDeterminer(View view) {
+    SizeDeterminer(View view) {
       this.view = view;
     }
 
@@ -191,9 +189,9 @@ void checkCurrentDimens() {
         return;
       }
 
-      int currentWidth = getViewWidthOrParam();
-      int currentHeight = getViewHeightOrParam();
-      if (!isSizeValid(currentWidth) || !isSizeValid(currentHeight)) {
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (!isViewStateAndSizeValid(currentWidth, currentHeight)) {
         return;
       }
 
@@ -202,29 +200,27 @@ void checkCurrentDimens() {
     }
 
     void getSize(SizeReadyCallback cb) {
-      int currentWidth = getViewWidthOrParam();
-      int currentHeight = getViewHeightOrParam();
-      if (isSizeValid(currentWidth) && isSizeValid(currentHeight)) {
-        int paddingAdjustedWidth = currentWidth == WindowManager.LayoutParams.WRAP_CONTENT
-            ? currentWidth
-            : currentWidth - ViewCompat.getPaddingStart(view) - ViewCompat.getPaddingEnd(view);
-        int paddingAdjustedHeight = currentHeight == LayoutParams.WRAP_CONTENT
-            ? currentHeight
-            : currentHeight - view.getPaddingTop() - view.getPaddingBottom();
-        cb.onSizeReady(paddingAdjustedWidth, paddingAdjustedHeight);
-      } else {
-        // We want to notify callbacks in the order they were added and we only expect one or two
-        // callbacks to
-        // be added a time, so a List is a reasonable choice.
-        if (!cbs.contains(cb)) {
-          cbs.add(cb);
-        }
-        if (layoutListener == null) {
-          final ViewTreeObserver observer = view.getViewTreeObserver();
-          layoutListener = new SizeDeterminerLayoutListener(this);
-          observer.addOnPreDrawListener(layoutListener);
-        }
+      int currentWidth = getTargetWidth();
+      int currentHeight = getTargetHeight();
+      if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
+        cb.onSizeReady(currentWidth, currentHeight);
+        return;
       }
+
+      // We want to notify callbacks in the order they were added and we only expect one or two
+      // callbacks to be added a time, so a List is a reasonable choice.
+      if (!cbs.contains(cb)) {
+        cbs.add(cb);
+      }
+      if (layoutListener == null) {
+        ViewTreeObserver observer = view.getViewTreeObserver();
+        layoutListener = new SizeDeterminerLayoutListener(this);
+        observer.addOnPreDrawListener(layoutListener);
+      }
+    }
+
+    void removeCallback(SizeReadyCallback cb) {
+      cbs.remove(cb);
     }
 
     void clearCallbacksAndListener() {
@@ -242,64 +238,67 @@ void clearCallbacksAndListener() {
       cbs.clear();
     }
 
-    private int getViewHeightOrParam() {
-      final LayoutParams layoutParams = view.getLayoutParams();
-      if (isSizeValid(view.getHeight())) {
-        return view.getHeight();
-      } else if (layoutParams != null) {
-        return getSizeForParam(layoutParams.height, true /*isHeight*/);
-      } else {
-        return PENDING_SIZE;
-      }
+    private boolean isViewStateAndSizeValid(int width, int height) {
+      return isViewStateValid() && isSizeValid(width) && isSizeValid(height);
     }
 
-    private int getViewWidthOrParam() {
-      final LayoutParams layoutParams = view.getLayoutParams();
-      if (isSizeValid(view.getWidth())) {
-        return view.getWidth();
-      } else if (layoutParams != null) {
-        return getSizeForParam(layoutParams.width, false /*isHeight*/);
-      } else {
-        return PENDING_SIZE;
+    private boolean isViewStateValid() {
+      // We consider the view state as valid if the view has
+      // non-null layout params and a non-zero layout width and height.
+      if (view.getLayoutParams() != null
+          && view.getLayoutParams().width > 0
+          && view.getLayoutParams().height > 0) {
+        return true;
       }
-    }
 
-    private int getSizeForParam(int param, boolean isHeight) {
-      if (param == LayoutParams.WRAP_CONTENT) {
-        Point displayDimens = getDisplayDimens();
-        return isHeight ? displayDimens.y : displayDimens.x;
-      } else {
-        return param;
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+        return view.isLaidOut();
       }
+      return !view.isLayoutRequested();
+    }
+
+    private int getTargetHeight() {
+      int verticalPadding = view.getPaddingTop() + view.getPaddingBottom();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.height : PENDING_SIZE;
+      return getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);
     }
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
-    @SuppressWarnings("deprecation")
-    private Point getDisplayDimens() {
-      if (displayDimens != null) {
-        return displayDimens;
+    private int getTargetWidth() {
+      int horizontalPadding = view.getPaddingLeft() + view.getPaddingRight();
+      LayoutParams layoutParams = view.getLayoutParams();
+      int layoutParamSize = layoutParams != null ? layoutParams.width : PENDING_SIZE;
+      return getTargetDimen(view.getWidth(), layoutParamSize, horizontalPadding);
+    }
+
+    private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
+      int adjustedViewSize = viewSize - paddingSize;
+      if (isSizeValid(adjustedViewSize)) {
+        return adjustedViewSize;
       }
-      WindowManager windowManager =
-          (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
-      Display display = windowManager.getDefaultDisplay();
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
-        displayDimens = new Point();
-        display.getSize(displayDimens);
+
+      if (paramSize == PENDING_SIZE) {
+        return PENDING_SIZE;
+      }
+
+      if (paramSize == LayoutParams.WRAP_CONTENT) {
+        return SIZE_ORIGINAL;
+      } else if (paramSize > 0) {
+        return paramSize - paddingSize;
       } else {
-        displayDimens = new Point(display.getWidth(), display.getHeight());
+        return PENDING_SIZE;
       }
-      return displayDimens;
     }
 
     private boolean isSizeValid(int size) {
-      return size > 0 || size == LayoutParams.WRAP_CONTENT;
+      return size > 0 || size == SIZE_ORIGINAL;
     }
 
     private static class SizeDeterminerLayoutListener implements ViewTreeObserver
         .OnPreDrawListener {
       private final WeakReference<SizeDeterminer> sizeDeterminerRef;
 
-      public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
+      SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
         sizeDeterminerRef = new WeakReference<>(sizeDeterminer);
       }
 
diff --git a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
index 4c63f5819..0f4803ace 100644
--- a/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java
@@ -51,7 +51,9 @@ public synchronized int available() throws IOException {
 
   @Override
   public synchronized int read() throws IOException {
-    return checkReadSoFarOrThrow(super.read());
+    int value = super.read();
+    checkReadSoFarOrThrow(value >= 0 ? 1 : -1);
+    return value;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 3b595b6b0..ea66b1126 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -150,7 +150,7 @@ public static boolean isOnMainThread() {
   }
 
   /**
-   * Returns {@code true} if called on the main thread, {@code false} otherwise.
+   * Returns {@code true} if called on a background thread, {@code false} otherwise.
    */
   public static boolean isOnBackgroundThread() {
     return !isOnMainThread();
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index 22e9d4beb..62a086519 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -77,8 +77,8 @@
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
-import org.robolectric.internal.ShadowExtractor;
 import org.robolectric.res.builder.RobolectricPackageManager;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowBitmap;
 
 /**
@@ -89,7 +89,7 @@
     GlideTest.ShadowFileDescriptorContentResolver.class,
     GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class,
     GlideTest.MutableShadowBitmap.class })
-@SuppressWarnings("unchecked")
+@SuppressWarnings({"unchecked", "deprecation"})
 public class GlideTest {
   @SuppressWarnings("rawtypes")
   private Target target = null;
@@ -100,8 +100,7 @@
   public void setUp() throws Exception {
     Glide.tearDown();
 
-    RobolectricPackageManager pm =
-        (RobolectricPackageManager) RuntimeEnvironment.application.getPackageManager();
+    RobolectricPackageManager pm = RuntimeEnvironment.getRobolectricPackageManager();
     ApplicationInfo info =
         pm.getApplicationInfo(RuntimeEnvironment.application.getPackageName(), 0);
     info.metaData = new Bundle();
@@ -111,6 +110,7 @@ public void setUp() throws Exception {
     target = mock(Target.class);
     imageView = new ImageView(RuntimeEnvironment.application);
     imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
+    imageView.layout(0, 0, 100, 100);
     doAnswer(new CallSizeReady()).when(target).getSize(isA(SizeReadyCallback.class));
 
     Handler bgHandler = mock(Handler.class);
@@ -141,8 +141,8 @@ public void testCanSetMemoryCategory() {
 
     MemoryCategory memoryCategory = MemoryCategory.NORMAL;
     Glide glide =
-        new GlideBuilder(getContext()).setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
-            .createGlide();
+        new GlideBuilder().setMemoryCache(memoryCache).setBitmapPool(bitmapPool)
+            .build(getContext());
     glide.setMemoryCategory(memoryCategory);
 
     verify(memoryCache).setSizeMultiplier(eq(memoryCategory.getMultiplier()));
@@ -155,8 +155,8 @@ public void testClearMemory() {
     MemoryCache memoryCache = mock(MemoryCache.class);
 
     Glide glide =
-        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .createGlide();
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
+            .build(getContext());
 
     glide.clearMemory();
 
@@ -170,8 +170,8 @@ public void testTrimMemory() {
     MemoryCache memoryCache = mock(MemoryCache.class);
 
     Glide glide =
-        new GlideBuilder(getContext()).setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
-            .createGlide();
+        new GlideBuilder().setBitmapPool(bitmapPool).setMemoryCache(memoryCache)
+            .build(getContext());
 
     final int level = 123;
 
@@ -579,7 +579,7 @@ private String mockUri(Uri uri, InputStream is) {
     }
     ContentResolver contentResolver = RuntimeEnvironment.application.getContentResolver();
     ShadowFileDescriptorContentResolver shadowContentResolver =
-        (ShadowFileDescriptorContentResolver) ShadowExtractor.extract(contentResolver);
+        (ShadowFileDescriptorContentResolver) Shadow.extract(contentResolver);
     shadowContentResolver.registerInputStream(uri, is);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
diff --git a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
index ecf16662e..5be7653f0 100644
--- a/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java
@@ -8,11 +8,11 @@
 import static org.mockito.Mockito.when;
 
 import android.widget.ImageView;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.BackgroundUtil;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,10 +28,17 @@
 public class RequestBuilderTest {
   @Mock GlideContext glideContext;
   @Mock RequestManager requestManager;
+  private Glide glide;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    glide = Glide.get(RuntimeEnvironment.application);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test(expected = NullPointerException.class)
@@ -108,8 +115,8 @@ public void runTest() throws Exception {
         .thenReturn(mock(Target.class));
     when(glideContext.getDefaultRequestOptions()).thenReturn(new RequestOptions());
     when(requestManager.getDefaultRequestOptions())
-        .thenReturn((BaseRequestOptions) new RequestOptions());
-    return new RequestBuilder<>(glideContext, requestManager, Object.class)
+        .thenReturn((RequestOptions) new RequestOptions());
+    return new RequestBuilder<>(glide, requestManager, Object.class)
         .load((Object) null);
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
index eb9528704..9a23a4680 100644
--- a/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load;
 
+import static com.bumptech.glide.tests.Util.anyContext;
 import static com.bumptech.glide.tests.Util.anyResource;
 import static com.bumptech.glide.tests.Util.mockResource;
 import static org.junit.Assert.assertEquals;
@@ -11,6 +12,7 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
@@ -22,6 +24,7 @@
 import org.junit.runners.JUnit4;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.robolectric.RuntimeEnvironment;
 
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
@@ -32,10 +35,13 @@
   @Mock Resource<Object> initial;
   @Mock Resource<Object> firstTransformed;
   @Mock Resource<Object> secondTransformed;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+
+    context = RuntimeEnvironment.application;
   }
 
   @Test
@@ -44,32 +50,34 @@ public void testAppliesTransformationsInOrder() {
     final int height = 768;
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    when(first.transform(eq(initial), eq(width), eq(height))).thenReturn(firstTransformed);
+    when(first.transform(anyContext(), eq(initial), eq(width), eq(height)))
+        .thenReturn(firstTransformed);
 
-    when(second.transform(eq(firstTransformed), eq(width), eq(height)))
+    when(second.transform(anyContext(), eq(firstTransformed), eq(width), eq(height)))
         .thenReturn(secondTransformed);
 
-    assertEquals(secondTransformed, transformation.transform(initial, width, height));
+    assertEquals(secondTransformed, transformation.transform(context, initial, width, height));
   }
 
   @Test
   public void testInitialResourceIsNotRecycled() {
-    when(first.transform(anyResource(), anyInt(), anyInt())).thenReturn(firstTransformed);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first);
 
-    transformation.transform(initial, 123, 456);
+    transformation.transform(context, initial, 123, 456);
 
     verify(initial, never()).recycle();
   }
 
   @Test
   public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformations() {
-    when(first.transform(anyResource(), anyInt(), anyInt())).thenReturn(initial);
-    when(second.transform(anyResource(), anyInt(), anyInt())).thenReturn(initial);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    transformation.transform(initial, 1111, 2222);
+    transformation.transform(context, initial, 1111, 2222);
 
     verify(initial, never()).recycle();
   }
@@ -77,35 +85,38 @@ public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformati
   @Test
   public void
   testInitialResourceIsNotRecycledIfReturnedByOneTransformationButNotByALaterTransformation() {
-    when(first.transform(anyResource(), anyInt(), anyInt())).thenReturn(initial);
-    when(second.transform(anyResource(), anyInt(), anyInt()))
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt())).thenReturn(initial);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
         .thenReturn(mockResource());
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
-    transformation.transform(initial, 1, 2);
+    transformation.transform(context, initial, 1, 2);
 
     verify(initial, never()).recycle();
   }
 
   @Test
   public void testFinalResourceIsNotRecycled() {
-    when(first.transform(anyResource(), anyInt(), anyInt())).thenReturn(firstTransformed);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first);
 
-    transformation.transform(mockResource(), 111, 222);
+    transformation.transform(context, mockResource(), 111, 222);
 
     verify(firstTransformed, never()).recycle();
   }
 
   @Test
   public void testIntermediateResourcesAreRecycled() {
-    when(first.transform(anyResource(), anyInt(), anyInt())).thenReturn(firstTransformed);
-    when(second.transform(anyResource(), anyInt(), anyInt())).thenReturn(secondTransformed);
+    when(first.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(firstTransformed);
+    when(second.transform(anyContext(), anyResource(), anyInt(), anyInt()))
+        .thenReturn(secondTransformed);
 
     MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);
 
-    transformation.transform(mockResource(), 233, 454);
+    transformation.transform(context, mockResource(), 233, 454);
 
     verify(firstTransformed).recycle();
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
index 82080d64d..77c6a93f5 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java
@@ -4,7 +4,7 @@
 
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
 import java.io.IOException;
 import java.io.InputStream;
@@ -36,13 +36,12 @@ public void testIncludesGivenExifOrientation() throws IOException {
       for (int j = 0; j < 8; j++) {
         InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
         InputStream wrapped = new ExifOrientationStream(toWrap, i);
-        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
 
         toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
         wrapped = new ExifOrientationStream(toWrap, i);
-        parser = new ImageHeaderParser(wrapped, byteArrayPool);
-        assertThat(parser.getOrientation()).isEqualTo(i);
+        assertThat(parser.getOrientation(wrapped, byteArrayPool)).isEqualTo(i);
       }
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index a27944ab7..50535836c 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -12,12 +12,16 @@
 import android.database.MatrixCursor;
 import android.net.Uri;
 import android.provider.MediaStore;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -128,7 +132,10 @@ public Harness() {
     }
 
     public ThumbnailStreamOpener get() {
-      return new ThumbnailStreamOpener(service, query, byteArrayPool, getContentResolver());
+      List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+      parsers.add(new DefaultImageHeaderParser());
+      return new ThumbnailStreamOpener(
+          parsers, service, query, byteArrayPool, getContentResolver());
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index f2e318e1c..81687fa35 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -24,7 +24,7 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
@@ -43,7 +43,7 @@ public void testLoadResource_returnsFileDescriptor() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
 
     AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);
     ParcelFileDescriptor parcelFileDescriptor = mock(ParcelFileDescriptor.class);
@@ -62,7 +62,7 @@ public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
     shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
 
     FileDescriptorLocalUriFetcher fetcher =
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index 230db7a56..a7fb2d580 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -22,7 +22,7 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class })
@@ -40,7 +40,7 @@ public void testLoadResource_returnsInputStream() throws Exception {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
     shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
 
     StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
@@ -54,7 +54,7 @@ public void testLoadResource_withNullInputStream_callsLoadFailed() {
     Uri uri = Uri.parse("file://nothing");
 
     ContentResolver contentResolver = context.getContentResolver();
-    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
+    ContentResolverShadow shadow = (ContentResolverShadow) Shadow.extract(contentResolver);
 
     shadow.registerInputStream(uri, null /*inputStream*/);
 
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index 38f51ba04..6a5cb537c 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -483,6 +483,7 @@ public void runTest() throws Exception {
     GlideContext glideContext = mock(GlideContext.class);
     boolean isMemoryCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
+    boolean onlyRetrieveFromCache = false;
 
     public EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
@@ -515,6 +516,7 @@ public EngineTestHarness() {
           options,
           isMemoryCacheable,
           useUnlimitedSourceGeneratorPool,
+          onlyRetrieveFromCache,
           cb);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index f2359ad81..98c4b8371 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -7,6 +7,7 @@
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.Build;
+import com.bumptech.glide.load.engine.cache.MemorySizeCalculatorTest.LowRamActivityManager;
 import com.bumptech.glide.tests.Util;
 import com.google.common.collect.Range;
 import org.junit.After;
@@ -17,10 +18,13 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowActivityManager;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
+@Config(manifest = Config.NONE, sdk = 19, shadows = LowRamActivityManager.class)
 public class MemorySizeCalculatorTest {
   private MemorySizeHarness harness;
   private int initialSdkVersion;
@@ -28,6 +32,7 @@
   @Before
   public void setUp() {
     initialSdkVersion = Build.VERSION.SDK_INT;
+    Util.setSdkVersionInt(18);
     harness = new MemorySizeHarness();
   }
 
@@ -64,7 +69,7 @@ public void testDefaultMemoryCacheSizeIsLimitedByMemoryClass() {
 
     float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();
 
-    assertThat((float) memoryCacheSize)
+    assertThat(memoryCacheSize)
         .isIn(Range.atMost(memoryClassBytes * harness.sizeMultiplier));
   }
 
@@ -133,10 +138,11 @@ public void testCumulativePoolAndMemoryCacheSizesAreSmallerOnLowMemoryDevices()
 
   @Test
   public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {
-    ShadowActivityManager activityManager = Shadows.shadowOf(harness.activityManager);
+    LowRamActivityManager activityManager =
+        (LowRamActivityManager) Shadow.extract(harness.activityManager);
+    Util.setSdkVersionInt(19);
     activityManager.setMemoryClass(getLargeEnoughMemoryClass());
-
-    Util.setSdkVersionInt(10);
+    activityManager.setIsLowRam(true);
 
     int byteArrayPoolSize = harness.getCalculator().getArrayPoolSizeInBytes();
     assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);
@@ -181,4 +187,19 @@ public int getScreenSize() {
       return pixelSize * pixelSize * bytesPerPixel;
     }
   }
+
+  @Implements(ActivityManager.class)
+  public static final class LowRamActivityManager extends ShadowActivityManager {
+
+    private boolean isLowRam;
+
+    void setIsLowRam(boolean isLowRam) {
+      this.isLowRam = isLowRam;
+    }
+
+    @Implementation
+    public boolean isLowRamDevice() {
+      return isLowRam;
+    }
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
index 6c1bafb6f..d00b03193 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java
@@ -129,7 +129,7 @@ public void testStopsAllocatingBitmapsUntilNextIdleCallIfAllocationsTakeLongerTh
   public void testPreFillHandlerDoesNotPostIfHasNoBitmapsToAllocate() {
     BitmapPreFillRunner handler = getHandler(new HashMap<PreFillType, Integer>());
     handler.run();
-    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyInt());
+    verify(mainHandler, never()).postDelayed(any(Runnable.class), anyLong());
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
index e2d29159b..d5dc77761 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/UnitTransformationTest.java
@@ -6,24 +6,34 @@
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 
+import android.app.Application;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.tests.KeyAssertions;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.robolectric.RuntimeEnvironment;
 
 @RunWith(JUnit4.class)
 public class UnitTransformationTest {
 
+  private Application app;
+
+  @Before
+  public void setUp() {
+    app = RuntimeEnvironment.application;
+  }
+
   @Test
   public void testReturnsGivenResource() {
     Resource<Object> resource = mockResource();
     UnitTransformation<Object> transformation = UnitTransformation.get();
-    assertEquals(resource, transformation.transform(resource, 10, 10));
+    assertEquals(resource, transformation.transform(app, resource, 10, 10));
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
index 15a9fdfc5..b5fa17830 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.bumptech.glide.tests.Util.anyContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
@@ -9,8 +10,11 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.drawable.BitmapDrawable;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -18,6 +22,7 @@
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -41,32 +46,41 @@
 
   private BitmapDrawableTransformation transformation;
   private Bitmap bitmapToTransform;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
     bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
 
+    context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
     when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);
     when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);
-    transformation = new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool,
-        wrapped);
+    transformation = new BitmapDrawableTransformation(wrapped);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsOriginalResourceIfTransformationDoesNotTransform() {
     int outWidth = 123;
     int outHeight = 456;
-    when(wrapped.transform(Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
-        .thenAnswer(new Answer<Object>() {
+    when(wrapped.transform(
+        anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
+        .thenAnswer(new Answer<Resource<Bitmap>>() {
+          @SuppressWarnings("unchecked")
           @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            return invocation.getArguments()[0];
+          public Resource<Bitmap> answer(InvocationOnMock invocation) throws Throwable {
+            return (Resource<Bitmap>) invocation.getArguments()[1];
           }
         });
 
-    Resource<BitmapDrawable> transformed = transformation.transform(drawableResourceToTransform,
-        outWidth, outHeight);
+    Resource<BitmapDrawable> transformed =
+        transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
 
     assertThat(transformed).isEqualTo(drawableResourceToTransform);
   }
@@ -79,11 +93,11 @@ public void testReturnsNewResourceIfTransformationDoesTransform() {
     Bitmap transformedBitmap = Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.RGB_565);
     Resource<Bitmap> transformedBitmapResource = Util.mockResource();
     when(transformedBitmapResource.get()).thenReturn(transformedBitmap);
-    when(wrapped.transform(Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), eq(outWidth), eq(outHeight)))
         .thenReturn(transformedBitmapResource);
 
     Resource<BitmapDrawable> transformed =
-        transformation.transform(drawableResourceToTransform, outWidth, outHeight);
+        transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
 
     assertThat(transformed.get().getBitmap()).isEqualTo(transformedBitmap);
   }
@@ -95,13 +109,13 @@ public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
     Resource<Bitmap> transformed = Util.mockResource();
     when(transformed.get())
         .thenReturn(Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.ARGB_8888));
-    when(wrapped.transform(Util.<Bitmap>anyResource(), anyInt(), anyInt()))
+    when(wrapped.transform(anyContext(), Util.<Bitmap>anyResource(), anyInt(), anyInt()))
         .thenReturn(transformed);
 
-    transformation.transform(drawableResourceToTransform, outWidth, outHeight);
+    transformation.transform(context, drawableResourceToTransform, outWidth, outHeight);
     ArgumentCaptor<Resource<Bitmap>> captor = Util.cast(ArgumentCaptor.forClass(Resource.class));
 
-    verify(wrapped).transform(captor.capture(), eq(outWidth), eq(outHeight));
+    verify(wrapped).transform(anyContext(), captor.capture(), eq(outWidth), eq(outHeight));
 
     assertThat(captor.getValue().get()).isEqualTo(bitmapToTransform);
   }
@@ -110,13 +124,11 @@ public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("wrapped")).when(wrapped)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertSame(transformation,
-        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, wrapped));
+    KeyAssertions.assertSame(transformation, new BitmapDrawableTransformation(wrapped));
 
     @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(any(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation,
-        new BitmapDrawableTransformation(RuntimeEnvironment.application, bitmapPool, other));
+    KeyAssertions.assertDifferent(transformation, new BitmapDrawableTransformation(other));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 6d8f6ad43..876a2bdef 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -68,7 +68,6 @@ public void testEncoderObeysNonNullCompressFormat() throws IOException {
   }
 
   @Test
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
   public void testEncoderEncodesJpegWithNullFormatAndBitmapWithoutAlpha() throws IOException {
     harness.setFormat(null);
     harness.bitmap.setHasAlpha(false);
@@ -79,7 +78,6 @@ public void testEncoderEncodesJpegWithNullFormatAndBitmapWithoutAlpha() throws I
   }
 
   @Test
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
   public void testEncoderEncodesPngWithNullFormatAndBitmapWithAlpha() throws IOException {
     harness.setFormat(null);
     harness.bitmap.setHasAlpha(true);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
index 14a9e4c3c..d7d22f0c3 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java
@@ -5,19 +5,24 @@
 import static org.junit.Assert.assertNull;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
@@ -26,15 +31,24 @@
 
   @Mock
   private BitmapPool bitmapPool;
+  private Application context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
+    context = RuntimeEnvironment.application;
+
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceWhenBitmapNotTransformed() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
@@ -46,13 +60,13 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
     };
 
     Resource<Bitmap> resource = mockResource(100, 100);
-    assertEquals(resource, transformation.transform(resource, 1, 1));
+    assertEquals(resource, transformation.transform(context, resource, 1, 1));
   }
 
   @Test
   public void testReturnsNewResourceWhenBitmapTransformed() {
     final Bitmap transformed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
@@ -64,7 +78,7 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap bitmap, int
     };
 
     Resource<Bitmap> resource = mockResource(1, 2);
-    assertNotSame(resource, transformation.transform(resource, 100, 100));
+    assertNotSame(resource, transformation.transform(context, resource, 100, 100));
   }
 
   @Test
@@ -72,7 +86,7 @@ public void testPassesGivenArgumentsToTransform() {
     final int expectedWidth = 13;
     final int expectedHeight = 148;
     final Resource<Bitmap> resource = mockResource(223, 4123);
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
 
@@ -87,12 +101,12 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
       }
     };
 
-    transformation.transform(resource, expectedWidth, expectedHeight);
+    transformation.transform(context, resource, expectedWidth, expectedHeight);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidWidth() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
@@ -103,12 +117,12 @@ protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTra
         return null;
       }
     };
-    transformation.transform(mockResource(1, 1), -1, 100);
+    transformation.transform(context, mockResource(1, 1), -1, 100);
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsIfGivenInvalidHeight() {
-    BitmapTransformation transformation = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transformation = new BitmapTransformation() {
 
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) { }
@@ -120,12 +134,12 @@ protected Bitmap transform(@NonNull BitmapPool bitmapPool, @NonNull Bitmap toTra
       }
 
     };
-    transformation.transform(mockResource(1, 1), 100, -1);
+    transformation.transform(context, mockResource(1, 1), 100, -1);
   }
 
   @Test
   public void testReturnsNullIfTransformReturnsNull() {
-    BitmapTransformation transform = new BitmapTransformation(bitmapPool) {
+    BitmapTransformation transform = new BitmapTransformation() {
 
       @Override
       public void updateDiskCacheKey(MessageDigest messageDigest) {  }
@@ -138,7 +152,7 @@ protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform
     };
 
     Resource<Bitmap> resource = mockResource(100, 100);
-    assertNull(transform.transform(resource, 100, 100));
+    assertNull(transform.transform(context, resource, 100, 100));
   }
 
   @Test
@@ -147,7 +161,7 @@ public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {
 
     int expectedWidth = 200;
     Resource<Bitmap> resource = mockResource(expectedWidth, 300);
-    transform.transform(resource, Target.SIZE_ORIGINAL, 500);
+    transform.transform(context, resource, Target.SIZE_ORIGINAL, 500);
 
     assertEquals(expectedWidth, transform.givenWidth);
   }
@@ -158,7 +172,7 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
 
     int expectedHeight = 500;
     Resource<Bitmap> resource = mockResource(123, expectedHeight);
-    transform.transform(resource, 444, expectedHeight);
+    transform.transform(context, resource, 444, expectedHeight);
 
     assertEquals(expectedHeight, transform.givenHeight);
   }
@@ -174,10 +188,6 @@ public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {
     int givenWidth;
     int givenHeight;
 
-    public SizeTrackingTransform() {
-      super(bitmapPool);
-    }
-
     @Override
     protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,
         int outHeight) {
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
index 8d2f4a295..a421660e0 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java
@@ -11,7 +11,10 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -19,12 +22,14 @@
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
@@ -39,6 +44,7 @@
   private int bitmapWidth;
   private int bitmapHeight;
   private Bitmap bitmap;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -50,8 +56,15 @@ public void setUp() {
 
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
+    context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
 
-    centerCrop = new CenterCrop(pool);
+    centerCrop = new CenterCrop();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
@@ -59,7 +72,7 @@ public void testDoesNotPutNullBitmapAcquiredFromPool() {
     reset(pool);
     when(pool.get(anyInt(), anyInt(), any(Bitmap.Config.class))).thenReturn(null);
 
-    centerCrop.transform(resource, 100, 100);
+    centerCrop.transform(context, resource, 100, 100);
 
     verify(pool, never()).put(any(Bitmap.class));
   }
@@ -67,21 +80,21 @@ public void testDoesNotPutNullBitmapAcquiredFromPool() {
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-        centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+        centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    centerCrop.transform(resource, bitmapWidth, bitmapHeight);
+    centerCrop.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testDoesNotRecycleGivenResource() {
-    centerCrop.transform(resource, 50, 50);
+    centerCrop.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
@@ -90,7 +103,7 @@ public void testDoesNotRecycleGivenResource() {
   public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {
     Shadows.shadowOf(bitmap).setConfig(null);
 
-    centerCrop.transform(resource, 10, 10);
+    centerCrop.transform(context, resource, 10, 10);
 
     verify(pool).get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888));
     verify(pool, never()).get(anyInt(), anyInt(), (Bitmap.Config) isNull());
@@ -107,7 +120,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsLargerThanTarge
       when(resource.get()).thenReturn(toTransform);
 
       Resource<Bitmap> result =
-          centerCrop.transform(resource, expectedWidth, expectedHeight);
+          centerCrop.transform(context, resource, expectedWidth, expectedHeight);
       Bitmap transformed = result.get();
       assertEquals(expectedWidth, transformed.getWidth());
       assertEquals(expectedHeight, transformed.getHeight());
@@ -125,7 +138,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
       when(resource.get()).thenReturn(toTransform);
 
       Resource<Bitmap> result =
-          centerCrop.transform(resource, expectedWidth, expectedHeight);
+          centerCrop.transform(context, resource, expectedWidth, expectedHeight);
       Bitmap transformed = result.get();
       assertEquals(expectedWidth, transformed.getWidth());
       assertEquals(expectedHeight, transformed.getHeight());
@@ -134,7 +147,7 @@ public void testReturnsBitmapWithExactlyGivenDimensionsIfBitmapIsSmallerThanTarg
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerCrop, new CenterCrop(pool));
+    KeyAssertions.assertSame(centerCrop, new CenterCrop());
 
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
index 14a4969d9..ebb4129a8 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterInsideTest.java
@@ -8,10 +8,13 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Paint;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -20,12 +23,14 @@
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -37,10 +42,10 @@
 
   @Mock Resource<Bitmap> resource;
   @Mock Transformation<Bitmap> transformation;
-  private BitmapPool pool;
   private CenterInside centerInside;
   private int bitmapWidth;
   private int bitmapHeight;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -50,15 +55,22 @@ public void setUp() {
     Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
     when(resource.get()).thenReturn(bitmap);
 
-    pool = new BitmapPoolAdapter();
+    context = RuntimeEnvironment.application;
+    BitmapPool pool = new BitmapPoolAdapter();
+    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
 
-    centerInside = new CenterInside(pool);
+    centerInside = new CenterInside();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-            centerInside.transform(resource, bitmapWidth, bitmapHeight);
+            centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
@@ -66,7 +78,7 @@ public void testReturnsGivenResourceIfMatchesSizeExactly() {
   @Test
   public void testReturnsGivenResourceIfSmallerThanTarget() {
     Resource<Bitmap> result =
-        centerInside.transform(resource, 150, 150);
+        centerInside.transform(context, resource, 150, 150);
 
     assertEquals(resource, result);
   }
@@ -74,7 +86,7 @@ public void testReturnsGivenResourceIfSmallerThanTarget() {
   @Test
   public void testReturnsNewResourceIfLargerThanTarget() {
     Resource<Bitmap> result =
-        centerInside.transform(resource, 50, 50);
+        centerInside.transform(context, resource, 50, 50);
 
     assertNotEquals(resource, result);
   }
@@ -82,21 +94,21 @@ public void testReturnsNewResourceIfLargerThanTarget() {
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    centerInside.transform(resource, bitmapWidth, bitmapHeight);
+    centerInside.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testDoesNotRecycleGivenResource() {
-    centerInside.transform(resource, 50, 50);
+    centerInside.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(centerInside, new CenterInside(pool));
+    KeyAssertions.assertSame(centerInside, new CenterInside());
 
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
index e9dc68063..740472103 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java
@@ -5,15 +5,17 @@
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.Rect;
-import android.os.Build;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,7 +37,14 @@ public void setup() {
     MockitoAnnotations.initMocks(this);
     when(bitmapPool.get(anyInt(), anyInt(), any(Bitmap.Config.class)))
         .thenAnswer(new Util.CreateBitmap());
-    circleCrop = new CircleCrop(RuntimeEnvironment.application);
+    Context context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    circleCrop = new CircleCrop();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
@@ -87,7 +96,6 @@ private void assertSamePixels(Bitmap expected, Bitmap actual) {
     }
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
   private Bitmap createBitmapWithRedCircle(int width, int height) {
     int minEdge = Math.min(width, height);
     float radius = minEdge / 2f;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
new file mode 100644
index 000000000..40b9bfb7a
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java
@@ -0,0 +1,402 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import com.bumptech.glide.load.ImageHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser.ImageType;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.testutil.TestResourceUtil;
+import java.io.ByteArrayInputStream;
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.Util;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE, sdk = 18)
+public class DefaultImageHeaderParserTest {
+
+  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
+      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
+          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
+
+  private ArrayPool byteArrayPool;
+
+  @Before
+  public void setUp() {
+    byteArrayPool = new LruArrayPool();
+  }
+
+  @Test
+  public void testCanParsePngType() throws IOException {
+    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
+    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParsePngWithAlpha() throws IOException {
+    for (int i = 3; i <= 6; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG_A, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParsePngWithoutAlpha() throws IOException {
+    for (int i = 0; i < 3; i++) {
+      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
+      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
+        @Override
+        public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+            throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(is));
+        }
+        @Override
+        public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+            ArrayPool byteArrayPool) throws IOException {
+          assertEquals(ImageType.PNG, parser.getType(byteBuffer));
+        }
+      });
+    }
+  }
+
+  @Test
+  public void testCanParseJpegType() throws IOException {
+    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.JPEG, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseGifType() throws IOException {
+    byte[] data = new byte[] { 'G', 'I', 'F' };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.GIF, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
+        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP_A, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testCanParseWebpWithoutAlpha() throws IOException {
+    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
+        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
+        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.WEBP, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
+    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #286.
+  @Test
+  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
+    byte[] data =
+        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
+    runTest(data, new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(-1, parser.getOrientation(is, byteArrayPool));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(-1, parser.getOrientation(byteBuffer, byteArrayPool));
+      }
+    });
+  }
+
+  @Test
+  public void testReturnsUnknownForEmptyData() throws IOException {
+    runTest(new byte[0], new ParserTestCase() {
+      @Override
+      public void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+          throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(is));
+      }
+      @Override
+      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,
+          ArrayPool byteArrayPool) throws IOException {
+        assertEquals(ImageType.UNKNOWN, parser.getType(byteBuffer));
+      }
+    });
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialReads() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialReadInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  // Test for #387.
+  @Test
+  public void testHandlesPartialSkips() throws IOException {
+    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertThat(parser.getOrientation(new PartialSkipInputStream(is), byteArrayPool)).isEqualTo(6);
+  }
+
+  @Test
+  public void testHandlesSometimesZeroSkips() throws IOException {
+    InputStream is = new ByteArrayInputStream(
+        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
+    DefaultImageHeaderParser parser =
+        new DefaultImageHeaderParser();
+    assertEquals(ImageType.PNG, parser.getType(new SometimesZeroSkipInputStream(is)));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        (byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withNonExifSegmentLessThanLength_returnsUnknown() throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    byte[] data = new byte[] {
+        jpegHeaderBytes.get(0), jpegHeaderBytes.get(1),
+        (byte) DefaultImageHeaderParser.SEGMENT_START_ID,
+        // SEGMENT_TYPE (NOT EXIF_SEGMENT_TYPE)
+        (byte) 0xE5,
+        // SEGMENT_LENGTH
+        (byte) 0xFF, (byte) 0xFF,
+    };
+    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION,
+        parser.getOrientation(byteBuffer, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleButLessThanLength_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity());
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  @Test
+  public void getOrientation_withExifSegmentAndPreambleBetweenLengthAndExpected_returnsUnknown()
+      throws IOException {
+    ByteBuffer jpegHeaderBytes = getExifMagicNumber();
+    ByteBuffer exifSegmentPreamble =
+        ByteBuffer.wrap(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    ByteBuffer data = ByteBuffer.allocate(2 + 1 + 1 + 2 + exifSegmentPreamble.capacity() + 2 + 1);
+    data.put(jpegHeaderBytes)
+        .put((byte) DefaultImageHeaderParser.SEGMENT_START_ID)
+        .put((byte) DefaultImageHeaderParser.EXIF_SEGMENT_TYPE)
+        // SEGMENT_LENGTH, add two because length includes the segment length short, and one to go
+        // beyond the preamble bytes length for the test.
+        .putShort(
+            (short) (DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length + 2 + 1))
+        .put(DefaultImageHeaderParser.JPEG_EXIF_SEGMENT_PREAMBLE_BYTES);
+
+    data.position(0);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    assertEquals(ImageHeaderParser.UNKNOWN_ORIENTATION, parser.getOrientation(data, byteArrayPool));
+  }
+
+  private static ByteBuffer getExifMagicNumber() {
+    ByteBuffer jpegHeaderBytes = ByteBuffer.allocate(2);
+    jpegHeaderBytes.putShort((short) DefaultImageHeaderParser.EXIF_MAGIC_NUMBER);
+    jpegHeaderBytes.position(0);
+    return jpegHeaderBytes;
+  }
+
+  private interface ParserTestCase {
+    void run(DefaultImageHeaderParser parser, InputStream is, ArrayPool byteArrayPool)
+        throws IOException;
+    void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer, ArrayPool byteArrayPool)
+        throws IOException;
+  }
+
+  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
+    InputStream is = new ByteArrayInputStream(data);
+    DefaultImageHeaderParser parser = new DefaultImageHeaderParser();
+    test.run(parser, is, new LruArrayPool());
+
+    ByteBuffer buffer = ByteBuffer.wrap(data);
+    parser = new DefaultImageHeaderParser();
+    test.run(parser, buffer, new LruArrayPool());
+  }
+
+  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
+    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
+    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
+    result[result.length - 1] = (byte) bitDepth;
+    return result;
+  }
+
+  private static class SometimesZeroSkipInputStream extends FilterInputStream {
+    boolean returnZeroFlag = true;
+
+    protected SometimesZeroSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+      final long result;
+      if (returnZeroFlag) {
+        result = 0;
+      } else {
+        result = super.skip(byteCount);
+      }
+      returnZeroFlag = !returnZeroFlag;
+      return result;
+    }
+  }
+
+  private static class PartialSkipInputStream extends FilterInputStream {
+
+    protected PartialSkipInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public long skip(long byteCount) throws IOException {
+        long toActuallySkip = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallySkip = 1;
+        }
+        return super.skip(toActuallySkip);
+    }
+  }
+
+  private static class PartialReadInputStream extends FilterInputStream {
+
+    protected PartialReadInputStream(InputStream in) {
+        super(in);
+    }
+
+    @Override
+    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
+        int toActuallyRead = byteCount / 2;
+        if (byteCount == 1) {
+            toActuallyRead = 1;
+        }
+        return super.read(buffer, byteOffset, toActuallyRead);
+    }
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
index 3bcd69b66..4cbfc7e49 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
@@ -11,6 +11,7 @@
 import android.os.Build;
 import android.util.DisplayMetrics;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -22,6 +23,8 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -53,7 +56,11 @@ public void setUp() throws Exception {
         RuntimeEnvironment.application.getResources().getDisplayMetrics();
     when(byteArrayPool.get(anyInt(), Matchers.eq(byte[].class)))
         .thenReturn(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
-    downsampler = new Downsampler(displayMetrics, bitmapPool, byteArrayPool);
+
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
+    downsampler = new Downsampler(parsers, displayMetrics, bitmapPool, byteArrayPool);
 
     initialSdkVersion = Build.VERSION.SDK_INT;
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
index 9a18ecbdb..65b073205 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/FitCenterTest.java
@@ -7,10 +7,13 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Application;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Paint;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -19,12 +22,14 @@
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -36,10 +41,10 @@
 
   @Mock Resource<Bitmap> resource;
   @Mock Transformation<Bitmap> transformation;
-  private BitmapPool pool;
   private FitCenter fitCenter;
   private int bitmapWidth;
   private int bitmapHeight;
+  private Application context;
 
   @Before
   public void setUp() {
@@ -49,36 +54,44 @@ public void setUp() {
     Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
     when(resource.get()).thenReturn(bitmap);
 
-    pool = new BitmapPoolAdapter();
+    BitmapPool pool = new BitmapPoolAdapter();
+    context = RuntimeEnvironment.application;
+    Glide.init(new GlideBuilder().setBitmapPool(pool).build(context));
 
-    fitCenter = new FitCenter(pool);
+
+    fitCenter = new FitCenter();
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
   public void testReturnsGivenResourceIfMatchesSizeExactly() {
     Resource<Bitmap> result =
-        fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+        fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     assertEquals(resource, result);
   }
 
   @Test
   public void testDoesNotRecycleGivenResourceIfMatchesSizeExactly() {
-    fitCenter.transform(resource, bitmapWidth, bitmapHeight);
+    fitCenter.transform(context, resource, bitmapWidth, bitmapHeight);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testDoesNotRecycleGivenResource() {
-    fitCenter.transform(resource, 50, 50);
+    fitCenter.transform(context, resource, 50, 50);
 
     verify(resource, never()).recycle();
   }
 
   @Test
   public void testEquals() throws NoSuchAlgorithmException {
-    KeyAssertions.assertSame(fitCenter, new FitCenter(pool));
+    KeyAssertions.assertSame(fitCenter, new FitCenter());
 
     doAnswer(new Util.WriteDigest("other")).when(transformation)
         .updateDiskCacheKey(any(MessageDigest.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
deleted file mode 100644
index ed6b2c680..000000000
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java
+++ /dev/null
@@ -1,254 +0,0 @@
-package com.bumptech.glide.load.resource.bitmap;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-
-import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
-import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
-import com.bumptech.glide.testutil.TestResourceUtil;
-import java.io.ByteArrayInputStream;
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.util.Util;
-
-@RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class ImageHeaderParserTest {
-
-  private static final byte[] PNG_HEADER_WITH_IHDR_CHUNK =
-      new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0xd, 0xa, 0x1a, 0xa, 0x0, 0x0, 0x0, 0xd, 0x49,
-          0x48, 0x44, 0x52, 0x0, 0x0, 0x1, (byte) 0x90, 0x0, 0x0, 0x1, 0x2c, 0x8, 0x6 };
-
-  private ArrayPool byteArrayPool;
-
-  @Before
-  public void setUp() {
-    byteArrayPool = new LruArrayPool();
-  }
-
-  @Test
-  public void testCanParsePngType() throws IOException {
-    // PNG magic number from: http://en.wikipedia.org/wiki/Portable_Network_Graphics.
-    byte[] data = new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.PNG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParsePngWithAlpha() throws IOException {
-    for (int i = 3; i <= 6; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG_A, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParsePngWithoutAlpha() throws IOException {
-    for (int i = 0; i < 3; i++) {
-      byte[] pngHeaderWithIhdrChunk = generatePngHeaderWithIhdr(i);
-      runTest(pngHeaderWithIhdrChunk, new ParserTestCase() {
-        @Override
-        public void run(ImageHeaderParser parser) throws IOException {
-          assertEquals(ImageType.PNG, parser.getType());
-        }
-      });
-    }
-  }
-
-  @Test
-  public void testCanParseJpegType() throws IOException {
-    byte[] data = new byte[] { (byte) 0xFF, (byte) 0xD8 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.JPEG, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseGifType() throws IOException {
-    byte[] data = new byte[] { 'G', 'I', 'F' };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.GIF, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseWebpWithAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x3c, 0x50, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x4c, 0x30, 0x50, 0x00, 0x00, 0x2f, (byte) 0xef, (byte) 0x80, 0x15,
-        0x10, (byte) 0x8d, 0x30, 0x68, 0x1b, (byte) 0xc9, (byte) 0x91, (byte) 0xb2 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.WEBP_A, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testCanParseWebpWithoutAlpha() throws IOException {
-    byte[] data = new byte[] { 0x52, 0x49, 0x46, 0x46, 0x72, 0x1c, 0x00, 0x00, 0x57, 0x45, 0x42,
-        0x50, 0x56, 0x50, 0x38, 0x20, 0x66, 0x1c, 0x00, 0x00, 0x30, 0x3c, 0x01, (byte) 0x9d, 0x01,
-        0x2a, 0x52, 0x02, (byte) 0x94, 0x03, 0x00, (byte) 0xc7 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.WEBP, parser.getType());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownTypeForUnknownImageHeaders() throws IOException {
-    byte[] data = new byte[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #286.
-  @Test
-  public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
-    byte[] data =
-        Util.readBytes(TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg"));
-    runTest(data, new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(-1, parser.getOrientation());
-      }
-    });
-  }
-
-  @Test
-  public void testReturnsUnknownForEmptyData() throws IOException {
-    runTest(new byte[0], new ParserTestCase() {
-      @Override
-      public void run(ImageHeaderParser parser) throws IOException {
-        assertEquals(ImageType.UNKNOWN, parser.getType());
-      }
-    });
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialReads() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  // Test for #387.
-  @Test
-  public void testHandlesPartialSkips() throws IOException {
-    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is), byteArrayPool);
-    assertThat(parser.getOrientation()).isEqualTo(6);
-  }
-
-  @Test
-  public void testHandlesSometimesZeroSkips() throws IOException {
-    InputStream is = new ByteArrayInputStream(
-        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
-    ImageHeaderParser parser =
-        new ImageHeaderParser(new SometimesZeroSkipInputStream(is), byteArrayPool);
-    assertEquals(ImageType.PNG, parser.getType());
-  }
-
-  private interface ParserTestCase {
-    void run(ImageHeaderParser parser) throws IOException;
-  }
-
-  private static void runTest(byte[] data, ParserTestCase test) throws IOException {
-    InputStream is = new ByteArrayInputStream(data);
-    ImageHeaderParser parser = new ImageHeaderParser(is, new LruArrayPool());
-    test.run(parser);
-
-    ByteBuffer buffer = ByteBuffer.wrap(data);
-    parser = new ImageHeaderParser(buffer, new LruArrayPool());
-    test.run(parser);
-  }
-
-  private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
-    byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
-    System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
-    result[result.length - 1] = (byte) bitDepth;
-    return result;
-  }
-
-  private static class SometimesZeroSkipInputStream extends FilterInputStream {
-    boolean returnZeroFlag = true;
-
-    protected SometimesZeroSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-      final long result;
-      if (returnZeroFlag) {
-        result = 0;
-      } else {
-        result = super.skip(byteCount);
-      }
-      returnZeroFlag = !returnZeroFlag;
-      return result;
-    }
-  }
-
-  private static class PartialSkipInputStream extends FilterInputStream {
-
-    protected PartialSkipInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public long skip(long byteCount) throws IOException {
-        long toActuallySkip = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallySkip = 1;
-        }
-        return super.skip(toActuallySkip);
-    }
-  }
-
-  private static class PartialReadInputStream extends FilterInputStream {
-
-    protected PartialReadInputStream(InputStream in) {
-        super(in);
-    }
-
-    @Override
-    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
-        int toActuallyRead = byteCount / 2;
-        if (byteCount == 1) {
-            toActuallyRead = 1;
-        }
-        return super.read(buffer, byteOffset, toActuallyRead);
-    }
-  }
-}
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index c4b9c51c1..ae6264663 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -12,11 +12,9 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.Matrix;
 import android.media.ExifInterface;
-import android.os.Build;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.util.Preconditions;
@@ -33,7 +31,6 @@
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowBitmap;
 
-@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = {
     TransformationUtilsTest.AlphaShadowBitmap.class })
@@ -353,7 +350,7 @@ public void testRotateImage() {
     assertTrue(toRotate == zero);
 
     Bitmap ninety = TransformationUtils.rotateImage(toRotate, 90);
-    assertTrue(Shadows.shadowOf(ninety).getDescription().contains("rotate=90.0"));
+    assertThat(Shadows.shadowOf(ninety).getDescription()).contains("rotate=90.0");
     assertEquals(toRotate.getWidth(), toRotate.getHeight());
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
index 718e0f1c1..8c78f1de1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java
@@ -12,12 +12,16 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.tests.GlideShadowLooper;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -56,10 +60,14 @@ public void setUp() {
         eq(gifHeader), isA(ByteBuffer.class), anyInt()))
         .thenReturn(gifDecoder);
 
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
     options = new Options();
     decoder =
         new ByteBufferGifDecoder(
             RuntimeEnvironment.application,
+            parsers,
             bitmapPool,
             new LruArrayPool(ARRAY_POOL_SIZE_BYTES),
             parserPool,
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index ee0fc5a3d..3d764e22d 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -41,7 +41,7 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowCanvas;
 
 @RunWith(RobolectricTestRunner.class)
@@ -94,7 +94,7 @@ public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
     drawable.draw(canvas);
 
     BitmapTrackingShadowCanvas shadowCanvas =
-        (BitmapTrackingShadowCanvas) ShadowExtractor.extract(canvas);
+        (BitmapTrackingShadowCanvas) Shadow.extract(canvas);
     assertThat(shadowCanvas.getDrawnBitmaps()).containsExactly(firstFrame);
   }
 
@@ -198,7 +198,7 @@ public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfHasNoCallback()
   }
 
   @Test
-  public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+  public void testStopsWhenCurrentFrameFinishesIfHasNoCallback() {
     drawable.setIsRunning(true);
     drawable.setCallback(null);
     drawable.onFrameReady();
@@ -207,18 +207,7 @@ public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneyc
   }
 
   @Test
-  public void testDoesNotStopWhenCurrentFrameFinishesIfHasNoCallbackAndIsPreHoneycomb() {
-    Util.setSdkVersionInt(10);
-
-    drawable.setIsRunning(true);
-    drawable.setCallback(null);
-    drawable.onFrameReady();
-
-    assertTrue(drawable.isRunning());
-  }
-
-  @Test
-  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {
+  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallback() {
     drawable.setIsRunning(true);
     drawable.setCallback(null);
     drawable.onFrameReady();
@@ -369,7 +358,7 @@ public void testLoopsASingleTimeIfLoopCountIsSetToOne() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -385,6 +374,7 @@ public void testLoopsForeverIfLoopCountIsSetToLoopForever() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
   }
 
   @Test
@@ -400,7 +390,7 @@ public void testLoopsOnceIfLoopCountIsSetToOneWithThreeFrames() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -416,7 +406,7 @@ public void testLoopsThreeTimesIfLoopCountIsSetToThree() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -429,6 +419,7 @@ public void testCallingStartResetsLoopCounter() {
     drawable.onFrameReady();
     when(frameLoader.getCurrentIndex()).thenReturn(1);
     drawable.onFrameReady();
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     drawable.start();
 
@@ -439,7 +430,7 @@ public void testCallingStartResetsLoopCounter() {
 
     // 4 onFrameReady(), 2 start()
     verify(cb, times(4 + 2)).invalidateDrawable(eq(drawable));
-    assertFalse(drawable.isRunning());
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test
@@ -453,6 +444,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     drawable.start();
 
     runLoops(initialLoopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
 
     final int newLoopCount = 2;
 
@@ -464,6 +456,7 @@ public void testChangingTheLoopCountAfterHittingTheMaxLoopCount() {
     int numStarts = 2;
     int expectedFrames = (initialLoopCount + newLoopCount) * frameCount + numStarts;
     verify(cb, times(expectedFrames)).invalidateDrawable(eq(drawable));
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
   @Test(expected = IllegalArgumentException.class)
@@ -472,7 +465,7 @@ public void testThrowsIfGivenLoopCountLessThanZeroAndNotInfinite() {
   }
 
   @Test
-  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
+  public void testUsesDecoderTotalLoopCountIfLoopCountIsLoopIntrinsic() {
     final int frameCount = 3;
     final int loopCount = 2;
     when(frameLoader.getLoopCount()).thenReturn(loopCount);
@@ -484,8 +477,26 @@ public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {
     runLoops(loopCount, frameCount);
 
     verifyRanLoops(loopCount, frameCount);
+    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());
   }
 
+  @Test
+  public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsForever() {
+    final int frameCount = 3;
+    final int loopCount = 40;
+    when(frameLoader.getLoopCount()).thenReturn(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER);
+    when(frameLoader.getFrameCount()).thenReturn(frameCount);
+    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);
+    drawable.setVisible(true, true);
+    drawable.start();
+
+    runLoops(loopCount, frameCount);
+
+    verifyRanLoops(loopCount, frameCount);
+    assertTrue("drawable should be still running", drawable.isRunning());
+  }
+
+
   @Test
   public void testDoesNotDrawFrameAfterRecycle() {
     Bitmap bitmap = Bitmap.createBitmap(100, 112341, Bitmap.Config.RGB_565);
@@ -562,6 +573,8 @@ private void runLoops(int loopCount, int frameCount) {
     for (int loop = 0; loop < loopCount; loop++) {
       for (int frame = 0; frame < frameCount; frame++) {
         when(frameLoader.getCurrentIndex()).thenReturn(frame);
+        assertTrue("drawable should be started before calling drawable.onFrameReady()",
+            drawable.isRunning());
         drawable.onFrameReady();
       }
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
index d9f0992c6..f73dc91a5 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformationTest.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.resource.gif;
 
 import static com.bumptech.glide.tests.Util.mockResource;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Matchers.isA;
@@ -9,7 +10,10 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.content.Context;
 import android.graphics.Bitmap;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -18,12 +22,14 @@
 import com.bumptech.glide.tests.Util;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
@@ -33,11 +39,20 @@
   @Mock BitmapPool bitmapPool;
 
   private GifDrawableTransformation transformation;
+  private Context context;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    transformation = new GifDrawableTransformation(wrapped, bitmapPool);
+    context = RuntimeEnvironment.application;
+
+    Glide.init(new GlideBuilder().setBitmapPool(bitmapPool).build(context));
+    transformation = new GifDrawableTransformation(wrapped);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
   }
 
   @Test
@@ -59,10 +74,10 @@ public void testSetsTransformationAsFrameTransformation() {
     Bitmap expectedBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
     Resource<Bitmap> expectedResource = mockResource();
     when(expectedResource.get()).thenReturn(expectedBitmap);
-    when(wrapped.transform(Util.<Bitmap>anyResource(), anyInt(), anyInt()))
+    when(wrapped.transform(any(Context.class), Util.<Bitmap>anyResource(), anyInt(), anyInt()))
         .thenReturn(expectedResource);
 
-    transformation.transform(resource, width, height);
+    transformation.transform(context, resource, width, height);
 
     verify(gifDrawable).setFrameTransformation(isA(Transformation.class), eq(expectedBitmap));
   }
@@ -71,11 +86,11 @@ public void testSetsTransformationAsFrameTransformation() {
   public void testEquals() throws NoSuchAlgorithmException {
     doAnswer(new Util.WriteDigest("first")).when(wrapped)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped, bitmapPool));
+    KeyAssertions.assertSame(transformation, new GifDrawableTransformation(wrapped));
 
     @SuppressWarnings("unchecked") Transformation<Bitmap> other = mock(Transformation.class);
     doAnswer(new Util.WriteDigest("other")).when(other)
         .updateDiskCacheKey(isA(MessageDigest.class));
-    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other, bitmapPool));
+    KeyAssertions.assertDifferent(transformation, new GifDrawableTransformation(other));
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 35e3b2365..0ad477634 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -24,7 +24,6 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.DelayTarget;
 import com.bumptech.glide.load.resource.gif.GifFrameLoader.FrameCallback;
-import com.bumptech.glide.request.BaseRequestOptions;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
@@ -82,7 +81,6 @@ public void tearDown() {
   private GifFrameLoader createGifFrameLoader(Handler handler) {
     Glide glide = getGlideSingleton();
     return new GifFrameLoader(
-        glide.getContext(),
         glide.getBitmapPool(),
         requestManager,
         gifDecoder,
@@ -130,7 +128,7 @@ public void testGetNextFrameIncrementsSignatureAndAdvancesDecoderBeforeStartingL
 
     InOrder order = inOrder(gifDecoder, requestBuilder);
     order.verify(gifDecoder).advance();
-    order.verify(requestBuilder).apply(isA(BaseRequestOptions.class));
+    order.verify(requestBuilder).apply(isA(RequestOptions.class));
     order.verify(requestBuilder).into(aTarget());
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
index 085014881..f6d4eba4c 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java
@@ -2,12 +2,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.bumptech.glide.load.ImageHeaderParser;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,7 +34,10 @@
   public void setUp() {
     MockitoAnnotations.initMocks(this);
 
-    decoder = new StreamGifDecoder(byteBufferDecoder, new LruArrayPool());
+    List<ImageHeaderParser> parsers = new ArrayList<ImageHeaderParser>();
+    parsers.add(new DefaultImageHeaderParser());
+
+    decoder = new StreamGifDecoder(parsers, byteBufferDecoder, new LruArrayPool());
     options = new Options();
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
index 6b3207ffc..3e3372e8e 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java
@@ -7,9 +7,7 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
-import android.os.Build;
 import android.support.v4.app.FragmentActivity;
 import com.bumptech.glide.RequestManager;
 import org.junit.Before;
@@ -18,12 +16,11 @@
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class RequestManagerFragmentTest {
   private static final String TAG = "tag";
   private Harness[] harnesses;
diff --git a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
index 40a403cbe..97884942a 100644
--- a/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
+++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java
@@ -30,12 +30,11 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
+import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class)
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class RequestManagerRetrieverTest {
   private static final String PARENT_TAG = "parent";
   private RetrieverHarness[] harnesses;
@@ -44,7 +43,7 @@
 
   @Before
   public void setUp() {
-    retriever = new RequestManagerRetriever();
+    retriever = new RequestManagerRetriever(null /*factory*/);
 
     harnesses =
         new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };
@@ -165,7 +164,6 @@ public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
     helpTestCanGetRequestManagerFromDetachedFragment();
   }
 
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
   private void helpTestCanGetRequestManagerFromDetachedFragment() {
     Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
     android.app.Fragment fragment = new android.app.Fragment();
@@ -206,7 +204,7 @@ public void testThrowsIfFragmentNotAttached() {
     retriever.get(fragment);
   }
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test(expected = NullPointerException.class)
   public void testThrowsIfSupportFragmentNotAttached() {
     Fragment fragment = new Fragment();
     retriever.get(fragment);
@@ -306,16 +304,6 @@ public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
     Robolectric.buildActivity(Issue117Activity.class).create().start().resume().visible();
   }
 
-  @Test
-  public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
-    Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
-    Activity activity = mock(Activity.class);
-    when(activity.getApplicationContext()).thenReturn(RuntimeEnvironment.application);
-    when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());
-
-    assertNotNull(retriever.get(activity));
-  }
-
   @Test
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
@@ -327,20 +315,6 @@ public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
     assertNotNull(retriever.get(spyActivity));
   }
 
-  @Test
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
-  public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
-    Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
-    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
-    android.app.Fragment fragment = new android.app.Fragment();
-
-    activity.getFragmentManager().beginTransaction().add(fragment, "test").commit();
-    android.app.Fragment spyFragment = Mockito.spy(fragment);
-    when(spyFragment.isDetached()).thenThrow(new NoSuchMethodError());
-
-    assertNotNull(retriever.get(spyFragment));
-  }
-
   @Test
   @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
   public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
diff --git a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
index 3f6eed8d0..3c7648274 100644
--- a/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
+++ b/library/src/test/java/com/bumptech/glide/module/ManifestParserTest.java
@@ -22,6 +22,7 @@
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE, sdk = 18)
+@SuppressWarnings("deprecation")
 public class ManifestParserTest {
   private static final String MODULE_VALUE = "GlideModule";
 
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index 792a81c06..cc3c11cd0 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -76,17 +76,17 @@ public void testReturnsTrueFromCancelIfNotYetDone() {
   }
 
   @Test
-  public void testClearsRequestOnMainThreadIfNotYetDoneOnCancel() {
+  public void cancel_withMayInterruptIfRunningTrueAndNotFinishedRequest_clearsFutureOnMainThread() {
     future.cancel(true);
 
     verify(handler).post(eq(future));
   }
 
   @Test
-  public void testClearsOnMainThreadWhenClearCalled() {
+  public void cancel_withInterruptFalseAndNotFinishedRequest_doesNotclearFutureOnMainThread() {
     future.cancel(false);
 
-    verify(handler).post(eq(future));
+    verify(handler, never()).post(eq(future));
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
similarity index 82%
rename from library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
rename to library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
index 368dba22f..23233e174 100644
--- a/library/src/test/java/com/bumptech/glide/request/BaseRequestOptionsTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java
@@ -10,20 +10,19 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest = Config.NONE)
-public class BaseRequestOptionsTest {
+public class RequestOptionsTest {
 
-  private TestOptions options;
+  private RequestOptions options;
   @Mock private Transformation<Bitmap> transformation;
 
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    options = new TestOptions();
+    options = new RequestOptions();
   }
 
   @Test
@@ -43,7 +42,7 @@ public void testIsTransformationAllowed_byDefault_isTrue() {
 
   @Test
   public void testIsTransformationSet_afterApplyingOptionsWithTransform_isTrue() {
-    TestOptions other = new TestOptions();
+    RequestOptions other = new RequestOptions();
     other.transform(Bitmap.class, transformation);
     options.apply(other);
     assertThat(options.isTransformationSet()).isTrue();
@@ -69,17 +68,17 @@ public void testIsTransformationRequired_afterDontTransform_isFalse() {
 
   @Test
   public void testApplyingDontTransform_overridesTransformations() {
-    options.transform(RuntimeEnvironment.application, transformation);
+    options.transform(transformation);
     options.dontTransform();
     assertThat(options.isTransformationSet()).isFalse();
     assertThat(options.isTransformationRequired()).isFalse();
     assertThat(options.getTransformations()).isEmpty();
   }
 
-  @Test
+@Test
   public void testApplyingTransformation_overridesDontTransform() {
     options.dontTransform();
-    options.transform(RuntimeEnvironment.application, transformation);
+    options.transform(transformation);
 
     assertThat(options.isTransformationAllowed()).isTrue();
     assertThat(options.isTransformationRequired()).isTrue();
@@ -88,8 +87,8 @@ public void testApplyingTransformation_overridesDontTransform() {
 
   @Test
   public void testApplyingOptions_withDontTransform_overridesTransformations() {
-    options.transform(RuntimeEnvironment.application, transformation);
-    TestOptions other = new TestOptions();
+    options.transform(transformation);
+    RequestOptions other = new RequestOptions();
     other.dontTransform();
 
     options.apply(other);
@@ -103,8 +102,8 @@ public void testApplyingOptions_withDontTransform_overridesTransformations() {
   @Test
   public void testApplyingOptions_withTransformation_overridesDontTransform() {
     options.dontTransform();
-    TestOptions other = new TestOptions();
-    other.transform(RuntimeEnvironment.application, transformation);
+    RequestOptions other = new RequestOptions();
+    other.transform(transformation);
 
     options.apply(other);
 
@@ -117,7 +116,7 @@ public void testApplyingOptions_withTransformation_overridesDontTransform() {
   @Test
   public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform() {
     options.dontTransform();
-    options.apply(new TestOptions());
+    options.apply(new RequestOptions());
 
     assertThat(options.isTransformationAllowed()).isFalse();
     assertThat(options.isTransformationRequired()).isFalse();
@@ -126,15 +125,11 @@ public void testApplyingDefaultOptions_withDontTransform_retainsDontTransform()
 
   @Test
   public void testApplyingDefaultOptions_withTransform_retrainsTransform() {
-    options.transform(RuntimeEnvironment.application, transformation);
-    options.apply(new TestOptions());
+    options.transform(transformation);
+    options.apply(new RequestOptions());
 
     assertThat(options.isTransformationAllowed()).isTrue();
     assertThat(options.isTransformationRequired()).isTrue();
     assertThat(options.getTransformations()).containsEntry(Bitmap.class, transformation);
   }
-
-  private static class TestOptions extends BaseRequestOptions<TestOptions> {
-    // Empty.
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 723fc3631..11e6a8bb7 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -278,7 +278,7 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), any(ResourceCallback.class));
+            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
   }
 
   @Test
@@ -297,7 +297,7 @@ public void testEngineLoadCancelledOnCancel() {
        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
           eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
           eq(harness.transformations), anyBoolean(), any(Options.class),
-          anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
+          anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenReturn(loadStatus);
 
     SingleRequest<List> request = harness.getRequest();
@@ -541,7 +541,8 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class)))
         .thenAnswer(new Answer<Object>() {
           @Override
           public Object answer(InvocationOnMock invocation) throws Throwable {
@@ -655,7 +656,8 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
   @Test
@@ -677,7 +679,7 @@ public void testCanReRunCancelledRequests() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
+            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenAnswer(new CallResourceCallback(harness.resource));
     SingleRequest<List> request = harness.getRequest();
 
@@ -706,7 +708,8 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
 
@@ -724,7 +727,8 @@ public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), eq(Boolean.TRUE), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), eq(Boolean.TRUE), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
   @Test
@@ -741,7 +745,8 @@ public void testCallsSourceExecutorEngineIfOptionsIsSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), eq(Boolean.FALSE), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), eq(Boolean.FALSE), anyBoolean(),
+            any(ResourceCallback.class));
   }
 
   // TODO do we want to move these to Util?
@@ -830,6 +835,11 @@ public void onResourceReady(List resource, Transition<? super List> transition)
     public void getSize(SizeReadyCallback cb) {
     }
 
+    @Override
+    public void removeCallback(SizeReadyCallback cb) {
+      // Do nothing.
+    }
+
     @Override
     public void setRequest(Request request) {
     }
diff --git a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
index 4fe6bf3d6..4ec3ed752 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java
@@ -18,7 +18,7 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowAppWidgetManager;
 
 @RunWith(RobolectricTestRunner.class)
@@ -31,7 +31,7 @@
 
   @Before
   public void setUp() {
-    shadowManager = (UpdateShadowAppWidgetManager) ShadowExtractor
+    shadowManager = (UpdateShadowAppWidgetManager) Shadow
         .extract(AppWidgetManager.getInstance(RuntimeEnvironment.application));
     viewId = 1234;
     views = mock(RemoteViews.class);
diff --git a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
index e48962886..eae33c7e4 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java
@@ -18,7 +18,7 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowNotificationManager;
 
 @RunWith(RobolectricTestRunner.class)
@@ -37,7 +37,7 @@
   public void setUp() {
     NotificationManager notificationManager = (NotificationManager) RuntimeEnvironment.application
         .getSystemService(Context.NOTIFICATION_SERVICE);
-    shadowManager = (UpdateShadowNotificationManager) ShadowExtractor.extract(notificationManager);
+    shadowManager = (UpdateShadowNotificationManager) Shadow.extract(notificationManager);
 
     remoteViews = mock(RemoteViews.class);
     viewId = 123;
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index aea5b2891..a31adc29c 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -13,46 +13,56 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import android.content.Context;
 import android.graphics.drawable.Drawable;
+import android.os.Build;
 import android.view.View;
 import android.view.ViewTreeObserver;
-import android.view.WindowManager;
 import com.bumptech.glide.request.Request;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.tests.Util;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
-import org.robolectric.internal.ShadowExtractor;
-import org.robolectric.shadows.ShadowDisplay;
+import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowView;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = { ViewTargetTest.SizedShadowView.class,
+@Config(manifest = Config.NONE, sdk = 19, shadows = { ViewTargetTest.SizedShadowView.class,
     ViewTargetTest.PreDrawShadowViewTreeObserver.class })
 public class ViewTargetTest {
   private View view;
   private ViewTarget<View, Object> target;
   private SizedShadowView shadowView;
   private PreDrawShadowViewTreeObserver shadowObserver;
+  @Mock private SizeReadyCallback cb;
+  @Mock private Request request;
+  private int sdkVersion;
 
   @Before
   public void setUp() {
+    sdkVersion = Build.VERSION.SDK_INT;
+    MockitoAnnotations.initMocks(this);
     view = new View(RuntimeEnvironment.application);
     target = new TestViewTarget(view);
 
-    shadowView = (SizedShadowView) ShadowExtractor.extract(view);
-    shadowObserver =
-        (PreDrawShadowViewTreeObserver) ShadowExtractor.extract(view.getViewTreeObserver());
+    shadowView = Shadow.extract(view);
+    shadowObserver = Shadow.extract(view.getViewTreeObserver());
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(sdkVersion);
   }
 
   @Test
@@ -73,8 +83,6 @@ public void testThrowsIfViewTagIsNotRequestObject() {
 
   @Test
   public void testCanSetAndRetrieveRequest() {
-    Request request = mock(Request.class);
-
     target.setRequest(request);
 
     assertEquals(request, target.getRequest());
@@ -82,8 +90,6 @@ public void testCanSetAndRetrieveRequest() {
 
   @Test
   public void testRetrievesRequestFromPreviousTargetForView() {
-    Request request = mock(Request.class);
-
     target.setRequest(request);
 
     ViewTarget<View, Object> second = new TestViewTarget(view);
@@ -94,10 +100,11 @@ public void testRetrievesRequestFromPreviousTargetForView() {
   @Test
   public void testSizeCallbackIsCalledSynchronouslyIfViewSizeSet() {
     int dimens = 333;
-    shadowView.setWidth(dimens);
-    shadowView.setHeight(dimens);
+    shadowView
+        .setWidth(dimens)
+        .setHeight(dimens)
+        .setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb).onSizeReady(eq(dimens), eq(dimens));
@@ -108,117 +115,84 @@ public void testSizeCallbackIsCalledSynchronouslyIfLayoutParamsConcreteSizeSet()
     int dimens = 444;
     LayoutParams layoutParams = new LayoutParams(dimens, dimens);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb).onSizeReady(eq(dimens), eq(dimens));
   }
 
-  private void setDisplayDimens(Integer width, Integer height) {
-    WindowManager windowManager =
-        (WindowManager) RuntimeEnvironment.application.getSystemService(Context.WINDOW_SERVICE);
-    ShadowDisplay shadowDisplay = Shadows.shadowOf(windowManager.getDefaultDisplay());
-    if (width != null) {
-      shadowDisplay.setWidth(width);
-    }
-
-    if (height != null) {
-      shadowDisplay.setHeight(height);
-    }
-  }
-
-  private void setDisplayWidth(int width) {
-    setDisplayDimens(width, null);
-  }
-
-  private void setDisplayHeight(int height) {
-    setDisplayDimens(null, height);
-  }
-
   @Test
-  public void testBothParamsWrapContent() {
+  public void getSize_withBothWrapContent_returnsSizeOriginal() {
     LayoutParams layoutParams =
         new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
 
-    int width = 123;
-    int height = 456;
-    setDisplayDimens(width, height);
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
-    verify(cb).onSizeReady(eq(width), eq(height));
+    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
   }
 
   @Test
-  public void testWrapContentWidthWithValidHeight() {
-    int displayWidth = 500;
-    setDisplayWidth(displayWidth);
-
+  public void getSize_withWrapContentWidthAndValidHeight_usesSizeOriginalWidthValidHeight() {
     int height = 100;
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, height);
     view.setLayoutParams(params);
+    shadowView.setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
-    verify(cb).onSizeReady(eq(displayWidth), eq(height));
+    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
   }
 
   @Test
-  public void testWrapContentHeightWithValidWidth() {
-    int displayHeight = 700;
-    setDisplayHeight(displayHeight);
+  public void getSize_withWrapContentHeightAndValidWidth_returnsWidthAndSizeOriginalHeight() {
     int width = 100;
     LayoutParams params = new LayoutParams(width, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
+    shadowView.setIsLaidOut(true);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
-    verify(cb).onSizeReady(eq(width), eq(displayHeight));
+    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
   }
 
   @Test
-  public void testWrapContentWidthWithMatchParentHeight() {
-    int displayWidth = 1234;
-    setDisplayWidth(displayWidth);
-
+  public void getSize_withWrapContentWidthAndMatchParentHeight_usesSizeOriginalWidthAndHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
     view.setLayoutParams(params);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int height = 32;
-    shadowView.setHeight(height);
+    shadowView
+        .setHeight(height)
+        .setIsLaidOut(true);
 
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(eq(displayWidth), eq(height));
+    verify(cb).onSizeReady(Target.SIZE_ORIGINAL, height);
   }
 
   @Test
-  public void testWrapContentHeightWithMatchParentWidth() {
-    int displayHeight = 5812;
-    setDisplayHeight(displayHeight);
-
+  public void getSize_withMatchParentWidthAndWrapContentHeight_usesWidthAndSizeOriginalHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
     view.setLayoutParams(params);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int width = 32;
-    shadowView.setWidth(width);
+    shadowView
+        .setWidth(width)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
-    verify(cb).onSizeReady(eq(width), eq(displayHeight));
+    verify(cb).onSizeReady(width, Target.SIZE_ORIGINAL);
   }
 
   @Test
@@ -226,15 +200,16 @@ public void testMatchParentWidthAndHeight() {
     LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
     view.setLayoutParams(params);
 
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     verify(cb, never()).onSizeReady(anyInt(), anyInt());
 
     int width = 32;
     int height = 45;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -242,13 +217,14 @@ public void testMatchParentWidthAndHeight() {
 
   @Test
   public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParams() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     int width = 12;
     int height = 32;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -263,8 +239,10 @@ public void testSizeCallbacksAreCalledInOrderPreDraw() {
     }
 
     int width = 100, height = 111;
-    shadowView.setWidth(width);
-    shadowView.setHeight(height);
+    shadowView
+        .setWidth(width)
+        .setHeight(height)
+        .setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     InOrder order = inOrder((Object[]) cbs);
@@ -275,11 +253,11 @@ public void testSizeCallbacksAreCalledInOrderPreDraw() {
 
   @Test
   public void testDoesNotNotifyCallbackTwiceIfAddedTwice() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
     target.getSize(cb);
 
     view.setLayoutParams(new LayoutParams(100, 100));
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
@@ -300,6 +278,7 @@ public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest
     target.getSize(cb1);
 
     view.setLayoutParams(new LayoutParams(100, 100));
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     assertThat(shadowObserver.getPreDrawListeners()).hasSize(0);
@@ -316,7 +295,6 @@ public void testDoesAddSecondListenerIfFirstListenerIsRemovedBeforeSecondRequest
 
   @Test
   public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
     shadowObserver.fireOnPreDrawListeners();
 
@@ -326,13 +304,13 @@ public void testSizeCallbackIsNotCalledPreDrawIfNoDimensSetOnPreDraw() {
 
   @Test
   public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutParamsSetLater() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     int width = 689;
     int height = 354;
     LayoutParams layoutParams = new LayoutParams(width, height);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
 
     verify(cb).onSizeReady(eq(width), eq(height));
@@ -340,11 +318,11 @@ public void testSizeCallbackIsCalledPreDrawIfNoDimensAndNoLayoutParamsButLayoutP
 
   @Test
   public void testCallbackIsNotCalledTwiceIfPreDrawFiresTwice() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     LayoutParams layoutParams = new LayoutParams(1234, 4123);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
     shadowObserver.fireOnPreDrawListeners();
 
@@ -362,6 +340,7 @@ public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
     int height = 875;
     LayoutParams layoutParams = new LayoutParams(width, height);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.fireOnPreDrawListeners();
     shadowObserver.fireOnPreDrawListeners();
 
@@ -371,13 +350,13 @@ public void testCallbacksFromMultipleRequestsAreNotifiedOnPreDraw() {
 
   @Test
   public void testDoesNotThrowOnPreDrawIfViewTreeObserverIsDead() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     target.getSize(cb);
 
     int width = 1;
     int height = 2;
     LayoutParams layoutParams = new LayoutParams(width, height);
     view.setLayoutParams(layoutParams);
+    shadowView.setIsLaidOut(true);
     shadowObserver.setIsAlive(false);
     shadowObserver.fireOnPreDrawListeners();
 
@@ -391,15 +370,77 @@ public void testThrowsIfGivenNullView() {
 
   @Test
   public void testDecreasesDimensionsByViewPadding() {
-    SizeReadyCallback cb = mock(SizeReadyCallback.class);
     view.setLayoutParams(new LayoutParams(100, 100));
     view.setPadding(25, 25, 25, 25);
+    shadowView.setIsLaidOut(true);
 
     target.getSize(cb);
 
     verify(cb).onSizeReady(50, 50);
   }
 
+  @Test
+  public void getSize_withValidWidthAndHeight_notLaidOut_doesNotCallSizeReady() {
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_notLaidOut_doesCallSizeReady() {
+    shadowView
+        .setLayoutParams(new LayoutParams(10, 10))
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, times(1)).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withLayoutParams_zeroWidthHeight_notLaidOut_doesNotCallSizeReady() {
+    shadowView
+        .setLayoutParams(new LayoutParams(0, 0))
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(false);
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withValidWidthAndHeight_preV19_layoutRequested_doesNotCallSizeReady() {
+    Util.setSdkVersionInt(18);
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .requestLayout();
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
+  @Test
+  public void getSize_withWidthAndHeightEqualToPadding_doesNotCallSizeReady() {
+    shadowView
+        .setWidth(100)
+        .setHeight(100)
+        .setIsLaidOut(true);
+
+    view.setPadding(50, 50, 50, 50);
+
+    target.getSize(cb);
+
+    verify(cb, never()).onSizeReady(anyInt(), anyInt());
+  }
+
   @Implements(ViewTreeObserver.class)
   public static class PreDrawShadowViewTreeObserver {
     private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
@@ -449,13 +490,33 @@ public void fireOnPreDrawListeners() {
   public static class SizedShadowView extends ShadowView {
     private int width;
     private int height;
+    private LayoutParams layoutParams;
+    private boolean isLaidOut;
+    private boolean isLayoutRequested;
 
-    public void setWidth(int width) {
+    public SizedShadowView setWidth(int width) {
       this.width = width;
+      return this;
     }
 
-    public void setHeight(int height) {
+    public SizedShadowView setHeight(int height) {
       this.height = height;
+      return this;
+    }
+
+    public SizedShadowView setLayoutParams(LayoutParams layoutParams) {
+      this.layoutParams = layoutParams;
+      return this;
+    }
+
+    public SizedShadowView setIsLaidOut(boolean isLaidOut) {
+      this.isLaidOut = isLaidOut;
+      return this;
+    }
+
+    @Implementation
+    public void requestLayout() {
+      isLayoutRequested = true;
     }
 
     @Implementation
@@ -467,6 +528,21 @@ public int getWidth() {
     public int getHeight() {
       return height;
     }
+
+    @Implementation
+    public boolean isLaidOut() {
+      return isLaidOut;
+    }
+
+    @Implementation
+    public boolean isLayoutRequested() {
+      return isLayoutRequested;
+    }
+
+    @Implementation
+    public LayoutParams getLayoutParams() {
+      return layoutParams;
+    }
   }
 
   private static class TestViewTarget extends ViewTarget<View, Object> {
diff --git a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
index 649c906de..95eaca505 100644
--- a/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
+++ b/library/src/test/java/com/bumptech/glide/resize/load/ExifTest.java
@@ -5,7 +5,7 @@
 
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;
-import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
+import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;
 import com.bumptech.glide.testutil.TestResourceUtil;
 import java.io.IOException;
 import java.io.InputStream;
@@ -29,7 +29,7 @@ private void assertOrientation(String filePrefix, int expectedOrientation) {
     InputStream is = null;
     try {
       is = open(filePrefix + "_" + expectedOrientation + ".jpg");
-      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),
+      assertEquals(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool),
           expectedOrientation);
     } catch (IOException e) {
       throw new RuntimeException(e);
@@ -52,7 +52,7 @@ public void setUp() {
   @Test
   public void testIssue387() throws IOException {
     InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
-    assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
+    assertThat(new DefaultImageHeaderParser().getOrientation(is, byteArrayPool)).isEqualTo(6);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/tests/Util.java b/library/src/test/java/com/bumptech/glide/tests/Util.java
index 5ca34fca6..e80796ba2 100644
--- a/library/src/test/java/com/bumptech/glide/tests/Util.java
+++ b/library/src/test/java/com/bumptech/glide/tests/Util.java
@@ -6,6 +6,7 @@
 import static org.mockito.Mockito.RETURNS_DEFAULTS;
 import static org.mockito.Mockito.mock;
 
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Build;
 import com.bumptech.glide.load.DataSource;
@@ -44,6 +45,10 @@ public static DataSource isADataSource() {
     return isA(DataSource.class);
   }
 
+  public static Context anyContext() {
+    return any(Context.class);
+  }
+
   /**
    * Creates a Mockito argument matcher to be used in verify.
    * It returns a generic typed {@link Resource} to prevent unchecked warnings.
diff --git a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java b/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
index 328bfb928..848321fe1 100644
--- a/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java
@@ -6,6 +6,7 @@
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.when;
 
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import org.junit.Before;
@@ -71,7 +72,7 @@ public void testAvailable_handlesReadValueOfZero() throws IOException {
     when(wrapped.read()).thenReturn(0);
 
     assertThat(is.read()).isEqualTo(0);
-    assertThat(is.available()).isEqualTo(contentLength);
+    assertThat(is.available()).isEqualTo(contentLength - 1);
   }
 
   @Test
@@ -130,4 +131,27 @@ public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow(
     when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
     is.read(new byte[10], 0, 0);
   }
+
+  @Test
+  public void testRead_readWithZeroes_doesNotThrow() throws IOException {
+    ByteArrayInputStream inner = new ByteArrayInputStream(new byte[] {0, 0, 0});
+    InputStream is = ContentLengthInputStream.obtain(inner, 3);
+
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(0);
+    assertThat(is.read()).isEqualTo(-1);
+  }
+
+  @Test
+  public void testRead_readWithHighValues_doesNotThrow() throws IOException {
+    ByteArrayInputStream inner =
+        new ByteArrayInputStream(new byte[] {(byte) 0xF0, (byte) 0xA0, (byte) 0xFF});
+    InputStream is = ContentLengthInputStream.obtain(inner, 3);
+
+    assertThat(is.read()).isEqualTo(0xF0);
+    assertThat(is.read()).isEqualTo(0xA0);
+    assertThat(is.read()).isEqualTo(0xFF);
+    assertThat(is.read()).isEqualTo(-1);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java b/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
index 8e23094cc..014cdaa19 100644
--- a/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
+++ b/library/src/test/java/com/bumptech/glide/util/ViewPreloadSizeProviderTest.java
@@ -46,6 +46,7 @@ public void testDoesNotObtainSizeFromViewOnceSizeIsSet() {
     int height = 456;
     provider.onSizeReady(width, height);
     view.setLayoutParams(new ViewGroup.LayoutParams(1, 1));
+    view.layout(0, 0, 1, 1);
 
     provider.setView(view);
 
@@ -58,6 +59,7 @@ public void testCanObtainFixedSizeFromView() {
     int width = 123;
     int height = 456;
     view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+    view.layout(0, 0, width, height);
 
     provider.setView(view);
 
@@ -81,6 +83,7 @@ public void testCanObtainSizeFromViewWhenGivenViewInConstructor() {
     int width = 100;
     int height = 200;
     view.setLayoutParams(new ViewGroup.LayoutParams(width, height));
+    view.layout(0, 0, width, height);
 
     provider = new ViewPreloadSizeProvider<>(view);
 
diff --git a/samples/contacturi/build.gradle b/samples/contacturi/build.gradle
index dccc94939..94799a5c2 100644
--- a/samples/contacturi/build.gradle
+++ b/samples/contacturi/build.gradle
@@ -4,6 +4,7 @@ dependencies {
     compile project(':library')
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
new file mode 100644
index 000000000..14dec10a2
--- /dev/null
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.contacturi;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Ensures that Glide's generated API is created for the Contact Uri sample.
+ */
+@GlideModule
+public class ContactUriModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
index 4fe9526c4..74aedca6b 100644
--- a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -13,7 +13,6 @@
 import android.provider.ContactsContract.Contacts;
 import android.view.View;
 import android.widget.ImageView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.Target;
 
@@ -72,20 +71,21 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
 
   @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
   private void showContact(long id) {
+    GlideRequests glideRequests = GlideApp.with(this);
     RequestOptions originalSize = new RequestOptions().override(Target.SIZE_ORIGINAL);
 
     Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI, id);
-    Glide.with(this).load(contactUri).apply(originalSize).into(imageViewContact);
+    glideRequests.load(contactUri).apply(originalSize).into(imageViewContact);
 
     Uri lookupUri = Contacts.getLookupUri(getContentResolver(), contactUri);
-    Glide.with(this).load(lookupUri).apply(originalSize).into(imageViewLookup);
+    glideRequests.load(lookupUri).apply(originalSize).into(imageViewLookup);
 
     Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
-    Glide.with(this).load(photoUri).apply(originalSize).into(imageViewPhoto);
+    glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);
 
     if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
       Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
-      Glide.with(this).load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
+      glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
     }
   }
 }
diff --git a/samples/flickr/build.gradle b/samples/flickr/build.gradle
index 3be1ccab8..a0233b7a8 100644
--- a/samples/flickr/build.gradle
+++ b/samples/flickr/build.gradle
@@ -5,6 +5,8 @@ dependencies {
     compile(project(':integration:recyclerview')) {
         transitive = false
     }
+    annotationProcessor project(':annotation:compiler')
+
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
     compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
@@ -17,7 +19,7 @@ android {
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.flickr'
-        minSdkVersion 11 // TODO it uses SearchView (and not the compat one)
+        minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
 
         versionCode 1
diff --git a/samples/flickr/src/main/AndroidManifest.xml b/samples/flickr/src/main/AndroidManifest.xml
index 0068f2ebf..9be7824f6 100644
--- a/samples/flickr/src/main/AndroidManifest.xml
+++ b/samples/flickr/src/main/AndroidManifest.xml
@@ -24,10 +24,5 @@
         </activity>
 
         <activity android:name=".FullscreenActivity"/>
-
-        <meta-data
-            android:name="com.bumptech.glide.samples.flickr.FlickrGlideModule"
-            android:value="GlideModule"/>
     </application>
-
 </manifest>
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
index f3e0558ec..cae1eaf14 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java
@@ -1,23 +1,25 @@
 package com.bumptech.glide.samples.flickr;
 
 import android.content.Context;
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import com.bumptech.glide.samples.flickr.api.Photo;
 import java.io.InputStream;
 
 /**
- * {@link com.bumptech.glide.module.GlideModule} for the Flickr sample app.
+ * Register {@link FlickrModelLoader} for the Flickr sample app.
  */
-public class FlickrGlideModule implements GlideModule {
+@GlideModule
+public class FlickrGlideModule extends AppGlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
+  public void registerComponents(Context context, Registry registry) {
+    registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
   }
 
+  // Disable manifest parsing to avoid adding similar modules twice.
   @Override
-  public void registerComponents(Context context, Registry registry) {
-    registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
+  public boolean isManifestParsingEnabled() {
+    return false;
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
index 9fc6a2340..57f3c23cf 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java
@@ -1,9 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
 import static com.bumptech.glide.GenericTransitionOptions.withNoTransition;
-import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
-import static com.bumptech.glide.request.RequestOptions.priorityOf;
 
 import android.content.Intent;
 import android.graphics.Rect;
@@ -44,9 +41,9 @@
   private int photoSize;
   private RecyclerView grid;
   private boolean thumbnail;
-  private RequestBuilder<Drawable> fullRequest;
-  private RequestBuilder<Drawable> thumbnailRequest;
-  private RequestBuilder<Drawable> preloadRequest;
+  private GlideRequest<Drawable> fullRequest;
+  private GlideRequest<Drawable> thumbnailRequest;
+  private GlideRequest<Drawable> preloadRequest;
   private GridLayoutManager layoutManager;
 
   public static FlickrPhotoGrid newInstance(int size, int preloadCount, boolean thumbnail) {
@@ -66,20 +63,20 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
     photoSize = args.getInt(IMAGE_SIZE_KEY);
     thumbnail = args.getBoolean(THUMBNAIL_KEY);
 
-    fullRequest = Glide.with(this)
+    fullRequest = GlideApp.with(this)
         .asDrawable()
-        .transition(withNoTransition())
-        .apply(centerCropTransform(getActivity()));
+        .centerCrop()
+        .transition(withNoTransition());
 
-    thumbnailRequest = Glide.with(this)
+    thumbnailRequest = GlideApp.with(this)
         .asDrawable()
-        .transition(withNoTransition())
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
-            .centerCrop(getActivity())
-            .override(Api.SQUARE_THUMB_SIZE));
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .centerCrop()
+        .override(Api.SQUARE_THUMB_SIZE)
+        .transition(withNoTransition());
 
     preloadRequest =
-        thumbnail ? thumbnailRequest.clone().apply(priorityOf(Priority.HIGH)) : fullRequest;
+        thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;
 
     final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);
 
@@ -100,7 +97,7 @@ public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
       @Override
       public void onViewRecycled(RecyclerView.ViewHolder holder) {
         PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;
-        Glide.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
+        GlideApp.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);
       }
     });
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
index c23ffdb0f..701710e04 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java
@@ -1,8 +1,6 @@
 package com.bumptech.glide.samples.flickr;
 
 import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
-import static com.bumptech.glide.request.RequestOptions.centerCropTransform;
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
 
 import android.content.Intent;
 import android.graphics.Color;
@@ -17,10 +15,8 @@
 import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.TextView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.samples.flickr.api.Api;
@@ -39,8 +35,8 @@
   private FlickrPhotoListAdapter adapter;
   private List<Photo> currentPhotos;
   private RecyclerView list;
-  private RequestBuilder<Drawable> fullRequest;
-  private RequestBuilder<Drawable> thumbRequest;
+  private GlideRequest<Drawable> fullRequest;
+  private GlideRequest<Drawable> thumbRequest;
   private ViewPreloadSizeProvider<Photo> preloadSizeProvider;
   private LinearLayoutManager layoutManager;
 
@@ -68,8 +64,9 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
     list.setAdapter(adapter);
 
     preloadSizeProvider = new ViewPreloadSizeProvider<>();
-    RecyclerViewPreloader<Photo> preloader = new RecyclerViewPreloader<>(Glide.with(this), adapter,
-        preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
+    RecyclerViewPreloader<Photo> preloader =
+        new RecyclerViewPreloader<>(
+            GlideApp.with(this), adapter, preloadSizeProvider, PRELOAD_AHEAD_ITEMS);
     list.addOnScrollListener(preloader);
     list.setItemViewCacheSize(0);
 
@@ -77,23 +74,23 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
       adapter.setPhotos(currentPhotos);
     }
 
-    final RequestManager requestManager = Glide.with(this);
-    fullRequest = requestManager
+    final GlideRequests glideRequests = GlideApp.with(this);
+    fullRequest = glideRequests
         .asDrawable()
-        .apply(centerCropTransform(getActivity())
-            .placeholder(new ColorDrawable(Color.GRAY)));
+        .centerCrop()
+        .placeholder(new ColorDrawable(Color.GRAY));
 
-    thumbRequest = requestManager
+    thumbRequest = glideRequests
         .asDrawable()
-        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
-            .override(Api.SQUARE_THUMB_SIZE))
+        .diskCacheStrategy(DiskCacheStrategy.DATA)
+        .override(Api.SQUARE_THUMB_SIZE)
         .transition(withCrossFade());
 
     list.setRecyclerListener(new RecyclerView.RecyclerListener() {
       @Override
       public void onViewRecycled(RecyclerView.ViewHolder holder) {
         PhotoTitleViewHolder vh = (PhotoTitleViewHolder) holder;
-        requestManager.clear(vh.imageView);
+        glideRequests.clear(vh.imageView);
       }
     });
 
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
index e29dd3f9d..47cbadb89 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java
@@ -23,7 +23,6 @@
 import android.view.ViewGroup;
 import android.widget.SearchView;
 import android.widget.TextView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.load.engine.prefill.PreFillType;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.samples.flickr.api.Api;
@@ -157,7 +156,8 @@ public void onCreate(Bundle savedInstanceState) {
     if (savedInstanceState == null) {
       // Weight values determined experimentally by measuring the number of incurred GCs while
       // scrolling through the various photo grids/lists.
-      Glide.get(this).preFillBitmapPool(new PreFillType.Builder(smallGridSize).setWeight(1),
+      GlideApp.get(this).preFillBitmapPool(
+          new PreFillType.Builder(smallGridSize).setWeight(1),
           new PreFillType.Builder(mediumGridSize).setWeight(1),
           new PreFillType.Builder(screenWidth / 2, listHeightSize).setWeight(6));
     }
@@ -191,13 +191,13 @@ protected void onDestroy() {
   @Override
   public void onTrimMemory(int level) {
     super.onTrimMemory(level);
-    Glide.get(this).trimMemory(level);
+    GlideApp.get(this).trimMemory(level);
   }
 
   @Override
   public void onLowMemory() {
     super.onLowMemory();
-    Glide.get(this).clearMemory();
+    GlideApp.get(this).clearMemory();
   }
 
   private void executeSearch(String searchString) {
@@ -284,13 +284,13 @@ public void setPrimaryItem(ViewGroup container, int position, Object object) {
       super.setPrimaryItem(container, position, object);
       if (position != mLastPosition) {
         if (mLastPosition >= 0) {
-          Glide.with(mLastFragment).pauseRequests();
+          GlideApp.with(mLastFragment).pauseRequests();
         }
         Fragment current = (Fragment) object;
         mLastPosition = position;
         mLastFragment = current;
         if (current.isAdded()) {
-          Glide.with(current).resumeRequests();
+          GlideApp.with(current).resumeRequests();
         }
       }
     }
@@ -349,7 +349,7 @@ public void run() {
           return;
         }
 
-        FutureTarget<File> futureTarget = Glide.with(context)
+        FutureTarget<File> futureTarget = GlideApp.with(context)
             .downloadOnly()
             .load(photo)
             .submit(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);
@@ -365,7 +365,7 @@ public void run() {
             Log.d(TAG, "Got ExecutionException waiting for background downloadOnly", e);
           }
         }
-        Glide.with(context).clear(futureTarget);
+        GlideApp.with(context).clear(futureTarget);
       }
     }
   }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
index 65c110caa..ba3095dc2 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.samples.flickr;
 
-
 import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
 
 import android.content.Context;
@@ -8,7 +7,6 @@
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
 import android.widget.ImageView;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.samples.flickr.api.Photo;
 
 /**
@@ -30,9 +28,6 @@ protected void onCreate(Bundle savedInstanceState) {
     ImageView fullscreenView = (ImageView) findViewById(R.id.fullscreen_view);
     Photo photo = getIntent().getParcelableExtra(ARG_PHOTO);
 
-    Glide.with(this)
-        .load(photo)
-        .apply(fitCenterTransform(this))
-        .into(fullscreenView);
+    GlideApp.with(this).load(photo).apply(fitCenterTransform()).into(fullscreenView);
   }
 }
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
index 1560cf82e..5988e6bf8 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java
@@ -1,15 +1,14 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.os.Build;
+import android.support.v7.widget.AppCompatImageView;
 import android.util.AttributeSet;
 import android.widget.ImageView;
 
 /**
  * An always square {@link ImageView}.
  */
-public final class SquareImageView extends ImageView {
+public final class SquareImageView extends AppCompatImageView {
 
   public SquareImageView(Context context) {
     super(context);
@@ -23,11 +22,6 @@ public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
   }
 
-  @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-  public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-    super(context, attrs, defStyleAttr, defStyleRes);
-  }
-
   @Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     super.onMeasure(widthMeasureSpec, widthMeasureSpec);
diff --git a/samples/gallery/build.gradle b/samples/gallery/build.gradle
index 481e13026..9f1cce8bc 100644
--- a/samples/gallery/build.gradle
+++ b/samples/gallery/build.gradle
@@ -7,6 +7,7 @@ dependencies {
     }
     compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
     compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
new file mode 100644
index 000000000..e5d4888ab
--- /dev/null
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/GalleryModule.java
@@ -0,0 +1,12 @@
+package com.bumptech.glide.samples.gallery;
+
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
+
+/**
+ * Ensures that Glide's generated API is created for the Gallery sample.
+ */
+@GlideModule
+public final class GalleryModule extends AppGlideModule {
+  // Intentionally empty.
+}
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
index 472c96a0e..30933931c 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java
@@ -9,8 +9,6 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;
 import java.util.List;
 
@@ -49,11 +47,11 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
   @Override
   public void onLoadFinished(Loader<List<MediaStoreData>> loader,
       List<MediaStoreData> mediaStoreData) {
-    RequestManager requestManager = Glide.with(this);
+    GlideRequests glideRequests = GlideApp.with(this);
     RecyclerAdapter adapter =
-        new RecyclerAdapter(getActivity(), mediaStoreData, requestManager);
+        new RecyclerAdapter(getActivity(), mediaStoreData, glideRequests);
     RecyclerViewPreloader<MediaStoreData> preloader =
-        new RecyclerViewPreloader<>(requestManager, adapter, adapter, 3);
+        new RecyclerViewPreloader<>(glideRequests, adapter, adapter, 3);
     recyclerView.addOnScrollListener(preloader);
     recyclerView.setAdapter(adapter);
   }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
index fc8e0315a..f600840b1 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java
@@ -2,7 +2,6 @@
 
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
-import com.bumptech.glide.Glide;
 import com.bumptech.glide.MemoryCategory;
 
 /**
@@ -14,6 +13,6 @@
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.main_activity);
-        Glide.get(this).setMemoryCategory(MemoryCategory.HIGH);
+        GlideApp.get(this).setMemoryCategory(MemoryCategory.HIGH);
     }
 }
diff --git a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
index 4e9b27d67..2486badfd 100644
--- a/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java
@@ -1,13 +1,8 @@
 package com.bumptech.glide.samples.gallery;
 
-import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;
-import static com.bumptech.glide.request.RequestOptions.signatureOf;
-
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
-import android.os.Build;
 import android.support.v7.widget.RecyclerView;
 import android.view.Display;
 import android.view.LayoutInflater;
@@ -18,7 +13,6 @@
 import android.widget.ImageView;
 import com.bumptech.glide.ListPreloader;
 import com.bumptech.glide.RequestBuilder;
-import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.signature.MediaStoreSignature;
 import java.util.Collections;
@@ -33,15 +27,13 @@
 
   private final List<MediaStoreData> data;
   private final int screenWidth;
-  private final RequestBuilder<Drawable> requestBuilder;
+  private final GlideRequest<Drawable> requestBuilder;
 
   private int[] actualDimensions;
 
-  RecyclerAdapter(Context context, List<MediaStoreData> data, RequestManager requestManager) {
+  RecyclerAdapter(Context context, List<MediaStoreData> data, GlideRequests glideRequests) {
     this.data = data;
-    requestBuilder = requestManager
-        .asDrawable()
-        .apply(fitCenterTransform(context));
+    requestBuilder = glideRequests.asDrawable().fitCenter();
 
     setHasStableIds(true);
 
@@ -79,7 +71,7 @@ public void onBindViewHolder(ListViewHolder viewHolder, int position) {
 
     requestBuilder
         .clone()
-        .apply(signatureOf(signature))
+        .signature(signature)
         .load(current.uri)
         .into(viewHolder.image);
   }
@@ -110,7 +102,7 @@ public int getItemViewType(int position) {
         new MediaStoreSignature(item.mimeType, item.dateModified, item.orientation);
     return requestBuilder
         .clone()
-        .apply(signatureOf(signature))
+        .signature(signature)
         .load(item.uri);
   }
 
@@ -120,21 +112,13 @@ public int getItemViewType(int position) {
   }
 
   // Display#getSize(Point)
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
   @SuppressWarnings("deprecation")
   private static int getScreenWidth(Context context) {
     WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
     Display display = wm.getDefaultDisplay();
-
-    final int result;
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
-      Point size = new Point();
-      display.getSize(size);
-      result = size.x;
-    } else {
-      result = display.getWidth();
-    }
-    return result;
+    Point size = new Point();
+    display.getSize(size);
+    return size.x;
   }
 
   /**
diff --git a/samples/giphy/build.gradle b/samples/giphy/build.gradle
index fc5b166fc..e2931ad27 100644
--- a/samples/giphy/build.gradle
+++ b/samples/giphy/build.gradle
@@ -5,8 +5,9 @@ dependencies {
     compile(project(':integration:recyclerview')) {
         transitive = false
     }
-    compile 'com.google.code.gson:gson:2.3'
+    compile 'com.google.code.gson:gson:2.4'
     compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}"
+    annotationProcessor project(':annotation:compiler')
 }
 
 android {
@@ -15,7 +16,7 @@ android {
 
     defaultConfig {
         applicationId 'com.bumptech.glide.samples.giphy'
-        minSdkVersion 14 // TODO uses Holo.Light.DarkActionBar theme
+        minSdkVersion MIN_SDK_VERSION as int
         targetSdkVersion TARGET_SDK_VERSION as int
         versionCode 1
         versionName '1.0'
diff --git a/samples/giphy/src/main/AndroidManifest.xml b/samples/giphy/src/main/AndroidManifest.xml
index 509f10a58..8d3ac29ac 100644
--- a/samples/giphy/src/main/AndroidManifest.xml
+++ b/samples/giphy/src/main/AndroidManifest.xml
@@ -20,10 +20,5 @@
             </intent-filter>
         </activity>
         <activity android:name=".FullscreenActivity"/>
-
-        <meta-data
-            android:name="com.bumptech.glide.samples.giphy.GiphyGlideModule"
-            android:value="GlideModule"/>
     </application>
-
 </manifest>
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
index a8c1152d7..999600314 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyGlideModule.java
@@ -1,22 +1,24 @@
 package com.bumptech.glide.samples.giphy;
 
 import android.content.Context;
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import java.io.InputStream;
 
 /**
- * {@link com.bumptech.glide.module.GlideModule} implementation for the Giphy sample app.
+ * Configures Glide for the Giphy sample app.
  */
-public class GiphyGlideModule implements GlideModule {
+@GlideModule
+public class GiphyGlideModule extends AppGlideModule {
   @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
+  public void registerComponents(Context context, Registry registry) {
+    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
   }
 
+  // Disable manifest parsing to avoid adding similar modules twice.
   @Override
-  public void registerComponents(Context context, Registry registry) {
-    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
+  public boolean isManifestParsingEnabled() {
+    return false;
   }
 }
diff --git a/samples/svg/build.gradle b/samples/svg/build.gradle
index 58a4e9f06..e244935ea 100644
--- a/samples/svg/build.gradle
+++ b/samples/svg/build.gradle
@@ -2,6 +2,7 @@ apply plugin: 'com.android.application'
 
 dependencies {
     compile project(':library')
+    annotationProcessor project(':annotation:compiler')
     compile 'com.caverock:androidsvg:1.2.1'
 }
 
diff --git a/samples/svg/src/main/AndroidManifest.xml b/samples/svg/src/main/AndroidManifest.xml
index 9eb410d93..7328e723d 100644
--- a/samples/svg/src/main/AndroidManifest.xml
+++ b/samples/svg/src/main/AndroidManifest.xml
@@ -8,9 +8,6 @@
         android:allowBackup="true"
         android:icon="@android:drawable/sym_def_app_icon"
         android:label="@string/app_name">
-        <meta-data
-            android:name="com.bumptech.glide.samples.svg.SvgModule"
-            android:value="GlideModule"/>
         <activity
             android:name=".MainActivity"
             android:label="@string/app_name">
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
index 0587c01f7..f60b46461 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.samples.svg;
 
 import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
-import static com.bumptech.glide.request.RequestOptions.placeholderOf;
 
 import android.app.Activity;
 import android.content.ContentResolver;
@@ -12,10 +11,8 @@
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.TextView;
-
 import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
-
 import java.io.File;
 
 /**
@@ -36,10 +33,10 @@ protected void onCreate(Bundle savedInstanceState) {
     imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
     imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);
 
-    requestBuilder = Glide.with(this)
+    requestBuilder = GlideApp.with(this)
         .as(PictureDrawable.class)
-        .apply(placeholderOf(R.drawable.image_loading)
-            .error(R.drawable.image_error))
+        .placeholder(R.drawable.image_loading)
+        .error(R.drawable.image_error)
         .transition(withCrossFade())
         .listener(new SvgSoftwareLayerSetter());
   }
@@ -52,9 +49,10 @@ protected void onStart() {
 
   public void clearCache(View v) {
     Log.w(TAG, "clearing cache");
-    Glide.with(this).clear(imageViewRes);
-    Glide.with(this).clear(imageViewNet);
-    Glide.get(this).clearMemory();
+    GlideRequests glideRequests = GlideApp.with(this);
+    glideRequests.clear(imageViewRes);
+    glideRequests.clear(imageViewNet);
+    GlideApp.get(this).clearMemory();
     File cacheDir = Glide.getPhotoCacheDir(this);
     if (cacheDir.isDirectory()) {
       for (File child : cacheDir.listFiles()) {
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
index b3cfcbfe0..372fbefb6 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java
@@ -2,26 +2,26 @@
 
 import android.content.Context;
 import android.graphics.drawable.PictureDrawable;
-
-import com.bumptech.glide.GlideBuilder;
 import com.bumptech.glide.Registry;
-import com.bumptech.glide.module.GlideModule;
+import com.bumptech.glide.annotation.GlideModule;
+import com.bumptech.glide.module.AppGlideModule;
 import com.caverock.androidsvg.SVG;
-
 import java.io.InputStream;
 
 /**
  * Module for the SVG sample app.
  */
-public class SvgModule implements GlideModule {
-  @Override
-  public void applyOptions(Context context, GlideBuilder builder) {
-    // Do nothing.
-  }
-
+@GlideModule
+public class SvgModule extends AppGlideModule {
   @Override
   public void registerComponents(Context context, Registry registry) {
     registry.register(SVG.class, PictureDrawable.class, new SvgDrawableTranscoder())
         .append(InputStream.class, SVG.class, new SvgDecoder());
   }
+
+  // Disable manifest parsing to avoid adding similar modules twice.
+  @Override
+  public boolean isManifestParsingEnabled() {
+    return false;
+  }
 }
diff --git a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
index c3b4aa003..a28a21b7c 100644
--- a/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java
@@ -1,10 +1,7 @@
 package com.bumptech.glide.samples.svg;
 
-import android.annotation.TargetApi;
 import android.graphics.drawable.PictureDrawable;
-import android.os.Build;
 import android.widget.ImageView;
-
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.engine.GlideException;
 import com.bumptech.glide.request.RequestListener;
@@ -16,16 +13,13 @@
  * {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on
  * a hardware backed {@link android.graphics.Canvas Canvas}.
  */
-@TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public class SvgSoftwareLayerSetter implements RequestListener<PictureDrawable> {
 
   @Override
   public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawable> target,
       boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
-    }
+    view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
     return false;
   }
 
@@ -33,9 +27,7 @@ public boolean onLoadFailed(GlideException e, Object model, Target<PictureDrawab
   public boolean onResourceReady(PictureDrawable resource, Object model,
       Target<PictureDrawable> target, DataSource dataSource, boolean isFirstResource) {
     ImageView view = ((ImageViewTarget<?>) target).getView();
-    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
-      view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
-    }
+    view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
     return false;
   }
 }
diff --git a/scripts/update_javadocs.sh b/scripts/update_javadocs.sh
new file mode 100755
index 000000000..a8646613b
--- /dev/null
+++ b/scripts/update_javadocs.sh
@@ -0,0 +1,54 @@
+#!/bin/bash
+set -e
+set -o pipefail
+
+TEMP_DIR="/tmp/tmp_glide_javadoc"
+JAVADOC_GH_PAGES_DIR="javadocs"
+
+if [[ -z "$1" ]]; 
+then
+  echo "You must supply a target version"
+  echo "Usage ./scripts/update_javadocs.sh <400>"
+  exit 1
+fi
+
+if [[ $(git status -uno --porcelain) ]];
+then 
+  echo "One or more changes, commit or revert first."
+  git status -uno --porcelain
+  exit 1
+fi
+
+if [ -e "$JAVADOC_GH_PAGES_DIR" ];
+then 
+  echo "javadocs directory exists locally, remove first."
+  exit 1
+fi
+
+if [[ $(git rev-list master...origin/master --count) -ne 0 ]]; 
+then 
+  echo "Origin and master are not up to date"
+  git rev-list master...origin/master --pretty
+  exit 1
+fi
+if [[ $(git rev-list gh-pages...origin/gh-pages --count) -ne 0 ]]; 
+then 
+  echo "Origin and gh-pages are not up to date"
+  git rev-list gh-pages...origin/gh-pages --pretty
+  exit 1
+fi
+
+git checkout master
+GIT_COMMIT_SHA="$(git rev-parse HEAD)"   
+./gradlew clean releaseJavadocJar javadoc
+rm -rf $TEMP_DIR
+cp -r glide/build/docs/javadoc $TEMP_DIR
+git checkout gh-pages
+rm -rf "${JAVADOC_GH_PAGES_DIR}/${1}"
+cp -r $TEMP_DIR $JAVADOC_GH_PAGES_DIR/$1
+rm -rf $TEMP_DIR
+git add "${JAVADOC_GH_PAGES_DIR}/$1" 
+git commit -m "Update javadocs for version $1" -m "Generated from commit on master branch: ${GIT_COMMIT_SHA}"
+echo "Copied javadoc into ${JAVADOC_GH_PAGES_DIR}/${1} and committed"
+git log -1 --pretty=%B
+echo "Ready to push"
diff --git a/settings.gradle b/settings.gradle
index a936e3039..650b0e229 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,7 +1,9 @@
 exec {
-  commandLine "git", "submodule", "update", "--init", "--recursive"
+    commandLine "git", "submodule", "update", "--init", "--recursive"
 }
 include ':library'
+include ':annotation'
+include ':annotation:compiler'
 include ':glide'
 include ':third_party:gif_decoder'
 include ':third_party:disklrucache'
diff --git a/third_party/disklrucache b/third_party/disklrucache
index 8106ee054..273f119c6 160000
--- a/third_party/disklrucache
+++ b/third_party/disklrucache
@@ -1 +1 @@
-Subproject commit 8106ee05443357bf9e17e0f88390bf047448a2df
+Subproject commit 273f119c607eb55da0627ebb4a0c1b0d1a15b2dc
diff --git a/third_party/gif_decoder/gradle.properties b/third_party/gif_decoder/gradle.properties
index 386921883..9ada85d40 100644
--- a/third_party/gif_decoder/gradle.properties
+++ b/third_party/gif_decoder/gradle.properties
@@ -1,10 +1,4 @@
 POM_NAME=Glide GIF Decoder Library
 POM_ARTIFACT_ID=gifdecoder
 POM_PACKAGING=aar
-
-VERSION_NAME=1.0.0-SNAPSHOT
-VERSION_MAJOR=1
-VERSION_MINOR=0
-VERSION_PATCH=0
-
 POM_DESCRIPTION=Implementation of GifDecoder that is more memory efficient to animate for Android devices.
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index 90ccfbfc7..257cd98f0 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -20,6 +20,8 @@
   int STATUS_OPEN_ERROR = 2;
   /** Unable to fully decode the current frame. */
   int STATUS_PARTIAL_DECODE = 3;
+  /** The total iteration count which means repeat forever. */
+  int TOTAL_ITERATION_COUNT_FOREVER = 0;
 
   /** Android Lint annotation for status codes that can be used with a GIF decoder. */
   @Retention(RetentionPolicy.SOURCE)
@@ -126,12 +128,55 @@
   void resetFrameIndex();
 
   /**
-   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
+   * Gets the "Netscape" loop count, if any. A count of 0 means repeat indefinitely.
    *
-   * @return iteration count if one was specified, else 1.
+   * @deprecated Use {@link #getNetscapeLoopCount()} instead.
+   *             This method cannot distinguish whether the loop count is 1 or doesn't exist.
+   * @return loop count if one was specified, else 1.
    */
+  @Deprecated
   int getLoopCount();
 
+  /**
+   * Gets the "Netscape" loop count, if any.
+   * A count of 0 ({@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <br>
+   * Use {@link #getTotalIterationCount()}
+   * to know how many times the animation sequence should be displayed.
+   *
+   * @return loop count if one was specified,
+   *         else -1 ({@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}).
+   */
+  int getNetscapeLoopCount();
+
+  /**
+   * Gets the total count
+   * which represents how many times the animation sequence should be displayed.
+   * A count of 0 ({@link #TOTAL_ITERATION_COUNT_FOREVER}) means repeat indefinitely.
+   * It must not be a negative value.
+   * <p>
+   *     The total count is calculated as follows by using {@link #getNetscapeLoopCount()}.
+   *     This behavior is the same as most web browsers.
+   *     <table border='1'>
+   *         <tr class='tableSubHeadingColor'><th>{@code getNetscapeLoopCount()}</th>
+   *             <th>The total count</th></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}</td>
+   *             <td>{@link #TOTAL_ITERATION_COUNT_FOREVER}</td></tr>
+   *         <tr><td>{@link GifHeader#NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST}</td>
+   *             <td>{@code 1}</td></tr>
+   *         <tr><td>{@code n (n > 0)}</td>
+   *             <td>{@code n + 1}</td></tr>
+   *     </table>
+   * </p>
+   *
+   * @see <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=592735#c5">Discussion about
+   *      the iteration count of animated GIFs (Chromium Issue 592735)</a>
+   *
+   * @return total iteration count calculated from "Netscape" loop count.
+   */
+  int getTotalIterationCount();
+
   /**
    * Returns an estimated byte size for this decoder based on the data provided to {@link
    * #setData(GifHeader, byte[])}, as well as internal buffers.
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index a0a9629f4..d43f7cca7 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -14,6 +14,11 @@
  */
 public class GifHeader {
 
+  /** The "Netscape" loop count which means loop forever. */
+  public static final int NETSCAPE_LOOP_COUNT_FOREVER = 0;
+  /** Indicates that this header has no "Netscape" loop count. */
+  public static final int NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST = -1;
+
   @ColorInt
   int[] gct = null;
   @GifDecoder.GifDecodeStatus
@@ -43,7 +48,7 @@
   int pixelAspect;
   @ColorInt
   int bgColor;
-  int loopCount;
+  int loopCount = NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
 
   public int getHeight() {
     return height;
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
index fa84d3f7f..05662c04e 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java
@@ -460,7 +460,8 @@ private void skip() {
     int blockSize;
     do {
       blockSize = read();
-      rawData.position(rawData.position() + blockSize);
+      int newPosition = Math.min(rawData.position() + blockSize, rawData.limit());
+      rawData.position(newPosition);
     } while (blockSize > 0);
   }
 
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
index f61279d42..80825fb09 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -28,9 +28,7 @@
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_PREVIOUS;
 import static com.bumptech.glide.gifdecoder.GifFrame.DISPOSAL_UNSPECIFIED;
 
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.os.Build;
 import android.support.annotation.ColorInt;
 import android.support.annotation.Nullable;
 import android.util.Log;
@@ -202,9 +200,28 @@ public void resetFrameIndex() {
 
   @Override
   public int getLoopCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
     return header.loopCount;
   }
 
+  @Override
+  public int getNetscapeLoopCount() {
+    return header.loopCount;
+  }
+
+  @Override
+  public int getTotalIterationCount() {
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST) {
+      return 1;
+    }
+    if (header.loopCount == GifHeader.NETSCAPE_LOOP_COUNT_FOREVER) {
+      return TOTAL_ITERATION_COUNT_FOREVER;
+    }
+    return header.loopCount + 1;
+  }
+
   @Override
   public int getByteSize() {
     return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
@@ -763,14 +780,7 @@ private Bitmap getNextBitmap() {
     Bitmap.Config config = isFirstFrameTransparent
         ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
     Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
-    setAlpha(result);
+    result.setHasAlpha(true);
     return result;
   }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-  private static void setAlpha(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
-      bitmap.setHasAlpha(true);
-    }
-  }
 }
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 23d368e50..13a581303 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -58,6 +58,36 @@ public void testFrameIndexStartsAtNegativeOne() {
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
 
+  @Test
+  public void testTotalIterationCountIsOneIfNetscapeLoopCountDoesntExist() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(1, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsForeverIfNetscapeLoopCountIsForever() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = GifHeader.NETSCAPE_LOOP_COUNT_FOREVER;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER, decoder.getTotalIterationCount());
+  }
+
+  @Test
+  public void testTotalIterationCountIsTwoIfNetscapeLoopCountIsOne() {
+    GifHeader gifheader = new GifHeader();
+    gifheader.loopCount = 1;
+    byte[] data = new byte[0];
+    GifDecoder decoder = new StandardGifDecoder(provider);
+    decoder.setData(gifheader, data);
+    assertEquals(2, decoder.getTotalIterationCount());
+  }
+
   @Test
   public void testAdvanceIncrementsFrameIndex() {
     GifHeader gifheader = new GifHeader();
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
index 3d45f5d39..55dfa41a4 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java
@@ -65,6 +65,58 @@ public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOEx
     assertEquals(GifDecoder.STATUS_OK, header.status);
   }
 
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIsZero() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_0.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_FOREVER, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_1() throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_1.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(1, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x0F()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_255.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(255, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0x10()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_256.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(256, header.loopCount);
+  }
+
+  @Test
+  public void testCanReadNetscapeIterationCountIfNetscapeIterationCountIs_0xFF()
+      throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_netscape_iteration_65535.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(65535, header.loopCount);
+  }
+
+  @Test
+  public void testLoopCountReturnsMinusOneWithoutNetscapeIterationCount()
+          throws IOException {
+    byte[] data = TestUtil.resourceToBytes(getClass(), "gif_without_netscape_iteration.gif");
+    parser.setData(data);
+    GifHeader header = parser.parseHeader();
+    assertEquals(GifHeader.NETSCAPE_LOOP_COUNT_DOES_NOT_EXIST, header.loopCount);
+  }
+
   @Test
   public void testCanReadImageDescriptorWithoutGraphicalExtension() {
     final int lzwMinCodeSize = 2;
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif
new file mode 100644
index 000000000..3dd7c1cb6
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_0.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif
new file mode 100644
index 000000000..480dc8c64
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_1.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif
new file mode 100644
index 000000000..62a489ea2
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_255.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif
new file mode 100644
index 000000000..c0443cd42
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_256.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif
new file mode 100644
index 000000000..b976157c3
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_netscape_iteration_65535.gif differ
diff --git a/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif
new file mode 100644
index 000000000..f67b1b6bf
Binary files /dev/null and b/third_party/gif_decoder/src/test/resources/gif_without_netscape_iteration.gif differ
