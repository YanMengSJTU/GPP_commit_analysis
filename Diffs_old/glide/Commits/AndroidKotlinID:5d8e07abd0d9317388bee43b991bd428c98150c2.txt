diff --git a/build.gradle b/build.gradle
index 9f289bb15..d7b42257b 100644
--- a/build.gradle
+++ b/build.gradle
@@ -62,8 +62,6 @@ subprojects { project ->
                 lintOptions {
                     warningsAsErrors true
                     quiet true
-                    // TODO(#2730): Remove this after updating to the latest support library.
-                    disable "GradleDependency"
                 }
             }
         }
diff --git a/gradle.properties b/gradle.properties
index f85a3f09f..65e27a5e3 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -15,7 +15,7 @@ POM_SCM_DEV_CONNECTION=scm:git@github.com:bumptech/glide.git
 POM_DEVELOPER_ID=sjudd
 POM_DEVELOPER_NAME=Sam Judd
 POM_DEVELOPER_EMAIL=judds@google.com
-ANDROID_SUPPORT_VERSION=26.1.0
+ANDROID_SUPPORT_VERSION=27.0.2
 VOLLEY_VERSION=1.0.0
 OK_HTTP_VERSION=3.9.0
 ANDROID_GRADLE_VERSION=3.0.1
@@ -25,7 +25,7 @@ JUNIT_VERSION=4.13-SNAPSHOT
 # Matches the version in Google.
 MOCKITO_VERSION=1.9.5
 MOCKITO_ANDROID_VERSION=2.11.0
-ROBOLECTRIC_VERSION=3.3.2
+ROBOLECTRIC_VERSION=3.6.1
 MOCKWEBSERVER_VERSION=3.0.0-RC1
 TRUTH_VERSION=0.36
 JSR_305_VERSION=3.0.2
@@ -36,8 +36,8 @@ PMD_VERSION=5.4.0
 FINDBUGS_VERSION=3.0.0
 ERROR_PRONE_VERSION=0.0.13
 
-COMPILE_SDK_VERSION=26
-TARGET_SDK_VERSION=26
+COMPILE_SDK_VERSION=27
+TARGET_SDK_VERSION=27
 MIN_SDK_VERSION=14
 
 org.gradle.jvmargs=-Xmx2048M
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
new file mode 100644
index 000000000..920e9635b
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java
@@ -0,0 +1,221 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.google.common.io.ByteStreams;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(AndroidJUnit4.class)
+public class AsBytesTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadImageResourceId_asBytes_providesBytesOfBitmap() {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.canonical)
+                .submit());
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmap_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(bitmap)
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadBitmapDrawable_asBytes_providesBytesOfBitmap() {
+    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(new BitmapDrawable(context.getResources(), bitmap))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBytes_withFrameTime_providesBytesOfFrame() {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile())
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFile_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFilePath_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(writeVideoToFile().getAbsolutePath())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            Glide.with(context)
+                .as(byte[].class)
+                .load(Uri.fromFile(writeVideoToFile()))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  @Test
+  public void loadVideoFileUri_asBytes_withFrameTime_providesByteOfFrame() throws IOException {
+    byte[] data =
+        concurrency.get(
+            GlideApp.with(context)
+                .as(byte[].class)
+                .load(Uri.fromFile(writeVideoToFile()))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(data).isNotNull();
+    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();
+  }
+
+  private File writeVideoToFile() throws IOException {
+    byte[] videoData = loadVideoBytes();
+    File parent = context.getCacheDir();
+    if (!parent.mkdirs() && (!parent.exists() || !parent.isDirectory())) {
+      throw new IllegalStateException("Failed to mkdirs for: " + parent);
+    }
+    File toWrite = new File(parent, "temp.jpeg");
+    if (toWrite.exists() && !toWrite.delete()) {
+      throw new IllegalStateException("Failed to delete existing temp file: " + toWrite);
+    }
+
+    OutputStream os = null;
+    try {
+      os = new BufferedOutputStream(new FileOutputStream(toWrite));
+      os.write(videoData);
+      os.close();
+    } finally {
+      if (os != null) {
+        os.close();
+      }
+    }
+    return toWrite;
+  }
+
+  private byte[] loadVideoBytes() throws IOException {
+    Resources resources = context.getResources();
+    InputStream is = resources.openRawResource(ResourceIds.raw.video);
+    return ByteStreams.toByteArray(is);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
new file mode 100644
index 000000000..d99570490
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java
@@ -0,0 +1,323 @@
+package com.bumptech.glide;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests that Glide is able to load videos stored in resources and loaded as
+ * {@link android.content.res.AssetFileDescriptor}s.
+ */
+@RunWith(AndroidJUnit4.class)
+public class LoadVideoResourceTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
+
+  private Context context;
+
+  @Before
+  public void setUp() throws IOException {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            Glide.with(context)
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_fromInt_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            Glide.with(context)
+                .load(new Integer(ResourceIds.raw.video))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  // Testing boxed integer.
+  @SuppressWarnings("UnnecessaryBoxing")
+  @Test
+  public void loadVideoResourceId_fromInteger_withFrameTime_decodesFrame() {
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(new Integer(ResourceIds.raw.video))
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(
+            Glide.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceId_asBitmap_withFrameTime_decodesFrame() {
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(ResourceIds.raw.video)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromId_withFrame_decodesFrame() {
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(context.getPackageName())
+            .path(String.valueOf(ResourceIds.raw.video))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Drawable frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_asBitmap_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUri_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri)
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+
+  @Test
+  public void loadVideoResourceUriString_fromName_withFrame_decodesFrame() {
+    Resources resources = context.getResources();
+    int resourceId = ResourceIds.raw.video;
+    Uri uri =
+        new Uri.Builder()
+            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+            .authority(resources.getResourcePackageName(resourceId))
+            .appendPath(resources.getResourceTypeName(resourceId))
+            .appendPath(resources.getResourceEntryName(resourceId))
+            .build();
+
+    Bitmap frame =
+        concurrency.get(
+            GlideApp.with(context)
+                .asBitmap()
+                .load(uri.toString())
+                .frame(TimeUnit.SECONDS.toMicros(1))
+                .submit());
+
+    assertThat(frame).isNotNull();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
index 1580247d0..ce9b7663f 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -43,7 +43,7 @@ public boolean await(long timeout, TimeUnit timeUnit) throws InterruptedExceptio
           reference.set(future.get(timeout, timeUnit));
           return true;
         } catch (ExecutionException e) {
-          throw new RuntimeException(e);
+          throw new RuntimeException(e.getCause());
         } catch (TimeoutException e) {
           return false;
         }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
index 3be32f73f..1211eb751 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java
@@ -21,6 +21,7 @@ private ResourceIds() {
     int opaque_gif = getResourceId("raw", "opaque_gif");
     int opaque_interlaced_gif = getResourceId("raw", "opaque_interlaced_gif");
     int webkit_logo_p3 = getResourceId("raw", "webkit_logo_p3");
+    int video = getResourceId("raw", "video");
   }
 
   public interface drawable {
diff --git a/instrumentation/src/main/res/raw/video.mp4 b/instrumentation/src/main/res/raw/video.mp4
new file mode 100644
index 000000000..3ffc91a98
Binary files /dev/null and b/instrumentation/src/main/res/raw/video.mp4 differ
diff --git a/integration/okhttp/build.gradle b/integration/okhttp/build.gradle
index f86e60534..627e957bb 100644
--- a/integration/okhttp/build.gradle
+++ b/integration/okhttp/build.gradle
@@ -4,7 +4,7 @@ dependencies {
     implementation project(':library')
     annotationProcessor project(':annotation:compiler')
 
-    api "com.squareup.okhttp:okhttp:2.7.1"
+    api "com.squareup.okhttp:okhttp:2.7.2"
     api "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}"
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 190ca1b71..5d2535aa0 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -2,7 +2,9 @@
 
 import android.app.Activity;
 import android.content.ComponentCallbacks2;
+import android.content.ContentResolver;
 import android.content.Context;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -19,6 +21,7 @@
 import android.view.View;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.DecodeFormat;
+import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.data.InputStreamRewinder;
 import com.bumptech.glide.load.engine.Engine;
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
@@ -54,7 +57,7 @@
 import com.bumptech.glide.load.resource.bitmap.ResourceBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
 import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.load.resource.bytes.ByteBufferRewinder;
 import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;
 import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;
@@ -66,6 +69,7 @@
 import com.bumptech.glide.load.resource.gif.StreamGifDecoder;
 import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.BitmapDrawableTranscoder;
+import com.bumptech.glide.load.resource.transcode.DrawableBytesTranscoder;
 import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
 import com.bumptech.glide.manager.RequestManagerRetriever;
@@ -333,7 +337,8 @@ private static void throwIncorrectGlideModule(Exception e) {
         resources.getDisplayMetrics(), bitmapPool, arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
         new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
-    VideoBitmapDecoder videoBitmapDecoder = new VideoBitmapDecoder(bitmapPool);
+    ResourceDecoder<ParcelFileDescriptor, Bitmap> parcelFileDescriptorVideoDecoder =
+        VideoDecoder.parcel(bitmapPool);
     ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);
     StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);
     ResourceDrawableDecoder resourceDrawableDecoder =
@@ -344,8 +349,15 @@ private static void throwIncorrectGlideModule(Exception e) {
         new ResourceLoader.UriFactory(resources);
     ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =
         new ResourceLoader.FileDescriptorFactory(resources);
+    ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory =
+        new ResourceLoader.AssetFileDescriptorFactory(resources);
     BitmapEncoder bitmapEncoder = new BitmapEncoder();
 
+    BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();
+    GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();
+
+    ContentResolver contentResolver = context.getContentResolver();
+
     registry
         .append(ByteBuffer.class, new ByteBufferEncoder())
         .append(InputStream.class, new StreamEncoder(arrayPool))
@@ -353,10 +365,18 @@ private static void throwIncorrectGlideModule(Exception e) {
         .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)
         .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder)
         .append(
-            Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class, videoBitmapDecoder)
+            Registry.BUCKET_BITMAP,
+            ParcelFileDescriptor.class,
+            Bitmap.class,
+            parcelFileDescriptorVideoDecoder)
         .append(
-            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
+            Registry.BUCKET_BITMAP,
+            AssetFileDescriptor.class,
+            Bitmap.class,
+            VideoDecoder.asset(bitmapPool))
         .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance())
+        .append(
+            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder())
         .append(Bitmap.class, bitmapEncoder)
         /* BitmapDrawables */
         .append(
@@ -373,7 +393,7 @@ private static void throwIncorrectGlideModule(Exception e) {
             Registry.BUCKET_BITMAP_DRAWABLE,
             ParcelFileDescriptor.class,
             BitmapDrawable.class,
-            new BitmapDrawableDecoder<>(resources, videoBitmapDecoder))
+            new BitmapDrawableDecoder<>(resources, parcelFileDescriptorVideoDecoder))
         .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder))
         /* GIFs */
         .append(
@@ -408,33 +428,49 @@ private static void throwIncorrectGlideModule(Exception e) {
         .register(new InputStreamRewinder.Factory(arrayPool))
         .append(int.class, InputStream.class, resourceLoaderStreamFactory)
         .append(
-                int.class,
-                ParcelFileDescriptor.class,
-                resourceLoaderFileDescriptorFactory)
+            int.class,
+            ParcelFileDescriptor.class,
+            resourceLoaderFileDescriptorFactory)
         .append(Integer.class, InputStream.class, resourceLoaderStreamFactory)
         .append(
-                Integer.class,
-                ParcelFileDescriptor.class,
-                resourceLoaderFileDescriptorFactory)
+            Integer.class,
+            ParcelFileDescriptor.class,
+            resourceLoaderFileDescriptorFactory)
         .append(Integer.class, Uri.class, resourceLoaderUriFactory)
+        .append(
+            int.class,
+            AssetFileDescriptor.class,
+            resourceLoaderAssetFileDescriptorFactory)
+        .append(
+            Integer.class,
+            AssetFileDescriptor.class,
+            resourceLoaderAssetFileDescriptorFactory)
         .append(int.class, Uri.class, resourceLoaderUriFactory)
         .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
+        .append(
+            String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
         .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
         .append(
-                Uri.class,
-                ParcelFileDescriptor.class,
-                new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+            Uri.class,
+            ParcelFileDescriptor.class,
+            new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
         .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
         .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
         .append(
             Uri.class,
             InputStream.class,
-            new UriLoader.StreamFactory(context.getContentResolver()))
-        .append(Uri.class, ParcelFileDescriptor.class,
-             new UriLoader.FileDescriptorFactory(context.getContentResolver()))
+            new UriLoader.StreamFactory(contentResolver))
+        .append(
+            Uri.class,
+            ParcelFileDescriptor.class,
+             new UriLoader.FileDescriptorFactory(contentResolver))
+        .append(
+            Uri.class,
+            AssetFileDescriptor.class,
+            new UriLoader.AssetFileDescriptorFactory(contentResolver))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
         .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
@@ -449,8 +485,13 @@ private static void throwIncorrectGlideModule(Exception e) {
             Bitmap.class,
             BitmapDrawable.class,
             new BitmapDrawableTranscoder(resources))
-        .register(Bitmap.class, byte[].class, new BitmapBytesTranscoder())
-        .register(GifDrawable.class, byte[].class, new GifDrawableBytesTranscoder());
+        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)
+        .register(
+            Drawable.class,
+            byte[].class,
+            new DrawableBytesTranscoder(
+                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))
+        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);
 
     ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
     glideContext =
diff --git a/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
new file mode 100644
index 000000000..66a287823
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/data/AssetFileDescriptorLocalUriFetcher.java
@@ -0,0 +1,39 @@
+package com.bumptech.glide.load.data;
+
+import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+/**
+ * Fetches an {@link AssetFileDescriptor} for a local {@link android.net.Uri}.
+ */
+public final class AssetFileDescriptorLocalUriFetcher extends LocalUriFetcher<AssetFileDescriptor> {
+
+  public AssetFileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
+  }
+
+  @Override
+  protected AssetFileDescriptor loadResource(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    AssetFileDescriptor result = contentResolver.openAssetFileDescriptor(uri, "r");
+    if (result == null) {
+      throw new FileNotFoundException("FileDescriptor is null for: " + uri);
+    }
+    return result;
+  }
+
+  @Override
+  protected void close(AssetFileDescriptor data) throws IOException {
+    data.close();
+  }
+
+  @NonNull
+  @Override
+  public Class<AssetFileDescriptor> getDataClass() {
+    return AssetFileDescriptor.class;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
index b84cf52ef..79d05eff5 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java
@@ -26,6 +26,7 @@
   private Key key;
   private DataSource dataSource;
   private Class<?> dataClass;
+  private String detailMessage;
 
   public GlideException(String message) {
     this(message, Collections.<Throwable>emptyList());
@@ -36,7 +37,7 @@ public GlideException(String detailMessage, Throwable cause) {
   }
 
   public GlideException(String detailMessage, List<Throwable> causes) {
-    super(detailMessage);
+    this.detailMessage = detailMessage;
     setStackTrace(EMPTY_ELEMENTS);
     this.causes = causes;
   }
@@ -51,6 +52,8 @@ void setLoggingDetails(Key key, DataSource dataSource, Class<?> dataClass) {
     this.dataClass = dataClass;
   }
 
+
+
   // No need to synchronize when doing nothing whatsoever.
   @SuppressWarnings("UnsynchronizedOverridesSynchronized")
   @Override
@@ -131,12 +134,30 @@ private void printStackTrace(Appendable appendable) {
     appendCauses(getCauses(), new IndentedAppendable(appendable));
   }
 
+  // PMD doesn't seem to notice that we're allocating the builder with the suggested size.
+  @SuppressWarnings("PMD.InsufficientStringBufferDeclaration")
   @Override
   public String getMessage() {
-    return super.getMessage()
-        + (dataClass != null ? ", " + dataClass : "")
-        + (dataSource != null ? ", " + dataSource : "")
-        + (key != null ? ", " + key : "");
+    StringBuilder result = new StringBuilder(71)
+        .append(detailMessage)
+        .append(dataClass != null ? ", " + dataClass : "")
+        .append(dataSource != null ? ", " + dataSource : "")
+        .append(key != null ? ", " + key : "");
+
+    List<Throwable> rootCauses = getRootCauses();
+    if (rootCauses.isEmpty()) {
+      return result.toString();
+    } else if (rootCauses.size() == 1) {
+      result.append("\nThere was 1 cause:");
+    } else {
+      result.append("\nThere were ").append(rootCauses.size()).append(" causes:");
+    }
+    for (Throwable cause : rootCauses) {
+      result.append('\n')
+          .append(cause.getClass().getName()).append('(').append(cause.getMessage()).append(')');
+    }
+    result.append("\n call GlideException#logRootCauses(String) for more detail");
+    return result.toString();
   }
 
   // Appendable throws, PrintWriter, PrintStream, and IndentedAppendable do not, so this should
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 5ede18bb8..1abc1fab4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -1,6 +1,7 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
@@ -104,6 +105,30 @@ public void teardown() {
     }
   }
 
+  /**
+   * Loads {@link AssetFileDescriptor}s from resource ids.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Integer, AssetFileDescriptor> {
+
+    private final Resources resources;
+
+    public AssetFileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
+    @Override
+    public ModelLoader<Integer, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
   /**
    * Factory for loading resource {@link Uri}s from Android resource ids.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index 26e2c95ec..9ce67c102 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.model;
 
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.NonNull;
@@ -91,4 +92,21 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from Strings.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<String, AssetFileDescriptor> {
+
+    @Override
+    public ModelLoader<String, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new StringLoader<>(multiFactory.build(Uri.class, AssetFileDescriptor.class));
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index 3b02a4902..77a316dd4 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -1,10 +1,12 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
+import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.AssetFileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.data.FileDescriptorLocalUriFetcher;
 import com.bumptech.glide.load.data.StreamLocalUriFetcher;
@@ -94,8 +96,8 @@ public void teardown() {
   /**
    * Loads {@link ParcelFileDescriptor}s from {@link Uri}s.
    */
-  public static class FileDescriptorFactory implements ModelLoaderFactory<Uri,
-      ParcelFileDescriptor>,
+  public static class FileDescriptorFactory
+      implements ModelLoaderFactory<Uri, ParcelFileDescriptor>,
       LocalUriFetcherFactory<ParcelFileDescriptor> {
 
     private final ContentResolver contentResolver;
@@ -120,4 +122,33 @@ public void teardown() {
       // Do nothing.
     }
   }
+
+  /**
+   * Loads {@link AssetFileDescriptor}s from {@link Uri}s.
+   */
+  public static final class AssetFileDescriptorFactory
+      implements ModelLoaderFactory<Uri, AssetFileDescriptor>,
+      LocalUriFetcherFactory<AssetFileDescriptor> {
+
+    private final ContentResolver contentResolver;
+
+    public AssetFileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
+    @Override
+    public ModelLoader<Uri, AssetFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+
+    @Override
+    public DataFetcher<AssetFileDescriptor> build(Uri uri) {
+      return new AssetFileDescriptorLocalUriFetcher(contentResolver, uri);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index 678961ed0..0685decb1 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -10,7 +10,7 @@
 import com.bumptech.glide.load.model.ModelLoader;
 import com.bumptech.glide.load.model.ModelLoaderFactory;
 import com.bumptech.glide.load.model.MultiModelLoaderFactory;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.signature.ObjectKey;
 import java.io.InputStream;
 
@@ -18,8 +18,8 @@
  * Loads {@link InputStream}s from media store video {@link Uri}s that point to pre-generated
  * thumbnails for those {@link Uri}s in the media store.
  *
- * <p>If {@link VideoBitmapDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
- * {@link VideoBitmapDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
+ * <p>If {@link VideoDecoder#TARGET_FRAME} is set with a non-null value that is not equal to
+ * {@link VideoDecoder#DEFAULT_FRAME}, this loader will always return {@code null}. The media
  * store does not use a defined frame to generate the thumbnail, so we cannot accurately fulfill
  * requests for specific frames.
  */
@@ -44,8 +44,8 @@ public MediaStoreVideoThumbLoader(Context context) {
   }
 
   private boolean isRequestingDefaultFrame(Options options) {
-    Long specifiedFrame = options.get(VideoBitmapDecoder.TARGET_FRAME);
-    return specifiedFrame != null && specifiedFrame == VideoBitmapDecoder.DEFAULT_FRAME;
+    Long specifiedFrame = options.get(VideoDecoder.TARGET_FRAME);
+    return specifiedFrame != null && specifiedFrame == VideoDecoder.DEFAULT_FRAME;
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
index e888fd5c1..3ef5b5b3e 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java
@@ -48,6 +48,9 @@ public boolean handles(@NonNull Uri source, @NonNull Options options) {
   public Resource<Bitmap> decode(@NonNull Uri source, int width, int height,
       @NonNull Options options) {
     Resource<Drawable> drawableResource = drawableDecoder.decode(source, width, height, options);
+    if (drawableResource == null) {
+      return null;
+    }
     Drawable drawable = drawableResource.get();
     return DrawableToBitmapConverter.convert(bitmapPool, drawable, width, height);
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
index ce47e2f6b..226765e2d 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java
@@ -1,20 +1,9 @@
 package com.bumptech.glide.load.resource.bitmap;
 
 import android.content.Context;
-import android.graphics.Bitmap;
-import android.media.MediaMetadataRetriever;
 import android.os.ParcelFileDescriptor;
-import android.support.annotation.NonNull;
-import android.support.annotation.VisibleForTesting;
 import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.Option;
-import com.bumptech.glide.load.Options;
-import com.bumptech.glide.load.ResourceDecoder;
-import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.security.MessageDigest;
 
 /**
  * An {@link com.bumptech.glide.load.ResourceDecoder} that can decode a thumbnail frame
@@ -22,134 +11,21 @@
  * video.
  *
  * @see android.media.MediaMetadataRetriever
+ *
+ * @deprecated Use {@link VideoDecoder#parcel(BitmapPool)} instead. This class may be removed and
+ * {@link VideoDecoder} may become final in a future version of Glide.
  */
-public class VideoBitmapDecoder implements ResourceDecoder<ParcelFileDescriptor, Bitmap> {
-  /**
-   * A constant indicating we should use whatever frame we consider best, frequently not the first
-   * frame.
-   */
-  public static final long DEFAULT_FRAME = -1;
-
-  /**
-   * A long indicating the time position (in microseconds) of the target frame which will be
-   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
-   * extract the video frame.
-   *
-   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
-   * source has a frame located at the position. When this happens, a frame nearby will be returned.
-   * If the long is negative, time position and option will ignored, and any frame that the
-   * implementation considers as representative may be returned.
-   */
-  public static final Option<Long> TARGET_FRAME = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
-      new Option.CacheKeyUpdater<Long>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
-
-        @Override
-        public void update(byte[] keyBytes, Long value, MessageDigest messageDigest) {
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putLong(value).array());
-          }
-        }
-      });
-
-  /**
-   * An integer indicating the frame option used to retrieve a target frame.
-   *
-   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
-   * {@link #DEFAULT_FRAME}.
-   *
-   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
-   */
-  // Public API.
-  @SuppressWarnings("WeakerAccess")
-  public static final Option<Integer> FRAME_OPTION = Option.disk(
-      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
-      null /*defaultValue*/,
-      new Option.CacheKeyUpdater<Integer>() {
-        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
+@Deprecated
+public class VideoBitmapDecoder extends VideoDecoder<ParcelFileDescriptor> {
 
-        @Override
-        public void update(byte[] keyBytes, Integer value, MessageDigest messageDigest) {
-          if (value == null) {
-            return;
-          }
-          messageDigest.update(keyBytes);
-          synchronized (buffer) {
-            buffer.position(0);
-            messageDigest.update(buffer.putInt(value).array());
-          }
-        }
-      }
-  );
-
-  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
-      new MediaMetadataRetrieverFactory();
-
-  private final BitmapPool bitmapPool;
-  private final MediaMetadataRetrieverFactory factory;
-
-  // Public API.
   @SuppressWarnings("unused")
   public VideoBitmapDecoder(Context context) {
     this(Glide.get(context).getBitmapPool());
   }
 
+  // Public API
+  @SuppressWarnings("WeakerAccess")
   public VideoBitmapDecoder(BitmapPool bitmapPool) {
-    this(bitmapPool, DEFAULT_FACTORY);
-  }
-
-  @VisibleForTesting
-  VideoBitmapDecoder(BitmapPool bitmapPool, MediaMetadataRetrieverFactory factory) {
-    this.bitmapPool = bitmapPool;
-    this.factory = factory;
-  }
-
-  @Override
-  public boolean handles(@NonNull ParcelFileDescriptor data, @NonNull Options options) {
-    // Calling setDataSource is expensive so avoid doing so unless we're actually called.
-    // For non-videos this isn't any cheaper, but for videos it saves the redundant call and
-    // 50-100ms.
-    return true;
-  }
-
-  @Override
-  public Resource<Bitmap> decode(@NonNull ParcelFileDescriptor resource, int outWidth,
-      int outHeight, @NonNull Options options) throws IOException {
-    long frameTimeMicros = options.get(TARGET_FRAME);
-    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
-      throw new IllegalArgumentException(
-          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
-    }
-    Integer frameOption = options.get(FRAME_OPTION);
-
-    final Bitmap result;
-    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
-    try {
-      mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());
-      if (frameTimeMicros == DEFAULT_FRAME) {
-        result = mediaMetadataRetriever.getFrameAtTime();
-      } else if (frameOption == null) {
-        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);
-      } else {
-        result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
-      }
-    } catch (RuntimeException e) {
-      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data.
-      throw new IOException(e);
-    } finally {
-      mediaMetadataRetriever.release();
-    }
-    resource.close();
-    return BitmapResource.obtain(result, bitmapPool);
-  }
-
-  @VisibleForTesting
-  static class MediaMetadataRetrieverFactory {
-    public MediaMetadataRetriever build() {
-      return new MediaMetadataRetriever();
-    }
+    super(bitmapPool, new ParcelFileDescriptorInitializer());
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
new file mode 100644
index 000000000..c58e781dc
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java
@@ -0,0 +1,209 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.annotation.TargetApi;
+import android.content.res.AssetFileDescriptor;
+import android.graphics.Bitmap;
+import android.media.MediaMetadataRetriever;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
+import android.os.ParcelFileDescriptor;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
+import com.bumptech.glide.load.Option;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.security.MessageDigest;
+
+
+/**
+ * Decodes video data to Bitmaps from {@link ParcelFileDescriptor}s and
+ * {@link AssetFileDescriptor}s.
+ *
+ * @param <T> The type of data, currently either {@link ParcelFileDescriptor} or
+ * {@link AssetFileDescriptor}.
+ */
+public class VideoDecoder<T> implements ResourceDecoder<T, Bitmap> {
+
+  /**
+   * A constant indicating we should use whatever frame we consider best, frequently not the first
+   * frame.
+   */
+  public static final long DEFAULT_FRAME = -1;
+
+  /** Matches the behavior of {@link MediaMetadataRetriever#getFrameAtTime(long)}. */
+  @VisibleForTesting
+  static final int DEFAULT_FRAME_OPTION = MediaMetadataRetriever.OPTION_CLOSEST_SYNC;
+
+  /**
+   * A long indicating the time position (in microseconds) of the target frame which will be
+   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to
+   * extract the video frame.
+   *
+   * <p>When retrieving the frame at the given time position, there is no guarantee that the data
+   * source has a frame located at the position. When this happens, a frame nearby will be returned.
+   * If the long is negative, time position and option will ignored, and any frame that the
+   * implementation considers as representative may be returned.
+   */
+  public static final Option<Long> TARGET_FRAME = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.TargetFrame", DEFAULT_FRAME,
+      new Option.CacheKeyUpdater<Long>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
+        @Override
+        public void update(byte[] keyBytes, Long value, MessageDigest messageDigest) {
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putLong(value).array());
+          }
+        }
+      });
+
+  /**
+   * An integer indicating the frame option used to retrieve a target frame.
+   *
+   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to
+   * {@link #DEFAULT_FRAME}.
+   *
+   * @see MediaMetadataRetriever#getFrameAtTime(long, int)
+   */
+  // Public API.
+  @SuppressWarnings("WeakerAccess")
+  public static final Option<Integer> FRAME_OPTION = Option.disk(
+      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",
+      /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,
+      new Option.CacheKeyUpdater<Integer>() {
+        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);
+        @Override
+        public void update(byte[] keyBytes, Integer value, MessageDigest messageDigest) {
+          if (value == null) {
+            return;
+          }
+          messageDigest.update(keyBytes);
+          synchronized (buffer) {
+            buffer.position(0);
+            messageDigest.update(buffer.putInt(value).array());
+          }
+        }
+      }
+  );
+
+  private static final MediaMetadataRetrieverFactory DEFAULT_FACTORY =
+      new MediaMetadataRetrieverFactory();
+
+  private final MediaMetadataRetrieverInitializer<T> initializer;
+  private final BitmapPool bitmapPool;
+  private final MediaMetadataRetrieverFactory factory;
+
+  public static ResourceDecoder<AssetFileDescriptor, Bitmap> asset(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new AssetFileDescriptorInitializer());
+  }
+
+  public static ResourceDecoder<ParcelFileDescriptor, Bitmap> parcel(BitmapPool bitmapPool) {
+    return new VideoDecoder<>(bitmapPool, new ParcelFileDescriptorInitializer());
+  }
+
+  VideoDecoder(
+      BitmapPool bitmapPool, MediaMetadataRetrieverInitializer<T> initializer) {
+    this(bitmapPool, initializer, DEFAULT_FACTORY);
+  }
+
+  @VisibleForTesting
+  VideoDecoder(
+      BitmapPool bitmapPool,
+      MediaMetadataRetrieverInitializer<T> initializer,
+      MediaMetadataRetrieverFactory factory) {
+    this.bitmapPool = bitmapPool;
+    this.initializer = initializer;
+    this.factory = factory;
+  }
+
+  @Override
+  public boolean handles(@NonNull T data, @NonNull Options options) {
+    // Calling setDataSource is expensive so avoid doing so unless we're actually called.
+    // For non-videos this isn't any cheaper, but for videos it safes the redundant call and
+    // 50-100ms.
+    return true;
+  }
+
+  @Override
+  public Resource<Bitmap> decode(
+      @NonNull T resource, int outWidth, int outHeight, @NonNull Options options)
+      throws IOException {
+    long frameTimeMicros = options.get(TARGET_FRAME);
+    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {
+      throw new IllegalArgumentException(
+          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);
+    }
+    Integer frameOption = options.get(FRAME_OPTION);
+    if (frameOption == null) {
+      frameOption = DEFAULT_FRAME_OPTION;
+    }
+
+    final Bitmap result;
+    MediaMetadataRetriever mediaMetadataRetriever = factory.build();
+    try {
+      initializer.initialize(mediaMetadataRetriever, resource);
+      result =
+          decodeFrame(mediaMetadataRetriever, frameTimeMicros, frameOption, outWidth, outHeight);
+    } catch (RuntimeException e) {
+      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data.
+      throw new IOException(e);
+    } finally {
+      mediaMetadataRetriever.release();
+    }
+
+    return BitmapResource.obtain(result, bitmapPool);
+  }
+
+  @TargetApi(Build.VERSION_CODES.O_MR1)
+  @Nullable
+  private static Bitmap decodeFrame(
+      MediaMetadataRetriever mediaMetadataRetriever,
+      long frameTimeMicros,
+      int frameOption,
+      int outWidth,
+      int outHeight) {
+     if (Build.VERSION.SDK_INT >= VERSION_CODES.O_MR1) {
+       return mediaMetadataRetriever.getScaledFrameAtTime(
+           frameTimeMicros, frameOption, outWidth, outHeight);
+    } else {
+      return mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);
+    }
+  }
+
+  @VisibleForTesting
+  static class MediaMetadataRetrieverFactory {
+    public MediaMetadataRetriever build() {
+      return new MediaMetadataRetriever();
+    }
+  }
+
+  @VisibleForTesting
+  interface MediaMetadataRetrieverInitializer<T> {
+    void initialize(MediaMetadataRetriever retriever, T data);
+  }
+
+  private static final class AssetFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<AssetFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, AssetFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor(), data.getStartOffset(), data.getLength());
+    }
+  }
+
+  // Visible for VideoBitmapDecoder.
+  static final class ParcelFileDescriptorInitializer
+      implements MediaMetadataRetrieverInitializer<ParcelFileDescriptor> {
+
+    @Override
+    public void initialize(MediaMetadataRetriever retriever, ParcelFileDescriptor data) {
+      retriever.setDataSource(data.getFileDescriptor());
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
index 09b327382..2cba88462 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java
@@ -2,6 +2,7 @@
 
 import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.engine.Resource;
 
 /**
@@ -11,8 +12,9 @@
 final class NonOwnedDrawableResource extends DrawableResource<Drawable> {
 
   @SuppressWarnings("unchecked")
-  static Resource<Drawable> newInstance(Drawable drawable) {
-    return new NonOwnedDrawableResource(drawable);
+  @Nullable
+  static Resource<Drawable> newInstance(@Nullable Drawable drawable) {
+    return drawable != null ? new NonOwnedDrawableResource(drawable) : null;
   }
 
   private NonOwnedDrawableResource(Drawable drawable) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
index da440845a..1550ef519 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java
@@ -7,6 +7,7 @@
 import android.net.Uri;
 import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
 import com.bumptech.glide.load.engine.Resource;
@@ -40,7 +41,7 @@ public boolean handles(@NonNull Uri source, @NonNull Options options) {
     return source.getScheme().equals(ContentResolver.SCHEME_ANDROID_RESOURCE);
   }
 
-  @NonNull
+  @Nullable
   @Override
   public Resource<Drawable> decode(@NonNull Uri source, int width, int height,
       @NonNull Options options) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
new file mode 100644
index 000000000..59be855f3
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java
@@ -0,0 +1,51 @@
+package com.bumptech.glide.load.resource.transcode;
+
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.bitmap.BitmapResource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+
+/**
+ * Obtains {@code byte[]} from {@link BitmapDrawable}s by delegating to a
+ * {@link ResourceTranscoder} for {@link Bitmap}s to {@code byte[]}s.
+ */
+public final class DrawableBytesTranscoder
+    implements ResourceTranscoder<Drawable, byte[]> {
+
+  private final BitmapPool bitmapPool;
+  private final ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder;
+  private final ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder;
+
+  public DrawableBytesTranscoder(
+      BitmapPool bitmapPool,
+      ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder,
+      ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder) {
+    this.bitmapPool = bitmapPool;
+    this.bitmapBytesTranscoder = bitmapBytesTranscoder;
+    this.gifDrawableBytesTranscoder = gifDrawableBytesTranscoder;
+  }
+
+  @Nullable
+  @Override
+  public Resource<byte[]> transcode(Resource<Drawable> toTranscode, Options options) {
+    Drawable drawable = toTranscode.get();
+    if (drawable instanceof BitmapDrawable) {
+      return bitmapBytesTranscoder.transcode(
+          BitmapResource.obtain(((BitmapDrawable) drawable).getBitmap(), bitmapPool), options);
+    } else if (drawable instanceof GifDrawable) {
+      return gifDrawableBytesTranscoder.transcode(toGifDrawableResource(toTranscode), options);
+    }
+    return null;
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Resource<GifDrawable> toGifDrawableResource(Resource<Drawable> resource) {
+    return (Resource<GifDrawable>) (Resource<?>) resource;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index b17a2bc5e..77dad3e09 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -11,8 +11,6 @@
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
 import com.bumptech.glide.util.Util;
-import java.io.PrintStream;
-import java.io.PrintWriter;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -211,7 +209,7 @@ private synchronized R doGet(Long timeoutMillis)
     if (Thread.interrupted()) {
       throw new InterruptedException();
     } else if (loadFailed) {
-      throw new GlideExecutionException(exception);
+      throw new ExecutionException(exception);
     } else if (isCancelled) {
       throw new CancellationException();
     } else if (!resultReceived) {
@@ -272,7 +270,6 @@ public synchronized boolean onResourceReady(
 
   @VisibleForTesting
   static class Waiter {
-
     // This is a simple wrapper class that is used to enable testing. The call to the wrapping class
     // is waited on appropriately.
     @SuppressWarnings("WaitNotInLoop")
@@ -284,35 +281,4 @@ void notifyAll(Object toNotify) {
       toNotify.notifyAll();
     }
   }
-
-  private static class GlideExecutionException extends ExecutionException {
-    private static final long serialVersionUID = 1L;
-
-
-    private final GlideException cause;
-
-    GlideExecutionException(GlideException cause) {
-      super();
-      this.cause = cause;
-    }
-
-    @Override
-    public void printStackTrace() {
-      printStackTrace(System.err);
-    }
-
-    @Override
-    public void printStackTrace(PrintStream s) {
-      super.printStackTrace(s);
-      s.print("Caused by: ");
-      cause.printStackTrace(s);
-    }
-
-    @Override
-    public void printStackTrace(PrintWriter s) {
-      super.printStackTrace(s);
-      s.print("Caused by: ");
-      cause.printStackTrace(s);
-    }
-  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index a45a265dd..9bf9b5205 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -27,7 +27,7 @@
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.load.resource.bitmap.DrawableTransformation;
 import com.bumptech.glide.load.resource.bitmap.FitCenter;
-import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
+import com.bumptech.glide.load.resource.bitmap.VideoDecoder;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
 import com.bumptech.glide.load.resource.gif.GifOptions;
@@ -888,17 +888,17 @@ public RequestOptions encodeQuality(@IntRange(from = 0, to = 100) int quality) {
   /**
    * Sets the time position of the frame to extract from a video.
    *
-   * <p>This is a component option specific to {@link VideoBitmapDecoder}. If the default video
+   * <p>This is a component option specific to {@link VideoDecoder}. If the default video
    * decoder is replaced or skipped because of your configuration, this option may be ignored.
    *
-   * @see VideoBitmapDecoder#TARGET_FRAME
+   * @see VideoDecoder#TARGET_FRAME
    * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the
    *                        Android framework implementation return a representative frame.
    */
   @NonNull
   @CheckResult
   public RequestOptions frame(@IntRange(from = 0) long frameTimeMicros) {
-    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
+    return set(VideoDecoder.TARGET_FRAME, frameTimeMicros);
   }
 
   /**
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
index 396aa31c1..ae2eb4bd6 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java
@@ -195,6 +195,7 @@ void setIsLowRam() {
     }
 
     @Implementation
+    @Override
     public boolean isLowRamDevice() {
       return isLowRam;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
similarity index 52%
rename from library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
rename to library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
index 377c85da2..e886c51fa 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/VideoDecoderTest.java
@@ -1,21 +1,21 @@
 package com.bumptech.glide.load.resource.bitmap;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.graphics.Bitmap;
 import android.media.MediaMetadataRetriever;
+import android.os.Build;
 import android.os.ParcelFileDescriptor;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.engine.Resource;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.util.Preconditions;
-import java.io.FileDescriptor;
 import java.io.IOException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,75 +25,88 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18)
-public class VideoBitmapDecoderTest {
+@Config(manifest = Config.NONE, sdk = 27)
+public class VideoDecoderTest {
   @Mock private ParcelFileDescriptor resource;
-  @Mock private VideoBitmapDecoder.MediaMetadataRetrieverFactory factory;
+  @Mock private VideoDecoder.MediaMetadataRetrieverFactory factory;
+  @Mock private VideoDecoder.MediaMetadataRetrieverInitializer<ParcelFileDescriptor> initializer;
   @Mock private MediaMetadataRetriever retriever;
   @Mock private BitmapPool bitmapPool;
-  private VideoBitmapDecoder decoder;
+  private VideoDecoder<ParcelFileDescriptor> decoder;
   private Options options;
+  private int initialSdkVersion;
 
   @Before
   public void setup() {
     MockitoAnnotations.initMocks(this);
     when(factory.build()).thenReturn(retriever);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
     options = new Options();
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
   }
 
   @Test
   public void testReturnsRetrievedFrameForResource() throws IOException {
+    Util.setSdkVersionInt(19);
     Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
-    when(retriever.getFrameAtTime()).thenReturn(expected);
+    when(retriever.getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION))
+        .thenReturn(expected);
 
-    FileDescriptor toSet = FileDescriptor.in;
-    when(resource.getFileDescriptor()).thenReturn(toSet);
     Resource<Bitmap> result =
         Preconditions.checkNotNull(decoder.decode(resource, 100, 100, options));
 
-    verify(retriever).setDataSource(eq(toSet));
+    verify(initializer).initialize(retriever, resource);
     assertEquals(expected, result.get());
   }
 
   @Test
   public void testReleasesMediaMetadataRetriever() throws IOException {
+    Util.setSdkVersionInt(19);
     decoder.decode(resource, 1, 2, options);
 
     verify(retriever).release();
   }
 
-  @Test
-  public void testClosesResource() throws IOException {
-    decoder.decode(resource, 1, 2, options);
-
-    verify(resource).close();
-  }
-
   @Test(expected = IllegalArgumentException.class)
   public void testThrowsExceptionIfCalledWithInvalidFrame() throws IOException {
-    options.set(VideoBitmapDecoder.TARGET_FRAME, -5L);
-    new VideoBitmapDecoder(bitmapPool, factory).decode(resource, 100, 100, options);
+    Util.setSdkVersionInt(19);
+    options.set(VideoDecoder.TARGET_FRAME, -5L);
+    new VideoDecoder<>(bitmapPool, initializer, factory).decode(resource, 100, 100, options);
   }
 
   @Test
   public void testSpecifiesThumbnailFrameIfICalledWithFrameNumber() throws IOException {
+    Util.setSdkVersionInt(19);
     long frame = 5;
-    options.set(VideoBitmapDecoder.TARGET_FRAME, frame);
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
+    options.set(VideoDecoder.TARGET_FRAME, frame);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
 
     decoder.decode(resource, 100, 100, options);
 
-    verify(retriever).getFrameAtTime(frame);
-    verify(retriever, never()).getFrameAtTime();
+    verify(retriever).getFrameAtTime(frame, VideoDecoder.DEFAULT_FRAME_OPTION);
   }
 
   @Test
   public void testDoesNotSpecifyThumbnailFrameIfCalledWithoutFrameNumber() throws IOException {
-    decoder = new VideoBitmapDecoder(bitmapPool, factory);
+    Util.setSdkVersionInt(19);
+    decoder = new VideoDecoder<>(bitmapPool, initializer, factory);
     decoder.decode(resource, 100, 100, options);
 
-    verify(retriever).getFrameAtTime();
-    verify(retriever, never()).getFrameAtTime(anyLong());
+    verify(retriever).getFrameAtTime(VideoDecoder.DEFAULT_FRAME, VideoDecoder.DEFAULT_FRAME_OPTION);
+  }
+
+  @Test
+  public void getScaledFrameAtTime() throws IOException {
+    Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    when(retriever.getScaledFrameAtTime(-1, MediaMetadataRetriever.OPTION_CLOSEST_SYNC, 100, 100))
+        .thenReturn(expected);
+
+    assertThat(decoder.decode(resource, 100, 100, options).get()).isSameAs(expected);
   }
 }
diff --git a/samples/imgur/build.gradle b/samples/imgur/build.gradle
index 16e7cfde5..27dcd1923 100644
--- a/samples/imgur/build.gradle
+++ b/samples/imgur/build.gradle
@@ -38,12 +38,12 @@ dependencies {
     annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}"
 
     implementation "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}"
-    implementation 'com.squareup.retrofit2:retrofit:2.2.0'
-    implementation 'com.squareup.retrofit2:converter-gson:2.2.0'
-    implementation 'com.squareup.retrofit2:adapter-rxjava:2.2.0'
+    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
+    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
+    implementation 'com.squareup.retrofit2:adapter-rxjava:2.3.0'
 
     implementation 'io.reactivex:rxandroid:1.2.1'
-    implementation 'io.reactivex:rxjava:1.2.9'
+    implementation 'io.reactivex:rxjava:1.3.4'
 
     implementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}"
     implementation "com.android.support:cardview-v7:${ANDROID_SUPPORT_VERSION}"
@@ -51,7 +51,7 @@ dependencies {
 
     // Fixes a compilation warning related to dagger, see
     // https://github.com/google/guava/issues/2721.
-    compileOnly "com.google.errorprone:error_prone_annotations:2.0.19"
+    compileOnly "com.google.errorprone:error_prone_annotations:2.1.3"
 }
 
 task run(type: Exec, dependsOn: 'installDebug') {
