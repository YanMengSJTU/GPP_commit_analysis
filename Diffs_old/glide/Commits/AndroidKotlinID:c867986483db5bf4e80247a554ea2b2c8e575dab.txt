diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
index 8c4810acf..fb0d1e7d8 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide;
 
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyTarget;
 import static org.mockito.AdditionalMatchers.not;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyBoolean;
@@ -17,7 +19,6 @@
 import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;
 import com.bumptech.glide.request.FutureTarget;
 import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.test.BitmapSubject;
 import com.bumptech.glide.test.ConcurrencyHelper;
 import com.bumptech.glide.test.GlideApp;
@@ -78,7 +79,7 @@ public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFro
 
     verify(requestListener)
         .onResourceReady(
-            any(Drawable.class),
+            anyDrawable(),
             any(),
             anyTarget(),
             eq(DataSource.MEMORY_CACHE),
@@ -129,7 +130,7 @@ public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {
 
     verify(requestListener)
         .onResourceReady(
-            any(Drawable.class),
+            anyDrawable(),
             any(),
             anyTarget(),
             not(eq(DataSource.MEMORY_CACHE)),
@@ -157,7 +158,7 @@ public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCac
 
     verify(requestListener)
         .onResourceReady(
-            any(Drawable.class),
+            anyDrawable(),
             any(),
             anyTarget(),
             eq(DataSource.DATA_DISK_CACHE),
@@ -187,8 +188,13 @@ public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFr
             .listener(requestListener)
             .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
 
-    verify(requestListener).onResourceReady(
-        any(Drawable.class), any(), anyTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyTarget(),
+            eq(DataSource.MEMORY_CACHE),
+            anyBoolean());
   }
 
   @Test
@@ -251,14 +257,15 @@ public void clearDiskCache_doesNotPreventFutureLoads()
             .diskCacheStrategy(DiskCacheStrategy.DATA)
             .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));
 
-    verify(requestListener).onResourceReady(
-        any(Drawable.class), any(), anyTarget(), eq(DataSource.DATA_DISK_CACHE), anyBoolean());
+    verify(requestListener)
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
   }
 
-  @SuppressWarnings("unchecked")
-  private static Target<Drawable> anyTarget() {
-    return (Target<Drawable>) any(Target.class);
-  }
 
   private void clearMemoryCacheOnMainThread() throws InterruptedException {
     concurrency.runOnMainThread(new Runnable() {
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
new file mode 100644
index 000000000..7cb306d38
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java
@@ -0,0 +1,254 @@
+package com.bumptech.glide;
+
+import static com.bumptech.glide.test.Matchers.anyDrawable;
+import static com.bumptech.glide.test.Matchers.anyTarget;
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.widget.ImageView;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.engine.executor.GlideExecutor;
+import com.bumptech.glide.request.RequestListener;
+import com.bumptech.glide.test.ConcurrencyHelper;
+import com.bumptech.glide.test.GlideApp;
+import com.bumptech.glide.test.ResourceIds;
+import com.bumptech.glide.test.TearDownGlide;
+import com.bumptech.glide.test.WaitModelLoader;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests the behaviors of Requests of all types.
+ */
+@RunWith(AndroidJUnit4.class)
+public class RequestTest {
+  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();
+  @Mock private RequestListener<Drawable> requestListener;
+  private ConcurrencyHelper concurrency = new ConcurrencyHelper();
+  private Context context;
+  private ImageView imageView;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    context = InstrumentationRegistry.getTargetContext();
+    imageView = new ImageView(context);
+    imageView.measure(100, 100);
+    imageView.layout(0, 0, 100, 100);
+
+    // Some emulators only have a single resize thread, so waiting on a latch will block them
+    // forever.
+    Glide.init(context,
+        new GlideBuilder().setResizeExecutor(GlideExecutor.newUnlimitedSourceExecutor()));
+  }
+
+  @Test
+  public void clear_withSingleRequest_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void clear_withRequestWithThumbnail_nullsOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(
+                GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.clearOnMainThread(imageView);
+    assertThat(imageView.getDrawable()).isNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequest_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnail_doesNotNullOutDrawableInView() {
+    concurrency.loadOnMainThread(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .thumbnail(
+                GlideApp.with(context)
+                  .load(ResourceIds.raw.canonical)
+                  .override(100, 100)),
+        imageView);
+    assertThat(imageView.getDrawable()).isNotNull();
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNotNull();
+  }
+
+  @Test
+  public void onStop_withSingleRequestInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(ResourceIds.raw.canonical)
+                .into(imageView);
+          }
+        });
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithThumbnailBothInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> model = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.runOnMainThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            GlideApp.with(context)
+                .load(model)
+                .thumbnail(
+                    GlideApp.with(context)
+                    .load(model)
+                    .override(100, 100))
+                .into(imageView);
+
+          }
+        });
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+    assertThat(imageView.getDrawable()).isNull();
+    model.countDown();
+  }
+
+  /** Tests #2555. */
+  @Test
+  public void onStop_withRequestWithOnlyFullInProgress_nullsOutDrawableInView() {
+    final WaitModel<Integer> mainModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(mainModel)
+            .listener(requestListener)
+                .thumbnail(GlideApp.with(context)
+                    .load(ResourceIds.raw.canonical)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+    assertThat(imageView.getDrawable()).isNull();
+    mainModel.countDown();
+  }
+
+  @Test
+  public void onStop_withRequestWithOnlyThumbnailInProgress_doesNotNullOutDrawableInView() {
+    final WaitModel<Integer> thumbModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);
+    concurrency.loadUntilFirstFinish(
+        GlideApp.with(context)
+            .load(ResourceIds.raw.canonical)
+            .listener(requestListener)
+                .thumbnail(GlideApp.with(context)
+                    .load(thumbModel)
+                    .listener(requestListener)
+                    .override(100, 100)),
+        imageView);
+
+    concurrency.runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(context).onStop();
+      }
+    });
+
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyTarget(),
+            eq(DataSource.DATA_DISK_CACHE),
+            anyBoolean());
+    verify(requestListener, never())
+        .onResourceReady(
+            anyDrawable(),
+            any(),
+            anyTarget(),
+            eq(DataSource.RESOURCE_DISK_CACHE),
+            anyBoolean());
+
+    // Only requests that are running are paused in onStop. The full request should take priority
+    // over the thumbnail request. Therefore, if the full request is finished in onStop, it should
+    // not be cleared, even if the thumbnail request is still running.
+    assertThat(imageView.getDrawable()).isNotNull();
+    thumbModel.countDown();
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
index 7da379364..c21a2292a 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java
@@ -5,6 +5,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
 import android.widget.ImageView;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.request.Request;
@@ -12,6 +13,7 @@
 import com.bumptech.glide.request.target.SizeReadyCallback;
 import com.bumptech.glide.request.target.Target;
 import com.bumptech.glide.request.transition.Transition;
+import com.bumptech.glide.util.Preconditions;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
@@ -25,8 +27,8 @@
  */
 public class ConcurrencyHelper {
   private final Handler handler = new Handler(Looper.getMainLooper());
-  private static final long TIMEOUT_MS = 5000;
-  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;
+  static final long TIMEOUT_MS = 5000;
+  static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;
 
   public <T> T get(Future<T> future) {
     try {
@@ -46,11 +48,27 @@
     return loadOnMainThread(builder, new DrawableImageViewTarget(imageView));
   }
 
-  public <T> Target<T> loadOnMainThread(final RequestBuilder<T> builder, final Target<T> target) {
-    return callOnMainThread(new Callable<Target<T>>() {
+  public void clearOnMainThread(final ImageView imageView) {
+    runOnMainThread(new Runnable() {
+      @Override
+      public void run() {
+        GlideApp.with(InstrumentationRegistry.getTargetContext())
+            .clear(imageView);
+      }
+    });
+  }
+
+  public Target<Drawable> loadUntilFirstFinish(
+      final RequestBuilder<Drawable> builder, ImageView imageView) {
+    return loadUntilFirstFinish(builder, new DrawableImageViewTarget(imageView));
+  }
+
+  public <T> Target<T> loadUntilFirstFinish(
+      final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    Target<T> result = callOnMainThread(new Callable<Target<T>>() {
       @Override
       public Target<T> call() throws Exception {
-        final CountDownLatch latch = new CountDownLatch(1);
         builder.into(new Target<T>() {
           @Override
           public void onStart() {
@@ -102,7 +120,81 @@ public void removeCallback(SizeReadyCallback cb) {
           @Override
           public void setRequest(@Nullable Request request) {
             target.setRequest(request);
+          }
+
+          @Nullable
+          @Override
+          public Request getRequest() {
+            return target.getRequest();
+          }
+        });
+        return target;
+      }
+    });
+    waitOnLatch(latch);
+    return result;
+  }
+
+  public <T> Target<T> loadOnMainThread(final RequestBuilder<T> builder, final Target<T> target) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    Target<T> result = callOnMainThread(new Callable<Target<T>>() {
+      @Override
+      public Target<T> call() throws Exception {
+        builder.into(new Target<T>() {
+          @Override
+          public void onStart() {
+            target.onStart();
+          }
+
+          @Override
+          public void onStop() {
+            target.onStop();
+          }
+
+          @Override
+          public void onDestroy() {
+            target.onDestroy();
+          }
 
+          @Override
+          public void onResourceReady(T resource, Transition<? super T> transition) {
+            target.onResourceReady(resource, transition);
+            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+              latch.countDown();
+            }
+          }
+
+          @Override
+          public void onLoadCleared(@Nullable Drawable placeholder) {
+            target.onLoadCleared(placeholder);
+          }
+
+          @Override
+          public void onLoadStarted(@Nullable Drawable placeholder) {
+            target.onLoadStarted(placeholder);
+          }
+
+          @Override
+          public void onLoadFailed(@Nullable Drawable errorDrawable) {
+            target.onLoadFailed(errorDrawable);
+            if (!Preconditions.checkNotNull(getRequest()).isRunning()) {
+              latch.countDown();
+            }
+          }
+
+          @Override
+          public void getSize(SizeReadyCallback cb) {
+            target.getSize(cb);
+          }
+
+          @Override
+          public void removeCallback(SizeReadyCallback cb) {
+            target.removeCallback(cb);
+          }
+
+          @Override
+          public void setRequest(@Nullable Request request) {
+            target.setRequest(request);
           }
 
           @Nullable
@@ -111,10 +203,11 @@ public Request getRequest() {
             return target.getRequest();
           }
         });
-        latch.await(TIMEOUT_MS, TIMEOUT_UNIT);
         return target;
       }
     });
+    waitOnLatch(latch);
+    return result;
   }
 
   public void pokeMainThread() {
@@ -151,11 +244,17 @@ public void run() {
         latch.countDown();
       }
     });
+    waitOnLatch(latch);
+    return reference.get();
+  }
+
+  private static void waitOnLatch(CountDownLatch latch) {
     try {
-      latch.await(TIMEOUT_MS, TIMEOUT_UNIT);
+      if (!latch.await(TIMEOUT_MS, TIMEOUT_UNIT)) {
+        throw new RuntimeException("Timed out waiting for latch");
+      }
     } catch (InterruptedException e) {
       throw new RuntimeException(e);
     }
-    return reference.get();
   }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
new file mode 100644
index 000000000..81d1f021f
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java
@@ -0,0 +1,25 @@
+package com.bumptech.glide.test;
+
+import static org.mockito.ArgumentMatchers.any;
+
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * Mockito matchers for various common classes.
+ */
+public final class Matchers {
+
+  private Matchers() {
+    // Utility class.
+  }
+
+  @SuppressWarnings("unchecked")
+  public static Target<Drawable> anyTarget() {
+    return (Target<Drawable>) any(Target.class);
+  }
+
+  public static Drawable anyDrawable() {
+    return any(Drawable.class);
+  }
+}
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
index a7abb5fc2..529933d51 100644
--- a/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.test;
 
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
 import com.bumptech.glide.Glide;
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
@@ -17,15 +15,12 @@ public Statement apply(final Statement base, Description description) {
     return new Statement() {
       @Override
       public void evaluate() throws Throwable {
-        base.evaluate();
-        tearDownGlide();
+        try {
+          base.evaluate();
+        } finally {
+          Glide.tearDown();
+        }
       }
     };
   }
-
-  private void tearDownGlide() {
-    Context context = InstrumentationRegistry.getTargetContext();
-    Glide.get(context).clearDiskCache();
-    Glide.tearDown();
-  }
 }
diff --git a/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
new file mode 100644
index 000000000..3718a1367
--- /dev/null
+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java
@@ -0,0 +1,145 @@
+package com.bumptech.glide.test;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.Priority;
+import com.bumptech.glide.load.DataSource;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.data.DataFetcher;
+import com.bumptech.glide.load.model.ModelLoader;
+import com.bumptech.glide.load.model.ModelLoaderFactory;
+import com.bumptech.glide.load.model.MultiModelLoaderFactory;
+import com.bumptech.glide.test.WaitModelLoader.WaitModel;
+import java.io.InputStream;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * Allows callers to load an object but force the load to pause until {@link WaitModel#countDown()}
+ * is called.
+ *
+ * <p>
+ */
+public final class WaitModelLoader<Model, Data>
+    implements ModelLoader<WaitModel<Model>, Data> {
+
+  private final ModelLoader<Model, Data> wrapped;
+
+  WaitModelLoader(ModelLoader<Model, Data> wrapped) {
+    this.wrapped = wrapped;
+  }
+
+  @Nullable
+  @Override
+  public LoadData<Data> buildLoadData(
+      WaitModel<Model> waitModel, int width, int height, Options options) {
+    LoadData<Data> wrappedLoadData = wrapped
+        .buildLoadData(waitModel.wrapped, width, height, options);
+    if (wrappedLoadData == null) {
+      return null;
+    }
+    return new LoadData<>(
+        wrappedLoadData.sourceKey, new WaitFetcher<>(wrappedLoadData.fetcher, waitModel.latch));
+  }
+
+  @Override
+  public boolean handles(WaitModel<Model> waitModel) {
+    return wrapped.handles(waitModel.wrapped);
+  }
+
+  public static final class WaitModel<T> {
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private final T wrapped;
+
+    WaitModel(T wrapped) {
+      this.wrapped = wrapped;
+    }
+
+    public void countDown() {
+      if (latch.getCount() != 1) {
+        throw new IllegalStateException();
+      }
+      latch.countDown();
+    }
+  }
+
+  public static final class Factory<Model, Data>
+      implements ModelLoaderFactory<WaitModel, Data> {
+
+    private final Class<Model> modelClass;
+    private final Class<Data> dataClass;
+
+    Factory(Class<Model> modelClass, Class<Data> dataClass) {
+      this.modelClass = modelClass;
+      this.dataClass = dataClass;
+    }
+
+    public static synchronized <T> WaitModel<T> waitOn(T model) {
+      @SuppressWarnings("unchecked") ModelLoaderFactory<WaitModel, InputStream> streamFactory =
+          new Factory<>((Class<T>) model.getClass(), InputStream.class);
+      Glide.get(InstrumentationRegistry.getTargetContext())
+          .getRegistry()
+          .replace(WaitModel.class, InputStream.class, streamFactory);
+
+      return new WaitModel<>(model);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public ModelLoader<WaitModel, Data> build(
+        MultiModelLoaderFactory multiFactory) {
+      WaitModelLoader<Model, Data> result =
+          new WaitModelLoader<>(multiFactory.build(modelClass, dataClass));
+      return (ModelLoader<WaitModel, Data>) (ModelLoader<?, ?>) result;
+    }
+
+    @Override
+    public void teardown() {
+      // Do nothing.
+    }
+  }
+
+  private static final class WaitFetcher<Data> implements DataFetcher<Data> {
+
+    private final DataFetcher<Data> wrapped;
+    private CountDownLatch toWaitOn;
+
+    WaitFetcher(DataFetcher<Data> wrapped, CountDownLatch toWaitOn) {
+      this.wrapped = wrapped;
+      this.toWaitOn = toWaitOn;
+    }
+
+    @Override
+    public void loadData(Priority priority, DataCallback<? super Data> callback) {
+      try {
+        toWaitOn.await(ConcurrencyHelper.TIMEOUT_MS, ConcurrencyHelper.TIMEOUT_UNIT);
+      } catch (InterruptedException e) {
+        throw new RuntimeException(e);
+      }
+      wrapped.loadData(priority, callback);
+    }
+
+    @Override
+    public void cleanup() {
+      wrapped.cleanup();
+    }
+
+    @Override
+    public void cancel() {
+      wrapped.cancel();
+    }
+
+    @NonNull
+    @Override
+    public Class<Data> getDataClass() {
+      return wrapped.getDataClass();
+    }
+
+    @NonNull
+    @Override
+    public DataSource getDataSource() {
+      return wrapped.getDataSource();
+    }
+  }
+}
diff --git a/library/build.gradle b/library/build.gradle
index 6f8565c22..e9ff851da 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -19,7 +19,6 @@ dependencies {
     testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}"
     testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}"
     testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}"
-    testImplementation 'commons-io:commons-io:2.6'
 }
 
 android.testOptions.unitTests.all { Test testTask ->
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 047c8691d..265dfd751 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -203,7 +203,8 @@ public static synchronized void init(Context context, GlideBuilder builder) {
   @VisibleForTesting
   public static synchronized void tearDown() {
     if (glide != null) {
-      glide.engine.tearDown();
+      glide.engine.shutdown();
+      glide.engine.clearDiskCache();
     }
     glide = null;
   }
@@ -564,7 +565,6 @@ public void clearDiskCache() {
     engine.clearDiskCache();
   }
 
-
   /**
    * Internal method.
    */
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 7cf3cab64..35d84c734 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -21,6 +21,8 @@
 import com.bumptech.glide.util.pool.FactoryPools;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Responsible for starting loads and managing active and cached resources.
@@ -315,8 +317,8 @@ public void clearDiskCache() {
   }
 
   @VisibleForTesting
-  public void tearDown() {
-    engineJobFactory.tearDown();
+  public void shutdown() {
+    engineJobFactory.shutdown();
   }
 
   /**
@@ -451,11 +453,11 @@ public DiskCache getDiskCache() {
     }
 
     @VisibleForTesting
-    void tearDown() {
-      diskCacheExecutor.shutdown();
-      sourceExecutor.shutdown();
-      sourceUnlimitedExecutor.shutdown();
-      animationExecutor.shutdown();
+    void shutdown() {
+      shutdownAndAwaitTermination(diskCacheExecutor);
+      shutdownAndAwaitTermination(sourceExecutor);
+      shutdownAndAwaitTermination(sourceUnlimitedExecutor);
+      shutdownAndAwaitTermination(animationExecutor);
     }
 
     @SuppressWarnings("unchecked")
@@ -464,5 +466,20 @@ void tearDown() {
       EngineJob<R> result = (EngineJob<R>) pool.acquire();
       return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool, useAnimationPool);
     }
+
+    private static void shutdownAndAwaitTermination(ExecutorService pool) {
+      long shutdownSeconds = 5;
+      pool.shutdown();
+      try {
+        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+          pool.shutdownNow();
+          if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {
+            throw new RuntimeException("Failed to shutdown");
+          }
+        }
+      } catch (InterruptedException ie) {
+        throw new RuntimeException(ie);
+      }
+    }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
index e1037656b..0e59214cb 100644
--- a/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java
@@ -1,5 +1,7 @@
 package com.bumptech.glide.request;
 
+import android.support.annotation.Nullable;
+
 /**
  * Runs a single primary {@link Request} until it completes and then a fallback error request only
  * if the single primary request fails.
@@ -7,11 +9,12 @@
 public final class ErrorRequestCoordinator implements RequestCoordinator,
     Request {
 
+  @Nullable
   private final RequestCoordinator coordinator;
   private Request primary;
   private Request error;
 
-  public ErrorRequestCoordinator(RequestCoordinator coordinator) {
+  public ErrorRequestCoordinator(@Nullable RequestCoordinator coordinator) {
     this.coordinator = coordinator;
   }
 
@@ -39,10 +42,9 @@ public void pause() {
 
   @Override
   public void clear() {
+    primary.clear();
     if (primary.isFailed()) {
       error.clear();
-    } else {
-      primary.clear();
     }
   }
 
@@ -105,6 +107,15 @@ public boolean canNotifyStatusChanged(Request request) {
     return parentCanNotifyStatusChanged() && isValidRequest(request);
   }
 
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && isValidRequest(request);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return coordinator == null || coordinator.canNotifyCleared(this);
+  }
+
   private boolean parentCanNotifyStatusChanged() {
     return coordinator == null || coordinator.canNotifyStatusChanged(this);
   }
@@ -139,7 +150,7 @@ public void onRequestFailed(Request request) {
     }
 
     if (coordinator != null) {
-      coordinator.onRequestFailed(error);
+      coordinator.onRequestFailed(this);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
index 36f3915e9..4aa69b394 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestCoordinator.java
@@ -20,6 +20,12 @@
    */
   boolean canNotifyStatusChanged(Request request);
 
+  /**
+   * Returns {@code true} if the {@link Request} can clear the
+   * {@link com.bumptech.glide.request.target.Target}.
+   */
+  boolean canNotifyCleared(Request request);
+
   /**
    * Returns true if any coordinated {@link Request} has successfully completed.
    *
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 2b2279d4d..7e82f957f 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -316,7 +316,7 @@ public void clear() {
     if (resource != null) {
       releaseResource(resource);
     }
-    if (canNotifyStatusChanged()) {
+    if (canNotifyCleared()) {
       target.onLoadCleared(getPlaceholderDrawable());
     }
     // Must be after cancel().
@@ -480,6 +480,10 @@ private boolean canSetResource() {
     return requestCoordinator == null || requestCoordinator.canSetImage(this);
   }
 
+  private boolean canNotifyCleared() {
+    return requestCoordinator == null || requestCoordinator.canNotifyCleared(this);
+  }
+
   private boolean canNotifyStatusChanged() {
     return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
index 8bee19db7..d93bef7f9 100644
--- a/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java
@@ -52,6 +52,15 @@ public boolean canNotifyStatusChanged(Request request) {
     return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
   }
 
+  @Override
+  public boolean canNotifyCleared(Request request) {
+    return parentCanNotifyCleared() && request.equals(full);
+  }
+
+  private boolean parentCanNotifyCleared() {
+    return coordinator == null || coordinator.canNotifyCleared(this);
+  }
+
   private boolean parentCanNotifyStatusChanged() {
     return coordinator == null || coordinator.canNotifyStatusChanged(this);
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
index 5fe54bda6..9005c3cb0 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java
@@ -9,7 +9,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.security.MessageDigest;
-import org.apache.commons.io.FileUtils;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -37,9 +36,27 @@ public void setUp() {
   @After
   public void tearDown() {
     try {
-      FileUtils.deleteDirectory(dir);
-    } catch (IOException e) {
-      throw new RuntimeException(e);
+      cache.clear();
+    } finally {
+      deleteRecursive(dir);
+    }
+  }
+
+  private void deleteRecursive(File file) {
+    if (!file.isDirectory()) {
+      if (!file.delete()) {
+        throw new IllegalStateException("Failed to delete: " + file);
+      }
+      return;
+    }
+
+    File[] files = file.listFiles();
+    if (files == null) {
+      return;
+    }
+
+    for (File child : files) {
+      deleteRecursive(child);
     }
   }
 
diff --git a/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java b/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
new file mode 100644
index 000000000..16d794915
--- /dev/null
+++ b/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java
@@ -0,0 +1,620 @@
+package com.bumptech.glide.request;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class ErrorRequestCoordinatorTest {
+
+  @Mock private Request primary;
+  @Mock private Request error;
+  @Mock private RequestCoordinator parent;
+  private ErrorRequestCoordinator coordinator;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    coordinator = new ErrorRequestCoordinator(/*coordinator=*/ null);
+    coordinator.setRequests(primary, error);
+  }
+
+  @Test
+  public void begin_startsPrimary() {
+    coordinator.begin();
+    verify(primary).begin();
+  }
+
+  @Test
+  public void begin_whenPrimaryIsAlreadyRunning_doesNotStartPrimaryAgain() {
+    when(primary.isRunning()).thenReturn(true);
+    coordinator.begin();
+    verify(primary, never()).begin();
+  }
+
+  @Test
+  public void pause_whenPrimaryHasNotFailed_pausesPrimary() {
+    coordinator.pause();
+    verify(primary).pause();
+  }
+
+  @Test
+  public void pause_whenPrimaryHasFailed_doesNotPausePrimary() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.pause();
+    verify(primary, never()).pause();
+  }
+
+  @Test
+  public void pause_whenErrorIsRunning_pausesError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.pause();
+    verify(error).pause();
+  }
+
+  @Test
+  public void pause_whenErrorIsNotRunning_doesNotPauseError() {
+    coordinator.pause();
+    verify(error, never()).pause();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_clearsPrimary() {
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasNotFailed_doesNotClearError() {
+    coordinator.clear();
+    verify(error, never()).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_clearsError() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.clear();
+    verify(error).clear();
+  }
+
+  @Test
+  public void clear_whenPrimaryHasFailed_clearsPrimary() {
+    when(primary.isFailed()).thenReturn(true);
+    coordinator.clear();
+    verify(primary).clear();
+  }
+
+  @Test
+  public void isPaused_primaryNotFailed_primaryNotPaused_returnsFalse() {
+    assertThat(coordinator.isPaused()).isFalse();
+  }
+
+  @Test
+  public void isPaused_primaryNotFailed_primaryPaused_returnsTrue() {
+    when(primary.isPaused()).thenReturn(true);
+    assertThat(coordinator.isPaused()).isTrue();
+  }
+
+  @Test
+  public void isPaused_primaryFailed_errorNotPaused_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isPaused()).isFalse();
+  }
+
+  @Test
+  public void isPaused_primaryFailed_errorPaused_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isPaused()).thenReturn(true);
+    assertThat(coordinator.isPaused()).isTrue();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryNotRunning_returnsFalse() {
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryNotFailed_primaryRunning_returnsTrue() {
+    when(primary.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorNotRunning_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isFalse();
+  }
+
+  @Test
+  public void isRunning_primaryFailed_errorRunning_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isRunning()).thenReturn(true);
+    assertThat(coordinator.isRunning()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryNotComplete_returnsFalse() {
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryNotFailed_primaryComplete_returnsTrue() {
+    when(primary.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorNotComplete_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isFalse();
+  }
+
+  @Test
+  public void isComplete_primaryFailed_errorComplete_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isComplete()).thenReturn(true);
+    assertThat(coordinator.isComplete()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryNotResourceSet_returnsFalse() {
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryNotFailed_primaryResourceSet_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorNotResourceSet_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isResourceSet_primaryFailed_errorResourceSet_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryNotCancelled_returnsFalse() {
+    assertThat(coordinator.isCancelled()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryNotFailed_primaryCancelled_returnsTrue() {
+    when(primary.isCancelled()).thenReturn(true);
+    assertThat(coordinator.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorNotCancelled_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isCancelled()).isFalse();
+  }
+
+  @Test
+  public void isCancelled_primaryFailed_errorCancelled_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isCancelled()).thenReturn(true);
+    assertThat(coordinator.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorNotFailed_returnsFalse() {
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_errorNotFailed_returnsFalse() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryNotFailed_errorFailed_returnsFalse() {
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isFalse();
+  }
+
+  @Test
+  public void isFailed_primaryFailed_andErrorFailed_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isFailed()).thenReturn(true);
+    assertThat(coordinator.isFailed()).isTrue();
+  }
+
+  @Test
+  public void recycle_recyclesPrimaryAndError() {
+    coordinator.recycle();
+    verify(primary).recycle();
+    verify(error).recycle();
+  }
+
+  @Test
+  public void isEquivalentTo() {
+    assertThat(coordinator.isEquivalentTo(primary)).isFalse();
+
+    ErrorRequestCoordinator other = new ErrorRequestCoordinator(/*coordinator=*/ null);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(primary, primary);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    other.setRequests(error, error);
+    assertThat(coordinator.isEquivalentTo(other)).isFalse();
+
+    when(primary.isEquivalentTo(primary)).thenReturn(true);
+    when(error.isEquivalentTo(error)).thenReturn(true);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    other = new ErrorRequestCoordinator(parent);
+    other.setRequests(primary, error);
+    assertThat(coordinator.isEquivalentTo(other)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_andNullParent_returnsTrue() {
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andNullParent_andNotFailedPrimary_returnsFalse() {
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(primary)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withNotFailedPrimary_parentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canSetImage(primary)).isFalse();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanSetImage_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canSetImage(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isTrue();
+  }
+
+  @Test
+  public void canSetImage_withError_andFailedPrimary_nonNullParentCanNotSetImage_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canSetImage(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCantNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withNotFailedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_notFailedPrimary_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCantNotify_false() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyStatusChanged_withError_failedPrimary_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(parent.canNotifyStatusChanged(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyStatusChanged(primary)).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_nullParent_returnsFalse() {
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_nullParent_returnsTrue() {
+    when(primary.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentResourceNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primarySet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isResourceSet()).thenReturn(true);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_parentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nullParent_returnsFalse() {
+    when(error.isResourceSet()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nullParent_returnsTrue() {
+    when(error.isResourceSet()).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_notFailedPrimary_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_failedPrimary_nonNullParentNotSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_errorSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.isAnyResourceSet()).thenReturn(true);
+    when(error.isResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentNotSet_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.isAnyResourceSet()).isFalse();
+  }
+
+  @Test
+  public void isAnyResourceSet_primaryNotSet_errorNotSet_nonNullParentSet_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    when(parent.isAnyResourceSet()).thenReturn(true);
+
+    assertThat(coordinator.isAnyResourceSet()).isTrue();
+  }
+
+  @Test
+  public void onRequestSuccess_nullParent_doesNotThrow() {
+    coordinator.onRequestSuccess(primary);
+  }
+
+  @Test
+  public void onRequestSuccess_nonNullParent_callsParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.onRequestSuccess(primary);
+    verify(parent).onRequestSuccess(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_beingsError() {
+    coordinator.onRequestFailed(primary);
+    verify(error).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_doesNotBeginError() {
+    when(error.isRunning()).thenReturn(true);
+    coordinator.onRequestFailed(primary);
+
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_doesNotBeginError() {
+    coordinator.onRequestFailed(error);
+    verify(error, never()).begin();
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_notRunningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(primary);
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void onRequestFailed_errorRequest_nonNullParent_notifiesParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    coordinator.onRequestFailed(error);
+
+    verify(parent).onRequestFailed(coordinator);
+  }
+
+  @Test
+  public void onRequestFailed_primaryRequest_runningError_nonNullParent_doesNotNotifyParent() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(error.isRunning()).thenReturn(true);
+
+    coordinator.onRequestFailed(primary);
+
+    verify(parent, never()).onRequestFailed(any(Request.class));
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_nullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequest_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_parentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(primary.isFailed()).thenReturn(false);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_primaryRequestFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(primary)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_nullParent_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nullParent_returnsTrue() {
+    when(primary.isFailed()).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotNotify_returnsFalse() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_errorRequest_primaryFailed_nonNullParentCanNotify_returnsTrue() {
+    coordinator = new ErrorRequestCoordinator(parent);
+    coordinator.setRequests(primary, error);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    when(primary.isFailed()).thenReturn(true);
+
+    assertThat(coordinator.canNotifyCleared(error)).isTrue();
+  }
+}
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 0002b5288..8abcab217 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -179,6 +179,14 @@ public void testIsCancelledAfterClear() {
     assertTrue(request.isCancelled());
   }
 
+  @Test
+  public void clear_notifiesTarget() {
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target).onLoadCleared(any(Drawable.class));
+  }
+
   @Test
   public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
     SingleRequest<List> request = builder.build();
@@ -188,6 +196,15 @@ public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
     verify(builder.target, times(1)).onLoadCleared(any(Drawable.class));
   }
 
+  @Test
+  public void clear_doesNotNotifyTarget_ifRequestCoordinatorReturnsFalseForCanClear() {
+    when(builder.requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(false);
+    SingleRequest<List> request = builder.build();
+    request.clear();
+
+    verify(builder.target, never()).onLoadCleared(any(Drawable.class));
+  }
+
   @Test
   public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
     RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
@@ -908,6 +925,7 @@ protected int doHash(@NonNull SingleRequestBuilder listSingleRequest) {
 
     SingleRequestBuilder() {
       when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
+      when(requestCoordinator.canNotifyCleared(any(Request.class))).thenReturn(true);
       when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);
       when(resource.get()).thenReturn(result);
     }
diff --git a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java b/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
index cf2087c8c..525d6dbc1 100644
--- a/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java
@@ -1,12 +1,12 @@
 package com.bumptech.glide.request;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -16,21 +16,21 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 @RunWith(JUnit4.class)
 public class ThumbnailRequestCoordinatorTest {
-  private Request full;
-  private Request thumb;
+  @Mock private Request full;
+  @Mock private Request thumb;
+  @Mock private RequestCoordinator parent;
   private ThumbnailRequestCoordinator coordinator;
-  private RequestCoordinator parent;
 
   @Before
   public void setUp() {
-    full = mock(Request.class);
-    thumb = mock(Request.class);
-    parent = mock(RequestCoordinator.class);
+    MockitoAnnotations.initMocks(this);
     coordinator = new ThumbnailRequestCoordinator();
     coordinator.setRequests(full, thumb);
   }
@@ -317,9 +317,9 @@ public void testDoesNotClearThumbOnThumbRequestComplete() {
 
   @Test
   public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
-      when(thumb.isComplete()).thenReturn(true);
-      coordinator.onRequestSuccess(full);
-      verify(thumb, never()).clear();
+    when(thumb.isComplete()).thenReturn(true);
+    coordinator.onRequestSuccess(full);
+    verify(thumb, never()).clear();
   }
 
   @Test
@@ -331,6 +331,32 @@ public void testDoesNotNotifyParentOnThumbRequestComplete() {
     verify(parent, never()).onRequestSuccess(any(Request.class));
   }
 
+  @Test
+  public void canNotifyCleared_withThumbRequest_returnsFalse() {
+    assertThat(coordinator.canNotifyCleared(thumb)).isFalse();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_andNullParent_returnsTrue() {
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanClear_returnsTrue() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(true);
+    assertThat(coordinator.canNotifyCleared(full)).isTrue();
+  }
+
+  @Test
+  public void canNotifyCleared_withFullRequest_nonNullParent_parentCanNotClear_returnsFalse() {
+    coordinator = new ThumbnailRequestCoordinator(parent);
+    coordinator.setRequests(full, thumb);
+    when(parent.canNotifyCleared(coordinator)).thenReturn(false);
+    assertThat(coordinator.canNotifyCleared(full)).isFalse();
+  }
+
   @Test
   public void testIsEquivalentTo() {
     ThumbnailRequestCoordinator first = new ThumbnailRequestCoordinator();
diff --git a/library/src/test/java/com/bumptech/glide/tests/TearDownGlide.java b/library/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
index c7eded785..d1814f48f 100644
--- a/library/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
+++ b/library/src/test/java/com/bumptech/glide/tests/TearDownGlide.java
@@ -1,49 +1,26 @@
 package com.bumptech.glide.tests;
 
-import android.content.Context;
 import com.bumptech.glide.Glide;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
 import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
-import org.robolectric.RuntimeEnvironment;
 
 /**
  * Clears out Glide's disk cache and the Glide singleton after every test method.
  */
 public final class TearDownGlide implements TestRule {
-  private static final long TIMEOUT = 500;
-  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;
-
   @Override
   public Statement apply(final Statement base, Description description) {
     return new Statement() {
       @Override
       public void evaluate() throws Throwable {
-        base.evaluate();
-        tearDownGlide();
-      }
-    };
-  }
+        try {
+          base.evaluate();
+        } finally {
+          Glide.tearDown();
 
-  private void tearDownGlide() {
-    final Context context = RuntimeEnvironment.application;
-    ExecutorService executor = Executors.newSingleThreadExecutor();
-    try {
-      executor.submit(new Runnable() {
-        @Override
-        public void run() {
-          Glide.get(context).clearDiskCache();
         }
-      }).get(TIMEOUT, TIMEOUT_UNIT);
-    } catch (InterruptedException | ExecutionException | TimeoutException e) {
-      throw new RuntimeException(e);
-    }
-    executor.shutdown();
-    Glide.tearDown();
+      }
+    };
   }
 }
