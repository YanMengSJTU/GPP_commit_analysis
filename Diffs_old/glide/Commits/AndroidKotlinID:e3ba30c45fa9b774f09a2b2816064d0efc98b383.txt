diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
index 5229afc21..ff0dbb20f 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java
@@ -4,9 +4,11 @@
 
 import com.bumptech.glide.annotation.GlideExtension;
 import com.google.common.base.Function;
+import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Lists;
+import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.JavaFile;
@@ -14,6 +16,7 @@
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
 import com.sun.tools.javac.code.Attribute;
 import com.sun.tools.javac.code.Type.ClassType;
 import java.lang.annotation.Annotation;
@@ -21,6 +24,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -35,8 +39,10 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
@@ -233,6 +239,88 @@ void infoLog(String toLog) {
     processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "[" + round + "] " + toLog);
   }
 
+  static CodeBlock generateCastingSuperCall(TypeName toReturn, ExecutableElement method) {
+    return CodeBlock.builder()
+        .add("return ($T) super.$N(", toReturn, method.getSimpleName())
+        .add(
+            FluentIterable.from(method.getParameters())
+                .transform(new Function<VariableElement, String>() {
+                  @Nullable
+                  @Override
+                  public String apply(VariableElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })
+                .join(Joiner.on(",")))
+        .add(");\n")
+        .build();
+  }
+
+  static MethodSpec.Builder overriding(ExecutableElement method) {
+    String methodName = method.getSimpleName().toString();
+
+    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
+        .addAnnotation(Override.class);
+
+    Set<Modifier> modifiers = method.getModifiers();
+    modifiers = new LinkedHashSet<>(modifiers);
+    modifiers.remove(Modifier.ABSTRACT);
+    Modifier defaultModifier = null;
+    // Modifier.DEFAULT doesn't exist until Java 8.
+    try {
+      defaultModifier = Modifier.valueOf("DEFAULT");
+    } catch (IllegalArgumentException e) {
+      // Ignored.
+    }
+    modifiers.remove(defaultModifier);
+
+    builder = builder.addModifiers(modifiers);
+
+    for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {
+      TypeVariable var = (TypeVariable) typeParameterElement.asType();
+      builder = builder.addTypeVariable(TypeVariableName.get(var));
+    }
+
+    builder = builder.returns(TypeName.get(method.getReturnType()))
+        .addParameters(getParameters(method))
+        .varargs(method.isVarArgs());
+
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      builder = builder.addException(TypeName.get(thrownType));
+    }
+
+    return builder;
+  }
+
+  static List<ParameterSpec> getParameters(ExecutableElement method) {
+    return getParameters(method.getParameters());
+  }
+
+  static List<ParameterSpec> getParameters(List<? extends VariableElement> parameters) {
+    List<ParameterSpec> result = new ArrayList<>();
+    for (VariableElement parameter : parameters) {
+      result.add(getParameter(parameter));
+    }
+    return result;
+  }
+
+  private static ParameterSpec getParameter(VariableElement method) {
+    TypeName type = TypeName.get(method.asType());
+    String name = method.getSimpleName().toString();
+    return ParameterSpec.builder(type, name)
+        .addModifiers(method.getModifiers())
+        .addAnnotations(getAnnotations(method))
+        .build();
+  }
+
+  private static List<AnnotationSpec> getAnnotations(VariableElement element) {
+    List<AnnotationSpec> result = new ArrayList<>();
+    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
+      result.add(AnnotationSpec.get(mirror));
+    }
+    return result;
+  }
+
   List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {
     return FluentIterable.from(clazz.getEnclosedElements())
         .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE))
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
index 90696a73c..f6d86cd79 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java
@@ -207,7 +207,7 @@ private MethodSpec generateRequestBuilderOverride(ExecutableElement methodToOver
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride)
+    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
         .returns(generatedRequestBuilderOfType)
         .addCode(CodeBlock.builder()
             .add("return ($T) super.$N(",
@@ -224,7 +224,13 @@ public String apply(VariableElement input) {
             .build());
 
     for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
-      builder.addAnnotation(AnnotationSpec.get(mirror));
+      builder = builder.addAnnotation(AnnotationSpec.get(mirror));
+    }
+
+    if (methodToOverride.isVarArgs()) {
+      builder = builder
+          .addModifiers(Modifier.FINAL)
+          .addAnnotation(SafeVarargs.class);
     }
 
     return builder.build();
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
index b54729593..ba624c744 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java
@@ -3,14 +3,12 @@
 import com.bumptech.glide.annotation.GlideExtension;
 import com.bumptech.glide.annotation.GlideType;
 import com.google.common.base.Function;
-import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Lists;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
@@ -25,7 +23,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -114,8 +111,9 @@ TypeSpec generate(
          .addModifiers(Modifier.PUBLIC)
          .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder))
          .addMethod(generateCallSuperConstructor())
-         .addMethods(generateAdditionalRequestManagerMethods(glideExtensions))
-         .addMethods(generateRequestManagerMethodOverrides())
+         .addMethods(generateExtensionRequestManagerMethods(glideExtensions))
+         .addMethods(generateRequestManagerRequestManagerMethodOverrides(generatedCodePackageName))
+         .addMethods(generateRequestManagerRequestBuilderMethodOverrides())
          .addMethods(
              FluentIterable.from(
                  Collections.singletonList(
@@ -157,7 +155,33 @@ private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec re
         .build();
   }
 
-  private List<MethodSpec> generateRequestManagerMethodOverrides() {
+  /** Generates the list of overrides of methods that return {@code RequestManager}. */
+  private List<MethodSpec> generateRequestManagerRequestManagerMethodOverrides(
+      final String generatedPackageName) {
+    return FluentIterable.from(
+        processorUtil.findInstanceMethodsReturning(requestManagerType, requestManagerType))
+        .transform(new Function<ExecutableElement, MethodSpec>() {
+          @Nullable
+          @Override
+          public MethodSpec apply(@Nullable ExecutableElement input) {
+            return generateRequestManagerRequestManagerMethodOverride(generatedPackageName, input);
+          }
+        })
+        .toList();
+  }
+
+  private MethodSpec generateRequestManagerRequestManagerMethodOverride(
+      String generatedPackageName, ExecutableElement method) {
+    ClassName generatedRequestManagerName =
+        ClassName.get(generatedPackageName, GENERATED_REQUEST_MANAGER_SIMPLE_NAME);
+    return ProcessorUtil.overriding(method)
+        .returns(generatedRequestManagerName)
+        .addCode(ProcessorUtil.generateCastingSuperCall(generatedRequestManagerName, method))
+        .build();
+  }
+
+  /** Generates the list of overrides of methods that return {@code RequestBuilder}. */
+  private List<MethodSpec> generateRequestManagerRequestBuilderMethodOverrides() {
     // Without the erasure, this is a RequestBuilder<Y>. A RequestBuilder<X> is not assignable to a
     // RequestBuilder<Y>. After type erasure this is a RequestBuilder. A RequestBuilder<X> is
     // assignable to the raw RequestBuilder.
@@ -176,7 +200,7 @@ public boolean apply(ExecutableElement input) {
         .transform(new Function<ExecutableElement, MethodSpec>() {
           @Override
           public MethodSpec apply(ExecutableElement input) {
-            return generateRequestManagerMethodOverride(input);
+            return generateRequestManagerRequestBuilderMethodOverride(input);
           }
         })
         .toList();
@@ -186,7 +210,8 @@ public MethodSpec apply(ExecutableElement input) {
    * Generates overrides of existing RequestManager methods so that they return our generated
    * RequestBuilder subtype.
    */
-  private MethodSpec generateRequestManagerMethodOverride(ExecutableElement methodToOverride) {
+  private MethodSpec generateRequestManagerRequestBuilderMethodOverride(
+      ExecutableElement methodToOverride) {
      // We've already verified that this method returns a RequestBuilder and RequestBuilders have
     // exactly one type argument, so this is safe unless those assumptions change.
     TypeMirror typeArgument =
@@ -195,21 +220,11 @@ private MethodSpec generateRequestManagerMethodOverride(ExecutableElement method
     ParameterizedTypeName generatedRequestBuilderOfType =
         ParameterizedTypeName.get(generatedRequestBuilderClassName, ClassName.get(typeArgument));
 
-    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride)
+    MethodSpec.Builder builder = ProcessorUtil.overriding(methodToOverride)
         .returns(generatedRequestBuilderOfType)
-        .addCode(CodeBlock.builder()
-            .add("return ($T) super.$N(",
-                generatedRequestBuilderOfType, methodToOverride.getSimpleName())
-            .add(FluentIterable.from(methodToOverride.getParameters())
-                .transform(new Function<VariableElement, String>() {
-                  @Override
-                  public String apply(VariableElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })
-                .join(Joiner.on(", ")))
-            .add(");\n")
-            .build());
+        .addCode(
+            ProcessorUtil.generateCastingSuperCall(
+                generatedRequestBuilderOfType, methodToOverride));
 
     for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {
       builder.addAnnotation(AnnotationSpec.get(mirror));
@@ -217,7 +232,7 @@ public String apply(VariableElement input) {
     return builder.build();
   }
 
-  private List<MethodSpec> generateAdditionalRequestManagerMethods(
+  private List<MethodSpec> generateExtensionRequestManagerMethods(
       Set<String> glideExtensions) {
     List<ExecutableElement> requestManagerExtensionMethods =
         processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);
@@ -252,7 +267,7 @@ private MethodSpec generateAdditionalRequestManagerMethod(ExecutableElement exte
   }
 
   /**
-   * The {@link com.bumptech.glide.request.RequestOptions} subclass should always be our
+   * The {@code RequestOptions} subclass should always be our
    * generated subclass type to avoid inadvertent errors where a different subclass is applied that
    * accidentally wipes out some logic in overidden methods in our generated subclass.
    */
diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
index 4f2df6d6e..32a62649a 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java
@@ -194,7 +194,7 @@ public MethodSpec apply(ExecutableElement input) {
   }
 
   private MethodSpec generateRequestOptionOverride(ExecutableElement methodToOverride) {
-    MethodSpec.Builder result = MethodSpec.overriding(methodToOverride)
+    MethodSpec.Builder result = ProcessorUtil.overriding(methodToOverride)
         .returns(glideOptionsName)
         .addModifiers(Modifier.FINAL)
         .addCode(CodeBlock.builder()
@@ -241,6 +241,7 @@ public String apply(VariableElement input) {
     MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
         .addModifiers(Modifier.PUBLIC)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(element))
+        .varargs(element.isVarArgs())
         .returns(glideOptionsName);
 
     // The 0th element is expected to be a RequestOptions object.
@@ -274,9 +275,7 @@ public String apply(VariableElement input) {
           .addAnnotation(Override.class);
     }
 
-    for (VariableElement variable : parameters) {
-      builder.addParameter(getParameterSpec(variable));
-    }
+    builder.addParameters(ProcessorUtil.getParameters(parameters));
 
     // Adds: <AnnotatedClass>.<thisMethodName>(RequestOptions<?>, <arg1>, <arg2>, <argN>);
     List<Object> args = new ArrayList<>();
@@ -368,8 +367,8 @@ private MethodAndStaticVar generateStaticMethodEquivalentForRequestOptionsStatic
     List<? extends VariableElement> parameters = staticMethod.getParameters();
     String createNewOptionAndCall = "new $T().$N(";
     if (!parameters.isEmpty()) {
+      methodSpecBuilder.addParameters(ProcessorUtil.getParameters(staticMethod));
       for (VariableElement parameter : parameters) {
-        methodSpecBuilder.addParameter(getParameterSpec(parameter));
         createNewOptionAndCall += parameter.getSimpleName().toString();
         // use the Application Context to avoid memory leaks.
         if (memoize && isAndroidContext(parameter)) {
@@ -446,6 +445,7 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
     MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(staticMethodName)
         .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
         .addJavadoc(processorUtil.generateSeeMethodJavadoc(instanceMethod))
+        .varargs(instanceMethod.isVarArgs())
         .returns(glideOptionsName);
 
     List<? extends VariableElement> parameters = instanceMethod.getParameters();
@@ -462,8 +462,8 @@ private MethodAndStaticVar generateStaticMethodEquivalentForExtensionMethod(
 
     String createNewOptionAndCall = "new $T().$L(";
     if (!parameters.isEmpty()) {
+      methodSpecBuilder.addParameters(ProcessorUtil.getParameters(parameters));
       for (VariableElement parameter : parameters) {
-        methodSpecBuilder.addParameter(getParameterSpec(parameter));
         createNewOptionAndCall += parameter.getSimpleName().toString();
         // use the Application Context to avoid memory leaks.
         if (memoize && isAndroidContext(parameter)) {
@@ -538,11 +538,6 @@ private boolean isMethodInRequestOptions(ExecutableElement toFind) {
     return false;
   }
 
-  private static ParameterSpec getParameterSpec(VariableElement variable) {
-    return ParameterSpec.builder(
-        TypeName.get(variable.asType()), variable.getSimpleName().toString()).build();
-  }
-
   private static List<String> getComparableParameterNames(
       ExecutableElement element, boolean skipFirst) {
     List<? extends VariableElement> parameters = element.getParameters();
diff --git a/library/build.gradle b/library/build.gradle
index cad1fbc17..b501d800a 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -147,14 +147,3 @@ afterEvaluate {
 }
 
 apply from: "${rootProject.projectDir}/scripts/upload.gradle"
-// exclude <dependency> tag for android support-v4 library from :glide's pom
-// this will ensure that this warning will not prevent the build from completing:
-// Module 'com.github.bumptech.glide:glide:4.0.0-SNAPSHOT' depends on one or more Android Libraries
-// but is a jar. Most users will need to override support-v4 version anyway if a newer version is
-// available
-// TODO make support-v4 a <scope>runtime</scope> dependency in pom.xml
-afterEvaluate {
-    uploadArchives.repositories.mavenDeployer.pom.whenConfigured { p ->
-        p.dependencies = p.dependencies.findAll { dep -> dep.artifactId != "support-v4" }
-    }
-}
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index e77742fcb..1276daea8 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -329,8 +329,14 @@ public Glide build(Context context) {
     }
 
     if (engine == null) {
-      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,
-          GlideExecutor.newUnlimitedSourceExecutor());
+      engine =
+          new Engine(
+              memoryCache,
+              diskCacheFactory,
+              diskCacheExecutor,
+              sourceExecutor,
+              GlideExecutor.newUnlimitedSourceExecutor(),
+              GlideExecutor.newAnimationExecutor());
     }
 
     RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(
diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index 37650c3f1..ef5bf00a9 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -4,8 +4,10 @@
 
 import android.net.Uri;
 import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
 import android.widget.ImageView;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
 import com.bumptech.glide.request.ErrorRequestCoordinator;
@@ -168,11 +170,16 @@ protected RequestOptions getMutableOptions() {
    * requests will actually finish. However, if the thumb request completes after the full request,
    * the thumb resource will never replace the full resource.
    *
-   * @param thumbnailRequest The request to use to load the thumbnail.
-   * @return This request builder.
+   * <p>Recursive calls to thumbnail are supported.
+   *
+   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
+   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder[])}.
+   *
    * @see #thumbnail(float)
+   * @see #thumbnail(RequestBuilder[])
    *
-   * <p> Recursive calls to thumbnail are supported. </p>
+   * @param thumbnailRequest The request to use to load the thumbnail.
+   * @return This request builder.
    */
   @CheckResult
   @SuppressWarnings("unchecked")
@@ -183,25 +190,92 @@ protected RequestOptions getMutableOptions() {
     return this;
   }
 
+  /**
+   * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are
+   * loaded as thumbnails in the given priority order.
+   *
+   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the
+   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied
+   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the
+   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on.
+   *
+   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or
+   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling
+   * {@link #thumbnail(RequestBuilder)} with {@code null}.
+   *
+   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be
+   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive
+   * chain.
+   *
+   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous
+   * calls to their {@link #thumbnail(RequestBuilder[])} or {@link #thumbnail(RequestBuilder)}
+   * methods overridden.
+   *
+   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},
+   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder[])}.
+   *
+   * @see #thumbnail(float)
+   * @see #thumbnail(RequestBuilder)
+   *
+   * @return This request builder.
+   */
+  @SuppressWarnings({"CheckResult", "unchecked"})
+  @CheckResult
+  public RequestBuilder<TranscodeType> thumbnail(
+      @Nullable RequestBuilder<TranscodeType> /*@Nullable*/ ... thumbnails) {
+    if (thumbnails == null || thumbnails.length == 0) {
+      return thumbnail((RequestBuilder<TranscodeType>) null);
+    }
+
+    RequestBuilder<TranscodeType> previous = null;
+
+    // Start with the lowest priority thumbnail so that we can safely handle mutations if
+    // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration.
+    // Starting with the highest priority thumbnail would prevent us from assigning the result of
+    // thumbnail because the mutated request wouldn't be used in the next iteration.
+    for (int i = thumbnails.length - 1; i >= 0; i--) {
+      RequestBuilder<TranscodeType> current = thumbnails[i];
+      // Ignore null thumbnails.
+      if (current == null) {
+        continue;
+      }
+
+      if (previous == null) {
+        // If we don't yet have our first non-null request, set it and continue.
+        previous = current;
+      } else {
+        // Otherwise make our next lowest priority request the thumbnail of our current request.
+        previous = current.thumbnail(previous);
+      }
+    }
+    return thumbnail(previous);
+  }
+
   /**
    * Loads a resource in an identical manner to this request except with the dimensions of the
    * target multiplied by the given size multiplier. If the thumbnail load completes before the full
    * size load, the thumbnail will be shown. If the thumbnail load completes after the full size
    * load, the thumbnail will not be shown.
    *
-   * <p> Note - The thumbnail resource will be smaller than the size requested so the target (or
+   * <p>Note - The thumbnail resource will be smaller than the size requested so the target (or
    * {@link ImageView}) must be able to scale the thumbnail appropriately. See
-   * {@link android.widget.ImageView.ScaleType}. </p>
+   * {@link android.widget.ImageView.ScaleType}.
    *
-   * <p> Almost all options will be copied from the original load, including the {@link
+   * <p>Almost all options will be copied from the original load, including the {@link
    * com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder},
    * and {@link com.bumptech.glide.load.Transformation}s. However,
    * {@link com.bumptech.glide.request.RequestOptions#placeholder(int)} and
    * {@link com.bumptech.glide.request.RequestOptions#error(int)}, and
    * {@link #listener(RequestListener)} will only be used on the full size load and will not be
-   * copied for the thumbnail load. </p>
+   * copied for the thumbnail load.
    *
-   * <p> Recursive calls to thumbnail are supported. </p>
+   * <p>Recursive calls to thumbnail are supported.
+   *
+   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder[])},
+   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder)}.
+   *
+   * @see #thumbnail(RequestBuilder)
+   * @see #thumbnail(RequestBuilder[])
    *
    * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading
    *                       the thumbnail.
@@ -310,12 +384,12 @@ protected RequestOptions getMutableOptions() {
   }
 
   /**
-   * Returns a request builder to load the given resource id. Returns a request builder that uses
-   * the {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
+   * Returns a request builder that uses the
+   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or
    * {@link Integer} to load the image represented by the given {@link Integer} resource id.
    * Defaults to {@link com.bumptech.glide.load.model.ResourceLoader} to load resource id models.
    *
-   * <p> By default this method adds a version code based signature to the cache key used to cache
+   * <p>By default this method adds a version code based signature to the cache key used to cache
    * this resource in Glide. This signature is sufficient to guarantee that end users will see the
    * most up to date versions of your Drawables, but during development if you do not increment your
    * version code before each install and you replace a Drawable with different data without
@@ -323,13 +397,19 @@ protected RequestOptions getMutableOptions() {
    * using {@link com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} via
    * {@link RequestOptions#diskCacheStrategy(com.bumptech.glide.load.engine.DiskCacheStrategy)}
    * during development, and re-enabling the default
-   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds. </p>
+   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds.
+   *
+   * <p>This method will load non-{@link android.graphics.Bitmap} resources like
+   * {@link android.graphics.drawable.VectorDrawable}s, but most common options including
+   * default {@link com.bumptech.glide.load.Transformation}s will not <em>NOT</em> work on
+   * non-{@link android.graphics.Bitmap} resources. As a result, functionality for
+   * non-{@link android.graphics.Bitmap} resources may be limited.
    *
    * @see #load(Integer)
    * @see com.bumptech.glide.signature.ApplicationVersionSignature
    */
   @CheckResult
-  public RequestBuilder<TranscodeType> load(@Nullable Integer resourceId) {
+  public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
     return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
index d1eb3619b..045100156 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java
@@ -18,7 +18,6 @@
 import com.bumptech.glide.load.engine.cache.DiskCache;
 import com.bumptech.glide.load.resource.bitmap.Downsampler;
 import com.bumptech.glide.util.LogTime;
-import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
 import com.bumptech.glide.util.pool.FactoryPools.Poolable;
 import com.bumptech.glide.util.pool.StateVerifier;
@@ -242,9 +241,8 @@ public void run() {
         throw e;
       }
     } finally {
-      Preconditions.checkArgument(
-          localFetcher == null || currentFetcher == null || localFetcher.equals(currentFetcher),
-          "Fetchers don't match!, old: " + localFetcher + " new: " + currentFetcher);
+      // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call
+      // close in all cases anyway.
       if (localFetcher != null) {
         localFetcher.cleanup();
       }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 315d4cf11..ed0ad6a58 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -66,9 +66,21 @@ public Engine(MemoryCache memoryCache,
       DiskCache.Factory diskCacheFactory,
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
-      GlideExecutor sourceUnlimitedExecutor) {
-    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
-        null, null, null, null, null, null);
+      GlideExecutor sourceUnlimitedExecutor,
+      GlideExecutor animationExecutor) {
+    this(
+        memoryCache,
+        diskCacheFactory,
+        diskCacheExecutor,
+        sourceExecutor,
+        sourceUnlimitedExecutor,
+        animationExecutor,
+        /*jobs=*/ null,
+        /*keyFactory=*/ null,
+        /*activeResources=*/ null,
+        /*engineJobFactory=*/ null,
+        /*decodeJobFactory=*/ null,
+        /*resourceRecycler=*/ null);
   }
 
   // Visible for testing.
@@ -77,6 +89,7 @@ public Engine(MemoryCache memoryCache,
       GlideExecutor diskCacheExecutor,
       GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
+      GlideExecutor animationExecutor,
       Map<Key, EngineJob<?>> jobs,
       EngineKeyFactory keyFactory,
       Map<Key, WeakReference<EngineResource<?>>> activeResources,
@@ -102,8 +115,9 @@ public Engine(MemoryCache memoryCache,
     this.jobs = jobs;
 
     if (engineJobFactory == null) {
-      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor,
-          sourceUnlimitedExecutor, this);
+      engineJobFactory =
+          new EngineJobFactory(
+              diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -155,6 +169,7 @@ public Engine(MemoryCache memoryCache,
       Options options,
       boolean isMemoryCacheable,
       boolean useUnlimitedSourceExecutorPool,
+      boolean useAnimationPool,
       boolean onlyRetrieveFromCache,
       ResourceCallback cb) {
     Util.assertMainThread();
@@ -191,7 +206,7 @@ public Engine(MemoryCache memoryCache,
     }
 
     EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
-        useUnlimitedSourceExecutorPool);
+        useUnlimitedSourceExecutorPool, useAnimationPool);
     DecodeJob<R> decodeJob = decodeJobFactory.build(
         glideContext,
         model,
@@ -453,29 +468,40 @@ public boolean queueIdle() {
     @Synthetic final GlideExecutor diskCacheExecutor;
     @Synthetic final GlideExecutor sourceExecutor;
     @Synthetic final GlideExecutor sourceUnlimitedExecutor;
+    @Synthetic final GlideExecutor animationExecutor;
     @Synthetic final EngineJobListener listener;
     @Synthetic final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
         new FactoryPools.Factory<EngineJob<?>>() {
           @Override
           public EngineJob<?> create() {
-            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
-                listener, pool);
+            return new EngineJob<Object>(
+                diskCacheExecutor,
+                sourceExecutor,
+                sourceUnlimitedExecutor,
+                animationExecutor,
+                listener,
+                pool);
           }
         });
 
-    EngineJobFactory(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
-        GlideExecutor sourceUnlimitedExecutor, EngineJobListener listener) {
+    EngineJobFactory(
+        GlideExecutor diskCacheExecutor,
+        GlideExecutor sourceExecutor,
+        GlideExecutor sourceUnlimitedExecutor,
+        GlideExecutor animationExecutor,
+        EngineJobListener listener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
       this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
+      this.animationExecutor = animationExecutor;
       this.listener = listener;
     }
 
     @SuppressWarnings("unchecked")
     <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,
-        boolean useUnlimitedSourceGeneratorPool) {
+        boolean useUnlimitedSourceGeneratorPool, boolean isAnimation) {
       EngineJob<R> result = (EngineJob<R>) pool.acquire();
-      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool);
+      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool, isAnimation);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index 3517092ac..38957f280 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -39,10 +39,12 @@
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
   private final GlideExecutor sourceUnlimitedExecutor;
+  private final GlideExecutor animationExecutor;
 
   private Key key;
   private boolean isCacheable;
   private boolean useUnlimitedSourceGeneratorPool;
+  private boolean isAnimation;
   private Resource<?> resource;
   private DataSource dataSource;
   private boolean hasResource;
@@ -57,31 +59,51 @@
   // Checked primarily on the main thread, but also on other threads in reschedule.
   private volatile boolean isCancelled;
 
-  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+  EngineJob(
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
-      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool) {
-    this(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, listener, pool,
+      GlideExecutor animationExecutor,
+      EngineJobListener listener,
+      Pools.Pool<EngineJob<?>> pool) {
+    this(
+        diskCacheExecutor,
+        sourceExecutor,
+        sourceUnlimitedExecutor,
+        animationExecutor,
+        listener,
+        pool,
         DEFAULT_FACTORY);
   }
 
   // Visible for testing.
-  EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+  EngineJob(
+      GlideExecutor diskCacheExecutor,
+      GlideExecutor sourceExecutor,
       GlideExecutor sourceUnlimitedExecutor,
-      EngineJobListener listener, Pools.Pool<EngineJob<?>> pool,
+      GlideExecutor animationExecutor,
+      EngineJobListener listener,
+      Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
     this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
+    this.animationExecutor = animationExecutor;
     this.listener = listener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
 
   // Visible for testing.
-  EngineJob<R> init(Key key, boolean isCacheable, boolean useUnlimitedSourceGeneratorPool) {
+  EngineJob<R> init(
+      Key key,
+      boolean isCacheable,
+      boolean useUnlimitedSourceGeneratorPool,
+      boolean isAnimation) {
     this.key = key;
     this.isCacheable = isCacheable;
     this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
+    this.isAnimation = isAnimation;
     return this;
   }
 
@@ -119,6 +141,9 @@ public void removeCallback(ResourceCallback cb) {
   }
 
   private GlideExecutor getActiveSourceExecutor() {
+    if (isAnimation) {
+      return animationExecutor;
+    }
     return useUnlimitedSourceGeneratorPool ? sourceUnlimitedExecutor : sourceExecutor;
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
index 3f7d9d3a9..1b0e17747 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.engine.cache;
 
 import android.content.Context;
-
 import android.support.annotation.Nullable;
 import java.io.File;
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index d80ff2059..b66014a04 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -44,6 +44,9 @@
   private static final String CPU_LOCATION = "/sys/devices/system/cpu/";
   // Don't use more than four threads when automatically determining thread count..
   private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
+  // May be accessed on other threads, but this is an optimization only so it's ok if we set its
+  // value more than once.
+  private static volatile int bestThreadCount;
   private final boolean executeSynchronously;
 
   /**
@@ -52,10 +55,11 @@
    */
   private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
   /**
-   * The default keep alive time for threads in source unlimited executor pool in milliseconds.
+   * The default keep alive time for threads in our cached thread pools in milliseconds.
    */
-  private static final long SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS =
-      TimeUnit.SECONDS.toMillis(10);
+  private static final long KEEP_ALIVE_TIME_MS = TimeUnit.SECONDS.toMillis(10);
+
+  private static final String ANIMATION_EXECUTOR_NAME = "animation";
 
   /**
    * Returns a new fixed thread pool with the default thread count returned from
@@ -160,7 +164,7 @@ public static GlideExecutor newSourceExecutor(int threadCount, String name,
 
   /**
    * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
-   * created by default, {@link #SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS} keep alive
+   * created by default, {@link #KEEP_ALIVE_TIME_MS} keep alive
    * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
    * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
    * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
@@ -175,7 +179,7 @@ public static GlideExecutor newSourceExecutor(int threadCount, String name,
   public static GlideExecutor newUnlimitedSourceExecutor() {
     return new GlideExecutor(0 /* corePoolSize */,
         Integer.MAX_VALUE /* maximumPoolSize */,
-        SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS,
+        KEEP_ALIVE_TIME_MS,
         SOURCE_UNLIMITED_EXECUTOR_NAME,
         UncaughtThrowableStrategy.DEFAULT,
         false /*preventNetworkOperations*/,
@@ -183,6 +187,25 @@ public static GlideExecutor newUnlimitedSourceExecutor() {
         new SynchronousQueue<Runnable>());
   }
 
+  public static GlideExecutor newAnimationExecutor() {
+    int bestThreadCount = calculateBestThreadCount();
+    // We don't want to add a ton of threads running animations in parallel with our source and
+    // disk cache executors. Doing so adds unnecessary CPU load and can also dramatically increase
+    // our maximum memory usage. Typically one thread is sufficient here, but for higher end devices
+    // with more cores, two threads can provide better performance if lots of GIFs are showing at
+    // once.
+    int maximumPoolSize = bestThreadCount >= 4 ? 2 : 1;
+    return new GlideExecutor(
+        /*corePoolSize=*/ 0,
+        maximumPoolSize,
+        KEEP_ALIVE_TIME_MS,
+        ANIMATION_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT,
+        /*preventNetworkOperations=*/ true,
+        /*executeSynchronously=*/ false,
+        new PriorityBlockingQueue<Runnable>());
+  }
+
   // Visible for testing.
   GlideExecutor(int poolSize, String name,
       UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
@@ -280,31 +303,35 @@ public void execute(Runnable command) {
    * http://goo.gl/8H670N.
    */
   public static int calculateBestThreadCount() {
-    // We override the current ThreadPolicy to allow disk reads.
-    // This shouldn't actually do disk-IO and accesses a device file.
-    // See: https://github.com/bumptech/glide/issues/1170
-    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
-    File[] cpus = null;
-    try {
-      File cpuInfo = new File(CPU_LOCATION);
-      final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
-      cpus = cpuInfo.listFiles(new FilenameFilter() {
-        @Override
-        public boolean accept(File file, String s) {
-          return cpuNamePattern.matcher(s).matches();
+    if (bestThreadCount == 0) {
+      // We override the current ThreadPolicy to allow disk reads.
+      // This shouldn't actually do disk-IO and accesses a device file.
+      // See: https://github.com/bumptech/glide/issues/1170
+      ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();
+      File[] cpus = null;
+      try {
+        File cpuInfo = new File(CPU_LOCATION);
+        final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);
+        cpus = cpuInfo.listFiles(new FilenameFilter() {
+          @Override
+          public boolean accept(File file, String s) {
+            return cpuNamePattern.matcher(s).matches();
+          }
+        });
+      } catch (Throwable t) {
+        if (Log.isLoggable(TAG, Log.ERROR)) {
+          Log.e(TAG, "Failed to calculate accurate cpu count", t);
         }
-      });
-    } catch (Throwable t) {
-      if (Log.isLoggable(TAG, Log.ERROR)) {
-        Log.e(TAG, "Failed to calculate accurate cpu count", t);
+      } finally {
+        StrictMode.setThreadPolicy(originalPolicy);
       }
-    } finally {
-      StrictMode.setThreadPolicy(originalPolicy);
-    }
 
-    int cpuCount = cpus != null ? cpus.length : 0;
-    int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());
-    return Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));
+      int cpuCount = cpus != null ? cpus.length : 0;
+      int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());
+      bestThreadCount =
+          Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));
+    }
+    return bestThreadCount;
   }
 
   /**
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index e6ca4aa75..57eebd0b8 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -122,9 +122,6 @@ public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws I
   // 10MB. This is the max image header size we can handle, we preallocate a much smaller buffer
   // but will resize up to this amount if necessary.
   private static final int MARK_POSITION = 10 * 1024 * 1024;
-  // Defines the level of precision we get when using inDensity/inTargetDensity to calculate an
-  // arbitrary float scale factor.
-  private static final int DENSITY_PRECISION_MULTIPLIER = 1000000000;
 
   private final BitmapPool bitmapPool;
   private final DisplayMetrics displayMetrics;
@@ -446,7 +443,7 @@ static void calculateScaling(
     // densities here so we calculate the final Bitmap size correctly.
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
       options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor);
-      options.inDensity = DENSITY_PRECISION_MULTIPLIER;
+      options.inDensity = getDensityMultiplier(adjustedScaleFactor);
     }
     if (isScaling(options)) {
       options.inScaled = true;
@@ -473,12 +470,19 @@ static void calculateScaling(
    * the final scale factor is as close to our target as possible.
    */
   private static int adjustTargetDensityForError(double adjustedScaleFactor) {
-    int targetDensity = round(DENSITY_PRECISION_MULTIPLIER * adjustedScaleFactor);
-    float scaleFactorWithError = targetDensity / (float) DENSITY_PRECISION_MULTIPLIER;
+    int densityMultiplier = getDensityMultiplier(adjustedScaleFactor);
+    int targetDensity = round(densityMultiplier * adjustedScaleFactor);
+    float scaleFactorWithError = targetDensity / (float) densityMultiplier;
     double difference = adjustedScaleFactor / scaleFactorWithError;
     return round(difference * targetDensity);
   }
 
+  private static int getDensityMultiplier(double adjustedScaleFactor) {
+    return (int) Math.round(
+        Integer.MAX_VALUE
+            * (adjustedScaleFactor <= 1D ? adjustedScaleFactor : 1 / adjustedScaleFactor));
+  }
+
   // This is weird, but it matches the logic in a bunch of Android views/framework classes for
   // rounding.
   private static int round(double value) {
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
index be3e804a2..0e0ce2622 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java
@@ -5,6 +5,7 @@
 import android.support.annotation.NonNull;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
+import com.bumptech.glide.util.Util;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
 
@@ -51,18 +52,22 @@ public RoundedCorners(@SuppressWarnings("unused") Context context, int roundingR
   @Override
   protected Bitmap transform(
       @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {
-    return TransformationUtils.roundedCorners(pool, toTransform, outWidth, outHeight,
-        roundingRadius);
+    return TransformationUtils.roundedCorners(pool, toTransform, roundingRadius);
   }
 
   @Override
   public boolean equals(Object o) {
-    return (o instanceof RoundedCorners) && ((RoundedCorners) o).roundingRadius == roundingRadius;
+    if (o instanceof RoundedCorners) {
+      RoundedCorners other = (RoundedCorners) o;
+      return roundingRadius == other.roundingRadius;
+    }
+    return false;
   }
 
   @Override
   public int hashCode() {
-    return ID.hashCode() + roundingRadius;
+    return Util.hashCode(ID.hashCode(),
+        Util.hashCode(roundingRadius));
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
index 671fb7816..881d0a5c1 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java
@@ -14,6 +14,7 @@
 import android.os.Build;
 import android.support.annotation.NonNull;
 import android.util.Log;
+import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.util.Preconditions;
 import com.bumptech.glide.util.Synthetic;
@@ -397,16 +398,41 @@ private static Bitmap getAlphaSafeBitmap(@NonNull BitmapPool pool,
    * @param roundingRadius the corner radius to be applied (in device-specific pixels).
    * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
    * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
+   *
+   * @deprecated Width and height are unused and ignored. Use
+   * {@link #roundedCorners(BitmapPool, Bitmap, int)} instead.
+   */
+  @Deprecated
+  public static Bitmap roundedCorners(
+      @NonNull BitmapPool pool,
+      @NonNull Bitmap inBitmap,
+      @SuppressWarnings("unused") int width,
+      @SuppressWarnings("unused") int height,
+      int roundingRadius) {
+    return roundedCorners(pool, inBitmap, roundingRadius);
+  }
+
+  /**
+   * Creates a bitmap from a source bitmap and rounds the corners.
+   *
+   * <p>This method does <em>NOT</em> resize the given {@link Bitmap}, it only rounds it's corners.
+   * To both resize and round the corners of an image, consider
+   * {@link com.bumptech.glide.request.RequestOptions#transforms(Transformation[])} and/or
+   * {@link com.bumptech.glide.load.MultiTransformation}.
+   *
+   * @param inBitmap the source bitmap to use as a basis for the created bitmap.
+   * @param roundingRadius the corner radius to be applied (in device-specific pixels).
+   * @return a {@link Bitmap} similar to inBitmap but with rounded corners.
+   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less.
    */
-  public static Bitmap roundedCorners(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap,
-      int width, int height, int roundingRadius) {
-    Preconditions.checkArgument(width > 0, "width must be greater than 0.");
-    Preconditions.checkArgument(height > 0, "height must be greater than 0.");
+  public static Bitmap roundedCorners(
+      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int roundingRadius) {
     Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");
 
     // Alpha is required for this transformation.
     Bitmap toTransform = getAlphaSafeBitmap(pool, inBitmap);
-    Bitmap result = pool.get(width, height, Bitmap.Config.ARGB_8888);
+    Bitmap result =
+        pool.get(toTransform.getWidth(), toTransform.getHeight(), Bitmap.Config.ARGB_8888);
 
     result.setHasAlpha(true);
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index 2b56d271e..bb04fc835 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -131,7 +131,7 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
     // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code
     // than 0.
     int sampleSize = Math.max(1, powerOfTwoSampleSize);
-    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+    if (Log.isLoggable(TAG, Log.VERBOSE) && sampleSize > 1) {
       Log.v(TAG, "Downsampling GIF"
           + ", sampleSize: " + sampleSize
           + ", target dimens: [" + targetWidth + "x" + targetHeight + "]"
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index 9c51ba3ed..bda033ce9 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -205,7 +205,7 @@ private void loadNextFrame() {
 
     gifDecoder.advance();
     next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);
-    requestBuilder.clone().apply(signatureOf(getFrameSignature())).load(gifDecoder).into(next);
+    requestBuilder.apply(signatureOf(getFrameSignature())).load(gifDecoder).into(next);
   }
 
   private void recycleFirstFrame() {
@@ -298,11 +298,12 @@ public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transiti
         .asBitmap()
         .apply(
             diskCacheStrategyOf(DiskCacheStrategy.NONE)
+                .useAnimationPool(true)
                 .skipMemoryCache(true)
                 .override(width, height));
   }
 
-  static Key getFrameSignature() {
+  private static Key getFrameSignature() {
     // Some devices seem to have crypto bugs that throw exceptions when you create a new UUID.
     // See #1510.
     return new ObjectKey(Math.random());
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
index a5cbcc053..277a7b100 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java
@@ -5,6 +5,9 @@
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.CheckResult;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.FloatRange;
+import android.support.annotation.IntRange;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import com.bumptech.glide.Priority;
@@ -60,6 +63,7 @@
   private static final int TRANSFORMATION_REQUIRED = 1 << 17;
   private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
   private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;
+  private static final int USE_ANIMATION_POOL = 1 << 20;
 
   @Nullable
   private static RequestOptions skipMemoryCacheTrueOptions;
@@ -113,13 +117,15 @@
   private boolean useUnlimitedSourceGeneratorsPool;
   private boolean onlyRetrieveFromCache;
   private boolean isScaleOnlyOrNoTransform = true;
+  private boolean useAnimationPool;
 
   /**
    * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set.
    */
   @SuppressWarnings("WeakerAccess") // Public API
   @CheckResult
-  public static RequestOptions sizeMultiplierOf(float sizeMultiplier) {
+  public static RequestOptions sizeMultiplierOf(
+      @FloatRange(from = 0, to = 1) float sizeMultiplier) {
     return new RequestOptions().sizeMultiplier(sizeMultiplier);
   }
 
@@ -152,7 +158,7 @@ public static RequestOptions placeholderOf(@Nullable Drawable placeholder) {
    * Returns a {@link RequestOptions} object with {@link #placeholder(int)} set.
    */
   @CheckResult
-  public static RequestOptions placeholderOf(int placeholderId) {
+  public static RequestOptions placeholderOf(@DrawableRes int placeholderId) {
     return new RequestOptions().placeholder(placeholderId);
   }
 
@@ -168,7 +174,7 @@ public static RequestOptions errorOf(@Nullable Drawable errorDrawable) {
    * Returns a {@link RequestOptions} object with {@link #error(int)}} set.
    */
   @CheckResult
-  public static RequestOptions errorOf(int errorId) {
+  public static RequestOptions errorOf(@DrawableRes int errorId) {
     return new RequestOptions().error(errorId);
   }
 
@@ -195,7 +201,9 @@ public static RequestOptions skipMemoryCacheOf(boolean skipMemoryCache) {
    */
   @SuppressWarnings("WeakerAccess") // Public API
   @CheckResult
-  public static RequestOptions overrideOf(int width, int height) {
+  public static RequestOptions overrideOf(
+      @IntRange(from = 0) int width,
+      @IntRange(from = 0) int height) {
     return new RequestOptions().override(width, height);
   }
 
@@ -205,7 +213,7 @@ public static RequestOptions overrideOf(int width, int height) {
    */
   @SuppressWarnings("WeakerAccess") // Public API
   @CheckResult
-  public static RequestOptions overrideOf(int size) {
+  public static RequestOptions overrideOf(@IntRange(from = 0) int size) {
     return overrideOf(size, size);
   }
 
@@ -326,7 +334,7 @@ public static RequestOptions formatOf(@NonNull DecodeFormat format) {
    */
   @SuppressWarnings("WeakerAccess") // Public API
   @CheckResult
-  public static RequestOptions frameOf(long frameTimeMicros) {
+  public static RequestOptions frameOf(@IntRange(from = 0) long frameTimeMicros) {
     return new RequestOptions().frame(frameTimeMicros);
   }
 
@@ -343,7 +351,7 @@ public static RequestOptions downsampleOf(@NonNull DownsampleStrategy strategy)
    * Returns a {@link RequestOptions} object with {@link #timeout(int)} set.
    */
   @CheckResult
-  public static RequestOptions timeoutOf(int timeout) {
+  public static RequestOptions timeoutOf(@IntRange(from = 0) int timeout) {
     return new RequestOptions().timeout(timeout);
   }
 
@@ -353,7 +361,7 @@ public static RequestOptions timeoutOf(int timeout) {
    */
   @SuppressWarnings("WeakerAccess") // Public API
   @CheckResult
-  public static RequestOptions encodeQualityOf(int quality) {
+  public static RequestOptions encodeQualityOf(@IntRange(from = 0, to = 100) int quality) {
     return new RequestOptions().encodeQuality(quality);
   }
 
@@ -397,7 +405,7 @@ private static boolean isSet(int fields, int flag) {
    * @return This request builder.
    */
   @CheckResult
-  public RequestOptions sizeMultiplier(float sizeMultiplier) {
+  public RequestOptions sizeMultiplier(@FloatRange(from = 0, to = 1) float sizeMultiplier) {
     if (isAutoCloneEnabled) {
       return clone().sizeMultiplier(sizeMultiplier);
     }
@@ -411,6 +419,15 @@ public RequestOptions sizeMultiplier(float sizeMultiplier) {
     return selfOrThrowIfLocked();
   }
 
+  /**
+   * If set to {@code true}, uses a cached unlimited {@link java.util.concurrent.Executor} to run
+   * the request.
+   *
+   * <p>This method should <em>ONLY</em> be used when a Glide load is started recursively on one
+   * of Glide's threads as part of another request. Using this method in other scenarios can lead
+   * to excessive memory usage and OOMs and/or a significant decrease in performance across an
+   * application.
+   */
   @CheckResult
   public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
     if (isAutoCloneEnabled) {
@@ -423,6 +440,27 @@ public RequestOptions useUnlimitedSourceGeneratorsPool(boolean flag) {
     return selfOrThrowIfLocked();
   }
 
+  /**
+   * If set to {@code true}, uses a special {@link java.util.concurrent.Executor} that is used
+   * exclusively for decoding frames of animated resources, like GIFs.
+   *
+   * <p>The animation executor disallows network operations and must not be used for loads that
+   * may load remote data. The animation executor has fewer threads available to it than Glide's
+   * normal executors and is only useful as a way of avoiding blocking on longer and more expensive
+   * reads for critical requests like those in an animating GIF.
+   */
+  @CheckResult
+  public RequestOptions useAnimationPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useAnimationPool(flag);
+    }
+
+    useAnimationPool = flag;
+    fields |= USE_ANIMATION_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
   /**
    * If set to true, will only load an item if found in the cache, and will not fetch from source.
    */
@@ -507,7 +545,7 @@ public RequestOptions placeholder(@Nullable Drawable drawable) {
    * @return This request builder.
    */
   @CheckResult
-  public RequestOptions placeholder(int resourceId) {
+  public RequestOptions placeholder(@DrawableRes int resourceId) {
     if (isAutoCloneEnabled) {
       return clone().placeholder(resourceId);
     }
@@ -532,7 +570,7 @@ public RequestOptions placeholder(int resourceId) {
    * @return This request builder.
    */
   @CheckResult
-  public RequestOptions fallback(Drawable drawable) {
+  public RequestOptions fallback(@Nullable Drawable drawable) {
     if (isAutoCloneEnabled) {
       return clone().fallback(drawable);
     }
@@ -557,7 +595,7 @@ public RequestOptions fallback(Drawable drawable) {
    * @return This request builder.
    */
   @CheckResult
-  public RequestOptions fallback(int resourceId) {
+  public RequestOptions fallback(@DrawableRes int resourceId) {
     if (isAutoCloneEnabled) {
       return clone().fallback(resourceId);
     }
@@ -593,7 +631,7 @@ public RequestOptions error(@Nullable Drawable drawable) {
    * @return This request builder.
    */
   @CheckResult
-  public RequestOptions error(int resourceId) {
+  public RequestOptions error(@DrawableRes int resourceId) {
     if (isAutoCloneEnabled) {
       return clone().error(resourceId);
     }
@@ -612,7 +650,7 @@ public RequestOptions error(int resourceId) {
    * @return this request builder.
    */
   @CheckResult
-  public RequestOptions theme(Resources.Theme theme) {
+  public RequestOptions theme(@Nullable Resources.Theme theme) {
     if (isAutoCloneEnabled) {
       return clone().theme(theme);
     }
@@ -779,7 +817,7 @@ public RequestOptions encodeFormat(@NonNull Bitmap.CompressFormat format) {
    * {@link BitmapEncoder#COMPRESSION_QUALITY}.
    */
   @CheckResult
-  public RequestOptions encodeQuality(int quality) {
+  public RequestOptions encodeQuality(@IntRange(from = 0, to = 100) int quality) {
     return set(BitmapEncoder.COMPRESSION_QUALITY, quality);
   }
 
@@ -794,7 +832,7 @@ public RequestOptions encodeQuality(int quality) {
    *                        Android framework implementation return a representative frame.
    */
   @CheckResult
-  public RequestOptions frame(long frameTimeMicros) {
+  public RequestOptions frame(@IntRange(from = 0) long frameTimeMicros) {
     return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);
   }
 
@@ -864,7 +902,7 @@ public RequestOptions downsample(@NonNull DownsampleStrategy strategy) {
    * @param timeoutMs The read and write timeout in milliseconds.
    */
   @CheckResult
-  public RequestOptions timeout(int timeoutMs) {
+  public RequestOptions timeout(@IntRange(from = 0) int timeoutMs) {
     return set(HttpGlideUrlLoader.TIMEOUT, timeoutMs);
   }
 
@@ -1101,7 +1139,7 @@ public RequestOptions transforms(@NonNull Transformation<Bitmap>... transformati
   // Guaranteed to modify the current object by the isAutoCloneEnabledCheck.
   @SuppressWarnings("CheckResult")
   @CheckResult
-  public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
+  public RequestOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {
     if (isAutoCloneEnabled) {
       return clone().optionalTransform(transformation);
     }
@@ -1131,8 +1169,8 @@ public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
    * @param transformation The {@link Transformation} to apply.
    */
   @CheckResult
-  public <T> RequestOptions optionalTransform(Class<T> resourceClass,
-      Transformation<T> transformation) {
+  public <T> RequestOptions optionalTransform(
+      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {
     if (isAutoCloneEnabled) {
       return clone().optionalTransform(resourceClass, transformation);
     }
@@ -1163,7 +1201,7 @@ public RequestOptions optionalTransform(Transformation<Bitmap> transformation) {
   @SuppressWarnings("CheckResult")
   @CheckResult
   public <T> RequestOptions transform(
-      Class<T> resourceClass, Transformation<T> transformation) {
+      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {
     if (isAutoCloneEnabled) {
       return clone().transform(resourceClass, transformation);
     }
@@ -1216,7 +1254,7 @@ public RequestOptions dontAnimate() {
   }
 
   @CheckResult
-  public RequestOptions apply(RequestOptions other) {
+  public RequestOptions apply(@NonNull RequestOptions other) {
     if (isAutoCloneEnabled) {
       return clone().apply(other);
     }
@@ -1227,6 +1265,9 @@ public RequestOptions apply(RequestOptions other) {
     if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
       useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
     }
+    if (isSet(other.fields, USE_ANIMATION_POOL)) {
+      useAnimationPool = other.useAnimationPool;
+    }
     if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
       diskCacheStrategy = other.diskCacheStrategy;
     }
@@ -1503,6 +1544,10 @@ public final boolean getUseUnlimitedSourceGeneratorsPool() {
     return useUnlimitedSourceGeneratorsPool;
   }
 
+  public final boolean getUseAnimationPool() {
+    return useAnimationPool;
+  }
+
   public final boolean getOnlyRetrieveFromCache() {
     return onlyRetrieveFromCache;
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 2d7951351..e543cc66b 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -439,6 +439,7 @@ public void onSizeReady(int width, int height) {
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
         requestOptions.getUseUnlimitedSourceGeneratorsPool(),
+        requestOptions.getUseAnimationPool(),
         requestOptions.getOnlyRetrieveFromCache(),
         this);
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 6a740e638..de3766e31 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -459,6 +459,7 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
     EngineJobListener listener = mock(EngineJobListener.class);
     boolean isCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
+    boolean isAnimation = false;
     int numCbs = 10;
     List<ResourceCallback> cbs = new ArrayList<>();
     EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
@@ -466,14 +467,22 @@ public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOn
     GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
     GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
     GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
+    GlideExecutor animationService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      job = new EngineJob<>(diskCacheService, sourceService, sourceUnlimitedService, listener, pool,
-          factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool);
+      job =
+          new EngineJob<>(
+              diskCacheService,
+              sourceService,
+              sourceUnlimitedService,
+              animationService,
+              listener,
+              pool,
+              factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool, isAnimation);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
@@ -495,17 +504,26 @@ public MultiCbHarness() {
     GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
     GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
     GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
+    GlideExecutor animationService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     boolean isCacheable = true;
     boolean useUnlimitedSourceGeneratorPool = false;
+    boolean isAnimation = false;
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DataSource dataSource = DataSource.DATA_DISK_CACHE;
 
     public EngineJob<Object> getJob() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      EngineJob<Object> result = new EngineJob<>(
-          diskCacheService, sourceService, sourceUnlimitedService, listener, pool, factory)
-          .init(key, isCacheable, useUnlimitedSourceGeneratorPool);
+      EngineJob<Object> result =
+          new EngineJob<>(
+              diskCacheService,
+              sourceService,
+              sourceUnlimitedService,
+              animationService,
+              listener,
+              pool,
+              factory)
+              .init(key, isCacheable, useUnlimitedSourceGeneratorPool, isAnimation);
       result.addCallback(cb);
       return result;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index f442d9684..b226e3aa3 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -422,7 +422,8 @@ public void testFactoryIsGivenNecessaryArguments() {
     verify(harness.engineJobFactory).build(
         eq(harness.cacheKey),
         eq(true) /*isMemoryCacheable*/,
-        eq(false) /*useUnlimitedSourceGeneratorPool*/);
+        eq(false) /*useUnlimitedSourceGeneratorPool*/,
+        /*isAnimation=*/ eq(false));
   }
 
   @Test
@@ -433,7 +434,8 @@ public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
     verify(harness.engineJobFactory).build(
         eq(harness.cacheKey),
         eq(true) /*isMemoryCacheable*/,
-        eq(true) /*useUnlimitedSourceGeneratorPool*/);
+        eq(true) /*useUnlimitedSourceGeneratorPool*/,
+        /*isAnimation=*/ eq(false));
   }
 
   @Test
@@ -492,16 +494,24 @@ public EngineTestHarness() {
 
       job = mock(EngineJob.class);
 
-      engine = new Engine(cache, mock(DiskCache.Factory.class),
-          GlideExecutor.newDiskCacheExecutor(),
-          MockGlideExecutor.newMainThreadExecutor(),
-          MockGlideExecutor.newMainThreadUnlimitedExecutor(),
-          jobs, keyFactory, activeResources,
-          engineJobFactory, decodeJobFactory, resourceRecycler);
+      engine =
+          new Engine(
+              cache,
+              mock(DiskCache.Factory.class),
+              GlideExecutor.newDiskCacheExecutor(),
+              MockGlideExecutor.newMainThreadExecutor(),
+              MockGlideExecutor.newMainThreadUnlimitedExecutor(),
+              MockGlideExecutor.newMainThreadUnlimitedExecutor(),
+              jobs,
+              keyFactory,
+              activeResources,
+              engineJobFactory,
+              decodeJobFactory,
+              resourceRecycler);
     }
 
     public Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean()))
+      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean(), anyBoolean()))
           .thenReturn((EngineJob<Object>) job);
       return engine.load(glideContext,
           model,
@@ -514,10 +524,11 @@ public EngineTestHarness() {
           DiskCacheStrategy.ALL,
           transformations,
           false /*isTransformationRequired*/,
-          true,
+          isScaleOnlyOrNoTransform,
           options,
           isMemoryCacheable,
           useUnlimitedSourceGeneratorPool,
+          /*useAnimationPool=*/ false,
           onlyRetrieveFromCache,
           cb);
     }
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index fc06b4087..aabefcffa 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -277,10 +277,25 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
     request.onSizeReady(100, 100);
 
     verify(harness.engine, times(1))
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
-            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
+        .load(
+            eq(harness.glideContext),
+            eq(harness.model),
+            eq(harness.signature),
+            eq(100),
+            eq(100),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(harness.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class));
   }
 
   @Test
@@ -296,10 +311,25 @@ public void testEngineLoadCancelledOnCancel() {
     Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
 
     when(harness.engine
-       .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
-          eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-          eq(harness.transformations), anyBoolean(), anyBoolean(), any(Options.class),
-          anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
+       .load(
+           eq(harness.glideContext),
+           eq(harness.model),
+           eq(harness.signature),
+           anyInt(),
+           anyInt(),
+           eq(Object.class),
+           eq(List.class),
+           any(Priority.class),
+           any(DiskCacheStrategy.class),
+           eq(harness.transformations),
+           anyBoolean(),
+           anyBoolean(),
+           any(Options.class),
+           anyBoolean(),
+           anyBoolean(),
+           anyBoolean(),
+           anyBoolean(),
+           any(ResourceCallback.class)))
         .thenReturn(loadStatus);
 
     SingleRequest<List> request = harness.getRequest();
@@ -540,10 +570,24 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
     final SingleRequest<List> request = harness.getRequest();
 
     when(harness.engine
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+        .load(
+            eq(harness.glideContext),
+            eq(harness.model),
+            eq(harness.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(harness.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
             any(ResourceCallback.class)))
         .thenAnswer(new Answer<Object>() {
           @Override
@@ -655,10 +699,24 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
     request.begin();
 
     verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+        .load(
+            eq(harness.glideContext),
+            eq(harness.model),
+            eq(harness.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(harness.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool*/ anyBoolean(),
+            anyBoolean(),
             any(ResourceCallback.class));
   }
 
@@ -678,10 +736,25 @@ public void testCanReRunCancelledRequests() {
         .getSize(any(SizeReadyCallback.class));
 
     when(harness.engine
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
-            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
-            eq(harness.transformations), anyBoolean(), anyBoolean(), any(Options.class),
-            anyBoolean(), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
+        .load(
+            eq(harness.glideContext),
+            eq(harness.model),
+            eq(harness.signature),
+            eq(100),
+            eq(100),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(harness.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
+            any(ResourceCallback.class)))
         .thenAnswer(new CallResourceCallback(harness.resource));
     SingleRequest<List> request = harness.getRequest();
 
@@ -707,10 +780,24 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
     request.onSizeReady(100, 100);
 
     verify(harness.engine, never())
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), anyBoolean(), anyBoolean(),
+        .load(
+            eq(harness.glideContext),
+            eq(harness.model),
+            eq(harness.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(harness.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            anyBoolean(),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
             any(ResourceCallback.class));
   }
 
@@ -726,10 +813,24 @@ public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
     request.begin();
 
     verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), eq(Boolean.TRUE), anyBoolean(),
+        .load(
+            eq(harness.glideContext),
+            eq(harness.model),
+            eq(harness.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(harness.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            eq(true),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
             any(ResourceCallback.class));
   }
 
@@ -744,10 +845,24 @@ public void testCallsSourceExecutorEngineIfOptionsIsSet() {
     request.begin();
 
     verify(harness.engine)
-        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
-            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
-            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            anyBoolean(), any(Options.class), anyBoolean(), eq(Boolean.FALSE), anyBoolean(),
+        .load(
+            eq(harness.glideContext),
+            eq(harness.model),
+            eq(harness.signature),
+            anyInt(),
+            anyInt(),
+            eq(Object.class),
+            eq(List.class),
+            any(Priority.class),
+            any(DiskCacheStrategy.class),
+            eq(harness.transformations),
+            anyBoolean(),
+            anyBoolean(),
+            any(Options.class),
+            anyBoolean(),
+            eq(false),
+            /*useAnimationPool=*/ anyBoolean(),
+            anyBoolean(),
             any(ResourceCallback.class));
   }
 
diff --git a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
index cdfc96e91..7b9d639aa 100644
--- a/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java
@@ -4,7 +4,6 @@
 import dagger.Component;
 import dagger.android.AndroidInjector;
 import dagger.android.support.AndroidSupportInjectionModule;
-
 import javax.inject.Singleton;
 
 /**
