diff --git a/README.md b/README.md
index 44ceb7c68..4301cb748 100644
--- a/README.md
+++ b/README.md
@@ -748,12 +748,463 @@ RuntimeCompat：可用进程数
         throw new IllegalArgumentException("Connot create a mutalbe Bitmap with config: "+config+". Consider setting Downsample#ALLOW_HARDWARE_CONFIG to false in your RequestOptions and/or in GlideBuilder.setDefaultRequestOptions");
       }
     }
+    @Nullable
+    private synchronized Bitmap getDirtyOrNull(int width,int height,@Nullable Bitmap.Config config){
+      assertNotHardwareConfig(config);
+      final Bitmap result=strategy.get(width,height,config!=null?config:DEFAULT_CONFIG);
+      if(result==null){
+        misses++;
+      }else{
+        hits++;
+        currentSize-=strategy.getSize(result);
+        tracker.remove(result);
+        normalize(result);
+      }
+      dump();
+      return result;
+    }
+    private static void normalize(Bitmap bitmap){
+      bitmap.setHasAlpha(true);
+      maybeSetPreMultiplied(bitmap);
+    }
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private static void maybeSetPreMultiplied(Bitmap bitmap){
+      if(Build.VERSION_CODES.SDK_INT>=Build.VERSION_CODES.KITKAT){
+        bitmap.setPremultiplied(true);
+      }
+    }
+    @Override
+    public void clearMemory(){
+      trimToSize(0);
+    }
+    @Override
+    public void trimMemory(int level){
+      if(level>=android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND){
+        clearMemory();
+      }else if(level>=android.content.ComponentCallback2.TRIM_MEMORY_UI_HIDDEN||level==android.content.ComponentCallback2.TRIM_MEMORY_RUNNING_CRITICAL){
+        trimToSize(getMaxSize/2);
+      }
+    }
+    private synchronized void trimToSize(long size){
+      while(currentSize>size){
+        final Bitmap removed=strategy.removeLast();
+        if(removed==null){
+          currentSize=0;
+          return
+        }
+        tracker.remove(removed);
+        currentSize-=strategy.getSize(removed);
+        evictions++;
+        dump();
+        removed.recycle();
+      }
+    }
+    private void dump(){
+      if(Log.isLoggable(TAG,Log.VERBOSE)){
+        dumpUnchecked();
+      }
+    }
+    private void dumpUnchecked(){
+      Log.v(TAG,"Hits="+hits+",misses="+misses+",puts="+puts+",evictions="+evictions+",currentSize="+currentSize+",maxSize="+masSize+"\nStrategy="+strategy);
+    }
     
+    private static LurPoolStrategy getDefaultStrategy(){
+      final LruPoolStrategy strategy;
+      if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.KITKAT){
+        strategy=new SizeConfigStrategy();
+      }else{
+        strategy=new AttributeStrategy();
+      }
+      return strategy;
+    }
+    @TargetApi(Build.VERSION_CODES.O)
+    private static Set<Bitmap.Config> getDefaultAllowedConfigs(){
+      Set<Bitmap.Config> configs=new HashSet<>(Arrays.asList(Bitmap.Config.values()));
+      if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.KITKAT){
+        configs.add(null);
+      }
+      if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O){
+        configs.remove(Bitmap.Config.HARDWARE);
+      }
+      return Collections.unmodifiableSet(configs);
+    }
+    private interface BitmapTracker{
+      void add(Bitmap bitmap);
+      void remove(Bitmap bitmap);
+    }
+    private static class ThrowingBitmapTracker implements BitmapTracker{
+      private final Set<Bitmap> bitmaps=Collections.synchronizedSet(new HashSet<Bitmap>());
+      @Override
+      public void add(Bitmap bitmap){
+        if(bitmaps.contains(bitmap)){
+          throw new IllegalStateException("Cannot add already added bitmap:"+bitmap+" ["+bitmap.getWidth()+"x"+bitmap.getHeight()+"]");
+        }
+        bitmaps.add(bitmap);
+      }
+      @Override
+      public void remove(Bitmap bitmap){
+        if(!bitmaps.contains(bitmap)){
+          throw new IllegalStateException("Connot remove bitmap not in tracker");
+        }
+        bitmaps.remove(bitmap);
+      }
+    }
+    private static final class NullBitmapTracker implements BitmapTracker{
+      NullBitmapTracker(){}
+      @Override
+      public void add(Bitmap bitmap){}
+      @Override
+      public void remove(Bitmap bitmap){}
+    }
+  }
+```
+SizeConfigStrategy
+```java
+  @RequiresApi(Build.VERSION_CODES.KITKAT)
+  public class SizeConfigStrategy implements LruPoolStrategy{
+    private static final int MAX_SIZE_MULTIPLE=8;
+    private static fianl Bitmap.Config[] ARGB_8888_IN_CONFIGS;
+    static{
+      Bitmap.Config[] result=new Bitmap.Config[]{
+        Bitmap.Config.ARGB_8888,
+        null,
+      };
+      if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O){
+        result=Arrays.copyOf(result,result.length+1);
+      }
+      ARGB_8888_IN_CONFIGS=result;
+    }
+    private static final Bitmap.Config[] RGBA_F16_IN_CONFIGS=ARGB_8888_IN_CONFIGS;
+    private static final Bitmap.COnfig[] RGB_565_IN_CONFIGS=new Bitmap.Config[]{Bitmap.Config.RGB_565};
+    private static final Bitmap.Config[] ARGB_4444_IN_CONFIGS=new Bitmap.Config[]{Bitmap.Config.ARGB_4444};
+    private static final Bitmap.Config[] ALPHA_8_IN_CONFIGS=new Bitmap.Config[]{Bitmap.Config.ALPHA_8};
+    
+    private final KeyPool keyPool=new KeyPool();
+    private final GroupedLinkedMap<Key,Bitmap> groupedMap=new GroupedLinkedMap<>();
+    private final Map<Bitmap.Config,NavigableMap<Integer,Integer>> sortedSizes=new HashMap<>();
+    
+    @Override
+    public void put(Bitmap bitmap){
+      int size=Util.getBitmapByteSize(bitmap);
+      Key key=keyPool.get(size,bitmap.getConfig());
+      groupedMap.put(key,bitmap);
+      NavigalbeMap<Integer,Integer> sizes=getSizesForConfig(bitmap.getConfig());
+      Integer current=sizes.get(key.size);
+      sizes.put(key.size,current==null?1:current+1);
+    }
+    @Override
+    @Nullable
+    public Bitmap get(int width,int height,Bitmap.Config config){
+      int size=Util.getBitmapByteSize(width,height,config);
+      Key bestKey=findBestKey(size,config);
+      Bitmap result=groupedMap.get(bestKey);
+      if(result!=null){
+        decrementBitmapOfSize(bestKey.size,result);
+        result.reconfigure(width,height,config);
+      }
+      return result;
+    }
+    private Key findBestKey(int size,Bitmap.Config config){
+      Key result=keyPool.get(size,config);
+      for(Bitmap.Config possibleConfig:getInConfigs(config)){
+        NavigableMap<Integer,Integer> sizesForPossibleConfig=getSizesForConfig(possibleConfig);
+        Integer possibleSize=sizesForPossibleConfig.ceilingKey(size);
+        if(possibleSize!=null&&possibleSize<=size*MAX_SIZE_MULTIPLE){
+          if(possibleSize!=size||(possibleConfig==null?config!=null:!possibleConfig.equals(config))){
+            keyPool.offer(result);
+            result=keyPool.get(possibleSize,possibleConfig);
+          }
+          break;
+        }
+      }
+      return result;
+    }
+    @Override
+    @Nullable
+    public Bitmap removeLast(){
+      Bitmap removed=groupedMap.removeLast();
+      if(removed!=null){
+        int removedSize=Util.getBitmapByteSize(removed);
+        decrementBitmapOfSize(removedSize,removed);
+      }
+      return removed;
+    }
+    private void decrementBitmapOfSize(Integer size,Bitmap removed){
+      Bitmap.Config config=removed.getConfig();
+      NavigableMap<Integer,Integer> sizes=getSizesForConfig(config);
+      Integer current=sizes.get(size);
+      if(current==null){
+        throw new IllegalStateException("Tried to decrement empty size,size:"+size+:",removed:"+logBitmap(removed)+",this:"+this);
+      }
+      if(current==1){
+        sizes.remove(size);
+      }else{
+        sizes.put(size,current-1);
+      }
+    }
+    private NavigableMap<Integer,Integer> getSizesForConfig(Bitmap.Config config){
+      NavigableMap<Integer,Integer> sizes=sortedSizes.get(config);
+      if(sizes==null){
+        sizes=new TreeMap<>();
+        sortedSizes.put(config.sizes);
+      }
+      return sizes;
+    }
+    @Override
+    public String logBitmap(Bitmap bitmap){
+      int size=Util.getBitmapByteSize(bitmap);
+      return getBitmapString(size,bitmap.getConfig());
+    }
+    @Override
+    public String logBitmap(int width,int height,Bitmap.Config config){
+      int size=Util.getBitmapByteSize(width,height,config);
+      return getBitmapString(size,config);
+    }
+    @Override
+    public int getSize(Bitmap bitmap){
+      return Util.getBitmapByteSize(bitmap);
+    }
+    @Override
+    public String toString(){
+      StringBuilder sb=new StringBuilder().append("SizeConfigStrategy{groupedMap=").append(groupedMap).append(",sortedSizes=(");
+      for(Map.Entry<Bitmap.Config,NavigableMap<Integer,Integer>> entry: sortedSizes.entrySet()){
+        sb.append(entry.getKey()).append('[').append(entry.getValue()).append("], ");
+      }
+      if(!sortedSizes.isEmpty()){
+        sb.replace(sb.length()-2,sb.length(),"");
+      }
+      return sb.append(")}").toString();
+    }
+    
+    static class KeyPool extends BaseKeyPool<Key>{
+      public Key get(int size,Bitmap.Config config){
+        Key result=get();
+        result.init(size,config);
+        return result;
+      }
+      @Override
+      protected Key create(){
+        return new Key(this);
+      }
+    }
+    static final class Key implements Poolable{
+      private final KeyPool pool;
+      private Bitmap.Config config;
+      public Key(KeyPool pool){
+        this.pool=pool;
+      }
+      Key(KeyPool pool,int size,Bitmap.Config config){
+        this(pool);
+        init(size,config);
+      }
+      public void init(int size,Bitmap.Config config){
+        this.size=size;
+        this.config=config;
+      }
+      @Override
+      public void offer(){
+        pool.offer(this);
+      }
+      @Override
+      public String toString(){
+        return getBitmapString(size,config);
+      }
+      @Ovrride
+      public boolean equals(Object o){
+        if(o instanceof Key){
+          Key other=(Key)o;
+          return size==other.size&&Util.bothNullOrEqual(config,other.config);
+        }
+        return false;
+      }
+      @Override
+      public int hashCode(){
+        int result=size;
+        result=31*result+(config!=null?config.hashCode():0);
+        return result;
+      }
+    }
+    static String getBimapString(int size,Bitmap.Config config){
+      return "["+size+"]("+config+")";
+    }
+    private static Bitmap.Config[] getInConfigs(Bitmap.Config requested){
+      if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O){
+        if(Bitmap.Config.RGBA_F16.equals(requested)){
+          return RGBA_F16_IN_CONFIGS;
+        }
+      }
+      switch(requested){
+        case ARGB_8888:
+          return ARGB_8888_IN_CONFIGS;
+        case RGB_565:
+          return RGB_565_IN_CONFIGS;
+        case ARGB_4444:
+          return ARGB_4444_IN_CONFIGS;
+        case ALPHA_8:
+          return ALPHA_8_IN_CONFIGS;
+        default:
+          return new Bitmap.Config[]{requested};
+      }
+    }
+  }
+```
+BaseKeyPool
+```java
+  abstract class BaseKeyPool<T extends Poolable>{
+    private static final int MAX_SIZE=20;
+    private final Queue<T> keyPool=Util.createQueue(MAX_SIZE);
+    
+    T get(){
+      T result=keyPool.poll();
+      if(result==null){
+        result=create();
+      }
+      return result;
+    }
+    public void offer(T key){
+      if(keyPool.size()<MAX_SIZE){
+        keyPool.offer(key);
+      }
+    }
+    abstract T create();
+  }
+```
+Util
+```java
+  public final class Util{
+    private static final int HASH_MULTIPLIER=31;
+    private static final int HASH_ACCUMULATOR=17;
+    private static final char[] HEX_CHAR_ARRAY="0123456789abcdef".toCharArray();
+    private static final char[] SHA_256_CHARS=new char[64]
+    private Uitl(){}
+    @NonNull
+    public static String sha256BytesToHex(@NonNull byte[] bytes){
+      sychronized(SHA_256_CHARS){
+        return bytesToHex(bytes,SHA_256_CHARS);
+      }
+    }
+    @NonNull
+    private static String bytesToHex(@NonNull byte[] bytes,@NonNull char[] hexChars){
+      int v;
+      for(int j=0;j<bytes.length;j++){
+        v=bytes[j]&0xFF;
+        hexChars[j*2]=HEX_CHAR_ARRAY[V>>>4];
+        hexChars[j*2+1]=HEX_CHAR_ARRAY[V&0x0F];
+      }
+      return new String(hexChars);
+    }
+    @Deprecated
+    public static int getSize(@NonNull Bitmap bitmap){
+      return getBitmapByteSize(bitmap);
+    }
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    public static int getBitmapByteSize(@NonNull Bitmap bitmap){
+      if(bitmap.isRecycled()){
+        throw new IllegalStateException("Cannot obtain size for recycled Bitmap:"+bitmap+"["+bitmap.getWidth()+"x"+bitmap.getHeight()+"]"+bitmap.getConfig());
+      }
+      if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.KITKAT){
+        try{
+          return bitmap.getAllocationByteCount();
+        }catch(NullPointerException e){
+          
+        }
+      }
+      return bitmap.getHeight*bitmap.getRowBytes();
+    }
+    private static int getBytesPerPixel(@Nullable Bitmap.Config config){
+      if(config==null){
+        config=Bitmap.Config.ARGB_8888;
+      }
+      int bytesPerPixel;
+      switch(config){
+        case ALPHA_8:
+          bytesPerPixel=1;
+          break;
+        case RGB_565:
+        case ARGB_4444:
+          bytesPerPixel=2;
+          break;
+        case RGBA_F16:
+          bytesPerPixel=8;
+          break;
+        case ARGB_8888:
+        default:
+          bytesPerPixel=4;
+          break;
+      }
+      return bytesPerPixel;
+    }
+    public static boolean isValidDimensions(int width,int height){
+      return isValidDimension(width)&&isValidDimension(height);
+    }
+    private static boolean isValidDimensions(int dimen){
+      return dimen>0||dimen==Target.SIZE_ORIGINAL;
+    }
+    public static void assetMainThread(){
+      if(!isOnMainThread()){
+        throw new IllegalArgumentException("You must call this method on the main thread");
+      }
+    }
+    public static void assertBackgroundThread(){
+      if(!isOnBackgroundThread()){
+        throw new IllegalArgumentException("You must call this method on a background thread");
+      }
+    }
+    public static boolean isOnMainThread(){
+      return Looper.myLooper()==Looper.getMainLooper();
+    }
+    public static boolean isOnBackgroundThread(){
+      return !isOnMainThread();
+    }
+    @NonNull
+    public static <T> Queue<T> createQueue(int size){
+      return new ArrayDeque<>(size);
+    }
+    @NonNull
+    public static <T> List<T> getSnapshot(@NonNull Collection<T> other){
+      List<T> result=new ArrayList<>(other.size());
+      for(T item: other){
+        if(item!=null){
+          result.add(item);
+        }
+      }
+      return result;
+    }
+    public static boolean bothNullOrEqual(@Nullable Object a,@Nullable Object b){
+      return a==null?b==null:a.equals(b);
+    }
+    public static boolean bothModelsNullEquivalentOrEquals(@Nullable Object a,@Nullable Object b){
+      if(a==null){
+        return b==null;
+      }
+      if(a istanceof Model){
+        return ((Model)a).isEquivalentTo(b);
+      }
+      return a.equals(b);
+    }
+    public static int hashCode(int value){
+      return hashCode(value,HASH_ACCUMULATOR);
+    }
+    public static int hashCode(int value,int accumulator){
+      return accumulator*HASH_MULTIPLIER+value;
+    }
+    public static int hashCode(float value){
+      return hashCode(value,HASH_ACCUMULATOR);
+    }
+    public static int hashCode(float value,int accumulator){
+      return hashCode(Float.floatToIntBits(value),accumulator);
+    }
+    public static int hashCode(@Nullable Object object,int accumulator){
+      return hashCode(object==null?0:object.hashCode(),accumulator);
+    }
+    public static int hashCode(boolean value,int accumulator){
+      return hashCode(value?1:0,accumulator);
+    }
+    public static int hashCode(boolean value){
+      return hashCode(value,HASH_ACCUMULATOR);
+    }
   }
 ```
-
-
-
 
 
 
