diff --git a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
index 24bd13efe..051cc4be6 100644
--- a/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java
@@ -42,7 +42,8 @@
 
   void validateExtension(TypeElement typeElement) {
     if (!typeElement.getModifiers().contains(Modifier.PUBLIC)) {
-      throw new IllegalArgumentException("RequestOptionsExtensions must be public");
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, including: " + getName(typeElement));
     }
     for (Element element : typeElement.getEnclosedElements()) {
       if (element.getKind() == ElementKind.CONSTRUCTOR) {
@@ -58,15 +59,30 @@ void validateExtension(TypeElement typeElement) {
     }
   }
 
+  private static String getQualifiedMethodName(ExecutableElement executableElement) {
+    return getEnclosingClassName(executableElement) + "#" + getName(executableElement);
+  }
+
+  private static String getEnclosingClassName(Element element) {
+    return element.getEnclosingElement().toString();
+  }
+
+  private static String getName(Element element) {
+    return element.toString();
+  }
+
   private static void validateExtensionConstructor(Element element) {
     if (!element.getModifiers().contains(Modifier.PRIVATE)) {
-      throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
-          + " constructors and only static methods. Found a non-private constructor");
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found a non-private constructor in: " + getEnclosingClassName(element));
     }
     ExecutableElement executableElement = (ExecutableElement) element;
     if (!executableElement.getParameters().isEmpty()) {
-      throw new IllegalArgumentException("RequestOptionsExtensions must be public, with private"
-          + " constructors and only static methods. Found parameters in the constructor");
+      throw new IllegalArgumentException(
+          "RequestOptionsExtensions must be public, with private constructors and only static"
+              + " methods. Found parameters in the constructor of: "
+              + getEnclosingClassName(element));
     }
   }
 
@@ -84,9 +100,9 @@ private void validateNewGlideOption(ExecutableElement executableElement) {
     TypeMirror returnType = executableElement.getReturnType();
     if (!isRequestOptions(returnType)) {
       throw new IllegalArgumentException("@GlideOption methods should return a RequestOptions"
-          + " object, but given: " + returnType + ". If you're using old style @GlideOption"
-          + " methods, your method may have a void return type, but doing so is deprecated and"
-          + " support will be removed in a future version");
+          + " object, but " + getQualifiedMethodName(executableElement) + " returns " + returnType
+          + ". If you're using old style @GlideOption methods, your method may have a void return"
+          + " type, but doing so is deprecated and support will be removed in a future version");
     }
     validateGlideOptionOverride(executableElement);
   }
@@ -104,13 +120,15 @@ private void validateDeprecatedGlideOption(ExecutableElement executableElement)
   private static void validateGlideOptionParameters(ExecutableElement executableElement) {
     if (executableElement.getParameters().isEmpty()) {
       throw new IllegalArgumentException("@GlideOption methods must take a "
-          + "RequestOptions object as their first parameter, but given none");
+          + "RequestOptions object as their first parameter, but "
+          + getQualifiedMethodName(executableElement) + " has none");
     }
     VariableElement first = executableElement.getParameters().get(0);
     TypeMirror expected = first.asType();
     if (!isRequestOptions(expected)) {
       throw new IllegalArgumentException("@GlideOption methods must take a"
-          + " RequestOptions object as their first parameter, but given: " + expected);
+          + " RequestOptions object as their first parameter, but the first parameter in "
+          + getQualifiedMethodName(executableElement) + " is " + expected);
     }
   }
 
@@ -125,11 +143,11 @@ private void validateGlideOptionOverride(ExecutableElement element) {
       throw new IllegalArgumentException("Accidentally attempting to override a method in"
           + " RequestOptions. Add an 'override' value in the @GlideOption annotation"
           + " if this is intentional. Offending method: "
-          + element.getEnclosingElement() + "#" + element);
+          + getQualifiedMethodName(element));
     } else if (!isOverridingRequestOptionsMethod && overrideType != GlideOption.OVERRIDE_NONE) {
       throw new IllegalArgumentException("Requested to override an existing method in"
           + " RequestOptions, but no such method was found. Offending method: "
-          + element.getEnclosingElement() + "#" + element);
+          + getQualifiedMethodName(element));
     }
   }
 
@@ -186,9 +204,10 @@ private void validateNewGlideType(ExecutableElement executableElement) {
     if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {
       String expectedClassName = getGlideTypeValue(executableElement);
       throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<"
-          + expectedClassName + "> object, but given: " + returnType + ". If you're"
-          + " using old style @GlideType methods, your method may have a void return type, but"
-          + " doing so is deprecated and support will be removed in a future version");
+          + expectedClassName + "> object, but " + getQualifiedMethodName(executableElement)
+          + " returns: " + returnType + ". If you're using old style @GlideType methods, your"
+          + " method may have a void return type, but doing so is deprecated and support will be"
+          + " removed in a future version");
     }
     validateGlideTypeParameters(executableElement);
   }
@@ -228,14 +247,15 @@ private static void validateGlideTypeParameters(ExecutableElement executableElem
     if (executableElement.getParameters().size() != 1) {
       throw new IllegalArgumentException("@GlideType methods must take a"
           + " RequestBuilder object as their first and only parameter, but given multiple for: "
-      + executableElement.getEnclosingElement() + "#" + executableElement);
+          + getQualifiedMethodName(executableElement));
     }
 
     VariableElement first = executableElement.getParameters().get(0);
     TypeMirror argumentType = first.asType();
     if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {
       throw new IllegalArgumentException("@GlideType methods must take a"
-          + " RequestBuilder object as their first and only parameter, but given: " + argumentType);
+          + " RequestBuilder object as their first and only parameter, but given: " + argumentType
+          + " for: " + getQualifiedMethodName(executableElement));
     }
   }
 
@@ -256,7 +276,7 @@ public String apply(AnnotationMirror input) {
     if (!annotationNames.contains(nonNull().reflectionName())) {
       processingEnvironment.getMessager().printMessage(
           Kind.WARNING,
-          executableElement.getEnclosingElement() + "#" + executableElement.getSimpleName()
+          getQualifiedMethodName(executableElement)
               + " is missing the " + nonNull().reflectionName() + " annotation,"
               + " please add it to ensure that your extension methods are always returning non-null"
               + " values");
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
index 9d891226a..c1a47efa2 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java
@@ -3,7 +3,9 @@
 import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
 
+import com.google.common.truth.Truth;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import org.junit.Rule;
@@ -23,36 +25,72 @@
 
   @Test
   public void compilation_withPublicConstructor_fails() {
-    expectedException.expect(RuntimeException.class);
-    javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "PublicConstructor",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "@GlideExtension",
-                "public class PublicConstructor { }"));
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PublicConstructor",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class PublicConstructor { }"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("non-private constructor");
+      Truth.assertThat(cause.getMessage()).contains("PublicConstructor");
+
+    }
   }
 
   @Test
-  public void compilation_withExtension_fails() {
-    expectedException.expect(RuntimeException.class);
-    javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "@GlideExtension",
-                "class Extension {",
-                "  private Extension() {}",
-                "}"));
+  public void compilation_withPackagePrivateExtension_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "PackagePrivateExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "class PackagePrivateExtension {",
+                  "  private PackagePrivateExtension() {}",
+                  "}"));
+      fail("Failed to throw expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("must be public");
+      Truth.assertThat(cause.getMessage()).contains("PackagePrivateExtension");
+    }
   }
 
+  @Test
+  public void compilation_withConstructorWithParameters_throws() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "ConstructorParametersExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "@GlideExtension",
+                  "public class ConstructorParametersExtension {",
+                  "  private ConstructorParametersExtension(int failParam) {}",
+                  "  public void doSomething() {}",
+                  "}"));
+      fail("Failed to get expected exception");
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      Truth.assertThat(cause.getMessage()).contains("parameters in the constructor");
+      Truth.assertThat(cause.getMessage()).contains("ConstructorParametersExtension");
+    }
+  }
 
   @Test
   public void compilation_withNonStaticMethod_succeeds() {
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
index 9f408b7e2..a0be89706 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java
@@ -3,7 +3,9 @@
 import static com.bumptech.glide.annotation.compiler.test.Util.emptyAppModule;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
 
+import com.google.common.truth.Truth;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import org.junit.Rule;
@@ -42,46 +44,32 @@ public void compilation_withAnnotatedNonStaticMethod_fails() {
                 "}"));
   }
 
-  @Test
-  public void compilation_withAnnotatedStaticMethod_withoutRequestOptionsArg_fails() {
-    expectedException.expect(RuntimeException.class);
-    javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideOption;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideOption",
-                "  public static void doSomething() {}",
-                "}"));
-
-  }
-
   @Test
   public void compilation_withAnnotatedStaticMethod_withRequestOptionsArgInWrongOrder_fails() {
-    expectedException.expect(RuntimeException.class);
-    javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideOption;",
-                "import com.bumptech.glide.request.RequestOptions;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideOption",
-                "  public static void doSomething(Object arg1, RequestOptions options) {}",
-                "}"));
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "NonRequestOptionsFirstArgExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.RequestOptions;",
+                  "@GlideExtension",
+                  "public class NonRequestOptionsFirstArgExtension{",
+                  "  private NonRequestOptionsFirstArgExtension() {}",
+                  "  @GlideOption",
+                  "  public static void doSomething(Object arg1, RequestOptions options) {}",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestOptions object as their first parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("NonRequestOptionsFirstArgExtension");
+    }
   }
 
   @Test
@@ -262,27 +250,35 @@ public void compilation_withRequestOptionsReturnValue_succeeds() {
 
   @Test
   public void compilation_withNonRequestOptionsReturnValue_fails() {
-    expectedException.expect(RuntimeException.class);
-    javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import android.support.annotation.NonNull;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideOption;",
-                "import com.bumptech.glide.request.RequestOptions;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @NonNull",
-                "  @GlideOption",
-                "  public static Object doSomething(RequestOptions options) {",
-                "    return options;",
-                "  }",
-                "}"));
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.RequestOptions;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static Object doSomething(RequestOptions options) {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideOption methods should return a RequestOptions object");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
   }
 
   @Test
@@ -310,4 +306,36 @@ public void compilation_withMissingNonNullAnnotation_warns() {
     assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");
     assertThat(compilation).hadWarningContaining("com.bumptech.glide.test.Extension#doSomething");
   }
+
+  @Test
+  public void compilation_withNoOptionParameters_fails() {
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "MissingRequestOptionsExtension",
+                  "package com.bumptech.glide.test;",
+                  "import android.support.annotation.NonNull;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideOption;",
+                  "import com.bumptech.glide.request.RequestOptions;",
+                  "@GlideExtension",
+                  "public class MissingRequestOptionsExtension {",
+                  "  private MissingRequestOptionsExtension() {}",
+                  "  @NonNull",
+                  "  @GlideOption",
+                  "  public static RequestOptions doSomething() {",
+                  "    return options;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestOptions object as their first parameter");
+      Truth.assertThat(message).contains("doSomething");
+      Truth.assertThat(message).contains("MissingRequestOptionsExtension");
+    }
+  }
 }
diff --git a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
index f3672822d..9076f806e 100644
--- a/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java
@@ -5,7 +5,9 @@
 import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
+import static org.junit.Assert.fail;
 
+import com.google.common.truth.Truth;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.io.IOException;
@@ -92,25 +94,29 @@ public void compilation_withAnnotatedStaticMethod_withRequestBuilderArg_succeeds
 
   @Test
   public void compilation_withAnnotatedStaticMethod_withNonRequestBuilderArg_fails() {
-    expectedException
-        .expectMessage(
-            "@GlideType methods must take a RequestBuilder object as their first and only"
-                + " parameter, but given: java.lang.Object");
-    javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines("Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.RequestBuilder;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideType;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideType(Number.class)",
-                "  public static void type(Object arg) {}",
-                "}"));
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongParameterTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongParameterTypeExtension {",
+                  "  private WrongParameterTypeExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static void type(Object arg) {}",
+                  "}"));
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("RequestBuilder object as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("WrongParameterTypeExtension");
+    }
   }
 
   @Test
@@ -197,58 +203,65 @@ public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_succee
 
   @Test
   public void compilation_withAnnotatedStaticMethod_returningNonRequestBuilder_fails() {
-    expectedException.expectMessage(
-        "@GlideType methods should return a RequestBuilder<java.lang.Number> object, but given:"
-            + " java.lang.Object. If you're using old style @GlideType methods, your method may"
-            + " have a void return type, but doing so is deprecated and support will be removed"
-            + " in a future version");
-    javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.RequestBuilder;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideType;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideType(Number.class)",
-                "  public static Object asNumber(",
-                "      RequestBuilder<Number> builder) {",
-                "    return new Object();",
-                "  }",
-                "}"));
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongReturnTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongReturnTypeExtension {",
+                  "  private WrongReturnTypeExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static Object asNumber(",
+                  "      RequestBuilder<Number> builder) {",
+                  "    return new Object();",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("@GlideType methods should return a RequestBuilder");
+      Truth.assertThat(message).contains("Number");
+      Truth.assertThat(message).contains("WrongReturnTypeExtension");
+    }
   }
 
   @Test
   public void compilation_withAnnotatedStaticMethod_returningBuilderWithIncorrectType_fails() {
-    expectedException.expectMessage(
-        "@GlideType methods should return a RequestBuilder<java.lang.Number> object, but given:"
-            + " com.bumptech.glide.RequestBuilder<java.lang.Object>. If you're using old style"
-            + " @GlideType methods, your method may have a void return type, but doing so is"
-            + " deprecated and support will be removed in a future version");
-    javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.RequestBuilder;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideType;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideType(Number.class)",
-                "  public static RequestBuilder<Object> asNumber(",
-                "      RequestBuilder<Object> builder) {",
-                "    return builder;",
-                "  }",
-                "}"));
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "WrongBuilderTypeExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class WrongBuilderTypeExtension {",
+                  "  private WrongBuilderTypeExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Object> asNumber(",
+                  "      RequestBuilder<Object> builder) {",
+                  "    return builder;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message)
+          .contains("@GlideType methods should return a RequestBuilder<java.lang.Number>");
+      Truth.assertThat(message)
+          .contains("WrongBuilderTypeExtension");
+    }
   }
 
   @Test
@@ -281,28 +294,34 @@ public void compilation_withAnnotatedStaticMethod_returningBuilder_andMultiplePa
 
   @Test
   public void compilation_withAnnotatedStaticMethod_returningBuilder_nonBuilderParam_fails() {
-    expectedException.expectMessage(
-        "@GlideType methods must take a RequestBuilder object as their first and only parameter,"
-            + " but given: java.lang.Object");
-    javac()
-        .withProcessors(new GlideAnnotationProcessor())
-        .compile(
-            emptyAppModule(),
-            JavaFileObjects.forSourceLines(
-                "Extension",
-                "package com.bumptech.glide.test;",
-                "import com.bumptech.glide.RequestBuilder;",
-                "import com.bumptech.glide.annotation.GlideExtension;",
-                "import com.bumptech.glide.annotation.GlideType;",
-                "@GlideExtension",
-                "public class Extension {",
-                "  private Extension() {}",
-                "  @GlideType(Number.class)",
-                "  public static RequestBuilder<Number> asNumber(",
-                "      Object arg) {",
-                "    return null;",
-                "  }",
-                "}"));
+    try {
+      javac()
+          .withProcessors(new GlideAnnotationProcessor())
+          .compile(
+              emptyAppModule(),
+              JavaFileObjects.forSourceLines(
+                  "IncorrectParameterExtension",
+                  "package com.bumptech.glide.test;",
+                  "import com.bumptech.glide.RequestBuilder;",
+                  "import com.bumptech.glide.annotation.GlideExtension;",
+                  "import com.bumptech.glide.annotation.GlideType;",
+                  "@GlideExtension",
+                  "public class IncorrectParameterExtension {",
+                  "  private IncorrectParameterExtension() {}",
+                  "  @GlideType(Number.class)",
+                  "  public static RequestBuilder<Number> asNumber(",
+                  "      Object arg) {",
+                  "    return null;",
+                  "  }",
+                  "}"));
+      fail();
+    } catch (RuntimeException e) {
+      String message = e.getCause().getMessage();
+      Truth.assertThat(message).contains("@GlideType methods must take a RequestBuilder object"
+          + " as their first and only parameter");
+      Truth.assertThat(message).contains("Object");
+      Truth.assertThat(message).contains("IncorrectParameterExtension");
+    }
   }
 
   @Test
diff --git a/build.gradle b/build.gradle
index 8987d5961..d54f9c4e5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,4 +1,5 @@
 import se.bjurr.violations.gradle.plugin.ViolationsTask
+import org.gradle.api.tasks.testing.logging.TestExceptionFormat
 
 buildscript {
     repositories {
@@ -31,6 +32,15 @@ if (JavaVersion.current().isJava8Compatible()) {
 }
 
 subprojects { project ->
+
+    repositories {
+        google()
+        jcenter()
+        maven {
+            url "https://oss.sonatype.org/content/repositories/snapshots"
+        }
+    }
+
     tasks.withType(JavaCompile) {
         sourceCompatibility = 1.7
         targetCompatibility = 1.7
@@ -54,40 +64,15 @@ subprojects { project ->
         }
     }
 
-    // Avoid issues like #2452.
-    tasks.withType(Jar) {
-        duplicatesStrategy = DuplicatesStrategy.FAIL
-    }
-
-    project.afterEvaluate {
-        if (project.hasProperty("android")
-                && project.name != 'pmd'
-                && project.name != 'findbugs') {
-            android {
-                lintOptions {
-                    warningsAsErrors true
-                    quiet true
-                    // Caught by the violations plugin.
-                    abortOnError false
-                }
-            }
-
-            android.variantFilter { variant ->
-                if(variant.buildType.name == 'release') {
-                    variant.setIgnore(true)
-                }
-            }
+    tasks.withType(Test) {
+        testLogging {
+            exceptionFormat = TestExceptionFormat.FULL
         }
     }
-}
 
-subprojects { project ->
-    repositories {
-        google()
-        jcenter()
-        maven {
-            url "https://oss.sonatype.org/content/repositories/snapshots"
-        }
+    // Avoid issues like #2452.
+    tasks.withType(Jar) {
+        duplicatesStrategy = DuplicatesStrategy.FAIL
     }
 
     apply plugin: 'checkstyle'
@@ -135,5 +120,24 @@ subprojects { project ->
             check.dependsOn('checkstyle')
             check.finalizedBy violations
         }
+
+        if (project.hasProperty("android")
+                && project.name != 'pmd'
+                && project.name != 'findbugs') {
+            android {
+                lintOptions {
+                    warningsAsErrors true
+                    quiet true
+                    // Caught by the violations plugin.
+                    abortOnError false
+                }
+            }
+
+            android.variantFilter { variant ->
+                if(variant.buildType.name == 'release') {
+                    variant.setIgnore(true)
+                }
+            }
+        }
     }
 }
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
index 078afb542..bfb14d052 100644
--- a/library/proguard-rules.txt
+++ b/library/proguard-rules.txt
@@ -1,6 +1,9 @@
 -keep public class * implements com.bumptech.glide.module.GlideModule
--keep public class * extends com.bumptech.glide.GeneratedAppGlideModule
+-keep public class * extends com.bumptech.glide.module.AppGlideModule
 -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
-    **[] $VALUES;
-    public *;
-}
\ No newline at end of file
+  **[] $VALUES;
+  public *;
+}
+
+# Uncomment for DexGuard only
+#-keepresourcexmlelements manifest/application/meta-data@value=GlideModule
\ No newline at end of file
diff --git a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index 8905d1bd2..1a2187ed6 100644
--- a/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/test/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -32,12 +32,14 @@
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.resource.gif.GifDrawableTest.BitmapTrackingShadowCanvas;
 import com.bumptech.glide.tests.GlideShadowLooper;
+import com.bumptech.glide.tests.TearDownGlide;
 import com.bumptech.glide.tests.Util;
 import com.bumptech.glide.util.Preconditions;
 import java.util.HashSet;
 import java.util.Set;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -54,6 +56,8 @@
 @Config(manifest = Config.NONE, sdk = 18,
     shadows = { GlideShadowLooper.class, BitmapTrackingShadowCanvas.class })
 public class GifDrawableTest {
+  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
+
   private GifDrawable drawable;
   private int frameHeight;
   private int frameWidth;
diff --git a/samples/imgur/build.gradle b/samples/imgur/build.gradle
index 27dcd1923..215392a94 100644
--- a/samples/imgur/build.gradle
+++ b/samples/imgur/build.gradle
@@ -20,7 +20,6 @@ android {
     buildTypes {
         release {
             minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
 }
diff --git a/samples/imgur/proguard-rules.pro b/samples/imgur/proguard-rules.pro
deleted file mode 100644
index 896f865d9..000000000
--- a/samples/imgur/proguard-rules.pro
+++ /dev/null
@@ -1,25 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Users/judds/Library/Android/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
-# Uncomment this to preserve the line number information for
-# debugging stack traces.
-#-keepattributes SourceFile,LineNumberTable
-
-# If you keep the line number information, uncomment this to
-# hide the original source file name.
-#-renamesourcefileattribute SourceFile
diff --git a/samples/svg/proguard-rules.pro b/samples/svg/proguard-rules.pro
deleted file mode 100644
index 95c847b91..000000000
--- a/samples/svg/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Users/judds/dev/adt-bundle-mac-x86_64-20131030/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
