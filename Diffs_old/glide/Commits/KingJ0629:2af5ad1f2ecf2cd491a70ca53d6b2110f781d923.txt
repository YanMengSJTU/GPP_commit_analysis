diff --git a/library/src/main/java/com/bumptech/glide/RequestBuilder.java b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
index d15224994..77db83f8e 100644
--- a/library/src/main/java/com/bumptech/glide/RequestBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java
@@ -589,7 +589,13 @@ protected RequestOptions getMutableOptions() {
     }
 
     options = options.autoClone();
-    // 创建请求
+    /**
+     * 创建请求对象
+     * buildRequest的target参数初始化了singleRequest的target变量，后续流程会用到
+     * 由{@link RequestBuilder#obtainRequest(Target, RequestListener, RequestOptions, RequestCoordinator, TransitionOptions, Priority, int, int)}
+     * 这个方法的返回值可知，请求最终托管给SingleRequest的实现
+     * 后面会用到{@link SingleRequest#begin()}
+     */
     Request request = buildRequest(target, targetListener, options);
     // 获取原先target的请求
     Request previous = target.getRequest();
@@ -597,7 +603,6 @@ protected RequestOptions getMutableOptions() {
     if (request.isEquivalentTo(previous) && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
 
       // 如果一样，就释放新请求
-      // 并且启动原来的请求
       request.recycle();
       // If the request is completed, beginning again will ensure the result is re-delivered,
       // triggering RequestListeners and Targets. If the request is failed, beginning again will
@@ -617,7 +622,9 @@ protected RequestOptions getMutableOptions() {
     requestManager.clear(target);
     // 并把新的请求用view的tag缓存起来
     target.setRequest(request);
-    // 启动新请求
+
+    // 首次加载主流程-->
+    // 把新请求加入等待队列
     requestManager.track(target, request);
 
     return target;
@@ -687,8 +694,12 @@ private boolean isSkipMemoryCacheWithCompletePreviousRequest(
       }
     }
 
-    // transcodeClass : Drawable
-    // glideContext.buildImageViewTarget(view, transcodeClass) -- > DrawableImageViewTarget.class
+    /**
+     * 首次加载主流程-->
+     * transcodeClass : Glide.with(context).load(new String())
+     * 在这里初始化RequestBuilder，把Drawable赋值给transcodeClass
+     * glideContext.buildImageViewTarget(view, transcodeClass) -- > DrawableImageViewTarget.class
+     */
     return into(glideContext.buildImageViewTarget(view, transcodeClass), null, requestOptions);
   }
 
@@ -932,6 +943,7 @@ private Request buildThumbnailRequestRecursive(
       int overrideWidth,
       int overrideHeight,
       RequestOptions requestOptions) {
+    // 是否有缩略图
     if (thumbnailBuilder != null) {
       // Recursive case: contains a potentially recursive thumbnail request builder.
       if (isThumbnailBuilt) {
@@ -1016,6 +1028,7 @@ private Request buildThumbnailRequestRecursive(
       return coordinator;
     } else {
       // Base case: no thumbnail.
+      // 首次加载的时候没有缩略图的情况
       return obtainRequest(
           target,
           targetListener,
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index 4738b6df8..f3b48b0c5 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -298,6 +298,7 @@ public void resumeRequestsRecursive() {
    */
   @Override
   public void onStart() {
+    // 启动先前被加入等待的请求队列
     resumeRequests();
     targetTracker.onStart();
   }
@@ -405,6 +406,7 @@ public void onDestroy() {
    * Equivalent to calling {@link #asDrawable()} and then {@link RequestBuilder#load(String)}.
    *
    * @return A new request builder for loading a {@link Drawable} using the given model.
+   * 返回一个用string（model）来加载这个{@link Drawable}的请求
    */
   @NonNull
   @CheckResult
diff --git a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
index fd88428e8..cb35b79fc 100644
--- a/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.manager;
 
+import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Util;
 import java.util.Collections;
 import java.util.Set;
@@ -46,6 +47,11 @@ public void removeListener(LifecycleListener listener) {
 
   void onStart() {
     isStarted = true;
+    /**
+     * 遍历所有监听生命周期的类，回调它们
+     * 我们主流程是RequestManager 实现的LifecycleListener
+     * {@link RequestManager#onStart()}
+     */
     for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
       lifecycleListener.onStart();
     }
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
index 6f3c67c2d..b6ce69199 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java
@@ -37,6 +37,12 @@
    */
   public void runRequest(Request request) {
     requests.add(request);
+    /**
+     * 第一次进来的时候isPaused是true，故首次加载的主流程不会进入这个if，故加载图片的request也不会在这里被启动
+     * 具体在哪里启动呢，是在整个方法走完之后，绑定的fragment回调生命周期
+     * 在{@link RequestManagerFragment#onStart()} 中启动等待运行的加载请求
+     * 等待运行的请求列表是 {@link #requests}
+     */
     if (!isPaused) {
       request.begin();
     } else {
@@ -113,6 +119,7 @@ public void pauseAllRequests() {
    */
   public void resumeRequests() {
     isPaused = false;
+    // 遍历等待中的请求，启动它们
     for (Request request : Util.getSnapshot(requests)) {
       if (!request.isComplete() && !request.isCancelled() && !request.isRunning()) {
         request.begin();
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 8154a27a0..e47c22e54 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -225,6 +225,10 @@ public void begin() {
     assertNotCallingCallbacks();
     stateVerifier.throwIfRecycled();
     startTime = LogTime.getLogTime();
+
+    /**
+     * model为null的时候去执行加载{@link #loadDrawable}错误占位图或者普通占位图
+     */
     if (model == null) {
       if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
         width = overrideWidth;
@@ -247,6 +251,10 @@ public void begin() {
     // new load etc. This does mean that users who want to restart a load because they expect that
     // the view size has changed will need to explicitly clear the View or Target before starting
     // the new load.
+    // 机翻：如果我们在完成后重新启动（通常通过类似于notifyDataSetChanged的方式，
+    // 可以将相同的请求启动到同一个目标或视图中），那么我们可以简单地使用上次检索到的资源和大小，
+    // 并跳过获取新的大小，开始一个新的加载等等。这意味着，想要重新开始加载的用户，
+    // 因为他们期望视图大小已经改变，需要在开始新加载之前明确地清除视图或目标。
     if (status == Status.COMPLETE) {
       onResourceReady(resource, DataSource.MEMORY_CACHE);
       return;
@@ -254,11 +262,20 @@ public void begin() {
 
     // Restarts for requests that are neither complete nor running can be treated as new requests
     // and can run again from the beginning.
-
+    // 没有完成的请求重新被启动，被看做是一个新情求
     status = Status.WAITING_FOR_SIZE;
+    // 判断图片尺寸是否已经被初始化过
     if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
       onSizeReady(overrideWidth, overrideHeight);
     } else {
+      /**
+       * 若第一次加载，尺寸未初始化，主流程进入这里
+       * 在前面流程中{@link com.bumptech.glide.RequestBuilder#into(Target, RequestListener, RequestOptions)}
+       * target被赋值为DrawableImageViewTarget.class
+       * DrawableImageViewTarget 继承 ImageViewTarget， ImageViewTarget 继承 ViewTarget
+       * 故target.getSize(this) 调用的是{@link com.bumptech.glide.request.target.ViewTarget#getSize(SizeReadyCallback)}
+       * this对象是SingleRequest自身实现了SizeReadyCallback接口
+       */
       target.getSize(this);
     }
 
@@ -437,6 +454,7 @@ public void onSizeReady(int width, int height) {
     if (status != Status.WAITING_FOR_SIZE) {
       return;
     }
+    // 改变加载状态
     status = Status.RUNNING;
 
     float sizeMultiplier = requestOptions.getSizeMultiplier();
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index e017e209b..ce1cd9e5a 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -370,6 +370,7 @@ void getSize(@NonNull SizeReadyCallback cb) {
       int currentWidth = getTargetWidth();
       int currentHeight = getTargetHeight();
       if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
+        // 计算出长宽，然后回调SingleRequest的onSizeReady方法
         cb.onSizeReady(currentWidth, currentHeight);
         return;
       }
diff --git a/library/src/main/java/com/bumptech/glide/util/Util.java b/library/src/main/java/com/bumptech/glide/util/Util.java
index 7e294e2c7..7ae5d66b6 100644
--- a/library/src/main/java/com/bumptech/glide/util/Util.java
+++ b/library/src/main/java/com/bumptech/glide/util/Util.java
@@ -176,6 +176,7 @@ public static boolean isOnBackgroundThread() {
    * modify the original list.
    *
    * <p>See #303, #375, #322, #2262.
+   * 去掉null对象
    */
   @NonNull
   @SuppressWarnings("UseBulkOperation")
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/SourceCodeInterpreted.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/SourceCodeInterpreted.java
index 06174b2e4..c2001631a 100644
--- a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/SourceCodeInterpreted.java
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/SourceCodeInterpreted.java
@@ -12,22 +12,20 @@
  */
 public class SourceCodeInterpreted extends Activity {
 
+
   @Override
   protected void onCreate(@Nullable Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
-
     // 常用调用方法
     Glide
         // 绑定生命周期
         .with(this)
-
         /**
-         * 把new String()赋值给RequestBuilder的Object model参数,并设置isModelSet为true
+         * 把new String()赋值给RequestBuilder的model参数,并设置isModelSet为true
          * {@link com.bumptech.glide.RequestBuilder#loadGeneric(Object)}
+         * 初始化RequestBuilder，把Drawable赋值给transcodeClass，后续主流程会用到这个参数
          */
         .load(new String())
-
-
         .into(new ImageView(this));
   }
 }
