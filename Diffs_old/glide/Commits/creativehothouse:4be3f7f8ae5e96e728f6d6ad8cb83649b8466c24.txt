diff --git a/library/build.gradle b/library/build.gradle
index 5ac346e41..d491221b6 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -6,6 +6,7 @@ apply plugin: 'jacoco'
 apply plugin: 'com.github.kt3k.coveralls'
 
 dependencies {
+    compile files('libs/japng-0.5.1.jar')
     compile project(':third_party:gif_decoder')
     compile project(':third_party:disklrucache')
     compile project(':annotation')
diff --git a/library/libs/japng-0.5.1.jar b/library/libs/japng-0.5.1.jar
new file mode 100644
index 000000000..b06d6c3b4
Binary files /dev/null and b/library/libs/japng-0.5.1.jar differ
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index c1251eab7..e3767f6f3 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -46,6 +46,9 @@
 import com.bumptech.glide.load.model.stream.MediaStoreImageThumbLoader;
 import com.bumptech.glide.load.model.stream.MediaStoreVideoThumbLoader;
 import com.bumptech.glide.load.model.stream.UrlLoader;
+import com.bumptech.glide.load.resource.apng.ApngDrawable;
+import com.bumptech.glide.load.resource.apng.ApngResourceDecoder;
+import com.bumptech.glide.load.resource.apng.ApngResourceEncoder;
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableDecoder;
 import com.bumptech.glide.load.resource.bitmap.BitmapDrawableEncoder;
 import com.bumptech.glide.load.resource.bitmap.BitmapEncoder;
@@ -89,8 +92,8 @@
  * {@link RequestBuilder} and maintaining an {@link Engine}, {@link BitmapPool},
  * {@link com.bumptech.glide.load.engine.cache.DiskCache} and {@link MemoryCache}.
  */
-@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-public class Glide implements ComponentCallbacks2 {
+@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public class Glide
+    implements ComponentCallbacks2 {
   private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
   private static final String TAG = "Glide";
   private static volatile Glide glide;
@@ -115,8 +118,7 @@
    * @param context A context.
    * @see #getPhotoCacheDir(android.content.Context, String)
    */
-  @Nullable
-  public static File getPhotoCacheDir(Context context) {
+  @Nullable public static File getPhotoCacheDir(Context context) {
     return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
   }
 
@@ -124,12 +126,11 @@ public static File getPhotoCacheDir(Context context) {
    * Returns a directory with the given name in the private cache directory of the application to
    * use to store retrieved media and thumbnails.
    *
-   * @param context   A context.
+   * @param context A context.
    * @param cacheName The name of the subdirectory in which to store the cache.
    * @see #getPhotoCacheDir(android.content.Context)
    */
-  @Nullable
-  public static File getPhotoCacheDir(Context context, String cacheName) {
+  @Nullable public static File getPhotoCacheDir(Context context, String cacheName) {
     File cacheDir = context.getCacheDir();
     if (cacheDir != null) {
       File result = new File(cacheDir, cacheName);
@@ -174,18 +175,15 @@ private static void checkAndInitializeGlide(Context context) {
     isInitializing = false;
   }
 
-  @VisibleForTesting
-  public static synchronized void init(Glide glide) {
+  @VisibleForTesting public static synchronized void init(Glide glide) {
     Glide.glide = glide;
   }
 
-  @VisibleForTesting
-  public static synchronized void tearDown() {
+  @VisibleForTesting public static synchronized void tearDown() {
     glide = null;
   }
 
-  @SuppressWarnings("deprecation")
-  private static void initializeGlide(Context context) {
+  @SuppressWarnings("deprecation") private static void initializeGlide(Context context) {
     Context applicationContext = context.getApplicationContext();
 
     GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
@@ -194,10 +192,9 @@ private static void initializeGlide(Context context) {
       manifestModules = new ManifestParser(applicationContext).parse();
     }
 
-    if (annotationGeneratedModule != null
-        && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
-      Set<Class<?>> excludedModuleClasses =
-          annotationGeneratedModule.getExcludedModuleClasses();
+    if (annotationGeneratedModule != null && !annotationGeneratedModule.getExcludedModuleClasses()
+        .isEmpty()) {
+      Set<Class<?>> excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();
       Iterator<com.bumptech.glide.module.GlideModule> iterator = manifestModules.iterator();
       while (iterator.hasNext()) {
         com.bumptech.glide.module.GlideModule current = iterator.next();
@@ -218,10 +215,9 @@ private static void initializeGlide(Context context) {
     }
 
     RequestManagerRetriever.RequestManagerFactory factory =
-        annotationGeneratedModule != null
-            ? annotationGeneratedModule.getRequestManagerFactory() : null;
-    GlideBuilder builder = new GlideBuilder()
-        .setRequestManagerFactory(factory);
+        annotationGeneratedModule != null ? annotationGeneratedModule.getRequestManagerFactory()
+            : null;
+    GlideBuilder builder = new GlideBuilder().setRequestManagerFactory(factory);
     for (com.bumptech.glide.module.GlideModule module : manifestModules) {
       module.applyOptions(applicationContext, builder);
     }
@@ -239,14 +235,12 @@ private static void initializeGlide(Context context) {
     Glide.glide = glide;
   }
 
-  @Nullable
-  @SuppressWarnings({"unchecked", "deprecation", "TryWithIdenticalCatches"})
+  @Nullable @SuppressWarnings({ "unchecked", "deprecation", "TryWithIdenticalCatches" })
   private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
     GeneratedAppGlideModule result = null;
     try {
-      Class<GeneratedAppGlideModule> clazz =
-          (Class<GeneratedAppGlideModule>)
-              Class.forName("com.bumptech.glide.GeneratedAppGlideModuleImpl");
+      Class<GeneratedAppGlideModule> clazz = (Class<GeneratedAppGlideModule>) Class.forName(
+          "com.bumptech.glide.GeneratedAppGlideModuleImpl");
       result = clazz.newInstance();
     } catch (ClassNotFoundException e) {
       if (Log.isLoggable(TAG, Log.WARN)) {
@@ -268,16 +262,10 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
     return result;
   }
 
-  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-  Glide(
-      Context context,
-      Engine engine,
-      MemoryCache memoryCache,
-      BitmapPool bitmapPool,
-      ArrayPool arrayPool,
+  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) Glide(Context context, Engine engine,
+      MemoryCache memoryCache, BitmapPool bitmapPool, ArrayPool arrayPool,
       RequestManagerRetriever requestManagerRetriever,
-      ConnectivityMonitorFactory connectivityMonitorFactory,
-      int logLevel,
+      ConnectivityMonitorFactory connectivityMonitorFactory, int logLevel,
       RequestOptions defaultRequestOptions,
       Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {
     this.engine = engine;
@@ -295,13 +283,14 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
     registry = new Registry();
     registry.register(new DefaultImageHeaderParser());
 
-    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),
-        resources.getDisplayMetrics(), bitmapPool, arrayPool);
+    Downsampler downsampler =
+        new Downsampler(registry.getImageHeaderParsers(), resources.getDisplayMetrics(), bitmapPool,
+            arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
         new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);
+    ApngResourceDecoder apngResourceDecoder = new ApngResourceDecoder(context, bitmapPool, arrayPool);
 
-    registry
-        .append(ByteBuffer.class, new ByteBufferEncoder())
+    registry.append(ByteBuffer.class, new ByteBufferEncoder())
         .append(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
         .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class,
@@ -331,6 +320,9 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>())
         .append(Registry.BUCKET_BITMAP, GifDecoder.class, Bitmap.class,
             new GifFrameResourceDecoder(bitmapPool))
+        /* APNG */
+        .append(Registry.BUCKET_APNG, InputStream.class, ApngDrawable.class, apngResourceDecoder)
+        .append(ApngDrawable.class, new ApngResourceEncoder())
         /* Drawables */
         .append(Uri.class, Drawable.class, new ResourceDrawableDecoder(context))
         /* Files */
@@ -344,15 +336,11 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         /* Models */
         .register(new InputStreamRewinder.Factory(arrayPool))
         .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
-        .append(
-                int.class,
-                ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
+        .append(int.class, ParcelFileDescriptor.class,
+            new ResourceLoader.FileDescriptorFactory(resources))
         .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
-        .append(
-                Integer.class,
-                ParcelFileDescriptor.class,
-                new ResourceLoader.FileDescriptorFactory(resources))
+        .append(Integer.class, ParcelFileDescriptor.class,
+            new ResourceLoader.FileDescriptorFactory(resources))
         .append(Integer.class, Uri.class, new ResourceLoader.UriFactory(resources))
         .append(int.class, Uri.class, new ResourceLoader.UriFactory(resources))
         .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
@@ -360,18 +348,14 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
         .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
-        .append(
-                Uri.class,
-                ParcelFileDescriptor.class,
-                new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+        .append(Uri.class, ParcelFileDescriptor.class,
+            new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
         .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
         .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
-        .append(
-            Uri.class,
-            InputStream.class,
+        .append(Uri.class, InputStream.class,
             new UriLoader.StreamFactory(context.getContentResolver()))
         .append(Uri.class, ParcelFileDescriptor.class,
-             new UriLoader.FileDescriptorFactory(context.getContentResolver()))
+            new UriLoader.FileDescriptorFactory(context.getContentResolver()))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
         .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
@@ -387,8 +371,7 @@ private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() {
 
     ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();
     glideContext =
-        new GlideContext(
-            context, registry, imageViewTargetFactory, defaultRequestOptions,
+        new GlideContext(context, registry, imageViewTargetFactory, defaultRequestOptions,
             defaultTransitionOptions, engine, logLevel);
   }
 
@@ -496,7 +479,7 @@ public void trimMemory(int level) {
    * Clears disk cache.
    *
    * <p>
-   *     This method should always be called on a background thread, since it is a blocking call.
+   * This method should always be called on a background thread, since it is a blocking call.
    * </p>
    */
   @SuppressWarnings("unused") // Public API
@@ -505,7 +488,6 @@ public void clearDiskCache() {
     engine.clearDiskCache();
   }
 
-
   /**
    * Internal method.
    */
@@ -539,8 +521,7 @@ public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {
   private static RequestManagerRetriever getRetriever(@Nullable Context context) {
     // Context could be null for other reasons (ie the user passes in null), but in practice it will
     // only occur due to errors with the Fragment lifecycle.
-    Preconditions.checkNotNull(
-        context,
+    Preconditions.checkNotNull(context,
         "You cannot start a load on a not yet attached View or a  Fragment where getActivity() "
             + "returns null (which usually occurs when getActivity() is called before the Fragment "
             + "is attached or after the Fragment is destroyed).");
@@ -681,18 +662,15 @@ void unregisterRequestManager(RequestManager requestManager) {
     }
   }
 
-  @Override
-  public void onTrimMemory(int level) {
+  @Override public void onTrimMemory(int level) {
     trimMemory(level);
   }
 
-  @Override
-  public void onConfigurationChanged(Configuration newConfig) {
+  @Override public void onConfigurationChanged(Configuration newConfig) {
     // Do nothing.
   }
 
-  @Override
-  public void onLowMemory() {
+  @Override public void onLowMemory() {
     clearMemory();
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index 97ef93a87..f3be90914 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -34,6 +34,7 @@
  */
 public class Registry {
   public static final String BUCKET_GIF = "Gif";
+  public static final String BUCKET_APNG = "Apng";
   public static final String BUCKET_BITMAP = "Bitmap";
   public static final String BUCKET_BITMAP_DRAWABLE = "BitmapDrawable";
   private static final String BUCKET_PREPEND_ALL = "legacy_prepend_all";
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index ecd2e5821..8a4e89e9f 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -1,9 +1,5 @@
 package com.bumptech.glide;
 
-import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
-import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
-import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
-
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.drawable.Drawable;
@@ -14,6 +10,7 @@
 import android.support.annotation.Nullable;
 import android.view.View;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.resource.apng.ApngDrawable;
 import com.bumptech.glide.load.resource.gif.GifDrawable;
 import com.bumptech.glide.manager.ConnectivityMonitor;
 import com.bumptech.glide.manager.ConnectivityMonitorFactory;
@@ -31,6 +28,10 @@
 import com.bumptech.glide.util.Util;
 import java.io.File;
 
+import static com.bumptech.glide.request.RequestOptions.decodeTypeOf;
+import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;
+import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;
+
 /**
  * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity
  * lifecycle events to intelligently stop, start, and restart requests. Retrieve either by
@@ -46,6 +47,7 @@
 public class RequestManager implements LifecycleListener {
   private static final RequestOptions DECODE_TYPE_BITMAP = decodeTypeOf(Bitmap.class).lock();
   private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();
+  private static final RequestOptions DECODE_TYPE_APNG = decodeTypeOf(ApngDrawable.class).lock();
   private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =
       diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
@@ -326,6 +328,24 @@ public void onDestroy() {
     return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
   }
 
+  /**
+   * Attempts to always load the resource as a
+   * {@link com.bumptech.glide.load.resource.apng.ApngDrawable}.
+   *
+   * <p> If the underlying data is not a APNG, this will fail. As a result, this should only be used
+   * if the model represents an animated APNG and the caller wants to interact with the ApngDrawable
+   * directly. Normally using just {@link #asDrawable()} is sufficient because it will determine
+   * whether or not the given data represents an animated APNG and return the appropriate {@link
+   * Drawable}, animated or not, automatically. </p>
+   *
+   * @return A new request builder for loading a
+   * {@link com.bumptech.glide.load.resource.apng.ApngDrawable}.
+   */
+  @CheckResult
+  public RequestBuilder<ApngDrawable> asApng() {
+    return as(ApngDrawable.class).apply(DECODE_TYPE_APNG);
+  }
+
   /**
    * Attempts to always load the resource using any registered {@link
    * com.bumptech.glide.load.ResourceDecoder}s that can decode any subclass of {@link Drawable}.
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngAnimationComposer.java b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngAnimationComposer.java
new file mode 100644
index 000000000..4defccff8
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngAnimationComposer.java
@@ -0,0 +1,204 @@
+package com.bumptech.glide.load.resource.apng;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffXfermode;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.drawable.BitmapDrawable;
+import android.support.annotation.ColorInt;
+import com.bumptech.glide.load.resource.apng.ApngBitmapProvider;
+import com.bumptech.glide.load.resource.apng.ApngDrawable;
+import java.util.ArrayList;
+import java.util.List;
+import net.ellerton.japng.argb8888.Argb8888Bitmap;
+import net.ellerton.japng.argb8888.Argb8888ScanlineProcessor;
+import net.ellerton.japng.chunks.PngAnimationControl;
+import net.ellerton.japng.chunks.PngFrameControl;
+import net.ellerton.japng.chunks.PngHeader;
+
+/**
+ * Takes loaded PNG frames and composes them into an android AnimationDrawable.
+ */
+public class ApngAnimationComposer {
+  private Resources resources;
+  private Canvas canvas;
+  private PngHeader header;
+  private Bitmap canvasBitmap;
+  private Argb8888ScanlineProcessor scanlineProcessor;
+  private PngAnimationControl animationControl;
+  private ApngBitmapProvider apngBitmapProvider;
+  private PngFrameControl currentFrame;
+  private List<Frame> frames;
+  private int durationScale = 1;
+  private Paint srcModePaint;
+
+  @ColorInt private int[] mainScratch;
+
+  public ApngAnimationComposer(Resources resources, PngHeader header,
+      Argb8888ScanlineProcessor scanlineProcessor, PngAnimationControl animationControl,
+      ApngBitmapProvider apngBitmapProvider) {
+    this.resources = resources;
+    this.header = header;
+    this.scanlineProcessor = scanlineProcessor;
+    this.animationControl = animationControl;
+    this.apngBitmapProvider = apngBitmapProvider;
+
+    this.canvasBitmap =
+        apngBitmapProvider.obtain(this.header.width, this.header.height, Bitmap.Config.ARGB_8888);
+    this.canvas = new Canvas(this.canvasBitmap);
+    this.frames = new ArrayList<>(animationControl.numFrames);
+    this.srcModePaint = new Paint();
+    this.srcModePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
+  }
+
+  public int getDurationScale() {
+    return durationScale;
+  }
+
+  public void setDurationScale(int durationScale) {
+    this.durationScale = durationScale;
+  }
+
+  public boolean isSingleFrame() {
+    return 1 == animationControl.numFrames;
+  }
+
+  public ApngDrawable assemble() {
+    // TODO: handle special case of one frame animation as a plain ImageView
+    boolean isFinite = !animationControl.loopForever();
+    ApngDrawable ad = new ApngDrawable(header);
+    ad.setOneShot(isFinite);
+
+    // The AnimationDrawable doesn't support a repeat count so add
+    // frames as required. At least the frames can re-use drawables.
+    int repeatSequenceCount = isFinite ? animationControl.numPlays : 1;
+
+    for (int i = 0; i < repeatSequenceCount; i++) {
+      for (Frame frame : frames) {
+        ad.addFrame(frame.drawable, frame.control.getDelayMilliseconds() * durationScale);
+        ad.addControll(frame.control);
+      }
+    }
+
+    ad.setNumFrames(animationControl.numFrames);
+    ad.setNumPlays(animationControl.numPlays);
+
+    return ad;
+  }
+
+  public Argb8888ScanlineProcessor beginFrame(PngFrameControl frameControl) {
+    currentFrame = frameControl;
+    return scanlineProcessor.cloneWithSharedBitmap(header.adjustFor(currentFrame));
+    //return scanlineProcessor.cloneWithNewBitmap(header.adjustFor(currentFrame));
+  }
+
+  public void completeFrame(Argb8888Bitmap frameImage) {
+    Bitmap frame = apngBitmapProvider.toBitmap(frameImage);
+    boolean isFull = currentFrame.height == header.height && currentFrame.width == header.width;
+    Paint paint = null;
+    BitmapDrawable bitmapDrawable;
+    Bitmap previous = null;
+
+    // Capture the current bitmap region IF it needs to be reverted after rendering
+    if (2 == currentFrame.disposeOp) {
+      previous = apngBitmapProvider.obtain(currentFrame.width, currentFrame.height,
+          Bitmap.Config.ARGB_8888);
+      Canvas canvas = new Canvas(previous);
+      Rect srcR = new Rect(currentFrame.xOffset, currentFrame.yOffset, currentFrame.xOffset + currentFrame.width, currentFrame.yOffset + currentFrame.height);
+      RectF dstR = new RectF(0, 0, currentFrame.width, currentFrame.height);
+      canvas.drawBitmap(canvasBitmap, srcR, dstR, new Paint());
+      canvas.setBitmap(null);
+      // or could use from frames?
+      //System.out.println(String.format("Captured previous %d x %d", previous.getWidth(), previous.getHeight()));
+    }
+
+    if (0 == currentFrame.blendOp) { // SRC_OVER, not blend (for blend, leave paint null)
+      //paint = new Paint();
+      //paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
+      paint = srcModePaint;
+    }
+
+    // Draw the new frame into place
+    canvas.drawBitmap(frame, currentFrame.xOffset, currentFrame.yOffset, paint);
+
+    // Extract a drawable from the canvas. Have to copy the current bitmap.
+    bitmapDrawable =
+        new BitmapDrawable(resources, canvasBitmap.copy(Bitmap.Config.ARGB_8888, false));
+    apngBitmapProvider.release(frame);
+
+    // Store the drawable in the sequence of frames
+    frames.add(new Frame(currentFrame, bitmapDrawable));
+
+    // Now "dispose" of the frame in preparation for the next.
+
+    // https://wiki.mozilla.org/APNG_Specification#.60fcTL.60:_The_Frame_Control_Chunk
+    //
+    // APNG_DISPOSE_OP_NONE: no disposal is done on this frame before rendering the next; the contents of the output buffer are left as is.
+    // APNG_DISPOSE_OP_BACKGROUND: the frame's region of the output buffer is to be cleared to fully transparent black before rendering the next frame.
+    // APNG_DISPOSE_OP_PREVIOUS: the frame's region of the output buffer is to be reverted to the previous contents before rendering the next frame.
+    //
+    switch (currentFrame.disposeOp) {
+      case 1: // APNG_DISPOSE_OP_BACKGROUND
+        //System.out.println(String.format("Frame %d clear background (full=%s, x=%d y=%d w=%d h=%d) previous=%s", currentFrame.sequenceNumber,
+        //        isFull, currentFrame.xOffset, currentFrame.yOffset, currentFrame.width, currentFrame.height, previous));
+        if (isFull) {
+          canvas.drawColor(0, PorterDuff.Mode.CLEAR); // Clear to fully transparent black
+        } else {
+          Rect rt = new Rect(currentFrame.xOffset, currentFrame.yOffset,
+              currentFrame.width + currentFrame.xOffset,
+              currentFrame.height + currentFrame.yOffset);
+          paint = new Paint();
+          paint.setColor(0);
+          paint.setStyle(Paint.Style.FILL);
+          canvas.drawRect(rt, paint);
+        }
+        break;
+
+      case 2: // APNG_DISPOSE_OP_PREVIOUS
+        //System.out.println(String.format("Frame %d restore previous (full=%s, x=%d y=%d w=%d h=%d) previous=%s", currentFrame.sequenceNumber,
+        //        isFull, currentFrame.xOffset, currentFrame.yOffset, currentFrame.width, currentFrame.height, previous));
+
+        // Put the original section back
+        if (null != previous) {
+          //paint = new Paint();
+          //paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
+          paint = srcModePaint;
+          canvas.drawBitmap(previous, currentFrame.xOffset, currentFrame.yOffset, paint);
+
+          //System.out.println("  Restored previous "+previous.getWidth()+" x "+previous.getHeight());
+
+          apngBitmapProvider.release(previous);
+        } else {
+          System.out.println("  Huh, no previous?");
+        }
+        break;
+
+      case 0: // APNG_DISPOSE_OP_NONE
+      default: // Default should never happen
+        // do nothing
+        //System.out.println("Frame "+currentFrame.sequenceNumber+" do nothing dispose");
+        break;
+    }
+
+    currentFrame = null;
+  }
+
+  public void clear() {
+    apngBitmapProvider.release(canvasBitmap);
+  }
+
+  public static class Frame {
+    public final PngFrameControl control;
+    public final BitmapDrawable drawable;
+
+    public Frame(PngFrameControl control, BitmapDrawable drawable) {
+      this.control = control;
+      this.drawable = drawable;
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngBitmapProvider.java b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngBitmapProvider.java
new file mode 100644
index 000000000..ea68e7391
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngBitmapProvider.java
@@ -0,0 +1,71 @@
+package com.bumptech.glide.load.resource.apng;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import net.ellerton.japng.argb8888.Argb8888Bitmap;
+
+/**
+ * wrapping Glide's {@link BitmapPool} and  {@link ArrayPool}.
+ */
+public final class ApngBitmapProvider {
+  private final BitmapPool bitmapPool;
+  @Nullable private final ArrayPool arrayPool;
+  /**
+   * Constructs an instance with a shared array pool. Arrays will be reused where
+   * possible.
+   */
+  public ApngBitmapProvider(BitmapPool bitmapPool, ArrayPool arrayPool) {
+    this.bitmapPool = bitmapPool;
+    this.arrayPool = arrayPool;
+  }
+
+  @NonNull
+  public Bitmap obtain(int width, int height, Bitmap.Config config) {
+    return bitmapPool.get(width, height, config);
+  }
+
+  public void release(Bitmap bitmap) {
+    bitmapPool.put(bitmap);
+  }
+
+  public byte[] obtainByteArray(int size) {
+    if (arrayPool == null) {
+      return new byte[size];
+    }
+    return arrayPool.get(size, byte[].class);
+  }
+
+  @SuppressWarnings("PMD.UseVarargs")
+  public void release(byte[] bytes) {
+    if (arrayPool == null) {
+      return;
+    }
+    arrayPool.put(bytes, byte[].class);
+  }
+
+  public int[] obtainIntArray(int size) {
+    if (arrayPool == null) {
+      return new int[size];
+    }
+    return arrayPool.get(size, int[].class);
+  }
+
+  @SuppressWarnings("PMD.UseVarargs")
+  public void release(int[] array) {
+    if (arrayPool == null) {
+      return;
+    }
+    arrayPool.put(array, int[].class);
+  }
+
+  public Bitmap toBitmap(Argb8888Bitmap src) {
+    int offset = 0;
+    int stride = src.width;
+    Bitmap bitmap = obtain(src.width,src.height,Bitmap.Config.ARGB_8888);
+    bitmap.setPixels(src.getPixelArray(), offset, stride,0,0, src.width, src.height );
+    return bitmap;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngDrawable.java
new file mode 100644
index 000000000..62d23e409
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngDrawable.java
@@ -0,0 +1,51 @@
+package com.bumptech.glide.load.resource.apng;
+
+import android.graphics.drawable.AnimationDrawable;
+import java.util.ArrayList;
+import java.util.List;
+import net.ellerton.japng.chunks.PngFrameControl;
+import net.ellerton.japng.chunks.PngHeader;
+
+/**
+ * Created by edwin on 3/30/17.
+ */
+
+public class ApngDrawable extends AnimationDrawable {
+
+  private final List<PngFrameControl> pngFrameControlList = new ArrayList<>();
+  private final PngHeader header;
+  private int numFrames;
+  private int numPlays;
+
+  public ApngDrawable(PngHeader header) {
+    this.header = header;
+  }
+
+  public void setNumFrames(int numFrames) {
+    this.numFrames = numFrames;
+  }
+
+  public void setNumPlays(int numPlays) {
+    this.numPlays = numPlays;
+  }
+
+  public void addControll(PngFrameControl control) {
+    pngFrameControlList.add(control);
+  }
+
+  public List<PngFrameControl> getPngFrameControlList() {
+    return pngFrameControlList;
+  }
+
+  public PngHeader getHeader() {
+    return header;
+  }
+
+  public int getNumFrames() {
+    return numFrames;
+  }
+
+  public int getNumPlays() {
+    return numPlays;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngDrawableResource.java b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngDrawableResource.java
new file mode 100755
index 000000000..019ee3f04
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngDrawableResource.java
@@ -0,0 +1,42 @@
+package com.bumptech.glide.load.resource.apng;
+
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.load.engine.Initializable;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+
+/**
+ * A resource wrapping an {@link GifDrawable}.
+ */
+public class ApngDrawableResource implements Resource<ApngDrawable>, Initializable {
+
+  private final ApngDrawable apngDrawable;
+
+  public ApngDrawableResource(ApngDrawable animationDrawable) {
+    this.apngDrawable = animationDrawable;
+  }
+
+  @Override public Class<ApngDrawable> getResourceClass() {
+    return ApngDrawable.class;
+  }
+
+  @Override public ApngDrawable get() {
+    return apngDrawable;
+  }
+
+  @Override public int getSize() {
+    return 0;
+  }
+
+  @Override public void recycle() {
+    apngDrawable.stop();
+  }
+
+  @Override public void initialize() {
+    Drawable firstFrame = apngDrawable.getFrame(0);
+    if (firstFrame instanceof BitmapDrawable) {
+      ((BitmapDrawable) firstFrame).getBitmap().prepareToDraw();
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngResourceDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngResourceDecoder.java
new file mode 100755
index 000000000..b964e6fdc
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngResourceDecoder.java
@@ -0,0 +1,52 @@
+package com.bumptech.glide.load.resource.apng;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.support.annotation.Nullable;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceDecoder;
+import com.bumptech.glide.load.engine.Resource;
+import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
+import com.bumptech.glide.load.resource.gif.GifDrawable;
+import java.io.IOException;
+import java.io.InputStream;
+import net.ellerton.japng.argb8888.Argb8888Processor;
+import net.ellerton.japng.error.PngException;
+import net.ellerton.japng.reader.DefaultPngChunkReader;
+import net.ellerton.japng.reader.PngReadHelper;
+
+/**
+ * An {@link ResourceDecoder} that decodes
+ * {@link GifDrawable} from {@link InputStream} data.
+ */
+public class ApngResourceDecoder implements ResourceDecoder<InputStream, ApngDrawable> {
+
+  final Resources resources;
+  final ApngBitmapProvider apngBitmapProvider;
+
+  public ApngResourceDecoder(Context context, BitmapPool bitmapPool, ArrayPool arrayPool) {
+    this.resources = context.getResources();
+    this.apngBitmapProvider = new ApngBitmapProvider(bitmapPool, arrayPool);
+  }
+
+  @Override public boolean handles(InputStream source, Options options) throws IOException {
+    return true;
+  }
+
+  @Nullable @Override
+  public Resource<ApngDrawable> decode(InputStream source, int width, int height, Options options)
+      throws IOException {
+    ApngViewBuilder apngViewBuilder = new ApngViewBuilder(resources, apngBitmapProvider);
+    Argb8888Processor<ApngDrawable> processor = new Argb8888Processor<>(apngViewBuilder);
+    try {
+      return new ApngDrawableResource(
+          PngReadHelper.read(source, new DefaultPngChunkReader<>(processor)));
+    } catch (PngException e) {
+      e.printStackTrace();
+    } finally {
+      apngViewBuilder.clear();
+    }
+    return null;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngResourceEncoder.java b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngResourceEncoder.java
new file mode 100755
index 000000000..359992fa4
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngResourceEncoder.java
@@ -0,0 +1,166 @@
+package com.bumptech.glide.load.resource.apng;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import com.bumptech.glide.load.EncodeStrategy;
+import com.bumptech.glide.load.Options;
+import com.bumptech.glide.load.ResourceEncoder;
+import com.bumptech.glide.load.engine.Resource;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.zip.CRC32;
+import net.ellerton.japng.chunks.PngFrameControl;
+import net.ellerton.japng.chunks.PngHeader;
+
+/**
+ * An {@link ResourceEncoder} that can write
+ * {@link ApngDrawable} to cache.
+ */
+public class ApngResourceEncoder implements ResourceEncoder<ApngDrawable> {
+  private static final byte[] PNG_SIGNATURE = new byte[] { -119, 80, 78, 71, 13, 10, 26, 10 };
+  private static final int IHDR_VALUE = 'I' << 24 | 'H' << 16 | 'D' << 8 | 'R';
+  private static final int PLTE_VALUE = 'P' << 24 | 'L' << 16 | 'T' << 8 | 'E';
+  private static final int IDAT_VALUE = 'I' << 24 | 'D' << 16 | 'A' << 8 | 'T';
+  private static final int IEND_VALUE = 'I' << 24 | 'E' << 16 | 'N' << 8 | 'D';
+  private static final int gAMA_VALUE = 'g' << 24 | 'A' << 16 | 'M' << 8 | 'A';
+  private static final int bKGD_VALUE = 'b' << 24 | 'K' << 16 | 'G' << 8 | 'D';
+  private static final int tRNS_VALUE = 't' << 24 | 'R' << 16 | 'N' << 8 | 'S';
+  private static final int acTL_VALUE = 'a' << 24 | 'c' << 16 | 'T' << 8 | 'L';
+  private static final int fcTL_VALUE = 'f' << 24 | 'c' << 16 | 'T' << 8 | 'L';
+  private static final int fdAT_VALUE = 'f' << 24 | 'd' << 16 | 'A' << 8 | 'T';
+
+  private ByteBuffer makeIHDRChunk(PngHeader header) throws IOException {
+    ByteBuffer bb = ByteBuffer.allocate(28);
+    bb.putInt(13);
+    bb.putInt(IHDR_VALUE);
+    bb.putInt(header.width);
+    bb.putInt(header.height);
+    bb.put(header.bitDepth);
+    bb.putInt(header.colourType.code);
+    bb.put(header.compressionMethod);
+    bb.put(header.filterMethod);
+    bb.put(header.interlaceMethod);
+    addCRC(bb);
+    bb.flip();
+    return bb;
+  }
+
+  private ByteBuffer makeACTLChunk(int frameCount, int loopCount) throws IOException {
+    ByteBuffer bb = ByteBuffer.allocate(20);
+    bb.putInt(8);
+    bb.putInt(acTL_VALUE);
+    bb.putInt(frameCount);
+    bb.putInt(loopCount);
+    addCRC(bb);
+    bb.flip();
+    return bb;
+  }
+
+  private ByteBuffer makeFCTL(PngFrameControl pngFrameControl, int sequenceNumber)
+      throws IOException {
+    ByteBuffer bb = ByteBuffer.allocate(38);
+    bb.putInt(26);
+    bb.putInt(fcTL_VALUE);
+    bb.putInt(sequenceNumber + 1);
+    bb.putInt(pngFrameControl.width);
+    bb.putInt(pngFrameControl.height);
+    bb.putInt(pngFrameControl.xOffset);
+    bb.putInt(pngFrameControl.yOffset);
+    bb.putShort(pngFrameControl.delayNumerator);
+    bb.putShort(pngFrameControl.delayNumerator);
+    bb.put(pngFrameControl.disposeOp);
+    bb.put(pngFrameControl.blendOp);
+    addCRC(bb);
+    bb.flip();
+    return bb;
+  }
+
+  private ByteBuffer makeFDAT(BitmapDrawable drawable, int sequenceNumber) throws IOException {
+
+    ByteArrayOutputStream stream = new ByteArrayOutputStream();
+    drawable.getBitmap().compress(Bitmap.CompressFormat.PNG, 100, stream);
+    byte[] bitmapdata = stream.toByteArray();
+    stream.close();
+
+    int lenght = bitmapdata.length + 16;
+    ByteBuffer bb = ByteBuffer.allocate(lenght);
+    bb.putInt(lenght);
+    bb.putInt(fdAT_VALUE);
+    bb.putInt(sequenceNumber);
+    bb.put(bitmapdata);
+    addCRC(bb);
+    bb.flip();
+    return bb;
+  }
+
+  private ByteBuffer makeIENDChunk() {
+    final ByteBuffer bb = ByteBuffer.allocate(12);
+    bb.putInt(0);
+    bb.putInt(IEND_VALUE);
+    addCRC(bb);
+    bb.flip();
+    return bb;
+  }
+
+  private void addCRC(ByteBuffer chunkBuffer) {
+    if (chunkBuffer.remaining() != 4) {
+      throw new IllegalArgumentException();
+    }
+
+    int size = chunkBuffer.position() - 4;
+
+    if (size <= 0) throw new IllegalArgumentException();
+
+    chunkBuffer.position(4);
+    byte[] bytes = new byte[size];
+    chunkBuffer.get(bytes);
+    chunkBuffer.putInt(crc(bytes));
+  }
+
+  private int crc(byte[] buf) {
+    return crc(buf, 0, buf.length);
+  }
+
+  private int crc(byte[] buf, int off, int len) {
+    CRC32 crc = new CRC32();
+    crc.update(buf, off, len);
+    return (int) crc.getValue();
+  }
+
+  @Override public EncodeStrategy getEncodeStrategy(Options options) {
+    return EncodeStrategy.SOURCE;
+  }
+
+  @Override public boolean encode(Resource<ApngDrawable> resource, File file, Options options) {
+    ApngDrawable drawable = resource.get();
+    FileOutputStream fos = null;
+    try {
+      fos = new FileOutputStream(file);
+      fos.write(PNG_SIGNATURE.clone());
+      fos.write(makeIHDRChunk(drawable.getHeader()).array());
+      fos.write(makeACTLChunk(drawable.getNumFrames(), drawable.getNumFrames()).array());
+
+      for (int i = 0; i < drawable.getNumFrames(); ++i) {
+        Drawable frame = drawable.getFrame(i);
+        fos.write(makeFCTL(drawable.getPngFrameControlList().get(i), i).array());
+        fos.write(makeFDAT((BitmapDrawable) frame, i).array());
+      }
+
+      fos.write(makeIENDChunk().array());
+      return true;
+    } catch (IOException e) {
+      e.printStackTrace();
+    } finally {
+      try {
+        if (fos != null) fos.close();
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+    return false;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngViewBuilder.java b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngViewBuilder.java
new file mode 100644
index 000000000..a64c23c87
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/apng/ApngViewBuilder.java
@@ -0,0 +1,89 @@
+package com.bumptech.glide.load.resource.apng;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.support.annotation.ColorInt;
+import net.ellerton.japng.PngScanlineBuffer;
+import net.ellerton.japng.argb8888.Argb8888Bitmap;
+import net.ellerton.japng.argb8888.Argb8888Processors;
+import net.ellerton.japng.argb8888.Argb8888ScanlineProcessor;
+import net.ellerton.japng.argb8888.BasicArgb8888Director;
+import net.ellerton.japng.chunks.PngAnimationControl;
+import net.ellerton.japng.chunks.PngFrameControl;
+import net.ellerton.japng.chunks.PngHeader;
+import net.ellerton.japng.error.PngException;
+
+/**
+ * Able to build android Views from PNG (ARGB8888) content.
+ */
+public class ApngViewBuilder extends BasicArgb8888Director<ApngDrawable> {
+
+  private final Resources resources;
+  private PngHeader header;
+  private ApngAnimationComposer animationComposer = null;
+  private ApngBitmapProvider apngBitmapProvider;
+
+  @ColorInt private int[] mainScratch;
+  private Bitmap defaultBitmap;
+
+  public ApngViewBuilder(Resources resources, ApngBitmapProvider apngBitmapProvider) {
+    this.resources = resources;
+    this.apngBitmapProvider = apngBitmapProvider;
+  }
+
+  @Override public void receiveHeader(PngHeader header, PngScanlineBuffer buffer)
+      throws PngException {
+    this.header = header;
+    mainScratch = apngBitmapProvider.obtainIntArray(header.width * header.height);
+    Argb8888Bitmap pngBitmap = new Argb8888Bitmap(mainScratch, header.width, header.height);
+    this.scanlineProcessor = Argb8888Processors.from(header, buffer, pngBitmap);
+  }
+
+  @Override public boolean wantDefaultImage() {
+    return false;
+  }
+
+  @Override public boolean wantAnimationFrames() {
+    return true;
+  }
+
+  @Override public Argb8888ScanlineProcessor beforeDefaultImage() {
+    return scanlineProcessor;
+  }
+
+  @Override public void receiveDefaultImage(Argb8888Bitmap defaultImage) {
+    int offset = 0;
+    int stride = defaultImage.width;
+    defaultBitmap =
+        apngBitmapProvider.obtain(defaultImage.width, defaultImage.height, Bitmap.Config.ARGB_8888);
+    defaultBitmap.setPixels(defaultImage.getPixelArray(), offset, stride, 0, 0, defaultImage.width,
+        defaultImage.height);
+  }
+
+  @Override public void receiveAnimationControl(PngAnimationControl animationControl) {
+    this.animationComposer = new ApngAnimationComposer(resources, header, scanlineProcessor,
+            animationControl, apngBitmapProvider);
+  }
+
+  @Override public Argb8888ScanlineProcessor receiveFrameControl(PngFrameControl frameControl) {
+    assert (animationComposer != null);
+    return animationComposer.beginFrame(frameControl);
+  }
+
+  @Override public void receiveFrameImage(Argb8888Bitmap frameImage) {
+    assert (animationComposer != null);
+    animationComposer.completeFrame(frameImage);
+  }
+
+  @Override public ApngDrawable getResult() {
+    return animationComposer.assemble();
+  }
+
+  public void clear() {
+    apngBitmapProvider.release(mainScratch);
+    if (defaultBitmap != null) {
+      apngBitmapProvider.release(defaultBitmap);
+    }
+    animationComposer.clear();
+  }
+}
