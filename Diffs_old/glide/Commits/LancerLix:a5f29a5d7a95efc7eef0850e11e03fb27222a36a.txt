diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index c773e740f..d3fc25937 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -40,8 +40,9 @@ Labels on issues are managed by contributors, you don't have to worry about them
 *bug + enhancement: feature that doesn't work, but it's an edge case that either has a workaround or doesn't affect many users*
 
 
+[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version**%3A%0A**Integration%20libraries**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details%20/%20Repro%20steps%20/%20Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60
 [2]: https://groups.google.com/forum/#!forum/glidelibrary
 [3]: http://webchat.freenode.net/?channels=glide-library
 [4]: https://developers.google.com/open-source/cla/individual
 [5]: https://github.com/bumptech/glide
-[6]: https://help.github.com/articles/subscribing-to-conversations/
\ No newline at end of file
+[6]: https://help.github.com/articles/subscribing-to-conversations/
diff --git a/README.md b/README.md
index 44df36b80..488f9b3c1 100644
--- a/README.md
+++ b/README.md
@@ -2,6 +2,7 @@ Glide
 =====
 
 [![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide)
+[Report an issue with Glide][5]
 
 Glide is a fast and efficient open source media management and image loading framework for Android that wraps media
 decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.
diff --git a/gradle.properties b/gradle.properties
index aab6d6df7..5e382c76c 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -18,7 +18,7 @@ POM_DEVELOPER_EMAIL=judds@google.com
 
 SUPPORT_V4_VERSION=22.2.0
 SUPPORT_V7_VERSION=22.2.0
-VOLLEY_VERSION=1.0.16
+VOLLEY_VERSION=1.0.0
 OK_HTTP_VERSION=3.0.1
 # TODO: use this in library/build.gradle.
 ANDROID_GRADLE_VERSION=1.2.3
@@ -27,7 +27,7 @@ ROBOLECTRIC_GRADLE_VERSION=1.1.0
 COVERALLS_GRADLE_VERSION=2.4.0
 JUNIT_VERSION=4.12
 MOCKITO_VERSION=1.10.19
-ROBOLECTRIC_VERSION=3.0-rc3
+ROBOLECTRIC_VERSION=3.1
 MOCKWEBSERVER_VERSION=3.0.0-RC1
 TRUTH_VERSION=0.26
 
diff --git a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
index f3ca40290..b07554288 100644
--- a/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java
@@ -6,6 +6,7 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
 import com.bumptech.glide.gifencoder.AnimatedGifEncoder;
 import com.bumptech.glide.load.EncodeStrategy;
 import com.bumptech.glide.load.Option;
@@ -192,7 +193,7 @@ private GifDecoder decodeHeaders(ByteBuffer data) {
   static class Factory {
 
     public GifDecoder buildDecoder(GifDecoder.BitmapProvider bitmapProvider) {
-      return new GifDecoder(bitmapProvider);
+      return new StandardGifDecoder(bitmapProvider);
     }
 
     public GifHeaderParser buildParser() {
diff --git a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
index 8a55295e1..556f72a82 100644
--- a/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.integration.okhttp;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -69,8 +67,7 @@ public Factory(OkHttpClient client) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
     }
 
diff --git a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
index 984000a46..73d8b1167 100644
--- a/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.integration.okhttp3;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -69,8 +67,7 @@ public Factory(Call.Factory client) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new OkHttpUrlLoader(client);
     }
 
diff --git a/integration/volley/build.gradle b/integration/volley/build.gradle
index 7c9f79531..87fb1bfa3 100644
--- a/integration/volley/build.gradle
+++ b/integration/volley/build.gradle
@@ -3,7 +3,7 @@ apply plugin: 'org.robolectric'
 
 dependencies {
     compile project(':library')
-    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"
+    compile "com.android.volley:volley:${VOLLEY_VERSION}"
 
     testCompile project(":testutil")
     testCompile "com.google.truth:truth:${TRUTH_VERSION}"
diff --git a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
index a07ef442e..63ded0783 100644
--- a/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java
@@ -73,8 +73,7 @@ public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
     }
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory factory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {
       return new VolleyUrlLoader(requestQueue, requestFactory);
     }
 
diff --git a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
index cbf27f64f..f1d102ad8 100644
--- a/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
+++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java
@@ -18,6 +18,7 @@
 import com.bumptech.glide.load.data.DataFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 
diff --git a/library/build.gradle b/library/build.gradle
index bde7cf66c..0a0d891f8 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -34,6 +34,7 @@ dependencies {
 android.testOptions.unitTests.all {
     // configure max heap size of the test JVM
     maxHeapSize = '2048m'
+    jvmArgs '-XX:MaxPermSize=2048m'
 }
 
 android {
diff --git a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
index 47657e942..a0d80fdaf 100644
--- a/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java
@@ -1,5 +1,8 @@
 package com.bumptech.glide;
 
+import com.bumptech.glide.request.transition.TransitionFactory;
+import com.bumptech.glide.request.transition.ViewPropertyTransition;
+
 /**
  * Implementation of {@link TransitionOptions} that exposes only generic methods that can be applied
  * to any resource type.
@@ -10,7 +13,42 @@
 public final class GenericTransitionOptions<TranscodeType> extends
   TransitionOptions<GenericTransitionOptions<TranscodeType>, TranscodeType> {
 
+  /**
+   * Removes any existing animation put on the builder.
+   *
+   * @see GenericTransitionOptions#dontTransition()
+   */
   public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {
     return new GenericTransitionOptions<TranscodeType>().dontTransition();
   }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given view animation.
+   *
+   * @see GenericTransitionOptions#transition(int)
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      int viewAnimationId) {
+    return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);
+  }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given animator.
+   *
+   * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator)
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      ViewPropertyTransition.Animator animator) {
+    return new GenericTransitionOptions<TranscodeType>().transition(animator);
+  }
+
+  /**
+   * Returns a typed {@link GenericTransitionOptions} object that uses the given transition factory.
+   *
+   * @see GenericTransitionOptions#transition(TransitionFactory)
+   */
+  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(
+      TransitionFactory<? super TranscodeType> transitionFactory) {
+    return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/Glide.java b/library/src/main/java/com/bumptech/glide/Glide.java
index 68843d6fb..e56ce022e 100644
--- a/library/src/main/java/com/bumptech/glide/Glide.java
+++ b/library/src/main/java/com/bumptech/glide/Glide.java
@@ -12,6 +12,7 @@
 import android.os.Build;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.Nullable;
+import android.support.annotation.VisibleForTesting;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.util.Log;
@@ -162,8 +163,8 @@ public static Glide get(Context context) {
     return glide;
   }
 
-  // For testing.
-  static void tearDown() {
+  @VisibleForTesting
+  public static void tearDown() {
     glide = null;
   }
 
@@ -186,13 +187,13 @@ static void tearDown() {
     DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);
     bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);
 
-    Resources resources = context.getResources();
+    final Resources resources = context.getResources();
 
     Downsampler downsampler =
         new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);
     ByteBufferGifDecoder byteBufferGifDecoder =
         new ByteBufferGifDecoder(context, bitmapPool, arrayPool);
-    registry = new Registry(context)
+    registry = new Registry()
         .register(ByteBuffer.class, new ByteBufferEncoder())
         .register(InputStream.class, new StreamEncoder(arrayPool))
         /* Bitmaps */
@@ -229,24 +230,36 @@ static void tearDown() {
         .append(File.class, File.class, new UnitModelLoader.Factory<File>())
         /* Models */
         .register(new InputStreamRewinder.Factory(arrayPool))
-        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(int.class, ParcelFileDescriptor.class, new ResourceLoader.FileDescriptorFactory())
-        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory())
-        .append(Integer.class, ParcelFileDescriptor.class,
-            new ResourceLoader.FileDescriptorFactory())
+        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(
+                int.class,
+                ParcelFileDescriptor.class,
+                new ResourceLoader.FileDescriptorFactory(resources))
+        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources))
+        .append(
+                Integer.class,
+                ParcelFileDescriptor.class,
+                new ResourceLoader.FileDescriptorFactory(resources))
         .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory())
         .append(String.class, InputStream.class, new StringLoader.StreamFactory())
         .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
         .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
-        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new AssetUriLoader.FileDescriptorFactory())
-        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory())
-        .append(Uri.class, InputStream.class, new UriLoader.StreamFactory())
-        .append(Uri.class, ParcelFileDescriptor.class, new UriLoader.FileDescriptorFactory())
+        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))
+        .append(
+                Uri.class,
+                ParcelFileDescriptor.class,
+                new AssetUriLoader.FileDescriptorFactory(context.getAssets()))
+        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))
+        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context))
+        .append(
+            Uri.class,
+             InputStream.class,
+             new UriLoader.StreamFactory(context.getContentResolver()))
+        .append(Uri.class, ParcelFileDescriptor.class,
+             new UriLoader.FileDescriptorFactory(context.getContentResolver()))
         .append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory())
         .append(URL.class, InputStream.class, new UrlLoader.StreamFactory())
-        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory())
+        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context))
         .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
         .append(byte[].class, ByteBuffer.class, new ByteArrayLoader.ByteBufferFactory())
         .append(byte[].class, InputStream.class, new ByteArrayLoader.StreamFactory())
@@ -288,6 +301,13 @@ public ArrayPool getArrayPool() {
     return arrayPool;
   }
 
+  /**
+   * @return The context associated with this instance.
+   */
+  public Context getContext() {
+    return glideContext.getBaseContext();
+  }
+
   ConnectivityMonitorFactory getConnectivityMonitorFactory() {
     return connectivityMonitorFactory;
   }
diff --git a/library/src/main/java/com/bumptech/glide/GlideBuilder.java b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
index 445507323..f0db1051b 100644
--- a/library/src/main/java/com/bumptech/glide/GlideBuilder.java
+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java
@@ -265,6 +265,7 @@ Glide createGlide() {
     if (sourceExecutor == null) {
       sourceExecutor = GlideExecutor.newSourceExecutor();
     }
+
     if (diskCacheExecutor == null) {
       diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
     }
@@ -299,7 +300,8 @@ Glide createGlide() {
     }
 
     if (engine == null) {
-      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor);
+      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,
+          GlideExecutor.newUnlimitedSourceExecutor());
     }
 
     return new Glide(
diff --git a/library/src/main/java/com/bumptech/glide/ListPreloader.java b/library/src/main/java/com/bumptech/glide/ListPreloader.java
index fba351ea0..3614d0ca1 100644
--- a/library/src/main/java/com/bumptech/glide/ListPreloader.java
+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java
@@ -1,9 +1,6 @@
 package com.bumptech.glide;
 
-import android.app.Activity;
-import android.app.Fragment;
 import android.support.annotation.Nullable;
-import android.support.v4.app.FragmentActivity;
 import android.widget.AbsListView;
 
 import com.bumptech.glide.request.target.BaseTarget;
@@ -93,41 +90,6 @@
     int[] getPreloadSize(T item, int adapterPosition, int perItemPosition);
   }
 
-  /**
-   * Helper constructor that accepts an {@link Activity}.
-   */
-  public ListPreloader(Activity activity, PreloadModelProvider<T> preloadModelProvider,
-      PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {
-    this(Glide.with(activity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link FragmentActivity}.
-   */
-  public ListPreloader(FragmentActivity fragmentActivity,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragmentActivity), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link Fragment}.
-   */
-  public ListPreloader(Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
-  /**
-   * Helper constructor that accepts an {@link android.support.v4.app.Fragment}.
-   */
-  public ListPreloader(android.support.v4.app.Fragment fragment,
-      PreloadModelProvider<T> preloadModelProvider, PreloadSizeProvider<T> preloadDimensionProvider,
-      int maxPreload) {
-    this(Glide.with(fragment), preloadModelProvider, preloadDimensionProvider, maxPreload);
-  }
-
   /**
    * Constructor for {@link com.bumptech.glide.ListPreloader} that accepts interfaces for providing
    * the dimensions of images to preload, the list of models to preload for a given position, and
diff --git a/library/src/main/java/com/bumptech/glide/Registry.java b/library/src/main/java/com/bumptech/glide/Registry.java
index dea54a6b9..e188cc5a4 100644
--- a/library/src/main/java/com/bumptech/glide/Registry.java
+++ b/library/src/main/java/com/bumptech/glide/Registry.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
 
 import com.bumptech.glide.load.Encoder;
@@ -43,9 +42,8 @@
   private final LoadPathCache loadPathCache = new LoadPathCache();
   private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();
 
-  public Registry(Context context) {
-    this.modelLoaderRegistry =
-        new ModelLoaderRegistry(context.getApplicationContext(), exceptionListPool);
+  public Registry() {
+    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);
     this.encoderRegistry = new EncoderRegistry();
     this.decoderRegistry = new ResourceDecoderRegistry();
     this.resourceEncoderRegistry = new ResourceEncoderRegistry();
diff --git a/library/src/main/java/com/bumptech/glide/RequestManager.java b/library/src/main/java/com/bumptech/glide/RequestManager.java
index f9be9ab73..90966b7c2 100644
--- a/library/src/main/java/com/bumptech/glide/RequestManager.java
+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java
@@ -52,7 +52,7 @@
       diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW)
           .skipMemoryCache(true);
 
-  private final GlideContext context;
+  private final Glide glide;
   private final Lifecycle lifecycle;
   private final RequestTracker requestTracker;
   private final RequestManagerTreeNode treeNode;
@@ -71,18 +71,24 @@ public void run() {
   @NonNull
   private BaseRequestOptions<?> requestOptions;
 
-  public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
-    this(context, lifecycle, treeNode,
-        new RequestTracker(), Glide.get(context).getConnectivityMonitorFactory());
+  public RequestManager(Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {
+    this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory());
   }
 
-  RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,
-      RequestTracker requestTracker, ConnectivityMonitorFactory factory) {
-    this.context = Glide.get(context).getGlideContext();
+  RequestManager(
+      Glide glide,
+      Lifecycle lifecycle,
+      RequestManagerTreeNode treeNode,
+      RequestTracker requestTracker,
+      ConnectivityMonitorFactory factory) {
+    this.glide = glide;
     this.lifecycle = lifecycle;
     this.treeNode = treeNode;
     this.requestTracker = requestTracker;
 
+    final Context context = glide.getGlideContext().getBaseContext();
+
+
     connectivityMonitor =
         factory.build(context, new RequestManagerConnectivityListener(requestTracker));
 
@@ -97,10 +103,10 @@ public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNo
     }
     lifecycle.addListener(connectivityMonitor);
 
-    defaultRequestOptions = this.context.getDefaultRequestOptions();
+    defaultRequestOptions = glide.getGlideContext().getDefaultRequestOptions();
     requestOptions = defaultRequestOptions;
 
-    Glide.get(context).registerRequestManager(this);
+    glide.registerRequestManager(this);
   }
 
   /**
@@ -155,14 +161,14 @@ public RequestManager setDefaultRequestOptions(RequestOptions requestOptions) {
    * @see android.content.ComponentCallbacks2#onTrimMemory(int)
    */
   public void onTrimMemory(int level) {
-    context.onTrimMemory(level);
+    glide.getGlideContext().onTrimMemory(level);
   }
 
   /**
    * @see android.content.ComponentCallbacks2#onLowMemory()
    */
   public void onLowMemory() {
-    context.onLowMemory();
+    glide.getGlideContext().onLowMemory();
   }
 
   /**
@@ -269,7 +275,7 @@ public void onDestroy() {
     lifecycle.removeListener(this);
     lifecycle.removeListener(connectivityMonitor);
     mainHandler.removeCallbacks(addSelfToLifecycle);
-    Glide.get(context).unregisterRequestManager(this);
+    glide.unregisterRequestManager(this);
   }
 
   /**
@@ -371,7 +377,7 @@ public void onDestroy() {
    * @return A new request builder for loading the given resource class.
    */
   public <ResourceType> RequestBuilder<ResourceType> as(Class<ResourceType> resourceClass) {
-    return new RequestBuilder<>(context, this, resourceClass);
+    return new RequestBuilder<>(glide.getGlideContext(), this, resourceClass);
   }
 
   /**
@@ -416,7 +422,7 @@ public void run() {
   private void untrackOrDelegate(Target<?> target) {
     boolean isOwnedByUs = untrack(target);
     if (!isOwnedByUs) {
-      Glide.get(context).removeFromManagers(target);
+      glide.removeFromManagers(target);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
index 489892e3b..286b43a37 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.AssetFileDescriptor;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
@@ -13,8 +12,8 @@
  * Fetches an {@link android.os.ParcelFileDescriptor} for a local {@link android.net.Uri}.
  */
 public class FileDescriptorLocalUriFetcher extends LocalUriFetcher<ParcelFileDescriptor> {
-  public FileDescriptorLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  public FileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    super(contentResolver, uri);
   }
 
   @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
index d9062bb12..0f28f0932 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java
@@ -23,7 +23,6 @@
 public class HttpUrlFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "HttpUrlFetcher";
   private static final int MAXIMUM_REDIRECTS = 5;
-  private static final int DEFAULT_TIMEOUT_MS = 2500;
   // Visible for testing.
   static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
       new DefaultHttpUrlConnectionFactory();
@@ -36,8 +35,8 @@
   private InputStream stream;
   private volatile boolean isCancelled;
 
-  public HttpUrlFetcher(GlideUrl glideUrl) {
-    this(glideUrl, DEFAULT_TIMEOUT_MS, DEFAULT_CONNECTION_FACTORY);
+  public HttpUrlFetcher(GlideUrl glideUrl, int timeout) {
+    this(glideUrl, timeout, DEFAULT_CONNECTION_FACTORY);
   }
 
   // Visible for testing.
diff --git a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
index add61c095..498c70d80 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.data;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
 import android.util.Log;
 
@@ -21,25 +20,24 @@
 public abstract class LocalUriFetcher<T> implements DataFetcher<T> {
   private static final String TAG = "LocalUriFetcher";
   private final Uri uri;
-  private final Context context;
+  private final ContentResolver contentResolver;
   private T data;
 
   /**
    * Opens an input stream for a uri pointing to a local asset. Only certain uris are supported
    *
-   * @param context Any {@link android.content.Context}.
+   * @param contentResolver Any {@link android.content.ContentResolver}.
    * @param uri     A Uri pointing to a local asset. This load will fail if the uri isn't openable
    *                by {@link ContentResolver#openInputStream(android.net.Uri)}
    * @see ContentResolver#openInputStream(android.net.Uri)
    */
-  public LocalUriFetcher(Context context, Uri uri) {
-    this.context = context.getApplicationContext();
+  public LocalUriFetcher(ContentResolver contentResolver, Uri uri) {
+    this.contentResolver = contentResolver;
     this.uri = uri;
   }
 
   @Override
   public final void loadData(Priority priority, DataCallback<? super T> callback) {
-    ContentResolver contentResolver = context.getContentResolver();
     try {
       data = loadResource(uri, contentResolver);
     } catch (FileNotFoundException e) {
diff --git a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
index 0704a922a..676e58637 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java
@@ -1,8 +1,11 @@
 package com.bumptech.glide.load.data;
 
+import android.annotation.TargetApi;
 import android.content.ContentResolver;
-import android.content.Context;
+import android.content.UriMatcher;
 import android.net.Uri;
+import android.os.Build;
+import android.provider.ContactsContract;
 
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -12,20 +15,82 @@
  * Fetches an {@link java.io.InputStream} for a local {@link android.net.Uri}.
  */
 public class StreamLocalUriFetcher extends LocalUriFetcher<InputStream> {
-  public StreamLocalUriFetcher(Context context, Uri uri) {
-    super(context, uri);
+  /**
+   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537)
+   */
+  private static final int ID_CONTACTS_LOOKUP = 1;
+  /**
+   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo)
+   */
+  private static final int ID_CONTACTS_THUMBNAIL = 2;
+  /**
+   * A contact uri (e.g. content://com.android.contacts/contacts/38)
+   */
+  private static final int ID_CONTACTS_CONTACT = 3;
+  /**
+   * A contact display photo (high resolution) uri
+   * (e.g. content://com.android.contacts/5/display_photo)
+   */
+  private static final int ID_CONTACTS_PHOTO = 4;
+  /**
+   * Match the incoming Uri for special cases which we can handle nicely.
+   */
+  private static final UriMatcher URI_MATCHER;
+
+  static {
+    URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_CONTACTS_LOOKUP);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_CONTACTS_LOOKUP);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_CONTACTS_THUMBNAIL);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACTS_CONTACT);
+    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/display_photo", ID_CONTACTS_PHOTO);
+  }
+
+  public StreamLocalUriFetcher(ContentResolver resolver, Uri uri) {
+    super(resolver, uri);
   }
 
   @Override
   protected InputStream loadResource(Uri uri, ContentResolver contentResolver)
       throws FileNotFoundException {
-    InputStream inputStream = contentResolver.openInputStream(uri);
+    InputStream inputStream = loadResourceFromUri(uri, contentResolver);
     if (inputStream == null) {
-      throw new FileNotFoundException("InputStream is null for :" + uri);
+      throw new FileNotFoundException("InputStream is null for " + uri);
     }
     return inputStream;
   }
 
+
+  private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver)
+      throws FileNotFoundException {
+    switch (URI_MATCHER.match(uri)) {
+      case ID_CONTACTS_CONTACT:
+        return openContactPhotoInputStream(contentResolver, uri);
+      case ID_CONTACTS_LOOKUP:
+        // If it was a Lookup uri then resolve it first, then continue loading the contact uri.
+        uri = ContactsContract.Contacts.lookupContact(contentResolver, uri);
+        if (uri == null) {
+          throw new FileNotFoundException("Contact cannot be found");
+        }
+        return openContactPhotoInputStream(contentResolver, uri);
+      case ID_CONTACTS_THUMBNAIL:
+      case ID_CONTACTS_PHOTO:
+      case UriMatcher.NO_MATCH:
+      default:
+        return contentResolver.openInputStream(uri);
+    }
+  }
+
+  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+  private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {
+    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+      return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri);
+    } else {
+      return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,
+          true /*preferHighres*/);
+    }
+  }
+
   @Override
   protected void close(InputStream data) throws IOException {
     data.close();
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
index e5e67fdd7..6fa7ffe17 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java
@@ -1,5 +1,6 @@
 package com.bumptech.glide.load.data.mediastore;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
@@ -21,29 +22,31 @@
  * A {@link DataFetcher} implementation for {@link InputStream}s that loads data from thumbnail
  * files obtained from the {@link MediaStore}.
  */
+@SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass")
 public class ThumbFetcher implements DataFetcher<InputStream> {
   private static final String TAG = "MediaStoreThumbFetcher";
-  private final Context context;
   private final Uri mediaStoreImageUri;
   private final ThumbnailStreamOpener opener;
   private InputStream inputStream;
 
+  // TODO(nnaze): These build methods do not need the full Glide or Context objects.
+
   public static ThumbFetcher buildImageFetcher(Context context, Uri uri) {
-    return build(context, uri, new ImageThumbnailQuery());
+    return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));
   }
 
   public static ThumbFetcher buildVideoFetcher(Context context, Uri uri) {
-    return build(context, uri, new VideoThumbnailQuery());
+    return build(context, uri, new VideoThumbnailQuery(context.getContentResolver()));
   }
 
   private static ThumbFetcher build(Context context, Uri uri, ThumbnailQuery query) {
     ArrayPool byteArrayPool = Glide.get(context).getArrayPool();
-    return new ThumbFetcher(context, uri, new ThumbnailStreamOpener(query, byteArrayPool));
+    return new ThumbFetcher(
+        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));
   }
 
   // Visible for testing.
-  ThumbFetcher(Context context, Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
-    this.context = context;
+  ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {
     this.mediaStoreImageUri = mediaStoreImageUri;
     this.opener = opener;
   }
@@ -64,11 +67,11 @@ public void loadData(Priority priority, DataCallback<? super InputStream> callba
   }
 
   private InputStream openThumbInputStream() throws FileNotFoundException {
-    InputStream result = opener.open(context, mediaStoreImageUri);
+    InputStream result = opener.open(mediaStoreImageUri);
 
     int orientation = -1;
     if (result != null) {
-      orientation = opener.getOrientation(context, mediaStoreImageUri);
+      orientation = opener.getOrientation(mediaStoreImageUri);
     }
 
     if (orientation != -1) {
@@ -104,6 +107,13 @@ public DataSource getDataSource() {
   }
 
   static class VideoThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    VideoThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
       MediaStore.Video.Thumbnails.DATA
     };
@@ -112,19 +122,26 @@ public DataSource getDataSource() {
         + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String videoId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { videoId },
+          new String[] {videoId},
           null /*sortOrder*/);
     }
   }
 
 
   static class ImageThumbnailQuery implements ThumbnailQuery {
+
+    private final ContentResolver contentResolver;
+
+    ImageThumbnailQuery(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     private static final String[] PATH_PROJECTION = {
       MediaStore.Images.Thumbnails.DATA,
     };
@@ -133,13 +150,13 @@ public Cursor query(Context context, Uri uri) {
         + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";
 
     @Override
-    public Cursor query(Context context, Uri uri) {
+    public Cursor query(Uri uri) {
       String imageId = uri.getLastPathSegment();
-      return context.getContentResolver().query(
+      return contentResolver.query(
           MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,
           PATH_PROJECTION,
           PATH_SELECTION,
-          new String[] { imageId },
+          new String[] {imageId},
           null /*sortOrder*/);
     }
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
index befebff43..07474cd13 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java
@@ -1,9 +1,8 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
 
 interface ThumbnailQuery {
-  Cursor query(Context context, Uri uri);
+  Cursor query(Uri uri);
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
index e6cfbc23f..a96f27006 100644
--- a/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java
@@ -1,6 +1,6 @@
 package com.bumptech.glide.load.data.mediastore;
 
-import android.content.Context;
+import android.content.ContentResolver;
 import android.database.Cursor;
 import android.net.Uri;
 import android.text.TextUtils;
@@ -20,23 +20,29 @@
   private final FileService service;
   private final ThumbnailQuery query;
   private final ArrayPool byteArrayPool;
+  private final ContentResolver contentResolver;
 
-  public ThumbnailStreamOpener(ThumbnailQuery query, ArrayPool byteArrayPool) {
-    this(DEFAULT_SERVICE, query, byteArrayPool);
+  public ThumbnailStreamOpener(
+      ThumbnailQuery query, ArrayPool byteArrayPool, ContentResolver contentResolver) {
+    this(DEFAULT_SERVICE, query, byteArrayPool, contentResolver);
   }
 
-  public ThumbnailStreamOpener(FileService service, ThumbnailQuery query,
-      ArrayPool byteArrayPool) {
+  public ThumbnailStreamOpener(
+      FileService service,
+      ThumbnailQuery query,
+      ArrayPool byteArrayPool,
+      ContentResolver contentResolver) {
     this.service = service;
     this.query = query;
     this.byteArrayPool = byteArrayPool;
+    this.contentResolver = contentResolver;
   }
 
-  public int getOrientation(Context context, Uri uri) {
+  public int getOrientation(Uri uri) {
     int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;
     InputStream is = null;
     try {
-      is = context.getContentResolver().openInputStream(uri);
+      is = contentResolver.openInputStream(uri);
       orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();
     } catch (IOException e) {
       if (Log.isLoggable(TAG, Log.DEBUG)) {
@@ -54,11 +60,11 @@ public int getOrientation(Context context, Uri uri) {
     return orientation;
   }
 
-  public InputStream open(Context context, Uri uri) throws FileNotFoundException {
+  public InputStream open(Uri uri) throws FileNotFoundException {
     Uri thumbnailUri = null;
     InputStream inputStream = null;
 
-    final Cursor cursor = query.query(context, uri);
+    final Cursor cursor = query.query(uri);
     try {
       if (cursor == null || !cursor.moveToFirst()) {
         return null;
@@ -78,7 +84,7 @@ public InputStream open(Context context, Uri uri) throws FileNotFoundException {
       }
     }
     if (thumbnailUri != null) {
-      inputStream = context.getContentResolver().openInputStream(thumbnailUri);
+      inputStream = contentResolver.openInputStream(thumbnailUri);
     }
     return inputStream;
   }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
index 3d1e3133e..377524e0d 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java
@@ -64,16 +64,18 @@ public void cancel() {
   }
 
   public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
-      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor) {
-    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, null, null, null, null,
-        null, null);
+      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor) {
+    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
+        null, null, null, null, null, null);
   }
 
   // Visible for testing.
   Engine(MemoryCache cache, DiskCache.Factory diskCacheFactory, GlideExecutor diskCacheExecutor,
-      GlideExecutor sourceExecutor, Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,
-      Map<Key, WeakReference<EngineResource<?>>> activeResources, EngineJobFactory engineJobFactory,
-      DecodeJobFactory decodeJobFactory, ResourceRecycler resourceRecycler) {
+      GlideExecutor sourceExecutor, GlideExecutor sourceUnlimitedExecutor, Map<Key, EngineJob> jobs,
+      EngineKeyFactory keyFactory, Map<Key, WeakReference<EngineResource<?>>> activeResources,
+      EngineJobFactory engineJobFactory, DecodeJobFactory decodeJobFactory,
+      ResourceRecycler resourceRecycler) {
     this.cache = cache;
     this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);
 
@@ -93,7 +95,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
     this.jobs = jobs;
 
     if (engineJobFactory == null) {
-      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor, this);
+      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor,
+          sourceUnlimitedExecutor, this);
     }
     this.engineJobFactory = engineJobFactory;
 
@@ -143,6 +146,7 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       boolean isTransformationRequired,
       Options options,
       boolean isMemoryCacheable,
+      boolean useUnlimitedSourceExecutorPool,
       ResourceCallback cb) {
     Util.assertMainThread();
     long startTime = LogTime.getLogTime();
@@ -177,7 +181,8 @@ public Engine(MemoryCache memoryCache, DiskCache.Factory diskCacheFactory,
       return new LoadStatus(cb, current);
     }
 
-    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable);
+    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,
+        useUnlimitedSourceExecutorPool);
     DecodeJob<R> decodeJob = decodeJobFactory.build(
         glideContext,
         model,
@@ -432,26 +437,30 @@ public boolean queueIdle() {
   static class EngineJobFactory {
     private final GlideExecutor diskCacheExecutor;
     private final GlideExecutor sourceExecutor;
+    private final GlideExecutor sourceUnlimitedExecutor;
     private final EngineJobListener listener;
     private final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,
         new FactoryPools.Factory<EngineJob<?>>() {
           @Override
           public EngineJob<?> create() {
-            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, listener, pool);
+            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,
+                listener, pool);
           }
         });
 
     EngineJobFactory(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
-        EngineJobListener listener) {
+        GlideExecutor sourceUnlimitedExecutor, EngineJobListener listener) {
       this.diskCacheExecutor = diskCacheExecutor;
       this.sourceExecutor = sourceExecutor;
+      this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
       this.listener = listener;
     }
 
     @SuppressWarnings("unchecked")
-    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable) {
+    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,
+        boolean useUnlimitedSourceGeneratorPool) {
       EngineJob<R> result = (EngineJob<R>) pool.acquire();
-      return result.init(key, isMemoryCacheable);
+      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool);
     }
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
index c58965ca1..36c997b22 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java
@@ -39,9 +39,11 @@
   private final EngineJobListener listener;
   private final GlideExecutor diskCacheExecutor;
   private final GlideExecutor sourceExecutor;
+  private final GlideExecutor sourceUnlimitedExecutor;
 
   private Key key;
   private boolean isCacheable;
+  private boolean useUnlimitedSourceGeneratorPool;
   private Resource<?> resource;
   private DataSource dataSource;
   private boolean hasResource;
@@ -57,31 +59,38 @@
   private volatile boolean isCancelled;
 
   EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
       EngineJobListener listener, Pools.Pool<EngineJob<?>> pool) {
-    this(diskCacheExecutor, sourceExecutor, listener, pool, DEFAULT_FACTORY);
+    this(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, listener, pool,
+        DEFAULT_FACTORY);
   }
 
   // Visible for testing.
   EngineJob(GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,
+      GlideExecutor sourceUnlimitedExecutor,
       EngineJobListener listener, Pools.Pool<EngineJob<?>> pool,
       EngineResourceFactory engineResourceFactory) {
     this.diskCacheExecutor = diskCacheExecutor;
     this.sourceExecutor = sourceExecutor;
+    this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;
     this.listener = listener;
     this.pool = pool;
     this.engineResourceFactory = engineResourceFactory;
   }
 
   // Visible for testing.
-  EngineJob<R> init(Key key, boolean isCacheable) {
+  EngineJob<R> init(Key key, boolean isCacheable, boolean useUnlimitedSourceGeneratorPool) {
     this.key = key;
     this.isCacheable = isCacheable;
+    this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;
     return this;
   }
 
   public void start(DecodeJob<R> decodeJob) {
     this.decodeJob = decodeJob;
-    GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : sourceExecutor;
+    GlideExecutor executor = decodeJob.willDecodeFromCache()
+        ? diskCacheExecutor
+        : getActiveSourceExecutor();
     executor.execute(decodeJob);
   }
 
@@ -110,6 +119,10 @@ public void removeCallback(ResourceCallback cb) {
     }
   }
 
+  private GlideExecutor getActiveSourceExecutor() {
+    return useUnlimitedSourceGeneratorPool ? sourceUnlimitedExecutor : sourceExecutor;
+  }
+
   // We cannot remove callbacks while notifying our list of callbacks directly because doing so
   // would cause a ConcurrentModificationException. However, we need to obey the cancellation
   // request such that if notifying a callback early in the callbacks list cancels a callback later
@@ -136,8 +149,9 @@ void cancel() {
 
     isCancelled = true;
     decodeJob.cancel();
-    boolean isPendingJobRemoved =
-        diskCacheExecutor.remove(decodeJob) || sourceExecutor.remove(decodeJob);
+    boolean isPendingJobRemoved = diskCacheExecutor.remove(decodeJob)
+        || sourceExecutor.remove(decodeJob)
+        || sourceUnlimitedExecutor.remove(decodeJob);
     listener.onEngineJobCancelled(this, key);
 
     if (isPendingJobRemoved) {
@@ -227,7 +241,7 @@ public void reschedule(DecodeJob<?> job) {
     if (isCancelled) {
       MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();
     } else {
-      sourceExecutor.execute(job);
+      getActiveSourceExecutor().execute(job);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
index 072aa25fd..5bb30cd51 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java
@@ -52,7 +52,8 @@ public LruArrayPool(int maxSize) {
   public synchronized <T> void put(T array, Class<T> arrayClass) {
     ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);
     int size = arrayAdapter.getArrayLength(array);
-    if (!isSmallEnoughForReuse(size)) {
+    int arrayBytes = size * arrayAdapter.getElementSizeInBytes();
+    if (!isSmallEnoughForReuse(arrayBytes)) {
       return;
     }
     Key key = keyPool.get(size, arrayClass);
@@ -61,7 +62,7 @@ public LruArrayPool(int maxSize) {
     NavigableMap<Integer, Integer> sizes = getSizesForAdapter(arrayClass);
     Integer current = sizes.get(key.size);
     sizes.put(key.size, current == null ? 1 : current + 1);
-    currentSize += size * arrayAdapter.getElementSizeInBytes();
+    currentSize += arrayBytes;
     evict();
   }
 
@@ -102,8 +103,8 @@ public LruArrayPool(int maxSize) {
     return (T) groupedMap.get(key);
   }
 
-  private boolean isSmallEnoughForReuse(int intSize) {
-    return intSize <= maxSize / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
+  private boolean isSmallEnoughForReuse(int byteSize) {
+    return byteSize <= maxSize / SINGLE_ARRAY_MAX_SIZE_DIVISOR;
   }
 
   private boolean mayFillRequest(int requestedSize, Integer actualSize) {
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
index dd970fb84..270b22013 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java
@@ -7,10 +7,12 @@
 
 import java.io.File;
 import java.io.FilenameFilter;
+import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.PriorityBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -44,6 +46,17 @@
   private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;
   private final boolean executeSynchronously;
 
+  /**
+   * The default thread name prefix for executors from unlimited thread pool used to
+   * load/decode/transform data not found in cache.
+   */
+  private static final String SOURCE_UNLIMITED_EXECUTOR_NAME = "source-unlimited";
+  /**
+   * The default keep alive time for threads in source unlimited executor pool in milliseconds.
+   */
+  private static final long SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS =
+      TimeUnit.SECONDS.toMillis(10);
+
   /**
    * Returns a new fixed thread pool with the default thread count returned from
    * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name
@@ -108,16 +121,68 @@ public static GlideExecutor newSourceExecutor(int threadCount, String name,
         false /*preventNetworkOperations*/, false /*executeSynchronously*/);
   }
 
+  /**
+   * Returns a new unlimited thread pool with zero core thread count to make sure no threads are
+   * created by default, {@link #SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS} keep alive
+   * time, the {@link #SOURCE_UNLIMITED_EXECUTOR_NAME} thread name prefix, the
+   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}
+   * uncaught throwable strategy, and the {@link SynchronousQueue} since using default unbounded
+   * blocking queue, for example, {@link PriorityBlockingQueue} effectively won't create more than
+   * {@code corePoolSize} threads.
+   * See <a href=
+   * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">
+   * ThreadPoolExecutor documentation</a>.
+   *
+   * <p>Source executors allow network operations on their threads.
+   */
+  public static GlideExecutor newUnlimitedSourceExecutor() {
+    return new GlideExecutor(0 /* corePoolSize */,
+        Integer.MAX_VALUE /* maximumPoolSize */,
+        SOURCE_UNLIMITED_EXECUTOR_KEEP_ALIVE_TIME_MS,
+        SOURCE_UNLIMITED_EXECUTOR_NAME,
+        UncaughtThrowableStrategy.DEFAULT,
+        false /*preventNetworkOperations*/,
+        false /*executeSynchronously*/,
+        new SynchronousQueue<Runnable>());
+  }
+
   // Visible for testing.
   GlideExecutor(int poolSize, String name,
       UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
       boolean executeSynchronously) {
+    this(
+        poolSize /* corePoolSize */,
+        poolSize /* maximumPoolSize */,
+        0 /* keepAliveTimeInMs */,
+        name,
+        uncaughtThrowableStrategy,
+        preventNetworkOperations,
+        executeSynchronously);
+  }
+
+  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously) {
+    this(
+        corePoolSize,
+        maximumPoolSize,
+        keepAliveTimeInMs,
+        name,
+        uncaughtThrowableStrategy,
+        preventNetworkOperations,
+        executeSynchronously,
+        new PriorityBlockingQueue<Runnable>());
+  }
+
+  GlideExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTimeInMs, String name,
+      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,
+      boolean executeSynchronously, BlockingQueue<Runnable> queue) {
     super(
-        poolSize /*corePoolSize*/,
-        poolSize /*maximumPoolSize*/,
-        0 /*keepAliveTime*/,
+        corePoolSize,
+        maximumPoolSize,
+        keepAliveTimeInMs,
         TimeUnit.MILLISECONDS,
-        new PriorityBlockingQueue<Runnable>(),
+        queue,
         new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));
     this.executeSynchronously = executeSynchronously;
   }
@@ -139,10 +204,21 @@ public void execute(Runnable command) {
 
   private <T> Future<T> maybeWait(Future<T> future) {
     if (executeSynchronously) {
-        try {
-        future.get();
-      } catch (InterruptedException | ExecutionException e) {
-        throw new RuntimeException(e);
+      boolean interrupted = false;
+      try {
+        while (!future.isDone()) {
+          try {
+            future.get();
+          } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+          } catch (InterruptedException e) {
+            interrupted = true;
+          }
+        }
+      } finally {
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
       }
     }
     return future;
@@ -230,7 +306,7 @@ protected void handle(Throwable t) {
   }
 
   /**
-   * A {@link java.util.concurrent.ThreadFactory} that builds threads with priority {@link
+   * A {@link java.util.concurrent.ThreadFactory} that builds threads slightly above priority {@link
    * android.os.Process#THREAD_PRIORITY_BACKGROUND}.
    */
   private static final class DefaultThreadFactory implements ThreadFactory {
@@ -251,7 +327,9 @@ public synchronized Thread newThread(@NonNull Runnable runnable) {
       final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {
         @Override
         public void run() {
-          android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+          android.os.Process.setThreadPriority(
+              android.os.Process.THREAD_PRIORITY_BACKGROUND
+              + android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE);
           if (preventNetworkOperations) {
             StrictMode.setThreadPolicy(
                 new ThreadPolicy.Builder()
diff --git a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
index baa57e8c9..1e15874b5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
@@ -61,10 +60,15 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       AssetFetcherFactory<InputStream> {
 
+    private final AssetManager assetManager;
+
+    public StreamFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
@@ -85,10 +89,15 @@ public void teardown() {
       ParcelFileDescriptor>,
       AssetFetcherFactory<ParcelFileDescriptor> {
 
+    private final AssetManager assetManager;
+
+    public FileDescriptorFactory(AssetManager assetManager) {
+      this.assetManager = assetManager;
+    }
+
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new AssetUriLoader<>(context.getAssets(), this);
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new AssetUriLoader<>(assetManager, this);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
index 52683e37d..45279ed3d 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -90,8 +88,7 @@ public DataSource getDataSource() {
   public static class ByteBufferFactory implements ModelLoaderFactory<byte[], ByteBuffer> {
 
     @Override
-    public ModelLoader<byte[], ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<ByteBuffer>() {
         @Override
         public ByteBuffer convert(byte[] model) {
@@ -117,8 +114,7 @@ public void teardown() {
   public static class StreamFactory implements ModelLoaderFactory<byte[], InputStream> {
 
     @Override
-    public ModelLoader<byte[], InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<byte[], InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new ByteArrayLoader<>(new Converter<InputStream>() {
         @Override
         public InputStream convert(byte[] model) {
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
index febd8bc1b..4e717d5ef 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ByteBufferFileLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.util.Log;
 
 import com.bumptech.glide.Priority;
@@ -37,8 +36,7 @@ public boolean handles(File file) {
   public static class Factory implements ModelLoaderFactory<File, ByteBuffer> {
 
     @Override
-    public ModelLoader<File, ByteBuffer> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<File, ByteBuffer> build(MultiModelLoaderFactory multiFactory) {
       return new ByteBufferFileLoader();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
index 1a105edde..aeff27aeb 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.util.Base64;
 
 import com.bumptech.glide.Priority;
@@ -148,8 +147,7 @@ public void close(InputStream inputStream) throws IOException {
     }
 
     @Override
-    public final ModelLoader<String, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new DataUrlLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
index e917a8f8b..370f10c0a 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/FileLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.os.ParcelFileDescriptor;
 import android.util.Log;
 
@@ -115,8 +114,7 @@ public Factory(FileOpener<Data> opener) {
     }
 
     @Override
-    public final ModelLoader<File, Data> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public final ModelLoader<File, Data> build(MultiModelLoaderFactory multiFactory) {
       return new FileLoader<>(opener);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
index 91cd2ebb1..e41d4f13c 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java
@@ -37,6 +37,8 @@
   @Nullable private URL safeUrl;
   @Nullable private volatile byte[] cacheKeyBytes;
 
+  private int hashCode;
+
   public GlideUrl(URL url) {
     this(url, Headers.DEFAULT);
   }
@@ -141,8 +143,10 @@ public boolean equals(Object o) {
 
   @Override
   public int hashCode() {
-    int hashCode = getCacheKey().hashCode();
-    hashCode = 31 * hashCode + headers.hashCode();
+    if (hashCode == 0) {
+      hashCode = getCacheKey().hashCode();
+      hashCode = 31 * hashCode + headers.hashCode();
+    }
     return hashCode;
   }
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
index ac81aa270..4e0b98081 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java
@@ -99,8 +99,14 @@ public DataSource getDataSource() {
    */
   public static final class Factory implements ModelLoaderFactory<Uri, File> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, File> build(Context context, MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, File> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreFileLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
index c3813f9ad..19e126019 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java
@@ -18,13 +18,11 @@
   /**
    * Build a concrete ModelLoader for this model type.
    *
-   * @param context      A context that cannot be retained by the factory but can be retained by the
-   *                     {@link ModelLoader}
    * @param multiFactory A map of classes to factories that can be used to construct additional
    *                     {@link ModelLoader}s that this factory's {@link ModelLoader} may depend on
    * @return A new {@link ModelLoader}
    */
-  ModelLoader<T, Y> build(Context context, MultiModelLoaderFactory multiFactory);
+  ModelLoader<T, Y> build(MultiModelLoaderFactory multiFactory);
 
   /**
    * A lifecycle method that will be called when this factory is about to replaced.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
index bf3ffbab4..dacf01427 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
 
 import java.util.ArrayList;
@@ -18,8 +17,8 @@
   private final MultiModelLoaderFactory multiModelLoaderFactory;
   private final ModelLoaderCache cache = new ModelLoaderCache();
 
-  public ModelLoaderRegistry(Context context, Pool<List<Exception>> exceptionListPool) {
-    this(new MultiModelLoaderFactory(context, exceptionListPool));
+  public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {
+    this(new MultiModelLoaderFactory(exceptionListPool));
   }
 
   // Visible for testing.
diff --git a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
index 3948b6736..8596436ea 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.support.annotation.Nullable;
 import android.support.v4.util.Pools.Pool;
 
@@ -22,20 +21,18 @@
   private static final Factory DEFAULT_FACTORY = new Factory();
   private static final ModelLoader<Object, Object> EMPTY_MODEL_LOADER = new EmptyModelLoader();
   private final List<Entry<?, ?>> entries = new ArrayList<>();
-  private final Context context;
   private final Factory factory;
   private final Set<Entry<?, ?>> alreadyUsedEntries = new HashSet<>();
   private final Pool<List<Exception>> exceptionListPool;
 
-  public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool) {
-    this(context, exceptionListPool, DEFAULT_FACTORY);
+  public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {
+    this(exceptionListPool, DEFAULT_FACTORY);
   }
 
   // Visible for testing.
-  MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionListPool,
+  MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool,
       Factory factory) {
     this.exceptionListPool = exceptionListPool;
-    this.context = context.getApplicationContext();
     this.factory = factory;
   }
 
@@ -158,8 +155,7 @@ public MultiModelLoaderFactory(Context context, Pool<List<Exception>> exceptionL
 
   @SuppressWarnings("unchecked")
   private <Model, Data> ModelLoader<Model, Data> build(Entry<?, ?> entry) {
-    return (ModelLoader<Model, Data>) Preconditions
-        .checkNotNull(entry.factory.build(context, this));
+    return (ModelLoader<Model, Data>) Preconditions.checkNotNull(entry.factory.build(this));
   }
 
   @SuppressWarnings("unchecked")
diff --git a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
index 8c420ae9f..bda92f708 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
@@ -23,10 +22,6 @@
   private final ModelLoader<Uri, Data> uriLoader;
   private final Resources resources;
 
-  public ResourceLoader(Context context, ModelLoader<Uri, Data> uriLoader) {
-    this(context.getResources(), uriLoader);
-  }
-
   public ResourceLoader(Resources resources, ModelLoader<Uri, Data> uriLoader) {
     this.resources = resources;
     this.uriLoader = uriLoader;
@@ -65,10 +60,15 @@ public boolean handles(Integer model) {
    */
   public static class StreamFactory implements ModelLoaderFactory<Integer, InputStream> {
 
+    private final Resources resources;
+
+    public StreamFactory(Resources resources) {
+      this.resources = resources;
+    }
+
     @Override
-    public ModelLoader<Integer, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context, multiFactory.build(Uri.class, InputStream.class));
+    public ModelLoader<Integer, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(resources, multiFactory.build(Uri.class, InputStream.class));
     }
 
     @Override
@@ -83,11 +83,16 @@ public void teardown() {
   public static class FileDescriptorFactory
       implements ModelLoaderFactory<Integer, ParcelFileDescriptor> {
 
+    private final Resources resources;
+
+    public FileDescriptorFactory(Resources resources) {
+      this.resources = resources;
+    }
+
     @Override
-    public ModelLoader<Integer, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new ResourceLoader<>(context,
-          multiFactory.build(Uri.class, ParcelFileDescriptor.class));
+    public ModelLoader<Integer, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new ResourceLoader<>(
+          resources, multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
index 5f878b1c5..9863fdc7b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/StringLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.Nullable;
@@ -63,8 +62,7 @@ private static Uri toFileUri(String path) {
   public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {
 
     @Override
-    public ModelLoader<String, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
     }
 
@@ -81,8 +79,7 @@ public void teardown() {
       implements ModelLoaderFactory<String, ParcelFileDescriptor> {
 
     @Override
-    public ModelLoader<String, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<String, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
       return new StringLoader<>(multiFactory.build(Uri.class, ParcelFileDescriptor.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
index e93e41371..198f01bfa 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
-
 import com.bumptech.glide.Priority;
 import com.bumptech.glide.load.DataSource;
 import com.bumptech.glide.load.Options;
@@ -70,8 +68,7 @@ public DataSource getDataSource() {
   public static class Factory<Model> implements ModelLoaderFactory<Model, Model> {
 
     @Override
-    public ModelLoader<Model, Model> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Model, Model> build(MultiModelLoaderFactory multiFactory) {
       return new UnitModelLoader<>();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
index d6a66a163..8eaff09ca 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java
@@ -1,7 +1,6 @@
 package com.bumptech.glide.load.model;
 
 import android.content.ContentResolver;
-import android.content.Context;
 import android.net.Uri;
 import android.os.ParcelFileDescriptor;
 
@@ -36,18 +35,16 @@
       )
   );
 
-  private final Context context;
   private final LocalUriFetcherFactory<Data> factory;
 
-  public UriLoader(Context context, LocalUriFetcherFactory<Data> factory) {
-    this.context = context;
+  public UriLoader(LocalUriFetcherFactory<Data> factory) {
     this.factory = factory;
   }
 
   @Override
   public LoadData<Data> buildLoadData(Uri model, int width, int height,
       Options options) {
-    return new LoadData<>(new ObjectKey(model), factory.build(context, model));
+    return new LoadData<>(new ObjectKey(model), factory.build(model));
   }
 
   @Override
@@ -61,7 +58,7 @@ public boolean handles(Uri model) {
    * @param <Data> The type of data the returned {@link DataFetcher} will obtain.
    */
   public interface LocalUriFetcherFactory<Data> {
-    DataFetcher<Data> build(Context context, Uri uri);
+    DataFetcher<Data> build(Uri uri);
   }
 
   /**
@@ -70,15 +67,20 @@ public boolean handles(Uri model) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream>,
       LocalUriFetcherFactory<InputStream> {
 
+    private final ContentResolver contentResolver;
+
+    public StreamFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     @Override
-    public DataFetcher<InputStream> build(Context context, Uri uri) {
-      return new StreamLocalUriFetcher(context, uri);
+    public DataFetcher<InputStream> build(Uri uri) {
+      return new StreamLocalUriFetcher(contentResolver, uri);
     }
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
@@ -94,15 +96,20 @@ public void teardown() {
       ParcelFileDescriptor>,
       LocalUriFetcherFactory<ParcelFileDescriptor> {
 
+    private final ContentResolver contentResolver;
+
+    public FileDescriptorFactory(ContentResolver contentResolver) {
+      this.contentResolver = contentResolver;
+    }
+
     @Override
-    public DataFetcher<ParcelFileDescriptor> build(Context context, Uri uri) {
-      return new FileDescriptorLocalUriFetcher(context, uri);
+    public DataFetcher<ParcelFileDescriptor> build(Uri uri) {
+      return new FileDescriptorLocalUriFetcher(contentResolver, uri);
     }
 
     @Override
-    public ModelLoader<Uri, ParcelFileDescriptor> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
-      return new UriLoader<>(context, this);
+    public ModelLoader<Uri, ParcelFileDescriptor> build(MultiModelLoaderFactory multiFactory) {
+      return new UriLoader<>(this);
     }
 
     @Override
diff --git a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
index f71d7e789..c957b8388 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/UrlUriLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model;
 
-import android.content.Context;
 import android.net.Uri;
 
 import com.bumptech.glide.load.Options;
@@ -50,8 +49,7 @@ public boolean handles(Uri uri) {
   public static class StreamFactory implements ModelLoaderFactory<Uri, InputStream> {
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlUriLoader<>(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
index a42d2ca14..189e79e20 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoader.java
@@ -1,8 +1,8 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
 import android.support.annotation.Nullable;
 
+import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.data.HttpUrlFetcher;
 import com.bumptech.glide.load.model.GlideUrl;
@@ -18,6 +18,15 @@
  * com.bumptech.glide.load.model.GlideUrl} (http/https URLS) into {@link java.io.InputStream} data.
  */
 public class HttpGlideUrlLoader implements ModelLoader<GlideUrl, InputStream> {
+  /**
+   * An integer option that is used to determine the maximum connect and read timeout durations (in
+   * milliseconds) for network connections.
+   *
+   * <p>Defaults to 2500ms.
+   */
+  public static final Option<Integer> TIMEOUT = Option.memory(
+      "com.bumptech.glide.load.model.stream.HttpGlideUrlLoader.Timeout", 2500);
+
   @Nullable private final ModelCache<GlideUrl, GlideUrl> modelCache;
 
   public HttpGlideUrlLoader() {
@@ -41,7 +50,8 @@ public HttpGlideUrlLoader(ModelCache<GlideUrl, GlideUrl> modelCache) {
         url = model;
       }
     }
-    return new LoadData<>(url, new HttpUrlFetcher(url));
+    int timeout = options.get(TIMEOUT);
+    return new LoadData<>(url, new HttpUrlFetcher(url, timeout));
   }
 
   @Override
@@ -56,8 +66,7 @@ public boolean handles(GlideUrl model) {
     private final ModelCache<GlideUrl, GlideUrl> modelCache = new ModelCache<>(500);
 
     @Override
-    public ModelLoader<GlideUrl, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpGlideUrlLoader(modelCache);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
index e3f11a6f4..a0638f0b5 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/HttpUriLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
 import android.net.Uri;
 
 import com.bumptech.glide.load.Options;
@@ -44,8 +43,7 @@ public boolean handles(Uri model) {
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
index 635d8c131..672aae25f 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreImageThumbLoader.java
@@ -43,9 +43,14 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreImageThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
index 1ab758391..cfda8463b 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/MediaStoreVideoThumbLoader.java
@@ -35,6 +35,7 @@
   @Nullable
   public LoadData<InputStream> buildLoadData(Uri model, int width, int height, Options options) {
     if (MediaStoreUtil.isThumbnailSize(width, height) && isRequestingDefaultFrame(options)) {
+      // TODO(nnaze): Tighten down this call to just the dependencies neede by buildVideoFetcher
       return new LoadData<>(new ObjectKey(model), ThumbFetcher.buildVideoFetcher(context, model));
     } else {
       return null;
@@ -57,9 +58,14 @@ public boolean handles(Uri model) {
    */
   public static class Factory implements ModelLoaderFactory<Uri, InputStream> {
 
+    private final Context context;
+
+    public Factory(Context context) {
+      this.context = context;
+    }
+
     @Override
-    public ModelLoader<Uri, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Uri, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new MediaStoreVideoThumbLoader(context);
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
index 5cbda7216..76bb9a227 100644
--- a/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/model/stream/UrlLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.load.model.stream;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -40,8 +38,7 @@ public boolean handles(URL model) {
   public static class StreamFactory implements ModelLoaderFactory<URL, InputStream> {
 
     @Override
-    public ModelLoader<URL, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<URL, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new UrlLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
new file mode 100644
index 000000000..c2e0533c1
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java
@@ -0,0 +1,144 @@
+package com.bumptech.glide.load.resource.bitmap;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+
+import com.bumptech.glide.TransitionOptions;
+import com.bumptech.glide.request.transition.BitmapTransitionFactory;
+import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
+import com.bumptech.glide.request.transition.TransitionFactory;
+
+/**
+ * Contains {@link Bitmap} specific animation options.
+ */
+public final class BitmapTransitionOptions extends
+    TransitionOptions<BitmapTransitionOptions, Bitmap> {
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade()
+   */
+  public static BitmapTransitionOptions withCrossFade() {
+    return new BitmapTransitionOptions().crossFade();
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int)
+   */
+  public static BitmapTransitionOptions withCrossFade(int duration) {
+    return new BitmapTransitionOptions().crossFade(duration);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int, int)
+   */
+  public static BitmapTransitionOptions withCrossFade(int animationId, int duration) {
+    return new BitmapTransitionOptions().crossFade(animationId, duration);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory)
+   */
+  public static BitmapTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return new BitmapTransitionOptions().crossFade(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory.Builder)
+   */
+  public static BitmapTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory.Builder builder) {
+    return new BitmapTransitionOptions().crossFade(builder);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that enables a any animation
+   * that is possible on drawables.
+   *
+   * @see #transitionUsing(TransitionFactory)
+   */
+  public static BitmapTransitionOptions withWrapped(
+      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+    return new BitmapTransitionOptions().transitionUsing(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link BitmapTransitionOptions} object that uses the given transition factory.
+   *
+   * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
+   */
+  public static BitmapTransitionOptions with(
+      TransitionFactory<Bitmap> transitionFactory) {
+    return new BitmapTransitionOptions().transition(transitionFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public BitmapTransitionOptions crossFade() {
+    return crossFade(new DrawableCrossFadeFactory.Builder());
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param duration The duration of the animation, see
+   *     {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder(int)}
+   */
+  public BitmapTransitionOptions crossFade(int duration) {
+    return crossFade(new DrawableCrossFadeFactory.Builder(duration));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param animationId The id of the animation to use if no placeholder or previous resource is
+   *     set, see {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   *     #setDefaultAnimationId(int)}.
+   * @param duration The duration of the cross fade, see
+   *     {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder(int)}
+   */
+  public BitmapTransitionOptions crossFade(int animationId, int duration) {
+    return crossFade(
+        new DrawableCrossFadeFactory.Builder(duration)
+            .setDefaultAnimationId(animationId));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return transitionUsing(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Enables a any Drawable based animation to run on Bitmaps as well.
+   */
+  public BitmapTransitionOptions transitionUsing(
+      TransitionFactory<Drawable> drawableCrossFadeFactory) {
+    return transition(new BitmapTransitionFactory(drawableCrossFadeFactory));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public BitmapTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+    return transitionUsing(builder.build());
+  }
+}
+
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
index d84dd89ab..a37e2bbb7 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java
@@ -21,8 +21,10 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
+import java.util.HashSet;
 import java.util.Queue;
 import java.util.Set;
 
@@ -47,6 +49,17 @@
       Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.DownsampleStrategy",
           DownsampleStrategy.AT_LEAST);
 
+  private static final String WBMP_MIME_TYPE = "image/vnd.wap.wbmp";
+  private static final String ICO_MIME_TYPE = "image/x-ico";
+  private static final Set<String> NO_DOWNSAMPLE_PRE_N_MIME_TYPES =
+      Collections.unmodifiableSet(
+          new HashSet<>(
+              Arrays.asList(
+                  WBMP_MIME_TYPE,
+                  ICO_MIME_TYPE
+              )
+          )
+      );
   private static final DecodeCallbacks EMPTY_CALLBACKS = new DecodeCallbacks() {
     @Override
     public void onObtainBounds() {
@@ -162,7 +175,7 @@ private Bitmap decodeFromWrappedStreams(InputStream is,
     String sourceMimeType = options.outMimeType;
 
     int orientation = getOrientation(is);
-    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(getOrientation(is));
+    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
 
     options.inPreferredConfig = getConfig(is, decodeFormat);
     if (options.inPreferredConfig != Bitmap.Config.ARGB_8888) {
@@ -240,9 +253,17 @@ static void calculateScaling(DownsampleStrategy downsampleStrategy, int degreesT
         ? Math.max(widthScaleFactor, heightScaleFactor)
         : Math.min(widthScaleFactor, heightScaleFactor);
 
-    int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
-    if (rounding == SampleSizeRounding.MEMORY && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
-      powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+    int powerOfTwoSampleSize;
+    // BitmapFactory does not support downsampling wbmp files on platforms <= M. See b/27305903.
+    if (Build.VERSION.SDK_INT <= 23
+        && NO_DOWNSAMPLE_PRE_N_MIME_TYPES.contains(options.outMimeType)) {
+      powerOfTwoSampleSize = 1;
+    } else {
+      powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
+      if (rounding == SampleSizeRounding.MEMORY
+          && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
+        powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
+      }
     }
 
     float adjustedScaleFactor = powerOfTwoSampleSize * exactScaleFactor;
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
index 9d8c8a2f2..481ad9144 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java
@@ -4,6 +4,7 @@
 
 import com.bumptech.glide.TransitionOptions;
 import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;
+import com.bumptech.glide.request.transition.TransitionFactory;
 
 /**
  * Contains {@link Drawable} specific animation options.
@@ -11,28 +12,112 @@
 public final class DrawableTransitionOptions extends
     TransitionOptions<DrawableTransitionOptions, Drawable> {
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade()
+   */
   public static DrawableTransitionOptions withCrossFade() {
     return new DrawableTransitionOptions().crossFade();
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int)
+   */
   public static DrawableTransitionOptions withCrossFade(int duration) {
     return new DrawableTransitionOptions().crossFade(duration);
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(int, int)
+   */
   public static DrawableTransitionOptions withCrossFade(int animationId, int duration) {
     return new DrawableTransitionOptions().crossFade(animationId, duration);
   }
 
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory)
+   */
+  public static DrawableTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return new DrawableTransitionOptions().crossFade(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation.
+   *
+   * @see #crossFade(DrawableCrossFadeFactory.Builder)
+   */
+  public static DrawableTransitionOptions withCrossFade(
+      DrawableCrossFadeFactory.Builder builder) {
+    return new DrawableTransitionOptions().crossFade(builder);
+  }
+
+  /**
+   * Returns a {@link DrawableTransitionOptions} object that uses the given transition factory.
+   *
+   * @see com.bumptech.glide.GenericTransitionOptions#with(TransitionFactory)
+   */
+  public static DrawableTransitionOptions with(
+      TransitionFactory<Drawable> transitionFactory) {
+    return new DrawableTransitionOptions().transition(transitionFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
   public DrawableTransitionOptions crossFade() {
-    return transition(new DrawableCrossFadeFactory());
+    return crossFade(new DrawableCrossFadeFactory.Builder());
   }
 
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param duration The duration of the animation, see
+   *     {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder(int)}
+   */
   public DrawableTransitionOptions crossFade(int duration) {
-    return transition(new DrawableCrossFadeFactory(duration));
+    return crossFade(new DrawableCrossFadeFactory.Builder(duration));
   }
 
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   *
+   * @param animationId The id of the animation to use if no placeholder or previous resource is
+   *     set, see {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder
+   *     #setDefaultAnimationId(int)}.
+   * @param duration The duration of the cross fade, see
+   *     {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder(int)}
+   */
   public DrawableTransitionOptions crossFade(int animationId, int duration) {
-    return transition(new DrawableCrossFadeFactory(animationId, duration));
+    return crossFade(
+        new DrawableCrossFadeFactory.Builder(duration)
+            .setDefaultAnimationId(animationId));
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {
+    return transition(drawableCrossFadeFactory);
+  }
+
+  /**
+   * Enables a cross fade animation between both the placeholder and the first resource and between
+   * subsequent resources (if thumbnails are used).
+   */
+  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {
+    return crossFade(builder.build());
   }
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
index 51f73252d..689467e4b 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java
@@ -8,6 +8,7 @@
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.gifdecoder.GifHeader;
 import com.bumptech.glide.gifdecoder.GifHeaderParser;
+import com.bumptech.glide.gifdecoder.StandardGifDecoder;
 import com.bumptech.glide.load.Option;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.ResourceDecoder;
@@ -65,7 +66,7 @@ public ByteBufferGifDecoder(
       ArrayPool arrayPool,
       GifHeaderParserPool parserPool,
       GifDecoderFactory gifDecoderFactory) {
-    this.context = context;
+    this.context = context.getApplicationContext();
     this.bitmapPool = bitmapPool;
     this.gifDecoderFactory = gifDecoderFactory;
     this.provider = new GifBitmapProvider(bitmapPool, arrayPool);
@@ -140,7 +141,7 @@ private static int getSampleSize(GifHeader gifHeader, int targetWidth, int targe
   static class GifDecoderFactory {
     public GifDecoder build(GifDecoder.BitmapProvider provider, GifHeader header,
         ByteBuffer data, int sampleSize) {
-      return new GifDecoder(provider, header, data, sampleSize);
+      return new StandardGifDecoder(provider, header, data, sampleSize);
     }
   }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
index dfcffbc6f..b7243dace 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java
@@ -12,8 +12,10 @@
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
+import android.support.annotation.VisibleForTesting;
 import android.view.Gravity;
 
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.gifdecoder.GifDecoder;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
@@ -94,18 +96,26 @@
   public GifDrawable(Context context, GifDecoder gifDecoder, BitmapPool bitmapPool,
       Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,
       Bitmap firstFrame) {
-    this(new GifState(context, bitmapPool,
-        new GifFrameLoader(context, gifDecoder, targetFrameWidth, targetFrameHeight,
-            frameTransformation, firstFrame)));
+    this(
+        new GifState(
+            bitmapPool,
+            new GifFrameLoader(
+                // TODO(b/27524013): Factor out this call to Glide.get()
+                Glide.get(context),
+                gifDecoder,
+                targetFrameWidth,
+                targetFrameHeight,
+                frameTransformation,
+                firstFrame)));
   }
 
   GifDrawable(GifState state) {
     this.state = Preconditions.checkNotNull(state);
   }
 
-  // Visible for testing.
-  GifDrawable(Context context, GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
-    this(new GifState(context, bitmapPool, frameLoader));
+  @VisibleForTesting
+  GifDrawable(GifFrameLoader frameLoader, BitmapPool bitmapPool, Paint paint) {
+    this(new GifState(bitmapPool, frameLoader));
     this.paint = paint;
   }
 
@@ -162,6 +172,8 @@ public void stop() {
   }
 
   private void startRunning() {
+    Preconditions.checkArgument(!isRecycled, "You cannot start a recycled Drawable. Ensure that"
+        + "you clear any references to the Drawable when clearing the corresponding request.");
     // If we have only a single frame, we don't want to decode it endlessly.
     if (state.frameLoader.getFrameCount() == 1) {
       invalidateSelf();
@@ -179,6 +191,9 @@ private void stopRunning() {
 
   @Override
   public boolean setVisible(boolean visible, boolean restart) {
+    Preconditions.checkArgument(!isRecycled, "Cannot change the visibility of a recycled resource."
+        + " Ensure that you unset the Drawable from your View before changing the View's"
+        + " visibility.");
     isVisible = visible;
     if (!visible) {
       stopRunning();
@@ -313,13 +328,11 @@ public void setLoopCount(int loopCount) {
 
   static class GifState extends ConstantState {
     static final int GRAVITY = Gravity.FILL;
-    final Context context;
     final BitmapPool bitmapPool;
     final GifFrameLoader frameLoader;
 
-    public GifState(Context context, BitmapPool bitmapPool, GifFrameLoader frameLoader) {
+    public GifState(BitmapPool bitmapPool, GifFrameLoader frameLoader) {
       this.bitmapPool = bitmapPool;
-      this.context = context.getApplicationContext();
       this.frameLoader = frameLoader;
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
index d6b4263ec..2775b496f 100644
--- a/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java
@@ -17,6 +17,7 @@
 import com.bumptech.glide.load.Key;
 import com.bumptech.glide.load.Transformation;
 import com.bumptech.glide.load.engine.DiskCacheStrategy;
+import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.request.RequestOptions;
 import com.bumptech.glide.request.target.SimpleTarget;
 import com.bumptech.glide.request.transition.Transition;
@@ -35,6 +36,7 @@
   private final Context context;
   private final List<FrameCallback> callbacks = new ArrayList<>();
   private final RequestManager requestManager;
+  private final BitmapPool bitmapPool;
 
   private boolean isRunning = false;
   private boolean isLoadPending = false;
@@ -49,24 +51,40 @@
     void onFrameReady();
   }
 
-  public GifFrameLoader(Context context, GifDecoder gifDecoder, int width, int height,
-      Transformation<Bitmap> transformation, Bitmap firstFrame) {
-    this(context,
-        Glide.with(context),
+  public GifFrameLoader(
+      Glide glide,
+      GifDecoder gifDecoder,
+      int width,
+      int height,
+      Transformation<Bitmap> transformation,
+      Bitmap firstFrame) {
+    this(
+        glide.getContext(),
+        glide.getBitmapPool(),
+        Glide.with(glide.getContext()),
         gifDecoder,
         null /*handler*/,
-        getRequestBuilder(context, width, height), transformation, firstFrame);
+        getRequestBuilder(Glide.with(glide.getContext()), width, height),
+        transformation,
+        firstFrame);
   }
 
   @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
-  GifFrameLoader(Context context, RequestManager requestManager, GifDecoder gifDecoder,
-      Handler handler, RequestBuilder<Bitmap> requestBuilder, Transformation<Bitmap> transformation,
+  GifFrameLoader(
+      Context context,
+      BitmapPool bitmapPool,
+      RequestManager requestManager,
+      GifDecoder gifDecoder,
+      Handler handler,
+      RequestBuilder<Bitmap> requestBuilder,
+      Transformation<Bitmap> transformation,
       Bitmap firstFrame) {
     this.requestManager = requestManager;
     if (handler == null) {
       handler = new Handler(Looper.getMainLooper(), new FrameLoaderCallback());
     }
     this.context = context;
+    this.bitmapPool = bitmapPool;
     this.handler = handler;
     this.requestBuilder = requestBuilder;
 
@@ -194,7 +212,7 @@ private void loadNextFrame() {
 
   private void recycleFirstFrame() {
     if (firstFrame != null) {
-      Glide.get(context).getBitmapPool().put(firstFrame);
+      bitmapPool.put(firstFrame);
       firstFrame = null;
     }
   }
@@ -268,9 +286,14 @@ public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transiti
     }
   }
 
-  private static RequestBuilder<Bitmap> getRequestBuilder(Context context, int width, int height) {
-    return Glide.with(context).asBitmap().apply(
-        diskCacheStrategyOf(DiskCacheStrategy.NONE).skipMemoryCache(true).override(width, height));
+  private static RequestBuilder<Bitmap> getRequestBuilder(
+      RequestManager requestManager, int width, int height) {
+    return requestManager
+        .asBitmap()
+        .apply(
+            diskCacheStrategyOf(DiskCacheStrategy.NONE)
+                .skipMemoryCache(true)
+                .override(width, height));
   }
 
   // Visible for testing.
diff --git a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
index 1ca543956..58d248d61 100644
--- a/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java
@@ -14,6 +14,7 @@
 import android.support.v4.app.FragmentManager;
 import android.util.Log;
 
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.util.Util;
 
@@ -82,9 +83,12 @@ private RequestManager getApplicationManager(Context context) {
           // activity. However, in this case since the manager attached to the application will not
           // receive lifecycle events, we must force the manager to start resumed using
           // ApplicationLifecycle.
+
+          // TODO(b/27524013): Factor out this Glide.get() call.
+          Glide glide = Glide.get(context);
           applicationManager =
-              new RequestManager(context.getApplicationContext(), new ApplicationLifecycle(),
-                  new EmptyRequestManagerTreeNode());
+              new RequestManager(
+                  glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
         }
       }
     }
@@ -186,8 +190,10 @@ RequestManager fragmentGet(Context context, android.app.FragmentManager fm,
     RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          new RequestManager(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
@@ -214,8 +220,10 @@ RequestManager supportFragmentGet(Context context, FragmentManager fm, Fragment
     SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
     RequestManager requestManager = current.getRequestManager();
     if (requestManager == null) {
+      // TODO(b/27524013): Factor out this Glide.get() call.
+      Glide glide = Glide.get(context);
       requestManager =
-          new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
+          new RequestManager(glide, current.getLifecycle(), current.getRequestManagerTreeNode());
       current.setRequestManager(requestManager);
     }
     return requestManager;
diff --git a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
index 7d9a755e5..6b658d5f4 100644
--- a/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.util.Log;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -11,6 +12,7 @@
  * Parses {@link com.bumptech.glide.module.GlideModule} references out of the AndroidManifest file.
  */
 public final class ManifestParser {
+  private static final String TAG = "ManifestParser";
   private static final String GLIDE_MODULE_VALUE = "GlideModule";
 
   private final Context context;
@@ -20,20 +22,30 @@ public ManifestParser(Context context) {
   }
 
   public List<GlideModule> parse() {
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Loading Glide modules");
+    }
     List<GlideModule> modules = new ArrayList<>();
     try {
       ApplicationInfo appInfo = context.getPackageManager()
           .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
-      if (appInfo.metaData != null) {
-        for (String key : appInfo.metaData.keySet()) {
-          if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
-            modules.add(parseModule(key));
+      if (appInfo.metaData == null) {
+        return modules;
+      }
+      for (String key : appInfo.metaData.keySet()) {
+        if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {
+          modules.add(parseModule(key));
+          if (Log.isLoggable(TAG, Log.DEBUG)) {
+            Log.d(TAG, "Loaded Glide module: " + key);
           }
         }
       }
     } catch (PackageManager.NameNotFoundException e) {
       throw new RuntimeException("Unable to find metadata to parse GlideModules", e);
     }
+    if (Log.isLoggable(TAG, Log.DEBUG)) {
+      Log.d(TAG, "Finished loading Glide modules");
+    }
 
     return modules;
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
index f9df455c9..649905f51 100644
--- a/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java
@@ -64,6 +64,7 @@
   private static final int THEME = 1 << 15;
   private static final int TRANSFORMATION_ALLOWED = 1 << 16;
   private static final int TRANSFORMATION_REQUIRED = 1 << 17;
+  private static final int USE_UNLIMITED_SOURCE_GENERATORS_POOL = 1 << 18;
 
   private int fields;
 
@@ -89,6 +90,7 @@
   private boolean isLocked;
   private Resources.Theme theme;
   private boolean isAutoCloneEnabled;
+  private boolean useUnlimitedSourceGeneratorsPool;
 
   /**
    * Applies a multiplier to the {@link com.bumptech.glide.request.target.Target}'s size before
@@ -114,6 +116,17 @@ public final CHILD sizeMultiplier(float sizeMultiplier) {
     return selfOrThrowIfLocked();
   }
 
+  public final CHILD useUnlimitedSourceGeneratorsPool(boolean flag) {
+    if (isAutoCloneEnabled) {
+      return clone().useUnlimitedSourceGeneratorsPool(flag);
+    }
+
+    this.useUnlimitedSourceGeneratorsPool = flag;
+    fields |= USE_UNLIMITED_SOURCE_GENERATORS_POOL;
+
+    return selfOrThrowIfLocked();
+  }
+
   /**
    * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load.
    *
@@ -754,6 +767,9 @@ public final CHILD apply(BaseRequestOptions<?> other) {
     if (isSet(other.fields, SIZE_MULTIPLIER)) {
       sizeMultiplier = other.sizeMultiplier;
     }
+    if (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {
+      useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;
+    }
     if (isSet(other.fields, DISK_CACHE_STRATEGY)) {
       diskCacheStrategy = other.diskCacheStrategy;
     }
@@ -942,4 +958,8 @@ private boolean isSet(int flag) {
   private static boolean isSet(int fields, int flag) {
     return (fields & flag) != 0;
   }
+
+  public final boolean getUseUnlimitedSourceGeneratorsPool() {
+    return useUnlimitedSourceGeneratorsPool;
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
index 681a949ce..094c7cf01 100644
--- a/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java
@@ -181,7 +181,7 @@ public synchronized void onResourceReady(R resource, Transition<? super R> trans
 
   private synchronized R doGet(Long timeoutMillis)
       throws ExecutionException, InterruptedException, TimeoutException {
-    if (assertBackgroundThread) {
+    if (assertBackgroundThread && !isDone()) {
       Util.assertBackgroundThread();
     }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index 4509e3401..f498d529b 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -373,8 +373,8 @@ public void onSizeReady(int width, int height) {
     status = Status.RUNNING;
 
     float sizeMultiplier = requestOptions.getSizeMultiplier();
-    this.width = Math.round(sizeMultiplier * width);
-    this.height = Math.round(sizeMultiplier * height);
+    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
+    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
 
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
@@ -393,12 +393,17 @@ public void onSizeReady(int width, int height) {
         requestOptions.isTransformationRequired(),
         requestOptions.getOptions(),
         requestOptions.isMemoryCacheable(),
+        requestOptions.getUseUnlimitedSourceGeneratorsPool(),
         this);
     if (Log.isLoggable(TAG, Log.VERBOSE)) {
       logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
     }
   }
 
+  private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
+    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
+  }
+
   private boolean canSetResource() {
     return requestCoordinator == null || requestCoordinator.canSetImage(this);
   }
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
index 85ed326a4..aa31b2b83 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java
@@ -54,7 +54,7 @@ public void setDrawable(Drawable drawable) {
   @Override
   public void onLoadStarted(@Nullable Drawable placeholder) {
     super.onLoadStarted(placeholder);
-    setResource(null);
+    setResourceInternal(null);
     setDrawable(placeholder);
   }
 
@@ -67,7 +67,7 @@ public void onLoadStarted(@Nullable Drawable placeholder) {
   @Override
   public void onLoadFailed(@Nullable Drawable errorDrawable) {
     super.onLoadFailed(errorDrawable);
-    setResource(null);
+    setResourceInternal(null);
     setDrawable(errorDrawable);
   }
 
@@ -80,19 +80,16 @@ public void onLoadFailed(@Nullable Drawable errorDrawable) {
   @Override
   public void onLoadCleared(@Nullable Drawable placeholder) {
     super.onLoadCleared(placeholder);
-    setResource(null);
+    setResourceInternal(null);
     setDrawable(placeholder);
   }
 
   @Override
   public void onResourceReady(Z resource, @Nullable Transition<? super Z> transition) {
     if (transition == null || !transition.transition(resource, this)) {
-      setResource(resource);
-    }
-
-    if (resource instanceof Animatable) {
-      animatable = (Animatable) resource;
-      animatable.start();
+      setResourceInternal(resource);
+    } else {
+      maybeUpdateAnimatable(resource);
     }
   }
 
@@ -110,6 +107,20 @@ public void onStop() {
     }
   }
 
+  private void setResourceInternal(@Nullable Z resource) {
+    maybeUpdateAnimatable(resource);
+    setResource(resource);
+  }
+
+  private void maybeUpdateAnimatable(@Nullable Z resource) {
+    if (resource instanceof Animatable) {
+      animatable = (Animatable) resource;
+      animatable.start();
+    } else {
+      animatable = null;
+    }
+  }
+
   protected abstract void setResource(@Nullable Z resource);
 }
 
diff --git a/library/src/main/java/com/bumptech/glide/request/target/Target.java b/library/src/main/java/com/bumptech/glide/request/target/Target.java
index 2245adace..5adf88de7 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/Target.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java
@@ -31,11 +31,15 @@
    * A lifecycle callback that is called when a load is started.
    *
    * <p> Note - This may not be called for every load, it is possible for example for loads to fail
-   * before the load starts (when the model object is null). </p>
+   * before the load starts (when the model object is null).
    *
    * <p> Note - This method may be called multiple times before any other lifecycle method is
    * called. Loads can be paused and restarted due to lifecycle or connectivity events and each
-   * restart may cause a call here. </p>
+   * restart may cause a call here.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
@@ -45,7 +49,11 @@
    * A lifecycle callback that is called when a load fails.
    *
    * <p> Note - This may be called before {@link #onLoadStarted(android.graphics.drawable.Drawable)
-   * } if the model object is null. </p>
+   * } if the model object is null.
+   *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
    *
    * @param errorDrawable The error drawable to optionally show, or null.
    */
@@ -61,6 +69,10 @@
   /**
    * A lifecycle callback that is called when a load is cancelled and its resources are freed.
    *
+   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,
+   * Transition)} is no longer displayed before redrawing the container (usually a View) or
+   * changing its visibility.
+   *
    * @param placeholder The placeholder drawable to optionally show, or null.
    */
   void onLoadCleared(@Nullable Drawable placeholder);
diff --git a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
index 336d4b069..5e85c6c28 100644
--- a/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java
@@ -6,6 +6,7 @@
 import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.support.annotation.Nullable;
+import android.support.v4.view.ViewCompat;
 import android.util.Log;
 import android.view.Display;
 import android.view.View;
@@ -204,7 +205,13 @@ void getSize(SizeReadyCallback cb) {
       int currentWidth = getViewWidthOrParam();
       int currentHeight = getViewHeightOrParam();
       if (isSizeValid(currentWidth) && isSizeValid(currentHeight)) {
-        cb.onSizeReady(currentWidth, currentHeight);
+        int paddingAdjustedWidth = currentWidth == WindowManager.LayoutParams.WRAP_CONTENT
+            ? currentWidth
+            : currentWidth - ViewCompat.getPaddingStart(view) - ViewCompat.getPaddingEnd(view);
+        int paddingAdjustedHeight = currentHeight == LayoutParams.WRAP_CONTENT
+            ? currentHeight
+            : currentHeight - view.getPaddingTop() - view.getPaddingBottom();
+        cb.onSizeReady(paddingAdjustedWidth, paddingAdjustedHeight);
       } else {
         // We want to notify callbacks in the order they were added and we only expect one or two
         // callbacks to
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
new file mode 100644
index 000000000..3968c6b23
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java
@@ -0,0 +1,55 @@
+package com.bumptech.glide.request.transition;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+
+import com.bumptech.glide.load.DataSource;
+
+/**
+ * A {@link TransitionFactory} for complex types that have a {@link android.graphics.Bitmap} inside.
+ * The transitioning bitmap is wrapped in a {@link android.graphics.drawable.BitmapDrawable}.
+ * Most commonly used with {@link DrawableCrossFadeFactory}.
+ *
+ *  @param <R> The type of the composite object that contains the {@link android.graphics.Bitmap} to
+ *            be transitioned.
+ */
+public abstract class BitmapContainerTransitionFactory<R> implements TransitionFactory<R> {
+  private final TransitionFactory<Drawable> realFactory;
+
+  public BitmapContainerTransitionFactory(TransitionFactory<Drawable> realFactory) {
+    this.realFactory = realFactory;
+  }
+
+  @Override
+  public Transition<R> build(DataSource dataSource, boolean isFirstResource) {
+    Transition<Drawable> transition = realFactory.build(dataSource, isFirstResource);
+    return new BitmapGlideAnimation(transition);
+  }
+
+  /**
+   * Retrieve the Bitmap from a composite object.
+   * <br>
+   * <b>Warning:</b> Do not convert any arbitrary object to Bitmap via expensive drawing here.
+   *
+   * @param current composite object containing a Bitmap and some other information
+   * @return the Bitmap contained within {@code current}
+   */
+  protected abstract Bitmap getBitmap(R current);
+
+  private class BitmapGlideAnimation implements Transition<R> {
+    private final Transition<Drawable> transition;
+
+    public BitmapGlideAnimation(Transition<Drawable> transition) {
+      this.transition = transition;
+    }
+
+    @Override
+    public boolean transition(R current, ViewAdapter adapter) {
+      Resources resources = adapter.getView().getResources();
+      Drawable currentBitmap = new BitmapDrawable(resources, getBitmap(current));
+      return transition.transition(currentBitmap, adapter);
+    }
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
new file mode 100644
index 000000000..a6982b5d5
--- /dev/null
+++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapTransitionFactory.java
@@ -0,0 +1,23 @@
+package com.bumptech.glide.request.transition;
+
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+
+/**
+ * A {@link TransitionFactory} for {@link android.graphics.Bitmap}s that uses a Drawable transition
+ * factory to transition from an existing drawable already visible on the target to the new bitmap.
+ *
+ * @see BitmapContainerTransitionFactory
+ */
+public class BitmapTransitionFactory extends BitmapContainerTransitionFactory<Bitmap> {
+  public BitmapTransitionFactory(@NonNull TransitionFactory<Drawable> realFactory) {
+    super(realFactory);
+  }
+
+  @Override
+  @NonNull
+  protected Bitmap getBitmap(@NonNull Bitmap current) {
+    return current;
+  }
+}
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index e4e3a0d93..166c34b08 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -15,35 +15,20 @@
  * <p> Resources are usually loaded from the memory cache just before the user can see the view, for
  * example when the user changes screens or scrolls back and forth in a list. In those cases the
  * user typically does not expect to see a transition. As a result, when the resource is loaded from
- * the memory cache this factory produces an {@link NoTransition}. </p>
+ * the memory cache this factory produces an {@link NoTransition}.
  */
 public class DrawableCrossFadeFactory implements TransitionFactory<Drawable> {
-  private static final int DEFAULT_DURATION_MS = 300;
   private final ViewAnimationFactory<Drawable> viewAnimationFactory;
   private final int duration;
+  private final boolean isCrossFadeEnabled;
   private DrawableCrossFadeTransition firstResourceTransition;
   private DrawableCrossFadeTransition secondResourceTransition;
 
-  public DrawableCrossFadeFactory() {
-    this(DEFAULT_DURATION_MS);
-  }
-
-  public DrawableCrossFadeFactory(int duration) {
-    this(new ViewAnimationFactory<Drawable>(
-        new DefaultViewTransitionAnimationFactory(duration)), duration);
-  }
-
-  public DrawableCrossFadeFactory(int defaultAnimationId, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimationId), duration);
-  }
-
-  public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
-    this(new ViewAnimationFactory<Drawable>(defaultAnimation), duration);
-  }
-
-  DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory, int duration) {
+  protected DrawableCrossFadeFactory(ViewAnimationFactory<Drawable> viewAnimationFactory,
+      int duration, boolean isCrossFadeEnabled) {
     this.viewAnimationFactory = viewAnimationFactory;
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   @Override
@@ -59,36 +44,117 @@ public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
 
   private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {
       if (firstResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(dataSource, true /*isFirstResource*/);
-          firstResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+        firstResourceTransition = buildTransition(dataSource, true /*isFirstResource*/);
       }
       return firstResourceTransition;
   }
 
   private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {
       if (secondResourceTransition == null) {
-          Transition<Drawable> defaultAnimation =
-              viewAnimationFactory.build(dataSource, false /*isFirstResource*/);
-          secondResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);
+        secondResourceTransition = buildTransition(dataSource, false /*isFirstResource*/);
       }
       return secondResourceTransition;
   }
 
-  private static class DefaultViewTransitionAnimationFactory implements ViewTransition
-      .ViewTransitionAnimationFactory {
+  private DrawableCrossFadeTransition buildTransition(DataSource dataSource,
+      boolean isFirstResource) {
+    Transition<Drawable> defaultAnimation =
+        viewAnimationFactory.build(dataSource, isFirstResource);
+    return new DrawableCrossFadeTransition(defaultAnimation, duration, isCrossFadeEnabled);
+  }
+
+  private static final class DefaultViewTransitionAnimationFactory implements
+      ViewTransition.ViewTransitionAnimationFactory {
 
-    private final int duration;
+    private final int durationMillis;
 
-    DefaultViewTransitionAnimationFactory(int duration) {
-      this.duration = duration;
+    DefaultViewTransitionAnimationFactory(int durationMillis) {
+      this.durationMillis = durationMillis;
     }
 
     @Override
     public Animation build(Context context) {
       AlphaAnimation animation = new AlphaAnimation(0f, 1f);
-      animation.setDuration(duration);
+      animation.setDuration(durationMillis);
       return animation;
     }
   }
+
+  /**
+   * A Builder for {@link DrawableCrossFadeFactory}.
+   */
+  public static class Builder {
+    private static final int DEFAULT_DURATION_MS = 300;
+    private int durationMillis;
+    private ViewAnimationFactory<Drawable> factory;
+    private boolean isCrossFadeEnabled;
+
+    public Builder() {
+      this(DEFAULT_DURATION_MS);
+    }
+
+    /**
+     * @param durationMillis The duration of both the default animation when no previous Drawable
+     *     is present and the cross fade animation when a previous Drawable is present. This value
+     *     will not be used by the default animation if {@link #setDefaultAnimationId(int)},
+     *     {@link #setDefaultAnimation(Animation)}, or
+     *     {@link #setDefaultAnimationFactory(ViewAnimationFactory)} is called.
+     */
+    public Builder(int durationMillis) {
+      this.durationMillis = durationMillis;
+      factory = new ViewAnimationFactory<>(
+          new DefaultViewTransitionAnimationFactory(durationMillis));
+    }
+
+    /**
+     * Enables or disables animating the alpha of the {@link Drawable} the cross fade will animate
+     * from.
+     *
+     * <p>Defaults to {@code false}.
+     *
+     * @param isCrossFadeEnabled If {@code true} the previous {@link Drawable}'s alpha will be
+     *     animated from 100 to 0 while the new {@link Drawable}'s alpha is
+     *     animated from 0 to 100. Otherwise the previous {@link Drawable}'s
+     *     alpha will remain at 100 throughout the animation. See
+     *     {@link android.graphics.drawable.TransitionDrawable#setCrossFadeEnabled(boolean)}
+     */
+    public Builder setCrossFadeEnabled(boolean isCrossFadeEnabled) {
+      this.isCrossFadeEnabled = isCrossFadeEnabled;
+      return this;
+    }
+
+    /**
+     * Sets the resource id of the {@link Animation} to use when no previous {@link Drawable} is
+     * available to animate from.
+     *
+     * <p>Defaults to a simple fade in.
+     */
+    public Builder setDefaultAnimationId(int animationId) {
+      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animationId));
+    }
+
+    /**
+     * Sets the {@link Animation} to use when no previous {@link Drawable} is available to animate
+     * from.
+     *
+     * <p>It is not safe to use the same {@link Animation} object for multiple animations
+     * simultaneously. Always pass in a new instance to this method.
+     */
+    public Builder setDefaultAnimation(Animation animation) {
+      return setDefaultAnimationFactory(new ViewAnimationFactory<Drawable>(animation));
+    }
+
+    /**
+     * Sets the {@link ViewAnimationFactory} to use to generate animations to animate when no
+     * previous {@link Drawable} is available to animate from.
+     */
+    public Builder setDefaultAnimationFactory(ViewAnimationFactory<Drawable> factory) {
+      this.factory = factory;
+      return this;
+    }
+
+    public DrawableCrossFadeFactory build() {
+      return new DrawableCrossFadeFactory(factory, durationMillis, isCrossFadeEnabled);
+    }
+  }
 }
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
index 2cbca19c7..ee1ff46e2 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java
@@ -13,17 +13,28 @@
 public class DrawableCrossFadeTransition implements Transition<Drawable> {
   private final Transition<Drawable> defaultAnimation;
   private final int duration;
+  private final boolean isCrossFadeEnabled;
 
   /**
    * Constructor that takes a default animation and a duration in milliseconds that the cross fade
    * animation should last.
    *
+   * @param defaultAnimation The {@link Transition} to use if there is no previous
+   *                         {@link Drawable} (either a placeholder or previous resource) to
+   *                         transition from.
    * @param duration The duration that the cross fade animation should run if there is something to
    *                 cross fade from when a new {@link android.graphics.drawable.Drawable} is put.
+   * @param isCrossFadeEnabled If {@code true}, animates the previous resource's alpha to 0 while
+   *                         animating the new resource's alpha to 100. Otherwise, only animates
+   *                         the new resource's alpha to 100 while leaving the previous resource's
+   *                         alpha at 100. See
+   *                         {@link TransitionDrawable#setCrossFadeEnabled(boolean)}.
    */
-  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration) {
+  public DrawableCrossFadeTransition(Transition<Drawable> defaultAnimation, int duration,
+      boolean isCrossFadeEnabled) {
     this.defaultAnimation = defaultAnimation;
     this.duration = duration;
+    this.isCrossFadeEnabled = isCrossFadeEnabled;
   }
 
   /**
@@ -43,7 +54,7 @@ public boolean transition(Drawable current, ViewAdapter adapter) {
     if (previous != null) {
       TransitionDrawable transitionDrawable =
           new TransitionDrawable(new Drawable[] { previous, current });
-      transitionDrawable.setCrossFadeEnabled(true);
+      transitionDrawable.setCrossFadeEnabled(isCrossFadeEnabled);
       transitionDrawable.startTransition(duration);
       adapter.setDrawable(transitionDrawable);
       return true;
diff --git a/library/src/test/java/com/bumptech/glide/GlideTest.java b/library/src/test/java/com/bumptech/glide/GlideTest.java
index 18fc12548..bbc03b66a 100644
--- a/library/src/test/java/com/bumptech/glide/GlideTest.java
+++ b/library/src/test/java/com/bumptech/glide/GlideTest.java
@@ -126,7 +126,7 @@ public Boolean answer(InvocationOnMock invocation) throws Throwable {
 
     Lifecycle lifecycle = mock(Lifecycle.class);
     RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
-    requestManager = new RequestManager(getContext(), lifecycle, treeNode);
+    requestManager = new RequestManager(Glide.get(getContext()), lifecycle, treeNode);
     requestManager.resumeRequests();
   }
 
@@ -561,8 +561,7 @@ public void testClone() throws IOException {
         .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), failFetcher));
     when(failLoader.handles(isA(failModel))).thenReturn(true);
     ModelLoaderFactory<T, Z> failFactory = mock(ModelLoaderFactory.class);
-    when(failFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(failLoader);
+    when(failFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(failLoader);
 
     Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);
   }
@@ -600,8 +599,7 @@ private Context getContext() {
   private <T> void registerMockStreamModelLoader(final Class<T> modelClass) {
     ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);
     ModelLoaderFactory<T, InputStream> modelLoaderFactory = mock(ModelLoaderFactory.class);
-    when(modelLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
-        .thenReturn(modelLoader);
+    when(modelLoaderFactory.build(isA(MultiModelLoaderFactory.class))).thenReturn(modelLoader);
 
     Glide.get(RuntimeEnvironment.application).getRegistry()
         .prepend(modelClass, InputStream.class, modelLoaderFactory);
@@ -692,7 +690,7 @@ public void registerComponents(Context context, Registry registry) {
           .thenReturn(new ModelLoader.LoadData<>(mock(Key.class), mockStreamFetcher));
       when(mockUrlLoader.handles(isA(modelClass))).thenReturn(true);
       ModelLoaderFactory<X, Y> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);
-      when(mockUrlLoaderFactory.build(isA(Context.class), isA(MultiModelLoaderFactory.class)))
+      when(mockUrlLoaderFactory.build(isA(MultiModelLoaderFactory.class)))
           .thenReturn(mockUrlLoader);
 
       registry.replace(modelClass, dataClass, mockUrlLoaderFactory);
diff --git a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
index 0e171262f..4b964e1ee 100644
--- a/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
+++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java
@@ -57,8 +57,13 @@ public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable
           }
         });
     requestTracker = mock(RequestTracker.class);
-    manager = new RequestManager(RuntimeEnvironment.application, lifecycle, treeNode,
-        requestTracker, factory);
+    manager =
+        new RequestManager(
+            Glide.get(RuntimeEnvironment.application),
+            lifecycle,
+            treeNode,
+            requestTracker,
+            factory);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
index 4cef86d3a..549097336 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java
@@ -10,6 +10,7 @@
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.Headers;
 import com.bumptech.glide.testutil.TestUtil;
+
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
diff --git a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
index af261f814..d56c443a0 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java
@@ -64,7 +64,7 @@ public void testHandlesExceptionOnClose() throws Exception {
     final Closeable closeable = mock(Closeable.class);
 
     public TestLocalUriFetcher(Context context, Uri uri) {
-      super(context, uri);
+      super(context.getContentResolver(), uri);
     }
 
     @Override
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
index 0b0673dc3..db9fade55 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java
@@ -17,7 +17,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 import java.io.InputStream;
@@ -38,12 +37,12 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
 
     uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
-    fetcher = new ThumbFetcher(RuntimeEnvironment.application, uri, opener);
+    fetcher = new ThumbFetcher(uri, opener);
   }
 
   @Test
   public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.LOW, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
@@ -51,7 +50,7 @@ public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
 
   @Test
   public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {
-    when(opener.open(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(expected);
+    when(opener.open(eq(uri))).thenReturn(expected);
 
     fetcher.loadData(Priority.HIGH, callback);
 
diff --git a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
index f06fd0382..47b5c6eef 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java
@@ -8,6 +8,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import android.content.ContentResolver;
 import android.database.MatrixCursor;
 import android.net.Uri;
 import android.provider.MediaStore;
@@ -41,43 +42,41 @@ public void setUp() {
 
   @Test
   public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri))).thenReturn(null);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(null);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(new MatrixCursor(new String[1]));
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(new MatrixCursor(new String[1]));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
     MatrixCursor cursor = new MatrixCursor(new String[1]);
     cursor.addRow(new Object[] { "" });
-    when(harness.query.query(eq(RuntimeEnvironment.application), eq(harness.uri)))
-        .thenReturn(cursor);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    when(harness.query.query(eq(harness.uri))).thenReturn(cursor);
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnsNullIfFileDoesNotExist() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.exists(eq(harness.file))).thenReturn(false);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testReturnNullIfFileLengthIsZero() throws FileNotFoundException {
     when(harness.service.get(anyString())).thenReturn(harness.file);
     when(harness.service.length(eq(harness.file))).thenReturn(0L);
-    assertNull(harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertNull(harness.get().open(harness.uri));
   }
 
   @Test
   public void testClosesCursor() throws FileNotFoundException {
-    harness.get().open(RuntimeEnvironment.application, harness.uri);
+    harness.get().open(harness.uri);
     assertTrue(harness.cursor.isClosed());
   }
 
@@ -86,27 +85,33 @@ public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundExcep
     InputStream expected = new ByteArrayInputStream(new byte[0]);
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .registerInputStream(harness.uri, expected);
-    assertEquals(expected, harness.get().open(RuntimeEnvironment.application, harness.uri));
+    assertEquals(expected, harness.get().open(harness.uri));
   }
 
   @Test
   public void testVideoQueryReturnsVideoCursor() {
     Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.VideoThumbnailQuery query = new ThumbFetcher.VideoThumbnailQuery();
+    ThumbFetcher.VideoThumbnailQuery query =
+        new ThumbFetcher.VideoThumbnailQuery(getContentResovler());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
   }
 
   @Test
   public void testImageQueryReturnsImageCursor() {
     Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
-    ThumbFetcher.ImageThumbnailQuery query = new ThumbFetcher.ImageThumbnailQuery();
+    ThumbFetcher.ImageThumbnailQuery query =
+        new ThumbFetcher.ImageThumbnailQuery(getContentResovler());
     RoboCursor testCursor = new RoboCursor();
     Shadows.shadowOf(RuntimeEnvironment.application.getContentResolver())
         .setCursor(queryUri, testCursor);
-    assertEquals(testCursor, query.query(RuntimeEnvironment.application, harness.uri));
+    assertEquals(testCursor, query.query(harness.uri));
+  }
+
+  private static ContentResolver getContentResovler() {
+    return RuntimeEnvironment.application.getContentResolver();
   }
 
   private static class Harness {
@@ -119,14 +124,14 @@ public void testImageQueryReturnsImageCursor() {
 
     public Harness() {
       cursor.addRow(new String[] { file.getAbsolutePath() });
-      when(query.query(eq(RuntimeEnvironment.application), eq(uri))).thenReturn(cursor);
+      when(query.query(eq(uri))).thenReturn(cursor);
       when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
       when(service.exists(eq(file))).thenReturn(true);
       when(service.length(eq(file))).thenReturn(1L);
     }
 
     public ThumbnailStreamOpener get() {
-      return new ThumbnailStreamOpener(service, query, byteArrayPool);
+      return new ThumbnailStreamOpener(service, query, byteArrayPool, getContentResovler());
     }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
index 3a4f231ef..1dc6554fe 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java
@@ -53,7 +53,8 @@ public void testLoadResource_returnsFileDescriptor() throws Exception {
     when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(parcelFileDescriptor);
     shadow.registerFileDescriptor(uri, assetFileDescriptor);
 
-    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(eq(parcelFileDescriptor));
   }
@@ -67,7 +68,8 @@ public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {
     ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
     shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);
 
-    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);
+    FileDescriptorLocalUriFetcher fetcher =
+        new FileDescriptorLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onLoadFailed(isA(FileNotFoundException.class));
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
index 16f6d63cc..968c448be 100644
--- a/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java
@@ -46,7 +46,7 @@ public void testLoadResource_returnsInputStream() throws Exception {
     ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);
     shadow.registerInputStream(uri, new ByteArrayInputStream(new byte[0]));
 
-    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.NORMAL, callback);
     verify(callback).onDataReady(isNotNull(InputStream.class));
   }
@@ -61,7 +61,7 @@ public void testLoadResource_withNullInputStream_callsLoadFailed() {
 
     shadow.registerInputStream(uri, null /*inputStream*/);
 
-    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context, uri);
+    StreamLocalUriFetcher fetcher = new StreamLocalUriFetcher(context.getContentResolver(), uri);
     fetcher.loadData(Priority.LOW, callback);
 
     verify(callback).onLoadFailed(isA(FileNotFoundException.class));
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
index 2f3ea0229..0df1fe1fb 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java
@@ -441,6 +441,18 @@ public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSourceOnlyOnStart
     verify(harness.decodeJob).run();
   }
 
+  @Test
+  public void testSubmitsDecodeJobToUnlimitedSourceServiceWhenDecodingFromSourceOnlyOnStart() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    EngineJob<Object> job = harness.getJob();
+
+    when(harness.decodeJob.willDecodeFromCache()).thenReturn(false);
+    harness.diskCacheService.shutdownNow();
+    job.start(harness.decodeJob);
+
+    verify(harness.decodeJob).run();
+  }
+
   @SuppressWarnings("unchecked")
   private static class MultiCbHarness {
     Key key = mock(Key.class);
@@ -448,20 +460,22 @@ public void testSubmitsDecodeJobToSourceServiceWhenDecodingFromSourceOnlyOnStart
     EngineResource<Object> engineResource = mock(EngineResource.class);
     EngineJobListener listener = mock(EngineJobListener.class);
     boolean isCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
     int numCbs = 10;
     List<ResourceCallback> cbs = new ArrayList<>();
     EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);
     EngineJob<Object> job;
     GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
     GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     DataSource dataSource = DataSource.LOCAL;
 
     public MultiCbHarness() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      job = new EngineJob<>(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      job = new EngineJob<>(diskCacheService, sourceService, sourceUnlimitedService, listener, pool,
+          factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool);
       for (int i = 0; i < numCbs; i++) {
         cbs.add(mock(ResourceCallback.class));
       }
@@ -482,15 +496,17 @@ public MultiCbHarness() {
     EngineJobListener listener = mock(EngineJobListener.class);
     GlideExecutor diskCacheService = MockGlideExecutor.newMainThreadExecutor();
     GlideExecutor sourceService = MockGlideExecutor.newMainThreadExecutor();
+    GlideExecutor sourceUnlimitedService = MockGlideExecutor.newMainThreadUnlimitedExecutor();
     boolean isCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
     DecodeJob<Object> decodeJob = mock(DecodeJob.class);
     Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);
     DataSource dataSource = DataSource.DATA_DISK_CACHE;
 
     public EngineJob<Object> getJob() {
       when(factory.build(eq(resource), eq(isCacheable))).thenReturn(engineResource);
-      EngineJob result = new EngineJob(diskCacheService, sourceService, listener, pool, factory)
-          .init(key, isCacheable);
+      EngineJob result = new EngineJob(diskCacheService, sourceService, sourceUnlimitedService,
+          listener, pool, factory).init(key, isCacheable, useUnlimitedSourceGeneratorPool);
       result.addCallback(cb);
       return result;
     }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
index ac0098a9d..2b888bd38 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java
@@ -421,7 +421,21 @@ public void testKeyFactoryIsGivenNecessaryArguments() {
   public void testFactoryIsGivenNecessaryArguments() {
     harness.doLoad();
 
-    verify(harness.engineJobFactory).build(eq(harness.cacheKey), eq(true) /*isMemoryCacheable*/);
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(false) /*useUnlimitedSourceGeneratorPool*/);
+  }
+
+  @Test
+  public void testFactoryIsGivenNecessaryArgumentsWithUnlimitedPool() {
+    harness.useUnlimitedSourceGeneratorPool = true;
+    harness.doLoad();
+
+    verify(harness.engineJobFactory).build(
+        eq(harness.cacheKey),
+        eq(true) /*isMemoryCacheable*/,
+        eq(true) /*useUnlimitedSourceGeneratorPool*/);
   }
 
   @Test
@@ -470,6 +484,7 @@ public void runTest() throws Exception {
     Options options = new Options();
     GlideContext glideContext = mock(GlideContext.class);
     boolean isMemoryCacheable = true;
+    boolean useUnlimitedSourceGeneratorPool = false;
 
     public EngineTestHarness() {
       when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),
@@ -479,12 +494,14 @@ public EngineTestHarness() {
 
       engine = new Engine(cache, mock(DiskCache.Factory.class),
           GlideExecutor.newDiskCacheExecutor(),
-          MockGlideExecutor.newMainThreadExecutor(), jobs, keyFactory, activeResources,
+          MockGlideExecutor.newMainThreadExecutor(),
+          MockGlideExecutor.newMainThreadUnlimitedExecutor(),
+          jobs, keyFactory, activeResources,
           engineJobFactory, decodeJobFactory, resourceRecycler);
     }
 
     public Engine.LoadStatus doLoad() {
-      when(engineJobFactory.build(eq(cacheKey), anyBoolean())).thenReturn(job);
+      when(engineJobFactory.build(eq(cacheKey), anyBoolean(), anyBoolean())).thenReturn(job);
       return engine.load(glideContext,
           model,
           signature,
@@ -498,6 +515,7 @@ public EngineTestHarness() {
           false /*isTransformationRequired*/,
           options,
           isMemoryCacheable,
+          useUnlimitedSourceGeneratorPool,
           cb);
     }
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
index 2b5d216f2..af0dce220 100644
--- a/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
+++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java
@@ -12,4 +12,13 @@ public static GlideExecutor newMainThreadExecutor() {
         GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
         true /*runAllOnMainThread*/);
   }
+
+  public static GlideExecutor newMainThreadUnlimitedExecutor() {
+    return new GlideExecutor(0 /* corePoolSize */,
+        Integer.MAX_VALUE /* maximumPoolSize */,
+        java.util.concurrent.TimeUnit.SECONDS.toMillis(10) /* keepAliveTimeInMs */,
+        "mock-unlimited-glide-executor",
+        GlideExecutor.UncaughtThrowableStrategy.THROW, false /*preventNetworkOperations*/,
+        true /*runAllOnMainThread*/);
+  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
index 640ed84f2..b5d18a96a 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/DataUrlLoaderTest.java
@@ -18,7 +18,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
@@ -65,7 +64,7 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
     DataUrlLoader.StreamFactory factory = new DataUrlLoader.StreamFactory();
     options = new Options();
-    dataUrlLoader = (DataUrlLoader) factory.build(RuntimeEnvironment.application, multiFactory);
+    dataUrlLoader = (DataUrlLoader) factory.build(multiFactory);
     fetcher = dataUrlLoader.buildLoadData(VALID_PNG, -1, -1, options).fetcher;
 
   }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
index 3664fcce2..286d33e59 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java
@@ -1,13 +1,11 @@
 package com.bumptech.glide.load.model;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
 import android.support.v4.util.Pools.Pool;
 
 import com.bumptech.glide.Registry.NoModelLoaderAvailableException;
@@ -22,7 +20,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
@@ -48,10 +45,10 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     exceptionListPool = FactoryPools.threadSafeList();
 
-    multiFactory = new MultiModelLoaderFactory(RuntimeEnvironment.application, exceptionListPool,
-            multiModelLoaderFactory);
-    when(firstFactory.build(anyContext(), eq(multiFactory))).thenReturn(firstModelLoader);
-    when(secondFactory.build(anyContext(), eq(multiFactory))).thenReturn(secondModelLoader);
+    multiFactory = new MultiModelLoaderFactory(exceptionListPool,
+        multiModelLoaderFactory);
+    when(firstFactory.build(eq(multiFactory))).thenReturn(firstModelLoader);
+    when(secondFactory.build(eq(multiFactory))).thenReturn(secondModelLoader);
   }
 
   @Test
@@ -299,7 +296,7 @@ public void testBuild_respectsPrependOrder() {
       boolean append) {
     ModelLoaderFactory<X, Y> factory = mock(ModelLoaderFactory.class);
     ModelLoader<X, Y> loader = mock(ModelLoader.class);
-    when(factory.build(anyContext(), eq(multiFactory))).thenReturn(loader);
+    when(factory.build(eq(multiFactory))).thenReturn(loader);
     if (append) {
       multiFactory.append(modelClass, dataClass, factory);
     } else {
@@ -307,9 +304,5 @@ public void testBuild_respectsPrependOrder() {
     }
     return loader;
   }
-
-  private static Context anyContext() {
-    return any(Context.class);
-  }
 }
 
diff --git a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
index 492e029dc..4a914c316 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/ResourceLoaderTest.java
@@ -44,7 +44,7 @@ public void setUp() {
     MockitoAnnotations.initMocks(this);
     options = new Options();
 
-    loader = new ResourceLoader<>(RuntimeEnvironment.application, uriLoader);
+    loader = new ResourceLoader<>(RuntimeEnvironment.application.getResources(), uriLoader);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
index 47fcd5457..85b1dd864 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/UriLoaderTest.java
@@ -2,11 +2,9 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.when;
 
-import android.content.Context;
 import android.net.Uri;
 
 import com.bumptech.glide.load.Options;
@@ -18,7 +16,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 import java.io.File;
@@ -43,13 +40,13 @@ public void setUp() throws Exception {
     MockitoAnnotations.initMocks(this);
 
     options = new Options();
-    loader = new UriLoader<>(RuntimeEnvironment.application, factory);
+    loader = new UriLoader<>(factory);
   }
 
   @Test
   public void testHandlesFileUris() throws IOException {
     Uri fileUri = Uri.fromFile(new File("f"));
-    when(factory.build(anyContext(), eq(fileUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(fileUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(fileUri));
     assertEquals(localUriFetcher,
@@ -59,7 +56,7 @@ public void testHandlesFileUris() throws IOException {
   @Test
   public void testHandlesResourceUris() throws IOException {
     Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
-    when(factory.build(anyContext(), eq(resourceUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(resourceUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(resourceUri));
     assertEquals(localUriFetcher,
@@ -69,14 +66,10 @@ public void testHandlesResourceUris() throws IOException {
   @Test
   public void testHandlesContentUris() {
     Uri contentUri = Uri.parse("content://com.bumptech.glide");
-    when(factory.build(anyContext(), eq(contentUri))).thenReturn(localUriFetcher);
+    when(factory.build(eq(contentUri))).thenReturn(localUriFetcher);
 
     assertTrue(loader.handles(contentUri));
     assertEquals(localUriFetcher, loader.buildLoadData(contentUri, IMAGE_SIDE, IMAGE_SIDE,
         options).fetcher);
   }
-
-  private static Context anyContext() {
-    return any(Context.class);
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
index 35dc69180..b20dffa87 100644
--- a/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/model/stream/HttpGlideUrlLoaderTest.java
@@ -11,11 +11,13 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import java.io.InputStream;
 
-@RunWith(JUnit4.class)
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
 public class HttpGlideUrlLoaderTest {
   private HttpGlideUrlLoader loader;
   private GlideUrl model;
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
index 60e3e3db7..0c3dc6762 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java
@@ -21,16 +21,12 @@
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.shadows.ShadowBitmap;
 
 import java.io.File;
 import java.io.IOException;
 
 @RunWith(RobolectricTestRunner.class)
-@Config(manifest = Config.NONE, sdk = 18, shadows = {
-    BitmapEncoderTest.AlphaShadowBitmap.class })
+@Config(manifest = Config.NONE, sdk = 18)
 public class BitmapEncoderTest {
   private EncoderHarness harness;
 
@@ -137,21 +133,4 @@ public void tearDown() {
       file.delete();
     }
   }
-
-  @Implements(Bitmap.class)
-  public static class AlphaShadowBitmap extends ShadowBitmap {
-    private boolean hasAlpha;
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    @SuppressWarnings("unused")
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
-  }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
index 039dfec05..5f9a022d1 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java
@@ -8,6 +8,7 @@
 
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.os.Build;
 import android.util.DisplayMetrics;
 
 import com.bumptech.glide.load.DecodeFormat;
@@ -16,7 +17,9 @@
 import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;
 import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
 import com.bumptech.glide.load.resource.bitmap.DownsamplerTest.AllocationSizeBitmap;
+import com.bumptech.glide.tests.Util;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -43,6 +46,7 @@
   @Mock private ArrayPool byteArrayPool;
   private Downsampler downsampler;
   private Options options;
+  private int initialSdkVersion;
 
   @Before
   public void setUp() throws Exception {
@@ -53,6 +57,13 @@ public void setUp() throws Exception {
     when(byteArrayPool.get(anyInt(), Matchers.eq(byte[].class)))
         .thenReturn(new byte[ArrayPool.STANDARD_BUFFER_SIZE_BYTES]);
     downsampler = new Downsampler(displayMetrics, bitmapPool, byteArrayPool);
+
+    initialSdkVersion = Build.VERSION.SDK_INT;
+  }
+
+  @After
+  public void tearDown() {
+    Util.setSdkVersionInt(initialSdkVersion);
   }
 
   @Test
@@ -153,9 +164,34 @@ public void testCalculateScaling_withNone() {
     runScaleTest(87, 78, 100, 100, strategy, 87, 78);
   }
 
+  // BitmapFactory does not support downsampling wbmp files on platforms <=M. See b/27305903.
+  @Test
+  public void testCalculateScaling_withWbmp() {
+    Util.setSdkVersionInt(23);
+    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;
+    BitmapFactory.Options options = new BitmapFactory.Options();
+
+    options.outMimeType = "image/vnd.wap.wbmp";
+    runScaleTest(100, 100, 100, 100, strategy, 100, 100, options);
+    runScaleTest(200, 200, 100, 100, strategy, 100, 100, options);
+    runScaleTest(400, 400, 100, 100, strategy, 100, 100, options);
+    runScaleTest(300, 300, 100, 100, strategy, 100, 100, options);
+    runScaleTest(799, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(800, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(801, 100, 100, 100, strategy, 100, 13, options);
+    runScaleTest(100, 800, 100, 100, strategy, 13, 100, options);
+    runScaleTest(87, 78, 100, 100, strategy, 100, 90, options);
+  }
+
   private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
       int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight) {
-    BitmapFactory.Options options = new BitmapFactory.Options();
+    runScaleTest(sourceWidth, sourceHeight, targetWidth, targetHeight, strategy, expectedWidth,
+        expectedHeight, new BitmapFactory.Options());
+  }
+
+  private static void runScaleTest(int sourceWidth, int sourceHeight, int targetWidth,
+      int targetHeight, DownsampleStrategy strategy, int expectedWidth, int expectedHeight,
+      BitmapFactory.Options options) {
     Downsampler.calculateScaling(strategy, 0, sourceWidth, sourceHeight, targetWidth, targetHeight,
         options);
     assertSize(sourceWidth, sourceHeight, expectedWidth, expectedHeight, options);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
index 24bd56cad..184c81df0 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java
@@ -445,8 +445,6 @@ public void testInitializeMatrixSetsRotateOnRotation() {
   @Implements(Bitmap.class)
   public static class AlphaShadowBitmap extends ShadowBitmap {
 
-    private boolean hasAlpha;
-
     @Implementation
     public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       // Robolectric doesn't match the framework behavior with null configs, so we have to do so
@@ -454,15 +452,5 @@ public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
       Preconditions.checkNotNull("Config must not be null");
       return ShadowBitmap.createBitmap(width, height, config);
     }
-
-    @Implementation
-    public void setHasAlpha(boolean hasAlpha) {
-      this.hasAlpha = hasAlpha;
-    }
-
-    @Implementation
-    public boolean hasAlpha() {
-      return hasAlpha;
-    }
   }
 }
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
index d838b7efa..add4df1e2 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java
@@ -77,7 +77,7 @@ public void setUp() {
     frameWidth = 120;
     frameHeight = 450;
     firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);
-    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);
+    drawable = new GifDrawable(frameLoader, bitmapPool, paint);
     when(frameLoader.getWidth()).thenReturn(frameWidth);
     when(frameLoader.getHeight()).thenReturn(frameHeight);
     when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);
@@ -104,7 +104,7 @@ public void testShouldDrawFirstFrameBeforeAnyFrameRead() {
   @Test
   public void testDoesDrawCurrentFrameIfOneIsAvailable() {
     Canvas canvas = mock(Canvas.class);
-    Bitmap currentFrame = Bitmap.createBitmap(100123, 123141, Bitmap.Config.ARGB_4444);
+    Bitmap currentFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);
     when(frameLoader.getCurrentFrame()).thenReturn(currentFrame);
 
     drawable.draw(canvas);
diff --git a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
index 759a88013..1bc4f7992 100644
--- a/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
+++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java
@@ -18,7 +18,9 @@
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Message;
+import android.support.annotation.NonNull;
 
+import com.bumptech.glide.Glide;
 import com.bumptech.glide.RequestBuilder;
 import com.bumptech.glide.RequestManager;
 import com.bumptech.glide.gifdecoder.GifDecoder;
@@ -32,6 +34,7 @@
 import com.bumptech.glide.tests.Util.ReturnsSelfAnswer;
 import com.bumptech.glide.util.Util;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -71,8 +74,30 @@ public void setUp() {
 
     requestBuilder = mock(RequestBuilder.class, new ReturnsSelfAnswer());
 
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder, handler,
-        requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(handler);
+  }
+
+  @After
+  public void tearDown() {
+    Glide.tearDown();
+  }
+
+  @NonNull
+  private GifFrameLoader createGifFrameLoader(Handler handler) {
+    Glide glide = getGlideSingleton();
+    return new GifFrameLoader(
+        glide.getContext(),
+        glide.getBitmapPool(),
+        requestManager,
+        gifDecoder,
+        handler,
+        requestBuilder,
+        transformation,
+        firstFrame);
+  }
+
+  private static Glide getGlideSingleton() {
+    return Glide.get(RuntimeEnvironment.application);
   }
 
   @SuppressWarnings("unchecked")
@@ -174,8 +199,7 @@ public void testGetNextFrameDoesStartLoadAfterLoadCompletesIfStarted() {
   @Test
   public void testOnFrameReadyClearsPreviousFrame() {
     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -192,9 +216,8 @@ public void testOnFrameReadyClearsPreviousFrame() {
 
   @Test
   public void testOnFrameReadyWithNullResourceDoesNotClearPreviousFrame() {
-     // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager,
-        gifDecoder, null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null.
+    loader = createGifFrameLoader(null);
 
     DelayTarget previous = mock(DelayTarget.class);
     Request previousRequest = mock(Request.class);
@@ -229,9 +252,8 @@ public void testDelayTargetSetsResourceOnResourceReady() {
 
   @Test
   public void testClearsCompletedLoadOnFrameReadyIfCleared() {
-    // Force the loader to create a real Handler.
-    loader = new GifFrameLoader(RuntimeEnvironment.application, requestManager, gifDecoder,
-        null /*handler*/, requestBuilder, transformation, firstFrame);
+    // Force the loader to create a real Handler by passing null;
+    loader = createGifFrameLoader(null);
     loader.clear();
     DelayTarget delayTarget = mock(DelayTarget.class);
     Request request = mock(Request.class);
diff --git a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
index fb73a052b..6a8ef0884 100644
--- a/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/RequestFutureTargetTest.java
@@ -207,6 +207,14 @@ public void testThrowsExceptionIfGetCalledOnMainThread()
     future.get();
   }
 
+  @Test
+  public void testGetSucceedsOnMainThreadIfDone()
+      throws ExecutionException, InterruptedException {
+    future = new RequestFutureTarget<>(handler, width, height, true, waiter);
+    future.onResourceReady(new Object(), null);
+    future.get();
+  }
+
   @Test(expected = InterruptedException.class)
   public void testThrowsInterruptedExceptionIfThreadInterruptedWhenDoneWaiting()
       throws InterruptedException, ExecutionException {
diff --git a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
index 43af5105f..e9ae5049f 100644
--- a/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java
@@ -75,6 +75,7 @@
     GlideContext glideContext = mock(GlideContext.class);
     Key signature = mock(Key.class);
     Priority priority = Priority.HIGH;
+    boolean useUnlimitedSourceGeneratorsPool = false;
 
     Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();
 
@@ -91,7 +92,8 @@ public RequestHarness() {
         .fallback(fallbackDrawable)
         .override(overrideWidth, overrideHeight)
         .priority(priority)
-        .signature(signature);
+        .signature(signature)
+        .useUnlimitedSourceGeneratorsPool(useUnlimitedSourceGeneratorsPool);
       return SingleRequest
           .obtain(glideContext, model, List.class, requestOptions, overrideWidth, overrideHeight,
               priority, target, requestListener, requestCoordinator, engine, factory);
@@ -275,7 +277,7 @@ public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class));
+            anyBoolean(), anyBoolean(), any(ResourceCallback.class));
   }
 
   @Test
@@ -294,7 +296,7 @@ public void testEngineLoadCancelledOnCancel() {
        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),
           eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
           eq(harness.transformations), anyBoolean(), any(Options.class),
-          anyBoolean(), any(ResourceCallback.class)))
+          anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenReturn(loadStatus);
 
     SingleRequest<List> request = harness.getRequest();
@@ -538,7 +540,7 @@ public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchr
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class)))
+            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenAnswer(new Answer<Object>() {
           @Override
           public Object answer(InvocationOnMock invocation) throws Throwable {
@@ -652,7 +654,7 @@ public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
   }
 
   @Test
@@ -674,7 +676,7 @@ public void testCanReRunCancelledRequests() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),
             eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),
             eq(harness.transformations), anyBoolean(), any(Options.class),
-            anyBoolean(), any(ResourceCallback.class)))
+            anyBoolean(), anyBoolean(), any(ResourceCallback.class)))
         .thenAnswer(new CallResourceCallback(harness.resource));
     SingleRequest<List> request = harness.getRequest();
 
@@ -703,7 +705,42 @@ public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
         .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
             anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
             any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
-            any(Options.class), anyBoolean(), any(ResourceCallback.class));
+            any(Options.class), anyBoolean(), anyBoolean(), any(ResourceCallback.class));
+  }
+
+
+  @Test
+  public void testCallsSourceUnlimitedExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    harness.useUnlimitedSourceGeneratorsPool = true;
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.engine)
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), eq(Boolean.TRUE), any(ResourceCallback.class));
+  }
+
+  @Test
+  public void testCallsSourceExecutorEngineIfOptionsIsSet() {
+    doAnswer(new CallSizeReady(100, 100)).when(harness.target)
+        .getSize(any(SizeReadyCallback.class));
+
+    harness.useUnlimitedSourceGeneratorsPool = false;
+
+    SingleRequest<List> request = harness.getRequest();
+    request.begin();
+
+    verify(harness.engine)
+        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),
+            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),
+            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),
+            any(Options.class), anyBoolean(), eq(Boolean.FALSE), any(ResourceCallback.class));
   }
 
   @SuppressWarnings("unchecked")
diff --git a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
index 3debccfcd..8e59457ff 100644
--- a/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java
@@ -35,7 +35,6 @@
 import org.robolectric.internal.ShadowExtractor;
 import org.robolectric.shadows.ShadowDisplay;
 import org.robolectric.shadows.ShadowView;
-import org.robolectric.shadows.ShadowViewTreeObserver;
 
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
@@ -393,8 +392,19 @@ public void testThrowsIfGivenNullView() {
     new TestViewTarget(null);
   }
 
+  @Test
+  public void testDecreasesDimensionsByViewPadding() {
+    SizeReadyCallback cb = mock(SizeReadyCallback.class);
+    view.setLayoutParams(new LayoutParams(100, 100));
+    view.setPadding(25, 25, 25, 25);
+
+    target.getSize(cb);
+
+    verify(cb).onSizeReady(50, 50);
+  }
+
   @Implements(ViewTreeObserver.class)
-  public static class PreDrawShadowViewTreeObserver extends ShadowViewTreeObserver {
+  public static class PreDrawShadowViewTreeObserver {
     private CopyOnWriteArrayList<OnPreDrawListener> preDrawListeners = new CopyOnWriteArrayList<>();
     private boolean isAlive = true;
 
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
index 5bc27b14a..62dd94c0d 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java
@@ -24,7 +24,8 @@
   @Before
   public void setUp() {
     ViewAnimationFactory<Drawable> viewAnimationFactory = mock(ViewAnimationFactory.class);
-    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/);
+    factory = new DrawableCrossFadeFactory(viewAnimationFactory, 100 /*duration*/,
+        false /*isCrosFadeEnabled*/);
   }
 
   @Test
diff --git a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
index 78861713d..35dc2eba1 100644
--- a/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
+++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java
@@ -73,7 +73,7 @@ public void testReturnsTrueIfSetsTransitionDrawable() {
     Transition<Drawable> defaultAnimation = mock(Transition.class);
     int duration = 200;
     DrawableCrossFadeTransition animation =
-        new DrawableCrossFadeTransition(defaultAnimation, duration);
+        new DrawableCrossFadeTransition(defaultAnimation, duration, true /*isCrossFadeEnabled*/);
   }
 }
 
diff --git a/samples/contacturi/build.gradle b/samples/contacturi/build.gradle
new file mode 100644
index 000000000..dccc94939
--- /dev/null
+++ b/samples/contacturi/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'com.android.application'
+
+dependencies {
+    compile project(':library')
+    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}"
+    compile "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}"
+}
+
+android {
+    compileSdkVersion COMPILE_SDK_VERSION as int
+    buildToolsVersion BUILD_TOOLS_VERSION as String
+
+    defaultConfig {
+        applicationId 'com.bumptech.glide.samples.contacturi'
+        minSdkVersion MIN_SDK_VERSION as int
+        targetSdkVersion TARGET_SDK_VERSION as int
+
+        versionCode 1
+        versionName '1.0'
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+}
+
+task run(type: Exec, dependsOn: 'installDebug') {
+    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"'
+    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.contacturi/.MainActivity'
+}
diff --git a/samples/contacturi/src/main/AndroidManifest.xml b/samples/contacturi/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..ecfd4c859
--- /dev/null
+++ b/samples/contacturi/src/main/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.bumptech.glide.samples.contacturi" >
+
+    <uses-permission android:name="android.permission.READ_CONTACTS" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@android:drawable/sym_def_app_icon"
+        android:label="@string/app_name"
+        android:theme="@style/Theme.AppCompat" >
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
new file mode 100644
index 000000000..23d36e183
--- /dev/null
+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java
@@ -0,0 +1,92 @@
+package com.bumptech.glide.samples.contacturi;
+
+import static android.os.Build.VERSION;
+import static android.os.Build.VERSION_CODES;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.ContentUris;
+import android.content.Intent;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract.Contacts;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.bumptech.glide.Glide;
+import com.bumptech.glide.request.RequestOptions;
+import com.bumptech.glide.request.target.Target;
+
+/**
+ * An activity that demonstrates loading photos using
+ * {@link com.bumptech.glide.load.data.StreamLocalUriFetcher content uris} through Glide.
+ * It works by making the user to choose a contact when presses a button,
+ * and after he chooses a contact with photo,
+ * We try to load both a high res image and thumbnail image of that contact with various Uris.
+ */
+public class MainActivity extends Activity {
+  private static final int REQUEST_CONTACT = 1;
+
+  private ImageView imageViewContact;
+  private ImageView imageViewLookup;
+  private ImageView imageViewPhoto;
+  private ImageView imageViewDisplayPhoto;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.activity_main);
+
+    imageViewContact = (ImageView) findViewById(R.id.image_contact);
+    imageViewLookup = (ImageView) findViewById(R.id.image_lookup);
+    imageViewPhoto = (ImageView) findViewById(R.id.image_photo);
+    imageViewDisplayPhoto = (ImageView) findViewById(R.id.image_display_photo);
+
+    findViewById(R.id.button_pick_contact).setOnClickListener(new View.OnClickListener() {
+      @Override
+      public void onClick(View v) {
+        Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
+        startActivityForResult(intent, REQUEST_CONTACT);
+      }
+    });
+  }
+
+  @Override
+  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+    if (requestCode == REQUEST_CONTACT && resultCode == RESULT_OK) {
+      final Cursor cursor = getContentResolver().query(data.getData(), null, null, null, null);
+      try {
+        if (cursor != null && cursor.moveToFirst()) {
+          final long contactId = cursor.getLong(cursor.getColumnIndex(Contacts._ID));
+          showContact(contactId);
+        }
+      } finally {
+        if (cursor != null) {
+          cursor.close();
+        }
+      }
+      return;
+    }
+    super.onActivityResult(requestCode, resultCode, data);
+  }
+
+  @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
+  private void showContact(long id) {
+    RequestOptions originalSize = new RequestOptions().override(Target.SIZE_ORIGINAL);
+
+    Uri contactUri = ContentUris.withAppendedId(Contacts.CONTENT_URI, id);
+    Glide.with(this).load(contactUri).apply(originalSize).into(imageViewContact);
+
+    Uri lookupUri = Contacts.getLookupUri(getContentResolver(), contactUri);
+    Glide.with(this).load(lookupUri).apply(originalSize).into(imageViewLookup);
+
+    Uri photoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.CONTENT_DIRECTORY);
+    Glide.with(this).load(photoUri).apply(originalSize).into(imageViewPhoto);
+
+    if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
+      Uri displayPhotoUri = Uri.withAppendedPath(contactUri, Contacts.Photo.DISPLAY_PHOTO);
+      Glide.with(this).load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);
+    }
+  }
+}
diff --git a/samples/contacturi/src/main/res/layout/activity_main.xml b/samples/contacturi/src/main/res/layout/activity_main.xml
new file mode 100644
index 000000000..fe9510388
--- /dev/null
+++ b/samples/contacturi/src/main/res/layout/activity_main.xml
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView
+        xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:tools="http://schemas.android.com/tools"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:fitsSystemWindows="true"
+        android:padding="@dimen/activity_horizontal_margin"
+        tools:context="com.bumptech.glide.samples.contacturi.MainActivity">
+    <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical">
+        <Button
+                android:id="@+id/button_pick_contact"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/pick_contact"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_contact"/>
+        <ImageView
+                android:id="@+id/image_contact"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_contact"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_lookup"/>
+        <ImageView
+                android:id="@+id/image_lookup"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_lookup"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_photo"/>
+        <ImageView
+                android:id="@+id/image_photo"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_photo"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+
+        <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_marginTop="@dimen/activity_vertical_margin"
+                android:text="@string/image_display_photo"/>
+        <ImageView
+                android:id="@+id/image_display_photo"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:contentDescription="@string/image_display_photo"
+                tools:src="@android:drawable/sym_def_app_icon"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/samples/contacturi/src/main/res/values/dimens.xml b/samples/contacturi/src/main/res/values/dimens.xml
new file mode 100644
index 000000000..47c822467
--- /dev/null
+++ b/samples/contacturi/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/samples/contacturi/src/main/res/values/strings.xml b/samples/contacturi/src/main/res/values/strings.xml
new file mode 100644
index 000000000..63bdff591
--- /dev/null
+++ b/samples/contacturi/src/main/res/values/strings.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">ContactUri Sample</string>
+    <string name="pick_contact">Pick Contact</string>
+    <string name="image_contact">Image based on contact Uri, best size on latest Android</string>
+    <string name="image_lookup">Image based on lookup Uri, same as contact Uri</string>
+    <string name="image_photo">Image based on photo Uri, thumbnail sized, usually 96x96px</string>
+    <string name="image_display_photo">Image based on display photo Uri, possibly 512x512px</string>
+</resources>
diff --git a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
index 708f68e3a..1060dce0a 100644
--- a/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java
@@ -1,7 +1,5 @@
 package com.bumptech.glide.samples.flickr;
 
-import android.content.Context;
-
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.GlideUrl;
 import com.bumptech.glide.load.model.ModelCache;
@@ -29,8 +27,7 @@
     private final ModelCache<Photo, GlideUrl> modelCache = new ModelCache<Photo, GlideUrl>(500);
 
     @Override
-    public ModelLoader<Photo, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Photo, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new FlickrModelLoader(multiFactory.build(GlideUrl.class, InputStream.class),
           modelCache);
     }
diff --git a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
index 3d27c6fe7..5e76ef724 100644
--- a/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java
@@ -1,6 +1,5 @@
 package com.bumptech.glide.samples.giphy;
 
-import android.content.Context;
 import android.text.TextUtils;
 
 import com.bumptech.glide.load.Options;
@@ -31,8 +30,7 @@ public boolean handles(Api.GifResult model) {
 
 
     @Override
-    public ModelLoader<Api.GifResult, InputStream> build(Context context,
-        MultiModelLoaderFactory multiFactory) {
+    public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
       return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
     }
 
diff --git a/settings.gradle b/settings.gradle
index c219743ba..d02c6fbd9 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -16,6 +16,7 @@ include ':samples:flickr'
 include ':samples:giphy'
 include ':samples:svg'
 include ':samples:gallery'
+include ':samples:contacturi'
 include ':integration'
 include ':integration:volley'
 include ':integration:okhttp'
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
index bab7cd168..9fe113b01 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java
@@ -1,60 +1,15 @@
 package com.bumptech.glide.gifdecoder;
 
-/**
- * Copyright (c) 2013 Xcellent Creations, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-import android.annotation.TargetApi;
 import android.graphics.Bitmap;
-import android.os.Build;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.util.Log;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.util.Arrays;
 
 /**
- * Reads frame data from a GIF image source and decodes it into individual frames for animation
- * purposes.  Image data can be read from either and InputStream source or a byte[].
- *
- * <p>This class is optimized for running animations with the frames, there are no methods to get
- * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
- * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
- * in the animation sequence.
- *
- * <p>The animation must be manually moved forward using {@link #advance()} before requesting the
- * next frame.  This method must also be called before you request the first frame or an error
- * will occur.
- *
- * <p>Implementation adapted from sample code published in Lyons. (2004). <em>Java for
- * Programmers</em>, republished under the MIT Open Source License
+ * Shared interface for GIF decoders.
  */
-public class GifDecoder {
-  private static final String TAG = GifDecoder.class.getSimpleName();
+public interface GifDecoder {
 
   /**
    * File read status: No errors.
@@ -72,70 +27,6 @@
    * Unable to fully decode the current frame.
    */
   public static final int STATUS_PARTIAL_DECODE = 3;
-  /**
-   * max decoder pixel stack size.
-   */
-  private static final int MAX_STACK_SIZE = 4096;
-
-  /**
-   * GIF Disposal Method meaning take no action.
-   */
-  private static final int DISPOSAL_UNSPECIFIED = 0;
-  /**
-   * GIF Disposal Method meaning leave canvas from previous frame.
-   */
-  private static final int DISPOSAL_NONE = 1;
-  /**
-   * GIF Disposal Method meaning clear canvas to background color.
-   */
-  private static final int DISPOSAL_BACKGROUND = 2;
-  /**
-   * GIF Disposal Method meaning clear canvas to frame before last.
-   */
-  private static final int DISPOSAL_PREVIOUS = 3;
-
-  private static final int NULL_CODE = -1;
-
-  private static final int INITIAL_FRAME_POINTER = -1;
-
-  private static final int BYTES_PER_INTEGER = 4;
-
-  // Global File Header values and parsing flags.
-  // Active color table.
-  private int[] act;
-
-  // Raw GIF data from input source.
-  private ByteBuffer rawData;
-
-  // Raw data read working array.
-  private byte[] block;
-
-  // Temporary buffer for block reading. Reads 16k chunks from the native buffer for processing,
-  // to greatly reduce JNI overhead.
-  private static final int WORK_BUFFER_SIZE = 16384;
-  @Nullable private byte[] workBuffer;
-  private int workBufferSize = 0;
-  private int workBufferPosition = 0;
-
-  private GifHeaderParser parser;
-
-  // LZW decoder working arrays.
-  private short[] prefix;
-  private byte[] suffix;
-  private byte[] pixelStack;
-  private byte[] mainPixels;
-  private int[] mainScratch;
-
-  private int framePointer;
-  private GifHeader header;
-  private BitmapProvider bitmapProvider;
-  private Bitmap previousImage;
-  private boolean savePrevious;
-  private int status;
-  private int sampleSize;
-  private int downsampledHeight;
-  private int downsampledWidth;
-  private boolean isFirstFrameTransparent;
 
   /**
    * An interface that can be used to provide reused {@link android.graphics.Bitmap}s to avoid GCs
@@ -183,32 +74,11 @@
     void release(int[] array);
   }
 
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
-    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
-  }
-
-  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
-      int sampleSize) {
-    this(provider);
-    setData(gifHeader, rawData, sampleSize);
-  }
-
-  public GifDecoder(BitmapProvider provider) {
-    this.bitmapProvider = provider;
-    header = new GifHeader();
-  }
+  int getWidth();
 
-  public int getWidth() {
-    return header.width;
-  }
+  int getHeight();
 
-  public int getHeight() {
-    return header.height;
-  }
-
-  public ByteBuffer getData() {
-    return rawData;
-  }
+  ByteBuffer getData();
 
   /**
    * Returns the current status of the decoder.
@@ -217,16 +87,12 @@ public ByteBuffer getData() {
    * was decoded successfully and/or completely. Format and open failures persist across frames.
    * </p>
    */
-  public int getStatus() {
-    return status;
-  }
+  int getStatus();
 
   /**
    * Move the animation frame counter forward.
    */
-  public void advance() {
-    framePointer = (framePointer + 1) % header.frameCount;
-  }
+  void advance();
 
   /**
    * Gets display duration for specified frame.
@@ -234,134 +100,52 @@ public void advance() {
    * @param n int index of frame.
    * @return delay in milliseconds.
    */
-  public int getDelay(int n) {
-    int delay = -1;
-    if ((n >= 0) && (n < header.frameCount)) {
-      delay = header.frames.get(n).delay;
-    }
-    return delay;
-  }
+  int getDelay(int n);
 
   /**
    * Gets display duration for the upcoming frame in ms.
    */
-  public int getNextDelay() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      return 0;
-    }
-
-    return getDelay(framePointer);
-  }
+  int getNextDelay();
 
   /**
    * Gets the number of frames read from file.
    *
    * @return frame count.
    */
-  public int getFrameCount() {
-    return header.frameCount;
-  }
+  int getFrameCount();
 
   /**
    * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
    *
    * @return frame index.
    */
-  public int getCurrentFrameIndex() {
-    return framePointer;
-  }
+  int getCurrentFrameIndex();
 
   /**
    * Resets the frame pointer to before the 0th frame, as if we'd never used this decoder to
    * decode any frames.
    */
-  public void resetFrameIndex() {
-    framePointer = INITIAL_FRAME_POINTER;
-  }
+  void resetFrameIndex();
 
   /**
    * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
    *
    * @return iteration count if one was specified, else 1.
    */
-  public int getLoopCount() {
-    return header.loopCount;
-  }
+  int getLoopCount();
 
   /**
    * Returns an estimated byte size for this decoder based on the data provided to {@link
    * #setData(GifHeader, byte[])}, as well as internal buffers.
    */
-  public int getByteSize() {
-    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
-  }
+  int getByteSize();
 
   /**
    * Get the next frame in the animation sequence.
    *
    * @return Bitmap representation of frame.
    */
-  public synchronized Bitmap getNextFrame() {
-    if (header.frameCount <= 0 || framePointer < 0) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
-            + framePointer);
-      }
-      status = STATUS_FORMAT_ERROR;
-    }
-    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "Unable to decode frame, status=" + status);
-      }
-      return null;
-    }
-    status = STATUS_OK;
-
-    GifFrame currentFrame = header.frames.get(framePointer);
-    GifFrame previousFrame = null;
-    int previousIndex = framePointer - 1;
-    if (previousIndex >= 0) {
-      previousFrame = header.frames.get(previousIndex);
-    }
-
-    final int savedBgColor = header.bgColor;
-
-    // Set the appropriate color table.
-    if (currentFrame.lct == null) {
-      act = header.gct;
-    } else {
-      act = currentFrame.lct;
-      if (header.bgIndex == currentFrame.transIndex) {
-        header.bgColor = 0;
-      }
-    }
-
-    int save = 0;
-    if (currentFrame.transparency) {
-      save = act[currentFrame.transIndex];
-      // Set transparent color if specified.
-      act[currentFrame.transIndex] = 0;
-    }
-    if (act == null) {
-      if (Log.isLoggable(TAG, Log.DEBUG)) {
-        Log.d(TAG, "No Valid Color Table");
-      }
-      // No color table defined.
-      status = STATUS_FORMAT_ERROR;
-      return null;
-    }
-
-    // Transfer pixel data to image.
-    Bitmap result = setPixels(currentFrame, previousFrame);
-
-    // Reset the transparent pixel in the color table
-    if (currentFrame.transparency) {
-      act[currentFrame.transIndex] = save;
-    }
-    header.bgColor = savedBgColor;
-
-    return result;
-  }
+  Bitmap getNextFrame();
 
   /**
    * Reads GIF image from stream.
@@ -369,108 +153,15 @@ public synchronized Bitmap getNextFrame() {
    * @param is containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public int read(InputStream is, int contentLength) {
-    if (is != null) {
-      try {
-        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
-        int nRead;
-        byte[] data = new byte[16384];
-        while ((nRead = is.read(data, 0, data.length)) != -1) {
-          buffer.write(data, 0, nRead);
-        }
-        buffer.flush();
+  int read(InputStream is, int contentLength);
 
-        read(buffer.toByteArray());
-      } catch (IOException e) {
-        Log.w(TAG, "Error reading data from stream", e);
-      }
-    } else {
-      status = STATUS_OPEN_ERROR;
-    }
+  void clear();
 
-    try {
-      if (is != null) {
-        is.close();
-      }
-    } catch (IOException e) {
-      Log.w(TAG, "Error closing stream", e);
-    }
+  void setData(GifHeader header, byte[] data);
 
-    return status;
-  }
+  void setData(GifHeader header, ByteBuffer buffer);
 
-  public void clear() {
-    header = null;
-    if (mainPixels != null) {
-      bitmapProvider.release(mainPixels);
-    }
-    if (mainScratch != null) {
-      bitmapProvider.release(mainScratch);
-    }
-    if (previousImage != null) {
-      bitmapProvider.release(previousImage);
-    }
-    previousImage = null;
-    rawData = null;
-    isFirstFrameTransparent = false;
-    if (block != null) {
-      bitmapProvider.release(block);
-    }
-    if (workBuffer != null) {
-      bitmapProvider.release(workBuffer);
-    }
-  }
-
-  public synchronized void setData(GifHeader header, byte[] data) {
-    setData(header, ByteBuffer.wrap(data));
-  }
-
-  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
-    setData(header, buffer, 1);
-  }
-
-  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
-    if (sampleSize <= 0) {
-      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
-    }
-    // Make sure sample size is a power of 2.
-    sampleSize = Integer.highestOneBit(sampleSize);
-    this.status = STATUS_OK;
-    this.header = header;
-    isFirstFrameTransparent = false;
-    framePointer = INITIAL_FRAME_POINTER;
-    // Initialize the raw data buffer.
-    rawData = buffer.asReadOnlyBuffer();
-    rawData.position(0);
-    rawData.order(ByteOrder.LITTLE_ENDIAN);
-
-    // No point in specially saving an old frame if we're never going to use it.
-    savePrevious = false;
-    for (GifFrame frame : header.frames) {
-      if (frame.dispose == DISPOSAL_PREVIOUS) {
-        savePrevious = true;
-        break;
-      }
-    }
-
-    this.sampleSize = sampleSize;
-    // Now that we know the size, init scratch arrays.
-    // TODO: Find a way to avoid this entirely or at least downsample it
-    // (either should be possible).
-    mainPixels = bitmapProvider.obtainByteArray(header.width * header.height);
-    mainScratch =
-        bitmapProvider.obtainIntArray((header.width / sampleSize) * (header.height / sampleSize));
-    downsampledWidth = header.width / sampleSize;
-    downsampledHeight = header.height / sampleSize;
-  }
-
-  private GifHeaderParser getHeaderParser() {
-    if (parser == null) {
-      parser = new GifHeaderParser();
-    }
-    return parser;
-  }
+  void setData(GifHeader header, ByteBuffer buffer, int sampleSize);
 
   /**
    * Reads GIF image from byte array.
@@ -478,385 +169,6 @@ private GifHeaderParser getHeaderParser() {
    * @param data containing GIF file.
    * @return read status code (0 = no errors).
    */
-  public synchronized int read(byte[] data) {
-    this.header = getHeaderParser().setData(data).parseHeader();
-    if (data != null) {
-      setData(header, data);
-    }
-
-    return status;
-  }
-
-  /**
-   * Creates new frame image from current data (and previous frames as specified by their
-   * disposition codes).
-   */
-  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
-    // Final location of blended pixels.
-    final int[] dest = mainScratch;
-
-    // clear all pixels when meet first frame
-    if (previousFrame == null) {
-      Arrays.fill(dest, 0);
-    }
-
-    // fill in starting image contents based on last image's dispose code
-    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
-      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
-      // mainScratch and therefore so will our dest array.
-      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
-        // Start with a canvas filled with the background color
-        int c = 0;
-        if (!currentFrame.transparency) {
-          c = header.bgColor;
-        } else if (framePointer == 0) {
-          // TODO: We should check and see if all individual pixels are replaced. If they are, the
-          // first frame isn't actually transparent. For now, it's simpler and safer to assume
-          // drawing a transparent background means the GIF contains transparency.
-          isFirstFrameTransparent = true;
-        }
-        Arrays.fill(dest, c);
-      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
-        // Start with the previous frame
-        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-            downsampledHeight);
-      }
-    }
-
-    // Decode pixels for this frame into the global pixels[] scratch.
-    decodeBitmapData(currentFrame);
-
-    int downsampledIH = currentFrame.ih / sampleSize;
-    int downsampledIY = currentFrame.iy / sampleSize;
-    int downsampledIW = currentFrame.iw / sampleSize;
-    int downsampledIX = currentFrame.ix / sampleSize;
-    // Copy each source line to the appropriate place in the destination.
-    int pass = 1;
-    int inc = 8;
-    int iline = 0;
-    boolean isFirstFrame = framePointer == 0;
-    for (int i = 0; i < downsampledIH; i++) {
-      int line = i;
-      if (currentFrame.interlace) {
-        if (iline >= downsampledIH) {
-          pass++;
-          switch (pass) {
-            case 2:
-              iline = 4;
-              break;
-            case 3:
-              iline = 2;
-              inc = 4;
-              break;
-            case 4:
-              iline = 1;
-              inc = 2;
-              break;
-            default:
-              break;
-          }
-        }
-        line = iline;
-        iline += inc;
-      }
-      line += downsampledIY;
-      if (line < downsampledHeight) {
-        int k = line * downsampledWidth;
-        // Start of line in dest.
-        int dx = k + downsampledIX;
-        // End of dest line.
-        int dlim = dx + downsampledIW;
-        if (k + downsampledWidth < dlim) {
-          // Past dest edge.
-          dlim = k + downsampledWidth;
-        }
-        // Start of line in source.
-        int sx = i * sampleSize * currentFrame.iw;
-        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
-        while (dx < dlim) {
-          // Map color and insert in destination.
-          int averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
-          if (averageColor != 0) {
-            dest[dx] = averageColor;
-          } else if (!isFirstFrameTransparent && isFirstFrame) {
-            isFirstFrameTransparent = true;
-          }
-          sx += sampleSize;
-          dx++;
-        }
-      }
-    }
-
-    // Copy pixels into previous image
-    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
-        || currentFrame.dispose == DISPOSAL_NONE)) {
-      if (previousImage == null) {
-        previousImage = getNextBitmap();
-      }
-      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
-          downsampledHeight);
-    }
-
-    // Set pixels for current image.
-    Bitmap result = getNextBitmap();
-    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
-    return result;
-  }
-
-  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
-      int currentFrameIw) {
-    int alphaSum = 0;
-    int redSum = 0;
-    int greenSum = 0;
-    int blueSum = 0;
-
-    int totalAdded = 0;
-    // Find the pixels in the current row.
-    for (int i = positionInMainPixels;
-        i < positionInMainPixels + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    // Find the pixels in the next row.
-    for (int i = positionInMainPixels + currentFrameIw;
-        i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
-        && i < maxPositionInMainPixels; i++) {
-      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
-      int currentColor = act[currentColorIndex];
-      if (currentColor != 0) {
-        alphaSum += currentColor >> 24 & 0x000000ff;
-        redSum += currentColor >> 16 & 0x000000ff;
-        greenSum += currentColor >> 8 & 0x000000ff;
-        blueSum += currentColor & 0x000000ff;
-        totalAdded++;
-      }
-    }
-    if (totalAdded == 0) {
-      return 0;
-    } else {
-      return ((alphaSum / totalAdded) << 24)
-          | ((redSum / totalAdded) << 16)
-          | ((greenSum / totalAdded) << 8)
-          | (blueSum / totalAdded);
-     }
-  }
-
-  /**
-   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
-   */
-  private void decodeBitmapData(GifFrame frame) {
-    workBufferSize = 0;
-    workBufferPosition = 0;
-    if (frame != null) {
-      // Jump to the frame start position.
-      rawData.position(frame.bufferFrameStart);
-    }
-
-    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
-    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
-        i, datum,
-        dataSize, first, top, bi, pi;
-
-    if (mainPixels == null || mainPixels.length < npix) {
-      // Allocate new pixel array.
-      mainPixels = bitmapProvider.obtainByteArray(npix);
-    }
-    if (prefix == null) {
-      prefix = new short[MAX_STACK_SIZE];
-    }
-    if (suffix == null) {
-      suffix = new byte[MAX_STACK_SIZE];
-    }
-    if (pixelStack == null) {
-      pixelStack = new byte[MAX_STACK_SIZE + 1];
-    }
-
-    // Initialize GIF data stream decoder.
-    dataSize = readByte();
-    clear = 1 << dataSize;
-    endOfInformation = clear + 1;
-    available = clear + 2;
-    oldCode = NULL_CODE;
-    codeSize = dataSize + 1;
-    codeMask = (1 << codeSize) - 1;
-    for (code = 0; code < clear; code++) {
-      // XXX ArrayIndexOutOfBoundsException.
-      prefix[code] = 0;
-      suffix[code] = (byte) code;
-    }
+  int read(byte[] data);
 
-    // Decode GIF pixel stream.
-    datum = bits = count = first = top = pi = bi = 0;
-    for (i = 0; i < npix; ) {
-      // Load bytes until there are enough bits for a code.
-      if (count == 0) {
-        // Read a new data block.
-        count = readBlock();
-        if (count <= 0) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-        bi = 0;
-      }
-
-      datum += (((int) block[bi]) & 0xff) << bits;
-      bits += 8;
-      bi++;
-      count--;
-
-      while (bits >= codeSize) {
-        // Get the next code.
-        code = datum & codeMask;
-        datum >>= codeSize;
-        bits -= codeSize;
-
-        // Interpret the code.
-        if (code == clear) {
-          // Reset decoder.
-          codeSize = dataSize + 1;
-          codeMask = (1 << codeSize) - 1;
-          available = clear + 2;
-          oldCode = NULL_CODE;
-          continue;
-        }
-
-        if (code > available) {
-          status = STATUS_PARTIAL_DECODE;
-          break;
-        }
-
-        if (code == endOfInformation) {
-          break;
-        }
-
-        if (oldCode == NULL_CODE) {
-          pixelStack[top++] = suffix[code];
-          oldCode = code;
-          first = code;
-          continue;
-        }
-        inCode = code;
-        if (code >= available) {
-          pixelStack[top++] = (byte) first;
-          code = oldCode;
-        }
-        while (code >= clear) {
-          pixelStack[top++] = suffix[code];
-          code = prefix[code];
-        }
-        first = ((int) suffix[code]) & 0xff;
-        pixelStack[top++] = (byte) first;
-
-        // Add a new string to the string table.
-        if (available < MAX_STACK_SIZE) {
-          prefix[available] = (short) oldCode;
-          suffix[available] = (byte) first;
-          available++;
-          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
-            codeSize++;
-            codeMask += available;
-          }
-        }
-        oldCode = inCode;
-
-        while (top > 0) {
-          // Pop a pixel off the pixel stack.
-          mainPixels[pi++] = pixelStack[--top];
-          i++;
-        }
-      }
-    }
-
-    // Clear missing pixels.
-    for (i = pi; i < npix; i++) {
-      mainPixels[i] = 0;
-    }
-  }
-
-  /**
-   * Reads the next chunk for the intermediate work buffer.
-   */
-  private void readChunkIfNeeded() {
-    if (workBufferSize > workBufferPosition) {
-      return;
-    }
-    if (workBuffer == null) {
-      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
-    }
-    workBufferPosition = 0;
-    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
-    rawData.get(workBuffer, 0, workBufferSize);
-  }
-
-  /**
-   * Reads a single byte from the input stream.
-   */
-  private int readByte() {
-    try {
-      readChunkIfNeeded();
-      return workBuffer[workBufferPosition++] & 0xFF;
-    } catch (Exception e) {
-      status = STATUS_FORMAT_ERROR;
-      return 0;
-    }
-  }
-
-  /**
-   * Reads next variable length block from input.
-   *
-   * @return number of bytes stored in "buffer".
-   */
-  private int readBlock() {
-    int blockSize = readByte();
-    if (blockSize > 0) {
-      try {
-        if (block == null) {
-          block = bitmapProvider.obtainByteArray(255);
-        }
-        final int remaining = workBufferSize - workBufferPosition;
-        if (remaining >= blockSize) {
-          // Block can be read from the current work buffer.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
-          workBufferPosition += blockSize;
-        } else if (rawData.remaining() + remaining >= blockSize) {
-          // Block can be read in two passes.
-          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
-          workBufferPosition = workBufferSize;
-          readChunkIfNeeded();
-          final int secondHalfRemaining = blockSize - remaining;
-          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
-          workBufferPosition += secondHalfRemaining;
-        } else {
-          status = STATUS_FORMAT_ERROR;
-        }
-      } catch (Exception e) {
-        Log.w(TAG, "Error Reading Block", e);
-        status = STATUS_FORMAT_ERROR;
-      }
-    }
-    return blockSize;
-  }
-
-  private Bitmap getNextBitmap() {
-    Bitmap.Config config = isFirstFrameTransparent
-        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
-    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
-    setAlpha(result);
-    return result;
-  }
-
-  @TargetApi(12)
-  private static void setAlpha(Bitmap bitmap) {
-    if (Build.VERSION.SDK_INT >= 12) {
-      bitmap.setHasAlpha(true);
-    }
-  }
 }
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
index 5b57212ec..6e36c08fd 100644
--- a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java
@@ -33,7 +33,6 @@
   int bgIndex;
   // Pixel aspect ratio.
   int pixelAspect;
-  //TODO: this is set both during reading the header and while decoding frames...
   int bgColor;
   int loopCount;
 
diff --git a/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
new file mode 100644
index 000000000..16f48a976
--- /dev/null
+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java
@@ -0,0 +1,773 @@
+package com.bumptech.glide.gifdecoder;
+
+/**
+ * Copyright (c) 2013 Xcellent Creations, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+import android.annotation.TargetApi;
+import android.graphics.Bitmap;
+import android.os.Build;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+/**
+ * Reads frame data from a GIF image source and decodes it into individual frames for animation
+ * purposes.  Image data can be read from either and InputStream source or a byte[].
+ *
+ * <p>This class is optimized for running animations with the frames, there are no methods to get
+ * individual frame images, only to decode the next frame in the animation sequence.  Instead, it
+ * lowers its memory footprint by only housing the minimum data necessary to decode the next frame
+ * in the animation sequence.
+ *
+ * <p>The animation must be manually moved forward using {@link #advance()} before requesting the
+ * next frame.  This method must also be called before you request the first frame or an error
+ * will occur.
+ *
+ * <p>Implementation adapted from sample code published in Lyons. (2004). <em>Java for
+ * Programmers</em>, republished under the MIT Open Source License
+ */
+public class StandardGifDecoder implements GifDecoder {
+  private static final String TAG = StandardGifDecoder.class.getSimpleName();
+
+  /**
+   * max decoder pixel stack size.
+   */
+  private static final int MAX_STACK_SIZE = 4096;
+
+  /**
+   * GIF Disposal Method meaning take no action.
+   */
+  private static final int DISPOSAL_UNSPECIFIED = 0;
+  /**
+   * GIF Disposal Method meaning leave canvas from previous frame.
+   */
+  private static final int DISPOSAL_NONE = 1;
+  /**
+   * GIF Disposal Method meaning clear canvas to background color.
+   */
+  private static final int DISPOSAL_BACKGROUND = 2;
+  /**
+   * GIF Disposal Method meaning clear canvas to frame before last.
+   */
+  private static final int DISPOSAL_PREVIOUS = 3;
+
+  private static final int NULL_CODE = -1;
+
+  private static final int INITIAL_FRAME_POINTER = -1;
+
+  private static final int BYTES_PER_INTEGER = Integer.SIZE / 8;
+
+  // Global File Header values and parsing flags.
+  // Active color table.
+  // Maximum size is 256, see GifHeaderParser.readColorTable
+  private int[] act;
+  // Private color table that can be modified if needed
+  private final int[] pct = new int[256];
+
+  // Raw GIF data from input source.
+  private ByteBuffer rawData;
+
+  // Raw data read working array.
+  private byte[] block;
+
+  // Temporary buffer for block reading. Reads 16k chunks from the native buffer for processing,
+  // to greatly reduce JNI overhead.
+  private static final int WORK_BUFFER_SIZE = 16384;
+  @Nullable private byte[] workBuffer;
+  private int workBufferSize = 0;
+  private int workBufferPosition = 0;
+
+  private GifHeaderParser parser;
+
+  // LZW decoder working arrays.
+  private short[] prefix;
+  private byte[] suffix;
+  private byte[] pixelStack;
+  private byte[] mainPixels;
+  private int[] mainScratch;
+
+  private int framePointer;
+  private GifHeader header;
+  private GifDecoder.BitmapProvider bitmapProvider;
+  private Bitmap previousImage;
+  private boolean savePrevious;
+  private int status;
+  private int sampleSize;
+  private int downsampledHeight;
+  private int downsampledWidth;
+  private boolean isFirstFrameTransparent;
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
+    this(provider, gifHeader, rawData, 1 /*sampleSize*/);
+  }
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData,
+      int sampleSize) {
+    this(provider);
+    setData(gifHeader, rawData, sampleSize);
+  }
+
+  public StandardGifDecoder(
+      GifDecoder.BitmapProvider provider) {
+    this.bitmapProvider = provider;
+    header = new GifHeader();
+  }
+
+  @Override
+  public int getWidth() {
+    return header.width;
+  }
+
+  @Override
+  public int getHeight() {
+    return header.height;
+  }
+
+  @Override
+  public ByteBuffer getData() {
+    return rawData;
+  }
+
+  @Override
+  public int getStatus() {
+    return status;
+  }
+
+  @Override
+  public void advance() {
+    framePointer = (framePointer + 1) % header.frameCount;
+  }
+
+  @Override
+  public int getDelay(int n) {
+    int delay = -1;
+    if ((n >= 0) && (n < header.frameCount)) {
+      delay = header.frames.get(n).delay;
+    }
+    return delay;
+  }
+
+  @Override
+  public int getNextDelay() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      return 0;
+    }
+
+    return getDelay(framePointer);
+  }
+
+  @Override
+  public int getFrameCount() {
+    return header.frameCount;
+  }
+
+  @Override
+  public int getCurrentFrameIndex() {
+    return framePointer;
+  }
+
+  @Override
+  public void resetFrameIndex() {
+    framePointer = INITIAL_FRAME_POINTER;
+  }
+
+  @Override
+  public int getLoopCount() {
+    return header.loopCount;
+  }
+
+  @Override
+  public int getByteSize() {
+    return rawData.limit() + mainPixels.length + (mainScratch.length * BYTES_PER_INTEGER);
+  }
+
+  @Override
+  public synchronized Bitmap getNextFrame() {
+    if (header.frameCount <= 0 || framePointer < 0) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
+            + framePointer);
+      }
+      status = STATUS_FORMAT_ERROR;
+    }
+    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "Unable to decode frame, status=" + status);
+      }
+      return null;
+    }
+    status = STATUS_OK;
+
+    GifFrame currentFrame = header.frames.get(framePointer);
+    GifFrame previousFrame = null;
+    int previousIndex = framePointer - 1;
+    if (previousIndex >= 0) {
+      previousFrame = header.frames.get(previousIndex);
+    }
+
+    // Set the appropriate color table.
+    act = currentFrame.lct != null ? currentFrame.lct : header.gct;
+    if (act == null) {
+      if (Log.isLoggable(TAG, Log.DEBUG)) {
+        Log.d(TAG, "No Valid Color Table");
+      }
+      // No color table defined.
+      status = STATUS_FORMAT_ERROR;
+      return null;
+    }
+
+    // Reset the transparent pixel in the color table
+    if (currentFrame.transparency) {
+      // Prepare local copy of color table ("pct = act"), see #1068
+      System.arraycopy(act, 0, pct, 0, act.length);
+      // Forget about act reference from shared header object, use copied version
+      act = pct;
+      // Set transparent color if specified.
+      act[currentFrame.transIndex] = 0;
+    }
+
+    // Transfer pixel data to image.
+    return setPixels(currentFrame, previousFrame);
+  }
+
+  @Override
+  public int read(InputStream is, int contentLength) {
+    if (is != null) {
+      try {
+        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
+        int nRead;
+        byte[] data = new byte[16384];
+        while ((nRead = is.read(data, 0, data.length)) != -1) {
+          buffer.write(data, 0, nRead);
+        }
+        buffer.flush();
+
+        read(buffer.toByteArray());
+      } catch (IOException e) {
+        Log.w(TAG, "Error reading data from stream", e);
+      }
+    } else {
+      status = STATUS_OPEN_ERROR;
+    }
+
+    try {
+      if (is != null) {
+        is.close();
+      }
+    } catch (IOException e) {
+      Log.w(TAG, "Error closing stream", e);
+    }
+
+    return status;
+  }
+
+  @Override
+  public void clear() {
+    header = null;
+    if (mainPixels != null) {
+      bitmapProvider.release(mainPixels);
+    }
+    if (mainScratch != null) {
+      bitmapProvider.release(mainScratch);
+    }
+    if (previousImage != null) {
+      bitmapProvider.release(previousImage);
+    }
+    previousImage = null;
+    rawData = null;
+    isFirstFrameTransparent = false;
+    if (block != null) {
+      bitmapProvider.release(block);
+    }
+    if (workBuffer != null) {
+      bitmapProvider.release(workBuffer);
+    }
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, byte[] data) {
+    setData(header, ByteBuffer.wrap(data));
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
+    setData(header, buffer, 1);
+  }
+
+  @Override
+  public synchronized void setData(GifHeader header, ByteBuffer buffer, int sampleSize) {
+    if (sampleSize <= 0) {
+      throw new IllegalArgumentException("Sample size must be >=0, not: " + sampleSize);
+    }
+    // Make sure sample size is a power of 2.
+    sampleSize = Integer.highestOneBit(sampleSize);
+    this.status = STATUS_OK;
+    this.header = header;
+    isFirstFrameTransparent = false;
+    framePointer = INITIAL_FRAME_POINTER;
+    // Initialize the raw data buffer.
+    rawData = buffer.asReadOnlyBuffer();
+    rawData.position(0);
+    rawData.order(ByteOrder.LITTLE_ENDIAN);
+
+    // No point in specially saving an old frame if we're never going to use it.
+    savePrevious = false;
+    for (GifFrame frame : header.frames) {
+      if (frame.dispose == DISPOSAL_PREVIOUS) {
+        savePrevious = true;
+        break;
+      }
+    }
+
+    this.sampleSize = sampleSize;
+    downsampledWidth = header.width / sampleSize;
+    downsampledHeight = header.height / sampleSize;
+    // Now that we know the size, init scratch arrays.
+    // TODO: Find a way to avoid this entirely or at least downsample it
+    // (either should be possible).
+    mainPixels = bitmapProvider.obtainByteArray(header.width * header.height);
+    mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);
+  }
+
+  private GifHeaderParser getHeaderParser() {
+    if (parser == null) {
+      parser = new GifHeaderParser();
+    }
+    return parser;
+  }
+
+  @Override
+  public synchronized int read(byte[] data) {
+    this.header = getHeaderParser().setData(data).parseHeader();
+    if (data != null) {
+      setData(header, data);
+    }
+
+    return status;
+  }
+
+  /**
+   * Creates new frame image from current data (and previous frames as specified by their
+   * disposition codes).
+   */
+  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {
+    // Final location of blended pixels.
+    final int[] dest = mainScratch;
+
+    // clear all pixels when meet first frame
+    if (previousFrame == null) {
+      Arrays.fill(dest, 0);
+    }
+
+    // fill in starting image contents based on last image's dispose code
+    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
+      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
+      // mainScratch and therefore so will our dest array.
+      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
+        // Start with a canvas filled with the background color
+        int c = 0;
+        if (!currentFrame.transparency) {
+          c = header.bgColor;
+          if (currentFrame.lct != null && header.bgIndex == currentFrame.transIndex) {
+            c = 0;
+          }
+        } else if (framePointer == 0) {
+          // TODO: We should check and see if all individual pixels are replaced. If they are, the
+          // first frame isn't actually transparent. For now, it's simpler and safer to assume
+          // drawing a transparent background means the GIF contains transparency.
+          isFirstFrameTransparent = true;
+        }
+        // The area used by the graphic must be restored to the background color.
+        int downsampledIH = previousFrame.ih / sampleSize;
+        int downsampledIY = previousFrame.iy / sampleSize;
+        int downsampledIW = previousFrame.iw / sampleSize;
+        int downsampledIX = previousFrame.ix / sampleSize;
+        int topLeft = downsampledIY * downsampledWidth + downsampledIX;
+        int bottomLeft = topLeft + downsampledIH * downsampledWidth;
+        for (int left = topLeft; left < bottomLeft; left += downsampledWidth) {
+          int right = left + downsampledIW;
+          for (int pointer = left; pointer < right; pointer++) {
+            dest[pointer] = c;
+          }
+        }
+      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
+        // Start with the previous frame
+        previousImage.getPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+            downsampledHeight);
+      }
+    }
+
+    // Decode pixels for this frame into the global pixels[] scratch.
+    decodeBitmapData(currentFrame);
+
+    int downsampledIH = currentFrame.ih / sampleSize;
+    int downsampledIY = currentFrame.iy / sampleSize;
+    int downsampledIW = currentFrame.iw / sampleSize;
+    int downsampledIX = currentFrame.ix / sampleSize;
+    // Copy each source line to the appropriate place in the destination.
+    int pass = 1;
+    int inc = 8;
+    int iline = 0;
+    boolean isFirstFrame = framePointer == 0;
+    for (int i = 0; i < downsampledIH; i++) {
+      int line = i;
+      if (currentFrame.interlace) {
+        if (iline >= downsampledIH) {
+          pass++;
+          switch (pass) {
+            case 2:
+              iline = 4;
+              break;
+            case 3:
+              iline = 2;
+              inc = 4;
+              break;
+            case 4:
+              iline = 1;
+              inc = 2;
+              break;
+            default:
+              break;
+          }
+        }
+        line = iline;
+        iline += inc;
+      }
+      line += downsampledIY;
+      if (line < downsampledHeight) {
+        int k = line * downsampledWidth;
+        // Start of line in dest.
+        int dx = k + downsampledIX;
+        // End of dest line.
+        int dlim = dx + downsampledIW;
+        if (k + downsampledWidth < dlim) {
+          // Past dest edge.
+          dlim = k + downsampledWidth;
+        }
+        // Start of line in source.
+        int sx = i * sampleSize * currentFrame.iw;
+        int maxPositionInSource = sx + ((dlim - dx) * sampleSize);
+        while (dx < dlim) {
+          // Map color and insert in destination.
+          int averageColor;
+          if (sampleSize == 1) {
+            int currentColorIndex = ((int) mainPixels[sx]) & 0xff;
+            averageColor = act[currentColorIndex];
+          } else {
+            // TODO: This is substantially slower (up to 50ms per frame) than just grabbing the
+            // current color index above, even with a sample size of 1.
+            averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);
+          }
+          if (averageColor != 0) {
+            dest[dx] = averageColor;
+          } else if (!isFirstFrameTransparent && isFirstFrame) {
+            isFirstFrameTransparent = true;
+          }
+          sx += sampleSize;
+          dx++;
+        }
+      }
+    }
+
+    // Copy pixels into previous image
+    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
+        || currentFrame.dispose == DISPOSAL_NONE)) {
+      if (previousImage == null) {
+        previousImage = getNextBitmap();
+      }
+      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,
+          downsampledHeight);
+    }
+
+    // Set pixels for current image.
+    Bitmap result = getNextBitmap();
+    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);
+    return result;
+  }
+
+  private int averageColorsNear(int positionInMainPixels, int maxPositionInMainPixels,
+      int currentFrameIw) {
+    int alphaSum = 0;
+    int redSum = 0;
+    int greenSum = 0;
+    int blueSum = 0;
+
+    int totalAdded = 0;
+    // Find the pixels in the current row.
+    for (int i = positionInMainPixels;
+        i < positionInMainPixels + sampleSize && i < mainPixels.length
+        && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & 0x000000ff;
+        redSum += currentColor >> 16 & 0x000000ff;
+        greenSum += currentColor >> 8 & 0x000000ff;
+        blueSum += currentColor & 0x000000ff;
+        totalAdded++;
+      }
+    }
+    // Find the pixels in the next row.
+    for (int i = positionInMainPixels + currentFrameIw;
+        i < positionInMainPixels + currentFrameIw + sampleSize && i < mainPixels.length
+        && i < maxPositionInMainPixels; i++) {
+      int currentColorIndex = ((int) mainPixels[i]) & 0xff;
+      int currentColor = act[currentColorIndex];
+      if (currentColor != 0) {
+        alphaSum += currentColor >> 24 & 0x000000ff;
+        redSum += currentColor >> 16 & 0x000000ff;
+        greenSum += currentColor >> 8 & 0x000000ff;
+        blueSum += currentColor & 0x000000ff;
+        totalAdded++;
+      }
+    }
+    if (totalAdded == 0) {
+      return 0;
+    } else {
+      return ((alphaSum / totalAdded) << 24)
+          | ((redSum / totalAdded) << 16)
+          | ((greenSum / totalAdded) << 8)
+          | (blueSum / totalAdded);
+     }
+  }
+
+  /**
+   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
+   */
+  private void decodeBitmapData(GifFrame frame) {
+    workBufferSize = 0;
+    workBufferPosition = 0;
+    if (frame != null) {
+      // Jump to the frame start position.
+      rawData.position(frame.bufferFrameStart);
+    }
+
+    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
+    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
+        i, datum,
+        dataSize, first, top, bi, pi;
+
+    if (mainPixels == null || mainPixels.length < npix) {
+      // Allocate new pixel array.
+      mainPixels = bitmapProvider.obtainByteArray(npix);
+    }
+    if (prefix == null) {
+      prefix = new short[MAX_STACK_SIZE];
+    }
+    if (suffix == null) {
+      suffix = new byte[MAX_STACK_SIZE];
+    }
+    if (pixelStack == null) {
+      pixelStack = new byte[MAX_STACK_SIZE + 1];
+    }
+
+    // Initialize GIF data stream decoder.
+    dataSize = readByte();
+    clear = 1 << dataSize;
+    endOfInformation = clear + 1;
+    available = clear + 2;
+    oldCode = NULL_CODE;
+    codeSize = dataSize + 1;
+    codeMask = (1 << codeSize) - 1;
+    for (code = 0; code < clear; code++) {
+      // XXX ArrayIndexOutOfBoundsException.
+      prefix[code] = 0;
+      suffix[code] = (byte) code;
+    }
+
+    // Decode GIF pixel stream.
+    datum = bits = count = first = top = pi = bi = 0;
+    for (i = 0; i < npix; ) {
+      // Load bytes until there are enough bits for a code.
+      if (count == 0) {
+        // Read a new data block.
+        count = readBlock();
+        if (count <= 0) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
+        }
+        bi = 0;
+      }
+
+      datum += (((int) block[bi]) & 0xff) << bits;
+      bits += 8;
+      bi++;
+      count--;
+
+      while (bits >= codeSize) {
+        // Get the next code.
+        code = datum & codeMask;
+        datum >>= codeSize;
+        bits -= codeSize;
+
+        // Interpret the code.
+        if (code == clear) {
+          // Reset decoder.
+          codeSize = dataSize + 1;
+          codeMask = (1 << codeSize) - 1;
+          available = clear + 2;
+          oldCode = NULL_CODE;
+          continue;
+        }
+
+        if (code > available) {
+          status = STATUS_PARTIAL_DECODE;
+          break;
+        }
+
+        if (code == endOfInformation) {
+          break;
+        }
+
+        if (oldCode == NULL_CODE) {
+          pixelStack[top++] = suffix[code];
+          oldCode = code;
+          first = code;
+          continue;
+        }
+        inCode = code;
+        if (code >= available) {
+          pixelStack[top++] = (byte) first;
+          code = oldCode;
+        }
+        while (code >= clear) {
+          pixelStack[top++] = suffix[code];
+          code = prefix[code];
+        }
+        first = ((int) suffix[code]) & 0xff;
+        pixelStack[top++] = (byte) first;
+
+        // Add a new string to the string table.
+        if (available < MAX_STACK_SIZE) {
+          prefix[available] = (short) oldCode;
+          suffix[available] = (byte) first;
+          available++;
+          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
+            codeSize++;
+            codeMask += available;
+          }
+        }
+        oldCode = inCode;
+
+        while (top > 0) {
+          // Pop a pixel off the pixel stack.
+          mainPixels[pi++] = pixelStack[--top];
+          i++;
+        }
+      }
+    }
+
+    // Clear missing pixels.
+    for (i = pi; i < npix; i++) {
+      mainPixels[i] = 0;
+    }
+  }
+
+  /**
+   * Reads the next chunk for the intermediate work buffer.
+   */
+  private void readChunkIfNeeded() {
+    if (workBufferSize > workBufferPosition) {
+      return;
+    }
+    if (workBuffer == null) {
+      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);
+    }
+    workBufferPosition = 0;
+    workBufferSize = Math.min(rawData.remaining(), WORK_BUFFER_SIZE);
+    rawData.get(workBuffer, 0, workBufferSize);
+  }
+
+  /**
+   * Reads a single byte from the input stream.
+   */
+  private int readByte() {
+    try {
+      readChunkIfNeeded();
+      return workBuffer[workBufferPosition++] & 0xFF;
+    } catch (Exception e) {
+      status = STATUS_FORMAT_ERROR;
+      return 0;
+    }
+  }
+
+  /**
+   * Reads next variable length block from input.
+   *
+   * @return number of bytes stored in "buffer".
+   */
+  private int readBlock() {
+    int blockSize = readByte();
+    if (blockSize > 0) {
+      try {
+        if (block == null) {
+          block = bitmapProvider.obtainByteArray(255);
+        }
+        final int remaining = workBufferSize - workBufferPosition;
+        if (remaining >= blockSize) {
+          // Block can be read from the current work buffer.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, blockSize);
+          workBufferPosition += blockSize;
+        } else if (rawData.remaining() + remaining >= blockSize) {
+          // Block can be read in two passes.
+          System.arraycopy(workBuffer, workBufferPosition, block, 0, remaining);
+          workBufferPosition = workBufferSize;
+          readChunkIfNeeded();
+          final int secondHalfRemaining = blockSize - remaining;
+          System.arraycopy(workBuffer, 0, block, remaining, secondHalfRemaining);
+          workBufferPosition += secondHalfRemaining;
+        } else {
+          status = STATUS_FORMAT_ERROR;
+        }
+      } catch (Exception e) {
+        Log.w(TAG, "Error Reading Block", e);
+        status = STATUS_FORMAT_ERROR;
+      }
+    }
+    return blockSize;
+  }
+
+  private Bitmap getNextBitmap() {
+    Bitmap.Config config = isFirstFrameTransparent
+        ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
+    Bitmap result = bitmapProvider.obtain(downsampledWidth, downsampledHeight, config);
+    setAlpha(result);
+    return result;
+  }
+
+  @TargetApi(12)
+  private static void setAlpha(Bitmap bitmap) {
+    if (Build.VERSION.SDK_INT >= 12) {
+      bitmap.setHasAlpha(true);
+    }
+  }
+}
diff --git a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
index 9b1b600b0..82b0c7d43 100644
--- a/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
+++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java
@@ -43,7 +43,7 @@ public void testCanDecodeFramesFromTestGif() throws IOException {
     GifHeaderParser headerParser = new GifHeaderParser();
     headerParser.setData(data);
     GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(header, data);
     decoder.advance();
     Bitmap bitmap = decoder.getNextFrame();
@@ -56,7 +56,7 @@ public void testFrameIndexStartsAtNegativeOne() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     assertEquals(-1, decoder.getCurrentFrameIndex());
   }
@@ -66,7 +66,7 @@ public void testAdvanceIncrementsFrameIndex() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     assertEquals(0, decoder.getCurrentFrameIndex());
@@ -77,7 +77,7 @@ public void testAdvanceWrapsIndexBackToZero() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 2;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -90,7 +90,7 @@ public void testSettingDataResetsFramePointer() {
     GifHeader gifheader = new GifHeader();
     gifheader.frameCount = 4;
     byte[] data = new byte[0];
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(gifheader, data);
     decoder.advance();
     decoder.advance();
@@ -108,7 +108,7 @@ public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalBackgroun
     GifHeaderParser headerParser = new GifHeaderParser();
     headerParser.setData(data);
     GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(header, data);
     decoder.advance();
     Bitmap firstFrame = decoder.getNextFrame();
@@ -127,7 +127,7 @@ public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalNone() th
     GifHeaderParser headerParser = new GifHeaderParser();
     headerParser.setData(data);
     GifHeader header = headerParser.parseHeader();
-    GifDecoder decoder = new GifDecoder(provider);
+    GifDecoder decoder = new StandardGifDecoder(provider);
     decoder.setData(header, data);
     decoder.advance();
     Bitmap firstFrame = decoder.getNextFrame();
