diff --git a/library/src/main/java/com/bumptech/glide/load/DataSource.java b/library/src/main/java/com/bumptech/glide/load/DataSource.java
index 699a13bfe..20d286d58 100644
--- a/library/src/main/java/com/bumptech/glide/load/DataSource.java
+++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java
@@ -23,6 +23,7 @@
   RESOURCE_DISK_CACHE,
   /**
    * Indicates data was retrieved from the in memory cache.
+   * 程序运行时的内存缓存
    */
   MEMORY_CACHE,
 }
diff --git a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
index d9cbc2879..93553cfa9 100644
--- a/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java
@@ -42,6 +42,11 @@
     this.options = Preconditions.checkNotNull(options);
   }
 
+  /**
+   * 整个处理流程是：
+   * 1、判断两个对象的 hashcode 是否相等，若不等，则认为两个对象不等，完毕，若相等，则比较 equals。
+   * 2、若两个对象的 equals 不等，则可以认为两个对象不等，否则认为他们相等
+   */
   @Override
   public boolean equals(Object o) {
     if (o instanceof EngineKey) {
@@ -58,6 +63,21 @@ public boolean equals(Object o) {
     return false;
   }
 
+  /**
+   * 原因一：更少的乘积结果冲突
+   * 31是质子数中一个“不大不小”的存在，如果你使用的是一个如2的较小质数，那么得出的乘积会在一个很小的范围，
+   * 很容易造成哈希值的冲突。而如果选择一个100以上的质数，得出的哈希值会超出int的最大范围，这两种都不合适。
+   * 而如果对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，
+   * 并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个（国外大神做的测试），
+   * 那么这几个数就被作为生成hashCode值得备选乘数了。
+   *
+   * 原因二：31可以被JVM优化
+   * JVM里最有效的计算方式就是进行位运算了：
+   * 左移 << : 左边的最高位丢弃，右边补全0（把 << 左边的数据*2的移动次幂）。
+   * 右移 >> : 把>>左边的数据/2的移动次幂。
+   * 无符号右移 >>> : 无论最高位是0还是1，左边补齐0。 　　
+   * 所以 ： 31 * i = (i << 5) - i（左边  31*2=62,右边   2*2^5-2=62） - 两边相等，JVM就可以高效的进行计算啦
+   */
   @Override
   public int hashCode() {
     if (hashCode == 0) {
diff --git a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
index e47c22e54..8071dca1c 100644
--- a/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java
@@ -570,7 +570,8 @@ public void onResourceReady(Resource<?> resource, DataSource dataSource) {
    *
    * @param resource original {@link Resource}, never <code>null</code>
    * @param result   object returned by {@link Resource#get()}, checked for type and never
-   *                 <code>null</code>
+   *                 <code>null</code>  缓存
+   * @param dataSource 缓存类型
    */
   private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
     // We must call isFirstReadyResource before setting status.
@@ -590,8 +591,12 @@ private void onResourceReady(Resource<R> resource, R result, DataSource dataSour
           || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource))
           && (targetListener == null
           || !targetListener.onResourceReady(result, model, target, dataSource, isFirstResource))) {
-        Transition<? super R> animation =
-            animationFactory.build(dataSource, isFirstResource);
+        // 根据数据来源，加载不同的动画效果
+        Transition<? super R> animation = animationFactory.build(dataSource, isFirstResource);
+        /**
+         * targer 是 DrawableImageViewTarget,
+         * 故调用的是 {@link com.bumptech.glide.request.target.ImageViewTarget#onResourceReady(Object, Transition)}
+         */
         target.onResourceReady(result, animation);
       }
     } finally {
diff --git a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
index 0a8da3056..8c189dfbc 100644
--- a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
+++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java
@@ -27,6 +27,7 @@ protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {
 
   @Override
   public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {
+    // 根据来源加载动画
     return dataSource == DataSource.MEMORY_CACHE
         ? NoTransition.<Drawable>get() : getResourceTransition();
   }
